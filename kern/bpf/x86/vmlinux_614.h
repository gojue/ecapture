#ifndef __VMLINUX_H__
#define __VMLINUX_H__

#ifndef BPF_NO_PRESERVE_ACCESS_INDEX
#pragma clang attribute push (__attribute__((preserve_access_index)), apply_to = record)
#endif

#ifndef __ksym
#define __ksym __attribute__((section(".ksyms")))
#endif

#ifndef __weak
#define __weak __attribute__((weak))
#endif

#ifndef __bpf_fastcall
#if __has_attribute(bpf_fastcall)
#define __bpf_fastcall __attribute__((bpf_fastcall))
#else
#define __bpf_fastcall
#endif
#endif

enum {
	ACPI_BUTTON_LID_INIT_IGNORE = 0,
	ACPI_BUTTON_LID_INIT_OPEN = 1,
	ACPI_BUTTON_LID_INIT_METHOD = 2,
	ACPI_BUTTON_LID_INIT_DISABLED = 3,
};

enum {
	ACPI_GENL_ATTR_UNSPEC = 0,
	ACPI_GENL_ATTR_EVENT = 1,
	__ACPI_GENL_ATTR_MAX = 2,
};

enum {
	ACPI_GENL_CMD_UNSPEC = 0,
	ACPI_GENL_CMD_EVENT = 1,
	__ACPI_GENL_CMD_MAX = 2,
};

enum {
	ACPI_REFCLASS_LOCAL = 0,
	ACPI_REFCLASS_ARG = 1,
	ACPI_REFCLASS_REFOF = 2,
	ACPI_REFCLASS_INDEX = 3,
	ACPI_REFCLASS_TABLE = 4,
	ACPI_REFCLASS_NAME = 5,
	ACPI_REFCLASS_DEBUG = 6,
	ACPI_REFCLASS_MAX = 6,
};

enum {
	ACPI_RSC_INITGET = 0,
	ACPI_RSC_INITSET = 1,
	ACPI_RSC_FLAGINIT = 2,
	ACPI_RSC_1BITFLAG = 3,
	ACPI_RSC_2BITFLAG = 4,
	ACPI_RSC_3BITFLAG = 5,
	ACPI_RSC_6BITFLAG = 6,
	ACPI_RSC_ADDRESS = 7,
	ACPI_RSC_BITMASK = 8,
	ACPI_RSC_BITMASK16 = 9,
	ACPI_RSC_COUNT = 10,
	ACPI_RSC_COUNT16 = 11,
	ACPI_RSC_COUNT_GPIO_PIN = 12,
	ACPI_RSC_COUNT_GPIO_RES = 13,
	ACPI_RSC_COUNT_GPIO_VEN = 14,
	ACPI_RSC_COUNT_SERIAL_RES = 15,
	ACPI_RSC_COUNT_SERIAL_VEN = 16,
	ACPI_RSC_DATA8 = 17,
	ACPI_RSC_EXIT_EQ = 18,
	ACPI_RSC_EXIT_LE = 19,
	ACPI_RSC_EXIT_NE = 20,
	ACPI_RSC_LENGTH = 21,
	ACPI_RSC_MOVE_GPIO_PIN = 22,
	ACPI_RSC_MOVE_GPIO_RES = 23,
	ACPI_RSC_MOVE_SERIAL_RES = 24,
	ACPI_RSC_MOVE_SERIAL_VEN = 25,
	ACPI_RSC_MOVE8 = 26,
	ACPI_RSC_MOVE16 = 27,
	ACPI_RSC_MOVE32 = 28,
	ACPI_RSC_MOVE64 = 29,
	ACPI_RSC_SET8 = 30,
	ACPI_RSC_SOURCE = 31,
	ACPI_RSC_SOURCEX = 32,
};

enum {
	ACTION_FAIL = 0,
	ACTION_REPREP = 1,
	ACTION_DELAYED_REPREP = 2,
	ACTION_RETRY = 3,
	ACTION_DELAYED_RETRY = 4,
};

enum {
	AC_GRP_AUDIO_FUNCTION = 1,
	AC_GRP_MODEM_FUNCTION = 2,
};

enum {
	AC_JACK_LINE_OUT = 0,
	AC_JACK_SPEAKER = 1,
	AC_JACK_HP_OUT = 2,
	AC_JACK_CD = 3,
	AC_JACK_SPDIF_OUT = 4,
	AC_JACK_DIG_OTHER_OUT = 5,
	AC_JACK_MODEM_LINE_SIDE = 6,
	AC_JACK_MODEM_HAND_SIDE = 7,
	AC_JACK_LINE_IN = 8,
	AC_JACK_AUX = 9,
	AC_JACK_MIC_IN = 10,
	AC_JACK_TELEPHONY = 11,
	AC_JACK_SPDIF_IN = 12,
	AC_JACK_DIG_OTHER_IN = 13,
	AC_JACK_OTHER = 15,
};

enum {
	AC_JACK_LOC_EXTERNAL = 0,
	AC_JACK_LOC_INTERNAL = 16,
	AC_JACK_LOC_SEPARATE = 32,
	AC_JACK_LOC_OTHER = 48,
};

enum {
	AC_JACK_LOC_NONE = 0,
	AC_JACK_LOC_REAR = 1,
	AC_JACK_LOC_FRONT = 2,
	AC_JACK_LOC_LEFT = 3,
	AC_JACK_LOC_RIGHT = 4,
	AC_JACK_LOC_TOP = 5,
	AC_JACK_LOC_BOTTOM = 6,
};

enum {
	AC_JACK_LOC_REAR_PANEL = 7,
	AC_JACK_LOC_DRIVE_BAY = 8,
	AC_JACK_LOC_RISER = 23,
	AC_JACK_LOC_HDMI = 24,
	AC_JACK_LOC_ATAPI = 25,
	AC_JACK_LOC_MOBILE_IN = 55,
	AC_JACK_LOC_MOBILE_OUT = 56,
};

enum {
	AC_JACK_PORT_COMPLEX = 0,
	AC_JACK_PORT_NONE = 1,
	AC_JACK_PORT_FIXED = 2,
	AC_JACK_PORT_BOTH = 3,
};

enum {
	AC_WID_AUD_OUT = 0,
	AC_WID_AUD_IN = 1,
	AC_WID_AUD_MIX = 2,
	AC_WID_AUD_SEL = 3,
	AC_WID_PIN = 4,
	AC_WID_POWER = 5,
	AC_WID_VOL_KNB = 6,
	AC_WID_BEEP = 7,
	AC_WID_VENDOR = 15,
};

enum {
	AFFINITY = 0,
	AFFINITY_LIST = 1,
	EFFECTIVE = 2,
	EFFECTIVE_LIST = 3,
};

enum {
	AHCI_MAX_PORTS = 32,
	AHCI_MAX_SG = 168,
	AHCI_DMA_BOUNDARY = 4294967295,
	AHCI_MAX_CMDS = 32,
	AHCI_CMD_SZ = 32,
	AHCI_CMD_SLOT_SZ = 1024,
	AHCI_RX_FIS_SZ = 256,
	AHCI_CMD_TBL_CDB = 64,
	AHCI_CMD_TBL_HDR_SZ = 128,
	AHCI_CMD_TBL_SZ = 2816,
	AHCI_CMD_TBL_AR_SZ = 90112,
	AHCI_PORT_PRIV_DMA_SZ = 91392,
	AHCI_PORT_PRIV_FBS_DMA_SZ = 95232,
	AHCI_IRQ_ON_SG = 2147483648,
	AHCI_CMD_ATAPI = 32,
	AHCI_CMD_WRITE = 64,
	AHCI_CMD_PREFETCH = 128,
	AHCI_CMD_RESET = 256,
	AHCI_CMD_CLR_BUSY = 1024,
	RX_FIS_PIO_SETUP = 32,
	RX_FIS_D2H_REG = 64,
	RX_FIS_SDB = 88,
	RX_FIS_UNK = 96,
	HOST_CAP = 0,
	HOST_CTL = 4,
	HOST_IRQ_STAT = 8,
	HOST_PORTS_IMPL = 12,
	HOST_VERSION = 16,
	HOST_EM_LOC = 28,
	HOST_EM_CTL = 32,
	HOST_CAP2 = 36,
	HOST_RESET = 1,
	HOST_IRQ_EN = 2,
	HOST_MRSM = 4,
	HOST_AHCI_EN = 2147483648,
	HOST_CAP_SXS = 32,
	HOST_CAP_EMS = 64,
	HOST_CAP_CCC = 128,
	HOST_CAP_PART = 8192,
	HOST_CAP_SSC = 16384,
	HOST_CAP_PIO_MULTI = 32768,
	HOST_CAP_FBS = 65536,
	HOST_CAP_PMP = 131072,
	HOST_CAP_ONLY = 262144,
	HOST_CAP_CLO = 16777216,
	HOST_CAP_LED = 33554432,
	HOST_CAP_ALPM = 67108864,
	HOST_CAP_SSS = 134217728,
	HOST_CAP_MPS = 268435456,
	HOST_CAP_SNTF = 536870912,
	HOST_CAP_NCQ = 1073741824,
	HOST_CAP_64 = 2147483648,
	HOST_CAP2_BOH = 1,
	HOST_CAP2_NVMHCI = 2,
	HOST_CAP2_APST = 4,
	HOST_CAP2_SDS = 8,
	HOST_CAP2_SADM = 16,
	HOST_CAP2_DESO = 32,
	PORT_LST_ADDR = 0,
	PORT_LST_ADDR_HI = 4,
	PORT_FIS_ADDR = 8,
	PORT_FIS_ADDR_HI = 12,
	PORT_IRQ_STAT = 16,
	PORT_IRQ_MASK = 20,
	PORT_CMD = 24,
	PORT_TFDATA = 32,
	PORT_SIG = 36,
	PORT_CMD_ISSUE = 56,
	PORT_SCR_STAT = 40,
	PORT_SCR_CTL = 44,
	PORT_SCR_ERR = 48,
	PORT_SCR_ACT = 52,
	PORT_SCR_NTF = 60,
	PORT_FBS = 64,
	PORT_DEVSLP = 68,
	PORT_IRQ_COLD_PRES = 2147483648,
	PORT_IRQ_TF_ERR = 1073741824,
	PORT_IRQ_HBUS_ERR = 536870912,
	PORT_IRQ_HBUS_DATA_ERR = 268435456,
	PORT_IRQ_IF_ERR = 134217728,
	PORT_IRQ_IF_NONFATAL = 67108864,
	PORT_IRQ_OVERFLOW = 16777216,
	PORT_IRQ_BAD_PMP = 8388608,
	PORT_IRQ_PHYRDY = 4194304,
	PORT_IRQ_DMPS = 128,
	PORT_IRQ_CONNECT = 64,
	PORT_IRQ_SG_DONE = 32,
	PORT_IRQ_UNK_FIS = 16,
	PORT_IRQ_SDB_FIS = 8,
	PORT_IRQ_DMAS_FIS = 4,
	PORT_IRQ_PIOS_FIS = 2,
	PORT_IRQ_D2H_REG_FIS = 1,
	PORT_IRQ_FREEZE = 683671632,
	PORT_IRQ_ERROR = 2025848912,
	DEF_PORT_IRQ = 2025848959,
	PORT_CMD_ASP = 134217728,
	PORT_CMD_ALPE = 67108864,
	PORT_CMD_ATAPI = 16777216,
	PORT_CMD_FBSCP = 4194304,
	PORT_CMD_ESP = 2097152,
	PORT_CMD_CPD = 1048576,
	PORT_CMD_MPSP = 524288,
	PORT_CMD_HPCP = 262144,
	PORT_CMD_PMP = 131072,
	PORT_CMD_LIST_ON = 32768,
	PORT_CMD_FIS_ON = 16384,
	PORT_CMD_FIS_RX = 16,
	PORT_CMD_CLO = 8,
	PORT_CMD_POWER_ON = 4,
	PORT_CMD_SPIN_UP = 2,
	PORT_CMD_START = 1,
	PORT_CMD_ICC_MASK = 4026531840,
	PORT_CMD_ICC_ACTIVE = 268435456,
	PORT_CMD_ICC_PARTIAL = 536870912,
	PORT_CMD_ICC_SLUMBER = 1610612736,
	PORT_CMD_CAP = 8126464,
	PORT_FBS_DWE_OFFSET = 16,
	PORT_FBS_ADO_OFFSET = 12,
	PORT_FBS_DEV_OFFSET = 8,
	PORT_FBS_DEV_MASK = 3840,
	PORT_FBS_SDE = 4,
	PORT_FBS_DEC = 2,
	PORT_FBS_EN = 1,
	PORT_DEVSLP_DM_OFFSET = 25,
	PORT_DEVSLP_DM_MASK = 503316480,
	PORT_DEVSLP_DITO_OFFSET = 15,
	PORT_DEVSLP_MDAT_OFFSET = 10,
	PORT_DEVSLP_DETO_OFFSET = 2,
	PORT_DEVSLP_DSP = 2,
	PORT_DEVSLP_ADSE = 1,
	AHCI_HFLAG_NO_NCQ = 1,
	AHCI_HFLAG_IGN_IRQ_IF_ERR = 2,
	AHCI_HFLAG_IGN_SERR_INTERNAL = 4,
	AHCI_HFLAG_32BIT_ONLY = 8,
	AHCI_HFLAG_MV_PATA = 16,
	AHCI_HFLAG_NO_MSI = 32,
	AHCI_HFLAG_NO_PMP = 64,
	AHCI_HFLAG_SECT255 = 256,
	AHCI_HFLAG_YES_NCQ = 512,
	AHCI_HFLAG_NO_SUSPEND = 1024,
	AHCI_HFLAG_SRST_TOUT_IS_OFFLINE = 2048,
	AHCI_HFLAG_NO_SNTF = 4096,
	AHCI_HFLAG_NO_FPDMA_AA = 8192,
	AHCI_HFLAG_YES_FBS = 16384,
	AHCI_HFLAG_DELAY_ENGINE = 32768,
	AHCI_HFLAG_NO_DEVSLP = 131072,
	AHCI_HFLAG_NO_FBS = 262144,
	AHCI_HFLAG_MULTI_MSI = 1048576,
	AHCI_HFLAG_WAKE_BEFORE_STOP = 4194304,
	AHCI_HFLAG_YES_ALPM = 8388608,
	AHCI_HFLAG_NO_WRITE_TO_RO = 16777216,
	AHCI_HFLAG_SUSPEND_PHYS = 33554432,
	AHCI_HFLAG_NO_SXS = 67108864,
	AHCI_HFLAG_43BIT_ONLY = 134217728,
	AHCI_HFLAG_INTEL_PCS_QUIRK = 268435456,
	AHCI_FLAG_COMMON = 393346,
	ICH_MAP = 144,
	PCS_6 = 146,
	PCS_7 = 148,
	EM_MAX_SLOTS = 15,
	EM_MAX_RETRY = 5,
	EM_CTL_RST = 512,
	EM_CTL_TM = 256,
	EM_CTL_MR = 1,
	EM_CTL_ALHD = 67108864,
	EM_CTL_XMT = 33554432,
	EM_CTL_SMB = 16777216,
	EM_CTL_SGPIO = 524288,
	EM_CTL_SES = 262144,
	EM_CTL_SAFTE = 131072,
	EM_CTL_LED = 65536,
	EM_MSG_TYPE_LED = 1,
	EM_MSG_TYPE_SAFTE = 2,
	EM_MSG_TYPE_SES2 = 4,
	EM_MSG_TYPE_SGPIO = 8,
};

enum {
	AHCI_PCI_BAR_STA2X11 = 0,
	AHCI_PCI_BAR_CAVIUM = 0,
	AHCI_PCI_BAR_LOONGSON = 0,
	AHCI_PCI_BAR_ENMOTUS = 2,
	AHCI_PCI_BAR_CAVIUM_GEN5 = 4,
	AHCI_PCI_BAR_STANDARD = 5,
};

enum {
	AML_FIELD_ACCESS_ANY = 0,
	AML_FIELD_ACCESS_BYTE = 1,
	AML_FIELD_ACCESS_WORD = 2,
	AML_FIELD_ACCESS_DWORD = 3,
	AML_FIELD_ACCESS_QWORD = 4,
	AML_FIELD_ACCESS_BUFFER = 5,
};

enum {
	AML_FIELD_ATTRIB_QUICK = 2,
	AML_FIELD_ATTRIB_SEND_RECEIVE = 4,
	AML_FIELD_ATTRIB_BYTE = 6,
	AML_FIELD_ATTRIB_WORD = 8,
	AML_FIELD_ATTRIB_BLOCK = 10,
	AML_FIELD_ATTRIB_BYTES = 11,
	AML_FIELD_ATTRIB_PROCESS_CALL = 12,
	AML_FIELD_ATTRIB_BLOCK_PROCESS_CALL = 13,
	AML_FIELD_ATTRIB_RAW_BYTES = 14,
	AML_FIELD_ATTRIB_RAW_PROCESS_BYTES = 15,
};

enum {
	AML_FIELD_UPDATE_PRESERVE = 0,
	AML_FIELD_UPDATE_WRITE_AS_ONES = 32,
	AML_FIELD_UPDATE_WRITE_AS_ZEROS = 64,
};

enum {
	ARCH_LBR_BR_TYPE_JCC = 0,
	ARCH_LBR_BR_TYPE_NEAR_IND_JMP = 1,
	ARCH_LBR_BR_TYPE_NEAR_REL_JMP = 2,
	ARCH_LBR_BR_TYPE_NEAR_IND_CALL = 3,
	ARCH_LBR_BR_TYPE_NEAR_REL_CALL = 4,
	ARCH_LBR_BR_TYPE_NEAR_RET = 5,
	ARCH_LBR_BR_TYPE_KNOWN_MAX = 5,
	ARCH_LBR_BR_TYPE_MAP_MAX = 16,
};

enum {
	ASCII_NULL = 0,
	ASCII_BELL = 7,
	ASCII_BACKSPACE = 8,
	ASCII_IGNORE_FIRST = 8,
	ASCII_HTAB = 9,
	ASCII_LINEFEED = 10,
	ASCII_VTAB = 11,
	ASCII_FORMFEED = 12,
	ASCII_CAR_RET = 13,
	ASCII_IGNORE_LAST = 13,
	ASCII_SHIFTOUT = 14,
	ASCII_SHIFTIN = 15,
	ASCII_CANCEL = 24,
	ASCII_SUBSTITUTE = 26,
	ASCII_ESCAPE = 27,
	ASCII_CSI_IGNORE_FIRST = 32,
	ASCII_CSI_IGNORE_LAST = 63,
	ASCII_DEL = 127,
	ASCII_EXT_CSI = 155,
};

enum {
	ATA_EH_SPDN_NCQ_OFF = 1,
	ATA_EH_SPDN_SPEED_DOWN = 2,
	ATA_EH_SPDN_FALLBACK_TO_PIO = 4,
	ATA_EH_SPDN_KEEP_ERRORS = 8,
	ATA_EFLAG_IS_IO = 1,
	ATA_EFLAG_DUBIOUS_XFER = 2,
	ATA_EFLAG_OLD_ER = -2147483648,
	ATA_ECAT_NONE = 0,
	ATA_ECAT_ATA_BUS = 1,
	ATA_ECAT_TOUT_HSM = 2,
	ATA_ECAT_UNK_DEV = 3,
	ATA_ECAT_DUBIOUS_NONE = 4,
	ATA_ECAT_DUBIOUS_ATA_BUS = 5,
	ATA_ECAT_DUBIOUS_TOUT_HSM = 6,
	ATA_ECAT_DUBIOUS_UNK_DEV = 7,
	ATA_ECAT_NR = 8,
	ATA_EH_CMD_DFL_TIMEOUT = 5000,
	ATA_EH_RESET_COOL_DOWN = 5000,
	ATA_EH_PRERESET_TIMEOUT = 10000,
	ATA_EH_FASTDRAIN_INTERVAL = 3000,
	ATA_EH_UA_TRIES = 5,
	ATA_EH_PROBE_TRIAL_INTERVAL = 60000,
	ATA_EH_PROBE_TRIALS = 2,
};

enum {
	ATA_MAX_DEVICES = 2,
	ATA_MAX_PRD = 256,
	ATA_SECT_SIZE = 512,
	ATA_MAX_SECTORS_128 = 128,
	ATA_MAX_SECTORS = 256,
	ATA_MAX_SECTORS_1024 = 1024,
	ATA_MAX_SECTORS_LBA48 = 65535,
	ATA_MAX_SECTORS_TAPE = 65535,
	ATA_MAX_TRIM_RNUM = 64,
	ATA_ID_WORDS = 256,
	ATA_ID_CONFIG = 0,
	ATA_ID_CYLS = 1,
	ATA_ID_HEADS = 3,
	ATA_ID_SECTORS = 6,
	ATA_ID_SERNO = 10,
	ATA_ID_BUF_SIZE = 21,
	ATA_ID_FW_REV = 23,
	ATA_ID_PROD = 27,
	ATA_ID_MAX_MULTSECT = 47,
	ATA_ID_DWORD_IO = 48,
	ATA_ID_TRUSTED = 48,
	ATA_ID_CAPABILITY = 49,
	ATA_ID_OLD_PIO_MODES = 51,
	ATA_ID_OLD_DMA_MODES = 52,
	ATA_ID_FIELD_VALID = 53,
	ATA_ID_CUR_CYLS = 54,
	ATA_ID_CUR_HEADS = 55,
	ATA_ID_CUR_SECTORS = 56,
	ATA_ID_MULTSECT = 59,
	ATA_ID_LBA_CAPACITY = 60,
	ATA_ID_SWDMA_MODES = 62,
	ATA_ID_MWDMA_MODES = 63,
	ATA_ID_PIO_MODES = 64,
	ATA_ID_EIDE_DMA_MIN = 65,
	ATA_ID_EIDE_DMA_TIME = 66,
	ATA_ID_EIDE_PIO = 67,
	ATA_ID_EIDE_PIO_IORDY = 68,
	ATA_ID_ADDITIONAL_SUPP = 69,
	ATA_ID_QUEUE_DEPTH = 75,
	ATA_ID_SATA_CAPABILITY = 76,
	ATA_ID_SATA_CAPABILITY_2 = 77,
	ATA_ID_FEATURE_SUPP = 78,
	ATA_ID_MAJOR_VER = 80,
	ATA_ID_COMMAND_SET_1 = 82,
	ATA_ID_COMMAND_SET_2 = 83,
	ATA_ID_CFSSE = 84,
	ATA_ID_CFS_ENABLE_1 = 85,
	ATA_ID_CFS_ENABLE_2 = 86,
	ATA_ID_CSF_DEFAULT = 87,
	ATA_ID_UDMA_MODES = 88,
	ATA_ID_HW_CONFIG = 93,
	ATA_ID_SPG = 98,
	ATA_ID_LBA_CAPACITY_2 = 100,
	ATA_ID_SECTOR_SIZE = 106,
	ATA_ID_WWN = 108,
	ATA_ID_LOGICAL_SECTOR_SIZE = 117,
	ATA_ID_COMMAND_SET_3 = 119,
	ATA_ID_COMMAND_SET_4 = 120,
	ATA_ID_LAST_LUN = 126,
	ATA_ID_DLF = 128,
	ATA_ID_CSFO = 129,
	ATA_ID_CFA_POWER = 160,
	ATA_ID_CFA_KEY_MGMT = 162,
	ATA_ID_CFA_MODES = 163,
	ATA_ID_DATA_SET_MGMT = 169,
	ATA_ID_SCT_CMD_XPORT = 206,
	ATA_ID_ROT_SPEED = 217,
	ATA_ID_PIO4 = 2,
	ATA_ID_SERNO_LEN = 20,
	ATA_ID_FW_REV_LEN = 8,
	ATA_ID_PROD_LEN = 40,
	ATA_ID_WWN_LEN = 8,
	ATA_PCI_CTL_OFS = 2,
	ATA_PIO0 = 1,
	ATA_PIO1 = 3,
	ATA_PIO2 = 7,
	ATA_PIO3 = 15,
	ATA_PIO4 = 31,
	ATA_PIO5 = 63,
	ATA_PIO6 = 127,
	ATA_PIO4_ONLY = 16,
	ATA_SWDMA0 = 1,
	ATA_SWDMA1 = 3,
	ATA_SWDMA2 = 7,
	ATA_SWDMA2_ONLY = 4,
	ATA_MWDMA0 = 1,
	ATA_MWDMA1 = 3,
	ATA_MWDMA2 = 7,
	ATA_MWDMA3 = 15,
	ATA_MWDMA4 = 31,
	ATA_MWDMA12_ONLY = 6,
	ATA_MWDMA2_ONLY = 4,
	ATA_UDMA0 = 1,
	ATA_UDMA1 = 3,
	ATA_UDMA2 = 7,
	ATA_UDMA3 = 15,
	ATA_UDMA4 = 31,
	ATA_UDMA5 = 63,
	ATA_UDMA6 = 127,
	ATA_UDMA7 = 255,
	ATA_UDMA24_ONLY = 20,
	ATA_UDMA_MASK_40C = 7,
	ATA_PRD_SZ = 8,
	ATA_PRD_TBL_SZ = 2048,
	ATA_PRD_EOT = -2147483648,
	ATA_DMA_TABLE_OFS = 4,
	ATA_DMA_STATUS = 2,
	ATA_DMA_CMD = 0,
	ATA_DMA_WR = 8,
	ATA_DMA_START = 1,
	ATA_DMA_INTR = 4,
	ATA_DMA_ERR = 2,
	ATA_DMA_ACTIVE = 1,
	ATA_HOB = 128,
	ATA_NIEN = 2,
	ATA_LBA = 64,
	ATA_DEV1 = 16,
	ATA_DEVICE_OBS = 160,
	ATA_DEVCTL_OBS = 8,
	ATA_BUSY = 128,
	ATA_DRDY = 64,
	ATA_DF = 32,
	ATA_DSC = 16,
	ATA_DRQ = 8,
	ATA_CORR = 4,
	ATA_SENSE = 2,
	ATA_ERR = 1,
	ATA_SRST = 4,
	ATA_ICRC = 128,
	ATA_BBK = 128,
	ATA_UNC = 64,
	ATA_MC = 32,
	ATA_IDNF = 16,
	ATA_MCR = 8,
	ATA_ABORTED = 4,
	ATA_TRK0NF = 2,
	ATA_AMNF = 1,
	ATAPI_LFS = 240,
	ATAPI_EOM = 2,
	ATAPI_ILI = 1,
	ATAPI_IO = 2,
	ATAPI_COD = 1,
	ATA_REG_DATA = 0,
	ATA_REG_ERR = 1,
	ATA_REG_NSECT = 2,
	ATA_REG_LBAL = 3,
	ATA_REG_LBAM = 4,
	ATA_REG_LBAH = 5,
	ATA_REG_DEVICE = 6,
	ATA_REG_STATUS = 7,
	ATA_REG_FEATURE = 1,
	ATA_REG_CMD = 7,
	ATA_REG_BYTEL = 4,
	ATA_REG_BYTEH = 5,
	ATA_REG_DEVSEL = 6,
	ATA_REG_IRQ = 2,
	ATA_CMD_DEV_RESET = 8,
	ATA_CMD_CHK_POWER = 229,
	ATA_CMD_STANDBY = 226,
	ATA_CMD_IDLE = 227,
	ATA_CMD_EDD = 144,
	ATA_CMD_DOWNLOAD_MICRO = 146,
	ATA_CMD_DOWNLOAD_MICRO_DMA = 147,
	ATA_CMD_NOP = 0,
	ATA_CMD_FLUSH = 231,
	ATA_CMD_FLUSH_EXT = 234,
	ATA_CMD_ID_ATA = 236,
	ATA_CMD_ID_ATAPI = 161,
	ATA_CMD_SERVICE = 162,
	ATA_CMD_READ = 200,
	ATA_CMD_READ_EXT = 37,
	ATA_CMD_READ_QUEUED = 38,
	ATA_CMD_READ_STREAM_EXT = 43,
	ATA_CMD_READ_STREAM_DMA_EXT = 42,
	ATA_CMD_WRITE = 202,
	ATA_CMD_WRITE_EXT = 53,
	ATA_CMD_WRITE_QUEUED = 54,
	ATA_CMD_WRITE_STREAM_EXT = 59,
	ATA_CMD_WRITE_STREAM_DMA_EXT = 58,
	ATA_CMD_WRITE_FUA_EXT = 61,
	ATA_CMD_WRITE_QUEUED_FUA_EXT = 62,
	ATA_CMD_FPDMA_READ = 96,
	ATA_CMD_FPDMA_WRITE = 97,
	ATA_CMD_NCQ_NON_DATA = 99,
	ATA_CMD_FPDMA_SEND = 100,
	ATA_CMD_FPDMA_RECV = 101,
	ATA_CMD_PIO_READ = 32,
	ATA_CMD_PIO_READ_EXT = 36,
	ATA_CMD_PIO_WRITE = 48,
	ATA_CMD_PIO_WRITE_EXT = 52,
	ATA_CMD_READ_MULTI = 196,
	ATA_CMD_READ_MULTI_EXT = 41,
	ATA_CMD_WRITE_MULTI = 197,
	ATA_CMD_WRITE_MULTI_EXT = 57,
	ATA_CMD_WRITE_MULTI_FUA_EXT = 206,
	ATA_CMD_SET_FEATURES = 239,
	ATA_CMD_SET_MULTI = 198,
	ATA_CMD_PACKET = 160,
	ATA_CMD_VERIFY = 64,
	ATA_CMD_VERIFY_EXT = 66,
	ATA_CMD_WRITE_UNCORR_EXT = 69,
	ATA_CMD_STANDBYNOW1 = 224,
	ATA_CMD_IDLEIMMEDIATE = 225,
	ATA_CMD_SLEEP = 230,
	ATA_CMD_INIT_DEV_PARAMS = 145,
	ATA_CMD_READ_NATIVE_MAX = 248,
	ATA_CMD_READ_NATIVE_MAX_EXT = 39,
	ATA_CMD_SET_MAX = 249,
	ATA_CMD_SET_MAX_EXT = 55,
	ATA_CMD_READ_LOG_EXT = 47,
	ATA_CMD_WRITE_LOG_EXT = 63,
	ATA_CMD_READ_LOG_DMA_EXT = 71,
	ATA_CMD_WRITE_LOG_DMA_EXT = 87,
	ATA_CMD_TRUSTED_NONDATA = 91,
	ATA_CMD_TRUSTED_RCV = 92,
	ATA_CMD_TRUSTED_RCV_DMA = 93,
	ATA_CMD_TRUSTED_SND = 94,
	ATA_CMD_TRUSTED_SND_DMA = 95,
	ATA_CMD_PMP_READ = 228,
	ATA_CMD_PMP_READ_DMA = 233,
	ATA_CMD_PMP_WRITE = 232,
	ATA_CMD_PMP_WRITE_DMA = 235,
	ATA_CMD_CONF_OVERLAY = 177,
	ATA_CMD_SEC_SET_PASS = 241,
	ATA_CMD_SEC_UNLOCK = 242,
	ATA_CMD_SEC_ERASE_PREP = 243,
	ATA_CMD_SEC_ERASE_UNIT = 244,
	ATA_CMD_SEC_FREEZE_LOCK = 245,
	ATA_CMD_SEC_DISABLE_PASS = 246,
	ATA_CMD_CONFIG_STREAM = 81,
	ATA_CMD_SMART = 176,
	ATA_CMD_MEDIA_LOCK = 222,
	ATA_CMD_MEDIA_UNLOCK = 223,
	ATA_CMD_DSM = 6,
	ATA_CMD_CHK_MED_CRD_TYP = 209,
	ATA_CMD_CFA_REQ_EXT_ERR = 3,
	ATA_CMD_CFA_WRITE_NE = 56,
	ATA_CMD_CFA_TRANS_SECT = 135,
	ATA_CMD_CFA_ERASE = 192,
	ATA_CMD_CFA_WRITE_MULT_NE = 205,
	ATA_CMD_REQ_SENSE_DATA = 11,
	ATA_CMD_SANITIZE_DEVICE = 180,
	ATA_CMD_ZAC_MGMT_IN = 74,
	ATA_CMD_ZAC_MGMT_OUT = 159,
	ATA_CMD_RESTORE = 16,
	ATA_SUBCMD_FPDMA_RECV_RD_LOG_DMA_EXT = 1,
	ATA_SUBCMD_FPDMA_RECV_ZAC_MGMT_IN = 2,
	ATA_SUBCMD_FPDMA_SEND_DSM = 0,
	ATA_SUBCMD_FPDMA_SEND_WR_LOG_DMA_EXT = 2,
	ATA_SUBCMD_NCQ_NON_DATA_ABORT_QUEUE = 0,
	ATA_SUBCMD_NCQ_NON_DATA_SET_FEATURES = 5,
	ATA_SUBCMD_NCQ_NON_DATA_ZERO_EXT = 6,
	ATA_SUBCMD_NCQ_NON_DATA_ZAC_MGMT_OUT = 7,
	ATA_SUBCMD_ZAC_MGMT_IN_REPORT_ZONES = 0,
	ATA_SUBCMD_ZAC_MGMT_OUT_CLOSE_ZONE = 1,
	ATA_SUBCMD_ZAC_MGMT_OUT_FINISH_ZONE = 2,
	ATA_SUBCMD_ZAC_MGMT_OUT_OPEN_ZONE = 3,
	ATA_SUBCMD_ZAC_MGMT_OUT_RESET_WRITE_POINTER = 4,
	ATA_LOG_DIRECTORY = 0,
	ATA_LOG_SATA_NCQ = 16,
	ATA_LOG_NCQ_NON_DATA = 18,
	ATA_LOG_NCQ_SEND_RECV = 19,
	ATA_LOG_CDL = 24,
	ATA_LOG_CDL_SIZE = 512,
	ATA_LOG_IDENTIFY_DEVICE = 48,
	ATA_LOG_SENSE_NCQ = 15,
	ATA_LOG_SENSE_NCQ_SIZE = 1024,
	ATA_LOG_CONCURRENT_POSITIONING_RANGES = 71,
	ATA_LOG_SUPPORTED_CAPABILITIES = 3,
	ATA_LOG_CURRENT_SETTINGS = 4,
	ATA_LOG_SECURITY = 6,
	ATA_LOG_SATA_SETTINGS = 8,
	ATA_LOG_ZONED_INFORMATION = 9,
	ATA_LOG_DEVSLP_OFFSET = 48,
	ATA_LOG_DEVSLP_SIZE = 8,
	ATA_LOG_DEVSLP_MDAT = 0,
	ATA_LOG_DEVSLP_MDAT_MASK = 31,
	ATA_LOG_DEVSLP_DETO = 1,
	ATA_LOG_DEVSLP_VALID = 7,
	ATA_LOG_DEVSLP_VALID_MASK = 128,
	ATA_LOG_NCQ_PRIO_OFFSET = 9,
	ATA_LOG_NCQ_SEND_RECV_SUBCMDS_OFFSET = 0,
	ATA_LOG_NCQ_SEND_RECV_SUBCMDS_DSM = 1,
	ATA_LOG_NCQ_SEND_RECV_DSM_OFFSET = 4,
	ATA_LOG_NCQ_SEND_RECV_DSM_TRIM = 1,
	ATA_LOG_NCQ_SEND_RECV_RD_LOG_OFFSET = 8,
	ATA_LOG_NCQ_SEND_RECV_RD_LOG_SUPPORTED = 1,
	ATA_LOG_NCQ_SEND_RECV_WR_LOG_OFFSET = 12,
	ATA_LOG_NCQ_SEND_RECV_WR_LOG_SUPPORTED = 1,
	ATA_LOG_NCQ_SEND_RECV_ZAC_MGMT_OFFSET = 16,
	ATA_LOG_NCQ_SEND_RECV_ZAC_MGMT_OUT_SUPPORTED = 1,
	ATA_LOG_NCQ_SEND_RECV_ZAC_MGMT_IN_SUPPORTED = 2,
	ATA_LOG_NCQ_SEND_RECV_SIZE = 20,
	ATA_LOG_NCQ_NON_DATA_SUBCMDS_OFFSET = 0,
	ATA_LOG_NCQ_NON_DATA_ABORT_OFFSET = 0,
	ATA_LOG_NCQ_NON_DATA_ABORT_NCQ = 1,
	ATA_LOG_NCQ_NON_DATA_ABORT_ALL = 2,
	ATA_LOG_NCQ_NON_DATA_ABORT_STREAMING = 4,
	ATA_LOG_NCQ_NON_DATA_ABORT_NON_STREAMING = 8,
	ATA_LOG_NCQ_NON_DATA_ABORT_SELECTED = 16,
	ATA_LOG_NCQ_NON_DATA_ZAC_MGMT_OFFSET = 28,
	ATA_LOG_NCQ_NON_DATA_ZAC_MGMT_OUT = 1,
	ATA_LOG_NCQ_NON_DATA_SIZE = 64,
	ATA_CMD_READ_LONG = 34,
	ATA_CMD_READ_LONG_ONCE = 35,
	ATA_CMD_WRITE_LONG = 50,
	ATA_CMD_WRITE_LONG_ONCE = 51,
	SETFEATURES_XFER = 3,
	XFER_UDMA_7 = 71,
	XFER_UDMA_6 = 70,
	XFER_UDMA_5 = 69,
	XFER_UDMA_4 = 68,
	XFER_UDMA_3 = 67,
	XFER_UDMA_2 = 66,
	XFER_UDMA_1 = 65,
	XFER_UDMA_0 = 64,
	XFER_MW_DMA_4 = 36,
	XFER_MW_DMA_3 = 35,
	XFER_MW_DMA_2 = 34,
	XFER_MW_DMA_1 = 33,
	XFER_MW_DMA_0 = 32,
	XFER_SW_DMA_2 = 18,
	XFER_SW_DMA_1 = 17,
	XFER_SW_DMA_0 = 16,
	XFER_PIO_6 = 14,
	XFER_PIO_5 = 13,
	XFER_PIO_4 = 12,
	XFER_PIO_3 = 11,
	XFER_PIO_2 = 10,
	XFER_PIO_1 = 9,
	XFER_PIO_0 = 8,
	XFER_PIO_SLOW = 0,
	SETFEATURES_WC_ON = 2,
	SETFEATURES_WC_OFF = 130,
	SETFEATURES_RA_ON = 170,
	SETFEATURES_RA_OFF = 85,
	SETFEATURES_AAM_ON = 66,
	SETFEATURES_AAM_OFF = 194,
	SETFEATURES_SPINUP = 7,
	SETFEATURES_SPINUP_TIMEOUT = 30000,
	SETFEATURES_SATA_ENABLE = 16,
	SETFEATURES_SATA_DISABLE = 144,
	SETFEATURES_CDL = 13,
	SATA_FPDMA_OFFSET = 1,
	SATA_FPDMA_AA = 2,
	SATA_DIPM = 3,
	SATA_FPDMA_IN_ORDER = 4,
	SATA_AN = 5,
	SATA_SSP = 6,
	SATA_DEVSLP = 9,
	SETFEATURE_SENSE_DATA = 195,
	SETFEATURE_SENSE_DATA_SUCC_NCQ = 196,
	ATA_SET_MAX_ADDR = 0,
	ATA_SET_MAX_PASSWD = 1,
	ATA_SET_MAX_LOCK = 2,
	ATA_SET_MAX_UNLOCK = 3,
	ATA_SET_MAX_FREEZE_LOCK = 4,
	ATA_SET_MAX_PASSWD_DMA = 5,
	ATA_SET_MAX_UNLOCK_DMA = 6,
	ATA_DCO_RESTORE = 192,
	ATA_DCO_FREEZE_LOCK = 193,
	ATA_DCO_IDENTIFY = 194,
	ATA_DCO_SET = 195,
	ATA_SMART_ENABLE = 216,
	ATA_SMART_READ_VALUES = 208,
	ATA_SMART_READ_THRESHOLDS = 209,
	ATA_DSM_TRIM = 1,
	ATA_SMART_LBAM_PASS = 79,
	ATA_SMART_LBAH_PASS = 194,
	ATAPI_PKT_DMA = 1,
	ATAPI_DMADIR = 4,
	ATAPI_CDB_LEN = 16,
	SATA_PMP_MAX_PORTS = 15,
	SATA_PMP_CTRL_PORT = 15,
	SATA_PMP_GSCR_DWORDS = 128,
	SATA_PMP_GSCR_PROD_ID = 0,
	SATA_PMP_GSCR_REV = 1,
	SATA_PMP_GSCR_PORT_INFO = 2,
	SATA_PMP_GSCR_ERROR = 32,
	SATA_PMP_GSCR_ERROR_EN = 33,
	SATA_PMP_GSCR_FEAT = 64,
	SATA_PMP_GSCR_FEAT_EN = 96,
	SATA_PMP_PSCR_STATUS = 0,
	SATA_PMP_PSCR_ERROR = 1,
	SATA_PMP_PSCR_CONTROL = 2,
	SATA_PMP_FEAT_BIST = 1,
	SATA_PMP_FEAT_PMREQ = 2,
	SATA_PMP_FEAT_DYNSSC = 4,
	SATA_PMP_FEAT_NOTIFY = 8,
	ATA_CBL_NONE = 0,
	ATA_CBL_PATA40 = 1,
	ATA_CBL_PATA80 = 2,
	ATA_CBL_PATA40_SHORT = 3,
	ATA_CBL_PATA_UNK = 4,
	ATA_CBL_PATA_IGN = 5,
	ATA_CBL_SATA = 6,
	SCR_STATUS = 0,
	SCR_ERROR = 1,
	SCR_CONTROL = 2,
	SCR_ACTIVE = 3,
	SCR_NOTIFICATION = 4,
	SERR_DATA_RECOVERED = 1,
	SERR_COMM_RECOVERED = 2,
	SERR_DATA = 256,
	SERR_PERSISTENT = 512,
	SERR_PROTOCOL = 1024,
	SERR_INTERNAL = 2048,
	SERR_PHYRDY_CHG = 65536,
	SERR_PHY_INT_ERR = 131072,
	SERR_COMM_WAKE = 262144,
	SERR_10B_8B_ERR = 524288,
	SERR_DISPARITY = 1048576,
	SERR_CRC = 2097152,
	SERR_HANDSHAKE = 4194304,
	SERR_LINK_SEQ_ERR = 8388608,
	SERR_TRANS_ST_ERROR = 16777216,
	SERR_UNRECOG_FIS = 33554432,
	SERR_DEV_XCHG = 67108864,
};

enum {
	ATA_READID_POSTRESET = 1,
	ATA_DNXFER_PIO = 0,
	ATA_DNXFER_DMA = 1,
	ATA_DNXFER_40C = 2,
	ATA_DNXFER_FORCE_PIO = 3,
	ATA_DNXFER_FORCE_PIO0 = 4,
	ATA_DNXFER_QUIET = -2147483648,
};

enum {
	AT_PKT_END = -1,
	BEYOND_PKT_END = -2,
};

enum {
	AUTOFS_DEV_IOCTL_VERSION_CMD = 113,
	AUTOFS_DEV_IOCTL_PROTOVER_CMD = 114,
	AUTOFS_DEV_IOCTL_PROTOSUBVER_CMD = 115,
	AUTOFS_DEV_IOCTL_OPENMOUNT_CMD = 116,
	AUTOFS_DEV_IOCTL_CLOSEMOUNT_CMD = 117,
	AUTOFS_DEV_IOCTL_READY_CMD = 118,
	AUTOFS_DEV_IOCTL_FAIL_CMD = 119,
	AUTOFS_DEV_IOCTL_SETPIPEFD_CMD = 120,
	AUTOFS_DEV_IOCTL_CATATONIC_CMD = 121,
	AUTOFS_DEV_IOCTL_TIMEOUT_CMD = 122,
	AUTOFS_DEV_IOCTL_REQUESTER_CMD = 123,
	AUTOFS_DEV_IOCTL_EXPIRE_CMD = 124,
	AUTOFS_DEV_IOCTL_ASKUMOUNT_CMD = 125,
	AUTOFS_DEV_IOCTL_ISMOUNTPOINT_CMD = 126,
};

enum {
	AUTOFS_IOC_EXPIRE_MULTI_CMD = 102,
	AUTOFS_IOC_PROTOSUBVER_CMD = 103,
	AUTOFS_IOC_ASKUMOUNT_CMD = 112,
};

enum {
	AUTOFS_IOC_READY_CMD = 96,
	AUTOFS_IOC_FAIL_CMD = 97,
	AUTOFS_IOC_CATATONIC_CMD = 98,
	AUTOFS_IOC_PROTOVER_CMD = 99,
	AUTOFS_IOC_SETTIMEOUT_CMD = 100,
	AUTOFS_IOC_EXPIRE_CMD = 101,
};

enum {
	AUTOP_INVALID = 0,
	AUTOP_HDD = 1,
	AUTOP_SSD_QD1 = 2,
	AUTOP_SSD_DFL = 3,
	AUTOP_SSD_FAST = 4,
};

enum {
	AUTO_PIN_LINE_OUT = 0,
	AUTO_PIN_SPEAKER_OUT = 1,
	AUTO_PIN_HP_OUT = 2,
};

enum {
	AUTO_PIN_MIC = 0,
	AUTO_PIN_LINE_IN = 1,
	AUTO_PIN_CD = 2,
	AUTO_PIN_AUX = 3,
	AUTO_PIN_LAST = 4,
};

enum {
	AX25_VALUES_IPDEFMODE = 0,
	AX25_VALUES_AXDEFMODE = 1,
	AX25_VALUES_BACKOFF = 2,
	AX25_VALUES_CONMODE = 3,
	AX25_VALUES_WINDOW = 4,
	AX25_VALUES_EWINDOW = 5,
	AX25_VALUES_T1 = 6,
	AX25_VALUES_T2 = 7,
	AX25_VALUES_T3 = 8,
	AX25_VALUES_IDLE = 9,
	AX25_VALUES_N2 = 10,
	AX25_VALUES_PACLEN = 11,
	AX25_VALUES_PROTOCOL = 12,
	AX25_MAX_VALUES = 13,
};

enum {
	AZX_DRIVER_ICH = 0,
	AZX_DRIVER_PCH = 1,
	AZX_DRIVER_SCH = 2,
	AZX_DRIVER_SKL = 3,
	AZX_DRIVER_HDMI = 4,
	AZX_DRIVER_ATI = 5,
	AZX_DRIVER_ATIHDMI = 6,
	AZX_DRIVER_ATIHDMI_NS = 7,
	AZX_DRIVER_GFHDMI = 8,
	AZX_DRIVER_VIA = 9,
	AZX_DRIVER_SIS = 10,
	AZX_DRIVER_ULI = 11,
	AZX_DRIVER_NVIDIA = 12,
	AZX_DRIVER_TERA = 13,
	AZX_DRIVER_CTX = 14,
	AZX_DRIVER_CTHDA = 15,
	AZX_DRIVER_CMEDIA = 16,
	AZX_DRIVER_ZHAOXIN = 17,
	AZX_DRIVER_LOONGSON = 18,
	AZX_DRIVER_GENERIC = 19,
	AZX_NUM_DRIVERS = 20,
};

enum {
	AZX_SNOOP_TYPE_NONE = 0,
	AZX_SNOOP_TYPE_SCH = 1,
	AZX_SNOOP_TYPE_ATI = 2,
	AZX_SNOOP_TYPE_NVIDIA = 3,
};

enum {
	Audit_equal = 0,
	Audit_not_equal = 1,
	Audit_bitmask = 2,
	Audit_bittest = 3,
	Audit_lt = 4,
	Audit_gt = 5,
	Audit_le = 6,
	Audit_ge = 7,
	Audit_bad = 8,
};

enum {
	B28_DPT_INI = 3584,
	B28_DPT_VAL = 3588,
	B28_DPT_CTRL = 3592,
	B28_DPT_TST = 3594,
};

enum {
	B28_Y2_SMB_CONFIG = 3648,
	B28_Y2_SMB_CSD_REG = 3652,
	B28_Y2_ASF_IRQ_V_BASE = 3680,
	B28_Y2_ASF_STAT_CMD = 3688,
	B28_Y2_ASF_HOST_COM = 3692,
	B28_Y2_DATA_REG_1 = 3696,
	B28_Y2_DATA_REG_2 = 3700,
	B28_Y2_DATA_REG_3 = 3704,
	B28_Y2_DATA_REG_4 = 3708,
};

enum {
	B6_EXT_REG = 768,
	B7_CFG_SPC = 896,
	B8_RQ1_REGS = 1024,
	B8_RQ2_REGS = 1152,
	B8_TS1_REGS = 1536,
	B8_TA1_REGS = 1664,
	B8_TS2_REGS = 1792,
	B8_TA2_REGS = 1920,
	B16_RAM_REGS = 2048,
};

enum {
	B8_Q_REGS = 1024,
	Q_D = 0,
	Q_VLAN = 32,
	Q_DONE = 36,
	Q_AC_L = 40,
	Q_AC_H = 44,
	Q_BC = 48,
	Q_CSR = 52,
	Q_TEST = 56,
	Q_WM = 64,
	Q_AL = 66,
	Q_RSP = 68,
	Q_RSL = 70,
	Q_RP = 72,
	Q_RL = 74,
	Q_WP = 76,
	Q_WSP = 77,
	Q_WL = 78,
	Q_WSL = 79,
};

enum {
	BASE_GMAC_1 = 10240,
	BASE_GMAC_2 = 14336,
};

enum {
	BDX_PCI_UNCORE_HA = 0,
	BDX_PCI_UNCORE_IMC = 1,
	BDX_PCI_UNCORE_IRP = 2,
	BDX_PCI_UNCORE_QPI = 3,
	BDX_PCI_UNCORE_R2PCIE = 4,
	BDX_PCI_UNCORE_R3QPI = 5,
};

enum {
	BIAS = 2147483648,
};

enum {
	BIOSET_NEED_BVECS = 1,
	BIOSET_NEED_RESCUER = 2,
	BIOSET_PERCPU_CACHE = 4,
};

enum {
	BIO_PAGE_PINNED = 0,
	BIO_CLONED = 1,
	BIO_BOUNCED = 2,
	BIO_QUIET = 3,
	BIO_CHAIN = 4,
	BIO_REFFED = 5,
	BIO_BPS_THROTTLED = 6,
	BIO_TRACE_COMPLETION = 7,
	BIO_CGROUP_ACCT = 8,
	BIO_QOS_THROTTLED = 9,
	BIO_QOS_MERGED = 10,
	BIO_REMAPPED = 11,
	BIO_ZONE_WRITE_PLUGGING = 12,
	BIO_EMULATES_ZONE_APPEND = 13,
	BIO_FLAG_LAST = 14,
};

enum {
	BLINK_42MS = 0,
	BLINK_84MS = 1,
	BLINK_170MS = 2,
	BLINK_340MS = 3,
	BLINK_670MS = 4,
};

enum {
	BLK_MQ_F_TAG_QUEUE_SHARED = 2,
	BLK_MQ_F_STACKING = 4,
	BLK_MQ_F_TAG_HCTX_SHARED = 8,
	BLK_MQ_F_BLOCKING = 16,
	BLK_MQ_F_TAG_RR = 32,
	BLK_MQ_F_NO_SCHED_BY_DEFAULT = 64,
	BLK_MQ_F_MAX = 128,
};

enum {
	BLK_MQ_NO_TAG = 4294967295,
	BLK_MQ_TAG_MIN = 1,
	BLK_MQ_TAG_MAX = 4294967294,
};

enum {
	BLK_MQ_REQ_NOWAIT = 1,
	BLK_MQ_REQ_RESERVED = 2,
	BLK_MQ_REQ_PM = 4,
};

enum {
	BLK_MQ_S_STOPPED = 0,
	BLK_MQ_S_TAG_ACTIVE = 1,
	BLK_MQ_S_SCHED_RESTART = 2,
	BLK_MQ_S_INACTIVE = 3,
	BLK_MQ_S_MAX = 4,
};

enum {
	BLK_MQ_UNIQUE_TAG_BITS = 16,
	BLK_MQ_UNIQUE_TAG_MASK = 65535,
};

enum {
	BLOCK_BITMAP = 0,
	INODE_BITMAP = 1,
	INODE_TABLE = 2,
	GROUP_TABLE_COUNT = 3,
};

enum {
	BMU_IDLE = -2147483648,
	BMU_RX_TCP_PKT = 1073741824,
	BMU_RX_IP_PKT = 536870912,
	BMU_ENA_RX_RSS_HASH = 32768,
	BMU_DIS_RX_RSS_HASH = 16384,
	BMU_ENA_RX_CHKSUM = 8192,
	BMU_DIS_RX_CHKSUM = 4096,
	BMU_CLR_IRQ_PAR = 2048,
	BMU_CLR_IRQ_TCP = 2048,
	BMU_CLR_IRQ_CHK = 1024,
	BMU_STOP = 512,
	BMU_START = 256,
	BMU_FIFO_OP_ON = 128,
	BMU_FIFO_OP_OFF = 64,
	BMU_FIFO_ENA = 32,
	BMU_FIFO_RST = 16,
	BMU_OP_ON = 8,
	BMU_OP_OFF = 4,
	BMU_RST_CLR = 2,
	BMU_RST_SET = 1,
	BMU_CLR_RESET = 22,
	BMU_OPER_INIT = 3368,
	BMU_WM_DEFAULT = 1536,
	BMU_WM_PEX = 128,
};

enum {
	BPF_ADJ_ROOM_ENCAP_L2_MASK = 255,
	BPF_ADJ_ROOM_ENCAP_L2_SHIFT = 56,
};

enum {
	BPF_ANY = 0,
	BPF_NOEXIST = 1,
	BPF_EXIST = 2,
	BPF_F_LOCK = 4,
};

enum {
	BPF_CSUM_LEVEL_QUERY = 0,
	BPF_CSUM_LEVEL_INC = 1,
	BPF_CSUM_LEVEL_DEC = 2,
	BPF_CSUM_LEVEL_RESET = 3,
};

enum {
	BPF_FIB_LKUP_RET_SUCCESS = 0,
	BPF_FIB_LKUP_RET_BLACKHOLE = 1,
	BPF_FIB_LKUP_RET_UNREACHABLE = 2,
	BPF_FIB_LKUP_RET_PROHIBIT = 3,
	BPF_FIB_LKUP_RET_NOT_FWDED = 4,
	BPF_FIB_LKUP_RET_FWD_DISABLED = 5,
	BPF_FIB_LKUP_RET_UNSUPP_LWT = 6,
	BPF_FIB_LKUP_RET_NO_NEIGH = 7,
	BPF_FIB_LKUP_RET_FRAG_NEEDED = 8,
	BPF_FIB_LKUP_RET_NO_SRC_ADDR = 9,
};

enum {
	BPF_FIB_LOOKUP_DIRECT = 1,
	BPF_FIB_LOOKUP_OUTPUT = 2,
	BPF_FIB_LOOKUP_SKIP_NEIGH = 4,
	BPF_FIB_LOOKUP_TBID = 8,
	BPF_FIB_LOOKUP_SRC = 16,
	BPF_FIB_LOOKUP_MARK = 32,
};

enum {
	BPF_FLOW_DISSECTOR_F_PARSE_1ST_FRAG = 1,
	BPF_FLOW_DISSECTOR_F_STOP_AT_FLOW_LABEL = 2,
	BPF_FLOW_DISSECTOR_F_STOP_AT_ENCAP = 4,
};

enum {
	BPF_F_ADJ_ROOM_FIXED_GSO = 1,
	BPF_F_ADJ_ROOM_ENCAP_L3_IPV4 = 2,
	BPF_F_ADJ_ROOM_ENCAP_L3_IPV6 = 4,
	BPF_F_ADJ_ROOM_ENCAP_L4_GRE = 8,
	BPF_F_ADJ_ROOM_ENCAP_L4_UDP = 16,
	BPF_F_ADJ_ROOM_NO_CSUM_RESET = 32,
	BPF_F_ADJ_ROOM_ENCAP_L2_ETH = 64,
	BPF_F_ADJ_ROOM_DECAP_L3_IPV4 = 128,
	BPF_F_ADJ_ROOM_DECAP_L3_IPV6 = 256,
};

enum {
	BPF_F_CURRENT_NETNS = -1,
};

enum {
	BPF_F_GET_BRANCH_RECORDS_SIZE = 1,
};

enum {
	BPF_F_HDR_FIELD_MASK = 15,
};

enum {
	BPF_F_INDEX_MASK = 4294967295ULL,
	BPF_F_CURRENT_CPU = 4294967295ULL,
	BPF_F_CTXLEN_MASK = 4503595332403200ULL,
};

enum {
	BPF_F_INGRESS = 1,
	BPF_F_BROADCAST = 8,
	BPF_F_EXCLUDE_INGRESS = 16,
};

enum {
	BPF_F_NEIGH = 65536,
	BPF_F_PEER = 131072,
	BPF_F_NEXTHOP = 262144,
};

enum {
	BPF_F_NO_PREALLOC = 1,
	BPF_F_NO_COMMON_LRU = 2,
	BPF_F_NUMA_NODE = 4,
	BPF_F_RDONLY = 8,
	BPF_F_WRONLY = 16,
	BPF_F_STACK_BUILD_ID = 32,
	BPF_F_ZERO_SEED = 64,
	BPF_F_RDONLY_PROG = 128,
	BPF_F_WRONLY_PROG = 256,
	BPF_F_CLONE = 512,
	BPF_F_MMAPABLE = 1024,
	BPF_F_PRESERVE_ELEMS = 2048,
	BPF_F_INNER_MAP = 4096,
	BPF_F_LINK = 8192,
	BPF_F_PATH_FD = 16384,
	BPF_F_VTYPE_BTF_OBJ_FD = 32768,
	BPF_F_TOKEN_FD = 65536,
	BPF_F_SEGV_ON_FAULT = 131072,
	BPF_F_NO_USER_CONV = 262144,
};

enum {
	BPF_F_PSEUDO_HDR = 16,
	BPF_F_MARK_MANGLED_0 = 32,
	BPF_F_MARK_ENFORCE = 64,
};

enum {
	BPF_F_RECOMPUTE_CSUM = 1,
	BPF_F_INVALIDATE_HASH = 2,
};

enum {
	BPF_F_SKIP_FIELD_MASK = 255,
	BPF_F_USER_STACK = 256,
	BPF_F_FAST_STACK_CMP = 512,
	BPF_F_REUSE_STACKID = 1024,
	BPF_F_USER_BUILD_ID = 2048,
};

enum {
	BPF_F_TIMER_ABS = 1,
	BPF_F_TIMER_CPU_PIN = 2,
};

enum {
	BPF_F_TUNINFO_FLAGS = 16,
};

enum {
	BPF_F_TUNINFO_IPV6 = 1,
};

enum {
	BPF_F_UPROBE_MULTI_RETURN = 1,
};

enum {
	BPF_F_ZERO_CSUM_TX = 2,
	BPF_F_DONT_FRAGMENT = 4,
	BPF_F_SEQ_NUMBER = 8,
	BPF_F_NO_TUNNEL_KEY = 16,
};

enum {
	BPF_LOAD_HDR_OPT_TCP_SYN = 1,
};

enum {
	BPF_LOCAL_STORAGE_GET_F_CREATE = 1,
	BPF_SK_STORAGE_GET_F_CREATE = 1,
};

enum {
	BPF_MAX_LOOPS = 8388608,
};

enum {
	BPF_MAX_TRAMP_LINKS = 38,
};

enum {
	BPF_RB_AVAIL_DATA = 0,
	BPF_RB_RING_SIZE = 1,
	BPF_RB_CONS_POS = 2,
	BPF_RB_PROD_POS = 3,
};

enum {
	BPF_RB_NO_WAKEUP = 1,
	BPF_RB_FORCE_WAKEUP = 2,
};

enum {
	BPF_REG_0 = 0,
	BPF_REG_1 = 1,
	BPF_REG_2 = 2,
	BPF_REG_3 = 3,
	BPF_REG_4 = 4,
	BPF_REG_5 = 5,
	BPF_REG_6 = 6,
	BPF_REG_7 = 7,
	BPF_REG_8 = 8,
	BPF_REG_9 = 9,
	BPF_REG_10 = 10,
	__MAX_BPF_REG = 11,
};

enum {
	BPF_RINGBUF_BUSY_BIT = 2147483648,
	BPF_RINGBUF_DISCARD_BIT = 1073741824,
	BPF_RINGBUF_HDR_SZ = 8,
};

enum {
	BPF_SKB_TSTAMP_UNSPEC = 0,
	BPF_SKB_TSTAMP_DELIVERY_MONO = 1,
	BPF_SKB_CLOCK_REALTIME = 0,
	BPF_SKB_CLOCK_MONOTONIC = 1,
	BPF_SKB_CLOCK_TAI = 2,
};

enum {
	BPF_SK_LOOKUP_F_REPLACE = 1,
	BPF_SK_LOOKUP_F_NO_REUSEPORT = 2,
};

enum {
	BPF_SOCK_OPS_RTO_CB_FLAG = 1,
	BPF_SOCK_OPS_RETRANS_CB_FLAG = 2,
	BPF_SOCK_OPS_STATE_CB_FLAG = 4,
	BPF_SOCK_OPS_RTT_CB_FLAG = 8,
	BPF_SOCK_OPS_PARSE_ALL_HDR_OPT_CB_FLAG = 16,
	BPF_SOCK_OPS_PARSE_UNKNOWN_HDR_OPT_CB_FLAG = 32,
	BPF_SOCK_OPS_WRITE_HDR_OPT_CB_FLAG = 64,
	BPF_SOCK_OPS_ALL_CB_FLAGS = 127,
};

enum {
	BPF_SOCK_OPS_VOID = 0,
	BPF_SOCK_OPS_TIMEOUT_INIT = 1,
	BPF_SOCK_OPS_RWND_INIT = 2,
	BPF_SOCK_OPS_TCP_CONNECT_CB = 3,
	BPF_SOCK_OPS_ACTIVE_ESTABLISHED_CB = 4,
	BPF_SOCK_OPS_PASSIVE_ESTABLISHED_CB = 5,
	BPF_SOCK_OPS_NEEDS_ECN = 6,
	BPF_SOCK_OPS_BASE_RTT = 7,
	BPF_SOCK_OPS_RTO_CB = 8,
	BPF_SOCK_OPS_RETRANS_CB = 9,
	BPF_SOCK_OPS_STATE_CB = 10,
	BPF_SOCK_OPS_TCP_LISTEN_CB = 11,
	BPF_SOCK_OPS_RTT_CB = 12,
	BPF_SOCK_OPS_PARSE_HDR_OPT_CB = 13,
	BPF_SOCK_OPS_HDR_OPT_LEN_CB = 14,
	BPF_SOCK_OPS_WRITE_HDR_OPT_CB = 15,
};

enum {
	BPF_TASK_ITER_ALL_PROCS = 0,
	BPF_TASK_ITER_ALL_THREADS = 1,
	BPF_TASK_ITER_PROC_THREADS = 2,
};

enum {
	BPF_TCP_ESTABLISHED = 1,
	BPF_TCP_SYN_SENT = 2,
	BPF_TCP_SYN_RECV = 3,
	BPF_TCP_FIN_WAIT1 = 4,
	BPF_TCP_FIN_WAIT2 = 5,
	BPF_TCP_TIME_WAIT = 6,
	BPF_TCP_CLOSE = 7,
	BPF_TCP_CLOSE_WAIT = 8,
	BPF_TCP_LAST_ACK = 9,
	BPF_TCP_LISTEN = 10,
	BPF_TCP_CLOSING = 11,
	BPF_TCP_NEW_SYN_RECV = 12,
	BPF_TCP_BOUND_INACTIVE = 13,
	BPF_TCP_MAX_STATES = 14,
};

enum {
	BPF_XFRM_STATE_OPTS_SZ = 36,
};

enum {
	BR_MCAST_DIR_RX = 0,
	BR_MCAST_DIR_TX = 1,
	BR_MCAST_DIR_SIZE = 2,
};

enum {
	BTF_FIELDS_MAX = 11,
};

enum {
	BTF_FIELD_IGNORE = 0,
	BTF_FIELD_FOUND = 1,
};

enum {
	BTF_F_COMPACT = 1,
	BTF_F_NONAME = 2,
	BTF_F_PTR_RAW = 4,
	BTF_F_ZERO = 8,
};

enum {
	BTF_KFUNC_SET_MAX_CNT = 256,
	BTF_DTOR_KFUNC_MAX_CNT = 256,
	BTF_KFUNC_FILTER_MAX_CNT = 16,
};

enum {
	BTF_KIND_UNKN = 0,
	BTF_KIND_INT = 1,
	BTF_KIND_PTR = 2,
	BTF_KIND_ARRAY = 3,
	BTF_KIND_STRUCT = 4,
	BTF_KIND_UNION = 5,
	BTF_KIND_ENUM = 6,
	BTF_KIND_FWD = 7,
	BTF_KIND_TYPEDEF = 8,
	BTF_KIND_VOLATILE = 9,
	BTF_KIND_CONST = 10,
	BTF_KIND_RESTRICT = 11,
	BTF_KIND_FUNC = 12,
	BTF_KIND_FUNC_PROTO = 13,
	BTF_KIND_VAR = 14,
	BTF_KIND_DATASEC = 15,
	BTF_KIND_FLOAT = 16,
	BTF_KIND_DECL_TAG = 17,
	BTF_KIND_TYPE_TAG = 18,
	BTF_KIND_ENUM64 = 19,
	NR_BTF_KINDS = 20,
	BTF_KIND_MAX = 19,
};

enum {
	BTF_MODULE_F_LIVE = 1,
};

enum {
	BTF_SOCK_TYPE_INET = 0,
	BTF_SOCK_TYPE_INET_CONN = 1,
	BTF_SOCK_TYPE_INET_REQ = 2,
	BTF_SOCK_TYPE_INET_TW = 3,
	BTF_SOCK_TYPE_REQ = 4,
	BTF_SOCK_TYPE_SOCK = 5,
	BTF_SOCK_TYPE_SOCK_COMMON = 6,
	BTF_SOCK_TYPE_TCP = 7,
	BTF_SOCK_TYPE_TCP_REQ = 8,
	BTF_SOCK_TYPE_TCP_TW = 9,
	BTF_SOCK_TYPE_TCP6 = 10,
	BTF_SOCK_TYPE_UDP = 11,
	BTF_SOCK_TYPE_UDP6 = 12,
	BTF_SOCK_TYPE_UNIX = 13,
	BTF_SOCK_TYPE_MPTCP = 14,
	BTF_SOCK_TYPE_SOCKET = 15,
	MAX_BTF_SOCK_TYPE = 16,
};

enum {
	BTF_TRACING_TYPE_TASK = 0,
	BTF_TRACING_TYPE_FILE = 1,
	BTF_TRACING_TYPE_VMA = 2,
	MAX_BTF_TRACING_TYPE = 3,
};

enum {
	BTF_VAR_STATIC = 0,
	BTF_VAR_GLOBAL_ALLOCATED = 1,
	BTF_VAR_GLOBAL_EXTERN = 2,
};

enum {
	BTS_STATE_STOPPED = 0,
	BTS_STATE_INACTIVE = 1,
	BTS_STATE_ACTIVE = 2,
};

enum {
	Blktrace_setup = 1,
	Blktrace_running = 2,
	Blktrace_stopped = 3,
};

enum {
	CACHE_VALID = 0,
	CACHE_NEGATIVE = 1,
	CACHE_PENDING = 2,
	CACHE_CLEANED = 3,
};

enum {
	CARDBUS_TYPE_DEFAULT = -1,
	CARDBUS_TYPE_TI = 0,
	CARDBUS_TYPE_TI113X = 1,
	CARDBUS_TYPE_TI12XX = 2,
	CARDBUS_TYPE_TI1250 = 3,
	CARDBUS_TYPE_RICOH = 4,
	CARDBUS_TYPE_TOPIC95 = 5,
	CARDBUS_TYPE_TOPIC97 = 6,
	CARDBUS_TYPE_O2MICRO = 7,
	CARDBUS_TYPE_ENE = 8,
};

enum {
	CFG_CHIP_R_MSK = 240,
	CFG_DIS_M2_CLK = 2,
	CFG_SNG_MAC = 1,
};

enum {
	CFG_LED_MODE_MSK = 28,
	CFG_LINK_2_AVAIL = 2,
	CFG_LINK_1_AVAIL = 1,
};

enum {
	CFTYPE_ONLY_ON_ROOT = 1,
	CFTYPE_NOT_ON_ROOT = 2,
	CFTYPE_NS_DELEGATABLE = 4,
	CFTYPE_NO_PREFIX = 8,
	CFTYPE_WORLD_WRITABLE = 16,
	CFTYPE_DEBUG = 32,
	__CFTYPE_ONLY_ON_DFL = 65536,
	__CFTYPE_NOT_ON_DFL = 131072,
	__CFTYPE_ADDED = 262144,
};

enum {
	CGROUPSTATS_CMD_ATTR_UNSPEC = 0,
	CGROUPSTATS_CMD_ATTR_FD = 1,
	__CGROUPSTATS_CMD_ATTR_MAX = 2,
};

enum {
	CGROUPSTATS_CMD_UNSPEC = 3,
	CGROUPSTATS_CMD_GET = 4,
	CGROUPSTATS_CMD_NEW = 5,
	__CGROUPSTATS_CMD_MAX = 6,
};

enum {
	CGROUPSTATS_TYPE_UNSPEC = 0,
	CGROUPSTATS_TYPE_CGROUP_STATS = 1,
	__CGROUPSTATS_TYPE_MAX = 2,
};

enum {
	CGRP_NOTIFY_ON_RELEASE = 0,
	CGRP_CPUSET_CLONE_CHILDREN = 1,
	CGRP_FREEZE = 2,
	CGRP_FROZEN = 3,
};

enum {
	CGRP_ROOT_NOPREFIX = 2,
	CGRP_ROOT_XATTR = 4,
	CGRP_ROOT_NS_DELEGATE = 8,
	CGRP_ROOT_FAVOR_DYNMODS = 16,
	CGRP_ROOT_CPUSET_V2_MODE = 65536,
	CGRP_ROOT_MEMORY_LOCAL_EVENTS = 131072,
	CGRP_ROOT_MEMORY_RECURSIVE_PROT = 262144,
	CGRP_ROOT_MEMORY_HUGETLB_ACCOUNTING = 524288,
	CGRP_ROOT_PIDS_LOCAL_EVENTS = 1048576,
};

enum {
	CHIP_ID_YUKON_XL = 179,
	CHIP_ID_YUKON_EC_U = 180,
	CHIP_ID_YUKON_EX = 181,
	CHIP_ID_YUKON_EC = 182,
	CHIP_ID_YUKON_FE = 183,
	CHIP_ID_YUKON_FE_P = 184,
	CHIP_ID_YUKON_SUPR = 185,
	CHIP_ID_YUKON_UL_2 = 186,
	CHIP_ID_YUKON_OPT = 188,
	CHIP_ID_YUKON_PRM = 189,
	CHIP_ID_YUKON_OP_2 = 190,
};

enum {
	CLEAR_RESIDUALS = 0,
};

enum {
	CMIS_MODULE_LOW_PWR = 1,
	CMIS_MODULE_READY = 3,
};

enum {
	CM_ASL_WLAN = 0,
	CM_ASL_BLUETOOTH = 1,
	CM_ASL_IRDA = 2,
	CM_ASL_1394 = 3,
	CM_ASL_CAMERA = 4,
	CM_ASL_TV = 5,
	CM_ASL_GPS = 6,
	CM_ASL_DVDROM = 7,
	CM_ASL_DISPLAYSWITCH = 8,
	CM_ASL_PANELBRIGHT = 9,
	CM_ASL_BIOSFLASH = 10,
	CM_ASL_ACPIFLASH = 11,
	CM_ASL_CPUFV = 12,
	CM_ASL_CPUTEMPERATURE = 13,
	CM_ASL_FANCPU = 14,
	CM_ASL_FANCHASSIS = 15,
	CM_ASL_USBPORT1 = 16,
	CM_ASL_USBPORT2 = 17,
	CM_ASL_USBPORT3 = 18,
	CM_ASL_MODEM = 19,
	CM_ASL_CARDREADER = 20,
	CM_ASL_3G = 21,
	CM_ASL_WIMAX = 22,
	CM_ASL_HWCF = 23,
	CM_ASL_LID = 24,
	CM_ASL_TYPE = 25,
	CM_ASL_PANELPOWER = 26,
	CM_ASL_TPD = 27,
};

enum {
	CONNSECMARK_SAVE = 1,
	CONNSECMARK_RESTORE = 2,
};

enum {
	COST_CTRL = 0,
	COST_MODEL = 1,
	NR_COST_CTRL_PARAMS = 2,
};

enum {
	CPU_WDOG = 3656,
	CPU_CNTR = 3660,
	CPU_TIM = 3664,
	CPU_AHB_ADDR = 3668,
	CPU_AHB_WDATA = 3672,
	CPU_AHB_RDATA = 3676,
	HCU_MAP_BASE = 3680,
	CPU_AHB_CTRL = 3684,
	HCU_CCSR = 3688,
	HCU_HCSR = 3692,
};

enum {
	CRNG_EMPTY = 0,
	CRNG_EARLY = 1,
	CRNG_READY = 2,
};

enum {
	CRNG_RESEED_START_INTERVAL = 1000,
	CRNG_RESEED_INTERVAL = 60000,
};

enum {
	CRYPTOA_UNSPEC = 0,
	CRYPTOA_ALG = 1,
	CRYPTOA_TYPE = 2,
	__CRYPTOA_MAX = 3,
};

enum {
	CRYPTO_AUTHENC_KEYA_UNSPEC = 0,
	CRYPTO_AUTHENC_KEYA_PARAM = 1,
};

enum {
	CRYPTO_MSG_ALG_REQUEST = 0,
	CRYPTO_MSG_ALG_REGISTER = 1,
	CRYPTO_MSG_ALG_LOADED = 2,
};

enum {
	CSD_FLAG_LOCK = 1,
	IRQ_WORK_PENDING = 1,
	IRQ_WORK_BUSY = 2,
	IRQ_WORK_LAZY = 4,
	IRQ_WORK_HARD_IRQ = 8,
	IRQ_WORK_CLAIMED = 3,
	CSD_TYPE_ASYNC = 0,
	CSD_TYPE_SYNC = 16,
	CSD_TYPE_IRQ_WORK = 32,
	CSD_TYPE_TTWU = 48,
	CSD_FLAG_TYPE_MASK = 240,
};

enum {
	CSI_DEC_hl_CURSOR_KEYS = 1,
	CSI_DEC_hl_132_COLUMNS = 3,
	CSI_DEC_hl_REVERSE_VIDEO = 5,
	CSI_DEC_hl_ORIGIN_MODE = 6,
	CSI_DEC_hl_AUTOWRAP = 7,
	CSI_DEC_hl_AUTOREPEAT = 8,
	CSI_DEC_hl_MOUSE_X10 = 9,
	CSI_DEC_hl_SHOW_CURSOR = 25,
	CSI_DEC_hl_MOUSE_VT200 = 1000,
};

enum {
	CSI_K_CURSOR_TO_LINEEND = 0,
	CSI_K_LINESTART_TO_CURSOR = 1,
	CSI_K_LINE = 2,
};

enum {
	CSI_hl_DISPLAY_CTRL = 3,
	CSI_hl_INSERT = 4,
	CSI_hl_AUTO_NL = 20,
};

enum {
	CSI_m_DEFAULT = 0,
	CSI_m_BOLD = 1,
	CSI_m_HALF_BRIGHT = 2,
	CSI_m_ITALIC = 3,
	CSI_m_UNDERLINE = 4,
	CSI_m_BLINK = 5,
	CSI_m_REVERSE = 7,
	CSI_m_PRI_FONT = 10,
	CSI_m_ALT_FONT1 = 11,
	CSI_m_ALT_FONT2 = 12,
	CSI_m_DOUBLE_UNDERLINE = 21,
	CSI_m_NORMAL_INTENSITY = 22,
	CSI_m_NO_ITALIC = 23,
	CSI_m_NO_UNDERLINE = 24,
	CSI_m_NO_BLINK = 25,
	CSI_m_NO_REVERSE = 27,
	CSI_m_FG_COLOR_BEG = 30,
	CSI_m_FG_COLOR_END = 37,
	CSI_m_FG_COLOR = 38,
	CSI_m_DEFAULT_FG_COLOR = 39,
	CSI_m_BG_COLOR_BEG = 40,
	CSI_m_BG_COLOR_END = 47,
	CSI_m_BG_COLOR = 48,
	CSI_m_DEFAULT_BG_COLOR = 49,
	CSI_m_BRIGHT_FG_COLOR_BEG = 90,
	CSI_m_BRIGHT_FG_COLOR_END = 97,
	CSI_m_BRIGHT_FG_COLOR_OFF = 60,
	CSI_m_BRIGHT_BG_COLOR_BEG = 100,
	CSI_m_BRIGHT_BG_COLOR_END = 107,
	CSI_m_BRIGHT_BG_COLOR_OFF = 60,
};

enum {
	CSS_NO_REF = 1,
	CSS_ONLINE = 2,
	CSS_RELEASED = 4,
	CSS_VISIBLE = 8,
	CSS_DYING = 16,
};

enum {
	CSS_TASK_ITER_PROCS = 1,
	CSS_TASK_ITER_THREADED = 2,
	CSS_TASK_ITER_SKIPPED = 65536,
};

enum {
	CTRL_ATTR_MCAST_GRP_UNSPEC = 0,
	CTRL_ATTR_MCAST_GRP_NAME = 1,
	CTRL_ATTR_MCAST_GRP_ID = 2,
	__CTRL_ATTR_MCAST_GRP_MAX = 3,
};

enum {
	CTRL_ATTR_OP_UNSPEC = 0,
	CTRL_ATTR_OP_ID = 1,
	CTRL_ATTR_OP_FLAGS = 2,
	__CTRL_ATTR_OP_MAX = 3,
};

enum {
	CTRL_ATTR_POLICY_UNSPEC = 0,
	CTRL_ATTR_POLICY_DO = 1,
	CTRL_ATTR_POLICY_DUMP = 2,
	__CTRL_ATTR_POLICY_DUMP_MAX = 3,
	CTRL_ATTR_POLICY_DUMP_MAX = 2,
};

enum {
	CTRL_ATTR_UNSPEC = 0,
	CTRL_ATTR_FAMILY_ID = 1,
	CTRL_ATTR_FAMILY_NAME = 2,
	CTRL_ATTR_VERSION = 3,
	CTRL_ATTR_HDRSIZE = 4,
	CTRL_ATTR_MAXATTR = 5,
	CTRL_ATTR_OPS = 6,
	CTRL_ATTR_MCAST_GROUPS = 7,
	CTRL_ATTR_POLICY = 8,
	CTRL_ATTR_OP_POLICY = 9,
	CTRL_ATTR_OP = 10,
	__CTRL_ATTR_MAX = 11,
};

enum {
	CTRL_CMD_UNSPEC = 0,
	CTRL_CMD_NEWFAMILY = 1,
	CTRL_CMD_DELFAMILY = 2,
	CTRL_CMD_GETFAMILY = 3,
	CTRL_CMD_NEWOPS = 4,
	CTRL_CMD_DELOPS = 5,
	CTRL_CMD_GETOPS = 6,
	CTRL_CMD_NEWMCAST_GRP = 7,
	CTRL_CMD_DELMCAST_GRP = 8,
	CTRL_CMD_GETMCAST_GRP = 9,
	CTRL_CMD_GETPOLICY = 10,
	__CTRL_CMD_MAX = 11,
};

enum {
	D0TIM = 128,
	D1TIM = 132,
	PM = 7,
	MDM = 768,
	UDM = 458752,
	PPE = 1073741824,
	USD = -2147483648,
};

enum {
	DAD_PROCESS = 0,
	DAD_BEGIN = 1,
	DAD_ABORT = 2,
};

enum {
	DD_DIR_COUNT = 2,
};

enum {
	DD_PRIO_COUNT = 3,
};

enum {
	DEBUG_FENCE_IDLE = 0,
	DEBUG_FENCE_NOTIFY = 1,
};

enum {
	DELL_INSPIRON_7375 = 0,
	DELL_LATITUDE_5495 = 1,
	LENOVO_IDEAPAD_330S_15ARR = 2,
};

enum {
	DESC_TSS = 9,
	DESC_LDT = 2,
	DESCTYPE_S = 16,
};

enum {
	DEVCONF_FORWARDING = 0,
	DEVCONF_HOPLIMIT = 1,
	DEVCONF_MTU6 = 2,
	DEVCONF_ACCEPT_RA = 3,
	DEVCONF_ACCEPT_REDIRECTS = 4,
	DEVCONF_AUTOCONF = 5,
	DEVCONF_DAD_TRANSMITS = 6,
	DEVCONF_RTR_SOLICITS = 7,
	DEVCONF_RTR_SOLICIT_INTERVAL = 8,
	DEVCONF_RTR_SOLICIT_DELAY = 9,
	DEVCONF_USE_TEMPADDR = 10,
	DEVCONF_TEMP_VALID_LFT = 11,
	DEVCONF_TEMP_PREFERED_LFT = 12,
	DEVCONF_REGEN_MAX_RETRY = 13,
	DEVCONF_MAX_DESYNC_FACTOR = 14,
	DEVCONF_MAX_ADDRESSES = 15,
	DEVCONF_FORCE_MLD_VERSION = 16,
	DEVCONF_ACCEPT_RA_DEFRTR = 17,
	DEVCONF_ACCEPT_RA_PINFO = 18,
	DEVCONF_ACCEPT_RA_RTR_PREF = 19,
	DEVCONF_RTR_PROBE_INTERVAL = 20,
	DEVCONF_ACCEPT_RA_RT_INFO_MAX_PLEN = 21,
	DEVCONF_PROXY_NDP = 22,
	DEVCONF_OPTIMISTIC_DAD = 23,
	DEVCONF_ACCEPT_SOURCE_ROUTE = 24,
	DEVCONF_MC_FORWARDING = 25,
	DEVCONF_DISABLE_IPV6 = 26,
	DEVCONF_ACCEPT_DAD = 27,
	DEVCONF_FORCE_TLLAO = 28,
	DEVCONF_NDISC_NOTIFY = 29,
	DEVCONF_MLDV1_UNSOLICITED_REPORT_INTERVAL = 30,
	DEVCONF_MLDV2_UNSOLICITED_REPORT_INTERVAL = 31,
	DEVCONF_SUPPRESS_FRAG_NDISC = 32,
	DEVCONF_ACCEPT_RA_FROM_LOCAL = 33,
	DEVCONF_USE_OPTIMISTIC = 34,
	DEVCONF_ACCEPT_RA_MTU = 35,
	DEVCONF_STABLE_SECRET = 36,
	DEVCONF_USE_OIF_ADDRS_ONLY = 37,
	DEVCONF_ACCEPT_RA_MIN_HOP_LIMIT = 38,
	DEVCONF_IGNORE_ROUTES_WITH_LINKDOWN = 39,
	DEVCONF_DROP_UNICAST_IN_L2_MULTICAST = 40,
	DEVCONF_DROP_UNSOLICITED_NA = 41,
	DEVCONF_KEEP_ADDR_ON_DOWN = 42,
	DEVCONF_RTR_SOLICIT_MAX_INTERVAL = 43,
	DEVCONF_SEG6_ENABLED = 44,
	DEVCONF_SEG6_REQUIRE_HMAC = 45,
	DEVCONF_ENHANCED_DAD = 46,
	DEVCONF_ADDR_GEN_MODE = 47,
	DEVCONF_DISABLE_POLICY = 48,
	DEVCONF_ACCEPT_RA_RT_INFO_MIN_PLEN = 49,
	DEVCONF_NDISC_TCLASS = 50,
	DEVCONF_RPL_SEG_ENABLED = 51,
	DEVCONF_RA_DEFRTR_METRIC = 52,
	DEVCONF_IOAM6_ENABLED = 53,
	DEVCONF_IOAM6_ID = 54,
	DEVCONF_IOAM6_ID_WIDE = 55,
	DEVCONF_NDISC_EVICT_NOCARRIER = 56,
	DEVCONF_ACCEPT_UNTRACKED_NA = 57,
	DEVCONF_ACCEPT_RA_MIN_LFT = 58,
	DEVCONF_MAX = 59,
};

enum {
	DIO_LOCKING = 1,
	DIO_SKIP_HOLES = 2,
};

enum {
	DIO_SHOULD_DIRTY = 1,
	DIO_IS_SYNC = 2,
};

enum {
	DIR_OFFSET_FIRST = 2,
	DIR_OFFSET_EOD = 2147483647,
};

enum {
	DIR_OFFSET_MIN = 3,
	DIR_OFFSET_MAX = 2147483646,
};

enum {
	DISABLE_ASL_WLAN = 1,
	DISABLE_ASL_BLUETOOTH = 2,
	DISABLE_ASL_IRDA = 4,
	DISABLE_ASL_CAMERA = 8,
	DISABLE_ASL_TV = 16,
	DISABLE_ASL_GPS = 32,
	DISABLE_ASL_DISPLAYSWITCH = 64,
	DISABLE_ASL_MODEM = 128,
	DISABLE_ASL_CARDREADER = 256,
	DISABLE_ASL_3G = 512,
	DISABLE_ASL_WIMAX = 1024,
	DISABLE_ASL_HWCF = 2048,
};

enum {
	DISCOVERED = 16,
	EXPLORED = 32,
	FALLTHROUGH = 1,
	BRANCH = 2,
};

enum {
	DISK_EVENT_FLAG_POLL = 1,
	DISK_EVENT_FLAG_UEVENT = 2,
	DISK_EVENT_FLAG_BLOCK_ON_EXCL_WRITE = 4,
};

enum {
	DISK_EVENT_MEDIA_CHANGE = 1,
	DISK_EVENT_EJECT_REQUEST = 2,
};

enum {
	DMA_DSCR_HOST = 0,
	DMA_DSCR_DEVICE = 1,
	DMA_DSCR_CTRL = 2,
	DMA_DSCR_NUM = 3,
};

enum {
	DMA_FENCE_WORK_IMM = 3,
};

enum {
	DM_IO_ACCOUNTED = 0,
	DM_IO_WAS_SPLIT = 1,
	DM_IO_BLK_STAT = 2,
};

enum {
	DM_TIO_INSIDE_DM_IO = 0,
	DM_TIO_IS_DUPLICATE_BIO = 1,
};

enum {
	DM_VERSION_CMD = 0,
	DM_REMOVE_ALL_CMD = 1,
	DM_LIST_DEVICES_CMD = 2,
	DM_DEV_CREATE_CMD = 3,
	DM_DEV_REMOVE_CMD = 4,
	DM_DEV_RENAME_CMD = 5,
	DM_DEV_SUSPEND_CMD = 6,
	DM_DEV_STATUS_CMD = 7,
	DM_DEV_WAIT_CMD = 8,
	DM_TABLE_LOAD_CMD = 9,
	DM_TABLE_CLEAR_CMD = 10,
	DM_TABLE_DEPS_CMD = 11,
	DM_TABLE_STATUS_CMD = 12,
	DM_LIST_VERSIONS_CMD = 13,
	DM_TARGET_MSG_CMD = 14,
	DM_DEV_SET_GEOMETRY_CMD = 15,
	DM_DEV_ARM_POLL_CMD = 16,
	DM_GET_TARGET_VERSION_CMD = 17,
};

enum {
	DONE_EXPLORING = 0,
	KEEP_EXPLORING = 1,
};

enum {
	DPT_START = 2,
	DPT_STOP = 1,
};

enum {
	DQF_INFO_DIRTY_B = 17,
};

enum {
	DQF_ROOT_SQUASH_B = 0,
	DQF_SYS_FILE_B = 16,
	DQF_PRIVATE = 17,
};

enum {
	DQST_LOOKUPS = 0,
	DQST_DROPS = 1,
	DQST_READS = 2,
	DQST_WRITES = 3,
	DQST_CACHE_HITS = 4,
	DQST_ALLOC_DQUOTS = 5,
	DQST_FREE_DQUOTS = 6,
	DQST_SYNCS = 7,
	_DQST_DQSTAT_LAST = 8,
};

enum {
	DUMP_PREFIX_NONE = 0,
	DUMP_PREFIX_ADDRESS = 1,
	DUMP_PREFIX_OFFSET = 2,
};

enum {
	EC_FLAGS_QUERY_ENABLED = 0,
	EC_FLAGS_EVENT_HANDLER_INSTALLED = 1,
	EC_FLAGS_EC_HANDLER_INSTALLED = 2,
	EC_FLAGS_EC_REG_CALLED = 3,
	EC_FLAGS_QUERY_METHODS_INSTALLED = 4,
	EC_FLAGS_STARTED = 5,
	EC_FLAGS_STOPPED = 6,
	EC_FLAGS_EVENTS_MASKED = 7,
};

enum {
	EMULATE = 0,
	XONLY = 1,
	NONE = 2,
};

enum {
	EPecma = 0,
	EPdec = 1,
	EPeq = 2,
	EPgt = 3,
	EPlt = 4,
};

enum {
	ERASE = 0,
	WERASE = 1,
	KILL = 2,
};

enum {
	ES_WRITTEN_B = 0,
	ES_UNWRITTEN_B = 1,
	ES_DELAYED_B = 2,
	ES_HOLE_B = 3,
	ES_REFERENCED_B = 4,
	ES_FLAGS = 5,
};

enum {
	ETHTOOL_A_BITSET_BITS_UNSPEC = 0,
	ETHTOOL_A_BITSET_BITS_BIT = 1,
	__ETHTOOL_A_BITSET_BITS_CNT = 2,
	ETHTOOL_A_BITSET_BITS_MAX = 1,
};

enum {
	ETHTOOL_A_BITSET_BIT_UNSPEC = 0,
	ETHTOOL_A_BITSET_BIT_INDEX = 1,
	ETHTOOL_A_BITSET_BIT_NAME = 2,
	ETHTOOL_A_BITSET_BIT_VALUE = 3,
	__ETHTOOL_A_BITSET_BIT_CNT = 4,
	ETHTOOL_A_BITSET_BIT_MAX = 3,
};

enum {
	ETHTOOL_A_BITSET_UNSPEC = 0,
	ETHTOOL_A_BITSET_NOMASK = 1,
	ETHTOOL_A_BITSET_SIZE = 2,
	ETHTOOL_A_BITSET_BITS = 3,
	ETHTOOL_A_BITSET_VALUE = 4,
	ETHTOOL_A_BITSET_MASK = 5,
	__ETHTOOL_A_BITSET_CNT = 6,
	ETHTOOL_A_BITSET_MAX = 5,
};

enum {
	ETHTOOL_A_C33_PSE_PW_LIMIT_UNSPEC = 0,
	ETHTOOL_A_C33_PSE_PW_LIMIT_MIN = 1,
	ETHTOOL_A_C33_PSE_PW_LIMIT_MAX = 2,
	__ETHTOOL_A_C33_PSE_PW_LIMIT_CNT = 3,
	__ETHTOOL_A_C33_PSE_PW_LIMIT_MAX = 2,
};

enum {
	ETHTOOL_A_CABLE_AMPLITUDE_UNSPEC = 0,
	ETHTOOL_A_CABLE_AMPLITUDE_PAIR = 1,
	ETHTOOL_A_CABLE_AMPLITUDE_mV = 2,
	__ETHTOOL_A_CABLE_AMPLITUDE_CNT = 3,
	ETHTOOL_A_CABLE_AMPLITUDE_MAX = 2,
};

enum {
	ETHTOOL_A_CABLE_FAULT_LENGTH_UNSPEC = 0,
	ETHTOOL_A_CABLE_FAULT_LENGTH_PAIR = 1,
	ETHTOOL_A_CABLE_FAULT_LENGTH_CM = 2,
	ETHTOOL_A_CABLE_FAULT_LENGTH_SRC = 3,
	__ETHTOOL_A_CABLE_FAULT_LENGTH_CNT = 4,
	ETHTOOL_A_CABLE_FAULT_LENGTH_MAX = 3,
};

enum {
	ETHTOOL_A_CABLE_INF_SRC_UNSPEC = 0,
	ETHTOOL_A_CABLE_INF_SRC_TDR = 1,
	ETHTOOL_A_CABLE_INF_SRC_ALCD = 2,
};

enum {
	ETHTOOL_A_CABLE_NEST_UNSPEC = 0,
	ETHTOOL_A_CABLE_NEST_RESULT = 1,
	ETHTOOL_A_CABLE_NEST_FAULT_LENGTH = 2,
	__ETHTOOL_A_CABLE_NEST_CNT = 3,
	ETHTOOL_A_CABLE_NEST_MAX = 2,
};

enum {
	ETHTOOL_A_CABLE_PAIR_A = 0,
	ETHTOOL_A_CABLE_PAIR_B = 1,
	ETHTOOL_A_CABLE_PAIR_C = 2,
	ETHTOOL_A_CABLE_PAIR_D = 3,
};

enum {
	ETHTOOL_A_CABLE_PULSE_UNSPEC = 0,
	ETHTOOL_A_CABLE_PULSE_mV = 1,
	__ETHTOOL_A_CABLE_PULSE_CNT = 2,
	ETHTOOL_A_CABLE_PULSE_MAX = 1,
};

enum {
	ETHTOOL_A_CABLE_RESULT_UNSPEC = 0,
	ETHTOOL_A_CABLE_RESULT_PAIR = 1,
	ETHTOOL_A_CABLE_RESULT_CODE = 2,
	ETHTOOL_A_CABLE_RESULT_SRC = 3,
	__ETHTOOL_A_CABLE_RESULT_CNT = 4,
	ETHTOOL_A_CABLE_RESULT_MAX = 3,
};

enum {
	ETHTOOL_A_CABLE_STEP_UNSPEC = 0,
	ETHTOOL_A_CABLE_STEP_FIRST_DISTANCE = 1,
	ETHTOOL_A_CABLE_STEP_LAST_DISTANCE = 2,
	ETHTOOL_A_CABLE_STEP_STEP_DISTANCE = 3,
	__ETHTOOL_A_CABLE_STEP_CNT = 4,
	ETHTOOL_A_CABLE_STEP_MAX = 3,
};

enum {
	ETHTOOL_A_CABLE_TDR_NEST_UNSPEC = 0,
	ETHTOOL_A_CABLE_TDR_NEST_STEP = 1,
	ETHTOOL_A_CABLE_TDR_NEST_AMPLITUDE = 2,
	ETHTOOL_A_CABLE_TDR_NEST_PULSE = 3,
	__ETHTOOL_A_CABLE_TDR_NEST_CNT = 4,
	ETHTOOL_A_CABLE_TDR_NEST_MAX = 3,
};

enum {
	ETHTOOL_A_CABLE_TEST_NTF_STATUS_UNSPEC = 0,
	ETHTOOL_A_CABLE_TEST_NTF_STATUS_STARTED = 1,
	ETHTOOL_A_CABLE_TEST_NTF_STATUS_COMPLETED = 2,
};

enum {
	ETHTOOL_A_CABLE_TEST_NTF_UNSPEC = 0,
	ETHTOOL_A_CABLE_TEST_NTF_HEADER = 1,
	ETHTOOL_A_CABLE_TEST_NTF_STATUS = 2,
	ETHTOOL_A_CABLE_TEST_NTF_NEST = 3,
	__ETHTOOL_A_CABLE_TEST_NTF_CNT = 4,
	ETHTOOL_A_CABLE_TEST_NTF_MAX = 3,
};

enum {
	ETHTOOL_A_CABLE_TEST_TDR_CFG_UNSPEC = 0,
	ETHTOOL_A_CABLE_TEST_TDR_CFG_FIRST = 1,
	ETHTOOL_A_CABLE_TEST_TDR_CFG_LAST = 2,
	ETHTOOL_A_CABLE_TEST_TDR_CFG_STEP = 3,
	ETHTOOL_A_CABLE_TEST_TDR_CFG_PAIR = 4,
	__ETHTOOL_A_CABLE_TEST_TDR_CFG_CNT = 5,
	ETHTOOL_A_CABLE_TEST_TDR_CFG_MAX = 4,
};

enum {
	ETHTOOL_A_CABLE_TEST_TDR_UNSPEC = 0,
	ETHTOOL_A_CABLE_TEST_TDR_HEADER = 1,
	ETHTOOL_A_CABLE_TEST_TDR_CFG = 2,
	__ETHTOOL_A_CABLE_TEST_TDR_CNT = 3,
	ETHTOOL_A_CABLE_TEST_TDR_MAX = 2,
};

enum {
	ETHTOOL_A_CABLE_TEST_UNSPEC = 0,
	ETHTOOL_A_CABLE_TEST_HEADER = 1,
	__ETHTOOL_A_CABLE_TEST_CNT = 2,
	ETHTOOL_A_CABLE_TEST_MAX = 1,
};

enum {
	ETHTOOL_A_CHANNELS_UNSPEC = 0,
	ETHTOOL_A_CHANNELS_HEADER = 1,
	ETHTOOL_A_CHANNELS_RX_MAX = 2,
	ETHTOOL_A_CHANNELS_TX_MAX = 3,
	ETHTOOL_A_CHANNELS_OTHER_MAX = 4,
	ETHTOOL_A_CHANNELS_COMBINED_MAX = 5,
	ETHTOOL_A_CHANNELS_RX_COUNT = 6,
	ETHTOOL_A_CHANNELS_TX_COUNT = 7,
	ETHTOOL_A_CHANNELS_OTHER_COUNT = 8,
	ETHTOOL_A_CHANNELS_COMBINED_COUNT = 9,
	__ETHTOOL_A_CHANNELS_CNT = 10,
	ETHTOOL_A_CHANNELS_MAX = 9,
};

enum {
	ETHTOOL_A_COALESCE_UNSPEC = 0,
	ETHTOOL_A_COALESCE_HEADER = 1,
	ETHTOOL_A_COALESCE_RX_USECS = 2,
	ETHTOOL_A_COALESCE_RX_MAX_FRAMES = 3,
	ETHTOOL_A_COALESCE_RX_USECS_IRQ = 4,
	ETHTOOL_A_COALESCE_RX_MAX_FRAMES_IRQ = 5,
	ETHTOOL_A_COALESCE_TX_USECS = 6,
	ETHTOOL_A_COALESCE_TX_MAX_FRAMES = 7,
	ETHTOOL_A_COALESCE_TX_USECS_IRQ = 8,
	ETHTOOL_A_COALESCE_TX_MAX_FRAMES_IRQ = 9,
	ETHTOOL_A_COALESCE_STATS_BLOCK_USECS = 10,
	ETHTOOL_A_COALESCE_USE_ADAPTIVE_RX = 11,
	ETHTOOL_A_COALESCE_USE_ADAPTIVE_TX = 12,
	ETHTOOL_A_COALESCE_PKT_RATE_LOW = 13,
	ETHTOOL_A_COALESCE_RX_USECS_LOW = 14,
	ETHTOOL_A_COALESCE_RX_MAX_FRAMES_LOW = 15,
	ETHTOOL_A_COALESCE_TX_USECS_LOW = 16,
	ETHTOOL_A_COALESCE_TX_MAX_FRAMES_LOW = 17,
	ETHTOOL_A_COALESCE_PKT_RATE_HIGH = 18,
	ETHTOOL_A_COALESCE_RX_USECS_HIGH = 19,
	ETHTOOL_A_COALESCE_RX_MAX_FRAMES_HIGH = 20,
	ETHTOOL_A_COALESCE_TX_USECS_HIGH = 21,
	ETHTOOL_A_COALESCE_TX_MAX_FRAMES_HIGH = 22,
	ETHTOOL_A_COALESCE_RATE_SAMPLE_INTERVAL = 23,
	ETHTOOL_A_COALESCE_USE_CQE_MODE_TX = 24,
	ETHTOOL_A_COALESCE_USE_CQE_MODE_RX = 25,
	ETHTOOL_A_COALESCE_TX_AGGR_MAX_BYTES = 26,
	ETHTOOL_A_COALESCE_TX_AGGR_MAX_FRAMES = 27,
	ETHTOOL_A_COALESCE_TX_AGGR_TIME_USECS = 28,
	ETHTOOL_A_COALESCE_RX_PROFILE = 29,
	ETHTOOL_A_COALESCE_TX_PROFILE = 30,
	__ETHTOOL_A_COALESCE_CNT = 31,
	ETHTOOL_A_COALESCE_MAX = 30,
};

enum {
	ETHTOOL_A_DEBUG_UNSPEC = 0,
	ETHTOOL_A_DEBUG_HEADER = 1,
	ETHTOOL_A_DEBUG_MSGMASK = 2,
	__ETHTOOL_A_DEBUG_CNT = 3,
	ETHTOOL_A_DEBUG_MAX = 2,
};

enum {
	ETHTOOL_A_EEE_UNSPEC = 0,
	ETHTOOL_A_EEE_HEADER = 1,
	ETHTOOL_A_EEE_MODES_OURS = 2,
	ETHTOOL_A_EEE_MODES_PEER = 3,
	ETHTOOL_A_EEE_ACTIVE = 4,
	ETHTOOL_A_EEE_ENABLED = 5,
	ETHTOOL_A_EEE_TX_LPI_ENABLED = 6,
	ETHTOOL_A_EEE_TX_LPI_TIMER = 7,
	__ETHTOOL_A_EEE_CNT = 8,
	ETHTOOL_A_EEE_MAX = 7,
};

enum {
	ETHTOOL_A_FEATURES_UNSPEC = 0,
	ETHTOOL_A_FEATURES_HEADER = 1,
	ETHTOOL_A_FEATURES_HW = 2,
	ETHTOOL_A_FEATURES_WANTED = 3,
	ETHTOOL_A_FEATURES_ACTIVE = 4,
	ETHTOOL_A_FEATURES_NOCHANGE = 5,
	__ETHTOOL_A_FEATURES_CNT = 6,
	ETHTOOL_A_FEATURES_MAX = 5,
};

enum {
	ETHTOOL_A_FEC_STAT_UNSPEC = 0,
	ETHTOOL_A_FEC_STAT_PAD = 1,
	ETHTOOL_A_FEC_STAT_CORRECTED = 2,
	ETHTOOL_A_FEC_STAT_UNCORR = 3,
	ETHTOOL_A_FEC_STAT_CORR_BITS = 4,
	__ETHTOOL_A_FEC_STAT_CNT = 5,
	ETHTOOL_A_FEC_STAT_MAX = 4,
};

enum {
	ETHTOOL_A_FEC_UNSPEC = 0,
	ETHTOOL_A_FEC_HEADER = 1,
	ETHTOOL_A_FEC_MODES = 2,
	ETHTOOL_A_FEC_AUTO = 3,
	ETHTOOL_A_FEC_ACTIVE = 4,
	ETHTOOL_A_FEC_STATS = 5,
	__ETHTOOL_A_FEC_CNT = 6,
	ETHTOOL_A_FEC_MAX = 5,
};

enum {
	ETHTOOL_A_HEADER_UNSPEC = 0,
	ETHTOOL_A_HEADER_DEV_INDEX = 1,
	ETHTOOL_A_HEADER_DEV_NAME = 2,
	ETHTOOL_A_HEADER_FLAGS = 3,
	ETHTOOL_A_HEADER_PHY_INDEX = 4,
	__ETHTOOL_A_HEADER_CNT = 5,
	ETHTOOL_A_HEADER_MAX = 4,
};

enum {
	ETHTOOL_A_IRQ_MODERATION_UNSPEC = 0,
	ETHTOOL_A_IRQ_MODERATION_USEC = 1,
	ETHTOOL_A_IRQ_MODERATION_PKTS = 2,
	ETHTOOL_A_IRQ_MODERATION_COMPS = 3,
	__ETHTOOL_A_IRQ_MODERATION_CNT = 4,
	ETHTOOL_A_IRQ_MODERATION_MAX = 3,
};

enum {
	ETHTOOL_A_LINKINFO_UNSPEC = 0,
	ETHTOOL_A_LINKINFO_HEADER = 1,
	ETHTOOL_A_LINKINFO_PORT = 2,
	ETHTOOL_A_LINKINFO_PHYADDR = 3,
	ETHTOOL_A_LINKINFO_TP_MDIX = 4,
	ETHTOOL_A_LINKINFO_TP_MDIX_CTRL = 5,
	ETHTOOL_A_LINKINFO_TRANSCEIVER = 6,
	__ETHTOOL_A_LINKINFO_CNT = 7,
	ETHTOOL_A_LINKINFO_MAX = 6,
};

enum {
	ETHTOOL_A_LINKMODES_UNSPEC = 0,
	ETHTOOL_A_LINKMODES_HEADER = 1,
	ETHTOOL_A_LINKMODES_AUTONEG = 2,
	ETHTOOL_A_LINKMODES_OURS = 3,
	ETHTOOL_A_LINKMODES_PEER = 4,
	ETHTOOL_A_LINKMODES_SPEED = 5,
	ETHTOOL_A_LINKMODES_DUPLEX = 6,
	ETHTOOL_A_LINKMODES_MASTER_SLAVE_CFG = 7,
	ETHTOOL_A_LINKMODES_MASTER_SLAVE_STATE = 8,
	ETHTOOL_A_LINKMODES_LANES = 9,
	ETHTOOL_A_LINKMODES_RATE_MATCHING = 10,
	__ETHTOOL_A_LINKMODES_CNT = 11,
	ETHTOOL_A_LINKMODES_MAX = 10,
};

enum {
	ETHTOOL_A_LINKSTATE_UNSPEC = 0,
	ETHTOOL_A_LINKSTATE_HEADER = 1,
	ETHTOOL_A_LINKSTATE_LINK = 2,
	ETHTOOL_A_LINKSTATE_SQI = 3,
	ETHTOOL_A_LINKSTATE_SQI_MAX = 4,
	ETHTOOL_A_LINKSTATE_EXT_STATE = 5,
	ETHTOOL_A_LINKSTATE_EXT_SUBSTATE = 6,
	ETHTOOL_A_LINKSTATE_EXT_DOWN_CNT = 7,
	__ETHTOOL_A_LINKSTATE_CNT = 8,
	ETHTOOL_A_LINKSTATE_MAX = 7,
};

enum {
	ETHTOOL_A_MM_STAT_UNSPEC = 0,
	ETHTOOL_A_MM_STAT_PAD = 1,
	ETHTOOL_A_MM_STAT_REASSEMBLY_ERRORS = 2,
	ETHTOOL_A_MM_STAT_SMD_ERRORS = 3,
	ETHTOOL_A_MM_STAT_REASSEMBLY_OK = 4,
	ETHTOOL_A_MM_STAT_RX_FRAG_COUNT = 5,
	ETHTOOL_A_MM_STAT_TX_FRAG_COUNT = 6,
	ETHTOOL_A_MM_STAT_HOLD_COUNT = 7,
	__ETHTOOL_A_MM_STAT_CNT = 8,
	ETHTOOL_A_MM_STAT_MAX = 7,
};

enum {
	ETHTOOL_A_MM_UNSPEC = 0,
	ETHTOOL_A_MM_HEADER = 1,
	ETHTOOL_A_MM_PMAC_ENABLED = 2,
	ETHTOOL_A_MM_TX_ENABLED = 3,
	ETHTOOL_A_MM_TX_ACTIVE = 4,
	ETHTOOL_A_MM_TX_MIN_FRAG_SIZE = 5,
	ETHTOOL_A_MM_RX_MIN_FRAG_SIZE = 6,
	ETHTOOL_A_MM_VERIFY_ENABLED = 7,
	ETHTOOL_A_MM_VERIFY_STATUS = 8,
	ETHTOOL_A_MM_VERIFY_TIME = 9,
	ETHTOOL_A_MM_MAX_VERIFY_TIME = 10,
	ETHTOOL_A_MM_STATS = 11,
	__ETHTOOL_A_MM_CNT = 12,
	ETHTOOL_A_MM_MAX = 11,
};

enum {
	ETHTOOL_A_MODULE_EEPROM_UNSPEC = 0,
	ETHTOOL_A_MODULE_EEPROM_HEADER = 1,
	ETHTOOL_A_MODULE_EEPROM_OFFSET = 2,
	ETHTOOL_A_MODULE_EEPROM_LENGTH = 3,
	ETHTOOL_A_MODULE_EEPROM_PAGE = 4,
	ETHTOOL_A_MODULE_EEPROM_BANK = 5,
	ETHTOOL_A_MODULE_EEPROM_I2C_ADDRESS = 6,
	ETHTOOL_A_MODULE_EEPROM_DATA = 7,
	__ETHTOOL_A_MODULE_EEPROM_CNT = 8,
	ETHTOOL_A_MODULE_EEPROM_MAX = 7,
};

enum {
	ETHTOOL_A_MODULE_FW_FLASH_UNSPEC = 0,
	ETHTOOL_A_MODULE_FW_FLASH_HEADER = 1,
	ETHTOOL_A_MODULE_FW_FLASH_FILE_NAME = 2,
	ETHTOOL_A_MODULE_FW_FLASH_PASSWORD = 3,
	ETHTOOL_A_MODULE_FW_FLASH_STATUS = 4,
	ETHTOOL_A_MODULE_FW_FLASH_STATUS_MSG = 5,
	ETHTOOL_A_MODULE_FW_FLASH_DONE = 6,
	ETHTOOL_A_MODULE_FW_FLASH_TOTAL = 7,
	__ETHTOOL_A_MODULE_FW_FLASH_CNT = 8,
	ETHTOOL_A_MODULE_FW_FLASH_MAX = 7,
};

enum {
	ETHTOOL_A_MODULE_UNSPEC = 0,
	ETHTOOL_A_MODULE_HEADER = 1,
	ETHTOOL_A_MODULE_POWER_MODE_POLICY = 2,
	ETHTOOL_A_MODULE_POWER_MODE = 3,
	__ETHTOOL_A_MODULE_CNT = 4,
	ETHTOOL_A_MODULE_MAX = 3,
};

enum {
	ETHTOOL_A_PAUSE_STAT_UNSPEC = 0,
	ETHTOOL_A_PAUSE_STAT_PAD = 1,
	ETHTOOL_A_PAUSE_STAT_TX_FRAMES = 2,
	ETHTOOL_A_PAUSE_STAT_RX_FRAMES = 3,
	__ETHTOOL_A_PAUSE_STAT_CNT = 4,
	ETHTOOL_A_PAUSE_STAT_MAX = 3,
};

enum {
	ETHTOOL_A_PAUSE_UNSPEC = 0,
	ETHTOOL_A_PAUSE_HEADER = 1,
	ETHTOOL_A_PAUSE_AUTONEG = 2,
	ETHTOOL_A_PAUSE_RX = 3,
	ETHTOOL_A_PAUSE_TX = 4,
	ETHTOOL_A_PAUSE_STATS = 5,
	ETHTOOL_A_PAUSE_STATS_SRC = 6,
	__ETHTOOL_A_PAUSE_CNT = 7,
	ETHTOOL_A_PAUSE_MAX = 6,
};

enum {
	ETHTOOL_A_PHC_VCLOCKS_UNSPEC = 0,
	ETHTOOL_A_PHC_VCLOCKS_HEADER = 1,
	ETHTOOL_A_PHC_VCLOCKS_NUM = 2,
	ETHTOOL_A_PHC_VCLOCKS_INDEX = 3,
	__ETHTOOL_A_PHC_VCLOCKS_CNT = 4,
	ETHTOOL_A_PHC_VCLOCKS_MAX = 3,
};

enum {
	ETHTOOL_A_PHY_UNSPEC = 0,
	ETHTOOL_A_PHY_HEADER = 1,
	ETHTOOL_A_PHY_INDEX = 2,
	ETHTOOL_A_PHY_DRVNAME = 3,
	ETHTOOL_A_PHY_NAME = 4,
	ETHTOOL_A_PHY_UPSTREAM_TYPE = 5,
	ETHTOOL_A_PHY_UPSTREAM_INDEX = 6,
	ETHTOOL_A_PHY_UPSTREAM_SFP_NAME = 7,
	ETHTOOL_A_PHY_DOWNSTREAM_SFP_NAME = 8,
	__ETHTOOL_A_PHY_CNT = 9,
	ETHTOOL_A_PHY_MAX = 8,
};

enum {
	ETHTOOL_A_PLCA_UNSPEC = 0,
	ETHTOOL_A_PLCA_HEADER = 1,
	ETHTOOL_A_PLCA_VERSION = 2,
	ETHTOOL_A_PLCA_ENABLED = 3,
	ETHTOOL_A_PLCA_STATUS = 4,
	ETHTOOL_A_PLCA_NODE_CNT = 5,
	ETHTOOL_A_PLCA_NODE_ID = 6,
	ETHTOOL_A_PLCA_TO_TMR = 7,
	ETHTOOL_A_PLCA_BURST_CNT = 8,
	ETHTOOL_A_PLCA_BURST_TMR = 9,
	__ETHTOOL_A_PLCA_CNT = 10,
	ETHTOOL_A_PLCA_MAX = 9,
};

enum {
	ETHTOOL_A_PRIVFLAGS_UNSPEC = 0,
	ETHTOOL_A_PRIVFLAGS_HEADER = 1,
	ETHTOOL_A_PRIVFLAGS_FLAGS = 2,
	__ETHTOOL_A_PRIVFLAGS_CNT = 3,
	ETHTOOL_A_PRIVFLAGS_MAX = 2,
};

enum {
	ETHTOOL_A_PROFILE_UNSPEC = 0,
	ETHTOOL_A_PROFILE_IRQ_MODERATION = 1,
	__ETHTOOL_A_PROFILE_CNT = 2,
	ETHTOOL_A_PROFILE_MAX = 1,
};

enum {
	ETHTOOL_A_PSE_UNSPEC = 0,
	ETHTOOL_A_PSE_HEADER = 1,
	ETHTOOL_A_PODL_PSE_ADMIN_STATE = 2,
	ETHTOOL_A_PODL_PSE_ADMIN_CONTROL = 3,
	ETHTOOL_A_PODL_PSE_PW_D_STATUS = 4,
	ETHTOOL_A_C33_PSE_ADMIN_STATE = 5,
	ETHTOOL_A_C33_PSE_ADMIN_CONTROL = 6,
	ETHTOOL_A_C33_PSE_PW_D_STATUS = 7,
	ETHTOOL_A_C33_PSE_PW_CLASS = 8,
	ETHTOOL_A_C33_PSE_ACTUAL_PW = 9,
	ETHTOOL_A_C33_PSE_EXT_STATE = 10,
	ETHTOOL_A_C33_PSE_EXT_SUBSTATE = 11,
	ETHTOOL_A_C33_PSE_AVAIL_PW_LIMIT = 12,
	ETHTOOL_A_C33_PSE_PW_LIMIT_RANGES = 13,
	__ETHTOOL_A_PSE_CNT = 14,
	ETHTOOL_A_PSE_MAX = 13,
};

enum {
	ETHTOOL_A_RINGS_UNSPEC = 0,
	ETHTOOL_A_RINGS_HEADER = 1,
	ETHTOOL_A_RINGS_RX_MAX = 2,
	ETHTOOL_A_RINGS_RX_MINI_MAX = 3,
	ETHTOOL_A_RINGS_RX_JUMBO_MAX = 4,
	ETHTOOL_A_RINGS_TX_MAX = 5,
	ETHTOOL_A_RINGS_RX = 6,
	ETHTOOL_A_RINGS_RX_MINI = 7,
	ETHTOOL_A_RINGS_RX_JUMBO = 8,
	ETHTOOL_A_RINGS_TX = 9,
	ETHTOOL_A_RINGS_RX_BUF_LEN = 10,
	ETHTOOL_A_RINGS_TCP_DATA_SPLIT = 11,
	ETHTOOL_A_RINGS_CQE_SIZE = 12,
	ETHTOOL_A_RINGS_TX_PUSH = 13,
	ETHTOOL_A_RINGS_RX_PUSH = 14,
	ETHTOOL_A_RINGS_TX_PUSH_BUF_LEN = 15,
	ETHTOOL_A_RINGS_TX_PUSH_BUF_LEN_MAX = 16,
	ETHTOOL_A_RINGS_HDS_THRESH = 17,
	ETHTOOL_A_RINGS_HDS_THRESH_MAX = 18,
	__ETHTOOL_A_RINGS_CNT = 19,
	ETHTOOL_A_RINGS_MAX = 18,
};

enum {
	ETHTOOL_A_RSS_UNSPEC = 0,
	ETHTOOL_A_RSS_HEADER = 1,
	ETHTOOL_A_RSS_CONTEXT = 2,
	ETHTOOL_A_RSS_HFUNC = 3,
	ETHTOOL_A_RSS_INDIR = 4,
	ETHTOOL_A_RSS_HKEY = 5,
	ETHTOOL_A_RSS_INPUT_XFRM = 6,
	ETHTOOL_A_RSS_START_CONTEXT = 7,
	__ETHTOOL_A_RSS_CNT = 8,
	ETHTOOL_A_RSS_MAX = 7,
};

enum {
	ETHTOOL_A_STATS_ETH_CTRL_3_TX = 0,
	ETHTOOL_A_STATS_ETH_CTRL_4_RX = 1,
	ETHTOOL_A_STATS_ETH_CTRL_5_RX_UNSUP = 2,
	__ETHTOOL_A_STATS_ETH_CTRL_CNT = 3,
	ETHTOOL_A_STATS_ETH_CTRL_MAX = 2,
};

enum {
	ETHTOOL_A_STATS_ETH_MAC_2_TX_PKT = 0,
	ETHTOOL_A_STATS_ETH_MAC_3_SINGLE_COL = 1,
	ETHTOOL_A_STATS_ETH_MAC_4_MULTI_COL = 2,
	ETHTOOL_A_STATS_ETH_MAC_5_RX_PKT = 3,
	ETHTOOL_A_STATS_ETH_MAC_6_FCS_ERR = 4,
	ETHTOOL_A_STATS_ETH_MAC_7_ALIGN_ERR = 5,
	ETHTOOL_A_STATS_ETH_MAC_8_TX_BYTES = 6,
	ETHTOOL_A_STATS_ETH_MAC_9_TX_DEFER = 7,
	ETHTOOL_A_STATS_ETH_MAC_10_LATE_COL = 8,
	ETHTOOL_A_STATS_ETH_MAC_11_XS_COL = 9,
	ETHTOOL_A_STATS_ETH_MAC_12_TX_INT_ERR = 10,
	ETHTOOL_A_STATS_ETH_MAC_13_CS_ERR = 11,
	ETHTOOL_A_STATS_ETH_MAC_14_RX_BYTES = 12,
	ETHTOOL_A_STATS_ETH_MAC_15_RX_INT_ERR = 13,
	ETHTOOL_A_STATS_ETH_MAC_18_TX_MCAST = 14,
	ETHTOOL_A_STATS_ETH_MAC_19_TX_BCAST = 15,
	ETHTOOL_A_STATS_ETH_MAC_20_XS_DEFER = 16,
	ETHTOOL_A_STATS_ETH_MAC_21_RX_MCAST = 17,
	ETHTOOL_A_STATS_ETH_MAC_22_RX_BCAST = 18,
	ETHTOOL_A_STATS_ETH_MAC_23_IR_LEN_ERR = 19,
	ETHTOOL_A_STATS_ETH_MAC_24_OOR_LEN = 20,
	ETHTOOL_A_STATS_ETH_MAC_25_TOO_LONG_ERR = 21,
	__ETHTOOL_A_STATS_ETH_MAC_CNT = 22,
	ETHTOOL_A_STATS_ETH_MAC_MAX = 21,
};

enum {
	ETHTOOL_A_STATS_ETH_PHY_5_SYM_ERR = 0,
	__ETHTOOL_A_STATS_ETH_PHY_CNT = 1,
	ETHTOOL_A_STATS_ETH_PHY_MAX = 0,
};

enum {
	ETHTOOL_A_STATS_GRP_UNSPEC = 0,
	ETHTOOL_A_STATS_GRP_PAD = 1,
	ETHTOOL_A_STATS_GRP_ID = 2,
	ETHTOOL_A_STATS_GRP_SS_ID = 3,
	ETHTOOL_A_STATS_GRP_STAT = 4,
	ETHTOOL_A_STATS_GRP_HIST_RX = 5,
	ETHTOOL_A_STATS_GRP_HIST_TX = 6,
	ETHTOOL_A_STATS_GRP_HIST_BKT_LOW = 7,
	ETHTOOL_A_STATS_GRP_HIST_BKT_HI = 8,
	ETHTOOL_A_STATS_GRP_HIST_VAL = 9,
	__ETHTOOL_A_STATS_GRP_CNT = 10,
	ETHTOOL_A_STATS_GRP_MAX = 9,
};

enum {
	ETHTOOL_A_STATS_PHY_RX_PKTS = 0,
	ETHTOOL_A_STATS_PHY_RX_BYTES = 1,
	ETHTOOL_A_STATS_PHY_RX_ERRORS = 2,
	ETHTOOL_A_STATS_PHY_TX_PKTS = 3,
	ETHTOOL_A_STATS_PHY_TX_BYTES = 4,
	ETHTOOL_A_STATS_PHY_TX_ERRORS = 5,
	__ETHTOOL_A_STATS_PHY_CNT = 6,
	ETHTOOL_A_STATS_PHY_MAX = 5,
};

enum {
	ETHTOOL_A_STATS_RMON_UNDERSIZE = 0,
	ETHTOOL_A_STATS_RMON_OVERSIZE = 1,
	ETHTOOL_A_STATS_RMON_FRAG = 2,
	ETHTOOL_A_STATS_RMON_JABBER = 3,
	__ETHTOOL_A_STATS_RMON_CNT = 4,
	ETHTOOL_A_STATS_RMON_MAX = 3,
};

enum {
	ETHTOOL_A_STATS_UNSPEC = 0,
	ETHTOOL_A_STATS_PAD = 1,
	ETHTOOL_A_STATS_HEADER = 2,
	ETHTOOL_A_STATS_GROUPS = 3,
	ETHTOOL_A_STATS_GRP = 4,
	ETHTOOL_A_STATS_SRC = 5,
	__ETHTOOL_A_STATS_CNT = 6,
	ETHTOOL_A_STATS_MAX = 5,
};

enum {
	ETHTOOL_A_STRINGSETS_UNSPEC = 0,
	ETHTOOL_A_STRINGSETS_STRINGSET = 1,
	__ETHTOOL_A_STRINGSETS_CNT = 2,
	ETHTOOL_A_STRINGSETS_MAX = 1,
};

enum {
	ETHTOOL_A_STRINGSET_UNSPEC = 0,
	ETHTOOL_A_STRINGSET_ID = 1,
	ETHTOOL_A_STRINGSET_COUNT = 2,
	ETHTOOL_A_STRINGSET_STRINGS = 3,
	__ETHTOOL_A_STRINGSET_CNT = 4,
	ETHTOOL_A_STRINGSET_MAX = 3,
};

enum {
	ETHTOOL_A_STRINGS_UNSPEC = 0,
	ETHTOOL_A_STRINGS_STRING = 1,
	__ETHTOOL_A_STRINGS_CNT = 2,
	ETHTOOL_A_STRINGS_MAX = 1,
};

enum {
	ETHTOOL_A_STRING_UNSPEC = 0,
	ETHTOOL_A_STRING_INDEX = 1,
	ETHTOOL_A_STRING_VALUE = 2,
	__ETHTOOL_A_STRING_CNT = 3,
	ETHTOOL_A_STRING_MAX = 2,
};

enum {
	ETHTOOL_A_STRSET_UNSPEC = 0,
	ETHTOOL_A_STRSET_HEADER = 1,
	ETHTOOL_A_STRSET_STRINGSETS = 2,
	ETHTOOL_A_STRSET_COUNTS_ONLY = 3,
	__ETHTOOL_A_STRSET_CNT = 4,
	ETHTOOL_A_STRSET_MAX = 3,
};

enum {
	ETHTOOL_A_TSCONFIG_UNSPEC = 0,
	ETHTOOL_A_TSCONFIG_HEADER = 1,
	ETHTOOL_A_TSCONFIG_HWTSTAMP_PROVIDER = 2,
	ETHTOOL_A_TSCONFIG_TX_TYPES = 3,
	ETHTOOL_A_TSCONFIG_RX_FILTERS = 4,
	ETHTOOL_A_TSCONFIG_HWTSTAMP_FLAGS = 5,
	__ETHTOOL_A_TSCONFIG_CNT = 6,
	ETHTOOL_A_TSCONFIG_MAX = 5,
};

enum {
	ETHTOOL_A_TSINFO_UNSPEC = 0,
	ETHTOOL_A_TSINFO_HEADER = 1,
	ETHTOOL_A_TSINFO_TIMESTAMPING = 2,
	ETHTOOL_A_TSINFO_TX_TYPES = 3,
	ETHTOOL_A_TSINFO_RX_FILTERS = 4,
	ETHTOOL_A_TSINFO_PHC_INDEX = 5,
	ETHTOOL_A_TSINFO_STATS = 6,
	ETHTOOL_A_TSINFO_HWTSTAMP_PROVIDER = 7,
	__ETHTOOL_A_TSINFO_CNT = 8,
	ETHTOOL_A_TSINFO_MAX = 7,
};

enum {
	ETHTOOL_A_TS_HWTSTAMP_PROVIDER_UNSPEC = 0,
	ETHTOOL_A_TS_HWTSTAMP_PROVIDER_INDEX = 1,
	ETHTOOL_A_TS_HWTSTAMP_PROVIDER_QUALIFIER = 2,
	__ETHTOOL_A_TS_HWTSTAMP_PROVIDER_CNT = 3,
	ETHTOOL_A_TS_HWTSTAMP_PROVIDER_MAX = 2,
};

enum {
	ETHTOOL_A_TS_STAT_UNSPEC = 0,
	ETHTOOL_A_TS_STAT_TX_PKTS = 1,
	ETHTOOL_A_TS_STAT_TX_LOST = 2,
	ETHTOOL_A_TS_STAT_TX_ERR = 3,
	ETHTOOL_A_TS_STAT_TX_ONESTEP_PKTS_UNCONFIRMED = 4,
	__ETHTOOL_A_TS_STAT_CNT = 5,
	ETHTOOL_A_TS_STAT_MAX = 4,
};

enum {
	ETHTOOL_A_TUNNEL_INFO_UNSPEC = 0,
	ETHTOOL_A_TUNNEL_INFO_HEADER = 1,
	ETHTOOL_A_TUNNEL_INFO_UDP_PORTS = 2,
	__ETHTOOL_A_TUNNEL_INFO_CNT = 3,
	ETHTOOL_A_TUNNEL_INFO_MAX = 2,
};

enum {
	ETHTOOL_A_TUNNEL_UDP_ENTRY_UNSPEC = 0,
	ETHTOOL_A_TUNNEL_UDP_ENTRY_PORT = 1,
	ETHTOOL_A_TUNNEL_UDP_ENTRY_TYPE = 2,
	__ETHTOOL_A_TUNNEL_UDP_ENTRY_CNT = 3,
	ETHTOOL_A_TUNNEL_UDP_ENTRY_MAX = 2,
};

enum {
	ETHTOOL_A_TUNNEL_UDP_TABLE_UNSPEC = 0,
	ETHTOOL_A_TUNNEL_UDP_TABLE_SIZE = 1,
	ETHTOOL_A_TUNNEL_UDP_TABLE_TYPES = 2,
	ETHTOOL_A_TUNNEL_UDP_TABLE_ENTRY = 3,
	__ETHTOOL_A_TUNNEL_UDP_TABLE_CNT = 4,
	ETHTOOL_A_TUNNEL_UDP_TABLE_MAX = 3,
};

enum {
	ETHTOOL_A_TUNNEL_UDP_UNSPEC = 0,
	ETHTOOL_A_TUNNEL_UDP_TABLE = 1,
	__ETHTOOL_A_TUNNEL_UDP_CNT = 2,
	ETHTOOL_A_TUNNEL_UDP_MAX = 1,
};

enum {
	ETHTOOL_A_WOL_UNSPEC = 0,
	ETHTOOL_A_WOL_HEADER = 1,
	ETHTOOL_A_WOL_MODES = 2,
	ETHTOOL_A_WOL_SOPASS = 3,
	__ETHTOOL_A_WOL_CNT = 4,
	ETHTOOL_A_WOL_MAX = 3,
};

enum {
	ETHTOOL_MSG_KERNEL_NONE = 0,
	ETHTOOL_MSG_STRSET_GET_REPLY = 1,
	ETHTOOL_MSG_LINKINFO_GET_REPLY = 2,
	ETHTOOL_MSG_LINKINFO_NTF = 3,
	ETHTOOL_MSG_LINKMODES_GET_REPLY = 4,
	ETHTOOL_MSG_LINKMODES_NTF = 5,
	ETHTOOL_MSG_LINKSTATE_GET_REPLY = 6,
	ETHTOOL_MSG_DEBUG_GET_REPLY = 7,
	ETHTOOL_MSG_DEBUG_NTF = 8,
	ETHTOOL_MSG_WOL_GET_REPLY = 9,
	ETHTOOL_MSG_WOL_NTF = 10,
	ETHTOOL_MSG_FEATURES_GET_REPLY = 11,
	ETHTOOL_MSG_FEATURES_SET_REPLY = 12,
	ETHTOOL_MSG_FEATURES_NTF = 13,
	ETHTOOL_MSG_PRIVFLAGS_GET_REPLY = 14,
	ETHTOOL_MSG_PRIVFLAGS_NTF = 15,
	ETHTOOL_MSG_RINGS_GET_REPLY = 16,
	ETHTOOL_MSG_RINGS_NTF = 17,
	ETHTOOL_MSG_CHANNELS_GET_REPLY = 18,
	ETHTOOL_MSG_CHANNELS_NTF = 19,
	ETHTOOL_MSG_COALESCE_GET_REPLY = 20,
	ETHTOOL_MSG_COALESCE_NTF = 21,
	ETHTOOL_MSG_PAUSE_GET_REPLY = 22,
	ETHTOOL_MSG_PAUSE_NTF = 23,
	ETHTOOL_MSG_EEE_GET_REPLY = 24,
	ETHTOOL_MSG_EEE_NTF = 25,
	ETHTOOL_MSG_TSINFO_GET_REPLY = 26,
	ETHTOOL_MSG_CABLE_TEST_NTF = 27,
	ETHTOOL_MSG_CABLE_TEST_TDR_NTF = 28,
	ETHTOOL_MSG_TUNNEL_INFO_GET_REPLY = 29,
	ETHTOOL_MSG_FEC_GET_REPLY = 30,
	ETHTOOL_MSG_FEC_NTF = 31,
	ETHTOOL_MSG_MODULE_EEPROM_GET_REPLY = 32,
	ETHTOOL_MSG_STATS_GET_REPLY = 33,
	ETHTOOL_MSG_PHC_VCLOCKS_GET_REPLY = 34,
	ETHTOOL_MSG_MODULE_GET_REPLY = 35,
	ETHTOOL_MSG_MODULE_NTF = 36,
	ETHTOOL_MSG_PSE_GET_REPLY = 37,
	ETHTOOL_MSG_RSS_GET_REPLY = 38,
	ETHTOOL_MSG_PLCA_GET_CFG_REPLY = 39,
	ETHTOOL_MSG_PLCA_GET_STATUS_REPLY = 40,
	ETHTOOL_MSG_PLCA_NTF = 41,
	ETHTOOL_MSG_MM_GET_REPLY = 42,
	ETHTOOL_MSG_MM_NTF = 43,
	ETHTOOL_MSG_MODULE_FW_FLASH_NTF = 44,
	ETHTOOL_MSG_PHY_GET_REPLY = 45,
	ETHTOOL_MSG_PHY_NTF = 46,
	ETHTOOL_MSG_TSCONFIG_GET_REPLY = 47,
	ETHTOOL_MSG_TSCONFIG_SET_REPLY = 48,
	__ETHTOOL_MSG_KERNEL_CNT = 49,
	ETHTOOL_MSG_KERNEL_MAX = 48,
};

enum {
	ETHTOOL_MSG_USER_NONE = 0,
	ETHTOOL_MSG_STRSET_GET = 1,
	ETHTOOL_MSG_LINKINFO_GET = 2,
	ETHTOOL_MSG_LINKINFO_SET = 3,
	ETHTOOL_MSG_LINKMODES_GET = 4,
	ETHTOOL_MSG_LINKMODES_SET = 5,
	ETHTOOL_MSG_LINKSTATE_GET = 6,
	ETHTOOL_MSG_DEBUG_GET = 7,
	ETHTOOL_MSG_DEBUG_SET = 8,
	ETHTOOL_MSG_WOL_GET = 9,
	ETHTOOL_MSG_WOL_SET = 10,
	ETHTOOL_MSG_FEATURES_GET = 11,
	ETHTOOL_MSG_FEATURES_SET = 12,
	ETHTOOL_MSG_PRIVFLAGS_GET = 13,
	ETHTOOL_MSG_PRIVFLAGS_SET = 14,
	ETHTOOL_MSG_RINGS_GET = 15,
	ETHTOOL_MSG_RINGS_SET = 16,
	ETHTOOL_MSG_CHANNELS_GET = 17,
	ETHTOOL_MSG_CHANNELS_SET = 18,
	ETHTOOL_MSG_COALESCE_GET = 19,
	ETHTOOL_MSG_COALESCE_SET = 20,
	ETHTOOL_MSG_PAUSE_GET = 21,
	ETHTOOL_MSG_PAUSE_SET = 22,
	ETHTOOL_MSG_EEE_GET = 23,
	ETHTOOL_MSG_EEE_SET = 24,
	ETHTOOL_MSG_TSINFO_GET = 25,
	ETHTOOL_MSG_CABLE_TEST_ACT = 26,
	ETHTOOL_MSG_CABLE_TEST_TDR_ACT = 27,
	ETHTOOL_MSG_TUNNEL_INFO_GET = 28,
	ETHTOOL_MSG_FEC_GET = 29,
	ETHTOOL_MSG_FEC_SET = 30,
	ETHTOOL_MSG_MODULE_EEPROM_GET = 31,
	ETHTOOL_MSG_STATS_GET = 32,
	ETHTOOL_MSG_PHC_VCLOCKS_GET = 33,
	ETHTOOL_MSG_MODULE_GET = 34,
	ETHTOOL_MSG_MODULE_SET = 35,
	ETHTOOL_MSG_PSE_GET = 36,
	ETHTOOL_MSG_PSE_SET = 37,
	ETHTOOL_MSG_RSS_GET = 38,
	ETHTOOL_MSG_PLCA_GET_CFG = 39,
	ETHTOOL_MSG_PLCA_SET_CFG = 40,
	ETHTOOL_MSG_PLCA_GET_STATUS = 41,
	ETHTOOL_MSG_MM_GET = 42,
	ETHTOOL_MSG_MM_SET = 43,
	ETHTOOL_MSG_MODULE_FW_FLASH_ACT = 44,
	ETHTOOL_MSG_PHY_GET = 45,
	ETHTOOL_MSG_TSCONFIG_GET = 46,
	ETHTOOL_MSG_TSCONFIG_SET = 47,
	__ETHTOOL_MSG_USER_CNT = 48,
	ETHTOOL_MSG_USER_MAX = 47,
};

enum {
	ETHTOOL_STATS_ETH_PHY = 0,
	ETHTOOL_STATS_ETH_MAC = 1,
	ETHTOOL_STATS_ETH_CTRL = 2,
	ETHTOOL_STATS_RMON = 3,
	ETHTOOL_STATS_PHY = 4,
	__ETHTOOL_STATS_CNT = 5,
};

enum {
	ETHTOOL_UDP_TUNNEL_TYPE_VXLAN = 0,
	ETHTOOL_UDP_TUNNEL_TYPE_GENEVE = 1,
	ETHTOOL_UDP_TUNNEL_TYPE_VXLAN_GPE = 2,
	__ETHTOOL_UDP_TUNNEL_TYPE_CNT = 3,
	ETHTOOL_UDP_TUNNEL_TYPE_MAX = 2,
};

enum {
	ETH_RSS_HASH_TOP_BIT = 0,
	ETH_RSS_HASH_XOR_BIT = 1,
	ETH_RSS_HASH_CRC32_BIT = 2,
	ETH_RSS_HASH_FUNCS_COUNT = 3,
};

enum {
	EVENTFS_SAVE_MODE = 65536,
	EVENTFS_SAVE_UID = 131072,
	EVENTFS_SAVE_GID = 262144,
};

enum {
	EVENT_FILE_FL_ENABLED = 1,
	EVENT_FILE_FL_RECORDED_CMD = 2,
	EVENT_FILE_FL_RECORDED_TGID = 4,
	EVENT_FILE_FL_FILTERED = 8,
	EVENT_FILE_FL_NO_SET_FILTER = 16,
	EVENT_FILE_FL_SOFT_MODE = 32,
	EVENT_FILE_FL_SOFT_DISABLED = 64,
	EVENT_FILE_FL_TRIGGER_MODE = 128,
	EVENT_FILE_FL_TRIGGER_COND = 256,
	EVENT_FILE_FL_PID_FILTER = 512,
	EVENT_FILE_FL_WAS_ENABLED = 1024,
	EVENT_FILE_FL_FREED = 2048,
};

enum {
	EVENT_FILE_FL_ENABLED_BIT = 0,
	EVENT_FILE_FL_RECORDED_CMD_BIT = 1,
	EVENT_FILE_FL_RECORDED_TGID_BIT = 2,
	EVENT_FILE_FL_FILTERED_BIT = 3,
	EVENT_FILE_FL_NO_SET_FILTER_BIT = 4,
	EVENT_FILE_FL_SOFT_MODE_BIT = 5,
	EVENT_FILE_FL_SOFT_DISABLED_BIT = 6,
	EVENT_FILE_FL_TRIGGER_MODE_BIT = 7,
	EVENT_FILE_FL_TRIGGER_COND_BIT = 8,
	EVENT_FILE_FL_PID_FILTER_BIT = 9,
	EVENT_FILE_FL_WAS_ENABLED_BIT = 10,
	EVENT_FILE_FL_FREED_BIT = 11,
};

enum {
	EVENT_TRIGGER_FL_PROBE = 1,
};

enum {
	EXT4_FC_REASON_XATTR = 0,
	EXT4_FC_REASON_CROSS_RENAME = 1,
	EXT4_FC_REASON_JOURNAL_FLAG_CHANGE = 2,
	EXT4_FC_REASON_NOMEM = 3,
	EXT4_FC_REASON_SWAP_BOOT = 4,
	EXT4_FC_REASON_RESIZE = 5,
	EXT4_FC_REASON_RENAME_DIR = 6,
	EXT4_FC_REASON_FALLOC_RANGE = 7,
	EXT4_FC_REASON_INODE_JOURNAL_DATA = 8,
	EXT4_FC_REASON_ENCRYPTED_FILENAME = 9,
	EXT4_FC_REASON_MAX = 10,
};

enum {
	EXT4_FC_STATUS_OK = 0,
	EXT4_FC_STATUS_INELIGIBLE = 1,
	EXT4_FC_STATUS_SKIPPED = 2,
	EXT4_FC_STATUS_FAILED = 3,
};

enum {
	EXT4_INODE_SECRM = 0,
	EXT4_INODE_UNRM = 1,
	EXT4_INODE_COMPR = 2,
	EXT4_INODE_SYNC = 3,
	EXT4_INODE_IMMUTABLE = 4,
	EXT4_INODE_APPEND = 5,
	EXT4_INODE_NODUMP = 6,
	EXT4_INODE_NOATIME = 7,
	EXT4_INODE_DIRTY = 8,
	EXT4_INODE_COMPRBLK = 9,
	EXT4_INODE_NOCOMPR = 10,
	EXT4_INODE_ENCRYPT = 11,
	EXT4_INODE_INDEX = 12,
	EXT4_INODE_IMAGIC = 13,
	EXT4_INODE_JOURNAL_DATA = 14,
	EXT4_INODE_NOTAIL = 15,
	EXT4_INODE_DIRSYNC = 16,
	EXT4_INODE_TOPDIR = 17,
	EXT4_INODE_HUGE_FILE = 18,
	EXT4_INODE_EXTENTS = 19,
	EXT4_INODE_VERITY = 20,
	EXT4_INODE_EA_INODE = 21,
	EXT4_INODE_DAX = 25,
	EXT4_INODE_INLINE_DATA = 28,
	EXT4_INODE_PROJINHERIT = 29,
	EXT4_INODE_CASEFOLD = 30,
	EXT4_INODE_RESERVED = 31,
};

enum {
	EXT4_MF_MNTDIR_SAMPLED = 0,
	EXT4_MF_FC_INELIGIBLE = 1,
};

enum {
	EXT4_STATE_NEW = 0,
	EXT4_STATE_XATTR = 1,
	EXT4_STATE_NO_EXPAND = 2,
	EXT4_STATE_DA_ALLOC_CLOSE = 3,
	EXT4_STATE_EXT_MIGRATE = 4,
	EXT4_STATE_NEWENTRY = 5,
	EXT4_STATE_MAY_INLINE_DATA = 6,
	EXT4_STATE_EXT_PRECACHED = 7,
	EXT4_STATE_LUSTRE_EA_INODE = 8,
	EXT4_STATE_VERITY_IN_PROGRESS = 9,
	EXT4_STATE_FC_COMMITTING = 10,
	EXT4_STATE_ORPHAN_FILE = 11,
};

enum {
	EXTRA_REG_NHMEX_M_FILTER = 0,
	EXTRA_REG_NHMEX_M_DSP = 1,
	EXTRA_REG_NHMEX_M_ISS = 2,
	EXTRA_REG_NHMEX_M_MAP = 3,
	EXTRA_REG_NHMEX_M_MSC_THR = 4,
	EXTRA_REG_NHMEX_M_PGT = 5,
	EXTRA_REG_NHMEX_M_PLD = 6,
	EXTRA_REG_NHMEX_M_ZDP_CTL_FVC = 7,
};

enum {
	Enabled = 0,
	Magic = 1,
};

enum {
	FATTR4_CLONE_BLKSIZE = 77,
	FATTR4_SPACE_FREED = 78,
	FATTR4_CHANGE_ATTR_TYPE = 79,
	FATTR4_SEC_LABEL = 80,
};

enum {
	FATTR4_DIR_NOTIF_DELAY = 56,
	FATTR4_DIRENT_NOTIF_DELAY = 57,
	FATTR4_DACL = 58,
	FATTR4_SACL = 59,
	FATTR4_CHANGE_POLICY = 60,
	FATTR4_FS_STATUS = 61,
	FATTR4_FS_LAYOUT_TYPES = 62,
	FATTR4_LAYOUT_HINT = 63,
	FATTR4_LAYOUT_TYPES = 64,
	FATTR4_LAYOUT_BLKSIZE = 65,
	FATTR4_LAYOUT_ALIGNMENT = 66,
	FATTR4_FS_LOCATIONS_INFO = 67,
	FATTR4_MDSTHRESHOLD = 68,
	FATTR4_RETENTION_GET = 69,
	FATTR4_RETENTION_SET = 70,
	FATTR4_RETENTEVT_GET = 71,
	FATTR4_RETENTEVT_SET = 72,
	FATTR4_RETENTION_HOLD = 73,
	FATTR4_MODE_SET_MASKED = 74,
	FATTR4_SUPPATTR_EXCLCREAT = 75,
	FATTR4_FS_CHARSET_CAP = 76,
};

enum {
	FATTR4_MODE_UMASK = 81,
};

enum {
	FATTR4_OPEN_ARGUMENTS = 86,
};

enum {
	FATTR4_SUPPORTED_ATTRS = 0,
	FATTR4_TYPE = 1,
	FATTR4_FH_EXPIRE_TYPE = 2,
	FATTR4_CHANGE = 3,
	FATTR4_SIZE = 4,
	FATTR4_LINK_SUPPORT = 5,
	FATTR4_SYMLINK_SUPPORT = 6,
	FATTR4_NAMED_ATTR = 7,
	FATTR4_FSID = 8,
	FATTR4_UNIQUE_HANDLES = 9,
	FATTR4_LEASE_TIME = 10,
	FATTR4_RDATTR_ERROR = 11,
	FATTR4_ACL = 12,
	FATTR4_ACLSUPPORT = 13,
	FATTR4_ARCHIVE = 14,
	FATTR4_CANSETTIME = 15,
	FATTR4_CASE_INSENSITIVE = 16,
	FATTR4_CASE_PRESERVING = 17,
	FATTR4_CHOWN_RESTRICTED = 18,
	FATTR4_FILEHANDLE = 19,
	FATTR4_FILEID = 20,
	FATTR4_FILES_AVAIL = 21,
	FATTR4_FILES_FREE = 22,
	FATTR4_FILES_TOTAL = 23,
	FATTR4_FS_LOCATIONS = 24,
	FATTR4_HIDDEN = 25,
	FATTR4_HOMOGENEOUS = 26,
	FATTR4_MAXFILESIZE = 27,
	FATTR4_MAXLINK = 28,
	FATTR4_MAXNAME = 29,
	FATTR4_MAXREAD = 30,
	FATTR4_MAXWRITE = 31,
	FATTR4_MIMETYPE = 32,
	FATTR4_MODE = 33,
	FATTR4_NO_TRUNC = 34,
	FATTR4_NUMLINKS = 35,
	FATTR4_OWNER = 36,
	FATTR4_OWNER_GROUP = 37,
	FATTR4_QUOTA_AVAIL_HARD = 38,
	FATTR4_QUOTA_AVAIL_SOFT = 39,
	FATTR4_QUOTA_USED = 40,
	FATTR4_RAWDEV = 41,
	FATTR4_SPACE_AVAIL = 42,
	FATTR4_SPACE_FREE = 43,
	FATTR4_SPACE_TOTAL = 44,
	FATTR4_SPACE_USED = 45,
	FATTR4_SYSTEM = 46,
	FATTR4_TIME_ACCESS = 47,
	FATTR4_TIME_ACCESS_SET = 48,
	FATTR4_TIME_BACKUP = 49,
	FATTR4_TIME_CREATE = 50,
	FATTR4_TIME_DELTA = 51,
	FATTR4_TIME_METADATA = 52,
	FATTR4_TIME_MODIFY = 53,
	FATTR4_TIME_MODIFY_SET = 54,
	FATTR4_MOUNTED_ON_FILEID = 55,
};

enum {
	FATTR4_TIME_DELEG_ACCESS = 84,
};

enum {
	FATTR4_TIME_DELEG_MODIFY = 85,
};

enum {
	FATTR4_XATTR_SUPPORT = 82,
};

enum {
	FIB6_NO_SERNUM_CHANGE = 0,
};

enum {
	FILEID_HIGH_OFF = 0,
	FILEID_LOW_OFF = 1,
	FILE_I_TYPE_OFF = 2,
	EMBED_FH_OFF = 3,
};

enum {
	FILTER_OTHER = 0,
	FILTER_STATIC_STRING = 1,
	FILTER_DYN_STRING = 2,
	FILTER_RDYN_STRING = 3,
	FILTER_PTR_STRING = 4,
	FILTER_TRACE_FN = 5,
	FILTER_CPUMASK = 6,
	FILTER_COMM = 7,
	FILTER_CPU = 8,
	FILTER_STACKTRACE = 9,
};

enum {
	FILT_ERR_NONE = 0,
	FILT_ERR_INVALID_OP = 1,
	FILT_ERR_TOO_MANY_OPEN = 2,
	FILT_ERR_TOO_MANY_CLOSE = 3,
	FILT_ERR_MISSING_QUOTE = 4,
	FILT_ERR_MISSING_BRACE_OPEN = 5,
	FILT_ERR_MISSING_BRACE_CLOSE = 6,
	FILT_ERR_OPERAND_TOO_LONG = 7,
	FILT_ERR_EXPECT_STRING = 8,
	FILT_ERR_EXPECT_DIGIT = 9,
	FILT_ERR_ILLEGAL_FIELD_OP = 10,
	FILT_ERR_FIELD_NOT_FOUND = 11,
	FILT_ERR_ILLEGAL_INTVAL = 12,
	FILT_ERR_BAD_SUBSYS_FILTER = 13,
	FILT_ERR_TOO_MANY_PREDS = 14,
	FILT_ERR_INVALID_FILTER = 15,
	FILT_ERR_INVALID_CPULIST = 16,
	FILT_ERR_IP_FIELD_ONLY = 17,
	FILT_ERR_INVALID_VALUE = 18,
	FILT_ERR_NO_FUNCTION = 19,
	FILT_ERR_ERRNO = 20,
	FILT_ERR_NO_FILTER = 21,
};

enum {
	FOLL_TOUCH = 65536,
	FOLL_TRIED = 131072,
	FOLL_REMOTE = 262144,
	FOLL_PIN = 524288,
	FOLL_FAST_ONLY = 1048576,
	FOLL_UNLOCKABLE = 2097152,
	FOLL_MADV_POPULATE = 4194304,
};

enum {
	FOLL_WRITE = 1,
	FOLL_GET = 2,
	FOLL_DUMP = 4,
	FOLL_FORCE = 8,
	FOLL_NOWAIT = 16,
	FOLL_NOFAULT = 32,
	FOLL_HWPOISON = 64,
	FOLL_ANON = 128,
	FOLL_LONGTERM = 256,
	FOLL_SPLIT_PMD = 512,
	FOLL_PCI_P2PDMA = 1024,
	FOLL_INTERRUPTIBLE = 2048,
	FOLL_HONOR_NUMA_FAULT = 4096,
};

enum {
	FORCE_CPU_RELOC = 1,
	FORCE_GTT_RELOC = 2,
	FORCE_GPU_RELOC = 3,
};

enum {
	FORMAT_HEADER = 1,
	FORMAT_FIELD_SEPERATOR = 2,
	FORMAT_PRINTFMT = 3,
};

enum {
	FRA_UNSPEC = 0,
	FRA_DST = 1,
	FRA_SRC = 2,
	FRA_IIFNAME = 3,
	FRA_GOTO = 4,
	FRA_UNUSED2 = 5,
	FRA_PRIORITY = 6,
	FRA_UNUSED3 = 7,
	FRA_UNUSED4 = 8,
	FRA_UNUSED5 = 9,
	FRA_FWMARK = 10,
	FRA_FLOW = 11,
	FRA_TUN_ID = 12,
	FRA_SUPPRESS_IFGROUP = 13,
	FRA_SUPPRESS_PREFIXLEN = 14,
	FRA_TABLE = 15,
	FRA_FWMASK = 16,
	FRA_OIFNAME = 17,
	FRA_PAD = 18,
	FRA_L3MDEV = 19,
	FRA_UID_RANGE = 20,
	FRA_PROTOCOL = 21,
	FRA_IP_PROTO = 22,
	FRA_SPORT_RANGE = 23,
	FRA_DPORT_RANGE = 24,
	FRA_DSCP = 25,
	FRA_FLOWLABEL = 26,
	FRA_FLOWLABEL_MASK = 27,
	__FRA_MAX = 28,
};

enum {
	FR_ACT_UNSPEC = 0,
	FR_ACT_TO_TBL = 1,
	FR_ACT_GOTO = 2,
	FR_ACT_NOP = 3,
	FR_ACT_RES3 = 4,
	FR_ACT_RES4 = 5,
	FR_ACT_BLACKHOLE = 6,
	FR_ACT_UNREACHABLE = 7,
	FR_ACT_PROHIBIT = 8,
	__FR_ACT_MAX = 9,
};

enum {
	FUTEX_STATE_OK = 0,
	FUTEX_STATE_EXITING = 1,
	FUTEX_STATE_DEAD = 2,
};

enum {
	F_TX_CHK_AUTO_OFF = -2147483648,
	F_TX_CHK_AUTO_ON = 1073741824,
	F_M_RX_RAM_DIS = 16777216,
};

enum {
	GATE_INTERRUPT = 14,
	GATE_TRAP = 15,
	GATE_CALL = 12,
	GATE_TASK = 5,
};

enum {
	GENHD_FL_REMOVABLE = 1,
	GENHD_FL_HIDDEN = 2,
	GENHD_FL_NO_PART = 4,
};

enum {
	GLB_GPIO_CLK_DEB_ENA = -2147483648,
	GLB_GPIO_CLK_DBG_MSK = 1006632960,
	GLB_GPIO_INT_RST_D3_DIS = 32768,
	GLB_GPIO_LED_PAD_SPEED_UP = 16384,
	GLB_GPIO_STAT_RACE_DIS = 8192,
	GLB_GPIO_TEST_SEL_MSK = 6144,
	GLB_GPIO_TEST_SEL_BASE = 2048,
	GLB_GPIO_RAND_ENA = 1024,
	GLB_GPIO_RAND_BIT_1 = 512,
};

enum {
	GMAC_CTRL = 3840,
	GPHY_CTRL = 3844,
	GMAC_IRQ_SRC = 3848,
	GMAC_IRQ_MSK = 3852,
	GMAC_LINK_CTRL = 3856,
	WOL_CTRL_STAT = 3872,
	WOL_MATCH_CTL = 3874,
	WOL_MATCH_RES = 3875,
	WOL_MAC_ADDR = 3876,
	WOL_PATT_RPTR = 3884,
	WOL_PATT_LEN_LO = 3888,
	WOL_PATT_LEN_HI = 3892,
	WOL_PATT_CNT_0 = 3896,
	WOL_PATT_CNT_4 = 3900,
};

enum {
	GMAC_TI_ST_VAL = 3604,
	GMAC_TI_ST_CTRL = 3608,
	GMAC_TI_ST_TST = 3610,
};

enum {
	GMC_SET_RST = 32768,
	GMC_SEC_RST_OFF = 16384,
	GMC_BYP_MACSECRX_ON = 8192,
	GMC_BYP_MACSECRX_OFF = 4096,
	GMC_BYP_MACSECTX_ON = 2048,
	GMC_BYP_MACSECTX_OFF = 1024,
	GMC_BYP_RETR_ON = 512,
	GMC_BYP_RETR_OFF = 256,
	GMC_H_BURST_ON = 128,
	GMC_H_BURST_OFF = 64,
	GMC_F_LOOPB_ON = 32,
	GMC_F_LOOPB_OFF = 16,
	GMC_PAUSE_ON = 8,
	GMC_PAUSE_OFF = 4,
	GMC_RST_CLR = 2,
	GMC_RST_SET = 1,
};

enum {
	GMLC_RST_CLR = 2,
	GMLC_RST_SET = 1,
};

enum {
	GMR_FS_LEN = 2147418112,
	GMR_FS_VLAN = 8192,
	GMR_FS_JABBER = 4096,
	GMR_FS_UN_SIZE = 2048,
	GMR_FS_MC = 1024,
	GMR_FS_BC = 512,
	GMR_FS_RX_OK = 256,
	GMR_FS_GOOD_FC = 128,
	GMR_FS_BAD_FC = 64,
	GMR_FS_MII_ERR = 32,
	GMR_FS_LONG_ERR = 16,
	GMR_FS_FRAGMENT = 8,
	GMR_FS_CRC_ERR = 2,
	GMR_FS_RX_FF_OV = 1,
	GMR_FS_ANY_ERR = 6267,
};

enum {
	GMT_ST_START = 4,
	GMT_ST_STOP = 2,
	GMT_ST_CLR_IRQ = 1,
};

enum {
	GM_GPCR_PROM_ENA = 16384,
	GM_GPCR_FC_TX_DIS = 8192,
	GM_GPCR_TX_ENA = 4096,
	GM_GPCR_RX_ENA = 2048,
	GM_GPCR_BURST_ENA = 1024,
	GM_GPCR_LOOP_ENA = 512,
	GM_GPCR_PART_ENA = 256,
	GM_GPCR_GIGS_ENA = 128,
	GM_GPCR_FL_PASS = 64,
	GM_GPCR_DUP_FULL = 32,
	GM_GPCR_FC_RX_DIS = 16,
	GM_GPCR_SPEED_100 = 8,
	GM_GPCR_AU_DUP_DIS = 4,
	GM_GPCR_AU_FCT_DIS = 2,
	GM_GPCR_AU_SPD_DIS = 1,
};

enum {
	GM_GP_STAT = 0,
	GM_GP_CTRL = 4,
	GM_TX_CTRL = 8,
	GM_RX_CTRL = 12,
	GM_TX_FLOW_CTRL = 16,
	GM_TX_PARAM = 20,
	GM_SERIAL_MODE = 24,
	GM_SRC_ADDR_1L = 28,
	GM_SRC_ADDR_1M = 32,
	GM_SRC_ADDR_1H = 36,
	GM_SRC_ADDR_2L = 40,
	GM_SRC_ADDR_2M = 44,
	GM_SRC_ADDR_2H = 48,
	GM_MC_ADDR_H1 = 52,
	GM_MC_ADDR_H2 = 56,
	GM_MC_ADDR_H3 = 60,
	GM_MC_ADDR_H4 = 64,
	GM_TX_IRQ_SRC = 68,
	GM_RX_IRQ_SRC = 72,
	GM_TR_IRQ_SRC = 76,
	GM_TX_IRQ_MSK = 80,
	GM_RX_IRQ_MSK = 84,
	GM_TR_IRQ_MSK = 88,
	GM_SMI_CTRL = 128,
	GM_SMI_DATA = 132,
	GM_PHY_ADDR = 136,
	GM_MIB_CNT_BASE = 256,
	GM_MIB_CNT_END = 604,
};

enum {
	GM_IS_TX_CO_OV = 32,
	GM_IS_RX_CO_OV = 16,
	GM_IS_TX_FF_UR = 8,
	GM_IS_TX_COMPL = 4,
	GM_IS_RX_FF_OR = 2,
	GM_IS_RX_COMPL = 1,
};

enum {
	GM_PAR_MIB_CLR = 32,
	GM_PAR_MIB_TST = 16,
};

enum {
	GM_RXCR_UCF_ENA = 32768,
	GM_RXCR_MCF_ENA = 16384,
	GM_RXCR_CRC_DIS = 8192,
	GM_RXCR_PASS_FC = 4096,
};

enum {
	GM_RXF_UC_OK = 256,
	GM_RXF_BC_OK = 264,
	GM_RXF_MPAUSE = 272,
	GM_RXF_MC_OK = 280,
	GM_RXF_FCS_ERR = 288,
	GM_RXO_OK_LO = 304,
	GM_RXO_OK_HI = 312,
	GM_RXO_ERR_LO = 320,
	GM_RXO_ERR_HI = 328,
	GM_RXF_SHT = 336,
	GM_RXE_FRAG = 344,
	GM_RXF_64B = 352,
	GM_RXF_127B = 360,
	GM_RXF_255B = 368,
	GM_RXF_511B = 376,
	GM_RXF_1023B = 384,
	GM_RXF_1518B = 392,
	GM_RXF_MAX_SZ = 400,
	GM_RXF_LNG_ERR = 408,
	GM_RXF_JAB_PKT = 416,
	GM_RXE_FIFO_OV = 432,
	GM_TXF_UC_OK = 448,
	GM_TXF_BC_OK = 456,
	GM_TXF_MPAUSE = 464,
	GM_TXF_MC_OK = 472,
	GM_TXO_OK_LO = 480,
	GM_TXO_OK_HI = 488,
	GM_TXF_64B = 496,
	GM_TXF_127B = 504,
	GM_TXF_255B = 512,
	GM_TXF_511B = 520,
	GM_TXF_1023B = 528,
	GM_TXF_1518B = 536,
	GM_TXF_MAX_SZ = 544,
	GM_TXF_COL = 560,
	GM_TXF_LAT_COL = 568,
	GM_TXF_ABO_COL = 576,
	GM_TXF_MUL_COL = 584,
	GM_TXF_SNG_COL = 592,
	GM_TXE_FIFO_UR = 600,
};

enum {
	GM_SMI_CT_PHY_A_MSK = 63488,
	GM_SMI_CT_REG_A_MSK = 1984,
	GM_SMI_CT_OP_RD = 32,
	GM_SMI_CT_RD_VAL = 16,
	GM_SMI_CT_BUSY = 8,
};

enum {
	GM_SMOD_DATABL_MSK = 63488,
	GM_SMOD_LIMIT_4 = 1024,
	GM_SMOD_VLAN_ENA = 512,
	GM_SMOD_JUMBO_ENA = 256,
	GM_NEW_FLOW_CTRL = 64,
	GM_SMOD_IPG_MSK = 31,
};

enum {
	GM_TXCR_FORCE_JAM = 32768,
	GM_TXCR_CRC_DIS = 16384,
	GM_TXCR_PAD_DIS = 8192,
	GM_TXCR_COL_THR_MSK = 7168,
};

enum {
	GM_TXPA_JAMLEN_MSK = 49152,
	GM_TXPA_JAMIPG_MSK = 15872,
	GM_TXPA_JAMDAT_MSK = 496,
	GM_TXPA_BO_LIM_MSK = 15,
	TX_JAM_LEN_DEF = 3,
	TX_JAM_IPG_DEF = 11,
	TX_IPG_JAM_DEF = 28,
	TX_BOF_LIM_DEF = 4,
};

enum {
	GPC_TX_PAUSE = 1073741824,
	GPC_RX_PAUSE = 536870912,
	GPC_SPEED = 402653184,
	GPC_LINK = 67108864,
	GPC_DUPLEX = 33554432,
	GPC_CLOCK = 16777216,
	GPC_PDOWN = 8388608,
	GPC_TSTMODE = 4194304,
	GPC_REG18 = 2097152,
	GPC_REG12SEL = 1572864,
	GPC_REG18SEL = 393216,
	GPC_SPILOCK = 65536,
	GPC_LEDMUX = 49152,
	GPC_INTPOL = 8192,
	GPC_DETECT = 4096,
	GPC_1000HD = 2048,
	GPC_SLAVE = 1024,
	GPC_PAUSE = 512,
	GPC_LEDCTL = 192,
	GPC_RST_CLR = 2,
	GPC_RST_SET = 1,
};

enum {
	GP_IDLE = 0,
	GP_ENTER = 1,
	GP_PASSED = 2,
	GP_EXIT = 3,
	GP_REPLAY = 4,
};

enum {
	GSSX_NULL = 0,
	GSSX_INDICATE_MECHS = 1,
	GSSX_GET_CALL_CONTEXT = 2,
	GSSX_IMPORT_AND_CANON_NAME = 3,
	GSSX_EXPORT_CRED = 4,
	GSSX_IMPORT_CRED = 5,
	GSSX_ACQUIRE_CRED = 6,
	GSSX_STORE_CRED = 7,
	GSSX_INIT_SEC_CONTEXT = 8,
	GSSX_ACCEPT_SEC_CONTEXT = 9,
	GSSX_RELEASE_HANDLE = 10,
	GSSX_GET_MIC = 11,
	GSSX_VERIFY = 12,
	GSSX_WRAP = 13,
	GSSX_UNWRAP = 14,
	GSSX_WRAP_SIZE_LIMIT = 15,
};

enum {
	GUC_CAPTURE_LIST_CLASS_RENDER_COMPUTE = 0,
	GUC_CAPTURE_LIST_CLASS_VIDEO = 1,
	GUC_CAPTURE_LIST_CLASS_VIDEOENHANCE = 2,
	GUC_CAPTURE_LIST_CLASS_BLITTER = 3,
	GUC_CAPTURE_LIST_CLASS_GSC_OTHER = 4,
};

enum {
	GUC_CAPTURE_LIST_INDEX_PF = 0,
	GUC_CAPTURE_LIST_INDEX_VF = 1,
	GUC_CAPTURE_LIST_INDEX_MAX = 2,
};

enum {
	GUC_CONTEXT_POLICIES_KLV_ID_EXECUTION_QUANTUM = 8193,
	GUC_CONTEXT_POLICIES_KLV_ID_PREEMPTION_TIMEOUT = 8194,
	GUC_CONTEXT_POLICIES_KLV_ID_SCHEDULING_PRIORITY = 8195,
	GUC_CONTEXT_POLICIES_KLV_ID_PREEMPT_TO_IDLE_ON_QUANTUM_EXPIRY = 8196,
	GUC_CONTEXT_POLICIES_KLV_ID_SLPM_GT_FREQUENCY = 8197,
	GUC_CONTEXT_POLICIES_KLV_NUM_IDS = 5,
};

enum {
	GUC_LOG_SECTIONS_CRASH = 0,
	GUC_LOG_SECTIONS_DEBUG = 1,
	GUC_LOG_SECTIONS_CAPTURE = 2,
	GUC_LOG_SECTIONS_LIMIT = 3,
};

enum {
	GUC_SCHEDULING_POLICIES_KLV_ID_RENDER_COMPUTE_YIELD = 4097,
};

enum {
	GUC_WORKAROUND_KLV_SERIALIZED_RA_MODE = 36865,
	GUC_WORKAROUND_KLV_BLOCK_INTERRUPTS_WHEN_MGSR_BLOCKED = 36866,
	GUC_WORKAROUND_KLV_AVOID_GFX_CLEAR_WHILE_ACTIVE = 36870,
};

enum {
	HANDSHAKE_A_ACCEPT_SOCKFD = 1,
	HANDSHAKE_A_ACCEPT_HANDLER_CLASS = 2,
	HANDSHAKE_A_ACCEPT_MESSAGE_TYPE = 3,
	HANDSHAKE_A_ACCEPT_TIMEOUT = 4,
	HANDSHAKE_A_ACCEPT_AUTH_MODE = 5,
	HANDSHAKE_A_ACCEPT_PEER_IDENTITY = 6,
	HANDSHAKE_A_ACCEPT_CERTIFICATE = 7,
	HANDSHAKE_A_ACCEPT_PEERNAME = 8,
	__HANDSHAKE_A_ACCEPT_MAX = 9,
	HANDSHAKE_A_ACCEPT_MAX = 8,
};

enum {
	HANDSHAKE_A_DONE_STATUS = 1,
	HANDSHAKE_A_DONE_SOCKFD = 2,
	HANDSHAKE_A_DONE_REMOTE_AUTH = 3,
	__HANDSHAKE_A_DONE_MAX = 4,
	HANDSHAKE_A_DONE_MAX = 3,
};

enum {
	HANDSHAKE_A_X509_CERT = 1,
	HANDSHAKE_A_X509_PRIVKEY = 2,
	__HANDSHAKE_A_X509_MAX = 3,
	HANDSHAKE_A_X509_MAX = 2,
};

enum {
	HANDSHAKE_CMD_READY = 1,
	HANDSHAKE_CMD_ACCEPT = 2,
	HANDSHAKE_CMD_DONE = 3,
	__HANDSHAKE_CMD_MAX = 4,
	HANDSHAKE_CMD_MAX = 3,
};

enum {
	HANDSHAKE_NLGRP_NONE = 0,
	HANDSHAKE_NLGRP_TLSHD = 1,
};

enum {
	HASH_SIZE = 128,
};

enum {
	HASH_TCP_IPV6_EX_CTRL = 32,
	HASH_IPV6_EX_CTRL = 16,
	HASH_TCP_IPV6_CTRL = 8,
	HASH_IPV6_CTRL = 4,
	HASH_TCP_IPV4_CTRL = 2,
	HASH_IPV4_CTRL = 1,
	HASH_ALL = 63,
};

enum {
	HAS_GLOBAL_MOCS = 1,
	HAS_ENGINE_MOCS = 2,
	HAS_RENDER_L3CC = 4,
};

enum {
	HAS_MII_XCVR = 65536,
	HAS_CHIP_XCVR = 131072,
	HAS_LNK_CHNG = 262144,
};

enum {
	HAS_READ = 1,
	HAS_WRITE = 2,
	HAS_LSEEK = 4,
	HAS_POLL = 8,
	HAS_IOCTL = 16,
};

enum {
	HCU_CCSR_SMBALERT_MONITOR = 134217728,
	HCU_CCSR_CPU_SLEEP = 67108864,
	HCU_CCSR_CS_TO = 33554432,
	HCU_CCSR_WDOG = 16777216,
	HCU_CCSR_CLR_IRQ_HOST = 131072,
	HCU_CCSR_SET_IRQ_HCU = 65536,
	HCU_CCSR_AHB_RST = 512,
	HCU_CCSR_CPU_RST_MODE = 256,
	HCU_CCSR_SET_SYNC_CPU = 32,
	HCU_CCSR_CPU_CLK_DIVIDE_MSK = 24,
	HCU_CCSR_CPU_CLK_DIVIDE_BASE = 8,
	HCU_CCSR_OS_PRSNT = 4,
	HCU_CCSR_UC_STATE_MSK = 3,
	HCU_CCSR_UC_STATE_BASE = 1,
	HCU_CCSR_ASF_RESET = 0,
	HCU_CCSR_ASF_HALTED = 2,
	HCU_CCSR_ASF_RUNNING = 1,
};

enum {
	HDA_DEV_CORE = 0,
	HDA_DEV_LEGACY = 1,
	HDA_DEV_ASOC = 2,
};

enum {
	HDA_DIG_NONE = 0,
	HDA_DIG_EXCLUSIVE = 1,
	HDA_DIG_ANALOG_DUP = 2,
};

enum {
	HDA_FIXUP_ACT_PRE_PROBE = 0,
	HDA_FIXUP_ACT_PROBE = 1,
	HDA_FIXUP_ACT_INIT = 2,
	HDA_FIXUP_ACT_BUILD = 3,
	HDA_FIXUP_ACT_FREE = 4,
};

enum {
	HDA_FIXUP_INVALID = 0,
	HDA_FIXUP_PINS = 1,
	HDA_FIXUP_VERBS = 2,
	HDA_FIXUP_FUNC = 3,
	HDA_FIXUP_PINCTLS = 4,
};

enum {
	HDA_FRONT = 0,
	HDA_REAR = 1,
	HDA_CLFE = 2,
	HDA_SIDE = 3,
};

enum {
	HDA_INPUT = 0,
	HDA_OUTPUT = 1,
};

enum {
	HDA_JACK_NOT_PRESENT = 0,
	HDA_JACK_PRESENT = 1,
	HDA_JACK_PHANTOM = 2,
};

enum {
	HDA_PCM_TYPE_AUDIO = 0,
	HDA_PCM_TYPE_SPDIF = 1,
	HDA_PCM_TYPE_HDMI = 2,
	HDA_PCM_TYPE_MODEM = 3,
	HDA_PCM_NTYPES = 4,
};

enum {
	HIBERNATION_INVALID = 0,
	HIBERNATION_PLATFORM = 1,
	HIBERNATION_SHUTDOWN = 2,
	HIBERNATION_REBOOT = 3,
	HIBERNATION_SUSPEND = 4,
	HIBERNATION_TEST_RESUME = 5,
	__HIBERNATION_AFTER_LAST = 6,
};

enum {
	HI_SOFTIRQ = 0,
	TIMER_SOFTIRQ = 1,
	NET_TX_SOFTIRQ = 2,
	NET_RX_SOFTIRQ = 3,
	BLOCK_SOFTIRQ = 4,
	IRQ_POLL_SOFTIRQ = 5,
	TASKLET_SOFTIRQ = 6,
	SCHED_SOFTIRQ = 7,
	HRTIMER_SOFTIRQ = 8,
	RCU_SOFTIRQ = 9,
	NR_SOFTIRQS = 10,
};

enum {
	HP_THREAD_NONE = 0,
	HP_THREAD_ACTIVE = 1,
	HP_THREAD_PARKED = 2,
};

enum {
	HSWEP_PCI_UNCORE_HA = 0,
	HSWEP_PCI_UNCORE_IMC = 1,
	HSWEP_PCI_UNCORE_IRP = 2,
	HSWEP_PCI_UNCORE_QPI = 3,
	HSWEP_PCI_UNCORE_R2PCIE = 4,
	HSWEP_PCI_UNCORE_R3QPI = 5,
};

enum {
	HUGETLB_SHMFS_INODE = 1,
	HUGETLB_ANONHUGE_INODE = 2,
};

enum {
	HW_BREAKPOINT_EMPTY = 0,
	HW_BREAKPOINT_R = 1,
	HW_BREAKPOINT_W = 2,
	HW_BREAKPOINT_RW = 3,
	HW_BREAKPOINT_X = 4,
	HW_BREAKPOINT_INVALID = 7,
};

enum {
	HW_BREAKPOINT_LEN_1 = 1,
	HW_BREAKPOINT_LEN_2 = 2,
	HW_BREAKPOINT_LEN_3 = 3,
	HW_BREAKPOINT_LEN_4 = 4,
	HW_BREAKPOINT_LEN_5 = 5,
	HW_BREAKPOINT_LEN_6 = 6,
	HW_BREAKPOINT_LEN_7 = 7,
	HW_BREAKPOINT_LEN_8 = 8,
};

enum {
	HW_OWNER = 128,
	OP_TCPWRITE = 17,
	OP_TCPSTART = 18,
	OP_TCPINIT = 20,
	OP_TCPLCK = 24,
	OP_TCPCHKSUM = 18,
	OP_TCPIS = 22,
	OP_TCPLW = 25,
	OP_TCPLSW = 27,
	OP_TCPLISW = 31,
	OP_ADDR64 = 33,
	OP_VLAN = 34,
	OP_ADDR64VLAN = 35,
	OP_LRGLEN = 36,
	OP_LRGLENVLAN = 38,
	OP_MSS = 40,
	OP_MSSVLAN = 42,
	OP_BUFFER = 64,
	OP_PACKET = 65,
	OP_LARGESEND = 67,
	OP_LSOV2 = 69,
	OP_RXSTAT = 96,
	OP_RXTIMESTAMP = 97,
	OP_RXVLAN = 98,
	OP_RXCHKS = 100,
	OP_RXCHKSVLAN = 102,
	OP_RXTIMEVLAN = 99,
	OP_RSS_HASH = 101,
	OP_TXINDEXLE = 104,
	OP_MACSEC = 108,
	OP_PUTIDX = 112,
};

enum {
	I915_FENCE_FLAG_ACTIVE = 3,
	I915_FENCE_FLAG_PQUEUE = 4,
	I915_FENCE_FLAG_HOLD = 5,
	I915_FENCE_FLAG_INITIAL_BREADCRUMB = 6,
	I915_FENCE_FLAG_SIGNAL = 7,
	I915_FENCE_FLAG_NOPREEMPT = 8,
	I915_FENCE_FLAG_SENTINEL = 9,
	I915_FENCE_FLAG_BOOST = 10,
	I915_FENCE_FLAG_SUBMIT_PARALLEL = 11,
	I915_FENCE_FLAG_SKIP_PARALLEL = 12,
	I915_FENCE_FLAG_COMPOSITE = 13,
};

enum {
	I915_PRIORITY_MIN = -1024,
	I915_PRIORITY_NORMAL = 0,
	I915_PRIORITY_MAX = 1024,
	I915_PRIORITY_HEARTBEAT = 1025,
	I915_PRIORITY_DISPLAY = 1026,
};

enum {
	ICMP6_MIB_NUM = 0,
	ICMP6_MIB_INMSGS = 1,
	ICMP6_MIB_INERRORS = 2,
	ICMP6_MIB_OUTMSGS = 3,
	ICMP6_MIB_OUTERRORS = 4,
	ICMP6_MIB_CSUMERRORS = 5,
	ICMP6_MIB_RATELIMITHOST = 6,
	__ICMP6_MIB_MAX = 7,
};

enum {
	ICMP_MIB_NUM = 0,
	ICMP_MIB_INMSGS = 1,
	ICMP_MIB_INERRORS = 2,
	ICMP_MIB_INDESTUNREACHS = 3,
	ICMP_MIB_INTIMEEXCDS = 4,
	ICMP_MIB_INPARMPROBS = 5,
	ICMP_MIB_INSRCQUENCHS = 6,
	ICMP_MIB_INREDIRECTS = 7,
	ICMP_MIB_INECHOS = 8,
	ICMP_MIB_INECHOREPS = 9,
	ICMP_MIB_INTIMESTAMPS = 10,
	ICMP_MIB_INTIMESTAMPREPS = 11,
	ICMP_MIB_INADDRMASKS = 12,
	ICMP_MIB_INADDRMASKREPS = 13,
	ICMP_MIB_OUTMSGS = 14,
	ICMP_MIB_OUTERRORS = 15,
	ICMP_MIB_OUTDESTUNREACHS = 16,
	ICMP_MIB_OUTTIMEEXCDS = 17,
	ICMP_MIB_OUTPARMPROBS = 18,
	ICMP_MIB_OUTSRCQUENCHS = 19,
	ICMP_MIB_OUTREDIRECTS = 20,
	ICMP_MIB_OUTECHOS = 21,
	ICMP_MIB_OUTECHOREPS = 22,
	ICMP_MIB_OUTTIMESTAMPS = 23,
	ICMP_MIB_OUTTIMESTAMPREPS = 24,
	ICMP_MIB_OUTADDRMASKS = 25,
	ICMP_MIB_OUTADDRMASKREPS = 26,
	ICMP_MIB_CSUMERRORS = 27,
	ICMP_MIB_RATELIMITGLOBAL = 28,
	ICMP_MIB_RATELIMITHOST = 29,
	__ICMP_MIB_MAX = 30,
};

enum {
	ICX_PCIE1_PMON_ID = 0,
	ICX_PCIE2_PMON_ID = 1,
	ICX_PCIE3_PMON_ID = 2,
	ICX_PCIE4_PMON_ID = 3,
	ICX_PCIE5_PMON_ID = 4,
	ICX_CBDMA_DMI_PMON_ID = 5,
};

enum {
	ICX_PCI_UNCORE_M2M = 0,
	ICX_PCI_UNCORE_UPI = 1,
	ICX_PCI_UNCORE_M3UPI = 2,
};

enum {
	IEEE80211_PROBE_FLAG_DIRECTED = 1,
	IEEE80211_PROBE_FLAG_MIN_CONTENT = 2,
	IEEE80211_PROBE_FLAG_RANDOM_SN = 4,
};

enum {
	IEEE80211_RX_MSG = 1,
	IEEE80211_TX_STATUS_MSG = 2,
};

enum {
	IFAL_ADDRESS = 1,
	IFAL_LABEL = 2,
	__IFAL_MAX = 3,
};

enum {
	IFA_UNSPEC = 0,
	IFA_ADDRESS = 1,
	IFA_LOCAL = 2,
	IFA_LABEL = 3,
	IFA_BROADCAST = 4,
	IFA_ANYCAST = 5,
	IFA_CACHEINFO = 6,
	IFA_MULTICAST = 7,
	IFA_FLAGS = 8,
	IFA_RT_PRIORITY = 9,
	IFA_TARGET_NETNSID = 10,
	IFA_PROTO = 11,
	__IFA_MAX = 12,
};

enum {
	IFLA_BRIDGE_FLAGS = 0,
	IFLA_BRIDGE_MODE = 1,
	IFLA_BRIDGE_VLAN_INFO = 2,
	IFLA_BRIDGE_VLAN_TUNNEL_INFO = 3,
	IFLA_BRIDGE_MRP = 4,
	IFLA_BRIDGE_CFM = 5,
	IFLA_BRIDGE_MST = 6,
	__IFLA_BRIDGE_MAX = 7,
};

enum {
	IFLA_BRPORT_UNSPEC = 0,
	IFLA_BRPORT_STATE = 1,
	IFLA_BRPORT_PRIORITY = 2,
	IFLA_BRPORT_COST = 3,
	IFLA_BRPORT_MODE = 4,
	IFLA_BRPORT_GUARD = 5,
	IFLA_BRPORT_PROTECT = 6,
	IFLA_BRPORT_FAST_LEAVE = 7,
	IFLA_BRPORT_LEARNING = 8,
	IFLA_BRPORT_UNICAST_FLOOD = 9,
	IFLA_BRPORT_PROXYARP = 10,
	IFLA_BRPORT_LEARNING_SYNC = 11,
	IFLA_BRPORT_PROXYARP_WIFI = 12,
	IFLA_BRPORT_ROOT_ID = 13,
	IFLA_BRPORT_BRIDGE_ID = 14,
	IFLA_BRPORT_DESIGNATED_PORT = 15,
	IFLA_BRPORT_DESIGNATED_COST = 16,
	IFLA_BRPORT_ID = 17,
	IFLA_BRPORT_NO = 18,
	IFLA_BRPORT_TOPOLOGY_CHANGE_ACK = 19,
	IFLA_BRPORT_CONFIG_PENDING = 20,
	IFLA_BRPORT_MESSAGE_AGE_TIMER = 21,
	IFLA_BRPORT_FORWARD_DELAY_TIMER = 22,
	IFLA_BRPORT_HOLD_TIMER = 23,
	IFLA_BRPORT_FLUSH = 24,
	IFLA_BRPORT_MULTICAST_ROUTER = 25,
	IFLA_BRPORT_PAD = 26,
	IFLA_BRPORT_MCAST_FLOOD = 27,
	IFLA_BRPORT_MCAST_TO_UCAST = 28,
	IFLA_BRPORT_VLAN_TUNNEL = 29,
	IFLA_BRPORT_BCAST_FLOOD = 30,
	IFLA_BRPORT_GROUP_FWD_MASK = 31,
	IFLA_BRPORT_NEIGH_SUPPRESS = 32,
	IFLA_BRPORT_ISOLATED = 33,
	IFLA_BRPORT_BACKUP_PORT = 34,
	IFLA_BRPORT_MRP_RING_OPEN = 35,
	IFLA_BRPORT_MRP_IN_OPEN = 36,
	IFLA_BRPORT_MCAST_EHT_HOSTS_LIMIT = 37,
	IFLA_BRPORT_MCAST_EHT_HOSTS_CNT = 38,
	IFLA_BRPORT_LOCKED = 39,
	IFLA_BRPORT_MAB = 40,
	IFLA_BRPORT_MCAST_N_GROUPS = 41,
	IFLA_BRPORT_MCAST_MAX_GROUPS = 42,
	IFLA_BRPORT_NEIGH_VLAN_SUPPRESS = 43,
	IFLA_BRPORT_BACKUP_NHID = 44,
	__IFLA_BRPORT_MAX = 45,
};

enum {
	IFLA_EVENT_NONE = 0,
	IFLA_EVENT_REBOOT = 1,
	IFLA_EVENT_FEATURES = 2,
	IFLA_EVENT_BONDING_FAILOVER = 3,
	IFLA_EVENT_NOTIFY_PEERS = 4,
	IFLA_EVENT_IGMP_RESEND = 5,
	IFLA_EVENT_BONDING_OPTIONS = 6,
};

enum {
	IFLA_INET6_UNSPEC = 0,
	IFLA_INET6_FLAGS = 1,
	IFLA_INET6_CONF = 2,
	IFLA_INET6_STATS = 3,
	IFLA_INET6_MCAST = 4,
	IFLA_INET6_CACHEINFO = 5,
	IFLA_INET6_ICMP6STATS = 6,
	IFLA_INET6_TOKEN = 7,
	IFLA_INET6_ADDR_GEN_MODE = 8,
	IFLA_INET6_RA_MTU = 9,
	__IFLA_INET6_MAX = 10,
};

enum {
	IFLA_INET_UNSPEC = 0,
	IFLA_INET_CONF = 1,
	__IFLA_INET_MAX = 2,
};

enum {
	IFLA_INFO_UNSPEC = 0,
	IFLA_INFO_KIND = 1,
	IFLA_INFO_DATA = 2,
	IFLA_INFO_XSTATS = 3,
	IFLA_INFO_SLAVE_KIND = 4,
	IFLA_INFO_SLAVE_DATA = 5,
	__IFLA_INFO_MAX = 6,
};

enum {
	IFLA_IPTUN_UNSPEC = 0,
	IFLA_IPTUN_LINK = 1,
	IFLA_IPTUN_LOCAL = 2,
	IFLA_IPTUN_REMOTE = 3,
	IFLA_IPTUN_TTL = 4,
	IFLA_IPTUN_TOS = 5,
	IFLA_IPTUN_ENCAP_LIMIT = 6,
	IFLA_IPTUN_FLOWINFO = 7,
	IFLA_IPTUN_FLAGS = 8,
	IFLA_IPTUN_PROTO = 9,
	IFLA_IPTUN_PMTUDISC = 10,
	IFLA_IPTUN_6RD_PREFIX = 11,
	IFLA_IPTUN_6RD_RELAY_PREFIX = 12,
	IFLA_IPTUN_6RD_PREFIXLEN = 13,
	IFLA_IPTUN_6RD_RELAY_PREFIXLEN = 14,
	IFLA_IPTUN_ENCAP_TYPE = 15,
	IFLA_IPTUN_ENCAP_FLAGS = 16,
	IFLA_IPTUN_ENCAP_SPORT = 17,
	IFLA_IPTUN_ENCAP_DPORT = 18,
	IFLA_IPTUN_COLLECT_METADATA = 19,
	IFLA_IPTUN_FWMARK = 20,
	__IFLA_IPTUN_MAX = 21,
};

enum {
	IFLA_OFFLOAD_XSTATS_HW_S_INFO_UNSPEC = 0,
	IFLA_OFFLOAD_XSTATS_HW_S_INFO_REQUEST = 1,
	IFLA_OFFLOAD_XSTATS_HW_S_INFO_USED = 2,
	__IFLA_OFFLOAD_XSTATS_HW_S_INFO_MAX = 3,
};

enum {
	IFLA_OFFLOAD_XSTATS_UNSPEC = 0,
	IFLA_OFFLOAD_XSTATS_CPU_HIT = 1,
	IFLA_OFFLOAD_XSTATS_HW_S_INFO = 2,
	IFLA_OFFLOAD_XSTATS_L3_STATS = 3,
	__IFLA_OFFLOAD_XSTATS_MAX = 4,
};

enum {
	IFLA_PORT_UNSPEC = 0,
	IFLA_PORT_VF = 1,
	IFLA_PORT_PROFILE = 2,
	IFLA_PORT_VSI_TYPE = 3,
	IFLA_PORT_INSTANCE_UUID = 4,
	IFLA_PORT_HOST_UUID = 5,
	IFLA_PORT_REQUEST = 6,
	IFLA_PORT_RESPONSE = 7,
	__IFLA_PORT_MAX = 8,
};

enum {
	IFLA_PROTO_DOWN_REASON_UNSPEC = 0,
	IFLA_PROTO_DOWN_REASON_MASK = 1,
	IFLA_PROTO_DOWN_REASON_VALUE = 2,
	__IFLA_PROTO_DOWN_REASON_CNT = 3,
	IFLA_PROTO_DOWN_REASON_MAX = 2,
};

enum {
	IFLA_STATS_GETSET_UNSPEC = 0,
	IFLA_STATS_GET_FILTERS = 1,
	IFLA_STATS_SET_OFFLOAD_XSTATS_L3_STATS = 2,
	__IFLA_STATS_GETSET_MAX = 3,
};

enum {
	IFLA_STATS_UNSPEC = 0,
	IFLA_STATS_LINK_64 = 1,
	IFLA_STATS_LINK_XSTATS = 2,
	IFLA_STATS_LINK_XSTATS_SLAVE = 3,
	IFLA_STATS_LINK_OFFLOAD_XSTATS = 4,
	IFLA_STATS_AF_SPEC = 5,
	__IFLA_STATS_MAX = 6,
};

enum {
	IFLA_UNSPEC = 0,
	IFLA_ADDRESS = 1,
	IFLA_BROADCAST = 2,
	IFLA_IFNAME = 3,
	IFLA_MTU = 4,
	IFLA_LINK = 5,
	IFLA_QDISC = 6,
	IFLA_STATS = 7,
	IFLA_COST = 8,
	IFLA_PRIORITY = 9,
	IFLA_MASTER = 10,
	IFLA_WIRELESS = 11,
	IFLA_PROTINFO = 12,
	IFLA_TXQLEN = 13,
	IFLA_MAP = 14,
	IFLA_WEIGHT = 15,
	IFLA_OPERSTATE = 16,
	IFLA_LINKMODE = 17,
	IFLA_LINKINFO = 18,
	IFLA_NET_NS_PID = 19,
	IFLA_IFALIAS = 20,
	IFLA_NUM_VF = 21,
	IFLA_VFINFO_LIST = 22,
	IFLA_STATS64 = 23,
	IFLA_VF_PORTS = 24,
	IFLA_PORT_SELF = 25,
	IFLA_AF_SPEC = 26,
	IFLA_GROUP = 27,
	IFLA_NET_NS_FD = 28,
	IFLA_EXT_MASK = 29,
	IFLA_PROMISCUITY = 30,
	IFLA_NUM_TX_QUEUES = 31,
	IFLA_NUM_RX_QUEUES = 32,
	IFLA_CARRIER = 33,
	IFLA_PHYS_PORT_ID = 34,
	IFLA_CARRIER_CHANGES = 35,
	IFLA_PHYS_SWITCH_ID = 36,
	IFLA_LINK_NETNSID = 37,
	IFLA_PHYS_PORT_NAME = 38,
	IFLA_PROTO_DOWN = 39,
	IFLA_GSO_MAX_SEGS = 40,
	IFLA_GSO_MAX_SIZE = 41,
	IFLA_PAD = 42,
	IFLA_XDP = 43,
	IFLA_EVENT = 44,
	IFLA_NEW_NETNSID = 45,
	IFLA_IF_NETNSID = 46,
	IFLA_TARGET_NETNSID = 46,
	IFLA_CARRIER_UP_COUNT = 47,
	IFLA_CARRIER_DOWN_COUNT = 48,
	IFLA_NEW_IFINDEX = 49,
	IFLA_MIN_MTU = 50,
	IFLA_MAX_MTU = 51,
	IFLA_PROP_LIST = 52,
	IFLA_ALT_IFNAME = 53,
	IFLA_PERM_ADDRESS = 54,
	IFLA_PROTO_DOWN_REASON = 55,
	IFLA_PARENT_DEV_NAME = 56,
	IFLA_PARENT_DEV_BUS_NAME = 57,
	IFLA_GRO_MAX_SIZE = 58,
	IFLA_TSO_MAX_SIZE = 59,
	IFLA_TSO_MAX_SEGS = 60,
	IFLA_ALLMULTI = 61,
	IFLA_DEVLINK_PORT = 62,
	IFLA_GSO_IPV4_MAX_SIZE = 63,
	IFLA_GRO_IPV4_MAX_SIZE = 64,
	IFLA_DPLL_PIN = 65,
	IFLA_MAX_PACING_OFFLOAD_HORIZON = 66,
	__IFLA_MAX = 67,
};

enum {
	IFLA_VF_INFO_UNSPEC = 0,
	IFLA_VF_INFO = 1,
	__IFLA_VF_INFO_MAX = 2,
};

enum {
	IFLA_VF_PORT_UNSPEC = 0,
	IFLA_VF_PORT = 1,
	__IFLA_VF_PORT_MAX = 2,
};

enum {
	IFLA_VF_STATS_RX_PACKETS = 0,
	IFLA_VF_STATS_TX_PACKETS = 1,
	IFLA_VF_STATS_RX_BYTES = 2,
	IFLA_VF_STATS_TX_BYTES = 3,
	IFLA_VF_STATS_BROADCAST = 4,
	IFLA_VF_STATS_MULTICAST = 5,
	IFLA_VF_STATS_PAD = 6,
	IFLA_VF_STATS_RX_DROPPED = 7,
	IFLA_VF_STATS_TX_DROPPED = 8,
	__IFLA_VF_STATS_MAX = 9,
};

enum {
	IFLA_VF_UNSPEC = 0,
	IFLA_VF_MAC = 1,
	IFLA_VF_VLAN = 2,
	IFLA_VF_TX_RATE = 3,
	IFLA_VF_SPOOFCHK = 4,
	IFLA_VF_LINK_STATE = 5,
	IFLA_VF_RATE = 6,
	IFLA_VF_RSS_QUERY_EN = 7,
	IFLA_VF_STATS = 8,
	IFLA_VF_TRUST = 9,
	IFLA_VF_IB_NODE_GUID = 10,
	IFLA_VF_IB_PORT_GUID = 11,
	IFLA_VF_VLAN_LIST = 12,
	IFLA_VF_BROADCAST = 13,
	__IFLA_VF_MAX = 14,
};

enum {
	IFLA_VF_VLAN_INFO_UNSPEC = 0,
	IFLA_VF_VLAN_INFO = 1,
	__IFLA_VF_VLAN_INFO_MAX = 2,
};

enum {
	IFLA_XDP_UNSPEC = 0,
	IFLA_XDP_FD = 1,
	IFLA_XDP_ATTACHED = 2,
	IFLA_XDP_FLAGS = 3,
	IFLA_XDP_PROG_ID = 4,
	IFLA_XDP_DRV_PROG_ID = 5,
	IFLA_XDP_SKB_PROG_ID = 6,
	IFLA_XDP_HW_PROG_ID = 7,
	IFLA_XDP_EXPECTED_FD = 8,
	__IFLA_XDP_MAX = 9,
};

enum {
	IF_ACT_NONE = -1,
	IF_ACT_FILTER = 0,
	IF_ACT_START = 1,
	IF_ACT_STOP = 2,
	IF_SRC_FILE = 3,
	IF_SRC_KERNEL = 4,
	IF_SRC_FILEADDR = 5,
	IF_SRC_KERNELADDR = 6,
};

enum {
	IF_LINK_MODE_DEFAULT = 0,
	IF_LINK_MODE_DORMANT = 1,
	IF_LINK_MODE_TESTING = 2,
};

enum {
	IF_OPER_UNKNOWN = 0,
	IF_OPER_NOTPRESENT = 1,
	IF_OPER_DOWN = 2,
	IF_OPER_LOWERLAYERDOWN = 3,
	IF_OPER_TESTING = 4,
	IF_OPER_DORMANT = 5,
	IF_OPER_UP = 6,
};

enum {
	IF_STATE_ACTION = 0,
	IF_STATE_SOURCE = 1,
	IF_STATE_END = 2,
};

enum {
	IIO_TOPOLOGY_TYPE = 0,
	UPI_TOPOLOGY_TYPE = 1,
	TOPOLOGY_MAX = 2,
};

enum {
	INET6_IFADDR_STATE_PREDAD = 0,
	INET6_IFADDR_STATE_DAD = 1,
	INET6_IFADDR_STATE_POSTDAD = 2,
	INET6_IFADDR_STATE_ERRDAD = 3,
	INET6_IFADDR_STATE_DEAD = 4,
};

enum {
	INET_DIAG_REQ_NONE = 0,
	INET_DIAG_REQ_BYTECODE = 1,
	INET_DIAG_REQ_SK_BPF_STORAGES = 2,
	INET_DIAG_REQ_PROTOCOL = 3,
	__INET_DIAG_REQ_MAX = 4,
};

enum {
	INET_ECN_NOT_ECT = 0,
	INET_ECN_ECT_1 = 1,
	INET_ECN_ECT_0 = 2,
	INET_ECN_CE = 3,
	INET_ECN_MASK = 3,
};

enum {
	INET_FLAGS_PKTINFO = 0,
	INET_FLAGS_TTL = 1,
	INET_FLAGS_TOS = 2,
	INET_FLAGS_RECVOPTS = 3,
	INET_FLAGS_RETOPTS = 4,
	INET_FLAGS_PASSSEC = 5,
	INET_FLAGS_ORIGDSTADDR = 6,
	INET_FLAGS_CHECKSUM = 7,
	INET_FLAGS_RECVFRAGSIZE = 8,
	INET_FLAGS_RECVERR = 9,
	INET_FLAGS_RECVERR_RFC4884 = 10,
	INET_FLAGS_FREEBIND = 11,
	INET_FLAGS_HDRINCL = 12,
	INET_FLAGS_MC_LOOP = 13,
	INET_FLAGS_MC_ALL = 14,
	INET_FLAGS_TRANSPARENT = 15,
	INET_FLAGS_IS_ICSK = 16,
	INET_FLAGS_NODEFRAG = 17,
	INET_FLAGS_BIND_ADDRESS_NO_PORT = 18,
	INET_FLAGS_DEFER_CONNECT = 19,
	INET_FLAGS_MC6_LOOP = 20,
	INET_FLAGS_RECVERR6_RFC4884 = 21,
	INET_FLAGS_MC6_ALL = 22,
	INET_FLAGS_AUTOFLOWLABEL_SET = 23,
	INET_FLAGS_AUTOFLOWLABEL = 24,
	INET_FLAGS_DONTFRAG = 25,
	INET_FLAGS_RECVERR6 = 26,
	INET_FLAGS_REPFLOW = 27,
	INET_FLAGS_RTALERT_ISOLATE = 28,
	INET_FLAGS_SNDFLOW = 29,
	INET_FLAGS_RTALERT = 30,
};

enum {
	INET_FRAG_FIRST_IN = 1,
	INET_FRAG_LAST_IN = 2,
	INET_FRAG_COMPLETE = 4,
	INET_FRAG_HASH_DEAD = 8,
	INET_FRAG_DROP = 16,
};

enum {
	INPUT_PIN_ATTR_UNUSED = 0,
	INPUT_PIN_ATTR_INT = 1,
	INPUT_PIN_ATTR_DOCK = 2,
	INPUT_PIN_ATTR_NORMAL = 3,
	INPUT_PIN_ATTR_REAR = 4,
	INPUT_PIN_ATTR_FRONT = 5,
	INPUT_PIN_ATTR_LAST = 5,
};

enum {
	INSN_F_FRAMENO_MASK = 7,
	INSN_F_SPI_MASK = 63,
	INSN_F_SPI_SHIFT = 3,
	INSN_F_STACK_ACCESS = 512,
};

enum {
	INTEL_ADVANCED_CONTEXT = 0,
	INTEL_LEGACY_32B_CONTEXT = 1,
	INTEL_ADVANCED_AD_CONTEXT = 2,
	INTEL_LEGACY_64B_CONTEXT = 3,
};

enum {
	INTEL_CONTEXT_SCHEDULE_IN = 0,
	INTEL_CONTEXT_SCHEDULE_OUT = 1,
	INTEL_CONTEXT_SCHEDULE_PREEMPTED = 2,
};

enum {
	INTEL_RPS_ENABLED = 0,
	INTEL_RPS_ACTIVE = 1,
	INTEL_RPS_INTERRUPTS = 2,
	INTEL_RPS_TIMER = 3,
};

enum {
	INTEL_WAKEREF_PUT_ASYNC_BIT = 0,
	__INTEL_WAKEREF_PUT_LAST_BIT__ = 1,
};

enum {
	INVERT = 1,
	PROCESS_AND = 2,
	PROCESS_OR = 4,
};

enum {
	IOAM6_ATTR_UNSPEC = 0,
	IOAM6_ATTR_NS_ID = 1,
	IOAM6_ATTR_NS_DATA = 2,
	IOAM6_ATTR_NS_DATA_WIDE = 3,
	IOAM6_ATTR_SC_ID = 4,
	IOAM6_ATTR_SC_DATA = 5,
	IOAM6_ATTR_SC_NONE = 6,
	IOAM6_ATTR_PAD = 7,
	__IOAM6_ATTR_MAX = 8,
};

enum {
	IOAM6_CMD_UNSPEC = 0,
	IOAM6_CMD_ADD_NAMESPACE = 1,
	IOAM6_CMD_DEL_NAMESPACE = 2,
	IOAM6_CMD_DUMP_NAMESPACES = 3,
	IOAM6_CMD_ADD_SCHEMA = 4,
	IOAM6_CMD_DEL_SCHEMA = 5,
	IOAM6_CMD_DUMP_SCHEMAS = 6,
	IOAM6_CMD_NS_SET_SCHEMA = 7,
	__IOAM6_CMD_MAX = 8,
};

enum {
	IOBL_BUF_RING = 1,
	IOBL_INC = 2,
};

enum {
	IOCB_CMD_PREAD = 0,
	IOCB_CMD_PWRITE = 1,
	IOCB_CMD_FSYNC = 2,
	IOCB_CMD_FDSYNC = 3,
	IOCB_CMD_POLL = 5,
	IOCB_CMD_NOOP = 6,
	IOCB_CMD_PREADV = 7,
	IOCB_CMD_PWRITEV = 8,
};

enum {
	IOMMU_SET_DOMAIN_MUST_SUCCEED = 1,
};

enum {
	IOPRIO_CLASS_NONE = 0,
	IOPRIO_CLASS_RT = 1,
	IOPRIO_CLASS_BE = 2,
	IOPRIO_CLASS_IDLE = 3,
	IOPRIO_CLASS_INVALID = 7,
};

enum {
	IOPRIO_HINT_NONE = 0,
	IOPRIO_HINT_DEV_DURATION_LIMIT_1 = 1,
	IOPRIO_HINT_DEV_DURATION_LIMIT_2 = 2,
	IOPRIO_HINT_DEV_DURATION_LIMIT_3 = 3,
	IOPRIO_HINT_DEV_DURATION_LIMIT_4 = 4,
	IOPRIO_HINT_DEV_DURATION_LIMIT_5 = 5,
	IOPRIO_HINT_DEV_DURATION_LIMIT_6 = 6,
	IOPRIO_HINT_DEV_DURATION_LIMIT_7 = 7,
};

enum {
	IOPRIO_WHO_PROCESS = 1,
	IOPRIO_WHO_PGRP = 2,
	IOPRIO_WHO_USER = 3,
};

enum {
	IORES_DESC_NONE = 0,
	IORES_DESC_CRASH_KERNEL = 1,
	IORES_DESC_ACPI_TABLES = 2,
	IORES_DESC_ACPI_NV_STORAGE = 3,
	IORES_DESC_PERSISTENT_MEMORY = 4,
	IORES_DESC_PERSISTENT_MEMORY_LEGACY = 5,
	IORES_DESC_DEVICE_PRIVATE_MEMORY = 6,
	IORES_DESC_RESERVED = 7,
	IORES_DESC_SOFT_RESERVED = 8,
	IORES_DESC_CXL = 9,
};

enum {
	IORES_MAP_SYSTEM_RAM = 1,
	IORES_MAP_ENCRYPTED = 2,
};

enum {
	IORING_MEM_REGION_REG_WAIT_ARG = 1,
};

enum {
	IORING_MEM_REGION_TYPE_USER = 1,
};

enum {
	IORING_REGISTER_SRC_REGISTERED = 1,
	IORING_REGISTER_DST_REPLACE = 2,
};

enum {
	IORING_REG_WAIT_TS = 1,
};

enum {
	IORING_RSRC_FILE = 0,
	IORING_RSRC_BUFFER = 1,
};

enum {
	IOU_F_TWQ_LAZY_WAKE = 1,
};

enum {
	IOU_OK = 0,
	IOU_ISSUE_SKIP_COMPLETE = -529,
	IOU_REQUEUE = -3072,
	IOU_STOP_MULTISHOT = -125,
};

enum {
	IOU_POLL_DONE = 0,
	IOU_POLL_NO_ACTION = 1,
	IOU_POLL_REMOVE_POLL_USE_RES = 2,
	IOU_POLL_REISSUE = 3,
	IOU_POLL_REQUEUE = 4,
};

enum {
	IO_ACCT_STALLED_BIT = 0,
};

enum {
	IO_APOLL_OK = 0,
	IO_APOLL_ABORTED = 1,
	IO_APOLL_READY = 2,
};

enum {
	IO_CHECK_CQ_OVERFLOW_BIT = 0,
	IO_CHECK_CQ_DROPPED_BIT = 1,
};

enum {
	IO_EVENTFD_OP_SIGNAL_BIT = 0,
};

enum {
	IO_REGION_F_VMAP = 1,
	IO_REGION_F_USER_PROVIDED = 2,
	IO_REGION_F_SINGLE_REF = 4,
};

enum {
	IO_SQ_THREAD_SHOULD_STOP = 0,
	IO_SQ_THREAD_SHOULD_PARK = 1,
};

enum {
	IO_WORKER_F_UP = 0,
	IO_WORKER_F_RUNNING = 1,
	IO_WORKER_F_FREE = 2,
	IO_WORKER_F_BOUND = 3,
};

enum {
	IO_WQ_ACCT_BOUND = 0,
	IO_WQ_ACCT_UNBOUND = 1,
	IO_WQ_ACCT_NR = 2,
};

enum {
	IO_WQ_BIT_EXIT = 0,
};

enum {
	IO_WQ_WORK_CANCEL = 1,
	IO_WQ_WORK_HASHED = 2,
	IO_WQ_WORK_UNBOUND = 4,
	IO_WQ_WORK_CONCURRENT = 16,
	IO_WQ_HASH_SHIFT = 24,
};

enum {
	IP6_FH_F_FRAG = 1,
	IP6_FH_F_AUTH = 2,
	IP6_FH_F_SKIP_RH = 4,
};

enum {
	IPMRA_CREPORT_UNSPEC = 0,
	IPMRA_CREPORT_MSGTYPE = 1,
	IPMRA_CREPORT_VIF_ID = 2,
	IPMRA_CREPORT_SRC_ADDR = 3,
	IPMRA_CREPORT_DST_ADDR = 4,
	IPMRA_CREPORT_PKT = 5,
	IPMRA_CREPORT_TABLE = 6,
	__IPMRA_CREPORT_MAX = 7,
};

enum {
	IPMRA_TABLE_UNSPEC = 0,
	IPMRA_TABLE_ID = 1,
	IPMRA_TABLE_CACHE_RES_QUEUE_LEN = 2,
	IPMRA_TABLE_MROUTE_REG_VIF_NUM = 3,
	IPMRA_TABLE_MROUTE_DO_ASSERT = 4,
	IPMRA_TABLE_MROUTE_DO_PIM = 5,
	IPMRA_TABLE_VIFS = 6,
	IPMRA_TABLE_MROUTE_DO_WRVIFWHOLE = 7,
	__IPMRA_TABLE_MAX = 8,
};

enum {
	IPMRA_VIFA_UNSPEC = 0,
	IPMRA_VIFA_IFINDEX = 1,
	IPMRA_VIFA_VIF_ID = 2,
	IPMRA_VIFA_FLAGS = 3,
	IPMRA_VIFA_BYTES_IN = 4,
	IPMRA_VIFA_BYTES_OUT = 5,
	IPMRA_VIFA_PACKETS_IN = 6,
	IPMRA_VIFA_PACKETS_OUT = 7,
	IPMRA_VIFA_LOCAL_ADDR = 8,
	IPMRA_VIFA_REMOTE_ADDR = 9,
	IPMRA_VIFA_PAD = 10,
	__IPMRA_VIFA_MAX = 11,
};

enum {
	IPMRA_VIF_UNSPEC = 0,
	IPMRA_VIF = 1,
	__IPMRA_VIF_MAX = 2,
};

enum {
	IPPROTO_IP = 0,
	IPPROTO_ICMP = 1,
	IPPROTO_IGMP = 2,
	IPPROTO_IPIP = 4,
	IPPROTO_TCP = 6,
	IPPROTO_EGP = 8,
	IPPROTO_PUP = 12,
	IPPROTO_UDP = 17,
	IPPROTO_IDP = 22,
	IPPROTO_TP = 29,
	IPPROTO_DCCP = 33,
	IPPROTO_IPV6 = 41,
	IPPROTO_RSVP = 46,
	IPPROTO_GRE = 47,
	IPPROTO_ESP = 50,
	IPPROTO_AH = 51,
	IPPROTO_MTP = 92,
	IPPROTO_BEETPH = 94,
	IPPROTO_ENCAP = 98,
	IPPROTO_PIM = 103,
	IPPROTO_COMP = 108,
	IPPROTO_L2TP = 115,
	IPPROTO_SCTP = 132,
	IPPROTO_UDPLITE = 136,
	IPPROTO_MPLS = 137,
	IPPROTO_ETHERNET = 143,
	IPPROTO_AGGFRAG = 144,
	IPPROTO_RAW = 255,
	IPPROTO_SMC = 256,
	IPPROTO_MPTCP = 262,
	IPPROTO_MAX = 263,
};

enum {
	IPSTATS_MIB_NUM = 0,
	IPSTATS_MIB_INPKTS = 1,
	IPSTATS_MIB_INOCTETS = 2,
	IPSTATS_MIB_INDELIVERS = 3,
	IPSTATS_MIB_OUTFORWDATAGRAMS = 4,
	IPSTATS_MIB_OUTREQUESTS = 5,
	IPSTATS_MIB_OUTOCTETS = 6,
	IPSTATS_MIB_INHDRERRORS = 7,
	IPSTATS_MIB_INTOOBIGERRORS = 8,
	IPSTATS_MIB_INNOROUTES = 9,
	IPSTATS_MIB_INADDRERRORS = 10,
	IPSTATS_MIB_INUNKNOWNPROTOS = 11,
	IPSTATS_MIB_INTRUNCATEDPKTS = 12,
	IPSTATS_MIB_INDISCARDS = 13,
	IPSTATS_MIB_OUTDISCARDS = 14,
	IPSTATS_MIB_OUTNOROUTES = 15,
	IPSTATS_MIB_REASMTIMEOUT = 16,
	IPSTATS_MIB_REASMREQDS = 17,
	IPSTATS_MIB_REASMOKS = 18,
	IPSTATS_MIB_REASMFAILS = 19,
	IPSTATS_MIB_FRAGOKS = 20,
	IPSTATS_MIB_FRAGFAILS = 21,
	IPSTATS_MIB_FRAGCREATES = 22,
	IPSTATS_MIB_INMCASTPKTS = 23,
	IPSTATS_MIB_OUTMCASTPKTS = 24,
	IPSTATS_MIB_INBCASTPKTS = 25,
	IPSTATS_MIB_OUTBCASTPKTS = 26,
	IPSTATS_MIB_INMCASTOCTETS = 27,
	IPSTATS_MIB_OUTMCASTOCTETS = 28,
	IPSTATS_MIB_INBCASTOCTETS = 29,
	IPSTATS_MIB_OUTBCASTOCTETS = 30,
	IPSTATS_MIB_CSUMERRORS = 31,
	IPSTATS_MIB_NOECTPKTS = 32,
	IPSTATS_MIB_ECT1PKTS = 33,
	IPSTATS_MIB_ECT0PKTS = 34,
	IPSTATS_MIB_CEPKTS = 35,
	IPSTATS_MIB_REASM_OVERLAPS = 36,
	IPSTATS_MIB_OUTPKTS = 37,
	__IPSTATS_MIB_MAX = 38,
};

enum {
	IPV4_DEVCONF_FORWARDING = 1,
	IPV4_DEVCONF_MC_FORWARDING = 2,
	IPV4_DEVCONF_PROXY_ARP = 3,
	IPV4_DEVCONF_ACCEPT_REDIRECTS = 4,
	IPV4_DEVCONF_SECURE_REDIRECTS = 5,
	IPV4_DEVCONF_SEND_REDIRECTS = 6,
	IPV4_DEVCONF_SHARED_MEDIA = 7,
	IPV4_DEVCONF_RP_FILTER = 8,
	IPV4_DEVCONF_ACCEPT_SOURCE_ROUTE = 9,
	IPV4_DEVCONF_BOOTP_RELAY = 10,
	IPV4_DEVCONF_LOG_MARTIANS = 11,
	IPV4_DEVCONF_TAG = 12,
	IPV4_DEVCONF_ARPFILTER = 13,
	IPV4_DEVCONF_MEDIUM_ID = 14,
	IPV4_DEVCONF_NOXFRM = 15,
	IPV4_DEVCONF_NOPOLICY = 16,
	IPV4_DEVCONF_FORCE_IGMP_VERSION = 17,
	IPV4_DEVCONF_ARP_ANNOUNCE = 18,
	IPV4_DEVCONF_ARP_IGNORE = 19,
	IPV4_DEVCONF_PROMOTE_SECONDARIES = 20,
	IPV4_DEVCONF_ARP_ACCEPT = 21,
	IPV4_DEVCONF_ARP_NOTIFY = 22,
	IPV4_DEVCONF_ACCEPT_LOCAL = 23,
	IPV4_DEVCONF_SRC_VMARK = 24,
	IPV4_DEVCONF_PROXY_ARP_PVLAN = 25,
	IPV4_DEVCONF_ROUTE_LOCALNET = 26,
	IPV4_DEVCONF_IGMPV2_UNSOLICITED_REPORT_INTERVAL = 27,
	IPV4_DEVCONF_IGMPV3_UNSOLICITED_REPORT_INTERVAL = 28,
	IPV4_DEVCONF_IGNORE_ROUTES_WITH_LINKDOWN = 29,
	IPV4_DEVCONF_DROP_UNICAST_IN_L2_MULTICAST = 30,
	IPV4_DEVCONF_DROP_GRATUITOUS_ARP = 31,
	IPV4_DEVCONF_BC_FORWARDING = 32,
	IPV4_DEVCONF_ARP_EVICT_NOCARRIER = 33,
	__IPV4_DEVCONF_MAX = 34,
};

enum {
	IPV6_SADDR_RULE_INIT = 0,
	IPV6_SADDR_RULE_LOCAL = 1,
	IPV6_SADDR_RULE_SCOPE = 2,
	IPV6_SADDR_RULE_PREFERRED = 3,
	IPV6_SADDR_RULE_OIF = 4,
	IPV6_SADDR_RULE_LABEL = 5,
	IPV6_SADDR_RULE_PRIVACY = 6,
	IPV6_SADDR_RULE_ORCHID = 7,
	IPV6_SADDR_RULE_PREFIX = 8,
	IPV6_SADDR_RULE_MAX = 9,
};

enum {
	IP_TUNNEL_CSUM_BIT = 0,
	IP_TUNNEL_ROUTING_BIT = 1,
	IP_TUNNEL_KEY_BIT = 2,
	IP_TUNNEL_SEQ_BIT = 3,
	IP_TUNNEL_STRICT_BIT = 4,
	IP_TUNNEL_REC_BIT = 5,
	IP_TUNNEL_VERSION_BIT = 6,
	IP_TUNNEL_NO_KEY_BIT = 7,
	IP_TUNNEL_DONT_FRAGMENT_BIT = 8,
	IP_TUNNEL_OAM_BIT = 9,
	IP_TUNNEL_CRIT_OPT_BIT = 10,
	IP_TUNNEL_GENEVE_OPT_BIT = 11,
	IP_TUNNEL_VXLAN_OPT_BIT = 12,
	IP_TUNNEL_NOCACHE_BIT = 13,
	IP_TUNNEL_ERSPAN_OPT_BIT = 14,
	IP_TUNNEL_GTP_OPT_BIT = 15,
	IP_TUNNEL_VTI_BIT = 16,
	IP_TUNNEL_SIT_ISATAP_BIT = 16,
	IP_TUNNEL_PFCP_OPT_BIT = 17,
	__IP_TUNNEL_FLAG_NUM = 18,
};

enum {
	IRQCHIP_FWNODE_REAL = 0,
	IRQCHIP_FWNODE_NAMED = 1,
	IRQCHIP_FWNODE_NAMED_ID = 2,
};

enum {
	IRQCHIP_SET_TYPE_MASKED = 1,
	IRQCHIP_EOI_IF_HANDLED = 2,
	IRQCHIP_MASK_ON_SUSPEND = 4,
	IRQCHIP_ONOFFLINE_ENABLED = 8,
	IRQCHIP_SKIP_SET_WAKE = 16,
	IRQCHIP_ONESHOT_SAFE = 32,
	IRQCHIP_EOI_THREADED = 64,
	IRQCHIP_SUPPORTS_LEVEL_MSI = 128,
	IRQCHIP_SUPPORTS_NMI = 256,
	IRQCHIP_ENABLE_WAKEUP_ON_SUSPEND = 512,
	IRQCHIP_AFFINITY_PRE_STARTUP = 1024,
	IRQCHIP_IMMUTABLE = 2048,
	IRQCHIP_MOVE_DEFERRED = 4096,
};

enum {
	IRQC_IS_HARDIRQ = 0,
	IRQC_IS_NESTED = 1,
};

enum {
	IRQD_TRIGGER_MASK = 15,
	IRQD_SETAFFINITY_PENDING = 256,
	IRQD_ACTIVATED = 512,
	IRQD_NO_BALANCING = 1024,
	IRQD_PER_CPU = 2048,
	IRQD_AFFINITY_SET = 4096,
	IRQD_LEVEL = 8192,
	IRQD_WAKEUP_STATE = 16384,
	IRQD_IRQ_DISABLED = 65536,
	IRQD_IRQ_MASKED = 131072,
	IRQD_IRQ_INPROGRESS = 262144,
	IRQD_WAKEUP_ARMED = 524288,
	IRQD_FORWARDED_TO_VCPU = 1048576,
	IRQD_AFFINITY_MANAGED = 2097152,
	IRQD_IRQ_STARTED = 4194304,
	IRQD_MANAGED_SHUTDOWN = 8388608,
	IRQD_SINGLE_TARGET = 16777216,
	IRQD_DEFAULT_TRIGGER_SET = 33554432,
	IRQD_CAN_RESERVE = 67108864,
	IRQD_HANDLE_ENFORCE_IRQCTX = 134217728,
	IRQD_AFFINITY_ON_ACTIVATE = 268435456,
	IRQD_IRQ_ENABLED_ON_SUSPEND = 536870912,
	IRQD_RESEND_WHEN_IN_PROGRESS = 1073741824,
};

enum {
	IRQS_AUTODETECT = 1,
	IRQS_SPURIOUS_DISABLED = 2,
	IRQS_POLL_INPROGRESS = 8,
	IRQS_ONESHOT = 32,
	IRQS_REPLAY = 64,
	IRQS_WAITING = 128,
	IRQS_PENDING = 512,
	IRQS_SUSPENDED = 2048,
	IRQS_TIMINGS = 4096,
	IRQS_NMI = 8192,
	IRQS_SYSFS = 16384,
};

enum {
	IRQTF_RUNTHREAD = 0,
	IRQTF_WARNED = 1,
	IRQTF_AFFINITY = 2,
	IRQTF_FORCED_THREAD = 3,
	IRQTF_READY = 4,
};

enum {
	IRQ_DOMAIN_FLAG_HIERARCHY = 1,
	IRQ_DOMAIN_NAME_ALLOCATED = 2,
	IRQ_DOMAIN_FLAG_IPI_PER_CPU = 4,
	IRQ_DOMAIN_FLAG_IPI_SINGLE = 8,
	IRQ_DOMAIN_FLAG_MSI = 16,
	IRQ_DOMAIN_FLAG_ISOLATED_MSI = 32,
	IRQ_DOMAIN_FLAG_NO_MAP = 64,
	IRQ_DOMAIN_FLAG_MSI_PARENT = 256,
	IRQ_DOMAIN_FLAG_MSI_DEVICE = 512,
	IRQ_DOMAIN_FLAG_DESTROY_GC = 1024,
	IRQ_DOMAIN_FLAG_NONCORE = 65536,
};

enum {
	IRQ_REMAP_XAPIC_MODE = 0,
	IRQ_REMAP_X2APIC_MODE = 1,
};

enum {
	IRQ_SET_MASK_OK = 0,
	IRQ_SET_MASK_OK_NOCOPY = 1,
	IRQ_SET_MASK_OK_DONE = 2,
};

enum {
	IRQ_STARTUP_NORMAL = 0,
	IRQ_STARTUP_MANAGED = 1,
	IRQ_STARTUP_ABORT = 2,
};

enum {
	IRQ_TYPE_NONE = 0,
	IRQ_TYPE_EDGE_RISING = 1,
	IRQ_TYPE_EDGE_FALLING = 2,
	IRQ_TYPE_EDGE_BOTH = 3,
	IRQ_TYPE_LEVEL_HIGH = 4,
	IRQ_TYPE_LEVEL_LOW = 8,
	IRQ_TYPE_LEVEL_MASK = 12,
	IRQ_TYPE_SENSE_MASK = 15,
	IRQ_TYPE_DEFAULT = 15,
	IRQ_TYPE_PROBE = 16,
	IRQ_LEVEL = 256,
	IRQ_PER_CPU = 512,
	IRQ_NOPROBE = 1024,
	IRQ_NOREQUEST = 2048,
	IRQ_NOAUTOEN = 4096,
	IRQ_NO_BALANCING = 8192,
	IRQ_NESTED_THREAD = 32768,
	IRQ_NOTHREAD = 65536,
	IRQ_PER_CPU_DEVID = 131072,
	IRQ_IS_POLLED = 262144,
	IRQ_DISABLE_UNLAZY = 524288,
	IRQ_HIDDEN = 1048576,
	IRQ_NO_DEBUG = 2097152,
};

enum {
	IVBEP_PCI_UNCORE_HA = 0,
	IVBEP_PCI_UNCORE_IMC = 1,
	IVBEP_PCI_UNCORE_IRP = 2,
	IVBEP_PCI_UNCORE_QPI = 3,
	IVBEP_PCI_UNCORE_R2PCIE = 4,
	IVBEP_PCI_UNCORE_R3QPI = 5,
};

enum {
	I_DATA_SEM_NORMAL = 0,
	I_DATA_SEM_OTHER = 1,
	I_DATA_SEM_QUOTA = 2,
	I_DATA_SEM_EA = 3,
};

enum {
	I_LCOEF_RBPS = 0,
	I_LCOEF_RSEQIOPS = 1,
	I_LCOEF_RRANDIOPS = 2,
	I_LCOEF_WBPS = 3,
	I_LCOEF_WSEQIOPS = 4,
	I_LCOEF_WRANDIOPS = 5,
	NR_I_LCOEFS = 6,
};

enum {
	KBUF_MODE_EXPAND = 1,
	KBUF_MODE_FREE = 2,
};

enum {
	KERNEL_PARAM_FL_UNSAFE = 1,
	KERNEL_PARAM_FL_HWPARAM = 2,
};

enum {
	KERNEL_PARAM_OPS_FL_NOARG = 1,
};

enum {
	KF_ARG_DYNPTR_ID = 0,
	KF_ARG_LIST_HEAD_ID = 1,
	KF_ARG_LIST_NODE_ID = 2,
	KF_ARG_RB_ROOT_ID = 3,
	KF_ARG_RB_NODE_ID = 4,
	KF_ARG_WORKQUEUE_ID = 5,
};

enum {
	KNL_PCI_UNCORE_MC_UCLK = 0,
	KNL_PCI_UNCORE_MC_DCLK = 1,
	KNL_PCI_UNCORE_EDC_UCLK = 2,
	KNL_PCI_UNCORE_EDC_ECLK = 3,
	KNL_PCI_UNCORE_M2PCIE = 4,
	KNL_PCI_UNCORE_IRP = 5,
};

enum {
	KTW_FREEZABLE = 1,
};

enum {
	KYBER_ASYNC_PERCENT = 75,
};

enum {
	KYBER_LATENCY_SHIFT = 2,
	KYBER_GOOD_BUCKETS = 4,
	KYBER_LATENCY_BUCKETS = 8,
};

enum {
	KYBER_READ = 0,
	KYBER_WRITE = 1,
	KYBER_DISCARD = 2,
	KYBER_OTHER = 3,
	KYBER_NUM_DOMAINS = 4,
};

enum {
	KYBER_TOTAL_LATENCY = 0,
	KYBER_IO_LATENCY = 1,
};

enum {
	LAST_NORM = 0,
	LAST_ROOT = 1,
	LAST_DOT = 2,
	LAST_DOTDOT = 3,
};

enum {
	LBR_FORMAT_32 = 0,
	LBR_FORMAT_LIP = 1,
	LBR_FORMAT_EIP = 2,
	LBR_FORMAT_EIP_FLAGS = 3,
	LBR_FORMAT_EIP_FLAGS2 = 4,
	LBR_FORMAT_INFO = 5,
	LBR_FORMAT_TIME = 6,
	LBR_FORMAT_INFO2 = 7,
	LBR_FORMAT_MAX_KNOWN = 7,
};

enum {
	LBR_NONE = 0,
	LBR_VALID = 1,
};

enum {
	LCOEF_RPAGE = 0,
	LCOEF_RSEQIO = 1,
	LCOEF_RRANDIO = 2,
	LCOEF_WPAGE = 3,
	LCOEF_WSEQIO = 4,
	LCOEF_WRANDIO = 5,
	NR_LCOEFS = 6,
};

enum {
	LED_PAR_CTRL_COLX = 0,
	LED_PAR_CTRL_ERROR = 1,
	LED_PAR_CTRL_DUPLEX = 2,
	LED_PAR_CTRL_DP_COL = 3,
	LED_PAR_CTRL_SPEED = 4,
	LED_PAR_CTRL_LINK = 5,
	LED_PAR_CTRL_TX = 6,
	LED_PAR_CTRL_RX = 7,
	LED_PAR_CTRL_ACT = 8,
	LED_PAR_CTRL_LNK_RX = 9,
	LED_PAR_CTRL_LNK_AC = 10,
	LED_PAR_CTRL_ACT_BL = 11,
	LED_PAR_CTRL_TX_BL = 12,
	LED_PAR_CTRL_RX_BL = 13,
	LED_PAR_CTRL_COL_BL = 14,
	LED_PAR_CTRL_INACT = 15,
};

enum {
	LIBATA_MAX_PRD = 128,
	LIBATA_DUMB_MAX_PRD = 64,
	ATA_DEF_QUEUE = 1,
	ATA_MAX_QUEUE = 32,
	ATA_TAG_INTERNAL = 32,
	ATA_SHORT_PAUSE = 16,
	ATAPI_MAX_DRAIN = 16384,
	ATA_ALL_DEVICES = 3,
	ATA_SHT_EMULATED = 1,
	ATA_SHT_THIS_ID = -1,
	ATA_TFLAG_LBA48 = 1,
	ATA_TFLAG_ISADDR = 2,
	ATA_TFLAG_DEVICE = 4,
	ATA_TFLAG_WRITE = 8,
	ATA_TFLAG_LBA = 16,
	ATA_TFLAG_FUA = 32,
	ATA_TFLAG_POLLING = 64,
	ATA_DFLAG_LBA = 1,
	ATA_DFLAG_LBA48 = 2,
	ATA_DFLAG_CDB_INTR = 4,
	ATA_DFLAG_NCQ = 8,
	ATA_DFLAG_FLUSH_EXT = 16,
	ATA_DFLAG_ACPI_PENDING = 32,
	ATA_DFLAG_ACPI_FAILED = 64,
	ATA_DFLAG_AN = 128,
	ATA_DFLAG_TRUSTED = 256,
	ATA_DFLAG_FUA = 512,
	ATA_DFLAG_DMADIR = 1024,
	ATA_DFLAG_NCQ_SEND_RECV = 2048,
	ATA_DFLAG_NCQ_PRIO = 4096,
	ATA_DFLAG_CDL = 8192,
	ATA_DFLAG_CFG_MASK = 16383,
	ATA_DFLAG_PIO = 16384,
	ATA_DFLAG_NCQ_OFF = 32768,
	ATA_DFLAG_SLEEPING = 65536,
	ATA_DFLAG_DUBIOUS_XFER = 131072,
	ATA_DFLAG_NO_UNLOAD = 262144,
	ATA_DFLAG_UNLOCK_HPA = 524288,
	ATA_DFLAG_INIT_MASK = 1048575,
	ATA_DFLAG_NCQ_PRIO_ENABLED = 1048576,
	ATA_DFLAG_CDL_ENABLED = 2097152,
	ATA_DFLAG_RESUMING = 4194304,
	ATA_DFLAG_DETACH = 16777216,
	ATA_DFLAG_DETACHED = 33554432,
	ATA_DFLAG_DA = 67108864,
	ATA_DFLAG_DEVSLP = 134217728,
	ATA_DFLAG_ACPI_DISABLED = 268435456,
	ATA_DFLAG_D_SENSE = 536870912,
	ATA_DFLAG_ZAC = 1073741824,
	ATA_DFLAG_FEATURES_MASK = 201341696,
	ATA_DEV_UNKNOWN = 0,
	ATA_DEV_ATA = 1,
	ATA_DEV_ATA_UNSUP = 2,
	ATA_DEV_ATAPI = 3,
	ATA_DEV_ATAPI_UNSUP = 4,
	ATA_DEV_PMP = 5,
	ATA_DEV_PMP_UNSUP = 6,
	ATA_DEV_SEMB = 7,
	ATA_DEV_SEMB_UNSUP = 8,
	ATA_DEV_ZAC = 9,
	ATA_DEV_ZAC_UNSUP = 10,
	ATA_DEV_NONE = 11,
	ATA_LFLAG_NO_HRST = 2,
	ATA_LFLAG_NO_SRST = 4,
	ATA_LFLAG_ASSUME_ATA = 8,
	ATA_LFLAG_ASSUME_SEMB = 16,
	ATA_LFLAG_ASSUME_CLASS = 24,
	ATA_LFLAG_NO_RETRY = 32,
	ATA_LFLAG_DISABLED = 64,
	ATA_LFLAG_SW_ACTIVITY = 128,
	ATA_LFLAG_NO_LPM = 256,
	ATA_LFLAG_RST_ONCE = 512,
	ATA_LFLAG_CHANGED = 1024,
	ATA_LFLAG_NO_DEBOUNCE_DELAY = 2048,
	ATA_FLAG_SLAVE_POSS = 1,
	ATA_FLAG_SATA = 2,
	ATA_FLAG_NO_LPM = 4,
	ATA_FLAG_NO_LOG_PAGE = 32,
	ATA_FLAG_NO_ATAPI = 64,
	ATA_FLAG_PIO_DMA = 128,
	ATA_FLAG_PIO_LBA48 = 256,
	ATA_FLAG_PIO_POLLING = 512,
	ATA_FLAG_NCQ = 1024,
	ATA_FLAG_NO_POWEROFF_SPINDOWN = 2048,
	ATA_FLAG_NO_HIBERNATE_SPINDOWN = 4096,
	ATA_FLAG_DEBUGMSG = 8192,
	ATA_FLAG_FPDMA_AA = 16384,
	ATA_FLAG_IGN_SIMPLEX = 32768,
	ATA_FLAG_NO_IORDY = 65536,
	ATA_FLAG_ACPI_SATA = 131072,
	ATA_FLAG_AN = 262144,
	ATA_FLAG_PMP = 524288,
	ATA_FLAG_FPDMA_AUX = 1048576,
	ATA_FLAG_EM = 2097152,
	ATA_FLAG_SW_ACTIVITY = 4194304,
	ATA_FLAG_NO_DIPM = 8388608,
	ATA_FLAG_SAS_HOST = 16777216,
	ATA_PFLAG_EH_PENDING = 1,
	ATA_PFLAG_EH_IN_PROGRESS = 2,
	ATA_PFLAG_FROZEN = 4,
	ATA_PFLAG_RECOVERED = 8,
	ATA_PFLAG_LOADING = 16,
	ATA_PFLAG_SCSI_HOTPLUG = 64,
	ATA_PFLAG_INITIALIZING = 128,
	ATA_PFLAG_RESETTING = 256,
	ATA_PFLAG_UNLOADING = 512,
	ATA_PFLAG_UNLOADED = 1024,
	ATA_PFLAG_RESUMING = 65536,
	ATA_PFLAG_SUSPENDED = 131072,
	ATA_PFLAG_PM_PENDING = 262144,
	ATA_PFLAG_INIT_GTM_VALID = 524288,
	ATA_PFLAG_PIO32 = 1048576,
	ATA_PFLAG_PIO32CHANGE = 2097152,
	ATA_PFLAG_EXTERNAL = 4194304,
	ATA_QCFLAG_ACTIVE = 1,
	ATA_QCFLAG_DMAMAP = 2,
	ATA_QCFLAG_RTF_FILLED = 4,
	ATA_QCFLAG_IO = 8,
	ATA_QCFLAG_RESULT_TF = 16,
	ATA_QCFLAG_CLEAR_EXCL = 32,
	ATA_QCFLAG_QUIET = 64,
	ATA_QCFLAG_RETRY = 128,
	ATA_QCFLAG_HAS_CDL = 256,
	ATA_QCFLAG_EH = 65536,
	ATA_QCFLAG_SENSE_VALID = 131072,
	ATA_QCFLAG_EH_SCHEDULED = 262144,
	ATA_QCFLAG_EH_SUCCESS_CMD = 524288,
	ATA_HOST_SIMPLEX = 1,
	ATA_HOST_STARTED = 2,
	ATA_HOST_PARALLEL_SCAN = 4,
	ATA_HOST_IGNORE_ATA = 8,
	ATA_HOST_NO_PART = 16,
	ATA_HOST_NO_SSC = 32,
	ATA_HOST_NO_DEVSLP = 64,
	ATA_TMOUT_INTERNAL_QUICK = 5000,
	ATA_TMOUT_MAX_PARK = 30000,
	ATA_TMOUT_FF_WAIT_LONG = 2000,
	ATA_TMOUT_FF_WAIT = 800,
	ATA_WAIT_AFTER_RESET = 150,
	ATA_TMOUT_PMP_SRST_WAIT = 10000,
	ATA_TMOUT_SPURIOUS_PHY = 10000,
	BUS_UNKNOWN = 0,
	BUS_DMA = 1,
	BUS_IDLE = 2,
	BUS_NOINTR = 3,
	BUS_NODATA = 4,
	BUS_TIMER = 5,
	BUS_PIO = 6,
	BUS_EDD = 7,
	BUS_IDENTIFY = 8,
	BUS_PACKET = 9,
	PORT_UNKNOWN = 0,
	PORT_ENABLED = 1,
	PORT_DISABLED = 2,
	ATA_NR_PIO_MODES = 7,
	ATA_NR_MWDMA_MODES = 5,
	ATA_NR_UDMA_MODES = 8,
	ATA_SHIFT_PIO = 0,
	ATA_SHIFT_MWDMA = 7,
	ATA_SHIFT_UDMA = 12,
	ATA_SHIFT_PRIO = 6,
	ATA_PRIO_HIGH = 2,
	ATA_DMA_PAD_SZ = 4,
	ATA_ERING_SIZE = 32,
	ATA_DEFER_LINK = 1,
	ATA_DEFER_PORT = 2,
	ATA_EH_DESC_LEN = 80,
	ATA_EH_REVALIDATE = 1,
	ATA_EH_SOFTRESET = 2,
	ATA_EH_HARDRESET = 4,
	ATA_EH_RESET = 6,
	ATA_EH_ENABLE_LINK = 8,
	ATA_EH_PARK = 32,
	ATA_EH_GET_SUCCESS_SENSE = 64,
	ATA_EH_SET_ACTIVE = 128,
	ATA_EH_PERDEV_MASK = 225,
	ATA_EH_ALL_ACTIONS = 15,
	ATA_EHI_HOTPLUGGED = 1,
	ATA_EHI_NO_AUTOPSY = 4,
	ATA_EHI_QUIET = 8,
	ATA_EHI_NO_RECOVERY = 16,
	ATA_EHI_DID_SOFTRESET = 65536,
	ATA_EHI_DID_HARDRESET = 131072,
	ATA_EHI_PRINTINFO = 262144,
	ATA_EHI_SETMODE = 524288,
	ATA_EHI_POST_SETMODE = 1048576,
	ATA_EHI_DID_PRINT_QUIRKS = 2097152,
	ATA_EHI_DID_RESET = 196608,
	ATA_EHI_TO_SLAVE_MASK = 12,
	ATA_EH_MAX_TRIES = 5,
	ATA_LINK_RESUME_TRIES = 5,
	ATA_EH_DEV_TRIES = 3,
	ATA_EH_PMP_TRIES = 5,
	ATA_EH_PMP_LINK_TRIES = 3,
	SATA_PMP_RW_TIMEOUT = 3000,
	ATA_EH_CMD_TIMEOUT_TABLE_SIZE = 8,
	ATA_QUIRK_DIAGNOSTIC = 1,
	ATA_QUIRK_NODMA = 2,
	ATA_QUIRK_NONCQ = 4,
	ATA_QUIRK_MAX_SEC_128 = 8,
	ATA_QUIRK_BROKEN_HPA = 16,
	ATA_QUIRK_DISABLE = 32,
	ATA_QUIRK_HPA_SIZE = 64,
	ATA_QUIRK_IVB = 128,
	ATA_QUIRK_STUCK_ERR = 256,
	ATA_QUIRK_BRIDGE_OK = 512,
	ATA_QUIRK_ATAPI_MOD16_DMA = 1024,
	ATA_QUIRK_FIRMWARE_WARN = 2048,
	ATA_QUIRK_1_5_GBPS = 4096,
	ATA_QUIRK_NOSETXFER = 8192,
	ATA_QUIRK_BROKEN_FPDMA_AA = 16384,
	ATA_QUIRK_DUMP_ID = 32768,
	ATA_QUIRK_MAX_SEC_LBA48 = 65536,
	ATA_QUIRK_ATAPI_DMADIR = 131072,
	ATA_QUIRK_NO_NCQ_TRIM = 262144,
	ATA_QUIRK_NOLPM = 524288,
	ATA_QUIRK_WD_BROKEN_LPM = 1048576,
	ATA_QUIRK_ZERO_AFTER_TRIM = 2097152,
	ATA_QUIRK_NO_DMA_LOG = 4194304,
	ATA_QUIRK_NOTRIM = 8388608,
	ATA_QUIRK_MAX_SEC_1024 = 16777216,
	ATA_QUIRK_MAX_TRIM_128M = 33554432,
	ATA_QUIRK_NO_NCQ_ON_ATI = 67108864,
	ATA_QUIRK_NO_LPM_ON_ATI = 134217728,
	ATA_QUIRK_NO_ID_DEV_LOG = 268435456,
	ATA_QUIRK_NO_LOG_DIR = 536870912,
	ATA_QUIRK_NO_FUA = 1073741824,
	ATA_DMA_MASK_ATA = 1,
	ATA_DMA_MASK_ATAPI = 2,
	ATA_DMA_MASK_CFA = 4,
	ATAPI_READ = 0,
	ATAPI_WRITE = 1,
	ATAPI_READ_CD = 2,
	ATAPI_PASS_THRU = 3,
	ATAPI_MISC = 4,
	ATA_TIMING_SETUP = 1,
	ATA_TIMING_ACT8B = 2,
	ATA_TIMING_REC8B = 4,
	ATA_TIMING_CYC8B = 8,
	ATA_TIMING_8BIT = 14,
	ATA_TIMING_ACTIVE = 16,
	ATA_TIMING_RECOVER = 32,
	ATA_TIMING_DMACK_HOLD = 64,
	ATA_TIMING_CYCLE = 128,
	ATA_TIMING_UDMA = 256,
	ATA_TIMING_ALL = 511,
	ATA_ACPI_FILTER_SETXFER = 1,
	ATA_ACPI_FILTER_LOCK = 2,
	ATA_ACPI_FILTER_DIPM = 4,
	ATA_ACPI_FILTER_FPDMA_OFFSET = 8,
	ATA_ACPI_FILTER_FPDMA_AA = 16,
	ATA_ACPI_FILTER_DEFAULT = 7,
};

enum {
	LINKLED_OFF = 1,
	LINKLED_ON = 2,
	LINKLED_LINKSYNC_OFF = 4,
	LINKLED_LINKSYNC_ON = 8,
	LINKLED_BLINK_OFF = 16,
	LINKLED_BLINK_ON = 32,
};

enum {
	LINUX_MIB_NUM = 0,
	LINUX_MIB_SYNCOOKIESSENT = 1,
	LINUX_MIB_SYNCOOKIESRECV = 2,
	LINUX_MIB_SYNCOOKIESFAILED = 3,
	LINUX_MIB_EMBRYONICRSTS = 4,
	LINUX_MIB_PRUNECALLED = 5,
	LINUX_MIB_RCVPRUNED = 6,
	LINUX_MIB_OFOPRUNED = 7,
	LINUX_MIB_OUTOFWINDOWICMPS = 8,
	LINUX_MIB_LOCKDROPPEDICMPS = 9,
	LINUX_MIB_ARPFILTER = 10,
	LINUX_MIB_TIMEWAITED = 11,
	LINUX_MIB_TIMEWAITRECYCLED = 12,
	LINUX_MIB_TIMEWAITKILLED = 13,
	LINUX_MIB_PAWSACTIVEREJECTED = 14,
	LINUX_MIB_PAWSESTABREJECTED = 15,
	LINUX_MIB_PAWS_OLD_ACK = 16,
	LINUX_MIB_DELAYEDACKS = 17,
	LINUX_MIB_DELAYEDACKLOCKED = 18,
	LINUX_MIB_DELAYEDACKLOST = 19,
	LINUX_MIB_LISTENOVERFLOWS = 20,
	LINUX_MIB_LISTENDROPS = 21,
	LINUX_MIB_TCPHPHITS = 22,
	LINUX_MIB_TCPPUREACKS = 23,
	LINUX_MIB_TCPHPACKS = 24,
	LINUX_MIB_TCPRENORECOVERY = 25,
	LINUX_MIB_TCPSACKRECOVERY = 26,
	LINUX_MIB_TCPSACKRENEGING = 27,
	LINUX_MIB_TCPSACKREORDER = 28,
	LINUX_MIB_TCPRENOREORDER = 29,
	LINUX_MIB_TCPTSREORDER = 30,
	LINUX_MIB_TCPFULLUNDO = 31,
	LINUX_MIB_TCPPARTIALUNDO = 32,
	LINUX_MIB_TCPDSACKUNDO = 33,
	LINUX_MIB_TCPLOSSUNDO = 34,
	LINUX_MIB_TCPLOSTRETRANSMIT = 35,
	LINUX_MIB_TCPRENOFAILURES = 36,
	LINUX_MIB_TCPSACKFAILURES = 37,
	LINUX_MIB_TCPLOSSFAILURES = 38,
	LINUX_MIB_TCPFASTRETRANS = 39,
	LINUX_MIB_TCPSLOWSTARTRETRANS = 40,
	LINUX_MIB_TCPTIMEOUTS = 41,
	LINUX_MIB_TCPLOSSPROBES = 42,
	LINUX_MIB_TCPLOSSPROBERECOVERY = 43,
	LINUX_MIB_TCPRENORECOVERYFAIL = 44,
	LINUX_MIB_TCPSACKRECOVERYFAIL = 45,
	LINUX_MIB_TCPRCVCOLLAPSED = 46,
	LINUX_MIB_TCPDSACKOLDSENT = 47,
	LINUX_MIB_TCPDSACKOFOSENT = 48,
	LINUX_MIB_TCPDSACKRECV = 49,
	LINUX_MIB_TCPDSACKOFORECV = 50,
	LINUX_MIB_TCPABORTONDATA = 51,
	LINUX_MIB_TCPABORTONCLOSE = 52,
	LINUX_MIB_TCPABORTONMEMORY = 53,
	LINUX_MIB_TCPABORTONTIMEOUT = 54,
	LINUX_MIB_TCPABORTONLINGER = 55,
	LINUX_MIB_TCPABORTFAILED = 56,
	LINUX_MIB_TCPMEMORYPRESSURES = 57,
	LINUX_MIB_TCPMEMORYPRESSURESCHRONO = 58,
	LINUX_MIB_TCPSACKDISCARD = 59,
	LINUX_MIB_TCPDSACKIGNOREDOLD = 60,
	LINUX_MIB_TCPDSACKIGNOREDNOUNDO = 61,
	LINUX_MIB_TCPSPURIOUSRTOS = 62,
	LINUX_MIB_TCPMD5NOTFOUND = 63,
	LINUX_MIB_TCPMD5UNEXPECTED = 64,
	LINUX_MIB_TCPMD5FAILURE = 65,
	LINUX_MIB_SACKSHIFTED = 66,
	LINUX_MIB_SACKMERGED = 67,
	LINUX_MIB_SACKSHIFTFALLBACK = 68,
	LINUX_MIB_TCPBACKLOGDROP = 69,
	LINUX_MIB_PFMEMALLOCDROP = 70,
	LINUX_MIB_TCPMINTTLDROP = 71,
	LINUX_MIB_TCPDEFERACCEPTDROP = 72,
	LINUX_MIB_IPRPFILTER = 73,
	LINUX_MIB_TCPTIMEWAITOVERFLOW = 74,
	LINUX_MIB_TCPREQQFULLDOCOOKIES = 75,
	LINUX_MIB_TCPREQQFULLDROP = 76,
	LINUX_MIB_TCPRETRANSFAIL = 77,
	LINUX_MIB_TCPRCVCOALESCE = 78,
	LINUX_MIB_TCPBACKLOGCOALESCE = 79,
	LINUX_MIB_TCPOFOQUEUE = 80,
	LINUX_MIB_TCPOFODROP = 81,
	LINUX_MIB_TCPOFOMERGE = 82,
	LINUX_MIB_TCPCHALLENGEACK = 83,
	LINUX_MIB_TCPSYNCHALLENGE = 84,
	LINUX_MIB_TCPFASTOPENACTIVE = 85,
	LINUX_MIB_TCPFASTOPENACTIVEFAIL = 86,
	LINUX_MIB_TCPFASTOPENPASSIVE = 87,
	LINUX_MIB_TCPFASTOPENPASSIVEFAIL = 88,
	LINUX_MIB_TCPFASTOPENLISTENOVERFLOW = 89,
	LINUX_MIB_TCPFASTOPENCOOKIEREQD = 90,
	LINUX_MIB_TCPFASTOPENBLACKHOLE = 91,
	LINUX_MIB_TCPSPURIOUS_RTX_HOSTQUEUES = 92,
	LINUX_MIB_BUSYPOLLRXPACKETS = 93,
	LINUX_MIB_TCPAUTOCORKING = 94,
	LINUX_MIB_TCPFROMZEROWINDOWADV = 95,
	LINUX_MIB_TCPTOZEROWINDOWADV = 96,
	LINUX_MIB_TCPWANTZEROWINDOWADV = 97,
	LINUX_MIB_TCPSYNRETRANS = 98,
	LINUX_MIB_TCPORIGDATASENT = 99,
	LINUX_MIB_TCPHYSTARTTRAINDETECT = 100,
	LINUX_MIB_TCPHYSTARTTRAINCWND = 101,
	LINUX_MIB_TCPHYSTARTDELAYDETECT = 102,
	LINUX_MIB_TCPHYSTARTDELAYCWND = 103,
	LINUX_MIB_TCPACKSKIPPEDSYNRECV = 104,
	LINUX_MIB_TCPACKSKIPPEDPAWS = 105,
	LINUX_MIB_TCPACKSKIPPEDSEQ = 106,
	LINUX_MIB_TCPACKSKIPPEDFINWAIT2 = 107,
	LINUX_MIB_TCPACKSKIPPEDTIMEWAIT = 108,
	LINUX_MIB_TCPACKSKIPPEDCHALLENGE = 109,
	LINUX_MIB_TCPWINPROBE = 110,
	LINUX_MIB_TCPKEEPALIVE = 111,
	LINUX_MIB_TCPMTUPFAIL = 112,
	LINUX_MIB_TCPMTUPSUCCESS = 113,
	LINUX_MIB_TCPDELIVERED = 114,
	LINUX_MIB_TCPDELIVEREDCE = 115,
	LINUX_MIB_TCPACKCOMPRESSED = 116,
	LINUX_MIB_TCPZEROWINDOWDROP = 117,
	LINUX_MIB_TCPRCVQDROP = 118,
	LINUX_MIB_TCPWQUEUETOOBIG = 119,
	LINUX_MIB_TCPFASTOPENPASSIVEALTKEY = 120,
	LINUX_MIB_TCPTIMEOUTREHASH = 121,
	LINUX_MIB_TCPDUPLICATEDATAREHASH = 122,
	LINUX_MIB_TCPDSACKRECVSEGS = 123,
	LINUX_MIB_TCPDSACKIGNOREDDUBIOUS = 124,
	LINUX_MIB_TCPMIGRATEREQSUCCESS = 125,
	LINUX_MIB_TCPMIGRATEREQFAILURE = 126,
	LINUX_MIB_TCPPLBREHASH = 127,
	LINUX_MIB_TCPAOREQUIRED = 128,
	LINUX_MIB_TCPAOBAD = 129,
	LINUX_MIB_TCPAOKEYNOTFOUND = 130,
	LINUX_MIB_TCPAOGOOD = 131,
	LINUX_MIB_TCPAODROPPEDICMPS = 132,
	__LINUX_MIB_MAX = 133,
};

enum {
	LINUX_MIB_TLSNUM = 0,
	LINUX_MIB_TLSCURRTXSW = 1,
	LINUX_MIB_TLSCURRRXSW = 2,
	LINUX_MIB_TLSCURRTXDEVICE = 3,
	LINUX_MIB_TLSCURRRXDEVICE = 4,
	LINUX_MIB_TLSTXSW = 5,
	LINUX_MIB_TLSRXSW = 6,
	LINUX_MIB_TLSTXDEVICE = 7,
	LINUX_MIB_TLSRXDEVICE = 8,
	LINUX_MIB_TLSDECRYPTERROR = 9,
	LINUX_MIB_TLSRXDEVICERESYNC = 10,
	LINUX_MIB_TLSDECRYPTRETRY = 11,
	LINUX_MIB_TLSRXNOPADVIOL = 12,
	LINUX_MIB_TLSRXREKEYOK = 13,
	LINUX_MIB_TLSRXREKEYERROR = 14,
	LINUX_MIB_TLSTXREKEYOK = 15,
	LINUX_MIB_TLSTXREKEYERROR = 16,
	LINUX_MIB_TLSRXREKEYRECEIVED = 17,
	__LINUX_MIB_TLSMAX = 18,
};

enum {
	LINUX_MIB_XFRMNUM = 0,
	LINUX_MIB_XFRMINERROR = 1,
	LINUX_MIB_XFRMINBUFFERERROR = 2,
	LINUX_MIB_XFRMINHDRERROR = 3,
	LINUX_MIB_XFRMINNOSTATES = 4,
	LINUX_MIB_XFRMINSTATEPROTOERROR = 5,
	LINUX_MIB_XFRMINSTATEMODEERROR = 6,
	LINUX_MIB_XFRMINSTATESEQERROR = 7,
	LINUX_MIB_XFRMINSTATEEXPIRED = 8,
	LINUX_MIB_XFRMINSTATEMISMATCH = 9,
	LINUX_MIB_XFRMINSTATEINVALID = 10,
	LINUX_MIB_XFRMINTMPLMISMATCH = 11,
	LINUX_MIB_XFRMINNOPOLS = 12,
	LINUX_MIB_XFRMINPOLBLOCK = 13,
	LINUX_MIB_XFRMINPOLERROR = 14,
	LINUX_MIB_XFRMOUTERROR = 15,
	LINUX_MIB_XFRMOUTBUNDLEGENERROR = 16,
	LINUX_MIB_XFRMOUTBUNDLECHECKERROR = 17,
	LINUX_MIB_XFRMOUTNOSTATES = 18,
	LINUX_MIB_XFRMOUTSTATEPROTOERROR = 19,
	LINUX_MIB_XFRMOUTSTATEMODEERROR = 20,
	LINUX_MIB_XFRMOUTSTATESEQERROR = 21,
	LINUX_MIB_XFRMOUTSTATEEXPIRED = 22,
	LINUX_MIB_XFRMOUTPOLBLOCK = 23,
	LINUX_MIB_XFRMOUTPOLDEAD = 24,
	LINUX_MIB_XFRMOUTPOLERROR = 25,
	LINUX_MIB_XFRMFWDHDRERROR = 26,
	LINUX_MIB_XFRMOUTSTATEINVALID = 27,
	LINUX_MIB_XFRMACQUIREERROR = 28,
	LINUX_MIB_XFRMOUTSTATEDIRERROR = 29,
	LINUX_MIB_XFRMINSTATEDIRERROR = 30,
	LINUX_MIB_XFRMINIPTFSERROR = 31,
	LINUX_MIB_XFRMOUTNOQSPACE = 32,
	__LINUX_MIB_XFRMMAX = 33,
};

enum {
	LK_STATE_IN_USE = 0,
	NFS_DELEGATED_STATE = 1,
	NFS_OPEN_STATE = 2,
	NFS_O_RDONLY_STATE = 3,
	NFS_O_WRONLY_STATE = 4,
	NFS_O_RDWR_STATE = 5,
	NFS_STATE_RECLAIM_REBOOT = 6,
	NFS_STATE_RECLAIM_NOGRACE = 7,
	NFS_STATE_POSIX_LOCKS = 8,
	NFS_STATE_RECOVERY_FAILED = 9,
	NFS_STATE_MAY_NOTIFY_LOCK = 10,
	NFS_STATE_CHANGE_WAIT = 11,
	NFS_CLNT_DST_SSC_COPY_STATE = 12,
	NFS_CLNT_SRC_SSC_COPY_STATE = 13,
	NFS_SRV_SSC_COPY_STATE = 14,
};

enum {
	LNK_SYNC_INI = 3120,
	LNK_SYNC_VAL = 3124,
	LNK_SYNC_CTRL = 3128,
	LNK_SYNC_TST = 3129,
	LNK_LED_REG = 3132,
	RX_GMF_EA = 3136,
	RX_GMF_AF_THR = 3140,
	RX_GMF_CTRL_T = 3144,
	RX_GMF_FL_MSK = 3148,
	RX_GMF_FL_THR = 3152,
	RX_GMF_FL_CTRL = 3154,
	RX_GMF_TR_THR = 3156,
	RX_GMF_UP_THR = 3160,
	RX_GMF_LP_THR = 3162,
	RX_GMF_VLAN = 3164,
	RX_GMF_WP = 3168,
	RX_GMF_WLEV = 3176,
	RX_GMF_RP = 3184,
	RX_GMF_RLEV = 3192,
};

enum {
	LOGIC_PIO_INDIRECT = 0,
	LOGIC_PIO_CPU_MMIO = 1,
};

enum {
	LO_FLAGS_READ_ONLY = 1,
	LO_FLAGS_AUTOCLEAR = 4,
	LO_FLAGS_PARTSCAN = 8,
	LO_FLAGS_DIRECT_IO = 16,
};

enum {
	LWTUNNEL_IP_OPTS_UNSPEC = 0,
	LWTUNNEL_IP_OPTS_GENEVE = 1,
	LWTUNNEL_IP_OPTS_VXLAN = 2,
	LWTUNNEL_IP_OPTS_ERSPAN = 3,
	__LWTUNNEL_IP_OPTS_MAX = 4,
};

enum {
	LWTUNNEL_IP_OPT_ERSPAN_UNSPEC = 0,
	LWTUNNEL_IP_OPT_ERSPAN_VER = 1,
	LWTUNNEL_IP_OPT_ERSPAN_INDEX = 2,
	LWTUNNEL_IP_OPT_ERSPAN_DIR = 3,
	LWTUNNEL_IP_OPT_ERSPAN_HWID = 4,
	__LWTUNNEL_IP_OPT_ERSPAN_MAX = 5,
};

enum {
	LWTUNNEL_IP_OPT_GENEVE_UNSPEC = 0,
	LWTUNNEL_IP_OPT_GENEVE_CLASS = 1,
	LWTUNNEL_IP_OPT_GENEVE_TYPE = 2,
	LWTUNNEL_IP_OPT_GENEVE_DATA = 3,
	__LWTUNNEL_IP_OPT_GENEVE_MAX = 4,
};

enum {
	LWTUNNEL_IP_OPT_VXLAN_UNSPEC = 0,
	LWTUNNEL_IP_OPT_VXLAN_GBP = 1,
	__LWTUNNEL_IP_OPT_VXLAN_MAX = 2,
};

enum {
	LWTUNNEL_XMIT_DONE = 0,
	LWTUNNEL_XMIT_CONTINUE = 256,
};

enum {
	Lo_unbound = 0,
	Lo_bound = 1,
	Lo_rundown = 2,
	Lo_deleting = 3,
};

enum {
	MAC_TX_CLK_0_MHZ = 2,
	MAC_TX_CLK_2_5_MHZ = 6,
	MAC_TX_CLK_25_MHZ = 7,
};

enum {
	MAGNITUDE_STRONG = 2,
	MAGNITUDE_WEAK = 3,
	MAGNITUDE_NUM = 4,
};

enum {
	MATCH_MTR = 0,
	MATCH_MEQ = 1,
	MATCH_MLE = 2,
	MATCH_MLT = 3,
	MATCH_MGE = 4,
	MATCH_MGT = 5,
};

enum {
	MAX_IORES_LEVEL = 5,
};

enum {
	MAX_OPT_ARGS = 3,
};

enum {
	MBE_REFERENCED_B = 0,
	MBE_REUSABLE_B = 1,
};

enum {
	MB_INODE_PA = 0,
	MB_GROUP_PA = 1,
};

enum {
	MDBA_GET_ENTRY_UNSPEC = 0,
	MDBA_GET_ENTRY = 1,
	MDBA_GET_ENTRY_ATTRS = 2,
	__MDBA_GET_ENTRY_MAX = 3,
};

enum {
	MDBA_SET_ENTRY_UNSPEC = 0,
	MDBA_SET_ENTRY = 1,
	MDBA_SET_ENTRY_ATTRS = 2,
	__MDBA_SET_ENTRY_MAX = 3,
};

enum {
	MD_RESYNC_NONE = 0,
	MD_RESYNC_YIELDED = 1,
	MD_RESYNC_DELAYED = 2,
	MD_RESYNC_ACTIVE = 3,
};

enum {
	MEMBARRIER_FLAG_SYNC_CORE = 1,
	MEMBARRIER_FLAG_RSEQ = 2,
};

enum {
	MEMBARRIER_STATE_PRIVATE_EXPEDITED_READY = 1,
	MEMBARRIER_STATE_PRIVATE_EXPEDITED = 2,
	MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY = 4,
	MEMBARRIER_STATE_GLOBAL_EXPEDITED = 8,
	MEMBARRIER_STATE_PRIVATE_EXPEDITED_SYNC_CORE_READY = 16,
	MEMBARRIER_STATE_PRIVATE_EXPEDITED_SYNC_CORE = 32,
	MEMBARRIER_STATE_PRIVATE_EXPEDITED_RSEQ_READY = 64,
	MEMBARRIER_STATE_PRIVATE_EXPEDITED_RSEQ = 128,
};

enum {
	MEMREMAP_WB = 1,
	MEMREMAP_WT = 2,
	MEMREMAP_WC = 4,
	MEMREMAP_ENC = 8,
	MEMREMAP_DEC = 16,
};

enum {
	MEMTYPE_EXACT_MATCH = 0,
	MEMTYPE_END_MATCH = 1,
};

enum {
	MFC_STATIC = 1,
	MFC_OFFLOAD = 2,
};

enum {
	MILLION = 1000000,
	MIN_PERIOD = 1000,
	MAX_PERIOD = 1000000,
	MARGIN_MIN_PCT = 10,
	MARGIN_LOW_PCT = 20,
	MARGIN_TARGET_PCT = 50,
	INUSE_ADJ_STEP_PCT = 25,
	TIMER_SLACK_PCT = 1,
	WEIGHT_ONE = 65536,
};

enum {
	MIPI_DCS_NOP = 0,
	MIPI_DCS_SOFT_RESET = 1,
	MIPI_DCS_GET_COMPRESSION_MODE = 3,
	MIPI_DCS_GET_DISPLAY_ID = 4,
	MIPI_DCS_GET_ERROR_COUNT_ON_DSI = 5,
	MIPI_DCS_GET_RED_CHANNEL = 6,
	MIPI_DCS_GET_GREEN_CHANNEL = 7,
	MIPI_DCS_GET_BLUE_CHANNEL = 8,
	MIPI_DCS_GET_DISPLAY_STATUS = 9,
	MIPI_DCS_GET_POWER_MODE = 10,
	MIPI_DCS_GET_ADDRESS_MODE = 11,
	MIPI_DCS_GET_PIXEL_FORMAT = 12,
	MIPI_DCS_GET_DISPLAY_MODE = 13,
	MIPI_DCS_GET_SIGNAL_MODE = 14,
	MIPI_DCS_GET_DIAGNOSTIC_RESULT = 15,
	MIPI_DCS_ENTER_SLEEP_MODE = 16,
	MIPI_DCS_EXIT_SLEEP_MODE = 17,
	MIPI_DCS_ENTER_PARTIAL_MODE = 18,
	MIPI_DCS_ENTER_NORMAL_MODE = 19,
	MIPI_DCS_GET_IMAGE_CHECKSUM_RGB = 20,
	MIPI_DCS_GET_IMAGE_CHECKSUM_CT = 21,
	MIPI_DCS_EXIT_INVERT_MODE = 32,
	MIPI_DCS_ENTER_INVERT_MODE = 33,
	MIPI_DCS_SET_GAMMA_CURVE = 38,
	MIPI_DCS_SET_DISPLAY_OFF = 40,
	MIPI_DCS_SET_DISPLAY_ON = 41,
	MIPI_DCS_SET_COLUMN_ADDRESS = 42,
	MIPI_DCS_SET_PAGE_ADDRESS = 43,
	MIPI_DCS_WRITE_MEMORY_START = 44,
	MIPI_DCS_WRITE_LUT = 45,
	MIPI_DCS_READ_MEMORY_START = 46,
	MIPI_DCS_SET_PARTIAL_ROWS = 48,
	MIPI_DCS_SET_PARTIAL_COLUMNS = 49,
	MIPI_DCS_SET_SCROLL_AREA = 51,
	MIPI_DCS_SET_TEAR_OFF = 52,
	MIPI_DCS_SET_TEAR_ON = 53,
	MIPI_DCS_SET_ADDRESS_MODE = 54,
	MIPI_DCS_SET_SCROLL_START = 55,
	MIPI_DCS_EXIT_IDLE_MODE = 56,
	MIPI_DCS_ENTER_IDLE_MODE = 57,
	MIPI_DCS_SET_PIXEL_FORMAT = 58,
	MIPI_DCS_WRITE_MEMORY_CONTINUE = 60,
	MIPI_DCS_SET_3D_CONTROL = 61,
	MIPI_DCS_READ_MEMORY_CONTINUE = 62,
	MIPI_DCS_GET_3D_CONTROL = 63,
	MIPI_DCS_SET_VSYNC_TIMING = 64,
	MIPI_DCS_SET_TEAR_SCANLINE = 68,
	MIPI_DCS_GET_SCANLINE = 69,
	MIPI_DCS_SET_DISPLAY_BRIGHTNESS = 81,
	MIPI_DCS_GET_DISPLAY_BRIGHTNESS = 82,
	MIPI_DCS_WRITE_CONTROL_DISPLAY = 83,
	MIPI_DCS_GET_CONTROL_DISPLAY = 84,
	MIPI_DCS_WRITE_POWER_SAVE = 85,
	MIPI_DCS_GET_POWER_SAVE = 86,
	MIPI_DCS_SET_CABC_MIN_BRIGHTNESS = 94,
	MIPI_DCS_GET_CABC_MIN_BRIGHTNESS = 95,
	MIPI_DCS_READ_DDB_START = 161,
	MIPI_DCS_READ_PPS_START = 162,
	MIPI_DCS_READ_DDB_CONTINUE = 168,
	MIPI_DCS_READ_PPS_CONTINUE = 169,
};

enum {
	MIPI_DSI_V_SYNC_START = 1,
	MIPI_DSI_V_SYNC_END = 17,
	MIPI_DSI_H_SYNC_START = 33,
	MIPI_DSI_H_SYNC_END = 49,
	MIPI_DSI_COMPRESSION_MODE = 7,
	MIPI_DSI_END_OF_TRANSMISSION = 8,
	MIPI_DSI_COLOR_MODE_OFF = 2,
	MIPI_DSI_COLOR_MODE_ON = 18,
	MIPI_DSI_SHUTDOWN_PERIPHERAL = 34,
	MIPI_DSI_TURN_ON_PERIPHERAL = 50,
	MIPI_DSI_GENERIC_SHORT_WRITE_0_PARAM = 3,
	MIPI_DSI_GENERIC_SHORT_WRITE_1_PARAM = 19,
	MIPI_DSI_GENERIC_SHORT_WRITE_2_PARAM = 35,
	MIPI_DSI_GENERIC_READ_REQUEST_0_PARAM = 4,
	MIPI_DSI_GENERIC_READ_REQUEST_1_PARAM = 20,
	MIPI_DSI_GENERIC_READ_REQUEST_2_PARAM = 36,
	MIPI_DSI_DCS_SHORT_WRITE = 5,
	MIPI_DSI_DCS_SHORT_WRITE_PARAM = 21,
	MIPI_DSI_DCS_READ = 6,
	MIPI_DSI_EXECUTE_QUEUE = 22,
	MIPI_DSI_SET_MAXIMUM_RETURN_PACKET_SIZE = 55,
	MIPI_DSI_NULL_PACKET = 9,
	MIPI_DSI_BLANKING_PACKET = 25,
	MIPI_DSI_GENERIC_LONG_WRITE = 41,
	MIPI_DSI_DCS_LONG_WRITE = 57,
	MIPI_DSI_PICTURE_PARAMETER_SET = 10,
	MIPI_DSI_COMPRESSED_PIXEL_STREAM = 11,
	MIPI_DSI_LOOSELY_PACKED_PIXEL_STREAM_YCBCR20 = 12,
	MIPI_DSI_PACKED_PIXEL_STREAM_YCBCR24 = 28,
	MIPI_DSI_PACKED_PIXEL_STREAM_YCBCR16 = 44,
	MIPI_DSI_PACKED_PIXEL_STREAM_30 = 13,
	MIPI_DSI_PACKED_PIXEL_STREAM_36 = 29,
	MIPI_DSI_PACKED_PIXEL_STREAM_YCBCR12 = 61,
	MIPI_DSI_PACKED_PIXEL_STREAM_16 = 14,
	MIPI_DSI_PACKED_PIXEL_STREAM_18 = 30,
	MIPI_DSI_PIXEL_STREAM_3BYTE_18 = 46,
	MIPI_DSI_PACKED_PIXEL_STREAM_24 = 62,
};

enum {
	MIPI_RESET_1 = 0,
	MIPI_AVDD_EN_1 = 1,
	MIPI_BKLT_EN_1 = 2,
	MIPI_AVEE_EN_1 = 3,
	MIPI_VIO_EN_1 = 4,
	MIPI_RESET_2 = 5,
	MIPI_AVDD_EN_2 = 6,
	MIPI_BKLT_EN_2 = 7,
	MIPI_AVEE_EN_2 = 8,
	MIPI_VIO_EN_2 = 9,
};

enum {
	MIX_INFLIGHT = 2147483648,
};

enum {
	MM_FILEPAGES = 0,
	MM_ANONPAGES = 1,
	MM_SWAPENTS = 2,
	MM_SHMEMPAGES = 3,
	NR_MM_COUNTERS = 4,
};

enum {
	MODE_640x480 = 0,
	MODE_800x600 = 1,
	MODE_1024x768 = 2,
};

enum {
	MOUNTPROC3_NULL = 0,
	MOUNTPROC3_MNT = 1,
	MOUNTPROC3_DUMP = 2,
	MOUNTPROC3_UMNT = 3,
	MOUNTPROC3_UMNTALL = 4,
	MOUNTPROC3_EXPORT = 5,
};

enum {
	MOUNTPROC_NULL = 0,
	MOUNTPROC_MNT = 1,
	MOUNTPROC_DUMP = 2,
	MOUNTPROC_UMNT = 3,
	MOUNTPROC_UMNTALL = 4,
	MOUNTPROC_EXPORT = 5,
};

enum {
	MOXA_SUPP_RS232 = 1,
	MOXA_SUPP_RS422 = 2,
	MOXA_SUPP_RS485 = 4,
};

enum {
	MPOL_DEFAULT = 0,
	MPOL_PREFERRED = 1,
	MPOL_BIND = 2,
	MPOL_INTERLEAVE = 3,
	MPOL_LOCAL = 4,
	MPOL_PREFERRED_MANY = 5,
	MPOL_WEIGHTED_INTERLEAVE = 6,
	MPOL_MAX = 7,
};

enum {
	MSI_FLAG_USE_DEF_DOM_OPS = 1,
	MSI_FLAG_USE_DEF_CHIP_OPS = 2,
	MSI_FLAG_ACTIVATE_EARLY = 4,
	MSI_FLAG_MUST_REACTIVATE = 8,
	MSI_FLAG_DEV_SYSFS = 16,
	MSI_FLAG_ALLOC_SIMPLE_MSI_DESCS = 32,
	MSI_FLAG_FREE_MSI_DESCS = 64,
	MSI_FLAG_USE_DEV_FWNODE = 128,
	MSI_FLAG_PARENT_PM_DEV = 256,
	MSI_FLAG_PCI_MSI_MASK_PARENT = 512,
	MSI_GENERIC_FLAGS_MASK = 65535,
	MSI_DOMAIN_FLAGS_MASK = 4294901760,
	MSI_FLAG_MULTI_PCI_MSI = 65536,
	MSI_FLAG_PCI_MSIX = 131072,
	MSI_FLAG_LEVEL_CAPABLE = 262144,
	MSI_FLAG_MSIX_CONTIGUOUS = 524288,
	MSI_FLAG_PCI_MSIX_ALLOC_DYN = 1048576,
	MSI_FLAG_NO_AFFINITY = 2097152,
};

enum {
	MTTG_TRAV_INIT = 0,
	MTTG_TRAV_NFP_UNSPEC = 1,
	MTTG_TRAV_NFP_SPEC = 2,
	MTTG_TRAV_DONE = 3,
};

enum {
	NAMESZ = 12,
};

enum {
	NAPIF_STATE_SCHED = 1,
	NAPIF_STATE_MISSED = 2,
	NAPIF_STATE_DISABLE = 4,
	NAPIF_STATE_NPSVC = 8,
	NAPIF_STATE_LISTED = 16,
	NAPIF_STATE_NO_BUSY_POLL = 32,
	NAPIF_STATE_IN_BUSY_POLL = 64,
	NAPIF_STATE_PREFER_BUSY_POLL = 128,
	NAPIF_STATE_THREADED = 256,
	NAPIF_STATE_SCHED_THREADED = 512,
};

enum {
	NAPI_F_PREFER_BUSY_POLL = 1,
	NAPI_F_END_ON_RESCHED = 2,
};

enum {
	NAPI_STATE_SCHED = 0,
	NAPI_STATE_MISSED = 1,
	NAPI_STATE_DISABLE = 2,
	NAPI_STATE_NPSVC = 3,
	NAPI_STATE_LISTED = 4,
	NAPI_STATE_NO_BUSY_POLL = 5,
	NAPI_STATE_IN_BUSY_POLL = 6,
	NAPI_STATE_PREFER_BUSY_POLL = 7,
	NAPI_STATE_THREADED = 8,
	NAPI_STATE_SCHED_THREADED = 9,
};

enum {
	NDA_UNSPEC = 0,
	NDA_DST = 1,
	NDA_LLADDR = 2,
	NDA_CACHEINFO = 3,
	NDA_PROBES = 4,
	NDA_VLAN = 5,
	NDA_PORT = 6,
	NDA_VNI = 7,
	NDA_IFINDEX = 8,
	NDA_MASTER = 9,
	NDA_LINK_NETNSID = 10,
	NDA_SRC_VNI = 11,
	NDA_PROTOCOL = 12,
	NDA_NH_ID = 13,
	NDA_FDB_EXT_ATTRS = 14,
	NDA_FLAGS_EXT = 15,
	NDA_NDM_STATE_MASK = 16,
	NDA_NDM_FLAGS_MASK = 17,
	__NDA_MAX = 18,
};

enum {
	NDD_UNARMED = 1,
	NDD_LOCKED = 2,
	NDD_SECURITY_OVERWRITE = 3,
	NDD_WORK_PENDING = 4,
	NDD_LABELING = 6,
	NDD_INCOHERENT = 7,
	NDD_REGISTER_SYNC = 8,
	ND_IOCTL_MAX_BUFLEN = 4194304,
	ND_CMD_MAX_ELEM = 5,
	ND_CMD_MAX_ENVELOPE = 256,
	ND_MAX_MAPPINGS = 32,
	ND_REGION_PAGEMAP = 0,
	ND_REGION_PERSIST_CACHE = 1,
	ND_REGION_PERSIST_MEMCTRL = 2,
	ND_REGION_ASYNC = 3,
	ND_REGION_CXL = 4,
	DPA_RESOURCE_ADJUSTED = 1,
};

enum {
	NDTA_UNSPEC = 0,
	NDTA_NAME = 1,
	NDTA_THRESH1 = 2,
	NDTA_THRESH2 = 3,
	NDTA_THRESH3 = 4,
	NDTA_CONFIG = 5,
	NDTA_PARMS = 6,
	NDTA_STATS = 7,
	NDTA_GC_INTERVAL = 8,
	NDTA_PAD = 9,
	__NDTA_MAX = 10,
};

enum {
	NDTPA_UNSPEC = 0,
	NDTPA_IFINDEX = 1,
	NDTPA_REFCNT = 2,
	NDTPA_REACHABLE_TIME = 3,
	NDTPA_BASE_REACHABLE_TIME = 4,
	NDTPA_RETRANS_TIME = 5,
	NDTPA_GC_STALETIME = 6,
	NDTPA_DELAY_PROBE_TIME = 7,
	NDTPA_QUEUE_LEN = 8,
	NDTPA_APP_PROBES = 9,
	NDTPA_UCAST_PROBES = 10,
	NDTPA_MCAST_PROBES = 11,
	NDTPA_ANYCAST_DELAY = 12,
	NDTPA_PROXY_DELAY = 13,
	NDTPA_PROXY_QLEN = 14,
	NDTPA_LOCKTIME = 15,
	NDTPA_QUEUE_LENBYTES = 16,
	NDTPA_MCAST_REPROBES = 17,
	NDTPA_PAD = 18,
	NDTPA_INTERVAL_PROBE_TIME_MS = 19,
	__NDTPA_MAX = 20,
};

enum {
	NDUSEROPT_UNSPEC = 0,
	NDUSEROPT_SRCADDR = 1,
	__NDUSEROPT_MAX = 2,
};

enum {
	NEIGH_ARP_TABLE = 0,
	NEIGH_ND_TABLE = 1,
	NEIGH_NR_TABLES = 2,
	NEIGH_LINK_TABLE = 2,
};

enum {
	NEIGH_VAR_MCAST_PROBES = 0,
	NEIGH_VAR_UCAST_PROBES = 1,
	NEIGH_VAR_APP_PROBES = 2,
	NEIGH_VAR_MCAST_REPROBES = 3,
	NEIGH_VAR_RETRANS_TIME = 4,
	NEIGH_VAR_BASE_REACHABLE_TIME = 5,
	NEIGH_VAR_DELAY_PROBE_TIME = 6,
	NEIGH_VAR_INTERVAL_PROBE_TIME_MS = 7,
	NEIGH_VAR_GC_STALETIME = 8,
	NEIGH_VAR_QUEUE_LEN_BYTES = 9,
	NEIGH_VAR_PROXY_QLEN = 10,
	NEIGH_VAR_ANYCAST_DELAY = 11,
	NEIGH_VAR_PROXY_DELAY = 12,
	NEIGH_VAR_LOCKTIME = 13,
	NEIGH_VAR_QUEUE_LEN = 14,
	NEIGH_VAR_RETRANS_TIME_MS = 15,
	NEIGH_VAR_BASE_REACHABLE_TIME_MS = 16,
	NEIGH_VAR_GC_INTERVAL = 17,
	NEIGH_VAR_GC_THRESH1 = 18,
	NEIGH_VAR_GC_THRESH2 = 19,
	NEIGH_VAR_GC_THRESH3 = 20,
	NEIGH_VAR_MAX = 21,
};

enum {
	NESTED_SYNC_IMM_BIT = 0,
	NESTED_SYNC_TODO_BIT = 1,
};

enum {
	NETCONFA_UNSPEC = 0,
	NETCONFA_IFINDEX = 1,
	NETCONFA_FORWARDING = 2,
	NETCONFA_RP_FILTER = 3,
	NETCONFA_MC_FORWARDING = 4,
	NETCONFA_PROXY_NEIGH = 5,
	NETCONFA_IGNORE_ROUTES_WITH_LINKDOWN = 6,
	NETCONFA_INPUT = 7,
	NETCONFA_BC_FORWARDING = 8,
	__NETCONFA_MAX = 9,
};

enum {
	NETDEV_A_DEV_IFINDEX = 1,
	NETDEV_A_DEV_PAD = 2,
	NETDEV_A_DEV_XDP_FEATURES = 3,
	NETDEV_A_DEV_XDP_ZC_MAX_SEGS = 4,
	NETDEV_A_DEV_XDP_RX_METADATA_FEATURES = 5,
	NETDEV_A_DEV_XSK_FEATURES = 6,
	__NETDEV_A_DEV_MAX = 7,
	NETDEV_A_DEV_MAX = 6,
};

enum {
	NETDEV_A_DMABUF_IFINDEX = 1,
	NETDEV_A_DMABUF_QUEUES = 2,
	NETDEV_A_DMABUF_FD = 3,
	NETDEV_A_DMABUF_ID = 4,
	__NETDEV_A_DMABUF_MAX = 5,
	NETDEV_A_DMABUF_MAX = 4,
};

enum {
	NETDEV_A_NAPI_IFINDEX = 1,
	NETDEV_A_NAPI_ID = 2,
	NETDEV_A_NAPI_IRQ = 3,
	NETDEV_A_NAPI_PID = 4,
	NETDEV_A_NAPI_DEFER_HARD_IRQS = 5,
	NETDEV_A_NAPI_GRO_FLUSH_TIMEOUT = 6,
	NETDEV_A_NAPI_IRQ_SUSPEND_TIMEOUT = 7,
	__NETDEV_A_NAPI_MAX = 8,
	NETDEV_A_NAPI_MAX = 7,
};

enum {
	NETDEV_A_PAGE_POOL_ID = 1,
	NETDEV_A_PAGE_POOL_IFINDEX = 2,
	NETDEV_A_PAGE_POOL_NAPI_ID = 3,
	NETDEV_A_PAGE_POOL_INFLIGHT = 4,
	NETDEV_A_PAGE_POOL_INFLIGHT_MEM = 5,
	NETDEV_A_PAGE_POOL_DETACH_TIME = 6,
	NETDEV_A_PAGE_POOL_DMABUF = 7,
	__NETDEV_A_PAGE_POOL_MAX = 8,
	NETDEV_A_PAGE_POOL_MAX = 7,
};

enum {
	NETDEV_A_PAGE_POOL_STATS_INFO = 1,
	NETDEV_A_PAGE_POOL_STATS_ALLOC_FAST = 8,
	NETDEV_A_PAGE_POOL_STATS_ALLOC_SLOW = 9,
	NETDEV_A_PAGE_POOL_STATS_ALLOC_SLOW_HIGH_ORDER = 10,
	NETDEV_A_PAGE_POOL_STATS_ALLOC_EMPTY = 11,
	NETDEV_A_PAGE_POOL_STATS_ALLOC_REFILL = 12,
	NETDEV_A_PAGE_POOL_STATS_ALLOC_WAIVE = 13,
	NETDEV_A_PAGE_POOL_STATS_RECYCLE_CACHED = 14,
	NETDEV_A_PAGE_POOL_STATS_RECYCLE_CACHE_FULL = 15,
	NETDEV_A_PAGE_POOL_STATS_RECYCLE_RING = 16,
	NETDEV_A_PAGE_POOL_STATS_RECYCLE_RING_FULL = 17,
	NETDEV_A_PAGE_POOL_STATS_RECYCLE_RELEASED_REFCNT = 18,
	__NETDEV_A_PAGE_POOL_STATS_MAX = 19,
	NETDEV_A_PAGE_POOL_STATS_MAX = 18,
};

enum {
	NETDEV_A_QSTATS_IFINDEX = 1,
	NETDEV_A_QSTATS_QUEUE_TYPE = 2,
	NETDEV_A_QSTATS_QUEUE_ID = 3,
	NETDEV_A_QSTATS_SCOPE = 4,
	NETDEV_A_QSTATS_RX_PACKETS = 8,
	NETDEV_A_QSTATS_RX_BYTES = 9,
	NETDEV_A_QSTATS_TX_PACKETS = 10,
	NETDEV_A_QSTATS_TX_BYTES = 11,
	NETDEV_A_QSTATS_RX_ALLOC_FAIL = 12,
	NETDEV_A_QSTATS_RX_HW_DROPS = 13,
	NETDEV_A_QSTATS_RX_HW_DROP_OVERRUNS = 14,
	NETDEV_A_QSTATS_RX_CSUM_COMPLETE = 15,
	NETDEV_A_QSTATS_RX_CSUM_UNNECESSARY = 16,
	NETDEV_A_QSTATS_RX_CSUM_NONE = 17,
	NETDEV_A_QSTATS_RX_CSUM_BAD = 18,
	NETDEV_A_QSTATS_RX_HW_GRO_PACKETS = 19,
	NETDEV_A_QSTATS_RX_HW_GRO_BYTES = 20,
	NETDEV_A_QSTATS_RX_HW_GRO_WIRE_PACKETS = 21,
	NETDEV_A_QSTATS_RX_HW_GRO_WIRE_BYTES = 22,
	NETDEV_A_QSTATS_RX_HW_DROP_RATELIMITS = 23,
	NETDEV_A_QSTATS_TX_HW_DROPS = 24,
	NETDEV_A_QSTATS_TX_HW_DROP_ERRORS = 25,
	NETDEV_A_QSTATS_TX_CSUM_NONE = 26,
	NETDEV_A_QSTATS_TX_NEEDS_CSUM = 27,
	NETDEV_A_QSTATS_TX_HW_GSO_PACKETS = 28,
	NETDEV_A_QSTATS_TX_HW_GSO_BYTES = 29,
	NETDEV_A_QSTATS_TX_HW_GSO_WIRE_PACKETS = 30,
	NETDEV_A_QSTATS_TX_HW_GSO_WIRE_BYTES = 31,
	NETDEV_A_QSTATS_TX_HW_DROP_RATELIMITS = 32,
	NETDEV_A_QSTATS_TX_STOP = 33,
	NETDEV_A_QSTATS_TX_WAKE = 34,
	__NETDEV_A_QSTATS_MAX = 35,
	NETDEV_A_QSTATS_MAX = 34,
};

enum {
	NETDEV_A_QUEUE_ID = 1,
	NETDEV_A_QUEUE_IFINDEX = 2,
	NETDEV_A_QUEUE_TYPE = 3,
	NETDEV_A_QUEUE_NAPI_ID = 4,
	NETDEV_A_QUEUE_DMABUF = 5,
	__NETDEV_A_QUEUE_MAX = 6,
	NETDEV_A_QUEUE_MAX = 5,
};

enum {
	NETDEV_CMD_DEV_GET = 1,
	NETDEV_CMD_DEV_ADD_NTF = 2,
	NETDEV_CMD_DEV_DEL_NTF = 3,
	NETDEV_CMD_DEV_CHANGE_NTF = 4,
	NETDEV_CMD_PAGE_POOL_GET = 5,
	NETDEV_CMD_PAGE_POOL_ADD_NTF = 6,
	NETDEV_CMD_PAGE_POOL_DEL_NTF = 7,
	NETDEV_CMD_PAGE_POOL_CHANGE_NTF = 8,
	NETDEV_CMD_PAGE_POOL_STATS_GET = 9,
	NETDEV_CMD_QUEUE_GET = 10,
	NETDEV_CMD_NAPI_GET = 11,
	NETDEV_CMD_QSTATS_GET = 12,
	NETDEV_CMD_BIND_RX = 13,
	NETDEV_CMD_NAPI_SET = 14,
	__NETDEV_CMD_MAX = 15,
	NETDEV_CMD_MAX = 14,
};

enum {
	NETDEV_NLGRP_MGMT = 0,
	NETDEV_NLGRP_PAGE_POOL = 1,
};

enum {
	NETDEV_STATS = 0,
	E1000_STATS = 1,
};

enum {
	NETIF_F_SG_BIT = 0,
	NETIF_F_IP_CSUM_BIT = 1,
	__UNUSED_NETIF_F_1 = 2,
	NETIF_F_HW_CSUM_BIT = 3,
	NETIF_F_IPV6_CSUM_BIT = 4,
	NETIF_F_HIGHDMA_BIT = 5,
	NETIF_F_FRAGLIST_BIT = 6,
	NETIF_F_HW_VLAN_CTAG_TX_BIT = 7,
	NETIF_F_HW_VLAN_CTAG_RX_BIT = 8,
	NETIF_F_HW_VLAN_CTAG_FILTER_BIT = 9,
	NETIF_F_VLAN_CHALLENGED_BIT = 10,
	NETIF_F_GSO_BIT = 11,
	__UNUSED_NETIF_F_12 = 12,
	__UNUSED_NETIF_F_13 = 13,
	NETIF_F_GRO_BIT = 14,
	NETIF_F_LRO_BIT = 15,
	NETIF_F_GSO_SHIFT = 16,
	NETIF_F_TSO_BIT = 16,
	NETIF_F_GSO_ROBUST_BIT = 17,
	NETIF_F_TSO_ECN_BIT = 18,
	NETIF_F_TSO_MANGLEID_BIT = 19,
	NETIF_F_TSO6_BIT = 20,
	NETIF_F_FSO_BIT = 21,
	NETIF_F_GSO_GRE_BIT = 22,
	NETIF_F_GSO_GRE_CSUM_BIT = 23,
	NETIF_F_GSO_IPXIP4_BIT = 24,
	NETIF_F_GSO_IPXIP6_BIT = 25,
	NETIF_F_GSO_UDP_TUNNEL_BIT = 26,
	NETIF_F_GSO_UDP_TUNNEL_CSUM_BIT = 27,
	NETIF_F_GSO_PARTIAL_BIT = 28,
	NETIF_F_GSO_TUNNEL_REMCSUM_BIT = 29,
	NETIF_F_GSO_SCTP_BIT = 30,
	NETIF_F_GSO_ESP_BIT = 31,
	NETIF_F_GSO_UDP_BIT = 32,
	NETIF_F_GSO_UDP_L4_BIT = 33,
	NETIF_F_GSO_FRAGLIST_BIT = 34,
	NETIF_F_GSO_LAST = 34,
	NETIF_F_FCOE_CRC_BIT = 35,
	NETIF_F_SCTP_CRC_BIT = 36,
	__UNUSED_NETIF_F_37 = 37,
	NETIF_F_NTUPLE_BIT = 38,
	NETIF_F_RXHASH_BIT = 39,
	NETIF_F_RXCSUM_BIT = 40,
	NETIF_F_NOCACHE_COPY_BIT = 41,
	NETIF_F_LOOPBACK_BIT = 42,
	NETIF_F_RXFCS_BIT = 43,
	NETIF_F_RXALL_BIT = 44,
	NETIF_F_HW_VLAN_STAG_TX_BIT = 45,
	NETIF_F_HW_VLAN_STAG_RX_BIT = 46,
	NETIF_F_HW_VLAN_STAG_FILTER_BIT = 47,
	NETIF_F_HW_L2FW_DOFFLOAD_BIT = 48,
	NETIF_F_HW_TC_BIT = 49,
	NETIF_F_HW_ESP_BIT = 50,
	NETIF_F_HW_ESP_TX_CSUM_BIT = 51,
	NETIF_F_RX_UDP_TUNNEL_PORT_BIT = 52,
	NETIF_F_HW_TLS_TX_BIT = 53,
	NETIF_F_HW_TLS_RX_BIT = 54,
	NETIF_F_GRO_HW_BIT = 55,
	NETIF_F_HW_TLS_RECORD_BIT = 56,
	NETIF_F_GRO_FRAGLIST_BIT = 57,
	NETIF_F_HW_MACSEC_BIT = 58,
	NETIF_F_GRO_UDP_FWD_BIT = 59,
	NETIF_F_HW_HSR_TAG_INS_BIT = 60,
	NETIF_F_HW_HSR_TAG_RM_BIT = 61,
	NETIF_F_HW_HSR_FWD_BIT = 62,
	NETIF_F_HW_HSR_DUP_BIT = 63,
	NETDEV_FEATURE_COUNT = 64,
};

enum {
	NETIF_MSG_DRV_BIT = 0,
	NETIF_MSG_PROBE_BIT = 1,
	NETIF_MSG_LINK_BIT = 2,
	NETIF_MSG_TIMER_BIT = 3,
	NETIF_MSG_IFDOWN_BIT = 4,
	NETIF_MSG_IFUP_BIT = 5,
	NETIF_MSG_RX_ERR_BIT = 6,
	NETIF_MSG_TX_ERR_BIT = 7,
	NETIF_MSG_TX_QUEUED_BIT = 8,
	NETIF_MSG_INTR_BIT = 9,
	NETIF_MSG_TX_DONE_BIT = 10,
	NETIF_MSG_RX_STATUS_BIT = 11,
	NETIF_MSG_PKTDATA_BIT = 12,
	NETIF_MSG_HW_BIT = 13,
	NETIF_MSG_WOL_BIT = 14,
	NETIF_MSG_CLASS_COUNT = 15,
};

enum {
	NETLINK_F_KERNEL_SOCKET = 0,
	NETLINK_F_RECV_PKTINFO = 1,
	NETLINK_F_BROADCAST_SEND_ERROR = 2,
	NETLINK_F_RECV_NO_ENOBUFS = 3,
	NETLINK_F_LISTEN_ALL_NSID = 4,
	NETLINK_F_CAP_ACK = 5,
	NETLINK_F_EXT_ACK = 6,
	NETLINK_F_STRICT_CHK = 7,
};

enum {
	NETLINK_UNCONNECTED = 0,
	NETLINK_CONNECTED = 1,
};

enum {
	NETNSA_NONE = 0,
	NETNSA_NSID = 1,
	NETNSA_PID = 2,
	NETNSA_FD = 3,
	NETNSA_TARGET_NSID = 4,
	NETNSA_CURRENT_NSID = 5,
	__NETNSA_MAX = 6,
};

enum {
	NET_NS_INDEX = 0,
	UTS_NS_INDEX = 1,
	IPC_NS_INDEX = 2,
	PID_NS_INDEX = 3,
	USER_NS_INDEX = 4,
	MNT_NS_INDEX = 5,
	CGROUP_NS_INDEX = 6,
	NR_NAMESPACES = 7,
};

enum {
	NEXTHOP_GRP_TYPE_MPATH = 0,
	NEXTHOP_GRP_TYPE_RES = 1,
	__NEXTHOP_GRP_TYPE_MAX = 2,
};

enum {
	NFNL_BATCH_FAILURE = 1,
	NFNL_BATCH_DONE = 2,
	NFNL_BATCH_REPLAY = 4,
};

enum {
	NFPROTO_UNSPEC = 0,
	NFPROTO_INET = 1,
	NFPROTO_IPV4 = 2,
	NFPROTO_ARP = 3,
	NFPROTO_NETDEV = 5,
	NFPROTO_BRIDGE = 7,
	NFPROTO_IPV6 = 10,
	NFPROTO_NUMPROTO = 11,
};

enum {
	NFSPROC4_CLNT_NULL = 0,
	NFSPROC4_CLNT_READ = 1,
	NFSPROC4_CLNT_WRITE = 2,
	NFSPROC4_CLNT_COMMIT = 3,
	NFSPROC4_CLNT_OPEN = 4,
	NFSPROC4_CLNT_OPEN_CONFIRM = 5,
	NFSPROC4_CLNT_OPEN_NOATTR = 6,
	NFSPROC4_CLNT_OPEN_DOWNGRADE = 7,
	NFSPROC4_CLNT_CLOSE = 8,
	NFSPROC4_CLNT_SETATTR = 9,
	NFSPROC4_CLNT_FSINFO = 10,
	NFSPROC4_CLNT_RENEW = 11,
	NFSPROC4_CLNT_SETCLIENTID = 12,
	NFSPROC4_CLNT_SETCLIENTID_CONFIRM = 13,
	NFSPROC4_CLNT_LOCK = 14,
	NFSPROC4_CLNT_LOCKT = 15,
	NFSPROC4_CLNT_LOCKU = 16,
	NFSPROC4_CLNT_ACCESS = 17,
	NFSPROC4_CLNT_GETATTR = 18,
	NFSPROC4_CLNT_LOOKUP = 19,
	NFSPROC4_CLNT_LOOKUP_ROOT = 20,
	NFSPROC4_CLNT_REMOVE = 21,
	NFSPROC4_CLNT_RENAME = 22,
	NFSPROC4_CLNT_LINK = 23,
	NFSPROC4_CLNT_SYMLINK = 24,
	NFSPROC4_CLNT_CREATE = 25,
	NFSPROC4_CLNT_PATHCONF = 26,
	NFSPROC4_CLNT_STATFS = 27,
	NFSPROC4_CLNT_READLINK = 28,
	NFSPROC4_CLNT_READDIR = 29,
	NFSPROC4_CLNT_SERVER_CAPS = 30,
	NFSPROC4_CLNT_DELEGRETURN = 31,
	NFSPROC4_CLNT_GETACL = 32,
	NFSPROC4_CLNT_SETACL = 33,
	NFSPROC4_CLNT_FS_LOCATIONS = 34,
	NFSPROC4_CLNT_RELEASE_LOCKOWNER = 35,
	NFSPROC4_CLNT_SECINFO = 36,
	NFSPROC4_CLNT_FSID_PRESENT = 37,
	NFSPROC4_CLNT_EXCHANGE_ID = 38,
	NFSPROC4_CLNT_CREATE_SESSION = 39,
	NFSPROC4_CLNT_DESTROY_SESSION = 40,
	NFSPROC4_CLNT_SEQUENCE = 41,
	NFSPROC4_CLNT_GET_LEASE_TIME = 42,
	NFSPROC4_CLNT_RECLAIM_COMPLETE = 43,
	NFSPROC4_CLNT_LAYOUTGET = 44,
	NFSPROC4_CLNT_GETDEVICEINFO = 45,
	NFSPROC4_CLNT_LAYOUTCOMMIT = 46,
	NFSPROC4_CLNT_LAYOUTRETURN = 47,
	NFSPROC4_CLNT_SECINFO_NO_NAME = 48,
	NFSPROC4_CLNT_TEST_STATEID = 49,
	NFSPROC4_CLNT_FREE_STATEID = 50,
	NFSPROC4_CLNT_GETDEVICELIST = 51,
	NFSPROC4_CLNT_BIND_CONN_TO_SESSION = 52,
	NFSPROC4_CLNT_DESTROY_CLIENTID = 53,
	NFSPROC4_CLNT_SEEK = 54,
	NFSPROC4_CLNT_ALLOCATE = 55,
	NFSPROC4_CLNT_DEALLOCATE = 56,
	NFSPROC4_CLNT_LAYOUTSTATS = 57,
	NFSPROC4_CLNT_CLONE = 58,
	NFSPROC4_CLNT_COPY = 59,
	NFSPROC4_CLNT_OFFLOAD_CANCEL = 60,
	NFSPROC4_CLNT_LOOKUPP = 61,
	NFSPROC4_CLNT_LAYOUTERROR = 62,
	NFSPROC4_CLNT_COPY_NOTIFY = 63,
	NFSPROC4_CLNT_GETXATTR = 64,
	NFSPROC4_CLNT_SETXATTR = 65,
	NFSPROC4_CLNT_LISTXATTRS = 66,
	NFSPROC4_CLNT_REMOVEXATTR = 67,
	NFSPROC4_CLNT_READ_PLUS = 68,
};

enum {
	NFS_DELEGATION_NEED_RECLAIM = 0,
	NFS_DELEGATION_RETURN = 1,
	NFS_DELEGATION_RETURN_IF_CLOSED = 2,
	NFS_DELEGATION_REFERENCED = 3,
	NFS_DELEGATION_RETURNING = 4,
	NFS_DELEGATION_REVOKED = 5,
	NFS_DELEGATION_TEST_EXPIRED = 6,
	NFS_DELEGATION_INODE_FREEING = 7,
	NFS_DELEGATION_RETURN_DELAYED = 8,
	NFS_DELEGATION_DELEGTIME = 9,
};

enum {
	NFS_IOHDR_ERROR = 0,
	NFS_IOHDR_EOF = 1,
	NFS_IOHDR_REDO = 2,
	NFS_IOHDR_STAT = 3,
	NFS_IOHDR_RESEND_PNFS = 4,
	NFS_IOHDR_RESEND_MDS = 5,
	NFS_IOHDR_UNSTABLE_WRITES = 6,
	NFS_IOHDR_ODIRECT = 7,
};

enum {
	NFS_OWNER_RECLAIM_REBOOT = 0,
	NFS_OWNER_RECLAIM_NOGRACE = 1,
};

enum {
	NF_BPF_CT_OPTS_SZ = 16,
};

enum {
	NHA_GROUP_STATS_ENTRY_UNSPEC = 0,
	NHA_GROUP_STATS_ENTRY_ID = 1,
	NHA_GROUP_STATS_ENTRY_PACKETS = 2,
	NHA_GROUP_STATS_ENTRY_PACKETS_HW = 3,
	__NHA_GROUP_STATS_ENTRY_MAX = 4,
};

enum {
	NHA_GROUP_STATS_UNSPEC = 0,
	NHA_GROUP_STATS_ENTRY = 1,
	__NHA_GROUP_STATS_MAX = 2,
};

enum {
	NHA_RES_BUCKET_UNSPEC = 0,
	NHA_RES_BUCKET_PAD = 0,
	NHA_RES_BUCKET_INDEX = 1,
	NHA_RES_BUCKET_IDLE_TIME = 2,
	NHA_RES_BUCKET_NH_ID = 3,
	__NHA_RES_BUCKET_MAX = 4,
};

enum {
	NHA_RES_GROUP_UNSPEC = 0,
	NHA_RES_GROUP_PAD = 0,
	NHA_RES_GROUP_BUCKETS = 1,
	NHA_RES_GROUP_IDLE_TIMER = 2,
	NHA_RES_GROUP_UNBALANCED_TIMER = 3,
	NHA_RES_GROUP_UNBALANCED_TIME = 4,
	__NHA_RES_GROUP_MAX = 5,
};

enum {
	NHA_UNSPEC = 0,
	NHA_ID = 1,
	NHA_GROUP = 2,
	NHA_GROUP_TYPE = 3,
	NHA_BLACKHOLE = 4,
	NHA_OIF = 5,
	NHA_GATEWAY = 6,
	NHA_ENCAP_TYPE = 7,
	NHA_ENCAP = 8,
	NHA_GROUPS = 9,
	NHA_MASTER = 10,
	NHA_FDB = 11,
	NHA_RES_GROUP = 12,
	NHA_RES_BUCKET = 13,
	NHA_OP_FLAGS = 14,
	NHA_GROUP_STATS = 15,
	NHA_HW_STATS_ENABLE = 16,
	NHA_HW_STATS_USED = 17,
	__NHA_MAX = 18,
};

enum {
	NHLT_CONFIG_TYPE_GENERIC = 0,
	NHLT_CONFIG_TYPE_MIC_ARRAY = 1,
};

enum {
	NHLT_MIC_ARRAY_2CH_SMALL = 10,
	NHLT_MIC_ARRAY_2CH_BIG = 11,
	NHLT_MIC_ARRAY_4CH_1ST_GEOM = 12,
	NHLT_MIC_ARRAY_4CH_L_SHAPED = 13,
	NHLT_MIC_ARRAY_4CH_2ND_GEOM = 14,
	NHLT_MIC_ARRAY_VENDOR_DEFINED = 15,
};

enum {
	NLA_UNSPEC = 0,
	NLA_U8 = 1,
	NLA_U16 = 2,
	NLA_U32 = 3,
	NLA_U64 = 4,
	NLA_STRING = 5,
	NLA_FLAG = 6,
	NLA_MSECS = 7,
	NLA_NESTED = 8,
	NLA_NESTED_ARRAY = 9,
	NLA_NUL_STRING = 10,
	NLA_BINARY = 11,
	NLA_S8 = 12,
	NLA_S16 = 13,
	NLA_S32 = 14,
	NLA_S64 = 15,
	NLA_BITFIELD32 = 16,
	NLA_REJECT = 17,
	NLA_BE16 = 18,
	NLA_BE32 = 19,
	NLA_SINT = 20,
	NLA_UINT = 21,
	__NLA_TYPE_MAX = 22,
};

enum {
	NLBL_CALIPSO_A_UNSPEC = 0,
	NLBL_CALIPSO_A_DOI = 1,
	NLBL_CALIPSO_A_MTYPE = 2,
	__NLBL_CALIPSO_A_MAX = 3,
};

enum {
	NLBL_CALIPSO_C_UNSPEC = 0,
	NLBL_CALIPSO_C_ADD = 1,
	NLBL_CALIPSO_C_REMOVE = 2,
	NLBL_CALIPSO_C_LIST = 3,
	NLBL_CALIPSO_C_LISTALL = 4,
	__NLBL_CALIPSO_C_MAX = 5,
};

enum {
	NLBL_CIPSOV4_A_UNSPEC = 0,
	NLBL_CIPSOV4_A_DOI = 1,
	NLBL_CIPSOV4_A_MTYPE = 2,
	NLBL_CIPSOV4_A_TAG = 3,
	NLBL_CIPSOV4_A_TAGLST = 4,
	NLBL_CIPSOV4_A_MLSLVLLOC = 5,
	NLBL_CIPSOV4_A_MLSLVLREM = 6,
	NLBL_CIPSOV4_A_MLSLVL = 7,
	NLBL_CIPSOV4_A_MLSLVLLST = 8,
	NLBL_CIPSOV4_A_MLSCATLOC = 9,
	NLBL_CIPSOV4_A_MLSCATREM = 10,
	NLBL_CIPSOV4_A_MLSCAT = 11,
	NLBL_CIPSOV4_A_MLSCATLST = 12,
	__NLBL_CIPSOV4_A_MAX = 13,
};

enum {
	NLBL_CIPSOV4_C_UNSPEC = 0,
	NLBL_CIPSOV4_C_ADD = 1,
	NLBL_CIPSOV4_C_REMOVE = 2,
	NLBL_CIPSOV4_C_LIST = 3,
	NLBL_CIPSOV4_C_LISTALL = 4,
	__NLBL_CIPSOV4_C_MAX = 5,
};

enum {
	NLBL_MGMT_A_UNSPEC = 0,
	NLBL_MGMT_A_DOMAIN = 1,
	NLBL_MGMT_A_PROTOCOL = 2,
	NLBL_MGMT_A_VERSION = 3,
	NLBL_MGMT_A_CV4DOI = 4,
	NLBL_MGMT_A_IPV6ADDR = 5,
	NLBL_MGMT_A_IPV6MASK = 6,
	NLBL_MGMT_A_IPV4ADDR = 7,
	NLBL_MGMT_A_IPV4MASK = 8,
	NLBL_MGMT_A_ADDRSELECTOR = 9,
	NLBL_MGMT_A_SELECTORLIST = 10,
	NLBL_MGMT_A_FAMILY = 11,
	NLBL_MGMT_A_CLPDOI = 12,
	__NLBL_MGMT_A_MAX = 13,
};

enum {
	NLBL_MGMT_C_UNSPEC = 0,
	NLBL_MGMT_C_ADD = 1,
	NLBL_MGMT_C_REMOVE = 2,
	NLBL_MGMT_C_LISTALL = 3,
	NLBL_MGMT_C_ADDDEF = 4,
	NLBL_MGMT_C_REMOVEDEF = 5,
	NLBL_MGMT_C_LISTDEF = 6,
	NLBL_MGMT_C_PROTOCOLS = 7,
	NLBL_MGMT_C_VERSION = 8,
	__NLBL_MGMT_C_MAX = 9,
};

enum {
	NLBL_UNLABEL_A_UNSPEC = 0,
	NLBL_UNLABEL_A_ACPTFLG = 1,
	NLBL_UNLABEL_A_IPV6ADDR = 2,
	NLBL_UNLABEL_A_IPV6MASK = 3,
	NLBL_UNLABEL_A_IPV4ADDR = 4,
	NLBL_UNLABEL_A_IPV4MASK = 5,
	NLBL_UNLABEL_A_IFACE = 6,
	NLBL_UNLABEL_A_SECCTX = 7,
	__NLBL_UNLABEL_A_MAX = 8,
};

enum {
	NLBL_UNLABEL_C_UNSPEC = 0,
	NLBL_UNLABEL_C_ACCEPT = 1,
	NLBL_UNLABEL_C_LIST = 2,
	NLBL_UNLABEL_C_STATICADD = 3,
	NLBL_UNLABEL_C_STATICREMOVE = 4,
	NLBL_UNLABEL_C_STATICLIST = 5,
	NLBL_UNLABEL_C_STATICADDDEF = 6,
	NLBL_UNLABEL_C_STATICREMOVEDEF = 7,
	NLBL_UNLABEL_C_STATICLISTDEF = 8,
	__NLBL_UNLABEL_C_MAX = 9,
};

enum {
	NLM_LCK_GRANTED = 0,
	NLM_LCK_DENIED = 1,
	NLM_LCK_DENIED_NOLOCKS = 2,
	NLM_LCK_BLOCKED = 3,
	NLM_LCK_DENIED_GRACE_PERIOD = 4,
	NLM_DEADLCK = 5,
	NLM_ROFS = 6,
	NLM_STALE_FH = 7,
	NLM_FBIG = 8,
	NLM_FAILED = 9,
};

enum {
	NMI_LOCAL = 0,
	NMI_UNKNOWN = 1,
	NMI_SERR = 2,
	NMI_IO_CHECK = 3,
	NMI_MAX = 4,
};

enum {
	NONE_FORCE_HPET_RESUME = 0,
	OLD_ICH_FORCE_HPET_RESUME = 1,
	ICH_FORCE_HPET_RESUME = 2,
	VT8237_FORCE_HPET_RESUME = 3,
	NVIDIA_FORCE_HPET_RESUME = 4,
	ATI_FORCE_HPET_RESUME = 5,
};

enum {
	NSMPROC_NULL = 0,
	NSMPROC_STAT = 1,
	NSMPROC_MON = 2,
	NSMPROC_UNMON = 3,
	NSMPROC_UNMON_ALL = 4,
	NSMPROC_SIMU_CRASH = 5,
	NSMPROC_NOTIFY = 6,
};

enum {
	NUM_TRIAL_SAMPLES = 8192,
	MAX_SAMPLES_PER_BIT = 66,
};

enum {
	NVMEM_ADD = 1,
	NVMEM_REMOVE = 2,
	NVMEM_CELL_ADD = 3,
	NVMEM_CELL_REMOVE = 4,
	NVMEM_LAYOUT_ADD = 5,
	NVMEM_LAYOUT_REMOVE = 6,
};

enum {
	NVME_AEN_BIT_NS_ATTR = 8,
	NVME_AEN_BIT_FW_ACT = 9,
	NVME_AEN_BIT_ANA_CHANGE = 11,
	NVME_AEN_BIT_DISC_CHANGE = 31,
};

enum {
	NVME_CC_ENABLE = 1,
	NVME_CC_EN_SHIFT = 0,
	NVME_CC_CSS_SHIFT = 4,
	NVME_CC_CSS_MASK = 112,
	NVME_CC_CSS_NVM = 0,
	NVME_CC_CSS_CSI = 96,
	NVME_CC_MPS_SHIFT = 7,
	NVME_CC_MPS_MASK = 1920,
	NVME_CC_AMS_SHIFT = 11,
	NVME_CC_AMS_MASK = 14336,
	NVME_CC_AMS_RR = 0,
	NVME_CC_AMS_WRRU = 2048,
	NVME_CC_AMS_VS = 14336,
	NVME_CC_SHN_SHIFT = 14,
	NVME_CC_SHN_MASK = 49152,
	NVME_CC_SHN_NONE = 0,
	NVME_CC_SHN_NORMAL = 16384,
	NVME_CC_SHN_ABRUPT = 32768,
	NVME_CC_IOSQES_SHIFT = 16,
	NVME_CC_IOSQES_MASK = 983040,
	NVME_CC_IOSQES = 393216,
	NVME_CC_IOCQES_SHIFT = 20,
	NVME_CC_IOCQES_MASK = 15728640,
	NVME_CC_IOCQES = 4194304,
	NVME_CC_CRIME = 16777216,
};

enum {
	NVME_CSTS_RDY = 1,
	NVME_CSTS_CFS = 2,
	NVME_CSTS_NSSRO = 16,
	NVME_CSTS_PP = 32,
	NVME_CSTS_SHST_NORMAL = 0,
	NVME_CSTS_SHST_OCCUR = 4,
	NVME_CSTS_SHST_CMPLT = 8,
	NVME_CSTS_SHST_MASK = 12,
};

enum {
	NVME_REG_CAP = 0,
	NVME_REG_VS = 8,
	NVME_REG_INTMS = 12,
	NVME_REG_INTMC = 16,
	NVME_REG_CC = 20,
	NVME_REG_CSTS = 28,
	NVME_REG_NSSR = 32,
	NVME_REG_AQA = 36,
	NVME_REG_ASQ = 40,
	NVME_REG_ACQ = 48,
	NVME_REG_CMBLOC = 56,
	NVME_REG_CMBSZ = 60,
	NVME_REG_BPINFO = 64,
	NVME_REG_BPRSEL = 68,
	NVME_REG_BPMBL = 72,
	NVME_REG_CMBMSC = 80,
	NVME_REG_CRTO = 104,
	NVME_REG_PMRCAP = 3584,
	NVME_REG_PMRCTL = 3588,
	NVME_REG_PMRSTS = 3592,
	NVME_REG_PMREBS = 3596,
	NVME_REG_PMRSWTP = 3600,
	NVME_REG_DBS = 4096,
};

enum {
	NV_CROSSOVER_DETECTION_DISABLED = 0,
	NV_CROSSOVER_DETECTION_ENABLED = 1,
};

enum {
	NV_DMA_64BIT_DISABLED = 0,
	NV_DMA_64BIT_ENABLED = 1,
};

enum {
	NV_MSIX_INT_DISABLED = 0,
	NV_MSIX_INT_ENABLED = 1,
};

enum {
	NV_MSI_INT_DISABLED = 0,
	NV_MSI_INT_ENABLED = 1,
};

enum {
	NV_OPTIMIZATION_MODE_THROUGHPUT = 0,
	NV_OPTIMIZATION_MODE_CPU = 1,
	NV_OPTIMIZATION_MODE_DYNAMIC = 2,
};

enum {
	NvRegIrqStatus = 0,
	NvRegIrqMask = 4,
	NvRegUnknownSetupReg6 = 8,
	NvRegPollingInterval = 12,
	NvRegMSIMap0 = 32,
	NvRegMSIMap1 = 36,
	NvRegMSIIrqMask = 48,
	NvRegMisc1 = 128,
	NvRegMacReset = 52,
	NvRegTransmitterControl = 132,
	NvRegTransmitterStatus = 136,
	NvRegPacketFilterFlags = 140,
	NvRegOffloadConfig = 144,
	NvRegReceiverControl = 148,
	NvRegReceiverStatus = 152,
	NvRegSlotTime = 156,
	NvRegTxDeferral = 160,
	NvRegRxDeferral = 164,
	NvRegMacAddrA = 168,
	NvRegMacAddrB = 172,
	NvRegMulticastAddrA = 176,
	NvRegMulticastAddrB = 180,
	NvRegMulticastMaskA = 184,
	NvRegMulticastMaskB = 188,
	NvRegPhyInterface = 192,
	NvRegBackOffControl = 196,
	NvRegTxRingPhysAddr = 256,
	NvRegRxRingPhysAddr = 260,
	NvRegRingSizes = 264,
	NvRegTransmitPoll = 268,
	NvRegLinkSpeed = 272,
	NvRegUnknownSetupReg5 = 304,
	NvRegTxWatermark = 316,
	NvRegTxRxControl = 324,
	NvRegTxRingPhysAddrHigh = 328,
	NvRegRxRingPhysAddrHigh = 332,
	NvRegTxPauseFrame = 368,
	NvRegTxPauseFrameLimit = 372,
	NvRegMIIStatus = 384,
	NvRegMIIMask = 388,
	NvRegAdapterControl = 392,
	NvRegMIISpeed = 396,
	NvRegMIIControl = 400,
	NvRegMIIData = 404,
	NvRegTxUnicast = 416,
	NvRegTxMulticast = 420,
	NvRegTxBroadcast = 424,
	NvRegWakeUpFlags = 512,
	NvRegMgmtUnitGetVersion = 516,
	NvRegMgmtUnitVersion = 520,
	NvRegPowerCap = 616,
	NvRegPowerState = 620,
	NvRegMgmtUnitControl = 632,
	NvRegTxCnt = 640,
	NvRegTxZeroReXmt = 644,
	NvRegTxOneReXmt = 648,
	NvRegTxManyReXmt = 652,
	NvRegTxLateCol = 656,
	NvRegTxUnderflow = 660,
	NvRegTxLossCarrier = 664,
	NvRegTxExcessDef = 668,
	NvRegTxRetryErr = 672,
	NvRegRxFrameErr = 676,
	NvRegRxExtraByte = 680,
	NvRegRxLateCol = 684,
	NvRegRxRunt = 688,
	NvRegRxFrameTooLong = 692,
	NvRegRxOverflow = 696,
	NvRegRxFCSErr = 700,
	NvRegRxFrameAlignErr = 704,
	NvRegRxLenErr = 708,
	NvRegRxUnicast = 712,
	NvRegRxMulticast = 716,
	NvRegRxBroadcast = 720,
	NvRegTxDef = 724,
	NvRegTxFrame = 728,
	NvRegRxCnt = 732,
	NvRegTxPause = 736,
	NvRegRxPause = 740,
	NvRegRxDropFrame = 744,
	NvRegVlanControl = 768,
	NvRegMSIXMap0 = 992,
	NvRegMSIXMap1 = 996,
	NvRegMSIXIrqStatus = 1008,
	NvRegPowerState2 = 1536,
};

enum {
	OD_NORMAL_SAMPLE = 0,
	OD_SUB_SAMPLE = 1,
};

enum {
	OPT_UID = 0,
	OPT_GID = 1,
	OPT_MODE = 2,
	OPT_DELEGATE_CMDS = 3,
	OPT_DELEGATE_MAPS = 4,
	OPT_DELEGATE_PROGS = 5,
	OPT_DELEGATE_ATTACHS = 6,
};

enum {
	Opt_block = 0,
	Opt_check = 1,
	Opt_cruft = 2,
	Opt_gid = 3,
	Opt_ignore = 4,
	Opt_iocharset = 5,
	Opt_map = 6,
	Opt_mode = 7,
	Opt_nojoliet = 8,
	Opt_norock = 9,
	Opt_sb = 10,
	Opt_session = 11,
	Opt_uid = 12,
	Opt_unhide = 13,
	Opt_utf8 = 14,
	Opt_err = 15,
	Opt_nocompress = 16,
	Opt_hide = 17,
	Opt_showassoc = 18,
	Opt_dmode = 19,
	Opt_overriderockperm = 20,
};

enum {
	Opt_bsd_df = 0,
	Opt_minix_df = 1,
	Opt_grpid = 2,
	Opt_nogrpid = 3,
	Opt_resgid = 4,
	Opt_resuid = 5,
	Opt_sb___2 = 6,
	Opt_nouid32 = 7,
	Opt_debug = 8,
	Opt_removed = 9,
	Opt_user_xattr = 10,
	Opt_acl = 11,
	Opt_auto_da_alloc = 12,
	Opt_noauto_da_alloc = 13,
	Opt_noload = 14,
	Opt_commit = 15,
	Opt_min_batch_time = 16,
	Opt_max_batch_time = 17,
	Opt_journal_dev = 18,
	Opt_journal_path = 19,
	Opt_journal_checksum = 20,
	Opt_journal_async_commit = 21,
	Opt_abort = 22,
	Opt_data_journal = 23,
	Opt_data_ordered = 24,
	Opt_data_writeback = 25,
	Opt_data_err_abort = 26,
	Opt_data_err_ignore = 27,
	Opt_test_dummy_encryption = 28,
	Opt_inlinecrypt = 29,
	Opt_usrjquota = 30,
	Opt_grpjquota = 31,
	Opt_quota = 32,
	Opt_noquota = 33,
	Opt_barrier = 34,
	Opt_nobarrier = 35,
	Opt_err___2 = 36,
	Opt_usrquota = 37,
	Opt_grpquota = 38,
	Opt_prjquota = 39,
	Opt_dax = 40,
	Opt_dax_always = 41,
	Opt_dax_inode = 42,
	Opt_dax_never = 43,
	Opt_stripe = 44,
	Opt_delalloc = 45,
	Opt_nodelalloc = 46,
	Opt_warn_on_error = 47,
	Opt_nowarn_on_error = 48,
	Opt_mblk_io_submit = 49,
	Opt_debug_want_extra_isize = 50,
	Opt_nomblk_io_submit = 51,
	Opt_block_validity = 52,
	Opt_noblock_validity = 53,
	Opt_inode_readahead_blks = 54,
	Opt_journal_ioprio = 55,
	Opt_dioread_nolock = 56,
	Opt_dioread_lock = 57,
	Opt_discard = 58,
	Opt_nodiscard = 59,
	Opt_init_itable = 60,
	Opt_noinit_itable = 61,
	Opt_max_dir_size_kb = 62,
	Opt_nojournal_checksum = 63,
	Opt_nombcache = 64,
	Opt_no_prefetch_block_bitmaps = 65,
	Opt_mb_optimize_scan = 66,
	Opt_errors = 67,
	Opt_data = 68,
	Opt_data_err = 69,
	Opt_jqfmt = 70,
	Opt_dax_type = 71,
};

enum {
	Opt_check___2 = 0,
	Opt_uid___2 = 1,
	Opt_gid___2 = 2,
	Opt_umask = 3,
	Opt_dmask = 4,
	Opt_fmask = 5,
	Opt_allow_utime = 6,
	Opt_codepage = 7,
	Opt_usefree = 8,
	Opt_nocase = 9,
	Opt_quiet = 10,
	Opt_showexec = 11,
	Opt_debug___2 = 12,
	Opt_immutable = 13,
	Opt_dots = 14,
	Opt_dotsOK = 15,
	Opt_charset = 16,
	Opt_shortname = 17,
	Opt_utf8___2 = 18,
	Opt_utf8_bool = 19,
	Opt_uni_xl = 20,
	Opt_uni_xl_bool = 21,
	Opt_nonumtail = 22,
	Opt_nonumtail_bool = 23,
	Opt_obsolete = 24,
	Opt_flush = 25,
	Opt_tz = 26,
	Opt_rodir = 27,
	Opt_errors___2 = 28,
	Opt_discard___2 = 29,
	Opt_nfs = 30,
	Opt_nfs_enum = 31,
	Opt_time_offset = 32,
	Opt_dos1xfloppy = 33,
};

enum {
	Opt_debug___3 = 0,
	Opt_dfltuid = 1,
	Opt_dfltgid = 2,
	Opt_afid = 3,
	Opt_uname = 4,
	Opt_remotename = 5,
	Opt_cache = 6,
	Opt_cachetag = 7,
	Opt_nodevmap = 8,
	Opt_noxattr = 9,
	Opt_directio = 10,
	Opt_ignoreqv = 11,
	Opt_access = 12,
	Opt_posixacl = 13,
	Opt_locktimeout = 14,
	Opt_err___3 = 15,
};

enum {
	Opt_direct = 0,
	Opt_fd = 1,
	Opt_gid___3 = 2,
	Opt_ignore___2 = 3,
	Opt_indirect = 4,
	Opt_maxproto = 5,
	Opt_minproto = 6,
	Opt_offset = 7,
	Opt_pgrp = 8,
	Opt_strictexpire = 9,
	Opt_uid___3 = 10,
};

enum {
	Opt_err___4 = 0,
	Opt_enc = 1,
	Opt_hash = 2,
};

enum {
	Opt_error = -1,
	Opt_context = 0,
	Opt_defcontext = 1,
	Opt_fscontext = 2,
	Opt_rootcontext = 3,
	Opt_seclabel = 4,
};

enum {
	Opt_find_uid = 0,
	Opt_find_gid = 1,
	Opt_find_user = 2,
	Opt_find_group = 3,
	Opt_find_err = 4,
};

enum {
	Opt_local_lock_all = 0,
	Opt_local_lock_flock = 1,
	Opt_local_lock_none = 2,
	Opt_local_lock_posix = 3,
};

enum {
	Opt_lookupcache_all = 0,
	Opt_lookupcache_none = 1,
	Opt_lookupcache_positive = 2,
};

enum {
	Opt_msize = 0,
	Opt_trans = 1,
	Opt_legacy = 2,
	Opt_version = 3,
	Opt_err___5 = 4,
};

enum {
	Opt_port = 0,
	Opt_rfdno = 1,
	Opt_wfdno = 2,
	Opt_err___6 = 3,
	Opt_privport = 4,
};

enum {
	Opt_sec_krb5 = 0,
	Opt_sec_krb5i = 1,
	Opt_sec_krb5p = 2,
	Opt_sec_lkey = 3,
	Opt_sec_lkeyi = 4,
	Opt_sec_lkeyp = 5,
	Opt_sec_none = 6,
	Opt_sec_spkm = 7,
	Opt_sec_spkmi = 8,
	Opt_sec_spkmp = 9,
	Opt_sec_sys = 10,
	nr__Opt_sec = 11,
};

enum {
	Opt_uid___4 = 0,
	Opt_gid___4 = 1,
	Opt_mode___2 = 2,
};

enum {
	Opt_uid___5 = 0,
	Opt_gid___5 = 1,
	Opt_mode___3 = 2,
	Opt_source = 3,
};

enum {
	Opt_uid___6 = 0,
	Opt_gid___6 = 1,
	Opt_mode___4 = 2,
	Opt_ptmxmode = 3,
	Opt_newinstance = 4,
	Opt_max = 5,
	Opt_err___7 = 6,
};

enum {
	Opt_vers_2 = 0,
	Opt_vers_3 = 1,
	Opt_vers_4 = 2,
	Opt_vers_4_0 = 3,
	Opt_vers_4_1 = 4,
	Opt_vers_4_2 = 5,
};

enum {
	Opt_write_lazy = 0,
	Opt_write_eager = 1,
	Opt_write_wait = 2,
};

enum {
	Opt_xprt_rdma = 0,
	Opt_xprt_rdma6 = 1,
	Opt_xprt_tcp = 2,
	Opt_xprt_tcp6 = 3,
	Opt_xprt_udp = 4,
	Opt_xprt_udp6 = 5,
	nr__Opt_xprt = 6,
};

enum {
	Opt_xprtsec_none = 0,
	Opt_xprtsec_tls = 1,
	Opt_xprtsec_mtls = 2,
	nr__Opt_xprtsec = 3,
};

enum {
	PAGE_WAS_MAPPED = 1,
	PAGE_WAS_MLOCKED = 2,
	PAGE_OLD_STATES = 3,
};

enum {
	PARSE_INVALID = 1,
	PARSE_NOT_LONGNAME = 2,
	PARSE_EOF = 3,
};

enum {
	PCI_DEV_REG1 = 64,
	PCI_DEV_REG2 = 68,
	PCI_DEV_STATUS = 124,
	PCI_DEV_REG3 = 128,
	PCI_DEV_REG4 = 132,
	PCI_DEV_REG5 = 136,
	PCI_CFG_REG_0 = 144,
	PCI_CFG_REG_1 = 148,
	PSM_CONFIG_REG0 = 152,
	PSM_CONFIG_REG1 = 156,
	PSM_CONFIG_REG2 = 352,
	PSM_CONFIG_REG3 = 356,
	PSM_CONFIG_REG4 = 360,
	PCI_LDO_CTRL = 188,
};

enum {
	PCI_REASSIGN_ALL_RSRC = 1,
	PCI_REASSIGN_ALL_BUS = 2,
	PCI_PROBE_ONLY = 4,
	PCI_CAN_SKIP_ISA_ALIGN = 8,
	PCI_ENABLE_PROC_DOMAINS = 16,
	PCI_COMPAT_DOMAIN_0 = 32,
	PCI_SCAN_ALL_PCIE_DEVS = 64,
};

enum {
	PCI_STD_RESOURCES = 0,
	PCI_STD_RESOURCE_END = 5,
	PCI_ROM_RESOURCE = 6,
	PCI_BRIDGE_RESOURCES = 7,
	PCI_BRIDGE_RESOURCE_END = 10,
	PCI_NUM_RESOURCES = 11,
	DEVICE_COUNT_RESOURCE = 11,
};

enum {
	PCMCIA_IOPORT_0 = 0,
	PCMCIA_IOPORT_1 = 1,
	PCMCIA_IOMEM_0 = 2,
	PCMCIA_IOMEM_1 = 3,
	PCMCIA_IOMEM_2 = 4,
	PCMCIA_IOMEM_3 = 5,
	PCMCIA_NUM_RESOURCES = 6,
};

enum {
	PC_VAUX_ENA = 128,
	PC_VAUX_DIS = 64,
	PC_VCC_ENA = 32,
	PC_VCC_DIS = 16,
	PC_VAUX_ON = 8,
	PC_VAUX_OFF = 4,
	PC_VCC_ON = 2,
	PC_VCC_OFF = 1,
};

enum {
	PERCPU_REF_INIT_ATOMIC = 1,
	PERCPU_REF_INIT_DEAD = 2,
	PERCPU_REF_ALLOW_REINIT = 4,
};

enum {
	PERF_BR_SPEC_NA = 0,
	PERF_BR_SPEC_WRONG_PATH = 1,
	PERF_BR_NON_SPEC_CORRECT_PATH = 2,
	PERF_BR_SPEC_CORRECT_PATH = 3,
	PERF_BR_SPEC_MAX = 4,
};

enum {
	PERF_BR_UNKNOWN = 0,
	PERF_BR_COND = 1,
	PERF_BR_UNCOND = 2,
	PERF_BR_IND = 3,
	PERF_BR_CALL = 4,
	PERF_BR_IND_CALL = 5,
	PERF_BR_RET = 6,
	PERF_BR_SYSCALL = 7,
	PERF_BR_SYSRET = 8,
	PERF_BR_COND_CALL = 9,
	PERF_BR_COND_RET = 10,
	PERF_BR_ERET = 11,
	PERF_BR_IRQ = 12,
	PERF_BR_SERROR = 13,
	PERF_BR_NO_TX = 14,
	PERF_BR_EXTEND_ABI = 15,
	PERF_BR_MAX = 16,
};

enum {
	PERF_GROUP_OAG = 0,
	PERF_GROUP_OAM_SAMEDIA_0 = 0,
	PERF_GROUP_MAX = 1,
	PERF_GROUP_INVALID = 4294967295,
};

enum {
	PERF_TXN_ELISION = 1ULL,
	PERF_TXN_TRANSACTION = 2ULL,
	PERF_TXN_SYNC = 4ULL,
	PERF_TXN_ASYNC = 8ULL,
	PERF_TXN_RETRY = 16ULL,
	PERF_TXN_CONFLICT = 32ULL,
	PERF_TXN_CAPACITY_WRITE = 64ULL,
	PERF_TXN_CAPACITY_READ = 128ULL,
	PERF_TXN_MAX = 256ULL,
	PERF_TXN_ABORT_MASK = 18446744069414584320ULL,
	PERF_TXN_ABORT_SHIFT = 32ULL,
};

enum {
	PERF_X86_EVENT_PEBS_LDLAT = 1,
	PERF_X86_EVENT_PEBS_ST = 2,
	PERF_X86_EVENT_PEBS_ST_HSW = 4,
	PERF_X86_EVENT_PEBS_LD_HSW = 8,
	PERF_X86_EVENT_PEBS_NA_HSW = 16,
	PERF_X86_EVENT_EXCL = 32,
	PERF_X86_EVENT_DYNAMIC = 64,
	PERF_X86_EVENT_EXCL_ACCT = 256,
	PERF_X86_EVENT_AUTO_RELOAD = 512,
	PERF_X86_EVENT_LARGE_PEBS = 1024,
	PERF_X86_EVENT_PEBS_VIA_PT = 2048,
	PERF_X86_EVENT_PAIR = 4096,
	PERF_X86_EVENT_LBR_SELECT = 8192,
	PERF_X86_EVENT_TOPDOWN = 16384,
	PERF_X86_EVENT_PEBS_STLAT = 32768,
	PERF_X86_EVENT_AMD_BRS = 65536,
	PERF_X86_EVENT_PEBS_LAT_HYBRID = 131072,
	PERF_X86_EVENT_NEEDS_BRANCH_STACK = 262144,
	PERF_X86_EVENT_BRANCH_COUNTERS = 524288,
};

enum {
	PER_LINUX = 0,
	PER_LINUX_32BIT = 8388608,
	PER_LINUX_FDPIC = 524288,
	PER_SVR4 = 68157441,
	PER_SVR3 = 83886082,
	PER_SCOSVR3 = 117440515,
	PER_OSR5 = 100663299,
	PER_WYSEV386 = 83886084,
	PER_ISCR4 = 67108869,
	PER_BSD = 6,
	PER_SUNOS = 67108870,
	PER_XENIX = 83886087,
	PER_LINUX32 = 8,
	PER_LINUX32_3GB = 134217736,
	PER_IRIX32 = 67108873,
	PER_IRIXN32 = 67108874,
	PER_IRIX64 = 67108875,
	PER_RISCOS = 12,
	PER_SOLARIS = 67108877,
	PER_UW7 = 68157454,
	PER_OSF4 = 15,
	PER_HPUX = 16,
	PER_MASK = 255,
};

enum {
	PEX_RD_ACCESS = -2147483648,
	PEX_DB_ACCESS = 1073741824,
};

enum {
	PG_BUSY = 0,
	PG_MAPPED = 1,
	PG_FOLIO = 2,
	PG_CLEAN = 3,
	PG_COMMIT_TO_DS = 4,
	PG_INODE_REF = 5,
	PG_HEADLOCK = 6,
	PG_TEARDOWN = 7,
	PG_UNLOCKPAGE = 8,
	PG_UPTODATE = 9,
	PG_WB_END = 10,
	PG_REMOVE = 11,
	PG_CONTENDED1 = 12,
	PG_CONTENDED2 = 13,
};

enum {
	PHY_ADDR_MARV = 0,
};

enum {
	PHY_AN_NXT_PG = 32768,
	PHY_AN_ACK = 16384,
	PHY_AN_RF = 8192,
	PHY_AN_PAUSE_ASYM = 2048,
	PHY_AN_PAUSE_CAP = 1024,
	PHY_AN_100BASE4 = 512,
	PHY_AN_100FULL = 256,
	PHY_AN_100HALF = 128,
	PHY_AN_10FULL = 64,
	PHY_AN_10HALF = 32,
	PHY_AN_CSMA = 1,
	PHY_AN_SEL = 31,
	PHY_AN_FULL = 321,
	PHY_AN_ALL = 480,
};

enum {
	PHY_CT_RESET = 32768,
	PHY_CT_LOOP = 16384,
	PHY_CT_SPS_LSB = 8192,
	PHY_CT_ANE = 4096,
	PHY_CT_PDOWN = 2048,
	PHY_CT_ISOL = 1024,
	PHY_CT_RE_CFG = 512,
	PHY_CT_DUP_MD = 256,
	PHY_CT_COL_TST = 128,
	PHY_CT_SPS_MSB = 64,
};

enum {
	PHY_CT_SP1000 = 64,
	PHY_CT_SP100 = 8192,
	PHY_CT_SP10 = 0,
};

enum {
	PHY_MARV_CTRL = 0,
	PHY_MARV_STAT = 1,
	PHY_MARV_ID0 = 2,
	PHY_MARV_ID1 = 3,
	PHY_MARV_AUNE_ADV = 4,
	PHY_MARV_AUNE_LP = 5,
	PHY_MARV_AUNE_EXP = 6,
	PHY_MARV_NEPG = 7,
	PHY_MARV_NEPG_LP = 8,
	PHY_MARV_1000T_CTRL = 9,
	PHY_MARV_1000T_STAT = 10,
	PHY_MARV_EXT_STAT = 15,
	PHY_MARV_PHY_CTRL = 16,
	PHY_MARV_PHY_STAT = 17,
	PHY_MARV_INT_MASK = 18,
	PHY_MARV_INT_STAT = 19,
	PHY_MARV_EXT_CTRL = 20,
	PHY_MARV_RXE_CNT = 21,
	PHY_MARV_EXT_ADR = 22,
	PHY_MARV_PORT_IRQ = 23,
	PHY_MARV_LED_CTRL = 24,
	PHY_MARV_LED_OVER = 25,
	PHY_MARV_EXT_CTRL_2 = 26,
	PHY_MARV_EXT_P_STAT = 27,
	PHY_MARV_CABLE_DIAG = 28,
	PHY_MARV_PAGE_ADDR = 29,
	PHY_MARV_PAGE_DATA = 30,
	PHY_MARV_FE_LED_PAR = 22,
	PHY_MARV_FE_LED_SER = 23,
	PHY_MARV_FE_VCT_TX = 26,
	PHY_MARV_FE_VCT_RX = 27,
	PHY_MARV_FE_SPEC_2 = 28,
};

enum {
	PHY_MARV_ID0_VAL = 321,
	PHY_BCOM_ID1_A1 = 24641,
	PHY_BCOM_ID1_B2 = 24643,
	PHY_BCOM_ID1_C0 = 24644,
	PHY_BCOM_ID1_C5 = 24647,
	PHY_MARV_ID1_B0 = 3107,
	PHY_MARV_ID1_B2 = 3109,
	PHY_MARV_ID1_C2 = 3266,
	PHY_MARV_ID1_Y2 = 3217,
	PHY_MARV_ID1_FE = 3203,
	PHY_MARV_ID1_ECU = 3248,
};

enum {
	PHY_M_1000C_TEST = 57344,
	PHY_M_1000C_MSE = 4096,
	PHY_M_1000C_MSC = 2048,
	PHY_M_1000C_MPD = 1024,
	PHY_M_1000C_AFD = 512,
	PHY_M_1000C_AHD = 256,
};

enum {
	PHY_M_AN_ASP_X = 256,
	PHY_M_AN_PC_X = 128,
	PHY_M_AN_1000X_AHD = 64,
	PHY_M_AN_1000X_AFD = 32,
};

enum {
	PHY_M_AN_NXT_PG = 32768,
	PHY_M_AN_ACK = 16384,
	PHY_M_AN_RF = 8192,
	PHY_M_AN_ASP = 2048,
	PHY_M_AN_PC = 1024,
	PHY_M_AN_100_T4 = 512,
	PHY_M_AN_100_FD = 256,
	PHY_M_AN_100_HD = 128,
	PHY_M_AN_10_FD = 64,
	PHY_M_AN_10_HD = 32,
	PHY_M_AN_SEL_MSK = 496,
};

enum {
	PHY_M_EC_ENA_BC_EXT = 32768,
	PHY_M_EC_ENA_LIN_LB = 16384,
	PHY_M_EC_DIS_LINK_P = 4096,
	PHY_M_EC_M_DSC_MSK = 3072,
	PHY_M_EC_S_DSC_MSK = 768,
	PHY_M_EC_M_DSC_MSK2 = 3584,
	PHY_M_EC_DOWN_S_ENA = 256,
	PHY_M_EC_RX_TIM_CT = 128,
	PHY_M_EC_MAC_S_MSK = 112,
	PHY_M_EC_FIB_AN_ENA = 8,
	PHY_M_EC_DTE_D_ENA = 4,
	PHY_M_EC_TX_TIM_CT = 2,
	PHY_M_EC_TRANS_DIS = 1,
	PHY_M_10B_TE_ENABLE = 128,
};

enum {
	PHY_M_FC_AUTO_SEL = 32768,
	PHY_M_FC_AN_REG_ACC = 16384,
	PHY_M_FC_RESOLUTION = 8192,
	PHY_M_SER_IF_AN_BP = 4096,
	PHY_M_SER_IF_BP_ST = 2048,
	PHY_M_IRQ_POLARITY = 1024,
	PHY_M_DIS_AUT_MED = 512,
	PHY_M_UNDOC1 = 128,
	PHY_M_DTE_POW_STAT = 16,
	PHY_M_MODE_MASK = 15,
};

enum {
	PHY_M_FELP_LED2_MSK = 3840,
	PHY_M_FELP_LED1_MSK = 240,
	PHY_M_FELP_LED0_MSK = 15,
};

enum {
	PHY_M_FESC_DIS_WAIT = 4,
	PHY_M_FESC_ENA_MCLK = 2,
	PHY_M_FESC_SEL_CL_A = 1,
};

enum {
	PHY_M_FIB_FORCE_LNK = 1024,
	PHY_M_FIB_SIGD_POL = 512,
	PHY_M_FIB_TX_DIS = 8,
};

enum {
	PHY_M_IS_AN_ERROR = 32768,
	PHY_M_IS_LSP_CHANGE = 16384,
	PHY_M_IS_DUP_CHANGE = 8192,
	PHY_M_IS_AN_PR = 4096,
	PHY_M_IS_AN_COMPL = 2048,
	PHY_M_IS_LST_CHANGE = 1024,
	PHY_M_IS_SYMB_ERROR = 512,
	PHY_M_IS_FALSE_CARR = 256,
	PHY_M_IS_FIFO_ERROR = 128,
	PHY_M_IS_MDI_CHANGE = 64,
	PHY_M_IS_DOWNSH_DET = 32,
	PHY_M_IS_END_CHANGE = 16,
	PHY_M_IS_DTE_CHANGE = 4,
	PHY_M_IS_POL_CHANGE = 2,
	PHY_M_IS_JABBER = 1,
	PHY_M_DEF_MSK = 25600,
	PHY_M_AN_MSK = 34816,
};

enum {
	PHY_M_LEDC_DIS_LED = 32768,
	PHY_M_LEDC_PULS_MSK = 28672,
	PHY_M_LEDC_F_INT = 2048,
	PHY_M_LEDC_BL_R_MSK = 1792,
	PHY_M_LEDC_DP_C_LSB = 128,
	PHY_M_LEDC_TX_C_LSB = 64,
	PHY_M_LEDC_LK_C_MSK = 56,
};

enum {
	PHY_M_LEDC_LINK_MSK = 24,
	PHY_M_LEDC_DP_CTRL = 4,
	PHY_M_LEDC_DP_C_MSB = 4,
	PHY_M_LEDC_RX_CTRL = 2,
	PHY_M_LEDC_TX_CTRL = 1,
	PHY_M_LEDC_TX_C_MSB = 1,
};

enum {
	PHY_M_LEDC_LOS_MSK = 61440,
	PHY_M_LEDC_INIT_MSK = 3840,
	PHY_M_LEDC_STA1_MSK = 240,
	PHY_M_LEDC_STA0_MSK = 15,
};

enum {
	PHY_M_MAC_MD_MSK = 896,
	PHY_M_MAC_GMIF_PUP = 8,
	PHY_M_MAC_MD_AUTO = 3,
	PHY_M_MAC_MD_COPPER = 5,
	PHY_M_MAC_MD_1000BX = 7,
};

enum {
	PHY_M_PC_COP_TX_DIS = 8,
	PHY_M_PC_POW_D_ENA = 4,
};

enum {
	PHY_M_PC_DIS_LINK_Pa = 32768,
	PHY_M_PC_DSC_MSK = 28672,
	PHY_M_PC_DOWN_S_ENA = 2048,
};

enum {
	PHY_M_PC_ENA_DTE_DT = 32768,
	PHY_M_PC_ENA_ENE_DT = 16384,
	PHY_M_PC_DIS_NLP_CK = 8192,
	PHY_M_PC_ENA_LIP_NP = 4096,
	PHY_M_PC_DIS_NLP_GN = 2048,
	PHY_M_PC_DIS_SCRAMB = 512,
	PHY_M_PC_DIS_FEFI = 256,
	PHY_M_PC_SH_TP_SEL = 64,
	PHY_M_PC_RX_FD_MSK = 12,
};

enum {
	PHY_M_PC_MAN_MDI = 0,
	PHY_M_PC_MAN_MDIX = 1,
	PHY_M_PC_ENA_AUTO = 3,
};

enum {
	PHY_M_PC_TX_FFD_MSK = 49152,
	PHY_M_PC_RX_FFD_MSK = 12288,
	PHY_M_PC_ASS_CRS_TX = 2048,
	PHY_M_PC_FL_GOOD = 1024,
	PHY_M_PC_EN_DET_MSK = 768,
	PHY_M_PC_ENA_EXT_D = 128,
	PHY_M_PC_MDIX_MSK = 96,
	PHY_M_PC_DIS_125CLK = 16,
	PHY_M_PC_MAC_POW_UP = 8,
	PHY_M_PC_SQE_T_ENA = 4,
	PHY_M_PC_POL_R_DIS = 2,
	PHY_M_PC_DIS_JABBER = 1,
};

enum {
	PHY_M_POLC_LS1M_MSK = 61440,
	PHY_M_POLC_IS0M_MSK = 3840,
	PHY_M_POLC_LOS_MSK = 192,
	PHY_M_POLC_INIT_MSK = 48,
	PHY_M_POLC_STA1_MSK = 12,
	PHY_M_POLC_STA0_MSK = 3,
};

enum {
	PHY_M_PS_SPEED_MSK = 49152,
	PHY_M_PS_SPEED_1000 = 32768,
	PHY_M_PS_SPEED_100 = 16384,
	PHY_M_PS_SPEED_10 = 0,
	PHY_M_PS_FULL_DUP = 8192,
	PHY_M_PS_PAGE_REC = 4096,
	PHY_M_PS_SPDUP_RES = 2048,
	PHY_M_PS_LINK_UP = 1024,
	PHY_M_PS_CABLE_MSK = 896,
	PHY_M_PS_MDI_X_STAT = 64,
	PHY_M_PS_DOWNS_STAT = 32,
	PHY_M_PS_ENDET_STAT = 16,
	PHY_M_PS_TX_P_EN = 8,
	PHY_M_PS_RX_P_EN = 4,
	PHY_M_PS_POL_REV = 2,
	PHY_M_PS_JABBER = 1,
};

enum {
	PHY_M_P_NO_PAUSE_X = 0,
	PHY_M_P_SYM_MD_X = 128,
	PHY_M_P_ASYM_MD_X = 256,
	PHY_M_P_BOTH_MD_X = 384,
};

enum {
	PIIX_IOCFG = 84,
	ICH5_PMR = 144,
	ICH5_PCS = 146,
	PIIX_SIDPR_BAR = 5,
	PIIX_SIDPR_LEN = 16,
	PIIX_SIDPR_IDX = 0,
	PIIX_SIDPR_DATA = 4,
	PIIX_FLAG_CHECKINTR = 268435456,
	PIIX_FLAG_SIDPR = 536870912,
	PIIX_PATA_FLAGS = 1,
	PIIX_SATA_FLAGS = 268435458,
	PIIX_FLAG_PIO16 = 1073741824,
	PIIX_80C_PRI = 48,
	PIIX_80C_SEC = 192,
	P0 = 0,
	P1 = 1,
	P2 = 2,
	P3 = 3,
	IDE = -1,
	NA = -2,
	RV = -3,
	PIIX_AHCI_DEVICE = 6,
	PIIX_HOST_BROKEN_SUSPEND = 16777216,
};

enum {
	PIM_TYPE_HELLO = 0,
	PIM_TYPE_REGISTER = 1,
	PIM_TYPE_REGISTER_STOP = 2,
	PIM_TYPE_JOIN_PRUNE = 3,
	PIM_TYPE_BOOTSTRAP = 4,
	PIM_TYPE_ASSERT = 5,
	PIM_TYPE_GRAFT = 6,
	PIM_TYPE_GRAFT_ACK = 7,
	PIM_TYPE_CANDIDATE_RP_ADV = 8,
};

enum {
	PLAT8250_DEV_LEGACY = -1,
	PLAT8250_DEV_PLATFORM = 0,
	PLAT8250_DEV_PLATFORM1 = 1,
	PLAT8250_DEV_PLATFORM2 = 2,
	PLAT8250_DEV_FOURPORT = 3,
	PLAT8250_DEV_ACCENT = 4,
	PLAT8250_DEV_BOCA = 5,
	PLAT8250_DEV_EXAR_ST16C554 = 6,
	PLAT8250_DEV_HUB6 = 7,
	PLAT8250_DEV_AU1X00 = 8,
	PLAT8250_DEV_SM501 = 9,
};

enum {
	POLICYDB_CAP_NETPEER = 0,
	POLICYDB_CAP_OPENPERM = 1,
	POLICYDB_CAP_EXTSOCKCLASS = 2,
	POLICYDB_CAP_ALWAYSNETWORK = 3,
	POLICYDB_CAP_CGROUPSECLABEL = 4,
	POLICYDB_CAP_NNP_NOSUID_TRANSITION = 5,
	POLICYDB_CAP_GENFS_SECLABEL_SYMLINKS = 6,
	POLICYDB_CAP_IOCTL_SKIP_CLOEXEC = 7,
	POLICYDB_CAP_USERSPACE_INITIAL_CONTEXT = 8,
	POLICYDB_CAP_NETLINK_XPERM = 9,
	__POLICYDB_CAP_MAX = 10,
};

enum {
	POOL_BITS = 256,
	POOL_READY_BITS = 256,
	POOL_EARLY_BITS = 128,
};

enum {
	POS_FIX_AUTO = 0,
	POS_FIX_LPIB = 1,
	POS_FIX_POSBUF = 2,
	POS_FIX_VIACOMBO = 3,
	POS_FIX_COMBO = 4,
	POS_FIX_SKL = 5,
	POS_FIX_FIFO = 6,
};

enum {
	POWER_SUPPLY_CAPACITY_LEVEL_UNKNOWN = 0,
	POWER_SUPPLY_CAPACITY_LEVEL_CRITICAL = 1,
	POWER_SUPPLY_CAPACITY_LEVEL_LOW = 2,
	POWER_SUPPLY_CAPACITY_LEVEL_NORMAL = 3,
	POWER_SUPPLY_CAPACITY_LEVEL_HIGH = 4,
	POWER_SUPPLY_CAPACITY_LEVEL_FULL = 5,
};

enum {
	POWER_SUPPLY_HEALTH_UNKNOWN = 0,
	POWER_SUPPLY_HEALTH_GOOD = 1,
	POWER_SUPPLY_HEALTH_OVERHEAT = 2,
	POWER_SUPPLY_HEALTH_DEAD = 3,
	POWER_SUPPLY_HEALTH_OVERVOLTAGE = 4,
	POWER_SUPPLY_HEALTH_UNDERVOLTAGE = 5,
	POWER_SUPPLY_HEALTH_UNSPEC_FAILURE = 6,
	POWER_SUPPLY_HEALTH_COLD = 7,
	POWER_SUPPLY_HEALTH_WATCHDOG_TIMER_EXPIRE = 8,
	POWER_SUPPLY_HEALTH_SAFETY_TIMER_EXPIRE = 9,
	POWER_SUPPLY_HEALTH_OVERCURRENT = 10,
	POWER_SUPPLY_HEALTH_CALIBRATION_REQUIRED = 11,
	POWER_SUPPLY_HEALTH_WARM = 12,
	POWER_SUPPLY_HEALTH_COOL = 13,
	POWER_SUPPLY_HEALTH_HOT = 14,
	POWER_SUPPLY_HEALTH_NO_BATTERY = 15,
};

enum {
	POWER_SUPPLY_SCOPE_UNKNOWN = 0,
	POWER_SUPPLY_SCOPE_SYSTEM = 1,
	POWER_SUPPLY_SCOPE_DEVICE = 2,
};

enum {
	POWER_SUPPLY_STATUS_UNKNOWN = 0,
	POWER_SUPPLY_STATUS_CHARGING = 1,
	POWER_SUPPLY_STATUS_DISCHARGING = 2,
	POWER_SUPPLY_STATUS_NOT_CHARGING = 3,
	POWER_SUPPLY_STATUS_FULL = 4,
};

enum {
	POWER_SUPPLY_TECHNOLOGY_UNKNOWN = 0,
	POWER_SUPPLY_TECHNOLOGY_NiMH = 1,
	POWER_SUPPLY_TECHNOLOGY_LION = 2,
	POWER_SUPPLY_TECHNOLOGY_LIPO = 3,
	POWER_SUPPLY_TECHNOLOGY_LiFe = 4,
	POWER_SUPPLY_TECHNOLOGY_NiCd = 5,
	POWER_SUPPLY_TECHNOLOGY_LiMn = 6,
};

enum {
	PREFIX_UNSPEC = 0,
	PREFIX_ADDRESS = 1,
	PREFIX_CACHEINFO = 2,
	__PREFIX_MAX = 3,
};

enum {
	PREF_UNIT_OP_ON = 8,
	PREF_UNIT_OP_OFF = 4,
	PREF_UNIT_RST_CLR = 2,
	PREF_UNIT_RST_SET = 1,
};

enum {
	PROCMON_0_85V_DOT_0 = 0,
	PROCMON_0_95V_DOT_0 = 1,
	PROCMON_0_95V_DOT_1 = 2,
	PROCMON_1_05V_DOT_0 = 3,
	PROCMON_1_05V_DOT_1 = 4,
};

enum {
	PROC_ENTRY_PERMANENT = 1,
	PROC_ENTRY_proc_read_iter = 2,
	PROC_ENTRY_proc_compat_ioctl = 4,
};

enum {
	PROC_ROOT_INO = 1,
	PROC_IPC_INIT_INO = 4026531839,
	PROC_UTS_INIT_INO = 4026531838,
	PROC_USER_INIT_INO = 4026531837,
	PROC_PID_INIT_INO = 4026531836,
	PROC_CGROUP_INIT_INO = 4026531835,
	PROC_TIME_INIT_INO = 4026531834,
};

enum {
	PSM_CONFIG_REG4_TIMER_PHY_LINK_DETECT_MSK = 240,
	PSM_CONFIG_REG4_TIMER_PHY_LINK_DETECT_BASE = 4,
	PSM_CONFIG_REG4_DEBUG_TIMER = 2,
	PSM_CONFIG_REG4_RST_PHY_LINK_DETECT = 1,
};

enum {
	PSS = 0,
	PPC = 1,
};

enum {
	PULS_NO_STR = 0,
	PULS_21MS = 1,
	PULS_42MS = 2,
	PULS_84MS = 3,
	PULS_170MS = 4,
	PULS_340MS = 5,
	PULS_670MS = 6,
	PULS_1300MS = 7,
};

enum {
	QIF_BLIMITS_B = 0,
	QIF_SPACE_B = 1,
	QIF_ILIMITS_B = 2,
	QIF_INODES_B = 3,
	QIF_BTIME_B = 4,
	QIF_ITIME_B = 5,
};

enum {
	QI_FREE = 0,
	QI_IN_USE = 1,
	QI_DONE = 2,
	QI_ABORT = 3,
};

enum {
	QOS_ENABLE = 0,
	QOS_CTRL = 1,
	NR_QOS_CTRL_PARAMS = 2,
};

enum {
	QOS_RPPM = 0,
	QOS_RLAT = 1,
	QOS_WPPM = 2,
	QOS_WLAT = 3,
	QOS_MIN = 4,
	QOS_MAX = 5,
	NR_QOS_PARAMS = 6,
};

enum {
	QUEUE_FLAG_DYING = 0,
	QUEUE_FLAG_NOMERGES = 1,
	QUEUE_FLAG_SAME_COMP = 2,
	QUEUE_FLAG_FAIL_IO = 3,
	QUEUE_FLAG_NOXMERGES = 4,
	QUEUE_FLAG_SAME_FORCE = 5,
	QUEUE_FLAG_INIT_DONE = 6,
	QUEUE_FLAG_STATS = 7,
	QUEUE_FLAG_REGISTERED = 8,
	QUEUE_FLAG_QUIESCED = 9,
	QUEUE_FLAG_RQ_ALLOC_TIME = 10,
	QUEUE_FLAG_HCTX_ACTIVE = 11,
	QUEUE_FLAG_SQ_SCHED = 12,
	QUEUE_FLAG_MAX = 13,
};

enum {
	QUOTA_NL_A_UNSPEC = 0,
	QUOTA_NL_A_QTYPE = 1,
	QUOTA_NL_A_EXCESS_ID = 2,
	QUOTA_NL_A_WARNING = 3,
	QUOTA_NL_A_DEV_MAJOR = 4,
	QUOTA_NL_A_DEV_MINOR = 5,
	QUOTA_NL_A_CAUSED_ID = 6,
	QUOTA_NL_A_PAD = 7,
	__QUOTA_NL_A_MAX = 8,
};

enum {
	QUOTA_NL_C_UNSPEC = 0,
	QUOTA_NL_C_WARNING = 1,
	__QUOTA_NL_C_MAX = 2,
};

enum {
	Q_R1 = 0,
	Q_R2 = 128,
	Q_XS1 = 512,
	Q_XA1 = 640,
	Q_XS2 = 768,
	Q_XA2 = 896,
};

enum {
	Q_REQUEUE_PI_NONE = 0,
	Q_REQUEUE_PI_IGNORE = 1,
	Q_REQUEUE_PI_IN_PROGRESS = 2,
	Q_REQUEUE_PI_WAIT = 3,
	Q_REQUEUE_PI_DONE = 4,
	Q_REQUEUE_PI_LOCKED = 5,
};

enum {
	RADIX_TREE_ITER_TAG_MASK = 15,
	RADIX_TREE_ITER_TAGGED = 16,
	RADIX_TREE_ITER_CONTIG = 32,
};

enum {
	RB_ADD_STAMP_NONE = 0,
	RB_ADD_STAMP_EXTEND = 2,
	RB_ADD_STAMP_ABSOLUTE = 4,
	RB_ADD_STAMP_FORCE = 8,
};

enum {
	RB_CTX_TRANSITION = 0,
	RB_CTX_NMI = 1,
	RB_CTX_IRQ = 2,
	RB_CTX_SOFTIRQ = 3,
	RB_CTX_NORMAL = 4,
	RB_CTX_MAX = 5,
};

enum {
	RB_ENA_STFWD = 32,
	RB_DIS_STFWD = 16,
	RB_ENA_OP_MD = 8,
	RB_DIS_OP_MD = 4,
	RB_RST_CLR = 2,
	RB_RST_SET = 1,
};

enum {
	RB_LEN_TIME_EXTEND = 8,
	RB_LEN_TIME_STAMP = 8,
};

enum {
	RB_START = 0,
	RB_END = 4,
	RB_WP = 8,
	RB_RP = 12,
	RB_RX_UTPP = 16,
	RB_RX_LTPP = 20,
	RB_RX_UTHP = 24,
	RB_RX_LTHP = 28,
	RB_PC = 32,
	RB_LEV = 36,
	RB_CTRL = 40,
	RB_TST1 = 41,
	RB_TST2 = 42,
};

enum {
	REASON_BOUNDS = -1,
	REASON_TYPE = -2,
	REASON_PATHS = -3,
	REASON_LIMIT = -4,
	REASON_STACK = -5,
};

enum {
	REGION_INTERSECTS = 0,
	REGION_DISJOINT = 1,
	REGION_MIXED = 2,
};

enum {
	REQ_FSEQ_PREFLUSH = 1,
	REQ_FSEQ_DATA = 2,
	REQ_FSEQ_POSTFLUSH = 4,
	REQ_FSEQ_DONE = 8,
	REQ_FSEQ_ACTIONS = 7,
	FLUSH_PENDING_TIMEOUT = 5000,
};

enum {
	REQ_F_FIXED_FILE = 1ULL,
	REQ_F_IO_DRAIN = 2ULL,
	REQ_F_LINK = 4ULL,
	REQ_F_HARDLINK = 8ULL,
	REQ_F_FORCE_ASYNC = 16ULL,
	REQ_F_BUFFER_SELECT = 32ULL,
	REQ_F_CQE_SKIP = 64ULL,
	REQ_F_FAIL = 256ULL,
	REQ_F_INFLIGHT = 512ULL,
	REQ_F_CUR_POS = 1024ULL,
	REQ_F_NOWAIT = 2048ULL,
	REQ_F_LINK_TIMEOUT = 4096ULL,
	REQ_F_NEED_CLEANUP = 8192ULL,
	REQ_F_POLLED = 16384ULL,
	REQ_F_IOPOLL_STATE = 32768ULL,
	REQ_F_BUFFER_SELECTED = 65536ULL,
	REQ_F_BUFFER_RING = 131072ULL,
	REQ_F_REISSUE = 262144ULL,
	REQ_F_SUPPORT_NOWAIT = 268435456ULL,
	REQ_F_ISREG = 536870912ULL,
	REQ_F_CREDS = 524288ULL,
	REQ_F_REFCOUNT = 1048576ULL,
	REQ_F_ARM_LTIMEOUT = 2097152ULL,
	REQ_F_ASYNC_DATA = 4194304ULL,
	REQ_F_SKIP_LINK_CQES = 8388608ULL,
	REQ_F_SINGLE_POLL = 16777216ULL,
	REQ_F_DOUBLE_POLL = 33554432ULL,
	REQ_F_APOLL_MULTISHOT = 67108864ULL,
	REQ_F_CLEAR_POLLIN = 134217728ULL,
	REQ_F_POLL_NO_LAZY = 1073741824ULL,
	REQ_F_CAN_POLL = 2147483648ULL,
	REQ_F_BL_EMPTY = 4294967296ULL,
	REQ_F_BL_NO_RECYCLE = 8589934592ULL,
	REQ_F_BUFFERS_COMMIT = 17179869184ULL,
	REQ_F_BUF_NODE = 34359738368ULL,
	REQ_F_HAS_METADATA = 68719476736ULL,
};

enum {
	REQ_F_FIXED_FILE_BIT = 0,
	REQ_F_IO_DRAIN_BIT = 1,
	REQ_F_LINK_BIT = 2,
	REQ_F_HARDLINK_BIT = 3,
	REQ_F_FORCE_ASYNC_BIT = 4,
	REQ_F_BUFFER_SELECT_BIT = 5,
	REQ_F_CQE_SKIP_BIT = 6,
	REQ_F_FAIL_BIT = 8,
	REQ_F_INFLIGHT_BIT = 9,
	REQ_F_CUR_POS_BIT = 10,
	REQ_F_NOWAIT_BIT = 11,
	REQ_F_LINK_TIMEOUT_BIT = 12,
	REQ_F_NEED_CLEANUP_BIT = 13,
	REQ_F_POLLED_BIT = 14,
	REQ_F_HYBRID_IOPOLL_STATE_BIT = 15,
	REQ_F_BUFFER_SELECTED_BIT = 16,
	REQ_F_BUFFER_RING_BIT = 17,
	REQ_F_REISSUE_BIT = 18,
	REQ_F_CREDS_BIT = 19,
	REQ_F_REFCOUNT_BIT = 20,
	REQ_F_ARM_LTIMEOUT_BIT = 21,
	REQ_F_ASYNC_DATA_BIT = 22,
	REQ_F_SKIP_LINK_CQES_BIT = 23,
	REQ_F_SINGLE_POLL_BIT = 24,
	REQ_F_DOUBLE_POLL_BIT = 25,
	REQ_F_APOLL_MULTISHOT_BIT = 26,
	REQ_F_CLEAR_POLLIN_BIT = 27,
	REQ_F_SUPPORT_NOWAIT_BIT = 28,
	REQ_F_ISREG_BIT = 29,
	REQ_F_POLL_NO_LAZY_BIT = 30,
	REQ_F_CAN_POLL_BIT = 31,
	REQ_F_BL_EMPTY_BIT = 32,
	REQ_F_BL_NO_RECYCLE_BIT = 33,
	REQ_F_BUFFERS_COMMIT_BIT = 34,
	REQ_F_BUF_NODE_BIT = 35,
	REQ_F_HAS_METADATA_BIT = 36,
	__REQ_F_LAST_BIT = 37,
};

enum {
	RES_USAGE = 0,
	RES_RSVD_USAGE = 1,
	RES_LIMIT = 2,
	RES_RSVD_LIMIT = 3,
	RES_MAX_USAGE = 4,
	RES_RSVD_MAX_USAGE = 5,
	RES_FAILCNT = 6,
	RES_RSVD_FAILCNT = 7,
};

enum {
	RI_CLR_RD_PERR = 512,
	RI_CLR_WR_PERR = 256,
	RI_RST_CLR = 2,
	RI_RST_SET = 1,
};

enum {
	RPCAUTH_info = 0,
	RPCAUTH_EOF = 1,
};

enum {
	RPCAUTH_lockd = 0,
	RPCAUTH_mount = 1,
	RPCAUTH_nfs = 2,
	RPCAUTH_portmap = 3,
	RPCAUTH_statd = 4,
	RPCAUTH_nfsd4_cb = 5,
	RPCAUTH_cache = 6,
	RPCAUTH_nfsd = 7,
	RPCAUTH_gssd = 8,
	RPCAUTH_RootEOF = 9,
};

enum {
	RPCBPROC_NULL = 0,
	RPCBPROC_SET = 1,
	RPCBPROC_UNSET = 2,
	RPCBPROC_GETPORT = 3,
	RPCBPROC_GETADDR = 3,
	RPCBPROC_DUMP = 4,
	RPCBPROC_CALLIT = 5,
	RPCBPROC_BCAST = 5,
	RPCBPROC_GETTIME = 6,
	RPCBPROC_UADDR2TADDR = 7,
	RPCBPROC_TADDR2UADDR = 8,
	RPCBPROC_GETVERSADDR = 9,
	RPCBPROC_INDIRECT = 10,
	RPCBPROC_GETADDRLIST = 11,
	RPCBPROC_GETSTAT = 12,
};

enum {
	RPC_PIPEFS_MOUNT = 0,
	RPC_PIPEFS_UMOUNT = 1,
};

enum {
	RPC_TASK_RUNNING = 0,
	RPC_TASK_QUEUED = 1,
	RPC_TASK_ACTIVE = 2,
	RPC_TASK_NEED_XMIT = 3,
	RPC_TASK_NEED_RECV = 4,
	RPC_TASK_MSG_PIN_WAIT = 5,
};

enum {
	RQ_SECURE = 0,
	RQ_LOCAL = 1,
	RQ_USEDEFERRAL = 2,
	RQ_DROPME = 3,
	RQ_VICTIM = 4,
	RQ_DATA = 5,
};

enum {
	RQ_WAIT_BUSY_PCT = 5,
	UNBUSY_THR_PCT = 75,
	MIN_DELAY_THR_PCT = 500,
	MAX_DELAY_THR_PCT = 25000,
	MIN_DELAY = 250,
	MAX_DELAY = 250000,
	DFGV_USAGE_PCT = 50,
	DFGV_PERIOD = 100000,
	MAX_LAGGING_PERIODS = 10,
	IOC_PAGE_SHIFT = 12,
	IOC_PAGE_SIZE = 4096,
	IOC_SECT_TO_PAGE_SHIFT = 3,
	LCOEF_RANDIO_PAGES = 4096,
};

enum {
	RTAX_UNSPEC = 0,
	RTAX_LOCK = 1,
	RTAX_MTU = 2,
	RTAX_WINDOW = 3,
	RTAX_RTT = 4,
	RTAX_RTTVAR = 5,
	RTAX_SSTHRESH = 6,
	RTAX_CWND = 7,
	RTAX_ADVMSS = 8,
	RTAX_REORDERING = 9,
	RTAX_HOPLIMIT = 10,
	RTAX_INITCWND = 11,
	RTAX_FEATURES = 12,
	RTAX_RTO_MIN = 13,
	RTAX_INITRWND = 14,
	RTAX_QUICKACK = 15,
	RTAX_CC_ALGO = 16,
	RTAX_FASTOPEN_NO_COOKIE = 17,
	__RTAX_MAX = 18,
};

enum {
	RTL8139 = 0,
	RTL8129 = 1,
};

enum {
	RTM_BASE = 16,
	RTM_NEWLINK = 16,
	RTM_DELLINK = 17,
	RTM_GETLINK = 18,
	RTM_SETLINK = 19,
	RTM_NEWADDR = 20,
	RTM_DELADDR = 21,
	RTM_GETADDR = 22,
	RTM_NEWROUTE = 24,
	RTM_DELROUTE = 25,
	RTM_GETROUTE = 26,
	RTM_NEWNEIGH = 28,
	RTM_DELNEIGH = 29,
	RTM_GETNEIGH = 30,
	RTM_NEWRULE = 32,
	RTM_DELRULE = 33,
	RTM_GETRULE = 34,
	RTM_NEWQDISC = 36,
	RTM_DELQDISC = 37,
	RTM_GETQDISC = 38,
	RTM_NEWTCLASS = 40,
	RTM_DELTCLASS = 41,
	RTM_GETTCLASS = 42,
	RTM_NEWTFILTER = 44,
	RTM_DELTFILTER = 45,
	RTM_GETTFILTER = 46,
	RTM_NEWACTION = 48,
	RTM_DELACTION = 49,
	RTM_GETACTION = 50,
	RTM_NEWPREFIX = 52,
	RTM_NEWMULTICAST = 56,
	RTM_DELMULTICAST = 57,
	RTM_GETMULTICAST = 58,
	RTM_NEWANYCAST = 60,
	RTM_DELANYCAST = 61,
	RTM_GETANYCAST = 62,
	RTM_NEWNEIGHTBL = 64,
	RTM_GETNEIGHTBL = 66,
	RTM_SETNEIGHTBL = 67,
	RTM_NEWNDUSEROPT = 68,
	RTM_NEWADDRLABEL = 72,
	RTM_DELADDRLABEL = 73,
	RTM_GETADDRLABEL = 74,
	RTM_GETDCB = 78,
	RTM_SETDCB = 79,
	RTM_NEWNETCONF = 80,
	RTM_DELNETCONF = 81,
	RTM_GETNETCONF = 82,
	RTM_NEWMDB = 84,
	RTM_DELMDB = 85,
	RTM_GETMDB = 86,
	RTM_NEWNSID = 88,
	RTM_DELNSID = 89,
	RTM_GETNSID = 90,
	RTM_NEWSTATS = 92,
	RTM_GETSTATS = 94,
	RTM_SETSTATS = 95,
	RTM_NEWCACHEREPORT = 96,
	RTM_NEWCHAIN = 100,
	RTM_DELCHAIN = 101,
	RTM_GETCHAIN = 102,
	RTM_NEWNEXTHOP = 104,
	RTM_DELNEXTHOP = 105,
	RTM_GETNEXTHOP = 106,
	RTM_NEWLINKPROP = 108,
	RTM_DELLINKPROP = 109,
	RTM_GETLINKPROP = 110,
	RTM_NEWVLAN = 112,
	RTM_DELVLAN = 113,
	RTM_GETVLAN = 114,
	RTM_NEWNEXTHOPBUCKET = 116,
	RTM_DELNEXTHOPBUCKET = 117,
	RTM_GETNEXTHOPBUCKET = 118,
	RTM_NEWTUNNEL = 120,
	RTM_DELTUNNEL = 121,
	RTM_GETTUNNEL = 122,
	__RTM_MAX = 123,
};

enum {
	RTN_UNSPEC = 0,
	RTN_UNICAST = 1,
	RTN_LOCAL = 2,
	RTN_BROADCAST = 3,
	RTN_ANYCAST = 4,
	RTN_MULTICAST = 5,
	RTN_BLACKHOLE = 6,
	RTN_UNREACHABLE = 7,
	RTN_PROHIBIT = 8,
	RTN_THROW = 9,
	RTN_NAT = 10,
	RTN_XRESOLVE = 11,
	__RTN_MAX = 12,
};

enum {
	RX_GCLKMAC_ENA = -2147483648,
	RX_GCLKMAC_OFF = 1073741824,
	RX_STFW_DIS = 536870912,
	RX_STFW_ENA = 268435456,
	RX_TRUNC_ON = 134217728,
	RX_TRUNC_OFF = 67108864,
	RX_VLAN_STRIP_ON = 33554432,
	RX_VLAN_STRIP_OFF = 16777216,
	RX_MACSEC_FLUSH_ON = 8388608,
	RX_MACSEC_FLUSH_OFF = 4194304,
	RX_MACSEC_ASF_FLUSH_ON = 2097152,
	RX_MACSEC_ASF_FLUSH_OFF = 1048576,
	GMF_RX_OVER_ON = 524288,
	GMF_RX_OVER_OFF = 262144,
	GMF_ASF_RX_OVER_ON = 131072,
	GMF_ASF_RX_OVER_OFF = 65536,
	GMF_WP_TST_ON = 16384,
	GMF_WP_TST_OFF = 8192,
	GMF_WP_STEP = 4096,
	GMF_RP_TST_ON = 1024,
	GMF_RP_TST_OFF = 512,
	GMF_RP_STEP = 256,
	GMF_RX_F_FL_ON = 128,
	GMF_RX_F_FL_OFF = 64,
	GMF_CLI_RX_FO = 32,
	GMF_CLI_RX_C = 16,
	GMF_OPER_ON = 8,
	GMF_OPER_OFF = 4,
	GMF_RST_CLR = 2,
	GMF_RST_SET = 1,
	RX_GMF_FL_THR_DEF = 10,
	GMF_RX_CTRL_DEF = 136,
};

enum {
	RX_IPV6_SA_MOB_ENA = 512,
	RX_IPV6_SA_MOB_DIS = 256,
	RX_IPV6_DA_MOB_ENA = 128,
	RX_IPV6_DA_MOB_DIS = 64,
	RX_PTR_SYNCDLY_ENA = 32,
	RX_PTR_SYNCDLY_DIS = 16,
	RX_ASF_NEWFLAG_ENA = 8,
	RX_ASF_NEWFLAG_DIS = 4,
	RX_FLSH_MISSPKT_ENA = 2,
	RX_FLSH_MISSPKT_DIS = 1,
};

enum {
	Root_NFS = 255,
	Root_CIFS = 254,
	Root_Generic = 253,
	Root_RAM0 = 1048576,
};

enum {
	Rworksched = 1,
	Rpending = 2,
	Wworksched = 4,
	Wpending = 8,
};

enum {
	SAMPLES = 8,
	MIN_CHANGE = 5,
};

enum {
	SB_UNFROZEN = 0,
	SB_FREEZE_WRITE = 1,
	SB_FREEZE_PAGEFAULT = 2,
	SB_FREEZE_FS = 3,
	SB_FREEZE_COMPLETE = 4,
};

enum {
	SCM_TSTAMP_SND = 0,
	SCM_TSTAMP_SCHED = 1,
	SCM_TSTAMP_ACK = 2,
};

enum {
	SCTP_AUTH_HMAC_ID_RESERVED_0 = 0,
	SCTP_AUTH_HMAC_ID_SHA1 = 1,
	SCTP_AUTH_HMAC_ID_RESERVED_2 = 2,
	SCTP_AUTH_HMAC_ID_SHA256 = 3,
	__SCTP_AUTH_HMAC_MAX = 4,
};

enum {
	SCTP_MAX_DUP_TSNS = 16,
};

enum {
	SCTP_MAX_STREAM = 65535,
};

enum {
	SC_STAT_CLR_IRQ = 16,
	SC_STAT_OP_ON = 8,
	SC_STAT_OP_OFF = 4,
	SC_STAT_RST_CLR = 2,
	SC_STAT_RST_SET = 1,
};

enum {
	SD_BALANCE_NEWIDLE = 1,
	SD_BALANCE_EXEC = 2,
	SD_BALANCE_FORK = 4,
	SD_BALANCE_WAKE = 8,
	SD_WAKE_AFFINE = 16,
	SD_ASYM_CPUCAPACITY = 32,
	SD_ASYM_CPUCAPACITY_FULL = 64,
	SD_SHARE_CPUCAPACITY = 128,
	SD_CLUSTER = 256,
	SD_SHARE_LLC = 512,
	SD_SERIALIZE = 1024,
	SD_ASYM_PACKING = 2048,
	SD_PREFER_SIBLING = 4096,
	SD_OVERLAP = 8192,
	SD_NUMA = 16384,
};

enum {
	SD_DEF_XFER_BLOCKS = 65535,
	SD_MAX_XFER_BLOCKS = 4294967295,
	SD_MAX_WS10_BLOCKS = 65535,
	SD_MAX_WS16_BLOCKS = 8388607,
};

enum {
	SD_EXT_CDB_SIZE = 32,
	SD_MEMPOOL_SIZE = 2,
};

enum {
	SD_LBP_FULL = 0,
	SD_LBP_UNMAP = 1,
	SD_LBP_WS16 = 2,
	SD_LBP_WS10 = 3,
	SD_LBP_ZERO = 4,
	SD_LBP_DISABLE = 5,
};

enum {
	SD_ZERO_WRITE = 0,
	SD_ZERO_WS = 1,
	SD_ZERO_WS16_UNMAP = 2,
	SD_ZERO_WS10_UNMAP = 3,
};

enum {
	SECTION_MARKED_PRESENT_BIT = 0,
	SECTION_HAS_MEM_MAP_BIT = 1,
	SECTION_IS_ONLINE_BIT = 2,
	SECTION_IS_EARLY_BIT = 3,
	SECTION_MAP_LAST_BIT = 4,
};

enum {
	SEG6_ATTR_UNSPEC = 0,
	SEG6_ATTR_DST = 1,
	SEG6_ATTR_DSTLEN = 2,
	SEG6_ATTR_HMACKEYID = 3,
	SEG6_ATTR_SECRET = 4,
	SEG6_ATTR_SECRETLEN = 5,
	SEG6_ATTR_ALGID = 6,
	SEG6_ATTR_HMACINFO = 7,
	__SEG6_ATTR_MAX = 8,
};

enum {
	SEG6_CMD_UNSPEC = 0,
	SEG6_CMD_SETHMAC = 1,
	SEG6_CMD_DUMPHMAC = 2,
	SEG6_CMD_SET_TUNSRC = 3,
	SEG6_CMD_GET_TUNSRC = 4,
	__SEG6_CMD_MAX = 5,
};

enum {
	SELNL_MSG_SETENFORCE = 16,
	SELNL_MSG_POLICYLOAD = 17,
	SELNL_MSG_MAX = 18,
};

enum {
	SFF8024_ID_UNK = 0,
	SFF8024_ID_SFF_8472 = 2,
	SFF8024_ID_SFP = 3,
	SFF8024_ID_DWDM_SFP = 11,
	SFF8024_ID_QSFP_8438 = 12,
	SFF8024_ID_QSFP_8436_8636 = 13,
	SFF8024_ID_QSFP28_8636 = 17,
	SFF8024_ID_QSFP_DD = 24,
	SFF8024_ID_OSFP = 25,
	SFF8024_ID_DSFP = 27,
	SFF8024_ID_QSFP_PLUS_CMIS = 30,
	SFF8024_ID_SFP_DD_CMIS = 31,
	SFF8024_ID_SFP_PLUS_CMIS = 32,
	SFF8024_ENCODING_UNSPEC = 0,
	SFF8024_ENCODING_8B10B = 1,
	SFF8024_ENCODING_4B5B = 2,
	SFF8024_ENCODING_NRZ = 3,
	SFF8024_ENCODING_8472_MANCHESTER = 4,
	SFF8024_ENCODING_8472_SONET = 5,
	SFF8024_ENCODING_8472_64B66B = 6,
	SFF8024_ENCODING_8436_MANCHESTER = 6,
	SFF8024_ENCODING_8436_SONET = 4,
	SFF8024_ENCODING_8436_64B66B = 5,
	SFF8024_ENCODING_256B257B = 7,
	SFF8024_ENCODING_PAM4 = 8,
	SFF8024_CONNECTOR_UNSPEC = 0,
	SFF8024_CONNECTOR_SC = 1,
	SFF8024_CONNECTOR_FIBERJACK = 6,
	SFF8024_CONNECTOR_LC = 7,
	SFF8024_CONNECTOR_MT_RJ = 8,
	SFF8024_CONNECTOR_MU = 9,
	SFF8024_CONNECTOR_SG = 10,
	SFF8024_CONNECTOR_OPTICAL_PIGTAIL = 11,
	SFF8024_CONNECTOR_MPO_1X12 = 12,
	SFF8024_CONNECTOR_MPO_2X16 = 13,
	SFF8024_CONNECTOR_HSSDC_II = 32,
	SFF8024_CONNECTOR_COPPER_PIGTAIL = 33,
	SFF8024_CONNECTOR_RJ45 = 34,
	SFF8024_CONNECTOR_NOSEPARATE = 35,
	SFF8024_CONNECTOR_MXC_2X16 = 36,
	SFF8024_ECC_UNSPEC = 0,
	SFF8024_ECC_100G_25GAUI_C2M_AOC = 1,
	SFF8024_ECC_100GBASE_SR4_25GBASE_SR = 2,
	SFF8024_ECC_100GBASE_LR4_25GBASE_LR = 3,
	SFF8024_ECC_100GBASE_ER4_25GBASE_ER = 4,
	SFF8024_ECC_100GBASE_SR10 = 5,
	SFF8024_ECC_100GBASE_CR4 = 11,
	SFF8024_ECC_25GBASE_CR_S = 12,
	SFF8024_ECC_25GBASE_CR_N = 13,
	SFF8024_ECC_10GBASE_T_SFI = 22,
	SFF8024_ECC_10GBASE_T_SR = 28,
	SFF8024_ECC_5GBASE_T = 29,
	SFF8024_ECC_2_5GBASE_T = 30,
};

enum {
	SFP_PHYS_ID = 0,
	SFP_PHYS_EXT_ID = 1,
	SFP_PHYS_EXT_ID_SFP = 4,
	SFP_CONNECTOR = 2,
	SFP_COMPLIANCE = 3,
	SFP_ENCODING = 11,
	SFP_BR_NOMINAL = 12,
	SFP_RATE_ID = 13,
	SFF_RID_8079 = 1,
	SFF_RID_8431_RX_ONLY = 2,
	SFF_RID_8431_TX_ONLY = 4,
	SFF_RID_8431 = 6,
	SFF_RID_10G8G = 14,
	SFP_LINK_LEN_SM_KM = 14,
	SFP_LINK_LEN_SM_100M = 15,
	SFP_LINK_LEN_50UM_OM2_10M = 16,
	SFP_LINK_LEN_62_5UM_OM1_10M = 17,
	SFP_LINK_LEN_COPPER_1M = 18,
	SFP_LINK_LEN_50UM_OM4_10M = 18,
	SFP_LINK_LEN_50UM_OM3_10M = 19,
	SFP_VENDOR_NAME = 20,
	SFP_VENDOR_OUI = 37,
	SFP_VENDOR_PN = 40,
	SFP_VENDOR_REV = 56,
	SFP_OPTICAL_WAVELENGTH_MSB = 60,
	SFP_OPTICAL_WAVELENGTH_LSB = 61,
	SFP_CABLE_SPEC = 60,
	SFP_CC_BASE = 63,
	SFP_OPTIONS = 64,
	SFP_OPTIONS_HIGH_POWER_LEVEL = 8192,
	SFP_OPTIONS_PAGING_A2 = 4096,
	SFP_OPTIONS_RETIMER = 2048,
	SFP_OPTIONS_COOLED_XCVR = 1024,
	SFP_OPTIONS_POWER_DECL = 512,
	SFP_OPTIONS_RX_LINEAR_OUT = 256,
	SFP_OPTIONS_RX_DECISION_THRESH = 128,
	SFP_OPTIONS_TUNABLE_TX = 64,
	SFP_OPTIONS_RATE_SELECT = 32,
	SFP_OPTIONS_TX_DISABLE = 16,
	SFP_OPTIONS_TX_FAULT = 8,
	SFP_OPTIONS_LOS_INVERTED = 4,
	SFP_OPTIONS_LOS_NORMAL = 2,
	SFP_BR_MAX = 66,
	SFP_BR_MIN = 67,
	SFP_VENDOR_SN = 68,
	SFP_DATECODE = 84,
	SFP_DIAGMON = 92,
	SFP_DIAGMON_DDM = 64,
	SFP_DIAGMON_INT_CAL = 32,
	SFP_DIAGMON_EXT_CAL = 16,
	SFP_DIAGMON_RXPWR_AVG = 8,
	SFP_DIAGMON_ADDRMODE = 4,
	SFP_ENHOPTS = 93,
	SFP_ENHOPTS_ALARMWARN = 128,
	SFP_ENHOPTS_SOFT_TX_DISABLE = 64,
	SFP_ENHOPTS_SOFT_TX_FAULT = 32,
	SFP_ENHOPTS_SOFT_RX_LOS = 16,
	SFP_ENHOPTS_SOFT_RATE_SELECT = 8,
	SFP_ENHOPTS_APP_SELECT_SFF8079 = 4,
	SFP_ENHOPTS_SOFT_RATE_SFF8431 = 2,
	SFP_SFF8472_COMPLIANCE = 94,
	SFP_SFF8472_COMPLIANCE_NONE = 0,
	SFP_SFF8472_COMPLIANCE_REV9_3 = 1,
	SFP_SFF8472_COMPLIANCE_REV9_5 = 2,
	SFP_SFF8472_COMPLIANCE_REV10_2 = 3,
	SFP_SFF8472_COMPLIANCE_REV10_4 = 4,
	SFP_SFF8472_COMPLIANCE_REV11_0 = 5,
	SFP_SFF8472_COMPLIANCE_REV11_3 = 6,
	SFP_SFF8472_COMPLIANCE_REV11_4 = 7,
	SFP_SFF8472_COMPLIANCE_REV12_0 = 8,
	SFP_CC_EXT = 95,
};

enum {
	SKBFL_ZEROCOPY_ENABLE = 1,
	SKBFL_SHARED_FRAG = 2,
	SKBFL_PURE_ZEROCOPY = 4,
	SKBFL_DONT_ORPHAN = 8,
	SKBFL_MANAGED_FRAG_REFS = 16,
};

enum {
	SKBTX_HW_TSTAMP = 1,
	SKBTX_SW_TSTAMP = 2,
	SKBTX_IN_PROGRESS = 4,
	SKBTX_HW_TSTAMP_USE_CYCLES = 8,
	SKBTX_WIFI_STATUS = 16,
	SKBTX_HW_TSTAMP_NETDEV = 32,
	SKBTX_SCHED_TSTAMP = 64,
};

enum {
	SKB_FCLONE_UNAVAILABLE = 0,
	SKB_FCLONE_ORIG = 1,
	SKB_FCLONE_CLONE = 2,
};

enum {
	SKB_GSO_TCPV4 = 1,
	SKB_GSO_DODGY = 2,
	SKB_GSO_TCP_ECN = 4,
	SKB_GSO_TCP_FIXEDID = 8,
	SKB_GSO_TCPV6 = 16,
	SKB_GSO_FCOE = 32,
	SKB_GSO_GRE = 64,
	SKB_GSO_GRE_CSUM = 128,
	SKB_GSO_IPXIP4 = 256,
	SKB_GSO_IPXIP6 = 512,
	SKB_GSO_UDP_TUNNEL = 1024,
	SKB_GSO_UDP_TUNNEL_CSUM = 2048,
	SKB_GSO_PARTIAL = 4096,
	SKB_GSO_TUNNEL_REMCSUM = 8192,
	SKB_GSO_SCTP = 16384,
	SKB_GSO_ESP = 32768,
	SKB_GSO_UDP = 65536,
	SKB_GSO_UDP_L4 = 131072,
	SKB_GSO_FRAGLIST = 262144,
};

enum {
	SKCIPHER_WALK_SLOW = 1,
	SKCIPHER_WALK_COPY = 2,
	SKCIPHER_WALK_DIFF = 4,
	SKCIPHER_WALK_SLEEP = 8,
};

enum {
	SKX_PCI_UNCORE_IMC = 0,
	SKX_PCI_UNCORE_M2M = 1,
	SKX_PCI_UNCORE_UPI = 2,
	SKX_PCI_UNCORE_M2PCIE = 3,
	SKX_PCI_UNCORE_M3UPI = 4,
};

enum {
	SK_DIAG_BPF_STORAGE_NONE = 0,
	SK_DIAG_BPF_STORAGE_PAD = 1,
	SK_DIAG_BPF_STORAGE_MAP_ID = 2,
	SK_DIAG_BPF_STORAGE_MAP_VALUE = 3,
	__SK_DIAG_BPF_STORAGE_MAX = 4,
};

enum {
	SK_DIAG_BPF_STORAGE_REP_NONE = 0,
	SK_DIAG_BPF_STORAGE = 1,
	__SK_DIAG_BPF_STORAGE_REP_MAX = 2,
};

enum {
	SK_DIAG_BPF_STORAGE_REQ_NONE = 0,
	SK_DIAG_BPF_STORAGE_REQ_MAP_FD = 1,
	__SK_DIAG_BPF_STORAGE_REQ_MAX = 2,
};

enum {
	SK_MEMINFO_RMEM_ALLOC = 0,
	SK_MEMINFO_RCVBUF = 1,
	SK_MEMINFO_WMEM_ALLOC = 2,
	SK_MEMINFO_SNDBUF = 3,
	SK_MEMINFO_FWD_ALLOC = 4,
	SK_MEMINFO_WMEM_QUEUED = 5,
	SK_MEMINFO_OPTMEM = 6,
	SK_MEMINFO_BACKLOG = 7,
	SK_MEMINFO_DROPS = 8,
	SK_MEMINFO_VARS = 9,
};

enum {
	SNBEP_PCI_QPI_PORT0_FILTER = 0,
	SNBEP_PCI_QPI_PORT1_FILTER = 1,
	BDX_PCI_QPI_PORT2_FILTER = 2,
};

enum {
	SNBEP_PCI_UNCORE_HA = 0,
	SNBEP_PCI_UNCORE_IMC = 1,
	SNBEP_PCI_UNCORE_QPI = 2,
	SNBEP_PCI_UNCORE_R2PCIE = 3,
	SNBEP_PCI_UNCORE_R3QPI = 4,
};

enum {
	SNB_PCI_UNCORE_IMC = 0,
};

enum {
	SNDRV_CHMAP_UNKNOWN = 0,
	SNDRV_CHMAP_NA = 1,
	SNDRV_CHMAP_MONO = 2,
	SNDRV_CHMAP_FL = 3,
	SNDRV_CHMAP_FR = 4,
	SNDRV_CHMAP_RL = 5,
	SNDRV_CHMAP_RR = 6,
	SNDRV_CHMAP_FC = 7,
	SNDRV_CHMAP_LFE = 8,
	SNDRV_CHMAP_SL = 9,
	SNDRV_CHMAP_SR = 10,
	SNDRV_CHMAP_RC = 11,
	SNDRV_CHMAP_FLC = 12,
	SNDRV_CHMAP_FRC = 13,
	SNDRV_CHMAP_RLC = 14,
	SNDRV_CHMAP_RRC = 15,
	SNDRV_CHMAP_FLW = 16,
	SNDRV_CHMAP_FRW = 17,
	SNDRV_CHMAP_FLH = 18,
	SNDRV_CHMAP_FCH = 19,
	SNDRV_CHMAP_FRH = 20,
	SNDRV_CHMAP_TC = 21,
	SNDRV_CHMAP_TFL = 22,
	SNDRV_CHMAP_TFR = 23,
	SNDRV_CHMAP_TFC = 24,
	SNDRV_CHMAP_TRL = 25,
	SNDRV_CHMAP_TRR = 26,
	SNDRV_CHMAP_TRC = 27,
	SNDRV_CHMAP_TFLC = 28,
	SNDRV_CHMAP_TFRC = 29,
	SNDRV_CHMAP_TSL = 30,
	SNDRV_CHMAP_TSR = 31,
	SNDRV_CHMAP_LLFE = 32,
	SNDRV_CHMAP_RLFE = 33,
	SNDRV_CHMAP_BC = 34,
	SNDRV_CHMAP_BLC = 35,
	SNDRV_CHMAP_BRC = 36,
	SNDRV_CHMAP_LAST = 36,
};

enum {
	SNDRV_CTL_IOCTL_ELEM_LIST32 = 3225965840,
	SNDRV_CTL_IOCTL_ELEM_INFO32 = 3239073041,
	SNDRV_CTL_IOCTL_ELEM_READ32 = 3267646738,
	SNDRV_CTL_IOCTL_ELEM_WRITE32 = 3267646739,
	SNDRV_CTL_IOCTL_ELEM_ADD32 = 3239073047,
	SNDRV_CTL_IOCTL_ELEM_REPLACE32 = 3239073048,
};

enum {
	SNDRV_CTL_TLV_OP_READ = 0,
	SNDRV_CTL_TLV_OP_WRITE = 1,
	SNDRV_CTL_TLV_OP_CMD = -1,
};

enum {
	SNDRV_HWDEP_IFACE_OPL2 = 0,
	SNDRV_HWDEP_IFACE_OPL3 = 1,
	SNDRV_HWDEP_IFACE_OPL4 = 2,
	SNDRV_HWDEP_IFACE_SB16CSP = 3,
	SNDRV_HWDEP_IFACE_EMU10K1 = 4,
	SNDRV_HWDEP_IFACE_YSS225 = 5,
	SNDRV_HWDEP_IFACE_ICS2115 = 6,
	SNDRV_HWDEP_IFACE_SSCAPE = 7,
	SNDRV_HWDEP_IFACE_VX = 8,
	SNDRV_HWDEP_IFACE_MIXART = 9,
	SNDRV_HWDEP_IFACE_USX2Y = 10,
	SNDRV_HWDEP_IFACE_EMUX_WAVETABLE = 11,
	SNDRV_HWDEP_IFACE_BLUETOOTH = 12,
	SNDRV_HWDEP_IFACE_USX2Y_PCM = 13,
	SNDRV_HWDEP_IFACE_PCXHR = 14,
	SNDRV_HWDEP_IFACE_SB_RC = 15,
	SNDRV_HWDEP_IFACE_HDA = 16,
	SNDRV_HWDEP_IFACE_USB_STREAM = 17,
	SNDRV_HWDEP_IFACE_FW_DICE = 18,
	SNDRV_HWDEP_IFACE_FW_FIREWORKS = 19,
	SNDRV_HWDEP_IFACE_FW_BEBOB = 20,
	SNDRV_HWDEP_IFACE_FW_OXFW = 21,
	SNDRV_HWDEP_IFACE_FW_DIGI00X = 22,
	SNDRV_HWDEP_IFACE_FW_TASCAM = 23,
	SNDRV_HWDEP_IFACE_LINE6 = 24,
	SNDRV_HWDEP_IFACE_FW_MOTU = 25,
	SNDRV_HWDEP_IFACE_FW_FIREFACE = 26,
	SNDRV_HWDEP_IFACE_LAST = 26,
};

enum {
	SNDRV_HWDEP_IOCTL_DSP_LOAD32 = 1079003139,
};

enum {
	SNDRV_PCM_AUDIO_TSTAMP_TYPE_COMPAT = 0,
	SNDRV_PCM_AUDIO_TSTAMP_TYPE_DEFAULT = 1,
	SNDRV_PCM_AUDIO_TSTAMP_TYPE_LINK = 2,
	SNDRV_PCM_AUDIO_TSTAMP_TYPE_LINK_ABSOLUTE = 3,
	SNDRV_PCM_AUDIO_TSTAMP_TYPE_LINK_ESTIMATED = 4,
	SNDRV_PCM_AUDIO_TSTAMP_TYPE_LINK_SYNCHRONIZED = 5,
	SNDRV_PCM_AUDIO_TSTAMP_TYPE_LAST = 5,
};

enum {
	SNDRV_PCM_CLASS_GENERIC = 0,
	SNDRV_PCM_CLASS_MULTI = 1,
	SNDRV_PCM_CLASS_MODEM = 2,
	SNDRV_PCM_CLASS_DIGITIZER = 3,
	SNDRV_PCM_CLASS_LAST = 3,
};

enum {
	SNDRV_PCM_IOCTL_HW_REFINE32 = 3260825872,
	SNDRV_PCM_IOCTL_HW_PARAMS32 = 3260825873,
	SNDRV_PCM_IOCTL_SW_PARAMS32 = 3228057875,
	SNDRV_PCM_IOCTL_STATUS_COMPAT32 = 2154578208,
	SNDRV_PCM_IOCTL_STATUS_EXT_COMPAT32 = 3228320036,
	SNDRV_PCM_IOCTL_DELAY32 = 2147762465,
	SNDRV_PCM_IOCTL_CHANNEL_INFO32 = 2148548914,
	SNDRV_PCM_IOCTL_REWIND32 = 1074020678,
	SNDRV_PCM_IOCTL_FORWARD32 = 1074020681,
	SNDRV_PCM_IOCTL_WRITEI_FRAMES32 = 1074544976,
	SNDRV_PCM_IOCTL_READI_FRAMES32 = 2148286801,
	SNDRV_PCM_IOCTL_WRITEN_FRAMES32 = 1074544978,
	SNDRV_PCM_IOCTL_READN_FRAMES32 = 2148286803,
	SNDRV_PCM_IOCTL_STATUS_COMPAT64 = 2155888928,
	SNDRV_PCM_IOCTL_STATUS_EXT_COMPAT64 = 3229630756,
};

enum {
	SNDRV_PCM_MMAP_OFFSET_DATA = 0,
	SNDRV_PCM_MMAP_OFFSET_STATUS_OLD = 2147483648,
	SNDRV_PCM_MMAP_OFFSET_CONTROL_OLD = 2164260864,
	SNDRV_PCM_MMAP_OFFSET_STATUS_NEW = 2181038080,
	SNDRV_PCM_MMAP_OFFSET_CONTROL_NEW = 2197815296,
	SNDRV_PCM_MMAP_OFFSET_STATUS = 2181038080,
	SNDRV_PCM_MMAP_OFFSET_CONTROL = 2197815296,
};

enum {
	SNDRV_PCM_STREAM_PLAYBACK = 0,
	SNDRV_PCM_STREAM_CAPTURE = 1,
	SNDRV_PCM_STREAM_LAST = 1,
};

enum {
	SNDRV_PCM_TSTAMP_NONE = 0,
	SNDRV_PCM_TSTAMP_ENABLE = 1,
	SNDRV_PCM_TSTAMP_LAST = 1,
};

enum {
	SNDRV_PCM_TSTAMP_TYPE_GETTIMEOFDAY = 0,
	SNDRV_PCM_TSTAMP_TYPE_MONOTONIC = 1,
	SNDRV_PCM_TSTAMP_TYPE_MONOTONIC_RAW = 2,
	SNDRV_PCM_TSTAMP_TYPE_LAST = 2,
};

enum {
	SNDRV_SEQ_IOCTL_CREATE_PORT32 = 3231994656,
	SNDRV_SEQ_IOCTL_DELETE_PORT32 = 1084511009,
	SNDRV_SEQ_IOCTL_GET_PORT_INFO32 = 3231994658,
	SNDRV_SEQ_IOCTL_SET_PORT_INFO32 = 1084511011,
	SNDRV_SEQ_IOCTL_QUERY_NEXT_PORT32 = 3231994706,
};

enum {
	SNDRV_TIMER_CLASS_NONE = -1,
	SNDRV_TIMER_CLASS_SLAVE = 0,
	SNDRV_TIMER_CLASS_GLOBAL = 1,
	SNDRV_TIMER_CLASS_CARD = 2,
	SNDRV_TIMER_CLASS_PCM = 3,
	SNDRV_TIMER_CLASS_LAST = 3,
};

enum {
	SNDRV_TIMER_EVENT_RESOLUTION = 0,
	SNDRV_TIMER_EVENT_TICK = 1,
	SNDRV_TIMER_EVENT_START = 2,
	SNDRV_TIMER_EVENT_STOP = 3,
	SNDRV_TIMER_EVENT_CONTINUE = 4,
	SNDRV_TIMER_EVENT_PAUSE = 5,
	SNDRV_TIMER_EVENT_EARLY = 6,
	SNDRV_TIMER_EVENT_SUSPEND = 7,
	SNDRV_TIMER_EVENT_RESUME = 8,
	SNDRV_TIMER_EVENT_MSTART = 12,
	SNDRV_TIMER_EVENT_MSTOP = 13,
	SNDRV_TIMER_EVENT_MCONTINUE = 14,
	SNDRV_TIMER_EVENT_MPAUSE = 15,
	SNDRV_TIMER_EVENT_MSUSPEND = 17,
	SNDRV_TIMER_EVENT_MRESUME = 18,
};

enum {
	SNDRV_TIMER_IOCTL_GPARAMS32 = 1077695492,
	SNDRV_TIMER_IOCTL_INFO32 = 2162185233,
	SNDRV_TIMER_IOCTL_STATUS_COMPAT32 = 1079530516,
	SNDRV_TIMER_IOCTL_STATUS_COMPAT64 = 1080054804,
};

enum {
	SNDRV_TIMER_IOCTL_START_OLD = 21536,
	SNDRV_TIMER_IOCTL_STOP_OLD = 21537,
	SNDRV_TIMER_IOCTL_CONTINUE_OLD = 21538,
	SNDRV_TIMER_IOCTL_PAUSE_OLD = 21539,
};

enum {
	SNDRV_TIMER_SCLASS_NONE = 0,
	SNDRV_TIMER_SCLASS_APPLICATION = 1,
	SNDRV_TIMER_SCLASS_SEQUENCER = 2,
	SNDRV_TIMER_SCLASS_OSS_SEQUENCER = 3,
	SNDRV_TIMER_SCLASS_LAST = 3,
};

enum {
	SND_CTL_SUBDEV_PCM = 0,
	SND_CTL_SUBDEV_RAWMIDI = 1,
	SND_CTL_SUBDEV_ITEMS = 2,
};

enum {
	SND_INTEL_DSP_DRIVER_ANY = 0,
	SND_INTEL_DSP_DRIVER_LEGACY = 1,
	SND_INTEL_DSP_DRIVER_SST = 2,
	SND_INTEL_DSP_DRIVER_SOF = 3,
	SND_INTEL_DSP_DRIVER_AVS = 4,
	SND_INTEL_DSP_DRIVER_LAST = 4,
};

enum {
	SNR_PCI_UNCORE_M2M = 0,
	SNR_PCI_UNCORE_PCIE3 = 1,
};

enum {
	SNR_QAT_PMON_ID = 0,
	SNR_CBDMA_DMI_PMON_ID = 1,
	SNR_NIS_PMON_ID = 2,
	SNR_DLB_PMON_ID = 3,
	SNR_PCIE_GEN3_PMON_ID = 4,
};

enum {
	SOCK_WAKE_IO = 0,
	SOCK_WAKE_WAITD = 1,
	SOCK_WAKE_SPACE = 2,
	SOCK_WAKE_URG = 3,
};

enum {
	SOF_TIMESTAMPING_TX_HARDWARE = 1,
	SOF_TIMESTAMPING_TX_SOFTWARE = 2,
	SOF_TIMESTAMPING_RX_HARDWARE = 4,
	SOF_TIMESTAMPING_RX_SOFTWARE = 8,
	SOF_TIMESTAMPING_SOFTWARE = 16,
	SOF_TIMESTAMPING_SYS_HARDWARE = 32,
	SOF_TIMESTAMPING_RAW_HARDWARE = 64,
	SOF_TIMESTAMPING_OPT_ID = 128,
	SOF_TIMESTAMPING_TX_SCHED = 256,
	SOF_TIMESTAMPING_TX_ACK = 512,
	SOF_TIMESTAMPING_OPT_CMSG = 1024,
	SOF_TIMESTAMPING_OPT_TSONLY = 2048,
	SOF_TIMESTAMPING_OPT_STATS = 4096,
	SOF_TIMESTAMPING_OPT_PKTINFO = 8192,
	SOF_TIMESTAMPING_OPT_TX_SWHW = 16384,
	SOF_TIMESTAMPING_BIND_PHC = 32768,
	SOF_TIMESTAMPING_OPT_ID_TCP = 65536,
	SOF_TIMESTAMPING_OPT_RX_FILTER = 131072,
	SOF_TIMESTAMPING_LAST = 131072,
	SOF_TIMESTAMPING_MASK = 262143,
};

enum {
	SPI_BLIST_NOIUS = 1,
};

enum {
	SP_TASK_PENDING = 0,
	SP_NEED_VICTIM = 1,
	SP_VICTIM_REMAINS = 2,
};

enum {
	SR_DMAR_FECTL_REG = 0,
	SR_DMAR_FEDATA_REG = 1,
	SR_DMAR_FEADDR_REG = 2,
	SR_DMAR_FEUADDR_REG = 3,
	MAX_SR_DMAR_REGS = 4,
};

enum {
	START_TS = 0,
	NOW_TS = 1,
	DELTA_TS = 2,
	JUMP_PREDICATE = 3,
	DELTA_TARGET = 4,
	N_CS_GPR = 5,
};

enum {
	STAT_CTRL = 3712,
	STAT_LAST_IDX = 3716,
	STAT_LIST_ADDR_LO = 3720,
	STAT_LIST_ADDR_HI = 3724,
	STAT_TXA1_RIDX = 3728,
	STAT_TXS1_RIDX = 3730,
	STAT_TXA2_RIDX = 3732,
	STAT_TXS2_RIDX = 3734,
	STAT_TX_IDX_TH = 3736,
	STAT_PUT_IDX = 3740,
	STAT_FIFO_WP = 3744,
	STAT_FIFO_RP = 3748,
	STAT_FIFO_RSP = 3750,
	STAT_FIFO_LEVEL = 3752,
	STAT_FIFO_SHLVL = 3754,
	STAT_FIFO_WM = 3756,
	STAT_FIFO_ISR_WM = 3757,
	STAT_LEV_TIMER_INI = 3760,
	STAT_LEV_TIMER_CNT = 3764,
	STAT_LEV_TIMER_CTRL = 3768,
	STAT_LEV_TIMER_TEST = 3769,
	STAT_TX_TIMER_INI = 3776,
	STAT_TX_TIMER_CNT = 3780,
	STAT_TX_TIMER_CTRL = 3784,
	STAT_TX_TIMER_TEST = 3785,
	STAT_ISR_TIMER_INI = 3792,
	STAT_ISR_TIMER_CNT = 3796,
	STAT_ISR_TIMER_CTRL = 3800,
	STAT_ISR_TIMER_TEST = 3801,
};

enum {
	SUNRPC_PIPEFS_NFS_PRIO = 0,
	SUNRPC_PIPEFS_RPC_PRIO = 1,
};

enum {
	SVC_HANDSHAKE_TO = 5000,
};

enum {
	SVC_POOL_AUTO = -1,
	SVC_POOL_GLOBAL = 0,
	SVC_POOL_PERCPU = 1,
	SVC_POOL_PERNODE = 2,
};

enum {
	SWITCHTEC_GAS_MRPC_OFFSET = 0,
	SWITCHTEC_GAS_TOP_CFG_OFFSET = 4096,
	SWITCHTEC_GAS_SW_EVENT_OFFSET = 6144,
	SWITCHTEC_GAS_SYS_INFO_OFFSET = 8192,
	SWITCHTEC_GAS_FLASH_INFO_OFFSET = 8704,
	SWITCHTEC_GAS_PART_CFG_OFFSET = 16384,
	SWITCHTEC_GAS_NTB_OFFSET = 65536,
	SWITCHTEC_GAS_PFF_CSR_OFFSET = 1261568,
};

enum {
	SWITCHTEC_NTB_REG_INFO_OFFSET = 0,
	SWITCHTEC_NTB_REG_CTRL_OFFSET = 16384,
	SWITCHTEC_NTB_REG_DBMSG_OFFSET = 409600,
};

enum {
	SWMII_SPEED_10 = 0,
	SWMII_SPEED_100 = 1,
	SWMII_SPEED_1000 = 2,
	SWMII_DUPLEX_HALF = 0,
	SWMII_DUPLEX_FULL = 1,
};

enum {
	SWP_USED = 1,
	SWP_WRITEOK = 2,
	SWP_DISCARDABLE = 4,
	SWP_DISCARDING = 8,
	SWP_SOLIDSTATE = 16,
	SWP_CONTINUED = 32,
	SWP_BLKDEV = 64,
	SWP_ACTIVATED = 128,
	SWP_FS_OPS = 256,
	SWP_AREA_DISCARD = 512,
	SWP_PAGE_DISCARD = 1024,
	SWP_STABLE_WRITES = 2048,
	SWP_SYNCHRONOUS_IO = 4096,
};

enum {
	SYNAPTICS_INTERTOUCH_NOT_SET = -1,
	SYNAPTICS_INTERTOUCH_OFF = 0,
	SYNAPTICS_INTERTOUCH_ON = 1,
};

enum {
	TASKLET_STATE_SCHED = 0,
	TASKLET_STATE_RUN = 1,
};

enum {
	TASKSTATS_CMD_ATTR_UNSPEC = 0,
	TASKSTATS_CMD_ATTR_PID = 1,
	TASKSTATS_CMD_ATTR_TGID = 2,
	TASKSTATS_CMD_ATTR_REGISTER_CPUMASK = 3,
	TASKSTATS_CMD_ATTR_DEREGISTER_CPUMASK = 4,
	__TASKSTATS_CMD_ATTR_MAX = 5,
};

enum {
	TASKSTATS_CMD_UNSPEC = 0,
	TASKSTATS_CMD_GET = 1,
	TASKSTATS_CMD_NEW = 2,
	__TASKSTATS_CMD_MAX = 3,
};

enum {
	TASKSTATS_TYPE_UNSPEC = 0,
	TASKSTATS_TYPE_PID = 1,
	TASKSTATS_TYPE_TGID = 2,
	TASKSTATS_TYPE_STATS = 3,
	TASKSTATS_TYPE_AGGR_PID = 4,
	TASKSTATS_TYPE_AGGR_TGID = 5,
	TASKSTATS_TYPE_NULL = 6,
	__TASKSTATS_TYPE_MAX = 7,
};

enum {
	TASK_COMM_LEN = 16,
};

enum {
	TBMU_TEST_BMU_TX_CHK_AUTO_OFF = -2147483648,
	TBMU_TEST_BMU_TX_CHK_AUTO_ON = 1073741824,
	TBMU_TEST_HOME_ADD_PAD_FIX1_EN = 536870912,
	TBMU_TEST_HOME_ADD_PAD_FIX1_DIS = 268435456,
	TBMU_TEST_ROUTING_ADD_FIX_EN = 134217728,
	TBMU_TEST_ROUTING_ADD_FIX_DIS = 67108864,
	TBMU_TEST_HOME_ADD_FIX_EN = 33554432,
	TBMU_TEST_HOME_ADD_FIX_DIS = 16777216,
	TBMU_TEST_TEST_RSPTR_ON = 4194304,
	TBMU_TEST_TEST_RSPTR_OFF = 2097152,
	TBMU_TEST_TESTSTEP_RSPTR = 1048576,
	TBMU_TEST_TEST_RPTR_ON = 262144,
	TBMU_TEST_TEST_RPTR_OFF = 131072,
	TBMU_TEST_TESTSTEP_RPTR = 65536,
	TBMU_TEST_TEST_WSPTR_ON = 16384,
	TBMU_TEST_TEST_WSPTR_OFF = 8192,
	TBMU_TEST_TESTSTEP_WSPTR = 4096,
	TBMU_TEST_TEST_WPTR_ON = 1024,
	TBMU_TEST_TEST_WPTR_OFF = 512,
	TBMU_TEST_TESTSTEP_WPTR = 256,
	TBMU_TEST_TEST_REQ_NB_ON = 64,
	TBMU_TEST_TEST_REQ_NB_OFF = 32,
	TBMU_TEST_TESTSTEP_REQ_NB = 16,
	TBMU_TEST_TEST_DONE_IDX_ON = 4,
	TBMU_TEST_TEST_DONE_IDX_OFF = 2,
	TBMU_TEST_TESTSTEP_DONE_IDX = 1,
};

enum {
	TCA_ACT_UNSPEC = 0,
	TCA_ACT_KIND = 1,
	TCA_ACT_OPTIONS = 2,
	TCA_ACT_INDEX = 3,
	TCA_ACT_STATS = 4,
	TCA_ACT_PAD = 5,
	TCA_ACT_COOKIE = 6,
	TCA_ACT_FLAGS = 7,
	TCA_ACT_HW_STATS = 8,
	TCA_ACT_USED_HW_STATS = 9,
	TCA_ACT_IN_HW_COUNT = 10,
	__TCA_ACT_MAX = 11,
};

enum {
	TCA_CGROUP_UNSPEC = 0,
	TCA_CGROUP_ACT = 1,
	TCA_CGROUP_POLICE = 2,
	TCA_CGROUP_EMATCHES = 3,
	__TCA_CGROUP_MAX = 4,
};

enum {
	TCA_EMATCH_TREE_UNSPEC = 0,
	TCA_EMATCH_TREE_HDR = 1,
	TCA_EMATCH_TREE_LIST = 2,
	__TCA_EMATCH_TREE_MAX = 3,
};

enum {
	TCA_FLOWER_KEY_CT_FLAGS_NEW = 1,
	TCA_FLOWER_KEY_CT_FLAGS_ESTABLISHED = 2,
	TCA_FLOWER_KEY_CT_FLAGS_RELATED = 4,
	TCA_FLOWER_KEY_CT_FLAGS_TRACKED = 8,
	TCA_FLOWER_KEY_CT_FLAGS_INVALID = 16,
	TCA_FLOWER_KEY_CT_FLAGS_REPLY = 32,
	__TCA_FLOWER_KEY_CT_FLAGS_MAX = 33,
};

enum {
	TCA_FLOWER_KEY_FLAGS_IS_FRAGMENT = 1,
	TCA_FLOWER_KEY_FLAGS_FRAG_IS_FIRST = 2,
	TCA_FLOWER_KEY_FLAGS_TUNNEL_CSUM = 4,
	TCA_FLOWER_KEY_FLAGS_TUNNEL_DONT_FRAGMENT = 8,
	TCA_FLOWER_KEY_FLAGS_TUNNEL_OAM = 16,
	TCA_FLOWER_KEY_FLAGS_TUNNEL_CRIT_OPT = 32,
	__TCA_FLOWER_KEY_FLAGS_MAX = 33,
};

enum {
	TCA_ROOT_UNSPEC = 0,
	TCA_ROOT_TAB = 1,
	TCA_ROOT_FLAGS = 2,
	TCA_ROOT_COUNT = 3,
	TCA_ROOT_TIME_DELTA = 4,
	TCA_ROOT_EXT_WARN_MSG = 5,
	__TCA_ROOT_MAX = 6,
};

enum {
	TCA_STAB_UNSPEC = 0,
	TCA_STAB_BASE = 1,
	TCA_STAB_DATA = 2,
	__TCA_STAB_MAX = 3,
};

enum {
	TCA_STATS_UNSPEC = 0,
	TCA_STATS_BASIC = 1,
	TCA_STATS_RATE_EST = 2,
	TCA_STATS_QUEUE = 3,
	TCA_STATS_APP = 4,
	TCA_STATS_RATE_EST64 = 5,
	TCA_STATS_PAD = 6,
	TCA_STATS_BASIC_HW = 7,
	TCA_STATS_PKT64 = 8,
	__TCA_STATS_MAX = 9,
};

enum {
	TCA_UNSPEC = 0,
	TCA_KIND = 1,
	TCA_OPTIONS = 2,
	TCA_STATS = 3,
	TCA_XSTATS = 4,
	TCA_RATE = 5,
	TCA_FCNT = 6,
	TCA_STATS2 = 7,
	TCA_STAB = 8,
	TCA_PAD = 9,
	TCA_DUMP_INVISIBLE = 10,
	TCA_CHAIN = 11,
	TCA_HW_OFFLOAD = 12,
	TCA_INGRESS_BLOCK = 13,
	TCA_EGRESS_BLOCK = 14,
	TCA_DUMP_FLAGS = 15,
	TCA_EXT_WARN_MSG = 16,
	__TCA_MAX = 17,
};

enum {
	TCPF_ESTABLISHED = 2,
	TCPF_SYN_SENT = 4,
	TCPF_SYN_RECV = 8,
	TCPF_FIN_WAIT1 = 16,
	TCPF_FIN_WAIT2 = 32,
	TCPF_TIME_WAIT = 64,
	TCPF_CLOSE = 128,
	TCPF_CLOSE_WAIT = 256,
	TCPF_LAST_ACK = 512,
	TCPF_LISTEN = 1024,
	TCPF_CLOSING = 2048,
	TCPF_NEW_SYN_RECV = 4096,
	TCPF_BOUND_INACTIVE = 8192,
};

enum {
	TCP_BPF_BASE = 0,
	TCP_BPF_TX = 1,
	TCP_BPF_RX = 2,
	TCP_BPF_TXRX = 3,
	TCP_BPF_NUM_CFGS = 4,
};

enum {
	TCP_BPF_IPV4 = 0,
	TCP_BPF_IPV6 = 1,
	TCP_BPF_NUM_PROTS = 2,
};

enum {
	TCP_BPF_IW = 1001,
	TCP_BPF_SNDCWND_CLAMP = 1002,
	TCP_BPF_DELACK_MAX = 1003,
	TCP_BPF_RTO_MIN = 1004,
	TCP_BPF_SYN = 1005,
	TCP_BPF_SYN_IP = 1006,
	TCP_BPF_SYN_MAC = 1007,
	TCP_BPF_SOCK_OPS_CB_FLAGS = 1008,
};

enum {
	TCP_CMSG_INQ = 1,
	TCP_CMSG_TS = 2,
};

enum {
	TCP_ESTABLISHED = 1,
	TCP_SYN_SENT = 2,
	TCP_SYN_RECV = 3,
	TCP_FIN_WAIT1 = 4,
	TCP_FIN_WAIT2 = 5,
	TCP_TIME_WAIT = 6,
	TCP_CLOSE = 7,
	TCP_CLOSE_WAIT = 8,
	TCP_LAST_ACK = 9,
	TCP_LISTEN = 10,
	TCP_CLOSING = 11,
	TCP_NEW_SYN_RECV = 12,
	TCP_BOUND_INACTIVE = 13,
	TCP_MAX_STATES = 14,
};

enum {
	TCP_FLAG_CWR = 32768,
	TCP_FLAG_ECE = 16384,
	TCP_FLAG_URG = 8192,
	TCP_FLAG_ACK = 4096,
	TCP_FLAG_PSH = 2048,
	TCP_FLAG_RST = 1024,
	TCP_FLAG_SYN = 512,
	TCP_FLAG_FIN = 256,
	TCP_RESERVED_BITS = 15,
	TCP_DATA_OFFSET = 240,
};

enum {
	TCP_METRICS_ATTR_UNSPEC = 0,
	TCP_METRICS_ATTR_ADDR_IPV4 = 1,
	TCP_METRICS_ATTR_ADDR_IPV6 = 2,
	TCP_METRICS_ATTR_AGE = 3,
	TCP_METRICS_ATTR_TW_TSVAL = 4,
	TCP_METRICS_ATTR_TW_TS_STAMP = 5,
	TCP_METRICS_ATTR_VALS = 6,
	TCP_METRICS_ATTR_FOPEN_MSS = 7,
	TCP_METRICS_ATTR_FOPEN_SYN_DROPS = 8,
	TCP_METRICS_ATTR_FOPEN_SYN_DROP_TS = 9,
	TCP_METRICS_ATTR_FOPEN_COOKIE = 10,
	TCP_METRICS_ATTR_SADDR_IPV4 = 11,
	TCP_METRICS_ATTR_SADDR_IPV6 = 12,
	TCP_METRICS_ATTR_PAD = 13,
	__TCP_METRICS_ATTR_MAX = 14,
};

enum {
	TCP_METRICS_CMD_UNSPEC = 0,
	TCP_METRICS_CMD_GET = 1,
	TCP_METRICS_CMD_DEL = 2,
	__TCP_METRICS_CMD_MAX = 3,
};

enum {
	TCP_MIB_NUM = 0,
	TCP_MIB_RTOALGORITHM = 1,
	TCP_MIB_RTOMIN = 2,
	TCP_MIB_RTOMAX = 3,
	TCP_MIB_MAXCONN = 4,
	TCP_MIB_ACTIVEOPENS = 5,
	TCP_MIB_PASSIVEOPENS = 6,
	TCP_MIB_ATTEMPTFAILS = 7,
	TCP_MIB_ESTABRESETS = 8,
	TCP_MIB_CURRESTAB = 9,
	TCP_MIB_INSEGS = 10,
	TCP_MIB_OUTSEGS = 11,
	TCP_MIB_RETRANSSEGS = 12,
	TCP_MIB_INERRS = 13,
	TCP_MIB_OUTRSTS = 14,
	TCP_MIB_CSUMERRORS = 15,
	__TCP_MIB_MAX = 16,
};

enum {
	TCP_NLA_PAD = 0,
	TCP_NLA_BUSY = 1,
	TCP_NLA_RWND_LIMITED = 2,
	TCP_NLA_SNDBUF_LIMITED = 3,
	TCP_NLA_DATA_SEGS_OUT = 4,
	TCP_NLA_TOTAL_RETRANS = 5,
	TCP_NLA_PACING_RATE = 6,
	TCP_NLA_DELIVERY_RATE = 7,
	TCP_NLA_SND_CWND = 8,
	TCP_NLA_REORDERING = 9,
	TCP_NLA_MIN_RTT = 10,
	TCP_NLA_RECUR_RETRANS = 11,
	TCP_NLA_DELIVERY_RATE_APP_LMT = 12,
	TCP_NLA_SNDQ_SIZE = 13,
	TCP_NLA_CA_STATE = 14,
	TCP_NLA_SND_SSTHRESH = 15,
	TCP_NLA_DELIVERED = 16,
	TCP_NLA_DELIVERED_CE = 17,
	TCP_NLA_BYTES_SENT = 18,
	TCP_NLA_BYTES_RETRANS = 19,
	TCP_NLA_DSACK_DUPS = 20,
	TCP_NLA_REORD_SEEN = 21,
	TCP_NLA_SRTT = 22,
	TCP_NLA_TIMEOUT_REHASH = 23,
	TCP_NLA_BYTES_NOTSENT = 24,
	TCP_NLA_EDT = 25,
	TCP_NLA_TTL = 26,
	TCP_NLA_REHASH = 27,
};

enum {
	TCP_NO_QUEUE = 0,
	TCP_RECV_QUEUE = 1,
	TCP_SEND_QUEUE = 2,
	TCP_QUEUES_NR = 3,
};

enum {
	TEST_NONE = 0,
	TEST_CORE = 1,
	TEST_CPUS = 2,
	TEST_PLATFORM = 3,
	TEST_DEVICES = 4,
	TEST_FREEZER = 5,
	__TEST_AFTER_LAST = 6,
};

enum {
	TIM_START = 4,
	TIM_STOP = 2,
	TIM_CLR_IRQ = 1,
};

enum {
	TKIP_DECRYPT_OK = 0,
	TKIP_DECRYPT_NO_EXT_IV = -1,
	TKIP_DECRYPT_INVALID_KEYIDX = -2,
	TKIP_DECRYPT_REPLAY = -3,
};

enum {
	TLS_ALERT_DESC_CLOSE_NOTIFY = 0,
	TLS_ALERT_DESC_UNEXPECTED_MESSAGE = 10,
	TLS_ALERT_DESC_BAD_RECORD_MAC = 20,
	TLS_ALERT_DESC_RECORD_OVERFLOW = 22,
	TLS_ALERT_DESC_HANDSHAKE_FAILURE = 40,
	TLS_ALERT_DESC_BAD_CERTIFICATE = 42,
	TLS_ALERT_DESC_UNSUPPORTED_CERTIFICATE = 43,
	TLS_ALERT_DESC_CERTIFICATE_REVOKED = 44,
	TLS_ALERT_DESC_CERTIFICATE_EXPIRED = 45,
	TLS_ALERT_DESC_CERTIFICATE_UNKNOWN = 46,
	TLS_ALERT_DESC_ILLEGAL_PARAMETER = 47,
	TLS_ALERT_DESC_UNKNOWN_CA = 48,
	TLS_ALERT_DESC_ACCESS_DENIED = 49,
	TLS_ALERT_DESC_DECODE_ERROR = 50,
	TLS_ALERT_DESC_DECRYPT_ERROR = 51,
	TLS_ALERT_DESC_TOO_MANY_CIDS_REQUESTED = 52,
	TLS_ALERT_DESC_PROTOCOL_VERSION = 70,
	TLS_ALERT_DESC_INSUFFICIENT_SECURITY = 71,
	TLS_ALERT_DESC_INTERNAL_ERROR = 80,
	TLS_ALERT_DESC_INAPPROPRIATE_FALLBACK = 86,
	TLS_ALERT_DESC_USER_CANCELED = 90,
	TLS_ALERT_DESC_MISSING_EXTENSION = 109,
	TLS_ALERT_DESC_UNSUPPORTED_EXTENSION = 110,
	TLS_ALERT_DESC_UNRECOGNIZED_NAME = 112,
	TLS_ALERT_DESC_BAD_CERTIFICATE_STATUS_RESPONSE = 113,
	TLS_ALERT_DESC_UNKNOWN_PSK_IDENTITY = 115,
	TLS_ALERT_DESC_CERTIFICATE_REQUIRED = 116,
	TLS_ALERT_DESC_NO_APPLICATION_PROTOCOL = 120,
};

enum {
	TLS_ALERT_LEVEL_WARNING = 1,
	TLS_ALERT_LEVEL_FATAL = 2,
};

enum {
	TLS_NO_KEYRING = 0,
	TLS_NO_PEERID = 0,
	TLS_NO_CERT = 0,
	TLS_NO_PRIVKEY = 0,
};

enum {
	TLS_RECORD_TYPE_CHANGE_CIPHER_SPEC = 20,
	TLS_RECORD_TYPE_ALERT = 21,
	TLS_RECORD_TYPE_HANDSHAKE = 22,
	TLS_RECORD_TYPE_DATA = 23,
	TLS_RECORD_TYPE_HEARTBEAT = 24,
	TLS_RECORD_TYPE_TLS12_CID = 25,
	TLS_RECORD_TYPE_ACK = 26,
};

enum {
	TOO_MANY_CLOSE = -1,
	TOO_MANY_OPEN = -2,
	MISSING_QUOTE = -3,
};

enum {
	TP_ERR_FILE_NOT_FOUND = 0,
	TP_ERR_NO_REGULAR_FILE = 1,
	TP_ERR_BAD_REFCNT = 2,
	TP_ERR_REFCNT_OPEN_BRACE = 3,
	TP_ERR_BAD_REFCNT_SUFFIX = 4,
	TP_ERR_BAD_UPROBE_OFFS = 5,
	TP_ERR_BAD_MAXACT_TYPE = 6,
	TP_ERR_BAD_MAXACT = 7,
	TP_ERR_MAXACT_TOO_BIG = 8,
	TP_ERR_BAD_PROBE_ADDR = 9,
	TP_ERR_NON_UNIQ_SYMBOL = 10,
	TP_ERR_BAD_RETPROBE = 11,
	TP_ERR_NO_TRACEPOINT = 12,
	TP_ERR_BAD_TP_NAME = 13,
	TP_ERR_BAD_ADDR_SUFFIX = 14,
	TP_ERR_NO_GROUP_NAME = 15,
	TP_ERR_GROUP_TOO_LONG = 16,
	TP_ERR_BAD_GROUP_NAME = 17,
	TP_ERR_NO_EVENT_NAME = 18,
	TP_ERR_EVENT_TOO_LONG = 19,
	TP_ERR_BAD_EVENT_NAME = 20,
	TP_ERR_EVENT_EXIST = 21,
	TP_ERR_RETVAL_ON_PROBE = 22,
	TP_ERR_NO_RETVAL = 23,
	TP_ERR_BAD_STACK_NUM = 24,
	TP_ERR_BAD_ARG_NUM = 25,
	TP_ERR_BAD_VAR = 26,
	TP_ERR_BAD_REG_NAME = 27,
	TP_ERR_BAD_MEM_ADDR = 28,
	TP_ERR_BAD_IMM = 29,
	TP_ERR_IMMSTR_NO_CLOSE = 30,
	TP_ERR_FILE_ON_KPROBE = 31,
	TP_ERR_BAD_FILE_OFFS = 32,
	TP_ERR_SYM_ON_UPROBE = 33,
	TP_ERR_TOO_MANY_OPS = 34,
	TP_ERR_DEREF_NEED_BRACE = 35,
	TP_ERR_BAD_DEREF_OFFS = 36,
	TP_ERR_DEREF_OPEN_BRACE = 37,
	TP_ERR_COMM_CANT_DEREF = 38,
	TP_ERR_BAD_FETCH_ARG = 39,
	TP_ERR_ARRAY_NO_CLOSE = 40,
	TP_ERR_BAD_ARRAY_SUFFIX = 41,
	TP_ERR_BAD_ARRAY_NUM = 42,
	TP_ERR_ARRAY_TOO_BIG = 43,
	TP_ERR_BAD_TYPE = 44,
	TP_ERR_BAD_STRING = 45,
	TP_ERR_BAD_SYMSTRING = 46,
	TP_ERR_BAD_BITFIELD = 47,
	TP_ERR_ARG_NAME_TOO_LONG = 48,
	TP_ERR_NO_ARG_NAME = 49,
	TP_ERR_BAD_ARG_NAME = 50,
	TP_ERR_USED_ARG_NAME = 51,
	TP_ERR_ARG_TOO_LONG = 52,
	TP_ERR_NO_ARG_BODY = 53,
	TP_ERR_BAD_INSN_BNDRY = 54,
	TP_ERR_FAIL_REG_PROBE = 55,
	TP_ERR_DIFF_PROBE_TYPE = 56,
	TP_ERR_DIFF_ARG_TYPE = 57,
	TP_ERR_SAME_PROBE = 58,
	TP_ERR_NO_EVENT_INFO = 59,
	TP_ERR_BAD_ATTACH_EVENT = 60,
	TP_ERR_BAD_ATTACH_ARG = 61,
	TP_ERR_NO_EP_FILTER = 62,
	TP_ERR_NOSUP_BTFARG = 63,
	TP_ERR_NO_BTFARG = 64,
	TP_ERR_NO_BTF_ENTRY = 65,
	TP_ERR_BAD_VAR_ARGS = 66,
	TP_ERR_NOFENTRY_ARGS = 67,
	TP_ERR_DOUBLE_ARGS = 68,
	TP_ERR_ARGS_2LONG = 69,
	TP_ERR_ARGIDX_2BIG = 70,
	TP_ERR_NO_PTR_STRCT = 71,
	TP_ERR_NOSUP_DAT_ARG = 72,
	TP_ERR_BAD_HYPHEN = 73,
	TP_ERR_NO_BTF_FIELD = 74,
	TP_ERR_BAD_BTF_TID = 75,
	TP_ERR_BAD_TYPE4STR = 76,
	TP_ERR_NEED_STRING_TYPE = 77,
	TP_ERR_TOO_MANY_EARGS = 78,
};

enum {
	TRACEFS_EVENT_INODE = 2,
	TRACEFS_GID_PERM_SET = 4,
	TRACEFS_UID_PERM_SET = 8,
	TRACEFS_INSTANCE_INODE = 16,
};

enum {
	TRACE_ARRAY_FL_GLOBAL = 1,
	TRACE_ARRAY_FL_BOOT = 2,
	TRACE_ARRAY_FL_MOD_INIT = 4,
};

enum {
	TRACE_EVENT_FL_CAP_ANY = 1,
	TRACE_EVENT_FL_NO_SET_FILTER = 2,
	TRACE_EVENT_FL_IGNORE_ENABLE = 4,
	TRACE_EVENT_FL_TRACEPOINT = 8,
	TRACE_EVENT_FL_DYNAMIC = 16,
	TRACE_EVENT_FL_KPROBE = 32,
	TRACE_EVENT_FL_UPROBE = 64,
	TRACE_EVENT_FL_EPROBE = 128,
	TRACE_EVENT_FL_FPROBE = 256,
	TRACE_EVENT_FL_CUSTOM = 512,
	TRACE_EVENT_FL_TEST_STR = 1024,
};

enum {
	TRACE_EVENT_FL_CAP_ANY_BIT = 0,
	TRACE_EVENT_FL_NO_SET_FILTER_BIT = 1,
	TRACE_EVENT_FL_IGNORE_ENABLE_BIT = 2,
	TRACE_EVENT_FL_TRACEPOINT_BIT = 3,
	TRACE_EVENT_FL_DYNAMIC_BIT = 4,
	TRACE_EVENT_FL_KPROBE_BIT = 5,
	TRACE_EVENT_FL_UPROBE_BIT = 6,
	TRACE_EVENT_FL_EPROBE_BIT = 7,
	TRACE_EVENT_FL_FPROBE_BIT = 8,
	TRACE_EVENT_FL_CUSTOM_BIT = 9,
	TRACE_EVENT_FL_TEST_STR_BIT = 10,
};

enum {
	TRACE_NOP_OPT_ACCEPT = 1,
	TRACE_NOP_OPT_REFUSE = 2,
};

enum {
	TRACE_PIDS = 1,
	TRACE_NO_PIDS = 2,
};

enum {
	TRACE_SIGNAL_DELIVERED = 0,
	TRACE_SIGNAL_IGNORED = 1,
	TRACE_SIGNAL_ALREADY_PENDING = 2,
	TRACE_SIGNAL_OVERFLOW_FAIL = 3,
	TRACE_SIGNAL_LOSE_INFO = 4,
};

enum {
	TST_FRC_DPERR_MR = 128,
	TST_FRC_DPERR_MW = 64,
	TST_FRC_DPERR_TR = 32,
	TST_FRC_DPERR_TW = 16,
	TST_FRC_APERR_M = 8,
	TST_FRC_APERR_T = 4,
	TST_CFG_WRITE_ON = 2,
	TST_CFG_WRITE_OFF = 1,
};

enum {
	TXA_ENA_FSYNC = 128,
	TXA_DIS_FSYNC = 64,
	TXA_ENA_ALLOC = 32,
	TXA_DIS_ALLOC = 16,
	TXA_START_RC = 8,
	TXA_STOP_RC = 4,
	TXA_ENA_ARB = 2,
	TXA_DIS_ARB = 1,
};

enum {
	TXA_ITI_INI = 512,
	TXA_ITI_VAL = 516,
	TXA_LIM_INI = 520,
	TXA_LIM_VAL = 524,
	TXA_CTRL = 528,
	TXA_TEST = 529,
	TXA_STAT = 530,
	RSS_KEY = 544,
	RSS_CFG = 584,
};

enum {
	TX_DYN_WM_ENA = 3,
};

enum {
	TX_GMF_EA = 3392,
	TX_GMF_AE_THR = 3396,
	TX_GMF_CTRL_T = 3400,
	TX_GMF_WP = 3424,
	TX_GMF_WSP = 3428,
	TX_GMF_WLEV = 3432,
	TX_GMF_RP = 3440,
	TX_GMF_RSTP = 3444,
	TX_GMF_RLEV = 3448,
	ECU_AE_THR = 112,
	ECU_TXFF_LEV = 416,
	ECU_JUMBO_WM = 128,
};

enum {
	TX_STFW_DIS = -2147483648,
	TX_STFW_ENA = 1073741824,
	TX_VLAN_TAG_ON = 33554432,
	TX_VLAN_TAG_OFF = 16777216,
	TX_PCI_JUM_ENA = 8388608,
	TX_PCI_JUM_DIS = 4194304,
	GMF_WSP_TST_ON = 262144,
	GMF_WSP_TST_OFF = 131072,
	GMF_WSP_STEP = 65536,
	GMF_CLI_TX_FU = 64,
	GMF_CLI_TX_FC = 32,
	GMF_CLI_TX_PE = 16,
};

enum {
	UDPTCP = 1,
	CALSUM = 2,
	WR_SUM = 4,
	INIT_SUM = 8,
	LOCK_SUM = 16,
	INS_VLAN = 32,
	EOP = 128,
};

enum {
	UDP_BPF_IPV4 = 0,
	UDP_BPF_IPV6 = 1,
	UDP_BPF_NUM_PROTS = 2,
};

enum {
	UDP_FLAGS_CORK = 0,
	UDP_FLAGS_NO_CHECK6_TX = 1,
	UDP_FLAGS_NO_CHECK6_RX = 2,
	UDP_FLAGS_GRO_ENABLED = 3,
	UDP_FLAGS_ACCEPT_FRAGLIST = 4,
	UDP_FLAGS_ACCEPT_L4 = 5,
	UDP_FLAGS_ENCAP_ENABLED = 6,
	UDP_FLAGS_UDPLITE_SEND_CC = 7,
	UDP_FLAGS_UDPLITE_RECV_CC = 8,
};

enum {
	UDP_MIB_NUM = 0,
	UDP_MIB_INDATAGRAMS = 1,
	UDP_MIB_NOPORTS = 2,
	UDP_MIB_INERRORS = 3,
	UDP_MIB_OUTDATAGRAMS = 4,
	UDP_MIB_RCVBUFERRORS = 5,
	UDP_MIB_SNDBUFERRORS = 6,
	UDP_MIB_CSUMERRORS = 7,
	UDP_MIB_IGNOREDMULTI = 8,
	UDP_MIB_MEMERRORS = 9,
	__UDP_MIB_MAX = 10,
};

enum {
	UNAME26 = 131072,
	ADDR_NO_RANDOMIZE = 262144,
	FDPIC_FUNCPTRS = 524288,
	MMAP_PAGE_ZERO = 1048576,
	ADDR_COMPAT_LAYOUT = 2097152,
	READ_IMPLIES_EXEC = 4194304,
	ADDR_LIMIT_32BIT = 8388608,
	SHORT_INODE = 16777216,
	WHOLE_SECONDS = 33554432,
	STICKY_TIMEOUTS = 67108864,
	ADDR_LIMIT_3GB = 134217728,
};

enum {
	UNCORE_TYPE_DF = 0,
	UNCORE_TYPE_L3 = 1,
	UNCORE_TYPE_UMC = 2,
	UNCORE_TYPE_MAX = 3,
};

enum {
	UNDEFINED_CAPABLE = 0,
	SYSTEM_INTEL_MSR_CAPABLE = 1,
	SYSTEM_AMD_MSR_CAPABLE = 2,
	SYSTEM_IO_CAPABLE = 3,
};

enum {
	US_FL_SINGLE_LUN = 1,
	US_FL_NEED_OVERRIDE = 2,
	US_FL_SCM_MULT_TARG = 4,
	US_FL_FIX_INQUIRY = 8,
	US_FL_FIX_CAPACITY = 16,
	US_FL_IGNORE_RESIDUE = 32,
	US_FL_BULK32 = 64,
	US_FL_NOT_LOCKABLE = 128,
	US_FL_GO_SLOW = 256,
	US_FL_NO_WP_DETECT = 512,
	US_FL_MAX_SECTORS_64 = 1024,
	US_FL_IGNORE_DEVICE = 2048,
	US_FL_CAPACITY_HEURISTICS = 4096,
	US_FL_MAX_SECTORS_MIN = 8192,
	US_FL_BULK_IGNORE_TAG = 16384,
	US_FL_SANE_SENSE = 32768,
	US_FL_CAPACITY_OK = 65536,
	US_FL_BAD_SENSE = 131072,
	US_FL_NO_READ_DISC_INFO = 262144,
	US_FL_NO_READ_CAPACITY_16 = 524288,
	US_FL_INITIAL_READ10 = 1048576,
	US_FL_WRITE_CACHE = 2097152,
	US_FL_NEEDS_CAP16 = 4194304,
	US_FL_IGNORE_UAS = 8388608,
	US_FL_BROKEN_FUA = 16777216,
	US_FL_NO_ATA_1X = 33554432,
	US_FL_NO_REPORT_OPCODES = 67108864,
	US_FL_MAX_SECTORS_240 = 134217728,
	US_FL_NO_REPORT_LUNS = 268435456,
	US_FL_ALWAYS_SYNC = 536870912,
	US_FL_NO_SAME = 1073741824,
	US_FL_SENSE_AFTER_SYNC = 2147483648,
};

enum {
	VERBOSE_STATUS = 1,
};

enum {
	VIA_STRFILT_CNT_SHIFT = 16,
	VIA_STRFILT_FAIL = 32768,
	VIA_STRFILT_ENABLE = 16384,
	VIA_RAWBITS_ENABLE = 8192,
	VIA_RNG_ENABLE = 64,
	VIA_NOISESRC1 = 256,
	VIA_NOISESRC2 = 512,
	VIA_XSTORE_CNT_MASK = 15,
	VIA_RNG_CHUNK_8 = 0,
	VIA_RNG_CHUNK_4 = 1,
	VIA_RNG_CHUNK_4_MASK = 4294967295,
	VIA_RNG_CHUNK_2 = 2,
	VIA_RNG_CHUNK_2_MASK = 65535,
	VIA_RNG_CHUNK_1 = 3,
	VIA_RNG_CHUNK_1_MASK = 255,
};

enum {
	VLV_IOSF_SB_BUNIT = 0,
	VLV_IOSF_SB_CCK = 1,
	VLV_IOSF_SB_CCU = 2,
	VLV_IOSF_SB_DPIO = 3,
	VLV_IOSF_SB_FLISDSI = 4,
	VLV_IOSF_SB_GPIO = 5,
	VLV_IOSF_SB_NC = 6,
	VLV_IOSF_SB_PUNIT = 7,
};

enum {
	VP_MSIX_CONFIG_VECTOR = 0,
	VP_MSIX_VQ_VECTOR = 1,
};

enum {
	VTIME_PER_SEC_SHIFT = 37ULL,
	VTIME_PER_SEC = 137438953472ULL,
	VTIME_PER_USEC = 137438ULL,
	VTIME_PER_NSEC = 137ULL,
	VRATE_MIN_PPM = 10000ULL,
	VRATE_MAX_PPM = 100000000ULL,
	VRATE_MIN = 1374ULL,
	VRATE_CLAMP_ADJ_PCT = 4ULL,
	AUTOP_CYCLE_NSEC = 10000000000ULL,
};

enum {
	WALK_TRAILING = 1,
	WALK_MORE = 2,
	WALK_NOFOLLOW = 4,
};

enum {
	WMI_READ_TAKES_NO_ARGS = 0,
	WMI_GUID_DUPLICATED = 1,
	WMI_NO_EVENT_DATA = 2,
};

enum {
	WOL_CTL_LINK_CHG_OCC = 32768,
	WOL_CTL_MAGIC_PKT_OCC = 16384,
	WOL_CTL_PATTERN_OCC = 8192,
	WOL_CTL_CLEAR_RESULT = 4096,
	WOL_CTL_ENA_PME_ON_LINK_CHG = 2048,
	WOL_CTL_DIS_PME_ON_LINK_CHG = 1024,
	WOL_CTL_ENA_PME_ON_MAGIC_PKT = 512,
	WOL_CTL_DIS_PME_ON_MAGIC_PKT = 256,
	WOL_CTL_ENA_PME_ON_PATTERN = 128,
	WOL_CTL_DIS_PME_ON_PATTERN = 64,
	WOL_CTL_ENA_LINK_CHG_UNIT = 32,
	WOL_CTL_DIS_LINK_CHG_UNIT = 16,
	WOL_CTL_ENA_MAGIC_PKT_UNIT = 8,
	WOL_CTL_DIS_MAGIC_PKT_UNIT = 4,
	WOL_CTL_ENA_PATTERN_UNIT = 2,
	WOL_CTL_DIS_PATTERN_UNIT = 1,
};

enum {
	X86_BR_NONE = 0,
	X86_BR_USER = 1,
	X86_BR_KERNEL = 2,
	X86_BR_CALL = 4,
	X86_BR_RET = 8,
	X86_BR_SYSCALL = 16,
	X86_BR_SYSRET = 32,
	X86_BR_INT = 64,
	X86_BR_IRET = 128,
	X86_BR_JCC = 256,
	X86_BR_JMP = 512,
	X86_BR_IRQ = 1024,
	X86_BR_IND_CALL = 2048,
	X86_BR_ABORT = 4096,
	X86_BR_IN_TX = 8192,
	X86_BR_NO_TX = 16384,
	X86_BR_ZERO_CALL = 32768,
	X86_BR_CALL_STACK = 65536,
	X86_BR_IND_JMP = 131072,
	X86_BR_TYPE_SAVE = 262144,
};

enum {
	X86_IRQ_ALLOC_LEGACY = 1,
};

enum {
	X86_PERF_KFREE_SHARED = 0,
	X86_PERF_KFREE_EXCL = 1,
	X86_PERF_KFREE_MAX = 2,
};

enum {
	XA_CHECK_SCHED = 4096,
};

enum {
	XDP_ATTACHED_NONE = 0,
	XDP_ATTACHED_DRV = 1,
	XDP_ATTACHED_SKB = 2,
	XDP_ATTACHED_HW = 3,
	XDP_ATTACHED_MULTI = 4,
};

enum {
	XFRM_DEV_OFFLOAD_IN = 1,
	XFRM_DEV_OFFLOAD_OUT = 2,
	XFRM_DEV_OFFLOAD_FWD = 3,
};

enum {
	XFRM_DEV_OFFLOAD_UNSPECIFIED = 0,
	XFRM_DEV_OFFLOAD_CRYPTO = 1,
	XFRM_DEV_OFFLOAD_PACKET = 2,
};

enum {
	XFRM_LOOKUP_ICMP = 1,
	XFRM_LOOKUP_QUEUE = 2,
	XFRM_LOOKUP_KEEP_DST_REF = 4,
};

enum {
	XFRM_MODE_FLAG_TUNNEL = 1,
};

enum {
	XFRM_MSG_BASE = 16,
	XFRM_MSG_NEWSA = 16,
	XFRM_MSG_DELSA = 17,
	XFRM_MSG_GETSA = 18,
	XFRM_MSG_NEWPOLICY = 19,
	XFRM_MSG_DELPOLICY = 20,
	XFRM_MSG_GETPOLICY = 21,
	XFRM_MSG_ALLOCSPI = 22,
	XFRM_MSG_ACQUIRE = 23,
	XFRM_MSG_EXPIRE = 24,
	XFRM_MSG_UPDPOLICY = 25,
	XFRM_MSG_UPDSA = 26,
	XFRM_MSG_POLEXPIRE = 27,
	XFRM_MSG_FLUSHSA = 28,
	XFRM_MSG_FLUSHPOLICY = 29,
	XFRM_MSG_NEWAE = 30,
	XFRM_MSG_GETAE = 31,
	XFRM_MSG_REPORT = 32,
	XFRM_MSG_MIGRATE = 33,
	XFRM_MSG_NEWSADINFO = 34,
	XFRM_MSG_GETSADINFO = 35,
	XFRM_MSG_NEWSPDINFO = 36,
	XFRM_MSG_GETSPDINFO = 37,
	XFRM_MSG_MAPPING = 38,
	XFRM_MSG_SETDEFAULT = 39,
	XFRM_MSG_GETDEFAULT = 40,
	__XFRM_MSG_MAX = 41,
};

enum {
	XFRM_POLICY_IN = 0,
	XFRM_POLICY_OUT = 1,
	XFRM_POLICY_FWD = 2,
	XFRM_POLICY_MASK = 3,
	XFRM_POLICY_MAX = 3,
};

enum {
	XFRM_POLICY_TYPE_MAIN = 0,
	XFRM_POLICY_TYPE_SUB = 1,
	XFRM_POLICY_TYPE_MAX = 2,
	XFRM_POLICY_TYPE_ANY = 255,
};

enum {
	XFRM_SHARE_ANY = 0,
	XFRM_SHARE_SESSION = 1,
	XFRM_SHARE_USER = 2,
	XFRM_SHARE_UNIQUE = 3,
};

enum {
	XFRM_STATE_VOID = 0,
	XFRM_STATE_ACQ = 1,
	XFRM_STATE_VALID = 2,
	XFRM_STATE_ERROR = 3,
	XFRM_STATE_EXPIRED = 4,
	XFRM_STATE_DEAD = 5,
};

enum {
	XPT_BUSY = 0,
	XPT_CONN = 1,
	XPT_CLOSE = 2,
	XPT_DATA = 3,
	XPT_TEMP = 4,
	XPT_DEAD = 5,
	XPT_CHNGBUF = 6,
	XPT_DEFERRED = 7,
	XPT_OLD = 8,
	XPT_LISTENER = 9,
	XPT_CACHE_AUTH = 10,
	XPT_LOCAL = 11,
	XPT_KILL_TEMP = 12,
	XPT_CONG_CTRL = 13,
	XPT_HANDSHAKE = 14,
	XPT_TLS_SESSION = 15,
	XPT_PEER_AUTH = 16,
	XPT_PEER_VALID = 17,
};

enum {
	XT_CONNTRACK_STATE = 1,
	XT_CONNTRACK_PROTO = 2,
	XT_CONNTRACK_ORIGSRC = 4,
	XT_CONNTRACK_ORIGDST = 8,
	XT_CONNTRACK_REPLSRC = 16,
	XT_CONNTRACK_REPLDST = 32,
	XT_CONNTRACK_STATUS = 64,
	XT_CONNTRACK_EXPIRES = 128,
	XT_CONNTRACK_ORIGSRC_PORT = 256,
	XT_CONNTRACK_ORIGDST_PORT = 512,
	XT_CONNTRACK_REPLSRC_PORT = 1024,
	XT_CONNTRACK_REPLDST_PORT = 2048,
	XT_CONNTRACK_DIRECTION = 4096,
	XT_CONNTRACK_STATE_ALIAS = 8192,
};

enum {
	Y2_ASF_OS_PRES = 16,
	Y2_ASF_RESET = 8,
	Y2_ASF_RUNNING = 4,
	Y2_ASF_CLR_HSTI = 2,
	Y2_ASF_IRQ = 1,
	Y2_ASF_UC_STATE = 12,
	Y2_ASF_CLK_HALT = 0,
};

enum {
	Y2_B8_PREF_REGS = 1104,
	PREF_UNIT_CTRL = 0,
	PREF_UNIT_LAST_IDX = 4,
	PREF_UNIT_ADDR_LO = 8,
	PREF_UNIT_ADDR_HI = 12,
	PREF_UNIT_GET_IDX = 16,
	PREF_UNIT_PUT_IDX = 20,
	PREF_UNIT_FIFO_WP = 32,
	PREF_UNIT_FIFO_RP = 36,
	PREF_UNIT_FIFO_WM = 40,
	PREF_UNIT_FIFO_LEV = 44,
	PREF_UNIT_MASK_IDX = 4095,
};

enum {
	Y2_CLK_DIV_VAL_MSK = 16711680,
	Y2_CLK_DIV_VAL2_MSK = 14680064,
	Y2_CLK_SELECT2_MSK = 2031616,
	Y2_CLK_DIV_ENA = 2,
	Y2_CLK_DIV_DIS = 1,
};

enum {
	Y2_IS_HW_ERR = -2147483648,
	Y2_IS_STAT_BMU = 1073741824,
	Y2_IS_ASF = 536870912,
	Y2_IS_CPU_TO = 268435456,
	Y2_IS_POLL_CHK = 134217728,
	Y2_IS_TWSI_RDY = 67108864,
	Y2_IS_IRQ_SW = 33554432,
	Y2_IS_TIMINT = 16777216,
	Y2_IS_IRQ_PHY2 = 4096,
	Y2_IS_IRQ_MAC2 = 2048,
	Y2_IS_CHK_RX2 = 1024,
	Y2_IS_CHK_TXS2 = 512,
	Y2_IS_CHK_TXA2 = 256,
	Y2_IS_PSM_ACK = 128,
	Y2_IS_PTP_TIST = 64,
	Y2_IS_PHY_QLNK = 32,
	Y2_IS_IRQ_PHY1 = 16,
	Y2_IS_IRQ_MAC1 = 8,
	Y2_IS_CHK_RX1 = 4,
	Y2_IS_CHK_TXS1 = 2,
	Y2_IS_CHK_TXA1 = 1,
	Y2_IS_BASE = -1073741824,
	Y2_IS_PORT_1 = 29,
	Y2_IS_PORT_2 = 7424,
	Y2_IS_ERROR = -2147480307,
};

enum {
	Y2_IS_TIST_OV = 536870912,
	Y2_IS_SENSOR = 268435456,
	Y2_IS_MST_ERR = 134217728,
	Y2_IS_IRQ_STAT = 67108864,
	Y2_IS_PCI_EXP = 33554432,
	Y2_IS_PCI_NEXP = 16777216,
	Y2_IS_PAR_RD2 = 8192,
	Y2_IS_PAR_WR2 = 4096,
	Y2_IS_PAR_MAC2 = 2048,
	Y2_IS_PAR_RX2 = 1024,
	Y2_IS_TCP_TXS2 = 512,
	Y2_IS_TCP_TXA2 = 256,
	Y2_IS_PAR_RD1 = 32,
	Y2_IS_PAR_WR1 = 16,
	Y2_IS_PAR_MAC1 = 8,
	Y2_IS_PAR_RX1 = 4,
	Y2_IS_TCP_TXS1 = 2,
	Y2_IS_TCP_TXA1 = 1,
	Y2_HWE_L1_MASK = 63,
	Y2_HWE_L2_MASK = 16128,
	Y2_HWE_ALL_MASK = 738213695,
};

enum {
	Y2_STATUS_LNK2_INAC = 128,
	Y2_CLK_GAT_LNK2_DIS = 64,
	Y2_COR_CLK_LNK2_DIS = 32,
	Y2_PCI_CLK_LNK2_DIS = 16,
	Y2_STATUS_LNK1_INAC = 8,
	Y2_CLK_GAT_LNK1_DIS = 4,
	Y2_COR_CLK_LNK1_DIS = 2,
	Y2_PCI_CLK_LNK1_DIS = 1,
};

enum {
	Y2_VMAIN_AVAIL = 131072,
	Y2_VAUX_AVAIL = 65536,
	Y2_HW_WOL_ON = 32768,
	Y2_HW_WOL_OFF = 16384,
	Y2_ASF_ENABLE = 8192,
	Y2_ASF_DISABLE = 4096,
	Y2_CLK_RUN_ENA = 2048,
	Y2_CLK_RUN_DIS = 1024,
	Y2_LED_STAT_ON = 512,
	Y2_LED_STAT_OFF = 256,
	CS_ST_SW_IRQ = 128,
	CS_CL_SW_IRQ = 64,
	CS_STOP_DONE = 32,
	CS_STOP_MAST = 16,
	CS_MRST_CLR = 8,
	CS_MRST_SET = 4,
	CS_RST_CLR = 2,
	CS_RST_SET = 1,
};

enum {
	ZONELIST_FALLBACK = 0,
	ZONELIST_NOFALLBACK = 1,
	MAX_ZONELISTS = 2,
};

enum {
	_DQUOT_USAGE_ENABLED = 0,
	_DQUOT_LIMITS_ENABLED = 1,
	_DQUOT_SUSPENDED = 2,
	_DQUOT_STATE_FLAGS = 3,
};

enum {
	_IRQ_DEFAULT_INIT_FLAGS = 0,
	_IRQ_PER_CPU = 512,
	_IRQ_LEVEL = 256,
	_IRQ_NOPROBE = 1024,
	_IRQ_NOREQUEST = 2048,
	_IRQ_NOTHREAD = 65536,
	_IRQ_NOAUTOEN = 4096,
	_IRQ_NO_BALANCING = 8192,
	_IRQ_NESTED_THREAD = 32768,
	_IRQ_PER_CPU_DEVID = 131072,
	_IRQ_IS_POLLED = 262144,
	_IRQ_DISABLE_UNLAZY = 524288,
	_IRQ_HIDDEN = 1048576,
	_IRQ_NO_DEBUG = 2097152,
	_IRQF_MODIFY_MASK = 2080527,
};

enum {
	__I915_SAMPLE_FREQ_ACT = 0,
	__I915_SAMPLE_FREQ_REQ = 1,
	__I915_SAMPLE_RC6 = 2,
	__I915_SAMPLE_RC6_LAST_REPORTED = 3,
	__I915_NUM_PMU_SAMPLERS = 4,
};

enum {
	__ND_OPT_PREFIX_INFO_END = 0,
	ND_OPT_SOURCE_LL_ADDR = 1,
	ND_OPT_TARGET_LL_ADDR = 2,
	ND_OPT_PREFIX_INFO = 3,
	ND_OPT_REDIRECT_HDR = 4,
	ND_OPT_MTU = 5,
	ND_OPT_NONCE = 14,
	__ND_OPT_ARRAY_MAX = 15,
	ND_OPT_ROUTE_INFO = 24,
	ND_OPT_RDNSS = 25,
	ND_OPT_DNSSL = 31,
	ND_OPT_6CO = 34,
	ND_OPT_CAPTIVE_PORTAL = 37,
	ND_OPT_PREF64 = 38,
	__ND_OPT_MAX = 39,
};

enum {
	__PERCPU_REF_ATOMIC = 1,
	__PERCPU_REF_DEAD = 2,
	__PERCPU_REF_ATOMIC_DEAD = 3,
	__PERCPU_REF_FLAG_BITS = 2,
};

enum {
	__SCHED_FEAT_PLACE_LAG = 0,
	__SCHED_FEAT_PLACE_DEADLINE_INITIAL = 1,
	__SCHED_FEAT_PLACE_REL_DEADLINE = 2,
	__SCHED_FEAT_RUN_TO_PARITY = 3,
	__SCHED_FEAT_PREEMPT_SHORT = 4,
	__SCHED_FEAT_NEXT_BUDDY = 5,
	__SCHED_FEAT_PICK_BUDDY = 6,
	__SCHED_FEAT_CACHE_HOT_BUDDY = 7,
	__SCHED_FEAT_DELAY_DEQUEUE = 8,
	__SCHED_FEAT_DELAY_ZERO = 9,
	__SCHED_FEAT_WAKEUP_PREEMPTION = 10,
	__SCHED_FEAT_HRTICK = 11,
	__SCHED_FEAT_HRTICK_DL = 12,
	__SCHED_FEAT_NONTASK_CAPACITY = 13,
	__SCHED_FEAT_TTWU_QUEUE = 14,
	__SCHED_FEAT_SIS_UTIL = 15,
	__SCHED_FEAT_WARN_DOUBLE_CLOCK = 16,
	__SCHED_FEAT_RT_PUSH_IPI = 17,
	__SCHED_FEAT_RT_RUNTIME_SHARE = 18,
	__SCHED_FEAT_LB_MIN = 19,
	__SCHED_FEAT_ATTACH_AGE_LOAD = 20,
	__SCHED_FEAT_WA_IDLE = 21,
	__SCHED_FEAT_WA_WEIGHT = 22,
	__SCHED_FEAT_WA_BIAS = 23,
	__SCHED_FEAT_UTIL_EST = 24,
	__SCHED_FEAT_LATENCY_WARN = 25,
	__SCHED_FEAT_NR = 26,
};

enum {
	___GFP_DMA_BIT = 0,
	___GFP_HIGHMEM_BIT = 1,
	___GFP_DMA32_BIT = 2,
	___GFP_MOVABLE_BIT = 3,
	___GFP_RECLAIMABLE_BIT = 4,
	___GFP_HIGH_BIT = 5,
	___GFP_IO_BIT = 6,
	___GFP_FS_BIT = 7,
	___GFP_ZERO_BIT = 8,
	___GFP_UNUSED_BIT = 9,
	___GFP_DIRECT_RECLAIM_BIT = 10,
	___GFP_KSWAPD_RECLAIM_BIT = 11,
	___GFP_WRITE_BIT = 12,
	___GFP_NOWARN_BIT = 13,
	___GFP_RETRY_MAYFAIL_BIT = 14,
	___GFP_NOFAIL_BIT = 15,
	___GFP_NORETRY_BIT = 16,
	___GFP_MEMALLOC_BIT = 17,
	___GFP_COMP_BIT = 18,
	___GFP_NOMEMALLOC_BIT = 19,
	___GFP_HARDWALL_BIT = 20,
	___GFP_THISNODE_BIT = 21,
	___GFP_ACCOUNT_BIT = 22,
	___GFP_ZEROTAGS_BIT = 23,
	___GFP_LAST_BIT = 24,
};

enum {
	__ctx_convertBPF_PROG_TYPE_SOCKET_FILTER = 0,
	__ctx_convertBPF_PROG_TYPE_SCHED_CLS = 1,
	__ctx_convertBPF_PROG_TYPE_SCHED_ACT = 2,
	__ctx_convertBPF_PROG_TYPE_XDP = 3,
	__ctx_convertBPF_PROG_TYPE_LWT_IN = 4,
	__ctx_convertBPF_PROG_TYPE_LWT_OUT = 5,
	__ctx_convertBPF_PROG_TYPE_LWT_XMIT = 6,
	__ctx_convertBPF_PROG_TYPE_LWT_SEG6LOCAL = 7,
	__ctx_convertBPF_PROG_TYPE_SOCK_OPS = 8,
	__ctx_convertBPF_PROG_TYPE_SK_SKB = 9,
	__ctx_convertBPF_PROG_TYPE_SK_MSG = 10,
	__ctx_convertBPF_PROG_TYPE_FLOW_DISSECTOR = 11,
	__ctx_convertBPF_PROG_TYPE_KPROBE = 12,
	__ctx_convertBPF_PROG_TYPE_TRACEPOINT = 13,
	__ctx_convertBPF_PROG_TYPE_PERF_EVENT = 14,
	__ctx_convertBPF_PROG_TYPE_RAW_TRACEPOINT = 15,
	__ctx_convertBPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE = 16,
	__ctx_convertBPF_PROG_TYPE_TRACING = 17,
	__ctx_convertBPF_PROG_TYPE_SK_REUSEPORT = 18,
	__ctx_convertBPF_PROG_TYPE_SK_LOOKUP = 19,
	__ctx_convertBPF_PROG_TYPE_SYSCALL = 20,
	__ctx_convertBPF_PROG_TYPE_NETFILTER = 21,
	__ctx_convert_unused = 22,
};

enum {
	attr_noop = 0,
	attr_delayed_allocation_blocks = 1,
	attr_session_write_kbytes = 2,
	attr_lifetime_write_kbytes = 3,
	attr_reserved_clusters = 4,
	attr_sra_exceeded_retry_limit = 5,
	attr_inode_readahead = 6,
	attr_trigger_test_error = 7,
	attr_first_error_time = 8,
	attr_last_error_time = 9,
	attr_clusters_in_group = 10,
	attr_mb_order = 11,
	attr_feature = 12,
	attr_pointer_pi = 13,
	attr_pointer_ui = 14,
	attr_pointer_ul = 15,
	attr_pointer_u64 = 16,
	attr_pointer_u8 = 17,
	attr_pointer_string = 18,
	attr_pointer_atomic = 19,
	attr_journal_task = 20,
};

enum {
	blank_off = 0,
	blank_normal_wait = 1,
	blank_vesa_wait = 2,
};

enum {
	cpuset = 0,
	possible = 1,
	fail = 2,
};

enum {
	dns_key_data = 0,
	dns_key_error = 1,
};

enum {
	e1000_10_half = 0,
	e1000_10_full = 1,
	e1000_100_half = 2,
	e1000_100_full = 3,
};

enum {
	e1000_igp_cable_length_10 = 10,
	e1000_igp_cable_length_20 = 20,
	e1000_igp_cable_length_30 = 30,
	e1000_igp_cable_length_40 = 40,
	e1000_igp_cable_length_50 = 50,
	e1000_igp_cable_length_60 = 60,
	e1000_igp_cable_length_70 = 70,
	e1000_igp_cable_length_80 = 80,
	e1000_igp_cable_length_90 = 90,
	e1000_igp_cable_length_100 = 100,
	e1000_igp_cable_length_110 = 110,
	e1000_igp_cable_length_115 = 115,
	e1000_igp_cable_length_120 = 120,
	e1000_igp_cable_length_130 = 130,
	e1000_igp_cable_length_140 = 140,
	e1000_igp_cable_length_150 = 150,
	e1000_igp_cable_length_160 = 160,
	e1000_igp_cable_length_170 = 170,
	e1000_igp_cable_length_180 = 180,
};

enum {
	false = 0,
	true = 1,
};

enum {
	mechtype_caddy = 0,
	mechtype_tray = 1,
	mechtype_popup = 2,
	mechtype_individual_changer = 4,
	mechtype_cartridge_changer = 5,
};

enum {
	none = 0,
	day = 1,
	month = 2,
	year = 3,
};

enum {
	pci_channel_io_normal = 1,
	pci_channel_io_frozen = 2,
	pci_channel_io_perm_failure = 3,
};

enum {
	preempt_dynamic_undefined = -1,
	preempt_dynamic_none = 0,
	preempt_dynamic_voluntary = 1,
	preempt_dynamic_full = 2,
	preempt_dynamic_lazy = 3,
};

enum {
	ptr_explicit = 0,
	ptr_ext4_sb_info_offset = 1,
	ptr_ext4_super_block_offset = 2,
};

enum {
	st_wordstart = 0,
	st_wordcmp = 1,
	st_wordskip = 2,
	st_bufcpy = 3,
};

enum {
	st_wordstart___2 = 0,
	st_wordcmp___2 = 1,
	st_wordskip___2 = 2,
};

enum {
	sysctl_hung_task_timeout_secs = 0,
};

enum {
	x86_lbr_exclusive_lbr = 0,
	x86_lbr_exclusive_bts = 1,
	x86_lbr_exclusive_pt = 2,
	x86_lbr_exclusive_max = 3,
};

typedef enum {
	BIT_DStream_unfinished = 0,
	BIT_DStream_endOfBuffer = 1,
	BIT_DStream_completed = 2,
	BIT_DStream_overflow = 3,
} BIT_DStream_status;

typedef enum {
	ZSTD_error_no_error = 0,
	ZSTD_error_GENERIC = 1,
	ZSTD_error_prefix_unknown = 10,
	ZSTD_error_version_unsupported = 12,
	ZSTD_error_frameParameter_unsupported = 14,
	ZSTD_error_frameParameter_windowTooLarge = 16,
	ZSTD_error_corruption_detected = 20,
	ZSTD_error_checksum_wrong = 22,
	ZSTD_error_dictionary_corrupted = 30,
	ZSTD_error_dictionary_wrong = 32,
	ZSTD_error_dictionaryCreation_failed = 34,
	ZSTD_error_parameter_unsupported = 40,
	ZSTD_error_parameter_outOfBound = 42,
	ZSTD_error_tableLog_tooLarge = 44,
	ZSTD_error_maxSymbolValue_tooLarge = 46,
	ZSTD_error_maxSymbolValue_tooSmall = 48,
	ZSTD_error_stage_wrong = 60,
	ZSTD_error_init_missing = 62,
	ZSTD_error_memory_allocation = 64,
	ZSTD_error_workSpace_tooSmall = 66,
	ZSTD_error_dstSize_tooSmall = 70,
	ZSTD_error_srcSize_wrong = 72,
	ZSTD_error_dstBuffer_null = 74,
	ZSTD_error_frameIndex_tooLarge = 100,
	ZSTD_error_seekableIO = 102,
	ZSTD_error_dstBuffer_wrong = 104,
	ZSTD_error_srcBuffer_wrong = 105,
	ZSTD_error_maxCode = 120,
} ZSTD_ErrorCode;

typedef ZSTD_ErrorCode ERR_enum;

typedef enum {
	ZSTD_reset_session_only = 1,
	ZSTD_reset_parameters = 2,
	ZSTD_reset_session_and_parameters = 3,
} ZSTD_ResetDirective;

typedef enum {
	ZSTD_bm_buffered = 0,
	ZSTD_bm_stable = 1,
} ZSTD_bufferMode_e;

typedef enum {
	ZSTD_d_windowLogMax = 100,
	ZSTD_d_experimentalParam1 = 1000,
	ZSTD_d_experimentalParam2 = 1001,
	ZSTD_d_experimentalParam3 = 1002,
	ZSTD_d_experimentalParam4 = 1003,
} ZSTD_dParameter;

typedef enum {
	ZSTDds_getFrameHeaderSize = 0,
	ZSTDds_decodeFrameHeader = 1,
	ZSTDds_decodeBlockHeader = 2,
	ZSTDds_decompressBlock = 3,
	ZSTDds_decompressLastBlock = 4,
	ZSTDds_checkChecksum = 5,
	ZSTDds_decodeSkippableHeader = 6,
	ZSTDds_skipFrame = 7,
} ZSTD_dStage;

typedef enum {
	zdss_init = 0,
	zdss_loadHeader = 1,
	zdss_read = 2,
	zdss_load = 3,
	zdss_flush = 4,
} ZSTD_dStreamStage;

typedef enum {
	ZSTD_dct_auto = 0,
	ZSTD_dct_rawContent = 1,
	ZSTD_dct_fullDict = 2,
} ZSTD_dictContentType_e;

typedef enum {
	ZSTD_dlm_byCopy = 0,
	ZSTD_dlm_byRef = 1,
} ZSTD_dictLoadMethod_e;

typedef enum {
	ZSTD_use_indefinitely = -1,
	ZSTD_dont_use = 0,
	ZSTD_use_once = 1,
} ZSTD_dictUses_e;

typedef enum {
	ZSTD_d_validateChecksum = 0,
	ZSTD_d_ignoreChecksum = 1,
} ZSTD_forceIgnoreChecksum_e;

typedef enum {
	ZSTD_f_zstd1 = 0,
	ZSTD_f_zstd1_magicless = 1,
} ZSTD_format_e;

typedef enum {
	ZSTD_frame = 0,
	ZSTD_skippableFrame = 1,
} ZSTD_frameType_e;

typedef enum {
	ZSTD_not_in_dst = 0,
	ZSTD_in_dst = 1,
	ZSTD_split = 2,
} ZSTD_litLocation_e;

typedef enum {
	ZSTD_lo_isRegularOffset = 0,
	ZSTD_lo_isLongOffset = 1,
} ZSTD_longOffset_e;

typedef enum {
	ZSTDnit_frameHeader = 0,
	ZSTDnit_blockHeader = 1,
	ZSTDnit_block = 2,
	ZSTDnit_lastBlock = 3,
	ZSTDnit_checksum = 4,
	ZSTDnit_skippableFrame = 5,
} ZSTD_nextInputType_e;

typedef enum {
	ZSTD_no_overlap = 0,
	ZSTD_overlap_src_before_dst = 1,
} ZSTD_overlap_e;

typedef enum {
	ZSTD_rmd_refSingleDDict = 0,
	ZSTD_rmd_refMultipleDDicts = 1,
} ZSTD_refMultipleDDicts_e;

typedef enum {
	OSL_GLOBAL_LOCK_HANDLER = 0,
	OSL_NOTIFY_HANDLER = 1,
	OSL_GPE_HANDLER = 2,
	OSL_DEBUGGER_MAIN_THREAD = 3,
	OSL_DEBUGGER_EXEC_THREAD = 4,
	OSL_EC_POLL_HANDLER = 5,
	OSL_EC_BURST_HANDLER = 6,
} acpi_execute_type;

typedef enum {
	ACPI_IMODE_LOAD_PASS1 = 1,
	ACPI_IMODE_LOAD_PASS2 = 2,
	ACPI_IMODE_EXECUTE = 3,
} acpi_interpreter_mode;

typedef enum {
	ACPI_TRACE_AML_METHOD = 0,
	ACPI_TRACE_AML_OPCODE = 1,
	ACPI_TRACE_AML_REGION = 2,
} acpi_trace_event_type;

typedef enum {
	bt_raw = 0,
	bt_rle = 1,
	bt_compressed = 2,
	bt_reserved = 3,
} blockType_e;

typedef enum {
	need_more = 0,
	block_done = 1,
	finish_started = 2,
	finish_done = 3,
} block_state;

typedef enum {
	CH_8139 = 0,
	CH_8139_K = 1,
	CH_8139A = 2,
	CH_8139A_G = 3,
	CH_8139B = 4,
	CH_8130 = 5,
	CH_8139C = 6,
	CH_8100 = 7,
	CH_8100B_8139D = 8,
	CH_8101 = 9,
} chip_t;

typedef enum {
	CODES = 0,
	LENS = 1,
	DISTS = 2,
} codetype;

typedef enum {
	FILE_MEMORY_MIGRATE = 0,
	FILE_CPULIST = 1,
	FILE_MEMLIST = 2,
	FILE_EFFECTIVE_CPULIST = 3,
	FILE_EFFECTIVE_MEMLIST = 4,
	FILE_SUBPARTS_CPULIST = 5,
	FILE_EXCLUSIVE_CPULIST = 6,
	FILE_EFFECTIVE_XCPULIST = 7,
	FILE_ISOLATED_CPULIST = 8,
	FILE_CPU_EXCLUSIVE = 9,
	FILE_MEM_EXCLUSIVE = 10,
	FILE_MEM_HARDWALL = 11,
	FILE_SCHED_LOAD_BALANCE = 12,
	FILE_PARTITION_ROOT = 13,
	FILE_SCHED_RELAX_DOMAIN_LEVEL = 14,
	FILE_MEMORY_PRESSURE_ENABLED = 15,
	FILE_MEMORY_PRESSURE = 16,
	FILE_SPREAD_PAGE = 17,
	FILE_SPREAD_SLAB = 18,
} cpuset_filetype_t;

typedef enum {
	CS_ONLINE = 0,
	CS_CPU_EXCLUSIVE = 1,
	CS_MEM_EXCLUSIVE = 2,
	CS_MEM_HARDWALL = 3,
	CS_MEMORY_MIGRATE = 4,
	CS_SCHED_LOAD_BALANCE = 5,
	CS_SPREAD_PAGE = 6,
	CS_SPREAD_SLAB = 7,
} cpuset_flagbits_t;

typedef enum {
	noDict = 0,
	withPrefix64k = 1,
	usingExtDict = 2,
} dict_directive;

typedef enum {
	EITHER = 0,
	INDEX = 1,
	DIRENT = 2,
	DIRENT_HTREE = 3,
} dirblock_type_t;

typedef enum {
	e1000_1000t_rx_status_not_ok = 0,
	e1000_1000t_rx_status_ok = 1,
	e1000_1000t_rx_status_undefined = 255,
} e1000_1000t_rx_status;

typedef enum {
	e1000_10bt_ext_dist_enable_normal = 0,
	e1000_10bt_ext_dist_enable_lower = 1,
	e1000_10bt_ext_dist_enable_undefined = 255,
} e1000_10bt_ext_dist_enable;

typedef enum {
	e1000_auto_x_mode_manual_mdi = 0,
	e1000_auto_x_mode_manual_mdix = 1,
	e1000_auto_x_mode_auto1 = 2,
	e1000_auto_x_mode_auto2 = 3,
	e1000_auto_x_mode_undefined = 255,
} e1000_auto_x_mode;

typedef enum {
	e1000_bus_speed_unknown = 0,
	e1000_bus_speed_33 = 1,
	e1000_bus_speed_66 = 2,
	e1000_bus_speed_100 = 3,
	e1000_bus_speed_120 = 4,
	e1000_bus_speed_133 = 5,
	e1000_bus_speed_reserved = 6,
} e1000_bus_speed;

typedef enum {
	e1000_bus_type_unknown = 0,
	e1000_bus_type_pci = 1,
	e1000_bus_type_pcix = 2,
	e1000_bus_type_reserved = 3,
} e1000_bus_type;

typedef enum {
	e1000_bus_width_unknown = 0,
	e1000_bus_width_32 = 1,
	e1000_bus_width_64 = 2,
	e1000_bus_width_reserved = 3,
} e1000_bus_width;

typedef enum {
	e1000_cable_length_50 = 0,
	e1000_cable_length_50_80 = 1,
	e1000_cable_length_80_110 = 2,
	e1000_cable_length_110_140 = 3,
	e1000_cable_length_140 = 4,
	e1000_cable_length_undefined = 255,
} e1000_cable_length;

typedef enum {
	e1000_downshift_normal = 0,
	e1000_downshift_activated = 1,
	e1000_downshift_undefined = 255,
} e1000_downshift;

typedef enum {
	e1000_dsp_config_disabled = 0,
	e1000_dsp_config_enabled = 1,
	e1000_dsp_config_activated = 2,
	e1000_dsp_config_undefined = 255,
} e1000_dsp_config;

typedef enum {
	e1000_eeprom_uninitialized = 0,
	e1000_eeprom_spi = 1,
	e1000_eeprom_microwire = 2,
	e1000_eeprom_flash = 3,
	e1000_eeprom_none = 4,
	e1000_num_eeprom_types = 5,
} e1000_eeprom_type;

typedef enum {
	E1000_FC_NONE = 0,
	E1000_FC_RX_PAUSE = 1,
	E1000_FC_TX_PAUSE = 2,
	E1000_FC_FULL = 3,
	E1000_FC_DEFAULT = 255,
} e1000_fc_type;

typedef enum {
	e1000_ffe_config_enabled = 0,
	e1000_ffe_config_active = 1,
	e1000_ffe_config_blocked = 2,
} e1000_ffe_config;

typedef enum {
	e1000_undefined = 0,
	e1000_82542_rev2_0 = 1,
	e1000_82542_rev2_1 = 2,
	e1000_82543 = 3,
	e1000_82544 = 4,
	e1000_82540 = 5,
	e1000_82545 = 6,
	e1000_82545_rev_3 = 7,
	e1000_82546 = 8,
	e1000_ce4100 = 9,
	e1000_82546_rev_3 = 10,
	e1000_82541 = 11,
	e1000_82541_rev_2 = 12,
	e1000_82547 = 13,
	e1000_82547_rev_2 = 14,
	e1000_num_macs = 15,
} e1000_mac_type;

typedef enum {
	e1000_media_type_copper = 0,
	e1000_media_type_fiber = 1,
	e1000_media_type_internal_serdes = 2,
	e1000_num_media_types = 3,
} e1000_media_type;

typedef enum {
	e1000_ms_hw_default = 0,
	e1000_ms_force_master = 1,
	e1000_ms_force_slave = 2,
	e1000_ms_auto = 3,
} e1000_ms_type;

typedef enum {
	e1000_phy_m88 = 0,
	e1000_phy_igp = 1,
	e1000_phy_8211 = 2,
	e1000_phy_8201 = 3,
	e1000_phy_undefined = 255,
} e1000_phy_type;

typedef enum {
	e1000_polarity_reversal_enabled = 0,
	e1000_polarity_reversal_disabled = 1,
	e1000_polarity_reversal_undefined = 255,
} e1000_polarity_reversal;

typedef enum {
	e1000_rev_polarity_normal = 0,
	e1000_rev_polarity_reversed = 1,
	e1000_rev_polarity_undefined = 255,
} e1000_rev_polarity;

typedef enum {
	e1000_smart_speed_default = 0,
	e1000_smart_speed_on = 1,
	e1000_smart_speed_off = 2,
} e1000_smart_speed;

typedef enum {
	decode_full_block = 0,
	partial_decode = 1,
} earlyEnd_directive;

typedef enum {
	endOnOutputSize = 0,
	endOnInputSize = 1,
} endCondition_directive;

typedef enum {
	EXT4_IGET_NORMAL = 0,
	EXT4_IGET_SPECIAL = 1,
	EXT4_IGET_HANDLE = 2,
	EXT4_IGET_BAD = 4,
	EXT4_IGET_EA_INODE = 8,
} ext4_iget_flags;

typedef enum {
	HEAD = 0,
	FLAGS = 1,
	TIME = 2,
	OS = 3,
	EXLEN = 4,
	EXTRA = 5,
	NAME = 6,
	COMMENT = 7,
	HCRC = 8,
	DICTID = 9,
	DICT = 10,
	TYPE = 11,
	TYPEDO = 12,
	STORED = 13,
	COPY = 14,
	TABLE = 15,
	LENLENS = 16,
	CODELENS = 17,
	LEN = 18,
	LENEXT = 19,
	DIST = 20,
	DISTEXT = 21,
	MATCH = 22,
	LIT = 23,
	CHECK = 24,
	LENGTH = 25,
	DONE = 26,
	BAD = 27,
	MEM = 28,
	SYNC = 29,
} inflate_mode;

typedef enum {
	ISOLATE_ABORT = 0,
	ISOLATE_NONE = 1,
	ISOLATE_SUCCESS = 2,
} isolate_migrate_t;

typedef enum {
	MAP_CHG_REUSE = 0,
	MAP_CHG_NEEDED = 1,
	MAP_CHG_ENFORCED = 2,
} map_chg_state;

typedef enum {
	PAGE_KEEP = 0,
	PAGE_ACTIVATE = 1,
	PAGE_SUCCESS = 2,
	PAGE_CLEAN = 3,
} pageout_t;

typedef enum {
	PHY_INTERFACE_MODE_NA = 0,
	PHY_INTERFACE_MODE_INTERNAL = 1,
	PHY_INTERFACE_MODE_MII = 2,
	PHY_INTERFACE_MODE_GMII = 3,
	PHY_INTERFACE_MODE_SGMII = 4,
	PHY_INTERFACE_MODE_TBI = 5,
	PHY_INTERFACE_MODE_REVMII = 6,
	PHY_INTERFACE_MODE_RMII = 7,
	PHY_INTERFACE_MODE_REVRMII = 8,
	PHY_INTERFACE_MODE_RGMII = 9,
	PHY_INTERFACE_MODE_RGMII_ID = 10,
	PHY_INTERFACE_MODE_RGMII_RXID = 11,
	PHY_INTERFACE_MODE_RGMII_TXID = 12,
	PHY_INTERFACE_MODE_RTBI = 13,
	PHY_INTERFACE_MODE_SMII = 14,
	PHY_INTERFACE_MODE_XGMII = 15,
	PHY_INTERFACE_MODE_XLGMII = 16,
	PHY_INTERFACE_MODE_MOCA = 17,
	PHY_INTERFACE_MODE_PSGMII = 18,
	PHY_INTERFACE_MODE_QSGMII = 19,
	PHY_INTERFACE_MODE_TRGMII = 20,
	PHY_INTERFACE_MODE_100BASEX = 21,
	PHY_INTERFACE_MODE_1000BASEX = 22,
	PHY_INTERFACE_MODE_2500BASEX = 23,
	PHY_INTERFACE_MODE_5GBASER = 24,
	PHY_INTERFACE_MODE_RXAUI = 25,
	PHY_INTERFACE_MODE_XAUI = 26,
	PHY_INTERFACE_MODE_10GBASER = 27,
	PHY_INTERFACE_MODE_25GBASER = 28,
	PHY_INTERFACE_MODE_USXGMII = 29,
	PHY_INTERFACE_MODE_10GKR = 30,
	PHY_INTERFACE_MODE_QUSGMII = 31,
	PHY_INTERFACE_MODE_1000BASEKX = 32,
	PHY_INTERFACE_MODE_10G_QXGMII = 33,
	PHY_INTERFACE_MODE_MAX = 34,
} phy_interface_t;

typedef enum {
	PSMOUSE_BAD_DATA = 0,
	PSMOUSE_GOOD_DATA = 1,
	PSMOUSE_FULL_PACKET = 2,
} psmouse_ret_t;

typedef enum {
	SS_FREE = 0,
	SS_UNCONNECTED = 1,
	SS_CONNECTING = 2,
	SS_CONNECTED = 3,
	SS_DISCONNECTING = 4,
} socket_state;

typedef enum {
	STATUSTYPE_INFO = 0,
	STATUSTYPE_TABLE = 1,
	STATUSTYPE_IMA = 2,
} status_type_t;

typedef enum {
	not_streaming = 0,
	is_streaming = 1,
} streaming_operation;

typedef enum {
	set_basic = 0,
	set_rle = 1,
	set_compressed = 2,
	set_repeat = 3,
} symbolEncodingType_e;

typedef ZSTD_ErrorCode zstd_error_code;

enum CSCRBits {
	CSCR_LinkOKBit = 1024,
	CSCR_LinkChangeBit = 2048,
	CSCR_LinkStatusBits = 61440,
	CSCR_LinkDownOffCmd = 960,
	CSCR_LinkDownCmd = 62400,
};

enum CSI_J {
	CSI_J_CURSOR_TO_END = 0,
	CSI_J_START_TO_CURSOR = 1,
	CSI_J_VISIBLE = 2,
	CSI_J_FULL = 3,
};

enum CSI_right_square_bracket {
	CSI_RSB_COLOR_FOR_UNDERLINE = 1,
	CSI_RSB_COLOR_FOR_HALF_BRIGHT = 2,
	CSI_RSB_MAKE_CUR_COLOR_DEFAULT = 8,
	CSI_RSB_BLANKING_INTERVAL = 9,
	CSI_RSB_BELL_FREQUENCY = 10,
	CSI_RSB_BELL_DURATION = 11,
	CSI_RSB_BRING_CONSOLE_TO_FRONT = 12,
	CSI_RSB_UNBLANK = 13,
	CSI_RSB_VESA_OFF_INTERVAL = 14,
	CSI_RSB_BRING_PREV_CONSOLE_TO_FRONT = 15,
	CSI_RSB_CURSOR_BLINK_INTERVAL = 16,
};

enum Cfg9346Bits {
	Cfg9346_Lock = 0,
	Cfg9346_Unlock = 192,
};

enum ChipCmdBits {
	CmdReset = 16,
	CmdRxEnb = 8,
	CmdTxEnb = 4,
	RxBufEmpty = 1,
};

enum ClearBitMasks {
	MultiIntrClear = 61440,
	ChipCmdClear = 226,
	Config1Clear = 206,
};

enum Config1Bits {
	Cfg1_PM_Enable = 1,
	Cfg1_VPD_Enable = 2,
	Cfg1_PIO = 4,
	Cfg1_MMIO = 8,
	LWAKE = 16,
	Cfg1_Driver_Load = 32,
	Cfg1_LED0 = 64,
	Cfg1_LED1 = 128,
	SLEEP = 2,
	PWRDN = 1,
};

enum Config3Bits {
	Cfg3_FBtBEn = 1,
	Cfg3_FuncRegEn = 2,
	Cfg3_CLKRUN_En = 4,
	Cfg3_CardB_En = 8,
	Cfg3_LinkUp = 16,
	Cfg3_Magic = 32,
	Cfg3_PARM_En = 64,
	Cfg3_GNTSel = 128,
};

enum Config4Bits {
	LWPTN = 4,
};

enum Config5Bits {
	Cfg5_PME_STS = 1,
	Cfg5_LANWake = 2,
	Cfg5_LDPS = 4,
	Cfg5_FIFOAddrPtr = 8,
	Cfg5_UWF = 16,
	Cfg5_MWF = 32,
	Cfg5_BWF = 64,
};

enum IntrStatusBits {
	PCIErr = 32768,
	PCSTimeout = 16384,
	RxFIFOOver = 64,
	RxUnderrun = 32,
	RxOverflow = 16,
	TxErr = 8,
	TxOK = 4,
	RxErr = 2,
	RxOK = 1,
	RxAckBits = 81,
};

enum KTHREAD_BITS {
	KTHREAD_IS_PER_CPU = 0,
	KTHREAD_SHOULD_STOP = 1,
	KTHREAD_SHOULD_PARK = 2,
};

enum OID {
	OID_id_dsa_with_sha1 = 0,
	OID_id_dsa = 1,
	OID_id_ecPublicKey = 2,
	OID_id_prime192v1 = 3,
	OID_id_prime256v1 = 4,
	OID_id_ecdsa_with_sha1 = 5,
	OID_id_ecdsa_with_sha224 = 6,
	OID_id_ecdsa_with_sha256 = 7,
	OID_id_ecdsa_with_sha384 = 8,
	OID_id_ecdsa_with_sha512 = 9,
	OID_rsaEncryption = 10,
	OID_sha1WithRSAEncryption = 11,
	OID_sha256WithRSAEncryption = 12,
	OID_sha384WithRSAEncryption = 13,
	OID_sha512WithRSAEncryption = 14,
	OID_sha224WithRSAEncryption = 15,
	OID_data = 16,
	OID_signed_data = 17,
	OID_email_address = 18,
	OID_contentType = 19,
	OID_messageDigest = 20,
	OID_signingTime = 21,
	OID_smimeCapabilites = 22,
	OID_smimeAuthenticatedAttrs = 23,
	OID_mskrb5 = 24,
	OID_krb5 = 25,
	OID_krb5u2u = 26,
	OID_msIndirectData = 27,
	OID_msStatementType = 28,
	OID_msSpOpusInfo = 29,
	OID_msPeImageDataObjId = 30,
	OID_msIndividualSPKeyPurpose = 31,
	OID_msOutlookExpress = 32,
	OID_ntlmssp = 33,
	OID_negoex = 34,
	OID_spnego = 35,
	OID_IAKerb = 36,
	OID_PKU2U = 37,
	OID_Scram = 38,
	OID_certAuthInfoAccess = 39,
	OID_sha1 = 40,
	OID_id_ansip384r1 = 41,
	OID_id_ansip521r1 = 42,
	OID_sha256 = 43,
	OID_sha384 = 44,
	OID_sha512 = 45,
	OID_sha224 = 46,
	OID_commonName = 47,
	OID_surname = 48,
	OID_countryName = 49,
	OID_locality = 50,
	OID_stateOrProvinceName = 51,
	OID_organizationName = 52,
	OID_organizationUnitName = 53,
	OID_title = 54,
	OID_description = 55,
	OID_name = 56,
	OID_givenName = 57,
	OID_initials = 58,
	OID_generationalQualifier = 59,
	OID_subjectKeyIdentifier = 60,
	OID_keyUsage = 61,
	OID_subjectAltName = 62,
	OID_issuerAltName = 63,
	OID_basicConstraints = 64,
	OID_crlDistributionPoints = 65,
	OID_certPolicies = 66,
	OID_authorityKeyIdentifier = 67,
	OID_extKeyUsage = 68,
	OID_NetlogonMechanism = 69,
	OID_appleLocalKdcSupported = 70,
	OID_gostCPSignA = 71,
	OID_gostCPSignB = 72,
	OID_gostCPSignC = 73,
	OID_gost2012PKey256 = 74,
	OID_gost2012PKey512 = 75,
	OID_gost2012Digest256 = 76,
	OID_gost2012Digest512 = 77,
	OID_gost2012Signature256 = 78,
	OID_gost2012Signature512 = 79,
	OID_gostTC26Sign256A = 80,
	OID_gostTC26Sign256B = 81,
	OID_gostTC26Sign256C = 82,
	OID_gostTC26Sign256D = 83,
	OID_gostTC26Sign512A = 84,
	OID_gostTC26Sign512B = 85,
	OID_gostTC26Sign512C = 86,
	OID_sm2 = 87,
	OID_sm3 = 88,
	OID_SM2_with_SM3 = 89,
	OID_sm3WithRSAEncryption = 90,
	OID_TPMLoadableKey = 91,
	OID_TPMImportableKey = 92,
	OID_TPMSealedData = 93,
	OID_sha3_256 = 94,
	OID_sha3_384 = 95,
	OID_sha3_512 = 96,
	OID_id_ecdsa_with_sha3_256 = 97,
	OID_id_ecdsa_with_sha3_384 = 98,
	OID_id_ecdsa_with_sha3_512 = 99,
	OID_id_rsassa_pkcs1_v1_5_with_sha3_256 = 100,
	OID_id_rsassa_pkcs1_v1_5_with_sha3_384 = 101,
	OID_id_rsassa_pkcs1_v1_5_with_sha3_512 = 102,
	OID__NR = 103,
};

enum P4_ESCR_EMASKS {
	P4_EVENT_TC_DELIVER_MODE__DD = 512,
	P4_EVENT_TC_DELIVER_MODE__DB = 1024,
	P4_EVENT_TC_DELIVER_MODE__DI = 2048,
	P4_EVENT_TC_DELIVER_MODE__BD = 4096,
	P4_EVENT_TC_DELIVER_MODE__BB = 8192,
	P4_EVENT_TC_DELIVER_MODE__BI = 16384,
	P4_EVENT_TC_DELIVER_MODE__ID = 32768,
	P4_EVENT_BPU_FETCH_REQUEST__TCMISS = 512,
	P4_EVENT_ITLB_REFERENCE__HIT = 512,
	P4_EVENT_ITLB_REFERENCE__MISS = 1024,
	P4_EVENT_ITLB_REFERENCE__HIT_UK = 2048,
	P4_EVENT_MEMORY_CANCEL__ST_RB_FULL = 2048,
	P4_EVENT_MEMORY_CANCEL__64K_CONF = 4096,
	P4_EVENT_MEMORY_COMPLETE__LSC = 512,
	P4_EVENT_MEMORY_COMPLETE__SSC = 1024,
	P4_EVENT_LOAD_PORT_REPLAY__SPLIT_LD = 1024,
	P4_EVENT_STORE_PORT_REPLAY__SPLIT_ST = 1024,
	P4_EVENT_MOB_LOAD_REPLAY__NO_STA = 1024,
	P4_EVENT_MOB_LOAD_REPLAY__NO_STD = 4096,
	P4_EVENT_MOB_LOAD_REPLAY__PARTIAL_DATA = 8192,
	P4_EVENT_MOB_LOAD_REPLAY__UNALGN_ADDR = 16384,
	P4_EVENT_PAGE_WALK_TYPE__DTMISS = 512,
	P4_EVENT_PAGE_WALK_TYPE__ITMISS = 1024,
	P4_EVENT_BSQ_CACHE_REFERENCE__RD_2ndL_HITS = 512,
	P4_EVENT_BSQ_CACHE_REFERENCE__RD_2ndL_HITE = 1024,
	P4_EVENT_BSQ_CACHE_REFERENCE__RD_2ndL_HITM = 2048,
	P4_EVENT_BSQ_CACHE_REFERENCE__RD_3rdL_HITS = 4096,
	P4_EVENT_BSQ_CACHE_REFERENCE__RD_3rdL_HITE = 8192,
	P4_EVENT_BSQ_CACHE_REFERENCE__RD_3rdL_HITM = 16384,
	P4_EVENT_BSQ_CACHE_REFERENCE__RD_2ndL_MISS = 131072,
	P4_EVENT_BSQ_CACHE_REFERENCE__RD_3rdL_MISS = 262144,
	P4_EVENT_BSQ_CACHE_REFERENCE__WR_2ndL_MISS = 524288,
	P4_EVENT_IOQ_ALLOCATION__DEFAULT = 512,
	P4_EVENT_IOQ_ALLOCATION__ALL_READ = 16384,
	P4_EVENT_IOQ_ALLOCATION__ALL_WRITE = 32768,
	P4_EVENT_IOQ_ALLOCATION__MEM_UC = 65536,
	P4_EVENT_IOQ_ALLOCATION__MEM_WC = 131072,
	P4_EVENT_IOQ_ALLOCATION__MEM_WT = 262144,
	P4_EVENT_IOQ_ALLOCATION__MEM_WP = 524288,
	P4_EVENT_IOQ_ALLOCATION__MEM_WB = 1048576,
	P4_EVENT_IOQ_ALLOCATION__OWN = 4194304,
	P4_EVENT_IOQ_ALLOCATION__OTHER = 8388608,
	P4_EVENT_IOQ_ALLOCATION__PREFETCH = 16777216,
	P4_EVENT_IOQ_ACTIVE_ENTRIES__DEFAULT = 512,
	P4_EVENT_IOQ_ACTIVE_ENTRIES__ALL_READ = 16384,
	P4_EVENT_IOQ_ACTIVE_ENTRIES__ALL_WRITE = 32768,
	P4_EVENT_IOQ_ACTIVE_ENTRIES__MEM_UC = 65536,
	P4_EVENT_IOQ_ACTIVE_ENTRIES__MEM_WC = 131072,
	P4_EVENT_IOQ_ACTIVE_ENTRIES__MEM_WT = 262144,
	P4_EVENT_IOQ_ACTIVE_ENTRIES__MEM_WP = 524288,
	P4_EVENT_IOQ_ACTIVE_ENTRIES__MEM_WB = 1048576,
	P4_EVENT_IOQ_ACTIVE_ENTRIES__OWN = 4194304,
	P4_EVENT_IOQ_ACTIVE_ENTRIES__OTHER = 8388608,
	P4_EVENT_IOQ_ACTIVE_ENTRIES__PREFETCH = 16777216,
	P4_EVENT_FSB_DATA_ACTIVITY__DRDY_DRV = 512,
	P4_EVENT_FSB_DATA_ACTIVITY__DRDY_OWN = 1024,
	P4_EVENT_FSB_DATA_ACTIVITY__DRDY_OTHER = 2048,
	P4_EVENT_FSB_DATA_ACTIVITY__DBSY_DRV = 4096,
	P4_EVENT_FSB_DATA_ACTIVITY__DBSY_OWN = 8192,
	P4_EVENT_FSB_DATA_ACTIVITY__DBSY_OTHER = 16384,
	P4_EVENT_BSQ_ALLOCATION__REQ_TYPE0 = 512,
	P4_EVENT_BSQ_ALLOCATION__REQ_TYPE1 = 1024,
	P4_EVENT_BSQ_ALLOCATION__REQ_LEN0 = 2048,
	P4_EVENT_BSQ_ALLOCATION__REQ_LEN1 = 4096,
	P4_EVENT_BSQ_ALLOCATION__REQ_IO_TYPE = 16384,
	P4_EVENT_BSQ_ALLOCATION__REQ_LOCK_TYPE = 32768,
	P4_EVENT_BSQ_ALLOCATION__REQ_CACHE_TYPE = 65536,
	P4_EVENT_BSQ_ALLOCATION__REQ_SPLIT_TYPE = 131072,
	P4_EVENT_BSQ_ALLOCATION__REQ_DEM_TYPE = 262144,
	P4_EVENT_BSQ_ALLOCATION__REQ_ORD_TYPE = 524288,
	P4_EVENT_BSQ_ALLOCATION__MEM_TYPE0 = 1048576,
	P4_EVENT_BSQ_ALLOCATION__MEM_TYPE1 = 2097152,
	P4_EVENT_BSQ_ALLOCATION__MEM_TYPE2 = 4194304,
	P4_EVENT_BSQ_ACTIVE_ENTRIES__REQ_TYPE0 = 512,
	P4_EVENT_BSQ_ACTIVE_ENTRIES__REQ_TYPE1 = 1024,
	P4_EVENT_BSQ_ACTIVE_ENTRIES__REQ_LEN0 = 2048,
	P4_EVENT_BSQ_ACTIVE_ENTRIES__REQ_LEN1 = 4096,
	P4_EVENT_BSQ_ACTIVE_ENTRIES__REQ_IO_TYPE = 16384,
	P4_EVENT_BSQ_ACTIVE_ENTRIES__REQ_LOCK_TYPE = 32768,
	P4_EVENT_BSQ_ACTIVE_ENTRIES__REQ_CACHE_TYPE = 65536,
	P4_EVENT_BSQ_ACTIVE_ENTRIES__REQ_SPLIT_TYPE = 131072,
	P4_EVENT_BSQ_ACTIVE_ENTRIES__REQ_DEM_TYPE = 262144,
	P4_EVENT_BSQ_ACTIVE_ENTRIES__REQ_ORD_TYPE = 524288,
	P4_EVENT_BSQ_ACTIVE_ENTRIES__MEM_TYPE0 = 1048576,
	P4_EVENT_BSQ_ACTIVE_ENTRIES__MEM_TYPE1 = 2097152,
	P4_EVENT_BSQ_ACTIVE_ENTRIES__MEM_TYPE2 = 4194304,
	P4_EVENT_SSE_INPUT_ASSIST__ALL = 16777216,
	P4_EVENT_PACKED_SP_UOP__ALL = 16777216,
	P4_EVENT_PACKED_DP_UOP__ALL = 16777216,
	P4_EVENT_SCALAR_SP_UOP__ALL = 16777216,
	P4_EVENT_SCALAR_DP_UOP__ALL = 16777216,
	P4_EVENT_64BIT_MMX_UOP__ALL = 16777216,
	P4_EVENT_128BIT_MMX_UOP__ALL = 16777216,
	P4_EVENT_X87_FP_UOP__ALL = 16777216,
	P4_EVENT_TC_MISC__FLUSH = 8192,
	P4_EVENT_GLOBAL_POWER_EVENTS__RUNNING = 512,
	P4_EVENT_TC_MS_XFER__CISC = 512,
	P4_EVENT_UOP_QUEUE_WRITES__FROM_TC_BUILD = 512,
	P4_EVENT_UOP_QUEUE_WRITES__FROM_TC_DELIVER = 1024,
	P4_EVENT_UOP_QUEUE_WRITES__FROM_ROM = 2048,
	P4_EVENT_RETIRED_MISPRED_BRANCH_TYPE__CONDITIONAL = 1024,
	P4_EVENT_RETIRED_MISPRED_BRANCH_TYPE__CALL = 2048,
	P4_EVENT_RETIRED_MISPRED_BRANCH_TYPE__RETURN = 4096,
	P4_EVENT_RETIRED_MISPRED_BRANCH_TYPE__INDIRECT = 8192,
	P4_EVENT_RETIRED_BRANCH_TYPE__CONDITIONAL = 1024,
	P4_EVENT_RETIRED_BRANCH_TYPE__CALL = 2048,
	P4_EVENT_RETIRED_BRANCH_TYPE__RETURN = 4096,
	P4_EVENT_RETIRED_BRANCH_TYPE__INDIRECT = 8192,
	P4_EVENT_RESOURCE_STALL__SBFULL = 16384,
	P4_EVENT_WC_BUFFER__WCB_EVICTS = 512,
	P4_EVENT_WC_BUFFER__WCB_FULL_EVICTS = 1024,
	P4_EVENT_FRONT_END_EVENT__NBOGUS = 512,
	P4_EVENT_FRONT_END_EVENT__BOGUS = 1024,
	P4_EVENT_EXECUTION_EVENT__NBOGUS0 = 512,
	P4_EVENT_EXECUTION_EVENT__NBOGUS1 = 1024,
	P4_EVENT_EXECUTION_EVENT__NBOGUS2 = 2048,
	P4_EVENT_EXECUTION_EVENT__NBOGUS3 = 4096,
	P4_EVENT_EXECUTION_EVENT__BOGUS0 = 8192,
	P4_EVENT_EXECUTION_EVENT__BOGUS1 = 16384,
	P4_EVENT_EXECUTION_EVENT__BOGUS2 = 32768,
	P4_EVENT_EXECUTION_EVENT__BOGUS3 = 65536,
	P4_EVENT_REPLAY_EVENT__NBOGUS = 512,
	P4_EVENT_REPLAY_EVENT__BOGUS = 1024,
	P4_EVENT_INSTR_RETIRED__NBOGUSNTAG = 512,
	P4_EVENT_INSTR_RETIRED__NBOGUSTAG = 1024,
	P4_EVENT_INSTR_RETIRED__BOGUSNTAG = 2048,
	P4_EVENT_INSTR_RETIRED__BOGUSTAG = 4096,
	P4_EVENT_UOPS_RETIRED__NBOGUS = 512,
	P4_EVENT_UOPS_RETIRED__BOGUS = 1024,
	P4_EVENT_UOP_TYPE__TAGLOADS = 1024,
	P4_EVENT_UOP_TYPE__TAGSTORES = 2048,
	P4_EVENT_BRANCH_RETIRED__MMNP = 512,
	P4_EVENT_BRANCH_RETIRED__MMNM = 1024,
	P4_EVENT_BRANCH_RETIRED__MMTP = 2048,
	P4_EVENT_BRANCH_RETIRED__MMTM = 4096,
	P4_EVENT_MISPRED_BRANCH_RETIRED__NBOGUS = 512,
	P4_EVENT_X87_ASSIST__FPSU = 512,
	P4_EVENT_X87_ASSIST__FPSO = 1024,
	P4_EVENT_X87_ASSIST__POAO = 2048,
	P4_EVENT_X87_ASSIST__POAU = 4096,
	P4_EVENT_X87_ASSIST__PREA = 8192,
	P4_EVENT_MACHINE_CLEAR__CLEAR = 512,
	P4_EVENT_MACHINE_CLEAR__MOCLEAR = 1024,
	P4_EVENT_MACHINE_CLEAR__SMCLEAR = 2048,
	P4_EVENT_INSTR_COMPLETED__NBOGUS = 512,
	P4_EVENT_INSTR_COMPLETED__BOGUS = 1024,
};

enum P4_EVENTS {
	P4_EVENT_TC_DELIVER_MODE = 0,
	P4_EVENT_BPU_FETCH_REQUEST = 1,
	P4_EVENT_ITLB_REFERENCE = 2,
	P4_EVENT_MEMORY_CANCEL = 3,
	P4_EVENT_MEMORY_COMPLETE = 4,
	P4_EVENT_LOAD_PORT_REPLAY = 5,
	P4_EVENT_STORE_PORT_REPLAY = 6,
	P4_EVENT_MOB_LOAD_REPLAY = 7,
	P4_EVENT_PAGE_WALK_TYPE = 8,
	P4_EVENT_BSQ_CACHE_REFERENCE = 9,
	P4_EVENT_IOQ_ALLOCATION = 10,
	P4_EVENT_IOQ_ACTIVE_ENTRIES = 11,
	P4_EVENT_FSB_DATA_ACTIVITY = 12,
	P4_EVENT_BSQ_ALLOCATION = 13,
	P4_EVENT_BSQ_ACTIVE_ENTRIES = 14,
	P4_EVENT_SSE_INPUT_ASSIST = 15,
	P4_EVENT_PACKED_SP_UOP = 16,
	P4_EVENT_PACKED_DP_UOP = 17,
	P4_EVENT_SCALAR_SP_UOP = 18,
	P4_EVENT_SCALAR_DP_UOP = 19,
	P4_EVENT_64BIT_MMX_UOP = 20,
	P4_EVENT_128BIT_MMX_UOP = 21,
	P4_EVENT_X87_FP_UOP = 22,
	P4_EVENT_TC_MISC = 23,
	P4_EVENT_GLOBAL_POWER_EVENTS = 24,
	P4_EVENT_TC_MS_XFER = 25,
	P4_EVENT_UOP_QUEUE_WRITES = 26,
	P4_EVENT_RETIRED_MISPRED_BRANCH_TYPE = 27,
	P4_EVENT_RETIRED_BRANCH_TYPE = 28,
	P4_EVENT_RESOURCE_STALL = 29,
	P4_EVENT_WC_BUFFER = 30,
	P4_EVENT_B2B_CYCLES = 31,
	P4_EVENT_BNR = 32,
	P4_EVENT_SNOOP = 33,
	P4_EVENT_RESPONSE = 34,
	P4_EVENT_FRONT_END_EVENT = 35,
	P4_EVENT_EXECUTION_EVENT = 36,
	P4_EVENT_REPLAY_EVENT = 37,
	P4_EVENT_INSTR_RETIRED = 38,
	P4_EVENT_UOPS_RETIRED = 39,
	P4_EVENT_UOP_TYPE = 40,
	P4_EVENT_BRANCH_RETIRED = 41,
	P4_EVENT_MISPRED_BRANCH_RETIRED = 42,
	P4_EVENT_X87_ASSIST = 43,
	P4_EVENT_MACHINE_CLEAR = 44,
	P4_EVENT_INSTR_COMPLETED = 45,
};

enum P4_EVENT_OPCODES {
	P4_EVENT_TC_DELIVER_MODE_OPCODE = 257,
	P4_EVENT_BPU_FETCH_REQUEST_OPCODE = 768,
	P4_EVENT_ITLB_REFERENCE_OPCODE = 6147,
	P4_EVENT_MEMORY_CANCEL_OPCODE = 517,
	P4_EVENT_MEMORY_COMPLETE_OPCODE = 2050,
	P4_EVENT_LOAD_PORT_REPLAY_OPCODE = 1026,
	P4_EVENT_STORE_PORT_REPLAY_OPCODE = 1282,
	P4_EVENT_MOB_LOAD_REPLAY_OPCODE = 770,
	P4_EVENT_PAGE_WALK_TYPE_OPCODE = 260,
	P4_EVENT_BSQ_CACHE_REFERENCE_OPCODE = 3079,
	P4_EVENT_IOQ_ALLOCATION_OPCODE = 774,
	P4_EVENT_IOQ_ACTIVE_ENTRIES_OPCODE = 6662,
	P4_EVENT_FSB_DATA_ACTIVITY_OPCODE = 5894,
	P4_EVENT_BSQ_ALLOCATION_OPCODE = 1287,
	P4_EVENT_BSQ_ACTIVE_ENTRIES_OPCODE = 1543,
	P4_EVENT_SSE_INPUT_ASSIST_OPCODE = 13313,
	P4_EVENT_PACKED_SP_UOP_OPCODE = 2049,
	P4_EVENT_PACKED_DP_UOP_OPCODE = 3073,
	P4_EVENT_SCALAR_SP_UOP_OPCODE = 2561,
	P4_EVENT_SCALAR_DP_UOP_OPCODE = 3585,
	P4_EVENT_64BIT_MMX_UOP_OPCODE = 513,
	P4_EVENT_128BIT_MMX_UOP_OPCODE = 6657,
	P4_EVENT_X87_FP_UOP_OPCODE = 1025,
	P4_EVENT_TC_MISC_OPCODE = 1537,
	P4_EVENT_GLOBAL_POWER_EVENTS_OPCODE = 4870,
	P4_EVENT_TC_MS_XFER_OPCODE = 1280,
	P4_EVENT_UOP_QUEUE_WRITES_OPCODE = 2304,
	P4_EVENT_RETIRED_MISPRED_BRANCH_TYPE_OPCODE = 1282,
	P4_EVENT_RETIRED_BRANCH_TYPE_OPCODE = 1026,
	P4_EVENT_RESOURCE_STALL_OPCODE = 257,
	P4_EVENT_WC_BUFFER_OPCODE = 1285,
	P4_EVENT_B2B_CYCLES_OPCODE = 5635,
	P4_EVENT_BNR_OPCODE = 2051,
	P4_EVENT_SNOOP_OPCODE = 1539,
	P4_EVENT_RESPONSE_OPCODE = 1027,
	P4_EVENT_FRONT_END_EVENT_OPCODE = 2053,
	P4_EVENT_EXECUTION_EVENT_OPCODE = 3077,
	P4_EVENT_REPLAY_EVENT_OPCODE = 2309,
	P4_EVENT_INSTR_RETIRED_OPCODE = 516,
	P4_EVENT_UOPS_RETIRED_OPCODE = 260,
	P4_EVENT_UOP_TYPE_OPCODE = 514,
	P4_EVENT_BRANCH_RETIRED_OPCODE = 1541,
	P4_EVENT_MISPRED_BRANCH_RETIRED_OPCODE = 772,
	P4_EVENT_X87_ASSIST_OPCODE = 773,
	P4_EVENT_MACHINE_CLEAR_OPCODE = 517,
	P4_EVENT_INSTR_COMPLETED_OPCODE = 1796,
};

enum P4_PEBS_METRIC {
	P4_PEBS_METRIC__none = 0,
	P4_PEBS_METRIC__1stl_cache_load_miss_retired = 1,
	P4_PEBS_METRIC__2ndl_cache_load_miss_retired = 2,
	P4_PEBS_METRIC__dtlb_load_miss_retired = 3,
	P4_PEBS_METRIC__dtlb_store_miss_retired = 4,
	P4_PEBS_METRIC__dtlb_all_miss_retired = 5,
	P4_PEBS_METRIC__tagged_mispred_branch = 6,
	P4_PEBS_METRIC__mob_load_replay_retired = 7,
	P4_PEBS_METRIC__split_load_retired = 8,
	P4_PEBS_METRIC__split_store_retired = 9,
	P4_PEBS_METRIC__max = 10,
};

enum RTL8139_registers {
	MAC0 = 0,
	MAR0 = 8,
	TxStatus0 = 16,
	TxAddr0 = 32,
	RxBuf = 48,
	ChipCmd = 55,
	RxBufPtr = 56,
	RxBufAddr = 58,
	IntrMask = 60,
	IntrStatus = 62,
	TxConfig = 64,
	RxConfig = 68,
	Timer = 72,
	RxMissed = 76,
	Cfg9346 = 80,
	Config0 = 81,
	Config1 = 82,
	TimerInt = 84,
	MediaStatus = 88,
	Config3 = 89,
	Config4 = 90,
	HltClk = 91,
	MultiIntr = 92,
	TxSummary = 96,
	BasicModeCtrl = 98,
	BasicModeStatus = 100,
	NWayAdvert = 102,
	NWayLPAR = 104,
	NWayExpansion = 106,
	FIFOTMS = 112,
	CSCR = 116,
	PARA78 = 120,
	FlashReg = 212,
	PARA7c = 124,
	Config5 = 216,
};

enum RxStatusBits {
	RxMulticast = 32768,
	RxPhysical = 16384,
	RxBroadcast = 8192,
	RxBadSymbol = 32,
	RxRunt = 16,
	RxTooLong = 8,
	RxCRCErr = 4,
	RxBadAlign = 2,
	RxStatusOK = 1,
};

enum SHIFT_DIRECTION {
	SHIFT_LEFT = 0,
	SHIFT_RIGHT = 1,
};

enum SS4_PACKET_ID {
	SS4_PACKET_ID_IDLE = 0,
	SS4_PACKET_ID_ONE = 1,
	SS4_PACKET_ID_TWO = 2,
	SS4_PACKET_ID_MULTI = 3,
	SS4_PACKET_ID_STICK = 4,
};

enum TG3_FLAGS {
	TG3_FLAG_TAGGED_STATUS = 0,
	TG3_FLAG_TXD_MBOX_HWBUG = 1,
	TG3_FLAG_USE_LINKCHG_REG = 2,
	TG3_FLAG_ERROR_PROCESSED = 3,
	TG3_FLAG_ENABLE_ASF = 4,
	TG3_FLAG_ASPM_WORKAROUND = 5,
	TG3_FLAG_POLL_SERDES = 6,
	TG3_FLAG_POLL_CPMU_LINK = 7,
	TG3_FLAG_MBOX_WRITE_REORDER = 8,
	TG3_FLAG_PCIX_TARGET_HWBUG = 9,
	TG3_FLAG_WOL_SPEED_100MB = 10,
	TG3_FLAG_WOL_ENABLE = 11,
	TG3_FLAG_EEPROM_WRITE_PROT = 12,
	TG3_FLAG_NVRAM = 13,
	TG3_FLAG_NVRAM_BUFFERED = 14,
	TG3_FLAG_SUPPORT_MSI = 15,
	TG3_FLAG_SUPPORT_MSIX = 16,
	TG3_FLAG_USING_MSI = 17,
	TG3_FLAG_USING_MSIX = 18,
	TG3_FLAG_PCIX_MODE = 19,
	TG3_FLAG_PCI_HIGH_SPEED = 20,
	TG3_FLAG_PCI_32BIT = 21,
	TG3_FLAG_SRAM_USE_CONFIG = 22,
	TG3_FLAG_TX_RECOVERY_PENDING = 23,
	TG3_FLAG_WOL_CAP = 24,
	TG3_FLAG_JUMBO_RING_ENABLE = 25,
	TG3_FLAG_PAUSE_AUTONEG = 26,
	TG3_FLAG_CPMU_PRESENT = 27,
	TG3_FLAG_40BIT_DMA_BUG = 28,
	TG3_FLAG_BROKEN_CHECKSUMS = 29,
	TG3_FLAG_JUMBO_CAPABLE = 30,
	TG3_FLAG_CHIP_RESETTING = 31,
	TG3_FLAG_INIT_COMPLETE = 32,
	TG3_FLAG_MAX_RXPEND_64 = 33,
	TG3_FLAG_PCI_EXPRESS = 34,
	TG3_FLAG_ASF_NEW_HANDSHAKE = 35,
	TG3_FLAG_HW_AUTONEG = 36,
	TG3_FLAG_IS_NIC = 37,
	TG3_FLAG_FLASH = 38,
	TG3_FLAG_FW_TSO = 39,
	TG3_FLAG_HW_TSO_1 = 40,
	TG3_FLAG_HW_TSO_2 = 41,
	TG3_FLAG_HW_TSO_3 = 42,
	TG3_FLAG_TSO_CAPABLE = 43,
	TG3_FLAG_TSO_BUG = 44,
	TG3_FLAG_ICH_WORKAROUND = 45,
	TG3_FLAG_1SHOT_MSI = 46,
	TG3_FLAG_NO_FWARE_REPORTED = 47,
	TG3_FLAG_NO_NVRAM_ADDR_TRANS = 48,
	TG3_FLAG_ENABLE_APE = 49,
	TG3_FLAG_PROTECTED_NVRAM = 50,
	TG3_FLAG_5701_DMA_BUG = 51,
	TG3_FLAG_USE_PHYLIB = 52,
	TG3_FLAG_MDIOBUS_INITED = 53,
	TG3_FLAG_LRG_PROD_RING_CAP = 54,
	TG3_FLAG_RGMII_INBAND_DISABLE = 55,
	TG3_FLAG_RGMII_EXT_IBND_RX_EN = 56,
	TG3_FLAG_RGMII_EXT_IBND_TX_EN = 57,
	TG3_FLAG_CLKREQ_BUG = 58,
	TG3_FLAG_NO_NVRAM = 59,
	TG3_FLAG_ENABLE_RSS = 60,
	TG3_FLAG_ENABLE_TSS = 61,
	TG3_FLAG_SHORT_DMA_BUG = 62,
	TG3_FLAG_USE_JUMBO_BDFLAG = 63,
	TG3_FLAG_L1PLLPD_EN = 64,
	TG3_FLAG_APE_HAS_NCSI = 65,
	TG3_FLAG_TX_TSTAMP_EN = 66,
	TG3_FLAG_4K_FIFO_LIMIT = 67,
	TG3_FLAG_5719_5720_RDMA_BUG = 68,
	TG3_FLAG_RESET_TASK_PENDING = 69,
	TG3_FLAG_PTP_CAPABLE = 70,
	TG3_FLAG_5705_PLUS = 71,
	TG3_FLAG_IS_5788 = 72,
	TG3_FLAG_5750_PLUS = 73,
	TG3_FLAG_5780_CLASS = 74,
	TG3_FLAG_5755_PLUS = 75,
	TG3_FLAG_57765_PLUS = 76,
	TG3_FLAG_57765_CLASS = 77,
	TG3_FLAG_5717_PLUS = 78,
	TG3_FLAG_IS_SSB_CORE = 79,
	TG3_FLAG_FLUSH_POSTED_WRITES = 80,
	TG3_FLAG_ROBOSWITCH = 81,
	TG3_FLAG_ONE_DMA_AT_ONCE = 82,
	TG3_FLAG_RGMII_MODE = 83,
	TG3_FLAG_NUMBER_OF_FLAGS = 84,
};

enum TxStatusBits {
	TxHostOwns = 8192,
	TxUnderrun = 16384,
	TxStatOK = 32768,
	TxOutOfWindow = 536870912,
	TxAborted = 1073741824,
	TxCarrierLost = 2147483648,
};

enum V7_PACKET_ID {
	V7_PACKET_ID_IDLE = 0,
	V7_PACKET_ID_TWO = 1,
	V7_PACKET_ID_MULTI = 2,
	V7_PACKET_ID_NEW = 3,
	V7_PACKET_ID_UNKNOWN = 4,
};

enum ___mac80211_drop_reason {
	___RX_CONTINUE = 1,
	___RX_QUEUED = 0,
	___RX_DROP_MONITOR = 131072,
	___RX_DROP_M_UNEXPECTED_4ADDR_FRAME = 131073,
	___RX_DROP_M_BAD_BCN_KEYIDX = 131074,
	___RX_DROP_M_BAD_MGMT_KEYIDX = 131075,
	___RX_DROP_UNUSABLE = 65536,
	___RX_DROP_U_MIC_FAIL = 65537,
	___RX_DROP_U_REPLAY = 65538,
	___RX_DROP_U_BAD_MMIE = 65539,
	___RX_DROP_U_DUP = 65540,
	___RX_DROP_U_SPURIOUS = 65541,
	___RX_DROP_U_DECRYPT_FAIL = 65542,
	___RX_DROP_U_NO_KEY_ID = 65543,
	___RX_DROP_U_BAD_CIPHER = 65544,
	___RX_DROP_U_OOM = 65545,
	___RX_DROP_U_NONSEQ_PN = 65546,
	___RX_DROP_U_BAD_KEY_COLOR = 65547,
	___RX_DROP_U_BAD_4ADDR = 65548,
	___RX_DROP_U_BAD_AMSDU = 65549,
	___RX_DROP_U_BAD_AMSDU_CIPHER = 65550,
	___RX_DROP_U_INVALID_8023 = 65551,
	___RX_DROP_U_RUNT_ACTION = 65552,
	___RX_DROP_U_UNPROT_ACTION = 65553,
	___RX_DROP_U_UNPROT_DUAL = 65554,
	___RX_DROP_U_UNPROT_UCAST_MGMT = 65555,
	___RX_DROP_U_UNPROT_MCAST_MGMT = 65556,
	___RX_DROP_U_UNPROT_BEACON = 65557,
	___RX_DROP_U_UNPROT_UNICAST_PUB_ACTION = 65558,
	___RX_DROP_U_UNPROT_ROBUST_ACTION = 65559,
	___RX_DROP_U_ACTION_UNKNOWN_SRC = 65560,
	___RX_DROP_U_REJECTED_ACTION_RESPONSE = 65561,
	___RX_DROP_U_EXPECT_DEFRAG_PROT = 65562,
	___RX_DROP_U_WEP_DEC_FAIL = 65563,
	___RX_DROP_U_NO_IV = 65564,
	___RX_DROP_U_NO_ICV = 65565,
	___RX_DROP_U_AP_RX_GROUPCAST = 65566,
	___RX_DROP_U_SHORT_MMIC = 65567,
	___RX_DROP_U_MMIC_FAIL = 65568,
	___RX_DROP_U_SHORT_TKIP = 65569,
	___RX_DROP_U_TKIP_FAIL = 65570,
	___RX_DROP_U_SHORT_CCMP = 65571,
	___RX_DROP_U_SHORT_CCMP_MIC = 65572,
	___RX_DROP_U_SHORT_GCMP = 65573,
	___RX_DROP_U_SHORT_GCMP_MIC = 65574,
	___RX_DROP_U_SHORT_CMAC = 65575,
	___RX_DROP_U_SHORT_CMAC256 = 65576,
	___RX_DROP_U_SHORT_GMAC = 65577,
	___RX_DROP_U_UNEXPECTED_VLAN_4ADDR = 65578,
	___RX_DROP_U_UNEXPECTED_STA_4ADDR = 65579,
	___RX_DROP_U_UNEXPECTED_VLAN_MCAST = 65580,
	___RX_DROP_U_NOT_PORT_CONTROL = 65581,
	___RX_DROP_U_UNKNOWN_ACTION_REJECTED = 65582,
};

enum __sk_action {
	__SK_DROP = 0,
	__SK_PASS = 1,
	__SK_REDIRECT = 2,
	__SK_NONE = 3,
};

enum _cache_type {
	CTYPE_NULL = 0,
	CTYPE_DATA = 1,
	CTYPE_INST = 2,
	CTYPE_UNIFIED = 3,
};

enum _slab_flag_bits {
	_SLAB_CONSISTENCY_CHECKS = 0,
	_SLAB_RED_ZONE = 1,
	_SLAB_POISON = 2,
	_SLAB_KMALLOC = 3,
	_SLAB_HWCACHE_ALIGN = 4,
	_SLAB_CACHE_DMA = 5,
	_SLAB_CACHE_DMA32 = 6,
	_SLAB_STORE_USER = 7,
	_SLAB_PANIC = 8,
	_SLAB_TYPESAFE_BY_RCU = 9,
	_SLAB_TRACE = 10,
	_SLAB_NOLEAKTRACE = 11,
	_SLAB_NO_MERGE = 12,
	_SLAB_NO_USER_FLAGS = 13,
	_SLAB_RECLAIM_ACCOUNT = 14,
	_SLAB_OBJECT_POISON = 15,
	_SLAB_CMPXCHG_DOUBLE = 16,
	_SLAB_FLAGS_LAST_BIT = 17,
};

enum access_coordinate_class {
	ACCESS_COORDINATE_LOCAL = 0,
	ACCESS_COORDINATE_CPU = 1,
	ACCESS_COORDINATE_MAX = 2,
};

enum ack_type {
	ACK_CLEAR = 0,
	ACK_SET = 1,
};

enum acpi_attr_enum {
	ACPI_ATTR_LABEL_SHOW = 0,
	ACPI_ATTR_INDEX_SHOW = 1,
};

enum acpi_backlight_type {
	acpi_backlight_undef = -1,
	acpi_backlight_none = 0,
	acpi_backlight_video = 1,
	acpi_backlight_vendor = 2,
	acpi_backlight_native = 3,
	acpi_backlight_nvidia_wmi_ec = 4,
	acpi_backlight_apple_gmux = 5,
	acpi_backlight_dell_uart = 6,
};

enum acpi_bridge_type {
	ACPI_BRIDGE_TYPE_PCIE = 1,
	ACPI_BRIDGE_TYPE_CXL = 2,
};

enum acpi_bus_device_type {
	ACPI_BUS_TYPE_DEVICE = 0,
	ACPI_BUS_TYPE_POWER = 1,
	ACPI_BUS_TYPE_PROCESSOR = 2,
	ACPI_BUS_TYPE_THERMAL = 3,
	ACPI_BUS_TYPE_POWER_BUTTON = 4,
	ACPI_BUS_TYPE_SLEEP_BUTTON = 5,
	ACPI_BUS_TYPE_ECDT_EC = 6,
	ACPI_BUS_DEVICE_TYPE_COUNT = 7,
};

enum acpi_cdat_type {
	ACPI_CDAT_TYPE_DSMAS = 0,
	ACPI_CDAT_TYPE_DSLBIS = 1,
	ACPI_CDAT_TYPE_DSMSCIS = 2,
	ACPI_CDAT_TYPE_DSIS = 3,
	ACPI_CDAT_TYPE_DSEMTS = 4,
	ACPI_CDAT_TYPE_SSLBIS = 5,
	ACPI_CDAT_TYPE_RESERVED = 6,
};

enum acpi_cedt_type {
	ACPI_CEDT_TYPE_CHBS = 0,
	ACPI_CEDT_TYPE_CFMWS = 1,
	ACPI_CEDT_TYPE_CXIMS = 2,
	ACPI_CEDT_TYPE_RDPAS = 3,
	ACPI_CEDT_TYPE_RESERVED = 4,
};

enum acpi_device_swnode_dev_props {
	ACPI_DEVICE_SWNODE_DEV_ROTATION = 0,
	ACPI_DEVICE_SWNODE_DEV_CLOCK_FREQUENCY = 1,
	ACPI_DEVICE_SWNODE_DEV_LED_MAX_MICROAMP = 2,
	ACPI_DEVICE_SWNODE_DEV_FLASH_MAX_MICROAMP = 3,
	ACPI_DEVICE_SWNODE_DEV_FLASH_MAX_TIMEOUT_US = 4,
	ACPI_DEVICE_SWNODE_DEV_NUM_OF = 5,
	ACPI_DEVICE_SWNODE_DEV_NUM_ENTRIES = 6,
};

enum acpi_device_swnode_ep_props {
	ACPI_DEVICE_SWNODE_EP_REMOTE_EP = 0,
	ACPI_DEVICE_SWNODE_EP_BUS_TYPE = 1,
	ACPI_DEVICE_SWNODE_EP_REG = 2,
	ACPI_DEVICE_SWNODE_EP_CLOCK_LANES = 3,
	ACPI_DEVICE_SWNODE_EP_DATA_LANES = 4,
	ACPI_DEVICE_SWNODE_EP_LANE_POLARITIES = 5,
	ACPI_DEVICE_SWNODE_EP_LINK_FREQUENCIES = 6,
	ACPI_DEVICE_SWNODE_EP_NUM_OF = 7,
	ACPI_DEVICE_SWNODE_EP_NUM_ENTRIES = 8,
};

enum acpi_device_swnode_port_props {
	ACPI_DEVICE_SWNODE_PORT_REG = 0,
	ACPI_DEVICE_SWNODE_PORT_NUM_OF = 1,
	ACPI_DEVICE_SWNODE_PORT_NUM_ENTRIES = 2,
};

enum acpi_dmar_scope_type {
	ACPI_DMAR_SCOPE_TYPE_NOT_USED = 0,
	ACPI_DMAR_SCOPE_TYPE_ENDPOINT = 1,
	ACPI_DMAR_SCOPE_TYPE_BRIDGE = 2,
	ACPI_DMAR_SCOPE_TYPE_IOAPIC = 3,
	ACPI_DMAR_SCOPE_TYPE_HPET = 4,
	ACPI_DMAR_SCOPE_TYPE_NAMESPACE = 5,
	ACPI_DMAR_SCOPE_TYPE_RESERVED = 6,
};

enum acpi_dmar_type {
	ACPI_DMAR_TYPE_HARDWARE_UNIT = 0,
	ACPI_DMAR_TYPE_RESERVED_MEMORY = 1,
	ACPI_DMAR_TYPE_ROOT_ATS = 2,
	ACPI_DMAR_TYPE_HARDWARE_AFFINITY = 3,
	ACPI_DMAR_TYPE_NAMESPACE = 4,
	ACPI_DMAR_TYPE_SATC = 5,
	ACPI_DMAR_TYPE_RESERVED = 6,
};

enum acpi_ec_event_state {
	EC_EVENT_READY = 0,
	EC_EVENT_IN_PROGRESS = 1,
	EC_EVENT_COMPLETE = 2,
};

enum acpi_irq_model_id {
	ACPI_IRQ_MODEL_PIC = 0,
	ACPI_IRQ_MODEL_IOAPIC = 1,
	ACPI_IRQ_MODEL_IOSAPIC = 2,
	ACPI_IRQ_MODEL_PLATFORM = 3,
	ACPI_IRQ_MODEL_GIC = 4,
	ACPI_IRQ_MODEL_LPIC = 5,
	ACPI_IRQ_MODEL_RINTC = 6,
	ACPI_IRQ_MODEL_COUNT = 7,
};

enum acpi_madt_multiproc_wakeup_version {
	ACPI_MADT_MP_WAKEUP_VERSION_NONE = 0,
	ACPI_MADT_MP_WAKEUP_VERSION_V1 = 1,
	ACPI_MADT_MP_WAKEUP_VERSION_RESERVED = 2,
};

enum acpi_madt_type {
	ACPI_MADT_TYPE_LOCAL_APIC = 0,
	ACPI_MADT_TYPE_IO_APIC = 1,
	ACPI_MADT_TYPE_INTERRUPT_OVERRIDE = 2,
	ACPI_MADT_TYPE_NMI_SOURCE = 3,
	ACPI_MADT_TYPE_LOCAL_APIC_NMI = 4,
	ACPI_MADT_TYPE_LOCAL_APIC_OVERRIDE = 5,
	ACPI_MADT_TYPE_IO_SAPIC = 6,
	ACPI_MADT_TYPE_LOCAL_SAPIC = 7,
	ACPI_MADT_TYPE_INTERRUPT_SOURCE = 8,
	ACPI_MADT_TYPE_LOCAL_X2APIC = 9,
	ACPI_MADT_TYPE_LOCAL_X2APIC_NMI = 10,
	ACPI_MADT_TYPE_GENERIC_INTERRUPT = 11,
	ACPI_MADT_TYPE_GENERIC_DISTRIBUTOR = 12,
	ACPI_MADT_TYPE_GENERIC_MSI_FRAME = 13,
	ACPI_MADT_TYPE_GENERIC_REDISTRIBUTOR = 14,
	ACPI_MADT_TYPE_GENERIC_TRANSLATOR = 15,
	ACPI_MADT_TYPE_MULTIPROC_WAKEUP = 16,
	ACPI_MADT_TYPE_CORE_PIC = 17,
	ACPI_MADT_TYPE_LIO_PIC = 18,
	ACPI_MADT_TYPE_HT_PIC = 19,
	ACPI_MADT_TYPE_EIO_PIC = 20,
	ACPI_MADT_TYPE_MSI_PIC = 21,
	ACPI_MADT_TYPE_BIO_PIC = 22,
	ACPI_MADT_TYPE_LPC_PIC = 23,
	ACPI_MADT_TYPE_RINTC = 24,
	ACPI_MADT_TYPE_IMSIC = 25,
	ACPI_MADT_TYPE_APLIC = 26,
	ACPI_MADT_TYPE_PLIC = 27,
	ACPI_MADT_TYPE_RESERVED = 28,
	ACPI_MADT_TYPE_OEM_RESERVED = 128,
};

enum acpi_pcct_type {
	ACPI_PCCT_TYPE_GENERIC_SUBSPACE = 0,
	ACPI_PCCT_TYPE_HW_REDUCED_SUBSPACE = 1,
	ACPI_PCCT_TYPE_HW_REDUCED_SUBSPACE_TYPE2 = 2,
	ACPI_PCCT_TYPE_EXT_PCC_MASTER_SUBSPACE = 3,
	ACPI_PCCT_TYPE_EXT_PCC_SLAVE_SUBSPACE = 4,
	ACPI_PCCT_TYPE_HW_REG_COMM_SUBSPACE = 5,
	ACPI_PCCT_TYPE_RESERVED = 6,
};

enum acpi_predicate {
	all_versions = 0,
	less_than_or_equal = 1,
	equal = 2,
	greater_than_or_equal = 3,
};

enum acpi_preferred_pm_profiles {
	PM_UNSPECIFIED = 0,
	PM_DESKTOP = 1,
	PM_MOBILE = 2,
	PM_WORKSTATION = 3,
	PM_ENTERPRISE_SERVER = 4,
	PM_SOHO_SERVER = 5,
	PM_APPLIANCE_PC = 6,
	PM_PERFORMANCE_SERVER = 7,
	PM_TABLET = 8,
	NR_PM_PROFILES = 9,
};

enum acpi_reconfig_event {
	ACPI_RECONFIG_DEVICE_ADD = 0,
	ACPI_RECONFIG_DEVICE_REMOVE = 1,
};

enum acpi_return_package_types {
	ACPI_PTYPE1_FIXED = 1,
	ACPI_PTYPE1_VAR = 2,
	ACPI_PTYPE1_OPTION = 3,
	ACPI_PTYPE2 = 4,
	ACPI_PTYPE2_COUNT = 5,
	ACPI_PTYPE2_PKG_COUNT = 6,
	ACPI_PTYPE2_FIXED = 7,
	ACPI_PTYPE2_MIN = 8,
	ACPI_PTYPE2_REV_FIXED = 9,
	ACPI_PTYPE2_FIX_VAR = 10,
	ACPI_PTYPE2_VAR_VAR = 11,
	ACPI_PTYPE2_UUID_PAIR = 12,
	ACPI_PTYPE_CUSTOM = 13,
};

enum acpi_srat_type {
	ACPI_SRAT_TYPE_CPU_AFFINITY = 0,
	ACPI_SRAT_TYPE_MEMORY_AFFINITY = 1,
	ACPI_SRAT_TYPE_X2APIC_CPU_AFFINITY = 2,
	ACPI_SRAT_TYPE_GICC_AFFINITY = 3,
	ACPI_SRAT_TYPE_GIC_ITS_AFFINITY = 4,
	ACPI_SRAT_TYPE_GENERIC_AFFINITY = 5,
	ACPI_SRAT_TYPE_GENERIC_PORT_AFFINITY = 6,
	ACPI_SRAT_TYPE_RINTC_AFFINITY = 7,
	ACPI_SRAT_TYPE_RESERVED = 8,
};

enum acpi_subtable_type {
	ACPI_SUBTABLE_COMMON = 0,
	ACPI_SUBTABLE_HMAT = 1,
	ACPI_SUBTABLE_PRMT = 2,
	ACPI_SUBTABLE_CEDT = 3,
	CDAT_SUBTABLE = 4,
};

enum acpi_video_level_idx {
	ACPI_VIDEO_AC_LEVEL = 0,
	ACPI_VIDEO_BATTERY_LEVEL = 1,
	ACPI_VIDEO_FIRST_LEVEL = 2,
};

enum actions {
	REGISTER = 0,
	DEREGISTER = 1,
	CPU_DONT_CARE = 2,
};

enum addr_type_t {
	UNICAST_ADDR = 0,
	MULTICAST_ADDR = 1,
	ANYCAST_ADDR = 2,
};

enum address_markers_idx {
	USER_SPACE_NR = 0,
	KERNEL_SPACE_NR = 1,
	LDT_NR = 2,
	LOW_KERNEL_NR = 3,
	VMALLOC_START_NR = 4,
	VMEMMAP_START_NR = 5,
	CPU_ENTRY_AREA_NR = 6,
	ESPFIX_START_NR = 7,
	EFI_END_NR = 8,
	HIGH_KERNEL_NR = 9,
	MODULES_VADDR_NR = 10,
	MODULES_END_NR = 11,
	FIXADDR_START_NR = 12,
	END_OF_SPACE_NR = 13,
};

enum alarmtimer_type {
	ALARM_REALTIME = 0,
	ALARM_BOOTTIME = 1,
	ALARM_NUMTYPE = 2,
	ALARM_REALTIME_FREEZER = 3,
	ALARM_BOOTTIME_FREEZER = 4,
};

enum align_flags {
	ALIGN_VA_32 = 1,
	ALIGN_VA_64 = 2,
};

enum allow_write_msrs {
	MSR_WRITES_ON = 0,
	MSR_WRITES_OFF = 1,
	MSR_WRITES_DEFAULT = 2,
};

enum amd_chipset_gen {
	NOT_AMD_CHIPSET = 0,
	AMD_CHIPSET_SB600 = 1,
	AMD_CHIPSET_SB700 = 2,
	AMD_CHIPSET_SB800 = 3,
	AMD_CHIPSET_HUDSON2 = 4,
	AMD_CHIPSET_BOLTON = 5,
	AMD_CHIPSET_YANGTZE = 6,
	AMD_CHIPSET_TAISHAN = 7,
	AMD_CHIPSET_UNKNOWN = 8,
};

enum amd_iommu_intr_mode_type {
	AMD_IOMMU_GUEST_IR_LEGACY = 0,
	AMD_IOMMU_GUEST_IR_LEGACY_GA = 1,
	AMD_IOMMU_GUEST_IR_VAPIC = 2,
};

enum amd_pref_core {
	AMD_PREF_CORE_UNKNOWN = 0,
	AMD_PREF_CORE_SUPPORTED = 1,
	AMD_PREF_CORE_UNSUPPORTED = 2,
};

enum amd_pstate_mode {
	AMD_PSTATE_UNDEFINED = 0,
	AMD_PSTATE_DISABLE = 1,
	AMD_PSTATE_PASSIVE = 2,
	AMD_PSTATE_ACTIVE = 3,
	AMD_PSTATE_GUIDED = 4,
	AMD_PSTATE_MAX = 5,
};

enum aper_size_type {
	U8_APER_SIZE = 0,
	U16_APER_SIZE = 1,
	U32_APER_SIZE = 2,
	LVL2_APER_SIZE = 3,
	FIXED_APER_SIZE = 4,
};

enum apic_intr_mode_id {
	APIC_PIC = 0,
	APIC_VIRTUAL_WIRE = 1,
	APIC_VIRTUAL_WIRE_NO_CONFIG = 2,
	APIC_SYMMETRIC_IO = 3,
	APIC_SYMMETRIC_IO_NO_ROUTING = 4,
};

enum array_state {
	clear = 0,
	inactive = 1,
	suspended = 2,
	readonly = 3,
	read_auto = 4,
	clean = 5,
	active = 6,
	write_pending = 7,
	active_idle = 8,
	broken = 9,
	bad_word = 10,
};

enum asn1_class {
	ASN1_UNIV = 0,
	ASN1_APPL = 1,
	ASN1_CONT = 2,
	ASN1_PRIV = 3,
};

enum asn1_method {
	ASN1_PRIM = 0,
	ASN1_CONS = 1,
};

enum asn1_opcode {
	ASN1_OP_MATCH = 0,
	ASN1_OP_MATCH_OR_SKIP = 1,
	ASN1_OP_MATCH_ACT = 2,
	ASN1_OP_MATCH_ACT_OR_SKIP = 3,
	ASN1_OP_MATCH_JUMP = 4,
	ASN1_OP_MATCH_JUMP_OR_SKIP = 5,
	ASN1_OP_MATCH_ANY = 8,
	ASN1_OP_MATCH_ANY_OR_SKIP = 9,
	ASN1_OP_MATCH_ANY_ACT = 10,
	ASN1_OP_MATCH_ANY_ACT_OR_SKIP = 11,
	ASN1_OP_COND_MATCH_OR_SKIP = 17,
	ASN1_OP_COND_MATCH_ACT_OR_SKIP = 19,
	ASN1_OP_COND_MATCH_JUMP_OR_SKIP = 21,
	ASN1_OP_COND_MATCH_ANY = 24,
	ASN1_OP_COND_MATCH_ANY_OR_SKIP = 25,
	ASN1_OP_COND_MATCH_ANY_ACT = 26,
	ASN1_OP_COND_MATCH_ANY_ACT_OR_SKIP = 27,
	ASN1_OP_COND_FAIL = 28,
	ASN1_OP_COMPLETE = 29,
	ASN1_OP_ACT = 30,
	ASN1_OP_MAYBE_ACT = 31,
	ASN1_OP_END_SEQ = 32,
	ASN1_OP_END_SET = 33,
	ASN1_OP_END_SEQ_OF = 34,
	ASN1_OP_END_SET_OF = 35,
	ASN1_OP_END_SEQ_ACT = 36,
	ASN1_OP_END_SET_ACT = 37,
	ASN1_OP_END_SEQ_OF_ACT = 38,
	ASN1_OP_END_SET_OF_ACT = 39,
	ASN1_OP_RETURN = 40,
	ASN1_OP__NR = 41,
};

enum asn1_tag {
	ASN1_EOC = 0,
	ASN1_BOOL = 1,
	ASN1_INT = 2,
	ASN1_BTS = 3,
	ASN1_OTS = 4,
	ASN1_NULL = 5,
	ASN1_OID = 6,
	ASN1_ODE = 7,
	ASN1_EXT = 8,
	ASN1_REAL = 9,
	ASN1_ENUM = 10,
	ASN1_EPDV = 11,
	ASN1_UTF8STR = 12,
	ASN1_RELOID = 13,
	ASN1_SEQ = 16,
	ASN1_SET = 17,
	ASN1_NUMSTR = 18,
	ASN1_PRNSTR = 19,
	ASN1_TEXSTR = 20,
	ASN1_VIDSTR = 21,
	ASN1_IA5STR = 22,
	ASN1_UNITIM = 23,
	ASN1_GENTIM = 24,
	ASN1_GRASTR = 25,
	ASN1_VISSTR = 26,
	ASN1_GENSTR = 27,
	ASN1_UNISTR = 28,
	ASN1_CHRSTR = 29,
	ASN1_BMPSTR = 30,
	ASN1_LONG_TAG = 31,
};

enum assoc_array_walk_status {
	assoc_array_walk_tree_empty = 0,
	assoc_array_walk_found_terminal_node = 1,
	assoc_array_walk_found_wrong_shortcut = 2,
};

enum assoc_status {
	ASSOC_SUCCESS = 0,
	ASSOC_REJECTED = 1,
	ASSOC_TIMEOUT = 2,
	ASSOC_ABANDON = 3,
};

enum asymmetric_payload_bits {
	asym_crypto = 0,
	asym_subtype = 1,
	asym_key_ids = 2,
	asym_auth = 3,
};

enum ata_completion_errors {
	AC_ERR_OK = 0,
	AC_ERR_DEV = 1,
	AC_ERR_HSM = 2,
	AC_ERR_TIMEOUT = 4,
	AC_ERR_MEDIA = 8,
	AC_ERR_ATA_BUS = 16,
	AC_ERR_HOST_BUS = 32,
	AC_ERR_SYSTEM = 64,
	AC_ERR_INVALID = 128,
	AC_ERR_OTHER = 256,
	AC_ERR_NODEV_HINT = 512,
	AC_ERR_NCQ = 1024,
};

enum ata_dev_iter_mode {
	ATA_DITER_ENABLED = 0,
	ATA_DITER_ENABLED_REVERSE = 1,
	ATA_DITER_ALL = 2,
	ATA_DITER_ALL_REVERSE = 3,
};

enum ata_link_iter_mode {
	ATA_LITER_EDGE = 0,
	ATA_LITER_HOST_FIRST = 1,
	ATA_LITER_PMP_FIRST = 2,
};

enum ata_lpm_hints {
	ATA_LPM_EMPTY = 1,
	ATA_LPM_HIPM = 2,
	ATA_LPM_WAKE_ONLY = 4,
};

enum ata_lpm_policy {
	ATA_LPM_UNKNOWN = 0,
	ATA_LPM_MAX_POWER = 1,
	ATA_LPM_MED_POWER = 2,
	ATA_LPM_MED_POWER_WITH_DIPM = 3,
	ATA_LPM_MIN_POWER_WITH_PARTIAL = 4,
	ATA_LPM_MIN_POWER = 5,
};

enum ata_prot_flags {
	ATA_PROT_FLAG_PIO = 1,
	ATA_PROT_FLAG_DMA = 2,
	ATA_PROT_FLAG_NCQ = 4,
	ATA_PROT_FLAG_ATAPI = 8,
	ATA_PROT_UNKNOWN = 255,
	ATA_PROT_NODATA = 0,
	ATA_PROT_PIO = 1,
	ATA_PROT_DMA = 2,
	ATA_PROT_NCQ_NODATA = 4,
	ATA_PROT_NCQ = 6,
	ATAPI_PROT_NODATA = 8,
	ATAPI_PROT_PIO = 9,
	ATAPI_PROT_DMA = 10,
};

enum ata_quirks {
	__ATA_QUIRK_DIAGNOSTIC = 0,
	__ATA_QUIRK_NODMA = 1,
	__ATA_QUIRK_NONCQ = 2,
	__ATA_QUIRK_MAX_SEC_128 = 3,
	__ATA_QUIRK_BROKEN_HPA = 4,
	__ATA_QUIRK_DISABLE = 5,
	__ATA_QUIRK_HPA_SIZE = 6,
	__ATA_QUIRK_IVB = 7,
	__ATA_QUIRK_STUCK_ERR = 8,
	__ATA_QUIRK_BRIDGE_OK = 9,
	__ATA_QUIRK_ATAPI_MOD16_DMA = 10,
	__ATA_QUIRK_FIRMWARE_WARN = 11,
	__ATA_QUIRK_1_5_GBPS = 12,
	__ATA_QUIRK_NOSETXFER = 13,
	__ATA_QUIRK_BROKEN_FPDMA_AA = 14,
	__ATA_QUIRK_DUMP_ID = 15,
	__ATA_QUIRK_MAX_SEC_LBA48 = 16,
	__ATA_QUIRK_ATAPI_DMADIR = 17,
	__ATA_QUIRK_NO_NCQ_TRIM = 18,
	__ATA_QUIRK_NOLPM = 19,
	__ATA_QUIRK_WD_BROKEN_LPM = 20,
	__ATA_QUIRK_ZERO_AFTER_TRIM = 21,
	__ATA_QUIRK_NO_DMA_LOG = 22,
	__ATA_QUIRK_NOTRIM = 23,
	__ATA_QUIRK_MAX_SEC_1024 = 24,
	__ATA_QUIRK_MAX_TRIM_128M = 25,
	__ATA_QUIRK_NO_NCQ_ON_ATI = 26,
	__ATA_QUIRK_NO_LPM_ON_ATI = 27,
	__ATA_QUIRK_NO_ID_DEV_LOG = 28,
	__ATA_QUIRK_NO_LOG_DIR = 29,
	__ATA_QUIRK_NO_FUA = 30,
	__ATA_QUIRK_MAX = 31,
};

enum ata_xfer_mask {
	ATA_MASK_PIO = 127,
	ATA_MASK_MWDMA = 3968,
	ATA_MASK_UDMA = 1044480,
};

enum atom_native_id {
	cmt_native_id = 2,
	skt_native_id = 3,
};

enum audit_nfcfgop {
	AUDIT_XT_OP_REGISTER = 0,
	AUDIT_XT_OP_REPLACE = 1,
	AUDIT_XT_OP_UNREGISTER = 2,
	AUDIT_NFT_OP_TABLE_REGISTER = 3,
	AUDIT_NFT_OP_TABLE_UNREGISTER = 4,
	AUDIT_NFT_OP_CHAIN_REGISTER = 5,
	AUDIT_NFT_OP_CHAIN_UNREGISTER = 6,
	AUDIT_NFT_OP_RULE_REGISTER = 7,
	AUDIT_NFT_OP_RULE_UNREGISTER = 8,
	AUDIT_NFT_OP_SET_REGISTER = 9,
	AUDIT_NFT_OP_SET_UNREGISTER = 10,
	AUDIT_NFT_OP_SETELEM_REGISTER = 11,
	AUDIT_NFT_OP_SETELEM_UNREGISTER = 12,
	AUDIT_NFT_OP_GEN_REGISTER = 13,
	AUDIT_NFT_OP_OBJ_REGISTER = 14,
	AUDIT_NFT_OP_OBJ_UNREGISTER = 15,
	AUDIT_NFT_OP_OBJ_RESET = 16,
	AUDIT_NFT_OP_FLOWTABLE_REGISTER = 17,
	AUDIT_NFT_OP_FLOWTABLE_UNREGISTER = 18,
	AUDIT_NFT_OP_SETELEM_RESET = 19,
	AUDIT_NFT_OP_RULE_RESET = 20,
	AUDIT_NFT_OP_INVALID = 21,
};

enum audit_nlgrps {
	AUDIT_NLGRP_NONE = 0,
	AUDIT_NLGRP_READLOG = 1,
	__AUDIT_NLGRP_MAX = 2,
};

enum audit_ntp_type {
	AUDIT_NTP_OFFSET = 0,
	AUDIT_NTP_FREQ = 1,
	AUDIT_NTP_STATUS = 2,
	AUDIT_NTP_TAI = 3,
	AUDIT_NTP_TICK = 4,
	AUDIT_NTP_ADJUST = 5,
	AUDIT_NTP_NVALS = 6,
};

enum audit_state {
	AUDIT_STATE_DISABLED = 0,
	AUDIT_STATE_BUILD = 1,
	AUDIT_STATE_RECORD = 2,
};

enum auditsc_class_t {
	AUDITSC_NATIVE = 0,
	AUDITSC_COMPAT = 1,
	AUDITSC_OPEN = 2,
	AUDITSC_OPENAT = 3,
	AUDITSC_SOCKETCALL = 4,
	AUDITSC_EXECVE = 5,
	AUDITSC_OPENAT2 = 6,
	AUDITSC_NVALS = 7,
};

enum autofs_notify {
	NFY_NONE = 0,
	NFY_MOUNT = 1,
	NFY_EXPIRE = 2,
};

enum aux_ch {
	AUX_CH_NONE = -1,
	AUX_CH_A = 0,
	AUX_CH_B = 1,
	AUX_CH_C = 2,
	AUX_CH_D = 3,
	AUX_CH_E = 4,
	AUX_CH_F = 5,
	AUX_CH_G = 6,
	AUX_CH_H = 7,
	AUX_CH_I = 8,
	AUX_CH_USBC1 = 3,
	AUX_CH_USBC2 = 4,
	AUX_CH_USBC3 = 5,
	AUX_CH_USBC4 = 6,
	AUX_CH_USBC5 = 7,
	AUX_CH_USBC6 = 8,
	AUX_CH_D_XELPD = 7,
	AUX_CH_E_XELPD = 8,
};

enum backlight_scale {
	BACKLIGHT_SCALE_UNKNOWN = 0,
	BACKLIGHT_SCALE_LINEAR = 1,
	BACKLIGHT_SCALE_NON_LINEAR = 2,
};

enum backlight_type {
	BACKLIGHT_RAW = 1,
	BACKLIGHT_PLATFORM = 2,
	BACKLIGHT_FIRMWARE = 3,
	BACKLIGHT_TYPE_MAX = 4,
};

enum backlight_update_reason {
	BACKLIGHT_UPDATE_HOTKEY = 0,
	BACKLIGHT_UPDATE_SYSFS = 1,
};

enum batadv_packettype {
	BATADV_IV_OGM = 0,
	BATADV_BCAST = 1,
	BATADV_CODED = 2,
	BATADV_ELP = 3,
	BATADV_OGM2 = 4,
	BATADV_MCAST = 5,
	BATADV_UNICAST = 64,
	BATADV_UNICAST_FRAG = 65,
	BATADV_UNICAST_4ADDR = 66,
	BATADV_ICMP = 67,
	BATADV_UNICAST_TVLV = 68,
};

enum bdb_block_id {
	BDB_GENERAL_FEATURES = 1,
	BDB_GENERAL_DEFINITIONS = 2,
	BDB_DISPLAY_TOGGLE = 3,
	BDB_MODE_SUPPORT_LIST = 4,
	BDB_GENERIC_MODE_TABLE = 5,
	BDB_EXT_MMIO_REGS = 6,
	BDB_SWF_IO = 7,
	BDB_SWF_MMIO = 8,
	BDB_DOT_CLOCK_OVERRIDE_ALM = 9,
	BDB_PSR = 9,
	BDB_MODE_REMOVAL_TABLE = 10,
	BDB_CHILD_DEVICE_TABLE = 11,
	BDB_DRIVER_FEATURES = 12,
	BDB_DRIVER_PERSISTENCE = 13,
	BDB_EXT_TABLE_PTRS = 14,
	BDB_DOT_CLOCK_OVERRIDE = 15,
	BDB_DISPLAY_SELECT_OLD = 16,
	BDB_SV_TEST_FUNCTIONS = 17,
	BDB_DRIVER_ROTATION = 18,
	BDB_DISPLAY_REMOVE_OLD = 19,
	BDB_OEM_CUSTOM = 20,
	BDB_EFP_LIST = 21,
	BDB_SDVO_LVDS_OPTIONS = 22,
	BDB_SDVO_LVDS_DTD = 23,
	BDB_SDVO_LVDS_PNP_ID = 24,
	BDB_SDVO_LVDS_PPS = 25,
	BDB_TV_OPTIONS = 26,
	BDB_EDP = 27,
	BDB_EFP_DTD = 28,
	BDB_DISPLAY_SELECT_IVB = 29,
	BDB_DISPLAY_REMOVE_IVB = 30,
	BDB_DISPLAY_SELECT_HSW = 31,
	BDB_DISPLAY_REMOVE_HSW = 32,
	BDB_LFP_OPTIONS = 40,
	BDB_LFP_DATA_PTRS = 41,
	BDB_LFP_DATA = 42,
	BDB_LFP_BACKLIGHT = 43,
	BDB_LFP_POWER = 44,
	BDB_EDP_BFI = 45,
	BDB_CHROMATICITY = 46,
	BDB_MIPI = 50,
	BDB_FIXED_SET_MODE = 51,
	BDB_MIPI_CONFIG = 52,
	BDB_MIPI_SEQUENCE = 53,
	BDB_RGB_PALETTE = 54,
	BDB_COMPRESSION_PARAMETERS_OLD = 55,
	BDB_COMPRESSION_PARAMETERS = 56,
	BDB_VSWING_PREEMPH = 57,
	BDB_GENERIC_DTD = 58,
	BDB_INT15_HOOK = 252,
	BDB_PRD_TABLE = 253,
	BDB_SKIP = 254,
};

enum behavior {
	EXCLUSIVE = 0,
	SHARED = 1,
	DROP = 2,
};

enum bh_state_bits {
	BH_Uptodate = 0,
	BH_Dirty = 1,
	BH_Lock = 2,
	BH_Req = 3,
	BH_Mapped = 4,
	BH_New = 5,
	BH_Async_Read = 6,
	BH_Async_Write = 7,
	BH_Delay = 8,
	BH_Boundary = 9,
	BH_Write_EIO = 10,
	BH_Unwritten = 11,
	BH_Quiet = 12,
	BH_Meta = 13,
	BH_Prio = 14,
	BH_Defer_Completion = 15,
	BH_PrivateStart = 16,
};

enum bhi_mitigations {
	BHI_MITIGATION_OFF = 0,
	BHI_MITIGATION_ON = 1,
	BHI_MITIGATION_VMEXIT_ONLY = 2,
};

enum bio_merge_status {
	BIO_MERGE_OK = 0,
	BIO_MERGE_NONE = 1,
	BIO_MERGE_FAILED = 2,
};

enum bio_post_read_step {
	STEP_INITIAL = 0,
	STEP_DECRYPT = 1,
	STEP_VERITY = 2,
	STEP_MAX = 3,
};

enum bip_flags {
	BIP_BLOCK_INTEGRITY = 1,
	BIP_MAPPED_INTEGRITY = 2,
	BIP_DISK_NOCHECK = 4,
	BIP_IP_CHECKSUM = 8,
	BIP_COPY_USER = 16,
	BIP_CHECK_GUARD = 32,
	BIP_CHECK_REFTAG = 64,
	BIP_CHECK_APPTAG = 128,
};

enum bitmap_page_attr {
	BITMAP_PAGE_DIRTY = 0,
	BITMAP_PAGE_PENDING = 1,
	BITMAP_PAGE_NEEDWRITE = 2,
};

enum bitmap_state {
	BITMAP_STALE = 1,
	BITMAP_WRITE_ERROR = 2,
	BITMAP_HOSTENDIAN = 15,
};

enum blacklist_hash_type {
	BLACKLIST_HASH_X509_TBS = 1,
	BLACKLIST_HASH_BINARY = 2,
};

enum blake2s_iv {
	BLAKE2S_IV0 = 1779033703,
	BLAKE2S_IV1 = 3144134277,
	BLAKE2S_IV2 = 1013904242,
	BLAKE2S_IV3 = 2773480762,
	BLAKE2S_IV4 = 1359893119,
	BLAKE2S_IV5 = 2600822924,
	BLAKE2S_IV6 = 528734635,
	BLAKE2S_IV7 = 1541459225,
};

enum blake2s_lengths {
	BLAKE2S_BLOCK_SIZE = 64,
	BLAKE2S_HASH_SIZE = 32,
	BLAKE2S_KEY_SIZE = 32,
	BLAKE2S_128_HASH_SIZE = 16,
	BLAKE2S_160_HASH_SIZE = 20,
	BLAKE2S_224_HASH_SIZE = 28,
	BLAKE2S_256_HASH_SIZE = 32,
};

enum blk_crypto_mode_num {
	BLK_ENCRYPTION_MODE_INVALID = 0,
	BLK_ENCRYPTION_MODE_AES_256_XTS = 1,
	BLK_ENCRYPTION_MODE_AES_128_CBC_ESSIV = 2,
	BLK_ENCRYPTION_MODE_ADIANTUM = 3,
	BLK_ENCRYPTION_MODE_SM4_XTS = 4,
	BLK_ENCRYPTION_MODE_MAX = 5,
};

enum blk_default_limits {
	BLK_MAX_SEGMENTS = 128,
	BLK_SAFE_MAX_SECTORS = 255,
	BLK_MAX_SEGMENT_SIZE = 65536,
	BLK_SEG_BOUNDARY_MASK = 4294967295,
};

enum blk_eh_timer_return {
	BLK_EH_DONE = 0,
	BLK_EH_RESET_TIMER = 1,
};

enum blk_integrity_checksum {
	BLK_INTEGRITY_CSUM_NONE = 0,
	BLK_INTEGRITY_CSUM_IP = 1,
	BLK_INTEGRITY_CSUM_CRC = 2,
	BLK_INTEGRITY_CSUM_CRC64 = 3,
} __attribute__((mode(byte)));

enum blk_integrity_flags {
	BLK_INTEGRITY_NOVERIFY = 1,
	BLK_INTEGRITY_NOGENERATE = 2,
	BLK_INTEGRITY_DEVICE_CAPABLE = 4,
	BLK_INTEGRITY_REF_TAG = 8,
	BLK_INTEGRITY_STACKED = 16,
};

enum blk_unique_id {
	BLK_UID_T10 = 1,
	BLK_UID_EUI64 = 2,
	BLK_UID_NAA = 3,
};

enum blkg_iostat_type {
	BLKG_IOSTAT_READ = 0,
	BLKG_IOSTAT_WRITE = 1,
	BLKG_IOSTAT_DISCARD = 2,
	BLKG_IOSTAT_NR = 3,
};

enum blkg_rwstat_type {
	BLKG_RWSTAT_READ = 0,
	BLKG_RWSTAT_WRITE = 1,
	BLKG_RWSTAT_SYNC = 2,
	BLKG_RWSTAT_ASYNC = 3,
	BLKG_RWSTAT_DISCARD = 4,
	BLKG_RWSTAT_NR = 5,
	BLKG_RWSTAT_TOTAL = 5,
};

enum blktrace_act {
	__BLK_TA_QUEUE = 1,
	__BLK_TA_BACKMERGE = 2,
	__BLK_TA_FRONTMERGE = 3,
	__BLK_TA_GETRQ = 4,
	__BLK_TA_SLEEPRQ = 5,
	__BLK_TA_REQUEUE = 6,
	__BLK_TA_ISSUE = 7,
	__BLK_TA_COMPLETE = 8,
	__BLK_TA_PLUG = 9,
	__BLK_TA_UNPLUG_IO = 10,
	__BLK_TA_UNPLUG_TIMER = 11,
	__BLK_TA_INSERT = 12,
	__BLK_TA_SPLIT = 13,
	__BLK_TA_BOUNCE = 14,
	__BLK_TA_REMAP = 15,
	__BLK_TA_ABORT = 16,
	__BLK_TA_DRV_DATA = 17,
	__BLK_TA_CGROUP = 256,
};

enum blktrace_cat {
	BLK_TC_READ = 1,
	BLK_TC_WRITE = 2,
	BLK_TC_FLUSH = 4,
	BLK_TC_SYNC = 8,
	BLK_TC_SYNCIO = 8,
	BLK_TC_QUEUE = 16,
	BLK_TC_REQUEUE = 32,
	BLK_TC_ISSUE = 64,
	BLK_TC_COMPLETE = 128,
	BLK_TC_FS = 256,
	BLK_TC_PC = 512,
	BLK_TC_NOTIFY = 1024,
	BLK_TC_AHEAD = 2048,
	BLK_TC_META = 4096,
	BLK_TC_DISCARD = 8192,
	BLK_TC_DRV_DATA = 16384,
	BLK_TC_FUA = 32768,
	BLK_TC_END = 32768,
};

enum blktrace_notify {
	__BLK_TN_PROCESS = 0,
	__BLK_TN_TIMESTAMP = 1,
	__BLK_TN_MESSAGE = 2,
	__BLK_TN_CGROUP = 256,
};

enum board_ids {
	board_ahci = 0,
	board_ahci_43bit_dma = 1,
	board_ahci_ign_iferr = 2,
	board_ahci_no_debounce_delay = 3,
	board_ahci_no_msi = 4,
	board_ahci_pcs_quirk = 5,
	board_ahci_pcs_quirk_no_devslp = 6,
	board_ahci_pcs_quirk_no_sntf = 7,
	board_ahci_yes_fbs = 8,
	board_ahci_al = 9,
	board_ahci_avn = 10,
	board_ahci_mcp65 = 11,
	board_ahci_mcp77 = 12,
	board_ahci_mcp89 = 13,
	board_ahci_mv = 14,
	board_ahci_sb600 = 15,
	board_ahci_sb700 = 16,
	board_ahci_vt8251 = 17,
	board_ahci_mcp_linux = 11,
	board_ahci_mcp67 = 11,
	board_ahci_mcp73 = 11,
	board_ahci_mcp79 = 12,
};

enum bp_type_idx {
	TYPE_INST = 0,
	TYPE_DATA = 0,
	TYPE_MAX = 1,
};

enum bpf_access_src {
	ACCESS_DIRECT = 1,
	ACCESS_HELPER = 2,
};

enum bpf_access_type {
	BPF_READ = 1,
	BPF_WRITE = 2,
};

enum bpf_addr_space_cast {
	BPF_ADDR_SPACE_CAST = 1,
};

enum bpf_adj_room_mode {
	BPF_ADJ_ROOM_NET = 0,
	BPF_ADJ_ROOM_MAC = 1,
};

enum bpf_arg_type {
	ARG_DONTCARE = 0,
	ARG_CONST_MAP_PTR = 1,
	ARG_PTR_TO_MAP_KEY = 2,
	ARG_PTR_TO_MAP_VALUE = 3,
	ARG_PTR_TO_MEM = 4,
	ARG_PTR_TO_ARENA = 5,
	ARG_CONST_SIZE = 6,
	ARG_CONST_SIZE_OR_ZERO = 7,
	ARG_PTR_TO_CTX = 8,
	ARG_ANYTHING = 9,
	ARG_PTR_TO_SPIN_LOCK = 10,
	ARG_PTR_TO_SOCK_COMMON = 11,
	ARG_PTR_TO_SOCKET = 12,
	ARG_PTR_TO_BTF_ID = 13,
	ARG_PTR_TO_RINGBUF_MEM = 14,
	ARG_CONST_ALLOC_SIZE_OR_ZERO = 15,
	ARG_PTR_TO_BTF_ID_SOCK_COMMON = 16,
	ARG_PTR_TO_PERCPU_BTF_ID = 17,
	ARG_PTR_TO_FUNC = 18,
	ARG_PTR_TO_STACK = 19,
	ARG_PTR_TO_CONST_STR = 20,
	ARG_PTR_TO_TIMER = 21,
	ARG_KPTR_XCHG_DEST = 22,
	ARG_PTR_TO_DYNPTR = 23,
	__BPF_ARG_TYPE_MAX = 24,
	ARG_PTR_TO_MAP_VALUE_OR_NULL = 259,
	ARG_PTR_TO_MEM_OR_NULL = 260,
	ARG_PTR_TO_CTX_OR_NULL = 264,
	ARG_PTR_TO_SOCKET_OR_NULL = 268,
	ARG_PTR_TO_STACK_OR_NULL = 275,
	ARG_PTR_TO_BTF_ID_OR_NULL = 269,
	ARG_PTR_TO_UNINIT_MEM = 67141636,
	ARG_PTR_TO_FIXED_SIZE_MEM = 262148,
	__BPF_ARG_TYPE_LIMIT = 134217727,
};

enum bpf_async_type {
	BPF_ASYNC_TYPE_TIMER = 0,
	BPF_ASYNC_TYPE_WQ = 1,
};

enum bpf_attach_type {
	BPF_CGROUP_INET_INGRESS = 0,
	BPF_CGROUP_INET_EGRESS = 1,
	BPF_CGROUP_INET_SOCK_CREATE = 2,
	BPF_CGROUP_SOCK_OPS = 3,
	BPF_SK_SKB_STREAM_PARSER = 4,
	BPF_SK_SKB_STREAM_VERDICT = 5,
	BPF_CGROUP_DEVICE = 6,
	BPF_SK_MSG_VERDICT = 7,
	BPF_CGROUP_INET4_BIND = 8,
	BPF_CGROUP_INET6_BIND = 9,
	BPF_CGROUP_INET4_CONNECT = 10,
	BPF_CGROUP_INET6_CONNECT = 11,
	BPF_CGROUP_INET4_POST_BIND = 12,
	BPF_CGROUP_INET6_POST_BIND = 13,
	BPF_CGROUP_UDP4_SENDMSG = 14,
	BPF_CGROUP_UDP6_SENDMSG = 15,
	BPF_LIRC_MODE2 = 16,
	BPF_FLOW_DISSECTOR = 17,
	BPF_CGROUP_SYSCTL = 18,
	BPF_CGROUP_UDP4_RECVMSG = 19,
	BPF_CGROUP_UDP6_RECVMSG = 20,
	BPF_CGROUP_GETSOCKOPT = 21,
	BPF_CGROUP_SETSOCKOPT = 22,
	BPF_TRACE_RAW_TP = 23,
	BPF_TRACE_FENTRY = 24,
	BPF_TRACE_FEXIT = 25,
	BPF_MODIFY_RETURN = 26,
	BPF_LSM_MAC = 27,
	BPF_TRACE_ITER = 28,
	BPF_CGROUP_INET4_GETPEERNAME = 29,
	BPF_CGROUP_INET6_GETPEERNAME = 30,
	BPF_CGROUP_INET4_GETSOCKNAME = 31,
	BPF_CGROUP_INET6_GETSOCKNAME = 32,
	BPF_XDP_DEVMAP = 33,
	BPF_CGROUP_INET_SOCK_RELEASE = 34,
	BPF_XDP_CPUMAP = 35,
	BPF_SK_LOOKUP = 36,
	BPF_XDP = 37,
	BPF_SK_SKB_VERDICT = 38,
	BPF_SK_REUSEPORT_SELECT = 39,
	BPF_SK_REUSEPORT_SELECT_OR_MIGRATE = 40,
	BPF_PERF_EVENT = 41,
	BPF_TRACE_KPROBE_MULTI = 42,
	BPF_LSM_CGROUP = 43,
	BPF_STRUCT_OPS = 44,
	BPF_NETFILTER = 45,
	BPF_TCX_INGRESS = 46,
	BPF_TCX_EGRESS = 47,
	BPF_TRACE_UPROBE_MULTI = 48,
	BPF_CGROUP_UNIX_CONNECT = 49,
	BPF_CGROUP_UNIX_SENDMSG = 50,
	BPF_CGROUP_UNIX_RECVMSG = 51,
	BPF_CGROUP_UNIX_GETPEERNAME = 52,
	BPF_CGROUP_UNIX_GETSOCKNAME = 53,
	BPF_NETKIT_PRIMARY = 54,
	BPF_NETKIT_PEER = 55,
	BPF_TRACE_KPROBE_SESSION = 56,
	BPF_TRACE_UPROBE_SESSION = 57,
	__MAX_BPF_ATTACH_TYPE = 58,
};

enum bpf_audit {
	BPF_AUDIT_LOAD = 0,
	BPF_AUDIT_UNLOAD = 1,
	BPF_AUDIT_MAX = 2,
};

enum bpf_cgroup_iter_order {
	BPF_CGROUP_ITER_ORDER_UNSPEC = 0,
	BPF_CGROUP_ITER_SELF_ONLY = 1,
	BPF_CGROUP_ITER_DESCENDANTS_PRE = 2,
	BPF_CGROUP_ITER_DESCENDANTS_POST = 3,
	BPF_CGROUP_ITER_ANCESTORS_UP = 4,
};

enum bpf_cgroup_storage_type {
	BPF_CGROUP_STORAGE_SHARED = 0,
	BPF_CGROUP_STORAGE_PERCPU = 1,
	__BPF_CGROUP_STORAGE_MAX = 2,
};

enum bpf_check_mtu_flags {
	BPF_MTU_CHK_SEGS = 1,
};

enum bpf_check_mtu_ret {
	BPF_MTU_CHK_RET_SUCCESS = 0,
	BPF_MTU_CHK_RET_FRAG_NEEDED = 1,
	BPF_MTU_CHK_RET_SEGS_TOOBIG = 2,
};

enum bpf_cmd {
	BPF_MAP_CREATE = 0,
	BPF_MAP_LOOKUP_ELEM = 1,
	BPF_MAP_UPDATE_ELEM = 2,
	BPF_MAP_DELETE_ELEM = 3,
	BPF_MAP_GET_NEXT_KEY = 4,
	BPF_PROG_LOAD = 5,
	BPF_OBJ_PIN = 6,
	BPF_OBJ_GET = 7,
	BPF_PROG_ATTACH = 8,
	BPF_PROG_DETACH = 9,
	BPF_PROG_TEST_RUN = 10,
	BPF_PROG_RUN = 10,
	BPF_PROG_GET_NEXT_ID = 11,
	BPF_MAP_GET_NEXT_ID = 12,
	BPF_PROG_GET_FD_BY_ID = 13,
	BPF_MAP_GET_FD_BY_ID = 14,
	BPF_OBJ_GET_INFO_BY_FD = 15,
	BPF_PROG_QUERY = 16,
	BPF_RAW_TRACEPOINT_OPEN = 17,
	BPF_BTF_LOAD = 18,
	BPF_BTF_GET_FD_BY_ID = 19,
	BPF_TASK_FD_QUERY = 20,
	BPF_MAP_LOOKUP_AND_DELETE_ELEM = 21,
	BPF_MAP_FREEZE = 22,
	BPF_BTF_GET_NEXT_ID = 23,
	BPF_MAP_LOOKUP_BATCH = 24,
	BPF_MAP_LOOKUP_AND_DELETE_BATCH = 25,
	BPF_MAP_UPDATE_BATCH = 26,
	BPF_MAP_DELETE_BATCH = 27,
	BPF_LINK_CREATE = 28,
	BPF_LINK_UPDATE = 29,
	BPF_LINK_GET_FD_BY_ID = 30,
	BPF_LINK_GET_NEXT_ID = 31,
	BPF_ENABLE_STATS = 32,
	BPF_ITER_CREATE = 33,
	BPF_LINK_DETACH = 34,
	BPF_PROG_BIND_MAP = 35,
	BPF_TOKEN_CREATE = 36,
	__MAX_BPF_CMD = 37,
};

enum bpf_cond_pseudo_jmp {
	BPF_MAY_GOTO = 0,
};

enum bpf_core_relo_kind {
	BPF_CORE_FIELD_BYTE_OFFSET = 0,
	BPF_CORE_FIELD_BYTE_SIZE = 1,
	BPF_CORE_FIELD_EXISTS = 2,
	BPF_CORE_FIELD_SIGNED = 3,
	BPF_CORE_FIELD_LSHIFT_U64 = 4,
	BPF_CORE_FIELD_RSHIFT_U64 = 5,
	BPF_CORE_TYPE_ID_LOCAL = 6,
	BPF_CORE_TYPE_ID_TARGET = 7,
	BPF_CORE_TYPE_EXISTS = 8,
	BPF_CORE_TYPE_SIZE = 9,
	BPF_CORE_ENUMVAL_EXISTS = 10,
	BPF_CORE_ENUMVAL_VALUE = 11,
	BPF_CORE_TYPE_MATCHES = 12,
};

enum bpf_dynptr_type {
	BPF_DYNPTR_TYPE_INVALID = 0,
	BPF_DYNPTR_TYPE_LOCAL = 1,
	BPF_DYNPTR_TYPE_RINGBUF = 2,
	BPF_DYNPTR_TYPE_SKB = 3,
	BPF_DYNPTR_TYPE_XDP = 4,
};

enum bpf_func_id {
	BPF_FUNC_unspec = 0,
	BPF_FUNC_map_lookup_elem = 1,
	BPF_FUNC_map_update_elem = 2,
	BPF_FUNC_map_delete_elem = 3,
	BPF_FUNC_probe_read = 4,
	BPF_FUNC_ktime_get_ns = 5,
	BPF_FUNC_trace_printk = 6,
	BPF_FUNC_get_prandom_u32 = 7,
	BPF_FUNC_get_smp_processor_id = 8,
	BPF_FUNC_skb_store_bytes = 9,
	BPF_FUNC_l3_csum_replace = 10,
	BPF_FUNC_l4_csum_replace = 11,
	BPF_FUNC_tail_call = 12,
	BPF_FUNC_clone_redirect = 13,
	BPF_FUNC_get_current_pid_tgid = 14,
	BPF_FUNC_get_current_uid_gid = 15,
	BPF_FUNC_get_current_comm = 16,
	BPF_FUNC_get_cgroup_classid = 17,
	BPF_FUNC_skb_vlan_push = 18,
	BPF_FUNC_skb_vlan_pop = 19,
	BPF_FUNC_skb_get_tunnel_key = 20,
	BPF_FUNC_skb_set_tunnel_key = 21,
	BPF_FUNC_perf_event_read = 22,
	BPF_FUNC_redirect = 23,
	BPF_FUNC_get_route_realm = 24,
	BPF_FUNC_perf_event_output = 25,
	BPF_FUNC_skb_load_bytes = 26,
	BPF_FUNC_get_stackid = 27,
	BPF_FUNC_csum_diff = 28,
	BPF_FUNC_skb_get_tunnel_opt = 29,
	BPF_FUNC_skb_set_tunnel_opt = 30,
	BPF_FUNC_skb_change_proto = 31,
	BPF_FUNC_skb_change_type = 32,
	BPF_FUNC_skb_under_cgroup = 33,
	BPF_FUNC_get_hash_recalc = 34,
	BPF_FUNC_get_current_task = 35,
	BPF_FUNC_probe_write_user = 36,
	BPF_FUNC_current_task_under_cgroup = 37,
	BPF_FUNC_skb_change_tail = 38,
	BPF_FUNC_skb_pull_data = 39,
	BPF_FUNC_csum_update = 40,
	BPF_FUNC_set_hash_invalid = 41,
	BPF_FUNC_get_numa_node_id = 42,
	BPF_FUNC_skb_change_head = 43,
	BPF_FUNC_xdp_adjust_head = 44,
	BPF_FUNC_probe_read_str = 45,
	BPF_FUNC_get_socket_cookie = 46,
	BPF_FUNC_get_socket_uid = 47,
	BPF_FUNC_set_hash = 48,
	BPF_FUNC_setsockopt = 49,
	BPF_FUNC_skb_adjust_room = 50,
	BPF_FUNC_redirect_map = 51,
	BPF_FUNC_sk_redirect_map = 52,
	BPF_FUNC_sock_map_update = 53,
	BPF_FUNC_xdp_adjust_meta = 54,
	BPF_FUNC_perf_event_read_value = 55,
	BPF_FUNC_perf_prog_read_value = 56,
	BPF_FUNC_getsockopt = 57,
	BPF_FUNC_override_return = 58,
	BPF_FUNC_sock_ops_cb_flags_set = 59,
	BPF_FUNC_msg_redirect_map = 60,
	BPF_FUNC_msg_apply_bytes = 61,
	BPF_FUNC_msg_cork_bytes = 62,
	BPF_FUNC_msg_pull_data = 63,
	BPF_FUNC_bind = 64,
	BPF_FUNC_xdp_adjust_tail = 65,
	BPF_FUNC_skb_get_xfrm_state = 66,
	BPF_FUNC_get_stack = 67,
	BPF_FUNC_skb_load_bytes_relative = 68,
	BPF_FUNC_fib_lookup = 69,
	BPF_FUNC_sock_hash_update = 70,
	BPF_FUNC_msg_redirect_hash = 71,
	BPF_FUNC_sk_redirect_hash = 72,
	BPF_FUNC_lwt_push_encap = 73,
	BPF_FUNC_lwt_seg6_store_bytes = 74,
	BPF_FUNC_lwt_seg6_adjust_srh = 75,
	BPF_FUNC_lwt_seg6_action = 76,
	BPF_FUNC_rc_repeat = 77,
	BPF_FUNC_rc_keydown = 78,
	BPF_FUNC_skb_cgroup_id = 79,
	BPF_FUNC_get_current_cgroup_id = 80,
	BPF_FUNC_get_local_storage = 81,
	BPF_FUNC_sk_select_reuseport = 82,
	BPF_FUNC_skb_ancestor_cgroup_id = 83,
	BPF_FUNC_sk_lookup_tcp = 84,
	BPF_FUNC_sk_lookup_udp = 85,
	BPF_FUNC_sk_release = 86,
	BPF_FUNC_map_push_elem = 87,
	BPF_FUNC_map_pop_elem = 88,
	BPF_FUNC_map_peek_elem = 89,
	BPF_FUNC_msg_push_data = 90,
	BPF_FUNC_msg_pop_data = 91,
	BPF_FUNC_rc_pointer_rel = 92,
	BPF_FUNC_spin_lock = 93,
	BPF_FUNC_spin_unlock = 94,
	BPF_FUNC_sk_fullsock = 95,
	BPF_FUNC_tcp_sock = 96,
	BPF_FUNC_skb_ecn_set_ce = 97,
	BPF_FUNC_get_listener_sock = 98,
	BPF_FUNC_skc_lookup_tcp = 99,
	BPF_FUNC_tcp_check_syncookie = 100,
	BPF_FUNC_sysctl_get_name = 101,
	BPF_FUNC_sysctl_get_current_value = 102,
	BPF_FUNC_sysctl_get_new_value = 103,
	BPF_FUNC_sysctl_set_new_value = 104,
	BPF_FUNC_strtol = 105,
	BPF_FUNC_strtoul = 106,
	BPF_FUNC_sk_storage_get = 107,
	BPF_FUNC_sk_storage_delete = 108,
	BPF_FUNC_send_signal = 109,
	BPF_FUNC_tcp_gen_syncookie = 110,
	BPF_FUNC_skb_output = 111,
	BPF_FUNC_probe_read_user = 112,
	BPF_FUNC_probe_read_kernel = 113,
	BPF_FUNC_probe_read_user_str = 114,
	BPF_FUNC_probe_read_kernel_str = 115,
	BPF_FUNC_tcp_send_ack = 116,
	BPF_FUNC_send_signal_thread = 117,
	BPF_FUNC_jiffies64 = 118,
	BPF_FUNC_read_branch_records = 119,
	BPF_FUNC_get_ns_current_pid_tgid = 120,
	BPF_FUNC_xdp_output = 121,
	BPF_FUNC_get_netns_cookie = 122,
	BPF_FUNC_get_current_ancestor_cgroup_id = 123,
	BPF_FUNC_sk_assign = 124,
	BPF_FUNC_ktime_get_boot_ns = 125,
	BPF_FUNC_seq_printf = 126,
	BPF_FUNC_seq_write = 127,
	BPF_FUNC_sk_cgroup_id = 128,
	BPF_FUNC_sk_ancestor_cgroup_id = 129,
	BPF_FUNC_ringbuf_output = 130,
	BPF_FUNC_ringbuf_reserve = 131,
	BPF_FUNC_ringbuf_submit = 132,
	BPF_FUNC_ringbuf_discard = 133,
	BPF_FUNC_ringbuf_query = 134,
	BPF_FUNC_csum_level = 135,
	BPF_FUNC_skc_to_tcp6_sock = 136,
	BPF_FUNC_skc_to_tcp_sock = 137,
	BPF_FUNC_skc_to_tcp_timewait_sock = 138,
	BPF_FUNC_skc_to_tcp_request_sock = 139,
	BPF_FUNC_skc_to_udp6_sock = 140,
	BPF_FUNC_get_task_stack = 141,
	BPF_FUNC_load_hdr_opt = 142,
	BPF_FUNC_store_hdr_opt = 143,
	BPF_FUNC_reserve_hdr_opt = 144,
	BPF_FUNC_inode_storage_get = 145,
	BPF_FUNC_inode_storage_delete = 146,
	BPF_FUNC_d_path = 147,
	BPF_FUNC_copy_from_user = 148,
	BPF_FUNC_snprintf_btf = 149,
	BPF_FUNC_seq_printf_btf = 150,
	BPF_FUNC_skb_cgroup_classid = 151,
	BPF_FUNC_redirect_neigh = 152,
	BPF_FUNC_per_cpu_ptr = 153,
	BPF_FUNC_this_cpu_ptr = 154,
	BPF_FUNC_redirect_peer = 155,
	BPF_FUNC_task_storage_get = 156,
	BPF_FUNC_task_storage_delete = 157,
	BPF_FUNC_get_current_task_btf = 158,
	BPF_FUNC_bprm_opts_set = 159,
	BPF_FUNC_ktime_get_coarse_ns = 160,
	BPF_FUNC_ima_inode_hash = 161,
	BPF_FUNC_sock_from_file = 162,
	BPF_FUNC_check_mtu = 163,
	BPF_FUNC_for_each_map_elem = 164,
	BPF_FUNC_snprintf = 165,
	BPF_FUNC_sys_bpf = 166,
	BPF_FUNC_btf_find_by_name_kind = 167,
	BPF_FUNC_sys_close = 168,
	BPF_FUNC_timer_init = 169,
	BPF_FUNC_timer_set_callback = 170,
	BPF_FUNC_timer_start = 171,
	BPF_FUNC_timer_cancel = 172,
	BPF_FUNC_get_func_ip = 173,
	BPF_FUNC_get_attach_cookie = 174,
	BPF_FUNC_task_pt_regs = 175,
	BPF_FUNC_get_branch_snapshot = 176,
	BPF_FUNC_trace_vprintk = 177,
	BPF_FUNC_skc_to_unix_sock = 178,
	BPF_FUNC_kallsyms_lookup_name = 179,
	BPF_FUNC_find_vma = 180,
	BPF_FUNC_loop = 181,
	BPF_FUNC_strncmp = 182,
	BPF_FUNC_get_func_arg = 183,
	BPF_FUNC_get_func_ret = 184,
	BPF_FUNC_get_func_arg_cnt = 185,
	BPF_FUNC_get_retval = 186,
	BPF_FUNC_set_retval = 187,
	BPF_FUNC_xdp_get_buff_len = 188,
	BPF_FUNC_xdp_load_bytes = 189,
	BPF_FUNC_xdp_store_bytes = 190,
	BPF_FUNC_copy_from_user_task = 191,
	BPF_FUNC_skb_set_tstamp = 192,
	BPF_FUNC_ima_file_hash = 193,
	BPF_FUNC_kptr_xchg = 194,
	BPF_FUNC_map_lookup_percpu_elem = 195,
	BPF_FUNC_skc_to_mptcp_sock = 196,
	BPF_FUNC_dynptr_from_mem = 197,
	BPF_FUNC_ringbuf_reserve_dynptr = 198,
	BPF_FUNC_ringbuf_submit_dynptr = 199,
	BPF_FUNC_ringbuf_discard_dynptr = 200,
	BPF_FUNC_dynptr_read = 201,
	BPF_FUNC_dynptr_write = 202,
	BPF_FUNC_dynptr_data = 203,
	BPF_FUNC_tcp_raw_gen_syncookie_ipv4 = 204,
	BPF_FUNC_tcp_raw_gen_syncookie_ipv6 = 205,
	BPF_FUNC_tcp_raw_check_syncookie_ipv4 = 206,
	BPF_FUNC_tcp_raw_check_syncookie_ipv6 = 207,
	BPF_FUNC_ktime_get_tai_ns = 208,
	BPF_FUNC_user_ringbuf_drain = 209,
	BPF_FUNC_cgrp_storage_get = 210,
	BPF_FUNC_cgrp_storage_delete = 211,
	__BPF_FUNC_MAX_ID = 212,
};

enum bpf_hdr_start_off {
	BPF_HDR_START_MAC = 0,
	BPF_HDR_START_NET = 1,
};

enum bpf_iter_feature {
	BPF_ITER_RESCHED = 1,
};

enum bpf_iter_state {
	BPF_ITER_STATE_INVALID = 0,
	BPF_ITER_STATE_ACTIVE = 1,
	BPF_ITER_STATE_DRAINED = 2,
};

enum bpf_iter_task_type {
	BPF_TASK_ITER_ALL = 0,
	BPF_TASK_ITER_TID = 1,
	BPF_TASK_ITER_TGID = 2,
};

enum bpf_jit_poke_reason {
	BPF_POKE_REASON_TAIL_CALL = 0,
};

enum bpf_kfunc_flags {
	BPF_F_PAD_ZEROS = 1,
};

enum bpf_link_type {
	BPF_LINK_TYPE_UNSPEC = 0,
	BPF_LINK_TYPE_RAW_TRACEPOINT = 1,
	BPF_LINK_TYPE_TRACING = 2,
	BPF_LINK_TYPE_CGROUP = 3,
	BPF_LINK_TYPE_ITER = 4,
	BPF_LINK_TYPE_NETNS = 5,
	BPF_LINK_TYPE_XDP = 6,
	BPF_LINK_TYPE_PERF_EVENT = 7,
	BPF_LINK_TYPE_KPROBE_MULTI = 8,
	BPF_LINK_TYPE_STRUCT_OPS = 9,
	BPF_LINK_TYPE_NETFILTER = 10,
	BPF_LINK_TYPE_TCX = 11,
	BPF_LINK_TYPE_UPROBE_MULTI = 12,
	BPF_LINK_TYPE_NETKIT = 13,
	BPF_LINK_TYPE_SOCKMAP = 14,
	__MAX_BPF_LINK_TYPE = 15,
};

enum bpf_lru_list_type {
	BPF_LRU_LIST_T_ACTIVE = 0,
	BPF_LRU_LIST_T_INACTIVE = 1,
	BPF_LRU_LIST_T_FREE = 2,
	BPF_LRU_LOCAL_LIST_T_FREE = 3,
	BPF_LRU_LOCAL_LIST_T_PENDING = 4,
};

enum bpf_map_type {
	BPF_MAP_TYPE_UNSPEC = 0,
	BPF_MAP_TYPE_HASH = 1,
	BPF_MAP_TYPE_ARRAY = 2,
	BPF_MAP_TYPE_PROG_ARRAY = 3,
	BPF_MAP_TYPE_PERF_EVENT_ARRAY = 4,
	BPF_MAP_TYPE_PERCPU_HASH = 5,
	BPF_MAP_TYPE_PERCPU_ARRAY = 6,
	BPF_MAP_TYPE_STACK_TRACE = 7,
	BPF_MAP_TYPE_CGROUP_ARRAY = 8,
	BPF_MAP_TYPE_LRU_HASH = 9,
	BPF_MAP_TYPE_LRU_PERCPU_HASH = 10,
	BPF_MAP_TYPE_LPM_TRIE = 11,
	BPF_MAP_TYPE_ARRAY_OF_MAPS = 12,
	BPF_MAP_TYPE_HASH_OF_MAPS = 13,
	BPF_MAP_TYPE_DEVMAP = 14,
	BPF_MAP_TYPE_SOCKMAP = 15,
	BPF_MAP_TYPE_CPUMAP = 16,
	BPF_MAP_TYPE_XSKMAP = 17,
	BPF_MAP_TYPE_SOCKHASH = 18,
	BPF_MAP_TYPE_CGROUP_STORAGE_DEPRECATED = 19,
	BPF_MAP_TYPE_CGROUP_STORAGE = 19,
	BPF_MAP_TYPE_REUSEPORT_SOCKARRAY = 20,
	BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE_DEPRECATED = 21,
	BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE = 21,
	BPF_MAP_TYPE_QUEUE = 22,
	BPF_MAP_TYPE_STACK = 23,
	BPF_MAP_TYPE_SK_STORAGE = 24,
	BPF_MAP_TYPE_DEVMAP_HASH = 25,
	BPF_MAP_TYPE_STRUCT_OPS = 26,
	BPF_MAP_TYPE_RINGBUF = 27,
	BPF_MAP_TYPE_INODE_STORAGE = 28,
	BPF_MAP_TYPE_TASK_STORAGE = 29,
	BPF_MAP_TYPE_BLOOM_FILTER = 30,
	BPF_MAP_TYPE_USER_RINGBUF = 31,
	BPF_MAP_TYPE_CGRP_STORAGE = 32,
	BPF_MAP_TYPE_ARENA = 33,
	__MAX_BPF_MAP_TYPE = 34,
};

enum bpf_netdev_command {
	XDP_SETUP_PROG = 0,
	XDP_SETUP_PROG_HW = 1,
	BPF_OFFLOAD_MAP_ALLOC = 2,
	BPF_OFFLOAD_MAP_FREE = 3,
	XDP_SETUP_XSK_POOL = 4,
};

enum bpf_perf_event_type {
	BPF_PERF_EVENT_UNSPEC = 0,
	BPF_PERF_EVENT_UPROBE = 1,
	BPF_PERF_EVENT_URETPROBE = 2,
	BPF_PERF_EVENT_KPROBE = 3,
	BPF_PERF_EVENT_KRETPROBE = 4,
	BPF_PERF_EVENT_TRACEPOINT = 5,
	BPF_PERF_EVENT_EVENT = 6,
};

enum bpf_prog_type {
	BPF_PROG_TYPE_UNSPEC = 0,
	BPF_PROG_TYPE_SOCKET_FILTER = 1,
	BPF_PROG_TYPE_KPROBE = 2,
	BPF_PROG_TYPE_SCHED_CLS = 3,
	BPF_PROG_TYPE_SCHED_ACT = 4,
	BPF_PROG_TYPE_TRACEPOINT = 5,
	BPF_PROG_TYPE_XDP = 6,
	BPF_PROG_TYPE_PERF_EVENT = 7,
	BPF_PROG_TYPE_CGROUP_SKB = 8,
	BPF_PROG_TYPE_CGROUP_SOCK = 9,
	BPF_PROG_TYPE_LWT_IN = 10,
	BPF_PROG_TYPE_LWT_OUT = 11,
	BPF_PROG_TYPE_LWT_XMIT = 12,
	BPF_PROG_TYPE_SOCK_OPS = 13,
	BPF_PROG_TYPE_SK_SKB = 14,
	BPF_PROG_TYPE_CGROUP_DEVICE = 15,
	BPF_PROG_TYPE_SK_MSG = 16,
	BPF_PROG_TYPE_RAW_TRACEPOINT = 17,
	BPF_PROG_TYPE_CGROUP_SOCK_ADDR = 18,
	BPF_PROG_TYPE_LWT_SEG6LOCAL = 19,
	BPF_PROG_TYPE_LIRC_MODE2 = 20,
	BPF_PROG_TYPE_SK_REUSEPORT = 21,
	BPF_PROG_TYPE_FLOW_DISSECTOR = 22,
	BPF_PROG_TYPE_CGROUP_SYSCTL = 23,
	BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE = 24,
	BPF_PROG_TYPE_CGROUP_SOCKOPT = 25,
	BPF_PROG_TYPE_TRACING = 26,
	BPF_PROG_TYPE_STRUCT_OPS = 27,
	BPF_PROG_TYPE_EXT = 28,
	BPF_PROG_TYPE_LSM = 29,
	BPF_PROG_TYPE_SK_LOOKUP = 30,
	BPF_PROG_TYPE_SYSCALL = 31,
	BPF_PROG_TYPE_NETFILTER = 32,
	__MAX_BPF_PROG_TYPE = 33,
};

enum bpf_reg_liveness {
	REG_LIVE_NONE = 0,
	REG_LIVE_READ32 = 1,
	REG_LIVE_READ64 = 2,
	REG_LIVE_READ = 3,
	REG_LIVE_WRITTEN = 4,
	REG_LIVE_DONE = 8,
};

enum bpf_reg_type {
	NOT_INIT = 0,
	SCALAR_VALUE = 1,
	PTR_TO_CTX = 2,
	CONST_PTR_TO_MAP = 3,
	PTR_TO_MAP_VALUE = 4,
	PTR_TO_MAP_KEY = 5,
	PTR_TO_STACK = 6,
	PTR_TO_PACKET_META = 7,
	PTR_TO_PACKET = 8,
	PTR_TO_PACKET_END = 9,
	PTR_TO_FLOW_KEYS = 10,
	PTR_TO_SOCKET = 11,
	PTR_TO_SOCK_COMMON = 12,
	PTR_TO_TCP_SOCK = 13,
	PTR_TO_TP_BUFFER = 14,
	PTR_TO_XDP_SOCK = 15,
	PTR_TO_BTF_ID = 16,
	PTR_TO_MEM = 17,
	PTR_TO_ARENA = 18,
	PTR_TO_BUF = 19,
	PTR_TO_FUNC = 20,
	CONST_PTR_TO_DYNPTR = 21,
	__BPF_REG_TYPE_MAX = 22,
	PTR_TO_MAP_VALUE_OR_NULL = 260,
	PTR_TO_SOCKET_OR_NULL = 267,
	PTR_TO_SOCK_COMMON_OR_NULL = 268,
	PTR_TO_TCP_SOCK_OR_NULL = 269,
	PTR_TO_BTF_ID_OR_NULL = 272,
	__BPF_REG_TYPE_LIMIT = 134217727,
};

enum bpf_ret_code {
	BPF_OK = 0,
	BPF_DROP = 2,
	BPF_REDIRECT = 7,
	BPF_LWT_REROUTE = 128,
	BPF_FLOW_DISSECTOR_CONTINUE = 129,
};

enum bpf_return_type {
	RET_INTEGER = 0,
	RET_VOID = 1,
	RET_PTR_TO_MAP_VALUE = 2,
	RET_PTR_TO_SOCKET = 3,
	RET_PTR_TO_TCP_SOCK = 4,
	RET_PTR_TO_SOCK_COMMON = 5,
	RET_PTR_TO_MEM = 6,
	RET_PTR_TO_MEM_OR_BTF_ID = 7,
	RET_PTR_TO_BTF_ID = 8,
	__BPF_RET_TYPE_MAX = 9,
	RET_PTR_TO_MAP_VALUE_OR_NULL = 258,
	RET_PTR_TO_SOCKET_OR_NULL = 259,
	RET_PTR_TO_TCP_SOCK_OR_NULL = 260,
	RET_PTR_TO_SOCK_COMMON_OR_NULL = 261,
	RET_PTR_TO_RINGBUF_MEM_OR_NULL = 1286,
	RET_PTR_TO_DYNPTR_MEM_OR_NULL = 262,
	RET_PTR_TO_BTF_ID_OR_NULL = 264,
	RET_PTR_TO_BTF_ID_TRUSTED = 1048584,
	__BPF_RET_TYPE_LIMIT = 134217727,
};

enum bpf_stack_build_id_status {
	BPF_STACK_BUILD_ID_EMPTY = 0,
	BPF_STACK_BUILD_ID_VALID = 1,
	BPF_STACK_BUILD_ID_IP = 2,
};

enum bpf_stack_slot_type {
	STACK_INVALID = 0,
	STACK_SPILL = 1,
	STACK_MISC = 2,
	STACK_ZERO = 3,
	STACK_DYNPTR = 4,
	STACK_ITER = 5,
	STACK_IRQ_FLAG = 6,
};

enum bpf_stats_type {
	BPF_STATS_RUN_TIME = 0,
};

enum bpf_struct_walk_result {
	WALK_SCALAR = 0,
	WALK_PTR = 1,
	WALK_STRUCT = 2,
};

enum bpf_task_fd_type {
	BPF_FD_TYPE_RAW_TRACEPOINT = 0,
	BPF_FD_TYPE_TRACEPOINT = 1,
	BPF_FD_TYPE_KPROBE = 2,
	BPF_FD_TYPE_KRETPROBE = 3,
	BPF_FD_TYPE_UPROBE = 4,
	BPF_FD_TYPE_URETPROBE = 5,
};

enum bpf_task_vma_iter_find_op {
	task_vma_iter_first_vma = 0,
	task_vma_iter_next_vma = 1,
	task_vma_iter_find_vma = 2,
};

enum bpf_text_poke_type {
	BPF_MOD_CALL = 0,
	BPF_MOD_JUMP = 1,
};

enum bpf_tramp_prog_type {
	BPF_TRAMP_FENTRY = 0,
	BPF_TRAMP_FEXIT = 1,
	BPF_TRAMP_MODIFY_RETURN = 2,
	BPF_TRAMP_MAX = 3,
	BPF_TRAMP_REPLACE = 4,
};

enum bpf_type {
	BPF_TYPE_UNSPEC = 0,
	BPF_TYPE_PROG = 1,
	BPF_TYPE_MAP = 2,
	BPF_TYPE_LINK = 3,
};

enum bpf_type_flag {
	PTR_MAYBE_NULL = 256,
	MEM_RDONLY = 512,
	MEM_RINGBUF = 1024,
	MEM_USER = 2048,
	MEM_PERCPU = 4096,
	OBJ_RELEASE = 8192,
	PTR_UNTRUSTED = 16384,
	MEM_UNINIT = 32768,
	DYNPTR_TYPE_LOCAL = 65536,
	DYNPTR_TYPE_RINGBUF = 131072,
	MEM_FIXED_SIZE = 262144,
	MEM_ALLOC = 524288,
	PTR_TRUSTED = 1048576,
	MEM_RCU = 2097152,
	NON_OWN_REF = 4194304,
	DYNPTR_TYPE_SKB = 8388608,
	DYNPTR_TYPE_XDP = 16777216,
	MEM_ALIGNED = 33554432,
	MEM_WRITE = 67108864,
	__BPF_TYPE_FLAG_MAX = 67108865,
	__BPF_TYPE_LAST_FLAG = 67108864,
};

enum bpf_xdp_mode {
	XDP_MODE_SKB = 0,
	XDP_MODE_DRV = 1,
	XDP_MODE_HW = 2,
	__MAX_XDP_MODE = 3,
};

enum bss_compare_mode {
	BSS_CMP_REGULAR = 0,
	BSS_CMP_HIDE_ZLEN = 1,
	BSS_CMP_HIDE_NUL = 2,
};

enum bss_param_flags {
	BSS_PARAM_FLAGS_CTS_PROT = 1,
	BSS_PARAM_FLAGS_SHORT_PREAMBLE = 2,
	BSS_PARAM_FLAGS_SHORT_SLOT_TIME = 4,
};

enum bss_source_type {
	BSS_SOURCE_DIRECT = 0,
	BSS_SOURCE_MBSSID = 1,
	BSS_SOURCE_STA_PROFILE = 2,
};

enum btf_arg_tag {
	ARG_TAG_CTX = 1,
	ARG_TAG_NONNULL = 2,
	ARG_TAG_TRUSTED = 4,
	ARG_TAG_NULLABLE = 8,
	ARG_TAG_ARENA = 16,
};

enum btf_field_iter_kind {
	BTF_FIELD_ITER_IDS = 0,
	BTF_FIELD_ITER_STRS = 1,
};

enum btf_field_type {
	BPF_SPIN_LOCK = 1,
	BPF_TIMER = 2,
	BPF_KPTR_UNREF = 4,
	BPF_KPTR_REF = 8,
	BPF_KPTR_PERCPU = 16,
	BPF_KPTR = 28,
	BPF_LIST_HEAD = 32,
	BPF_LIST_NODE = 64,
	BPF_RB_ROOT = 128,
	BPF_RB_NODE = 256,
	BPF_GRAPH_NODE = 320,
	BPF_GRAPH_ROOT = 160,
	BPF_REFCOUNT = 512,
	BPF_WORKQUEUE = 1024,
	BPF_UPTR = 2048,
};

enum btf_func_linkage {
	BTF_FUNC_STATIC = 0,
	BTF_FUNC_GLOBAL = 1,
	BTF_FUNC_EXTERN = 2,
};

enum btf_kfunc_hook {
	BTF_KFUNC_HOOK_COMMON = 0,
	BTF_KFUNC_HOOK_XDP = 1,
	BTF_KFUNC_HOOK_TC = 2,
	BTF_KFUNC_HOOK_STRUCT_OPS = 3,
	BTF_KFUNC_HOOK_TRACING = 4,
	BTF_KFUNC_HOOK_SYSCALL = 5,
	BTF_KFUNC_HOOK_FMODRET = 6,
	BTF_KFUNC_HOOK_CGROUP = 7,
	BTF_KFUNC_HOOK_SCHED_ACT = 8,
	BTF_KFUNC_HOOK_SK_SKB = 9,
	BTF_KFUNC_HOOK_SOCKET_FILTER = 10,
	BTF_KFUNC_HOOK_LWT = 11,
	BTF_KFUNC_HOOK_NETFILTER = 12,
	BTF_KFUNC_HOOK_KPROBE = 13,
	BTF_KFUNC_HOOK_MAX = 14,
};

enum bug_trap_type {
	BUG_TRAP_TYPE_NONE = 0,
	BUG_TRAP_TYPE_WARN = 1,
	BUG_TRAP_TYPE_BUG = 2,
};

enum bus_notifier_event {
	BUS_NOTIFY_ADD_DEVICE = 0,
	BUS_NOTIFY_DEL_DEVICE = 1,
	BUS_NOTIFY_REMOVED_DEVICE = 2,
	BUS_NOTIFY_BIND_DRIVER = 3,
	BUS_NOTIFY_BOUND_DRIVER = 4,
	BUS_NOTIFY_UNBIND_DRIVER = 5,
	BUS_NOTIFY_UNBOUND_DRIVER = 6,
	BUS_NOTIFY_DRIVER_NOT_BOUND = 7,
};

enum cache_tag_type {
	CACHE_TAG_IOTLB = 0,
	CACHE_TAG_DEVTLB = 1,
	CACHE_TAG_NESTING_IOTLB = 2,
	CACHE_TAG_NESTING_DEVTLB = 3,
};

enum cache_type {
	CACHE_TYPE_NOCACHE = 0,
	CACHE_TYPE_INST = 1,
	CACHE_TYPE_DATA = 2,
	CACHE_TYPE_SEPARATE = 3,
	CACHE_TYPE_UNIFIED = 4,
};

enum cb_command {
	cb_nop = 0,
	cb_iaaddr = 1,
	cb_config = 2,
	cb_multi = 3,
	cb_tx = 4,
	cb_ucode = 5,
	cb_dump = 6,
	cb_tx_sf = 8,
	cb_tx_nc = 16,
	cb_cid = 7936,
	cb_i = 8192,
	cb_s = 16384,
	cb_el = 32768,
};

enum cb_status {
	cb_complete = 32768,
	cb_ok = 8192,
};

enum cc_attr {
	CC_ATTR_MEM_ENCRYPT = 0,
	CC_ATTR_HOST_MEM_ENCRYPT = 1,
	CC_ATTR_GUEST_MEM_ENCRYPT = 2,
	CC_ATTR_GUEST_STATE_ENCRYPT = 3,
	CC_ATTR_GUEST_UNROLL_STRING_IO = 4,
	CC_ATTR_GUEST_SEV_SNP = 5,
	CC_ATTR_GUEST_SNP_SECURE_TSC = 6,
	CC_ATTR_HOST_SEV_SNP = 7,
};

enum cc_vendor {
	CC_VENDOR_NONE = 0,
	CC_VENDOR_AMD = 1,
	CC_VENDOR_INTEL = 2,
};

enum cdrom_print_option {
	CTL_NAME = 0,
	CTL_SPEED = 1,
	CTL_SLOTS = 2,
	CTL_CAPABILITY = 3,
};

enum cea_speaker_placement {
	FL = 1,
	FC = 2,
	FR = 4,
	FLC = 8,
	FRC = 16,
	RL = 32,
	RC = 64,
	RR = 128,
	RLC = 256,
	RRC = 512,
	LFE = 1024,
	FLW = 2048,
	FRW = 4096,
	FLH = 8192,
	FCH = 16384,
	FRH = 32768,
	TC = 65536,
};

enum cfg80211_assoc_req_flags {
	ASSOC_REQ_DISABLE_HT = 1,
	ASSOC_REQ_DISABLE_VHT = 2,
	ASSOC_REQ_USE_RRM = 4,
	CONNECT_REQ_EXTERNAL_AUTH_SUPPORT = 8,
	ASSOC_REQ_DISABLE_HE = 16,
	ASSOC_REQ_DISABLE_EHT = 32,
	CONNECT_REQ_MLO_SUPPORT = 64,
	ASSOC_REQ_SPP_AMSDU = 128,
};

enum cfg80211_bss_frame_type {
	CFG80211_BSS_FTYPE_UNKNOWN = 0,
	CFG80211_BSS_FTYPE_BEACON = 1,
	CFG80211_BSS_FTYPE_PRESP = 2,
	CFG80211_BSS_FTYPE_S1G_BEACON = 3,
};

enum cfg80211_connect_params_changed {
	UPDATE_ASSOC_IES = 1,
	UPDATE_FILS_ERP_INFO = 2,
	UPDATE_AUTH_TYPE = 4,
};

enum cfg80211_event_type {
	EVENT_CONNECT_RESULT = 0,
	EVENT_ROAMED = 1,
	EVENT_DISCONNECTED = 2,
	EVENT_IBSS_JOINED = 3,
	EVENT_STOPPED = 4,
	EVENT_PORT_AUTHORIZED = 5,
};

enum cfg80211_nan_conf_changes {
	CFG80211_NAN_CONF_CHANGED_PREF = 1,
	CFG80211_NAN_CONF_CHANGED_BANDS = 2,
};

enum cfg80211_rnr_iter_ret {
	RNR_ITER_CONTINUE = 0,
	RNR_ITER_BREAK = 1,
	RNR_ITER_ERROR = 2,
};

enum cfg80211_signal_type {
	CFG80211_SIGNAL_TYPE_NONE = 0,
	CFG80211_SIGNAL_TYPE_MBM = 1,
	CFG80211_SIGNAL_TYPE_UNSPEC = 2,
};

enum cfg80211_station_type {
	CFG80211_STA_AP_CLIENT = 0,
	CFG80211_STA_AP_CLIENT_UNASSOC = 1,
	CFG80211_STA_AP_MLME_CLIENT = 2,
	CFG80211_STA_AP_STA = 3,
	CFG80211_STA_IBSS = 4,
	CFG80211_STA_TDLS_PEER_SETUP = 5,
	CFG80211_STA_TDLS_PEER_ACTIVE = 6,
	CFG80211_STA_MESH_PEER_KERNEL = 7,
	CFG80211_STA_MESH_PEER_USER = 8,
};

enum cfi_mode {
	CFI_AUTO = 0,
	CFI_OFF = 1,
	CFI_KCFI = 2,
	CFI_FINEIBT = 3,
};

enum cgroup1_param {
	Opt_all = 0,
	Opt_clone_children = 1,
	Opt_cpuset_v2_mode = 2,
	Opt_name = 3,
	Opt_none = 4,
	Opt_noprefix = 5,
	Opt_release_agent = 6,
	Opt_xattr = 7,
	Opt_favordynmods = 8,
	Opt_nofavordynmods = 9,
};

enum cgroup2_param {
	Opt_nsdelegate = 0,
	Opt_favordynmods___2 = 1,
	Opt_memory_localevents = 2,
	Opt_memory_recursiveprot = 3,
	Opt_memory_hugetlb_accounting = 4,
	Opt_pids_localevents = 5,
	nr__cgroup2_params = 6,
};

enum cgroup_filetype {
	CGROUP_FILE_PROCS = 0,
	CGROUP_FILE_TASKS = 1,
};

enum cgroup_opt_features {
	OPT_FEATURE_COUNT = 0,
};

enum cgroup_subsys_id {
	cpuset_cgrp_id = 0,
	cpu_cgrp_id = 1,
	cpuacct_cgrp_id = 2,
	io_cgrp_id = 3,
	devices_cgrp_id = 4,
	freezer_cgrp_id = 5,
	net_cls_cgrp_id = 6,
	perf_event_cgrp_id = 7,
	net_prio_cgrp_id = 8,
	hugetlb_cgrp_id = 9,
	pids_cgrp_id = 10,
	rdma_cgrp_id = 11,
	misc_cgrp_id = 12,
	debug_cgrp_id = 13,
	CGROUP_SUBSYS_COUNT = 14,
};

enum chacha_constants {
	CHACHA_CONSTANT_EXPA = 1634760805,
	CHACHA_CONSTANT_ND_3 = 857760878,
	CHACHA_CONSTANT_2_BY = 2036477234,
	CHACHA_CONSTANT_TE_K = 1797285236,
};

enum check_link_response {
	HDCP_LINK_PROTECTED = 0,
	HDCP_TOPOLOGY_CHANGE = 1,
	HDCP_LINK_INTEGRITY_FAILURE = 2,
	HDCP_REAUTH_REQUEST = 3,
};

enum chip_flags {
	HasHltClk = 1,
	HasLWake = 2,
};

enum chipset_type {
	NOT_SUPPORTED = 0,
	SUPPORTED = 1,
};

enum class_map_type {
	DD_CLASS_TYPE_DISJOINT_BITS = 0,
	DD_CLASS_TYPE_LEVEL_NUM = 1,
	DD_CLASS_TYPE_DISJOINT_NAMES = 2,
	DD_CLASS_TYPE_LEVEL_NAMES = 3,
};

enum cleanup_prefix_rt_t {
	CLEANUP_PREFIX_RT_NOP = 0,
	CLEANUP_PREFIX_RT_DEL = 1,
	CLEANUP_PREFIX_RT_EXPIRE = 2,
};

enum clear_refs_types {
	CLEAR_REFS_ALL = 1,
	CLEAR_REFS_ANON = 2,
	CLEAR_REFS_MAPPED = 3,
	CLEAR_REFS_SOFT_DIRTY = 4,
	CLEAR_REFS_MM_HIWATER_RSS = 5,
	CLEAR_REFS_LAST = 6,
};

enum clock_event_state {
	CLOCK_EVT_STATE_DETACHED = 0,
	CLOCK_EVT_STATE_SHUTDOWN = 1,
	CLOCK_EVT_STATE_PERIODIC = 2,
	CLOCK_EVT_STATE_ONESHOT = 3,
	CLOCK_EVT_STATE_ONESHOT_STOPPED = 4,
};

enum clocksource_ids {
	CSID_GENERIC = 0,
	CSID_ARM_ARCH_COUNTER = 1,
	CSID_S390_TOD = 2,
	CSID_X86_TSC_EARLY = 3,
	CSID_X86_TSC = 4,
	CSID_X86_KVM_CLK = 5,
	CSID_X86_ART = 6,
	CSID_MAX = 7,
};

enum cmis_cdb_fw_write_mechanism {
	CMIS_CDB_FW_WRITE_MECHANISM_NONE = 0,
	CMIS_CDB_FW_WRITE_MECHANISM_LPL = 1,
	CMIS_CDB_FW_WRITE_MECHANISM_EPL = 16,
	CMIS_CDB_FW_WRITE_MECHANISM_BOTH = 17,
};

enum cntl_msg_types {
	IPCTNL_MSG_CT_NEW = 0,
	IPCTNL_MSG_CT_GET = 1,
	IPCTNL_MSG_CT_DELETE = 2,
	IPCTNL_MSG_CT_GET_CTRZERO = 3,
	IPCTNL_MSG_CT_GET_STATS_CPU = 4,
	IPCTNL_MSG_CT_GET_STATS = 5,
	IPCTNL_MSG_CT_GET_DYING = 6,
	IPCTNL_MSG_CT_GET_UNCONFIRMED = 7,
	IPCTNL_MSG_MAX = 8,
};

enum compact_priority {
	COMPACT_PRIO_SYNC_FULL = 0,
	MIN_COMPACT_PRIORITY = 0,
	COMPACT_PRIO_SYNC_LIGHT = 1,
	MIN_COMPACT_COSTLY_PRIORITY = 1,
	DEF_COMPACT_PRIORITY = 1,
	COMPACT_PRIO_ASYNC = 2,
	INIT_COMPACT_PRIORITY = 2,
};

enum compact_result {
	COMPACT_NOT_SUITABLE_ZONE = 0,
	COMPACT_SKIPPED = 1,
	COMPACT_DEFERRED = 2,
	COMPACT_NO_SUITABLE_PAGE = 3,
	COMPACT_CONTINUE = 4,
	COMPACT_COMPLETE = 5,
	COMPACT_PARTIAL_SKIPPED = 6,
	COMPACT_CONTENDED = 7,
	COMPACT_SUCCESS = 8,
};

enum con_flush_mode {
	CONSOLE_FLUSH_PENDING = 0,
	CONSOLE_REPLAY_ALL = 1,
};

enum con_msg_format_flags {
	MSG_FORMAT_DEFAULT = 0,
	MSG_FORMAT_SYSLOG = 1,
};

enum con_scroll {
	SM_UP = 0,
	SM_DOWN = 1,
};

enum cons_flags {
	CON_PRINTBUFFER = 1,
	CON_CONSDEV = 2,
	CON_ENABLED = 4,
	CON_BOOT = 8,
	CON_ANYTIME = 16,
	CON_BRL = 32,
	CON_EXTENDED = 64,
	CON_SUSPENDED = 128,
	CON_NBCON = 256,
};

enum context {
	IN_KERNEL = 1,
	IN_USER = 2,
	IN_KERNEL_RECOV = 3,
};

enum cp_error_code {
	CP_EC = 32767,
	CP_RET = 1,
	CP_IRET = 2,
	CP_ENDBR = 3,
	CP_RSTRORSSP = 4,
	CP_SETSSBSY = 5,
	CP_ENCL = 32768,
};

enum cpa_warn {
	CPA_CONFLICT = 0,
	CPA_PROTECT = 1,
	CPA_DETECT = 2,
};

enum cpio_fields {
	C_MAGIC = 0,
	C_INO = 1,
	C_MODE = 2,
	C_UID = 3,
	C_GID = 4,
	C_NLINK = 5,
	C_MTIME = 6,
	C_FILESIZE = 7,
	C_MAJ = 8,
	C_MIN = 9,
	C_RMAJ = 10,
	C_RMIN = 11,
	C_NAMESIZE = 12,
	C_CHKSUM = 13,
	C_NFIELDS = 14,
};

enum cppc_regs {
	HIGHEST_PERF = 0,
	NOMINAL_PERF = 1,
	LOW_NON_LINEAR_PERF = 2,
	LOWEST_PERF = 3,
	GUARANTEED_PERF = 4,
	DESIRED_PERF = 5,
	MIN_PERF = 6,
	MAX_PERF = 7,
	PERF_REDUC_TOLERANCE = 8,
	TIME_WINDOW = 9,
	CTR_WRAP_TIME = 10,
	REFERENCE_CTR = 11,
	DELIVERED_CTR = 12,
	PERF_LIMITED = 13,
	ENABLE = 14,
	AUTO_SEL_ENABLE = 15,
	AUTO_ACT_WINDOW = 16,
	ENERGY_PERF = 17,
	REFERENCE_PERF = 18,
	LOWEST_FREQ = 19,
	NOMINAL_FREQ = 20,
};

enum cpu_idle_type {
	__CPU_NOT_IDLE = 0,
	CPU_IDLE = 1,
	CPU_NEWLY_IDLE = 2,
	CPU_MAX_IDLE_TYPES = 3,
};

enum cpu_mitigations {
	CPU_MITIGATIONS_OFF = 0,
	CPU_MITIGATIONS_AUTO = 1,
	CPU_MITIGATIONS_AUTO_NOSMT = 2,
};

enum cpu_usage_stat {
	CPUTIME_USER = 0,
	CPUTIME_NICE = 1,
	CPUTIME_SYSTEM = 2,
	CPUTIME_SOFTIRQ = 3,
	CPUTIME_IRQ = 4,
	CPUTIME_IDLE = 5,
	CPUTIME_IOWAIT = 6,
	CPUTIME_STEAL = 7,
	CPUTIME_GUEST = 8,
	CPUTIME_GUEST_NICE = 9,
	NR_STATS = 10,
};

enum cpuacct_stat_index {
	CPUACCT_STAT_USER = 0,
	CPUACCT_STAT_SYSTEM = 1,
	CPUACCT_STAT_NSTATS = 2,
};

enum cpufreq_table_sorting {
	CPUFREQ_TABLE_UNSORTED = 0,
	CPUFREQ_TABLE_SORTED_ASCENDING = 1,
	CPUFREQ_TABLE_SORTED_DESCENDING = 2,
};

enum cpuhp_smt_control {
	CPU_SMT_ENABLED = 0,
	CPU_SMT_DISABLED = 1,
	CPU_SMT_FORCE_DISABLED = 2,
	CPU_SMT_NOT_SUPPORTED = 3,
	CPU_SMT_NOT_IMPLEMENTED = 4,
};

enum cpuhp_state {
	CPUHP_INVALID = -1,
	CPUHP_OFFLINE = 0,
	CPUHP_CREATE_THREADS = 1,
	CPUHP_PERF_PREPARE = 2,
	CPUHP_PERF_X86_PREPARE = 3,
	CPUHP_PERF_X86_AMD_UNCORE_PREP = 4,
	CPUHP_PERF_POWER = 5,
	CPUHP_PERF_SUPERH = 6,
	CPUHP_X86_HPET_DEAD = 7,
	CPUHP_X86_MCE_DEAD = 8,
	CPUHP_VIRT_NET_DEAD = 9,
	CPUHP_IBMVNIC_DEAD = 10,
	CPUHP_SLUB_DEAD = 11,
	CPUHP_DEBUG_OBJ_DEAD = 12,
	CPUHP_MM_WRITEBACK_DEAD = 13,
	CPUHP_MM_VMSTAT_DEAD = 14,
	CPUHP_SOFTIRQ_DEAD = 15,
	CPUHP_NET_MVNETA_DEAD = 16,
	CPUHP_CPUIDLE_DEAD = 17,
	CPUHP_ARM64_FPSIMD_DEAD = 18,
	CPUHP_ARM_OMAP_WAKE_DEAD = 19,
	CPUHP_IRQ_POLL_DEAD = 20,
	CPUHP_BLOCK_SOFTIRQ_DEAD = 21,
	CPUHP_BIO_DEAD = 22,
	CPUHP_ACPI_CPUDRV_DEAD = 23,
	CPUHP_S390_PFAULT_DEAD = 24,
	CPUHP_BLK_MQ_DEAD = 25,
	CPUHP_FS_BUFF_DEAD = 26,
	CPUHP_PRINTK_DEAD = 27,
	CPUHP_MM_MEMCQ_DEAD = 28,
	CPUHP_PERCPU_CNT_DEAD = 29,
	CPUHP_RADIX_DEAD = 30,
	CPUHP_PAGE_ALLOC = 31,
	CPUHP_NET_DEV_DEAD = 32,
	CPUHP_PCI_XGENE_DEAD = 33,
	CPUHP_IOMMU_IOVA_DEAD = 34,
	CPUHP_AP_ARM_CACHE_B15_RAC_DEAD = 35,
	CPUHP_PADATA_DEAD = 36,
	CPUHP_AP_DTPM_CPU_DEAD = 37,
	CPUHP_RANDOM_PREPARE = 38,
	CPUHP_WORKQUEUE_PREP = 39,
	CPUHP_POWER_NUMA_PREPARE = 40,
	CPUHP_HRTIMERS_PREPARE = 41,
	CPUHP_X2APIC_PREPARE = 42,
	CPUHP_SMPCFD_PREPARE = 43,
	CPUHP_RELAY_PREPARE = 44,
	CPUHP_MD_RAID5_PREPARE = 45,
	CPUHP_RCUTREE_PREP = 46,
	CPUHP_CPUIDLE_COUPLED_PREPARE = 47,
	CPUHP_POWERPC_PMAC_PREPARE = 48,
	CPUHP_POWERPC_MMU_CTX_PREPARE = 49,
	CPUHP_XEN_PREPARE = 50,
	CPUHP_XEN_EVTCHN_PREPARE = 51,
	CPUHP_ARM_SHMOBILE_SCU_PREPARE = 52,
	CPUHP_SH_SH3X_PREPARE = 53,
	CPUHP_TOPOLOGY_PREPARE = 54,
	CPUHP_NET_IUCV_PREPARE = 55,
	CPUHP_ARM_BL_PREPARE = 56,
	CPUHP_TRACE_RB_PREPARE = 57,
	CPUHP_MM_ZS_PREPARE = 58,
	CPUHP_MM_ZSWP_POOL_PREPARE = 59,
	CPUHP_KVM_PPC_BOOK3S_PREPARE = 60,
	CPUHP_ZCOMP_PREPARE = 61,
	CPUHP_TIMERS_PREPARE = 62,
	CPUHP_TMIGR_PREPARE = 63,
	CPUHP_MIPS_SOC_PREPARE = 64,
	CPUHP_BP_PREPARE_DYN = 65,
	CPUHP_BP_PREPARE_DYN_END = 85,
	CPUHP_BP_KICK_AP = 86,
	CPUHP_BRINGUP_CPU = 87,
	CPUHP_AP_IDLE_DEAD = 88,
	CPUHP_AP_OFFLINE = 89,
	CPUHP_AP_CACHECTRL_STARTING = 90,
	CPUHP_AP_SCHED_STARTING = 91,
	CPUHP_AP_RCUTREE_DYING = 92,
	CPUHP_AP_CPU_PM_STARTING = 93,
	CPUHP_AP_IRQ_GIC_STARTING = 94,
	CPUHP_AP_IRQ_HIP04_STARTING = 95,
	CPUHP_AP_IRQ_APPLE_AIC_STARTING = 96,
	CPUHP_AP_IRQ_ARMADA_XP_STARTING = 97,
	CPUHP_AP_IRQ_BCM2836_STARTING = 98,
	CPUHP_AP_IRQ_MIPS_GIC_STARTING = 99,
	CPUHP_AP_IRQ_EIOINTC_STARTING = 100,
	CPUHP_AP_IRQ_AVECINTC_STARTING = 101,
	CPUHP_AP_IRQ_SIFIVE_PLIC_STARTING = 102,
	CPUHP_AP_IRQ_THEAD_ACLINT_SSWI_STARTING = 103,
	CPUHP_AP_IRQ_RISCV_IMSIC_STARTING = 104,
	CPUHP_AP_IRQ_RISCV_SBI_IPI_STARTING = 105,
	CPUHP_AP_ARM_MVEBU_COHERENCY = 106,
	CPUHP_AP_PERF_X86_AMD_UNCORE_STARTING = 107,
	CPUHP_AP_PERF_X86_STARTING = 108,
	CPUHP_AP_PERF_X86_AMD_IBS_STARTING = 109,
	CPUHP_AP_PERF_XTENSA_STARTING = 110,
	CPUHP_AP_ARM_VFP_STARTING = 111,
	CPUHP_AP_ARM64_DEBUG_MONITORS_STARTING = 112,
	CPUHP_AP_PERF_ARM_HW_BREAKPOINT_STARTING = 113,
	CPUHP_AP_PERF_ARM_ACPI_STARTING = 114,
	CPUHP_AP_PERF_ARM_STARTING = 115,
	CPUHP_AP_PERF_RISCV_STARTING = 116,
	CPUHP_AP_ARM_L2X0_STARTING = 117,
	CPUHP_AP_EXYNOS4_MCT_TIMER_STARTING = 118,
	CPUHP_AP_ARM_ARCH_TIMER_STARTING = 119,
	CPUHP_AP_ARM_ARCH_TIMER_EVTSTRM_STARTING = 120,
	CPUHP_AP_ARM_GLOBAL_TIMER_STARTING = 121,
	CPUHP_AP_JCORE_TIMER_STARTING = 122,
	CPUHP_AP_ARM_TWD_STARTING = 123,
	CPUHP_AP_QCOM_TIMER_STARTING = 124,
	CPUHP_AP_TEGRA_TIMER_STARTING = 125,
	CPUHP_AP_ARMADA_TIMER_STARTING = 126,
	CPUHP_AP_MIPS_GIC_TIMER_STARTING = 127,
	CPUHP_AP_ARC_TIMER_STARTING = 128,
	CPUHP_AP_REALTEK_TIMER_STARTING = 129,
	CPUHP_AP_RISCV_TIMER_STARTING = 130,
	CPUHP_AP_CLINT_TIMER_STARTING = 131,
	CPUHP_AP_CSKY_TIMER_STARTING = 132,
	CPUHP_AP_TI_GP_TIMER_STARTING = 133,
	CPUHP_AP_HYPERV_TIMER_STARTING = 134,
	CPUHP_AP_DUMMY_TIMER_STARTING = 135,
	CPUHP_AP_ARM_XEN_STARTING = 136,
	CPUHP_AP_ARM_XEN_RUNSTATE_STARTING = 137,
	CPUHP_AP_ARM_CORESIGHT_STARTING = 138,
	CPUHP_AP_ARM_CORESIGHT_CTI_STARTING = 139,
	CPUHP_AP_ARM64_ISNDEP_STARTING = 140,
	CPUHP_AP_SMPCFD_DYING = 141,
	CPUHP_AP_HRTIMERS_DYING = 142,
	CPUHP_AP_TICK_DYING = 143,
	CPUHP_AP_X86_TBOOT_DYING = 144,
	CPUHP_AP_ARM_CACHE_B15_RAC_DYING = 145,
	CPUHP_AP_ONLINE = 146,
	CPUHP_TEARDOWN_CPU = 147,
	CPUHP_AP_ONLINE_IDLE = 148,
	CPUHP_AP_HYPERV_ONLINE = 149,
	CPUHP_AP_KVM_ONLINE = 150,
	CPUHP_AP_SCHED_WAIT_EMPTY = 151,
	CPUHP_AP_SMPBOOT_THREADS = 152,
	CPUHP_AP_IRQ_AFFINITY_ONLINE = 153,
	CPUHP_AP_BLK_MQ_ONLINE = 154,
	CPUHP_AP_ARM_MVEBU_SYNC_CLOCKS = 155,
	CPUHP_AP_X86_INTEL_EPB_ONLINE = 156,
	CPUHP_AP_PERF_ONLINE = 157,
	CPUHP_AP_PERF_X86_ONLINE = 158,
	CPUHP_AP_PERF_X86_UNCORE_ONLINE = 159,
	CPUHP_AP_PERF_X86_AMD_UNCORE_ONLINE = 160,
	CPUHP_AP_PERF_X86_AMD_POWER_ONLINE = 161,
	CPUHP_AP_PERF_S390_CF_ONLINE = 162,
	CPUHP_AP_PERF_S390_SF_ONLINE = 163,
	CPUHP_AP_PERF_ARM_CCI_ONLINE = 164,
	CPUHP_AP_PERF_ARM_CCN_ONLINE = 165,
	CPUHP_AP_PERF_ARM_HISI_CPA_ONLINE = 166,
	CPUHP_AP_PERF_ARM_HISI_DDRC_ONLINE = 167,
	CPUHP_AP_PERF_ARM_HISI_HHA_ONLINE = 168,
	CPUHP_AP_PERF_ARM_HISI_L3_ONLINE = 169,
	CPUHP_AP_PERF_ARM_HISI_PA_ONLINE = 170,
	CPUHP_AP_PERF_ARM_HISI_SLLC_ONLINE = 171,
	CPUHP_AP_PERF_ARM_HISI_PCIE_PMU_ONLINE = 172,
	CPUHP_AP_PERF_ARM_HNS3_PMU_ONLINE = 173,
	CPUHP_AP_PERF_ARM_L2X0_ONLINE = 174,
	CPUHP_AP_PERF_ARM_QCOM_L2_ONLINE = 175,
	CPUHP_AP_PERF_ARM_QCOM_L3_ONLINE = 176,
	CPUHP_AP_PERF_ARM_APM_XGENE_ONLINE = 177,
	CPUHP_AP_PERF_ARM_CAVIUM_TX2_UNCORE_ONLINE = 178,
	CPUHP_AP_PERF_ARM_MARVELL_CN10K_DDR_ONLINE = 179,
	CPUHP_AP_PERF_ARM_MRVL_PEM_ONLINE = 180,
	CPUHP_AP_PERF_POWERPC_NEST_IMC_ONLINE = 181,
	CPUHP_AP_PERF_POWERPC_CORE_IMC_ONLINE = 182,
	CPUHP_AP_PERF_POWERPC_THREAD_IMC_ONLINE = 183,
	CPUHP_AP_PERF_POWERPC_TRACE_IMC_ONLINE = 184,
	CPUHP_AP_PERF_POWERPC_HV_24x7_ONLINE = 185,
	CPUHP_AP_PERF_POWERPC_HV_GPCI_ONLINE = 186,
	CPUHP_AP_PERF_CSKY_ONLINE = 187,
	CPUHP_AP_TMIGR_ONLINE = 188,
	CPUHP_AP_WATCHDOG_ONLINE = 189,
	CPUHP_AP_WORKQUEUE_ONLINE = 190,
	CPUHP_AP_RANDOM_ONLINE = 191,
	CPUHP_AP_RCUTREE_ONLINE = 192,
	CPUHP_AP_KTHREADS_ONLINE = 193,
	CPUHP_AP_BASE_CACHEINFO_ONLINE = 194,
	CPUHP_AP_ONLINE_DYN = 195,
	CPUHP_AP_ONLINE_DYN_END = 235,
	CPUHP_AP_X86_HPET_ONLINE = 236,
	CPUHP_AP_X86_KVM_CLK_ONLINE = 237,
	CPUHP_AP_ACTIVE = 238,
	CPUHP_ONLINE = 239,
};

enum cpuhp_sync_state {
	SYNC_STATE_DEAD = 0,
	SYNC_STATE_KICKED = 1,
	SYNC_STATE_SHOULD_DIE = 2,
	SYNC_STATE_ALIVE = 3,
	SYNC_STATE_SHOULD_ONLINE = 4,
	SYNC_STATE_ONLINE = 5,
};

enum cpuid_leafs {
	CPUID_1_EDX = 0,
	CPUID_8000_0001_EDX = 1,
	CPUID_8086_0001_EDX = 2,
	CPUID_LNX_1 = 3,
	CPUID_1_ECX = 4,
	CPUID_C000_0001_EDX = 5,
	CPUID_8000_0001_ECX = 6,
	CPUID_LNX_2 = 7,
	CPUID_LNX_3 = 8,
	CPUID_7_0_EBX = 9,
	CPUID_D_1_EAX = 10,
	CPUID_LNX_4 = 11,
	CPUID_7_1_EAX = 12,
	CPUID_8000_0008_EBX = 13,
	CPUID_6_EAX = 14,
	CPUID_8000_000A_EDX = 15,
	CPUID_7_ECX = 16,
	CPUID_8000_0007_EBX = 17,
	CPUID_7_EDX = 18,
	CPUID_8000_001F_EAX = 19,
	CPUID_8000_0021_EAX = 20,
	CPUID_LNX_5 = 21,
	NR_CPUID_WORDS = 22,
};

enum cpuid_regs_idx {
	CPUID_EAX = 0,
	CPUID_EBX = 1,
	CPUID_ECX = 2,
	CPUID_EDX = 3,
};

enum createmode4 {
	NFS4_CREATE_UNCHECKED = 0,
	NFS4_CREATE_GUARDED = 1,
	NFS4_CREATE_EXCLUSIVE = 2,
	NFS4_CREATE_EXCLUSIVE4_1 = 3,
};

enum criteria {
	CR_POWER2_ALIGNED = 0,
	CR_GOAL_LEN_FAST = 1,
	CR_BEST_AVAIL_LEN = 2,
	CR_GOAL_LEN_SLOW = 3,
	CR_ANY_FREE = 4,
	EXT4_MB_NUM_CRS = 5,
};

enum csr_regs {
	B0_RAP = 0,
	B0_CTST = 4,
	B0_POWER_CTRL = 7,
	B0_ISRC = 8,
	B0_IMSK = 12,
	B0_HWE_ISRC = 16,
	B0_HWE_IMSK = 20,
	B0_Y2_SP_ISRC2 = 28,
	B0_Y2_SP_ISRC3 = 32,
	B0_Y2_SP_EISR = 36,
	B0_Y2_SP_LISR = 40,
	B0_Y2_SP_ICR = 44,
	B2_MAC_1 = 256,
	B2_MAC_2 = 264,
	B2_MAC_3 = 272,
	B2_CONN_TYP = 280,
	B2_PMD_TYP = 281,
	B2_MAC_CFG = 282,
	B2_CHIP_ID = 283,
	B2_E_0 = 284,
	B2_Y2_CLK_GATE = 285,
	B2_Y2_HW_RES = 286,
	B2_E_3 = 287,
	B2_Y2_CLK_CTRL = 288,
	B2_TI_INI = 304,
	B2_TI_VAL = 308,
	B2_TI_CTRL = 312,
	B2_TI_TEST = 313,
	B2_TST_CTRL1 = 344,
	B2_TST_CTRL2 = 345,
	B2_GP_IO = 348,
	B2_I2C_CTRL = 352,
	B2_I2C_DATA = 356,
	B2_I2C_IRQ = 360,
	B2_I2C_SW = 364,
	Y2_PEX_PHY_DATA = 368,
	Y2_PEX_PHY_ADDR = 370,
	B3_RAM_ADDR = 384,
	B3_RAM_DATA_LO = 388,
	B3_RAM_DATA_HI = 392,
	B3_RI_WTO_R1 = 400,
	B3_RI_WTO_XA1 = 401,
	B3_RI_WTO_XS1 = 402,
	B3_RI_RTO_R1 = 403,
	B3_RI_RTO_XA1 = 404,
	B3_RI_RTO_XS1 = 405,
	B3_RI_WTO_R2 = 406,
	B3_RI_WTO_XA2 = 407,
	B3_RI_WTO_XS2 = 408,
	B3_RI_RTO_R2 = 409,
	B3_RI_RTO_XA2 = 410,
	B3_RI_RTO_XS2 = 411,
	B3_RI_TO_VAL = 412,
	B3_RI_CTRL = 416,
	B3_RI_TEST = 418,
	B3_MA_TOINI_RX1 = 432,
	B3_MA_TOINI_RX2 = 433,
	B3_MA_TOINI_TX1 = 434,
	B3_MA_TOINI_TX2 = 435,
	B3_MA_TOVAL_RX1 = 436,
	B3_MA_TOVAL_RX2 = 437,
	B3_MA_TOVAL_TX1 = 438,
	B3_MA_TOVAL_TX2 = 439,
	B3_MA_TO_CTRL = 440,
	B3_MA_TO_TEST = 442,
	B3_MA_RCINI_RX1 = 448,
	B3_MA_RCINI_RX2 = 449,
	B3_MA_RCINI_TX1 = 450,
	B3_MA_RCINI_TX2 = 451,
	B3_MA_RCVAL_RX1 = 452,
	B3_MA_RCVAL_RX2 = 453,
	B3_MA_RCVAL_TX1 = 454,
	B3_MA_RCVAL_TX2 = 455,
	B3_MA_RC_CTRL = 456,
	B3_MA_RC_TEST = 458,
	B3_PA_TOINI_RX1 = 464,
	B3_PA_TOINI_RX2 = 468,
	B3_PA_TOINI_TX1 = 472,
	B3_PA_TOINI_TX2 = 476,
	B3_PA_TOVAL_RX1 = 480,
	B3_PA_TOVAL_RX2 = 484,
	B3_PA_TOVAL_TX1 = 488,
	B3_PA_TOVAL_TX2 = 492,
	B3_PA_CTRL = 496,
	B3_PA_TEST = 498,
	Y2_CFG_SPC = 7168,
	Y2_CFG_AER = 7424,
};

enum ctattr_counters {
	CTA_COUNTERS_UNSPEC = 0,
	CTA_COUNTERS_PACKETS = 1,
	CTA_COUNTERS_BYTES = 2,
	CTA_COUNTERS32_PACKETS = 3,
	CTA_COUNTERS32_BYTES = 4,
	CTA_COUNTERS_PAD = 5,
	__CTA_COUNTERS_MAX = 6,
};

enum ctattr_expect {
	CTA_EXPECT_UNSPEC = 0,
	CTA_EXPECT_MASTER = 1,
	CTA_EXPECT_TUPLE = 2,
	CTA_EXPECT_MASK = 3,
	CTA_EXPECT_TIMEOUT = 4,
	CTA_EXPECT_ID = 5,
	CTA_EXPECT_HELP_NAME = 6,
	CTA_EXPECT_ZONE = 7,
	CTA_EXPECT_FLAGS = 8,
	CTA_EXPECT_CLASS = 9,
	CTA_EXPECT_NAT = 10,
	CTA_EXPECT_FN = 11,
	__CTA_EXPECT_MAX = 12,
};

enum ctattr_expect_nat {
	CTA_EXPECT_NAT_UNSPEC = 0,
	CTA_EXPECT_NAT_DIR = 1,
	CTA_EXPECT_NAT_TUPLE = 2,
	__CTA_EXPECT_NAT_MAX = 3,
};

enum ctattr_expect_stats {
	CTA_STATS_EXP_UNSPEC = 0,
	CTA_STATS_EXP_NEW = 1,
	CTA_STATS_EXP_CREATE = 2,
	CTA_STATS_EXP_DELETE = 3,
	__CTA_STATS_EXP_MAX = 4,
};

enum ctattr_filter {
	CTA_FILTER_UNSPEC = 0,
	CTA_FILTER_ORIG_FLAGS = 1,
	CTA_FILTER_REPLY_FLAGS = 2,
	__CTA_FILTER_MAX = 3,
};

enum ctattr_help {
	CTA_HELP_UNSPEC = 0,
	CTA_HELP_NAME = 1,
	CTA_HELP_INFO = 2,
	__CTA_HELP_MAX = 3,
};

enum ctattr_ip {
	CTA_IP_UNSPEC = 0,
	CTA_IP_V4_SRC = 1,
	CTA_IP_V4_DST = 2,
	CTA_IP_V6_SRC = 3,
	CTA_IP_V6_DST = 4,
	__CTA_IP_MAX = 5,
};

enum ctattr_l4proto {
	CTA_PROTO_UNSPEC = 0,
	CTA_PROTO_NUM = 1,
	CTA_PROTO_SRC_PORT = 2,
	CTA_PROTO_DST_PORT = 3,
	CTA_PROTO_ICMP_ID = 4,
	CTA_PROTO_ICMP_TYPE = 5,
	CTA_PROTO_ICMP_CODE = 6,
	CTA_PROTO_ICMPV6_ID = 7,
	CTA_PROTO_ICMPV6_TYPE = 8,
	CTA_PROTO_ICMPV6_CODE = 9,
	__CTA_PROTO_MAX = 10,
};

enum ctattr_nat {
	CTA_NAT_UNSPEC = 0,
	CTA_NAT_V4_MINIP = 1,
	CTA_NAT_V4_MAXIP = 2,
	CTA_NAT_PROTO = 3,
	CTA_NAT_V6_MINIP = 4,
	CTA_NAT_V6_MAXIP = 5,
	__CTA_NAT_MAX = 6,
};

enum ctattr_protoinfo {
	CTA_PROTOINFO_UNSPEC = 0,
	CTA_PROTOINFO_TCP = 1,
	CTA_PROTOINFO_DCCP = 2,
	CTA_PROTOINFO_SCTP = 3,
	__CTA_PROTOINFO_MAX = 4,
};

enum ctattr_protoinfo_tcp {
	CTA_PROTOINFO_TCP_UNSPEC = 0,
	CTA_PROTOINFO_TCP_STATE = 1,
	CTA_PROTOINFO_TCP_WSCALE_ORIGINAL = 2,
	CTA_PROTOINFO_TCP_WSCALE_REPLY = 3,
	CTA_PROTOINFO_TCP_FLAGS_ORIGINAL = 4,
	CTA_PROTOINFO_TCP_FLAGS_REPLY = 5,
	__CTA_PROTOINFO_TCP_MAX = 6,
};

enum ctattr_protonat {
	CTA_PROTONAT_UNSPEC = 0,
	CTA_PROTONAT_PORT_MIN = 1,
	CTA_PROTONAT_PORT_MAX = 2,
	__CTA_PROTONAT_MAX = 3,
};

enum ctattr_secctx {
	CTA_SECCTX_UNSPEC = 0,
	CTA_SECCTX_NAME = 1,
	__CTA_SECCTX_MAX = 2,
};

enum ctattr_seqadj {
	CTA_SEQADJ_UNSPEC = 0,
	CTA_SEQADJ_CORRECTION_POS = 1,
	CTA_SEQADJ_OFFSET_BEFORE = 2,
	CTA_SEQADJ_OFFSET_AFTER = 3,
	__CTA_SEQADJ_MAX = 4,
};

enum ctattr_stats_cpu {
	CTA_STATS_UNSPEC = 0,
	CTA_STATS_SEARCHED = 1,
	CTA_STATS_FOUND = 2,
	CTA_STATS_NEW = 3,
	CTA_STATS_INVALID = 4,
	CTA_STATS_IGNORE = 5,
	CTA_STATS_DELETE = 6,
	CTA_STATS_DELETE_LIST = 7,
	CTA_STATS_INSERT = 8,
	CTA_STATS_INSERT_FAILED = 9,
	CTA_STATS_DROP = 10,
	CTA_STATS_EARLY_DROP = 11,
	CTA_STATS_ERROR = 12,
	CTA_STATS_SEARCH_RESTART = 13,
	CTA_STATS_CLASH_RESOLVE = 14,
	CTA_STATS_CHAIN_TOOLONG = 15,
	__CTA_STATS_MAX = 16,
};

enum ctattr_stats_global {
	CTA_STATS_GLOBAL_UNSPEC = 0,
	CTA_STATS_GLOBAL_ENTRIES = 1,
	CTA_STATS_GLOBAL_MAX_ENTRIES = 2,
	__CTA_STATS_GLOBAL_MAX = 3,
};

enum ctattr_synproxy {
	CTA_SYNPROXY_UNSPEC = 0,
	CTA_SYNPROXY_ISN = 1,
	CTA_SYNPROXY_ITS = 2,
	CTA_SYNPROXY_TSOFF = 3,
	__CTA_SYNPROXY_MAX = 4,
};

enum ctattr_tstamp {
	CTA_TIMESTAMP_UNSPEC = 0,
	CTA_TIMESTAMP_START = 1,
	CTA_TIMESTAMP_STOP = 2,
	CTA_TIMESTAMP_PAD = 3,
	__CTA_TIMESTAMP_MAX = 4,
};

enum ctattr_tuple {
	CTA_TUPLE_UNSPEC = 0,
	CTA_TUPLE_IP = 1,
	CTA_TUPLE_PROTO = 2,
	CTA_TUPLE_ZONE = 3,
	__CTA_TUPLE_MAX = 4,
};

enum ctattr_type {
	CTA_UNSPEC = 0,
	CTA_TUPLE_ORIG = 1,
	CTA_TUPLE_REPLY = 2,
	CTA_STATUS = 3,
	CTA_PROTOINFO = 4,
	CTA_HELP = 5,
	CTA_NAT_SRC = 6,
	CTA_TIMEOUT = 7,
	CTA_MARK = 8,
	CTA_COUNTERS_ORIG = 9,
	CTA_COUNTERS_REPLY = 10,
	CTA_USE = 11,
	CTA_ID = 12,
	CTA_NAT_DST = 13,
	CTA_TUPLE_MASTER = 14,
	CTA_SEQ_ADJ_ORIG = 15,
	CTA_NAT_SEQ_ADJ_ORIG = 15,
	CTA_SEQ_ADJ_REPLY = 16,
	CTA_NAT_SEQ_ADJ_REPLY = 16,
	CTA_SECMARK = 17,
	CTA_ZONE = 18,
	CTA_SECCTX = 19,
	CTA_TIMESTAMP = 20,
	CTA_MARK_MASK = 21,
	CTA_LABELS = 22,
	CTA_LABELS_MASK = 23,
	CTA_SYNPROXY = 24,
	CTA_FILTER = 25,
	CTA_STATUS_MASK = 26,
	CTA_TIMESTAMP_EVENT = 27,
	__CTA_MAX = 28,
};

enum cti_port_type {
	CTI_PORT_TYPE_NONE = 0,
	CTI_PORT_TYPE_RS232 = 1,
	CTI_PORT_TYPE_RS422_485 = 2,
	CTI_PORT_TYPE_RS232_422_485_HW = 3,
	CTI_PORT_TYPE_RS232_422_485_SW = 4,
	CTI_PORT_TYPE_RS232_422_485_4B = 5,
	CTI_PORT_TYPE_RS232_422_485_2B = 6,
	CTI_PORT_TYPE_MAX = 7,
};

enum ctnl_exp_msg_types {
	IPCTNL_MSG_EXP_NEW = 0,
	IPCTNL_MSG_EXP_GET = 1,
	IPCTNL_MSG_EXP_DELETE = 2,
	IPCTNL_MSG_EXP_GET_STATS_CPU = 3,
	IPCTNL_MSG_EXP_MAX = 4,
};

enum ctx_state {
	CT_STATE_DISABLED = -1,
	CT_STATE_KERNEL = 0,
	CT_STATE_IDLE = 1,
	CT_STATE_USER = 2,
	CT_STATE_GUEST = 3,
	CT_STATE_MAX = 4,
};

enum cuc_dump {
	cuc_dump_complete = 40965,
	cuc_dump_reset_complete = 40967,
};

enum d_real_type {
	D_REAL_DATA = 0,
	D_REAL_METADATA = 1,
};

enum d_walk_ret {
	D_WALK_CONTINUE = 0,
	D_WALK_QUIT = 1,
	D_WALK_NORETRY = 2,
	D_WALK_SKIP = 3,
};

enum dax_access_mode {
	DAX_ACCESS = 0,
	DAX_RECOVERY_WRITE = 1,
};

enum dbc_state {
	DS_DISABLED = 0,
	DS_INITIALIZED = 1,
	DS_ENABLED = 2,
	DS_CONNECTED = 3,
	DS_CONFIGURED = 4,
	DS_MAX = 5,
};

enum dbgfs_get_mode {
	DBGFS_GET_ALREADY = 0,
	DBGFS_GET_REGULAR = 1,
	DBGFS_GET_SHORT = 2,
};

enum dbuf_slice {
	DBUF_S1 = 0,
	DBUF_S2 = 1,
	DBUF_S3 = 2,
	DBUF_S4 = 3,
	I915_MAX_DBUF_SLICES = 4,
};

enum dccp_state {
	DCCP_OPEN = 1,
	DCCP_REQUESTING = 2,
	DCCP_LISTEN = 10,
	DCCP_RESPOND = 3,
	DCCP_ACTIVE_CLOSEREQ = 4,
	DCCP_PASSIVE_CLOSE = 8,
	DCCP_CLOSING = 11,
	DCCP_TIME_WAIT = 6,
	DCCP_CLOSED = 7,
	DCCP_NEW_SYN_RECV = 12,
	DCCP_PARTOPEN = 14,
	DCCP_PASSIVE_CLOSEREQ = 15,
	DCCP_MAX_STATES = 16,
};

enum dd_data_dir {
	DD_READ = 0,
	DD_WRITE = 1,
};

enum dd_prio {
	DD_RT_PRIO = 0,
	DD_BE_PRIO = 1,
	DD_IDLE_PRIO = 2,
	DD_PRIO_MAX = 2,
};

enum dentry_d_lock_class {
	DENTRY_D_LOCK_NORMAL = 0,
	DENTRY_D_LOCK_NESTED = 1,
};

enum depot_counter_id {
	DEPOT_COUNTER_REFD_ALLOCS = 0,
	DEPOT_COUNTER_REFD_FREES = 1,
	DEPOT_COUNTER_REFD_INUSE = 2,
	DEPOT_COUNTER_FREELIST_SIZE = 3,
	DEPOT_COUNTER_PERSIST_COUNT = 4,
	DEPOT_COUNTER_PERSIST_BYTES = 5,
	DEPOT_COUNTER_COUNT = 6,
};

enum desc_state {
	desc_miss = -1,
	desc_reserved = 0,
	desc_committed = 1,
	desc_finalized = 2,
	desc_reusable = 3,
};

enum dev_dma_attr {
	DEV_DMA_NOT_SUPPORTED = 0,
	DEV_DMA_NON_COHERENT = 1,
	DEV_DMA_COHERENT = 2,
};

enum dev_pm_qos_req_type {
	DEV_PM_QOS_RESUME_LATENCY = 1,
	DEV_PM_QOS_LATENCY_TOLERANCE = 2,
	DEV_PM_QOS_MIN_FREQUENCY = 3,
	DEV_PM_QOS_MAX_FREQUENCY = 4,
	DEV_PM_QOS_FLAGS = 5,
};

enum dev_prop_type {
	DEV_PROP_U8 = 0,
	DEV_PROP_U16 = 1,
	DEV_PROP_U32 = 2,
	DEV_PROP_U64 = 3,
	DEV_PROP_STRING = 4,
	DEV_PROP_REF = 5,
};

enum devcg_behavior {
	DEVCG_DEFAULT_NONE = 0,
	DEVCG_DEFAULT_ALLOW = 1,
	DEVCG_DEFAULT_DENY = 2,
};

enum device_link_state {
	DL_STATE_NONE = -1,
	DL_STATE_DORMANT = 0,
	DL_STATE_AVAILABLE = 1,
	DL_STATE_CONSUMER_PROBE = 2,
	DL_STATE_ACTIVE = 3,
	DL_STATE_SUPPLIER_UNBIND = 4,
};

enum device_physical_location_horizontal_position {
	DEVICE_HORI_POS_LEFT = 0,
	DEVICE_HORI_POS_CENTER = 1,
	DEVICE_HORI_POS_RIGHT = 2,
};

enum device_physical_location_panel {
	DEVICE_PANEL_TOP = 0,
	DEVICE_PANEL_BOTTOM = 1,
	DEVICE_PANEL_LEFT = 2,
	DEVICE_PANEL_RIGHT = 3,
	DEVICE_PANEL_FRONT = 4,
	DEVICE_PANEL_BACK = 5,
	DEVICE_PANEL_UNKNOWN = 6,
};

enum device_physical_location_vertical_position {
	DEVICE_VERT_POS_UPPER = 0,
	DEVICE_VERT_POS_CENTER = 1,
	DEVICE_VERT_POS_LOWER = 2,
};

enum device_removable {
	DEVICE_REMOVABLE_NOT_SUPPORTED = 0,
	DEVICE_REMOVABLE_UNKNOWN = 1,
	DEVICE_FIXED = 2,
	DEVICE_REMOVABLE = 3,
};

enum devkmsg_log_bits {
	__DEVKMSG_LOG_BIT_ON = 0,
	__DEVKMSG_LOG_BIT_OFF = 1,
	__DEVKMSG_LOG_BIT_LOCK = 2,
};

enum devkmsg_log_masks {
	DEVKMSG_LOG_MASK_ON = 1,
	DEVKMSG_LOG_MASK_OFF = 2,
	DEVKMSG_LOG_MASK_LOCK = 4,
};

enum devlink_port_flavour {
	DEVLINK_PORT_FLAVOUR_PHYSICAL = 0,
	DEVLINK_PORT_FLAVOUR_CPU = 1,
	DEVLINK_PORT_FLAVOUR_DSA = 2,
	DEVLINK_PORT_FLAVOUR_PCI_PF = 3,
	DEVLINK_PORT_FLAVOUR_PCI_VF = 4,
	DEVLINK_PORT_FLAVOUR_VIRTUAL = 5,
	DEVLINK_PORT_FLAVOUR_UNUSED = 6,
	DEVLINK_PORT_FLAVOUR_PCI_SF = 7,
};

enum devlink_port_fn_opstate {
	DEVLINK_PORT_FN_OPSTATE_DETACHED = 0,
	DEVLINK_PORT_FN_OPSTATE_ATTACHED = 1,
};

enum devlink_port_fn_state {
	DEVLINK_PORT_FN_STATE_INACTIVE = 0,
	DEVLINK_PORT_FN_STATE_ACTIVE = 1,
};

enum devlink_port_type {
	DEVLINK_PORT_TYPE_NOTSET = 0,
	DEVLINK_PORT_TYPE_AUTO = 1,
	DEVLINK_PORT_TYPE_ETH = 2,
	DEVLINK_PORT_TYPE_IB = 3,
};

enum devlink_rate_type {
	DEVLINK_RATE_TYPE_LEAF = 0,
	DEVLINK_RATE_TYPE_NODE = 1,
};

enum devm_ioremap_type {
	DEVM_IOREMAP = 0,
	DEVM_IOREMAP_UC = 1,
	DEVM_IOREMAP_WC = 2,
	DEVM_IOREMAP_NP = 3,
};

enum die_val {
	DIE_OOPS = 1,
	DIE_INT3 = 2,
	DIE_DEBUG = 3,
	DIE_PANIC = 4,
	DIE_NMI = 5,
	DIE_DIE = 6,
	DIE_KERNELDEBUG = 7,
	DIE_TRAP = 8,
	DIE_GPF = 9,
	DIE_CALL = 10,
	DIE_PAGE_FAULT = 11,
	DIE_NMIUNKNOWN = 12,
};

enum dim_cq_period_mode {
	DIM_CQ_PERIOD_MODE_START_FROM_EQE = 0,
	DIM_CQ_PERIOD_MODE_START_FROM_CQE = 1,
	DIM_CQ_PERIOD_NUM_MODES = 2,
};

enum dim_state {
	DIM_START_MEASURE = 0,
	DIM_MEASURE_IN_PROGRESS = 1,
	DIM_APPLY_NEW_PROFILE = 2,
};

enum dim_stats_state {
	DIM_STATS_WORSE = 0,
	DIM_STATS_SAME = 1,
	DIM_STATS_BETTER = 2,
};

enum dim_step_result {
	DIM_STEPPED = 0,
	DIM_TOO_TIRED = 1,
	DIM_ON_EDGE = 2,
};

enum dim_tune_state {
	DIM_PARKING_ON_TOP = 0,
	DIM_PARKING_TIRED = 1,
	DIM_GOING_RIGHT = 2,
	DIM_GOING_LEFT = 3,
};

enum dl_bw_request {
	dl_bw_req_deactivate = 0,
	dl_bw_req_alloc = 1,
	dl_bw_req_free = 2,
};

enum dl_dev_state {
	DL_DEV_NO_DRIVER = 0,
	DL_DEV_PROBING = 1,
	DL_DEV_DRIVER_BOUND = 2,
	DL_DEV_UNBINDING = 3,
};

enum dm_io_mem_type {
	DM_IO_PAGE_LIST = 0,
	DM_IO_BIO = 1,
	DM_IO_VMA = 2,
	DM_IO_KMEM = 3,
};

enum dm_queue_mode {
	DM_TYPE_NONE = 0,
	DM_TYPE_BIO_BASED = 1,
	DM_TYPE_REQUEST_BASED = 2,
	DM_TYPE_DAX_BIO_BASED = 3,
};

enum dm_raid1_error {
	DM_RAID1_WRITE_ERROR = 0,
	DM_RAID1_FLUSH_ERROR = 1,
	DM_RAID1_SYNC_ERROR = 2,
	DM_RAID1_READ_ERROR = 3,
};

enum dm_rh_region_states {
	DM_RH_CLEAN = 1,
	DM_RH_DIRTY = 2,
	DM_RH_NOSYNC = 4,
	DM_RH_RECOVERING = 8,
};

enum dma_ctrl_flags {
	DMA_PREP_INTERRUPT = 1,
	DMA_CTRL_ACK = 2,
	DMA_PREP_PQ_DISABLE_P = 4,
	DMA_PREP_PQ_DISABLE_Q = 8,
	DMA_PREP_CONTINUE = 16,
	DMA_PREP_FENCE = 32,
	DMA_CTRL_REUSE = 64,
	DMA_PREP_CMD = 128,
	DMA_PREP_REPEAT = 256,
	DMA_PREP_LOAD_EOT = 512,
};

enum dma_data_direction {
	DMA_BIDIRECTIONAL = 0,
	DMA_TO_DEVICE = 1,
	DMA_FROM_DEVICE = 2,
	DMA_NONE = 3,
};

enum dma_desc_metadata_mode {
	DESC_METADATA_NONE = 0,
	DESC_METADATA_CLIENT = 1,
	DESC_METADATA_ENGINE = 2,
};

enum dma_fence_flag_bits {
	DMA_FENCE_FLAG_SIGNALED_BIT = 0,
	DMA_FENCE_FLAG_TIMESTAMP_BIT = 1,
	DMA_FENCE_FLAG_ENABLE_SIGNAL_BIT = 2,
	DMA_FENCE_FLAG_USER_BITS = 3,
};

enum dma_residue_granularity {
	DMA_RESIDUE_GRANULARITY_DESCRIPTOR = 0,
	DMA_RESIDUE_GRANULARITY_SEGMENT = 1,
	DMA_RESIDUE_GRANULARITY_BURST = 2,
};

enum dma_resv_usage {
	DMA_RESV_USAGE_KERNEL = 0,
	DMA_RESV_USAGE_WRITE = 1,
	DMA_RESV_USAGE_READ = 2,
	DMA_RESV_USAGE_BOOKKEEP = 3,
};

enum dma_slave_buswidth {
	DMA_SLAVE_BUSWIDTH_UNDEFINED = 0,
	DMA_SLAVE_BUSWIDTH_1_BYTE = 1,
	DMA_SLAVE_BUSWIDTH_2_BYTES = 2,
	DMA_SLAVE_BUSWIDTH_3_BYTES = 3,
	DMA_SLAVE_BUSWIDTH_4_BYTES = 4,
	DMA_SLAVE_BUSWIDTH_8_BYTES = 8,
	DMA_SLAVE_BUSWIDTH_16_BYTES = 16,
	DMA_SLAVE_BUSWIDTH_32_BYTES = 32,
	DMA_SLAVE_BUSWIDTH_64_BYTES = 64,
	DMA_SLAVE_BUSWIDTH_128_BYTES = 128,
};

enum dma_status {
	DMA_COMPLETE = 0,
	DMA_IN_PROGRESS = 1,
	DMA_PAUSED = 2,
	DMA_ERROR = 3,
	DMA_OUT_OF_ORDER = 4,
};

enum dma_transaction_type {
	DMA_MEMCPY = 0,
	DMA_XOR = 1,
	DMA_PQ = 2,
	DMA_XOR_VAL = 3,
	DMA_PQ_VAL = 4,
	DMA_MEMSET = 5,
	DMA_MEMSET_SG = 6,
	DMA_INTERRUPT = 7,
	DMA_PRIVATE = 8,
	DMA_ASYNC_TX = 9,
	DMA_SLAVE = 10,
	DMA_CYCLIC = 11,
	DMA_INTERLEAVE = 12,
	DMA_COMPLETION_NO_ORDER = 13,
	DMA_REPEAT = 14,
	DMA_LOAD_EOT = 15,
	DMA_TX_TYPE_END = 16,
};

enum dma_transfer_direction {
	DMA_MEM_TO_MEM = 0,
	DMA_MEM_TO_DEV = 1,
	DMA_DEV_TO_MEM = 2,
	DMA_DEV_TO_DEV = 3,
	DMA_TRANS_NONE = 4,
};

enum dmaengine_alignment {
	DMAENGINE_ALIGN_1_BYTE = 0,
	DMAENGINE_ALIGN_2_BYTES = 1,
	DMAENGINE_ALIGN_4_BYTES = 2,
	DMAENGINE_ALIGN_8_BYTES = 3,
	DMAENGINE_ALIGN_16_BYTES = 4,
	DMAENGINE_ALIGN_32_BYTES = 5,
	DMAENGINE_ALIGN_64_BYTES = 6,
	DMAENGINE_ALIGN_128_BYTES = 7,
	DMAENGINE_ALIGN_256_BYTES = 8,
};

enum dmaengine_tx_result {
	DMA_TRANS_NOERROR = 0,
	DMA_TRANS_READ_FAILED = 1,
	DMA_TRANS_WRITE_FAILED = 2,
	DMA_TRANS_ABORTED = 3,
};

enum dmi_device_type {
	DMI_DEV_TYPE_ANY = 0,
	DMI_DEV_TYPE_OTHER = 1,
	DMI_DEV_TYPE_UNKNOWN = 2,
	DMI_DEV_TYPE_VIDEO = 3,
	DMI_DEV_TYPE_SCSI = 4,
	DMI_DEV_TYPE_ETHERNET = 5,
	DMI_DEV_TYPE_TOKENRING = 6,
	DMI_DEV_TYPE_SOUND = 7,
	DMI_DEV_TYPE_PATA = 8,
	DMI_DEV_TYPE_SATA = 9,
	DMI_DEV_TYPE_SAS = 10,
	DMI_DEV_TYPE_IPMI = -1,
	DMI_DEV_TYPE_OEM_STRING = -2,
	DMI_DEV_TYPE_DEV_ONBOARD = -3,
	DMI_DEV_TYPE_DEV_SLOT = -4,
};

enum dmi_entry_type {
	DMI_ENTRY_BIOS = 0,
	DMI_ENTRY_SYSTEM = 1,
	DMI_ENTRY_BASEBOARD = 2,
	DMI_ENTRY_CHASSIS = 3,
	DMI_ENTRY_PROCESSOR = 4,
	DMI_ENTRY_MEM_CONTROLLER = 5,
	DMI_ENTRY_MEM_MODULE = 6,
	DMI_ENTRY_CACHE = 7,
	DMI_ENTRY_PORT_CONNECTOR = 8,
	DMI_ENTRY_SYSTEM_SLOT = 9,
	DMI_ENTRY_ONBOARD_DEVICE = 10,
	DMI_ENTRY_OEMSTRINGS = 11,
	DMI_ENTRY_SYSCONF = 12,
	DMI_ENTRY_BIOS_LANG = 13,
	DMI_ENTRY_GROUP_ASSOC = 14,
	DMI_ENTRY_SYSTEM_EVENT_LOG = 15,
	DMI_ENTRY_PHYS_MEM_ARRAY = 16,
	DMI_ENTRY_MEM_DEVICE = 17,
	DMI_ENTRY_32_MEM_ERROR = 18,
	DMI_ENTRY_MEM_ARRAY_MAPPED_ADDR = 19,
	DMI_ENTRY_MEM_DEV_MAPPED_ADDR = 20,
	DMI_ENTRY_BUILTIN_POINTING_DEV = 21,
	DMI_ENTRY_PORTABLE_BATTERY = 22,
	DMI_ENTRY_SYSTEM_RESET = 23,
	DMI_ENTRY_HW_SECURITY = 24,
	DMI_ENTRY_SYSTEM_POWER_CONTROLS = 25,
	DMI_ENTRY_VOLTAGE_PROBE = 26,
	DMI_ENTRY_COOLING_DEV = 27,
	DMI_ENTRY_TEMP_PROBE = 28,
	DMI_ENTRY_ELECTRICAL_CURRENT_PROBE = 29,
	DMI_ENTRY_OOB_REMOTE_ACCESS = 30,
	DMI_ENTRY_BIS_ENTRY = 31,
	DMI_ENTRY_SYSTEM_BOOT = 32,
	DMI_ENTRY_MGMT_DEV = 33,
	DMI_ENTRY_MGMT_DEV_COMPONENT = 34,
	DMI_ENTRY_MGMT_DEV_THRES = 35,
	DMI_ENTRY_MEM_CHANNEL = 36,
	DMI_ENTRY_IPMI_DEV = 37,
	DMI_ENTRY_SYS_POWER_SUPPLY = 38,
	DMI_ENTRY_ADDITIONAL = 39,
	DMI_ENTRY_ONBOARD_DEV_EXT = 40,
	DMI_ENTRY_MGMT_CONTROLLER_HOST = 41,
	DMI_ENTRY_INACTIVE = 126,
	DMI_ENTRY_END_OF_TABLE = 127,
};

enum dmi_field {
	DMI_NONE = 0,
	DMI_BIOS_VENDOR = 1,
	DMI_BIOS_VERSION = 2,
	DMI_BIOS_DATE = 3,
	DMI_BIOS_RELEASE = 4,
	DMI_EC_FIRMWARE_RELEASE = 5,
	DMI_SYS_VENDOR = 6,
	DMI_PRODUCT_NAME = 7,
	DMI_PRODUCT_VERSION = 8,
	DMI_PRODUCT_SERIAL = 9,
	DMI_PRODUCT_UUID = 10,
	DMI_PRODUCT_SKU = 11,
	DMI_PRODUCT_FAMILY = 12,
	DMI_BOARD_VENDOR = 13,
	DMI_BOARD_NAME = 14,
	DMI_BOARD_VERSION = 15,
	DMI_BOARD_SERIAL = 16,
	DMI_BOARD_ASSET_TAG = 17,
	DMI_CHASSIS_VENDOR = 18,
	DMI_CHASSIS_TYPE = 19,
	DMI_CHASSIS_VERSION = 20,
	DMI_CHASSIS_SERIAL = 21,
	DMI_CHASSIS_ASSET_TAG = 22,
	DMI_STRING_MAX = 23,
	DMI_OEM_STRING = 24,
};

enum dns_lookup_status {
	DNS_LOOKUP_NOT_DONE = 0,
	DNS_LOOKUP_GOOD = 1,
	DNS_LOOKUP_GOOD_WITH_BAD = 2,
	DNS_LOOKUP_BAD = 3,
	DNS_LOOKUP_GOT_NOT_FOUND = 4,
	DNS_LOOKUP_GOT_LOCAL_FAILURE = 5,
	DNS_LOOKUP_GOT_TEMP_FAILURE = 6,
	DNS_LOOKUP_GOT_NS_FAILURE = 7,
	NR__dns_lookup_status = 8,
};

enum dns_payload_content_type {
	DNS_PAYLOAD_IS_SERVER_LIST = 0,
};

enum dock_callback_type {
	DOCK_CALL_HANDLER = 0,
	DOCK_CALL_FIXUP = 1,
	DOCK_CALL_UEVENT = 2,
};

enum dp_colorimetry {
	DP_COLORIMETRY_DEFAULT = 0,
	DP_COLORIMETRY_RGB_WIDE_FIXED = 1,
	DP_COLORIMETRY_BT709_YCC = 1,
	DP_COLORIMETRY_RGB_WIDE_FLOAT = 2,
	DP_COLORIMETRY_XVYCC_601 = 2,
	DP_COLORIMETRY_OPRGB = 3,
	DP_COLORIMETRY_XVYCC_709 = 3,
	DP_COLORIMETRY_DCI_P3_RGB = 4,
	DP_COLORIMETRY_SYCC_601 = 4,
	DP_COLORIMETRY_RGB_CUSTOM = 5,
	DP_COLORIMETRY_OPYCC_601 = 5,
	DP_COLORIMETRY_BT2020_RGB = 6,
	DP_COLORIMETRY_BT2020_CYCC = 6,
	DP_COLORIMETRY_BT2020_YCC = 7,
};

enum dp_content_type {
	DP_CONTENT_TYPE_NOT_DEFINED = 0,
	DP_CONTENT_TYPE_GRAPHICS = 1,
	DP_CONTENT_TYPE_PHOTO = 2,
	DP_CONTENT_TYPE_VIDEO = 3,
	DP_CONTENT_TYPE_GAME = 4,
};

enum dp_dynamic_range {
	DP_DYNAMIC_RANGE_VESA = 0,
	DP_DYNAMIC_RANGE_CTA = 1,
};

enum dp_pixelformat {
	DP_PIXELFORMAT_RGB = 0,
	DP_PIXELFORMAT_YUV444 = 1,
	DP_PIXELFORMAT_YUV422 = 2,
	DP_PIXELFORMAT_YUV420 = 3,
	DP_PIXELFORMAT_Y_ONLY = 4,
	DP_PIXELFORMAT_RAW = 5,
	DP_PIXELFORMAT_RESERVED = 6,
};

enum dpio_channel {
	DPIO_CH0 = 0,
	DPIO_CH1 = 1,
};

enum dpio_phy {
	DPIO_PHY0 = 0,
	DPIO_PHY1 = 1,
	DPIO_PHY2 = 2,
};

enum dpm_order {
	DPM_ORDER_NONE = 0,
	DPM_ORDER_DEV_AFTER_PARENT = 1,
	DPM_ORDER_PARENT_BEFORE_DEV = 2,
	DPM_ORDER_DEV_LAST = 3,
};

enum drbg_prefixes {
	DRBG_PREFIX0 = 0,
	DRBG_PREFIX1 = 1,
	DRBG_PREFIX2 = 2,
	DRBG_PREFIX3 = 3,
};

enum drbg_seed_state {
	DRBG_SEED_STATE_UNSEEDED = 0,
	DRBG_SEED_STATE_PARTIAL = 1,
	DRBG_SEED_STATE_FULL = 2,
};

enum drm_bridge_attach_flags {
	DRM_BRIDGE_ATTACH_NO_CONNECTOR = 1,
};

enum drm_bridge_ops {
	DRM_BRIDGE_OP_DETECT = 1,
	DRM_BRIDGE_OP_EDID = 2,
	DRM_BRIDGE_OP_HPD = 4,
	DRM_BRIDGE_OP_MODES = 8,
	DRM_BRIDGE_OP_HDMI = 16,
};

enum drm_color_encoding {
	DRM_COLOR_YCBCR_BT601 = 0,
	DRM_COLOR_YCBCR_BT709 = 1,
	DRM_COLOR_YCBCR_BT2020 = 2,
	DRM_COLOR_ENCODING_MAX = 3,
};

enum drm_color_lut_tests {
	DRM_COLOR_LUT_EQUAL_CHANNELS = 1,
	DRM_COLOR_LUT_NON_DECREASING = 2,
};

enum drm_color_range {
	DRM_COLOR_YCBCR_LIMITED_RANGE = 0,
	DRM_COLOR_YCBCR_FULL_RANGE = 1,
	DRM_COLOR_RANGE_MAX = 2,
};

enum drm_colorspace {
	DRM_MODE_COLORIMETRY_DEFAULT = 0,
	DRM_MODE_COLORIMETRY_NO_DATA = 0,
	DRM_MODE_COLORIMETRY_SMPTE_170M_YCC = 1,
	DRM_MODE_COLORIMETRY_BT709_YCC = 2,
	DRM_MODE_COLORIMETRY_XVYCC_601 = 3,
	DRM_MODE_COLORIMETRY_XVYCC_709 = 4,
	DRM_MODE_COLORIMETRY_SYCC_601 = 5,
	DRM_MODE_COLORIMETRY_OPYCC_601 = 6,
	DRM_MODE_COLORIMETRY_OPRGB = 7,
	DRM_MODE_COLORIMETRY_BT2020_CYCC = 8,
	DRM_MODE_COLORIMETRY_BT2020_RGB = 9,
	DRM_MODE_COLORIMETRY_BT2020_YCC = 10,
	DRM_MODE_COLORIMETRY_DCI_P3_RGB_D65 = 11,
	DRM_MODE_COLORIMETRY_DCI_P3_RGB_THEATER = 12,
	DRM_MODE_COLORIMETRY_RGB_WIDE_FIXED = 13,
	DRM_MODE_COLORIMETRY_RGB_WIDE_FLOAT = 14,
	DRM_MODE_COLORIMETRY_BT601_YCC = 15,
	DRM_MODE_COLORIMETRY_COUNT = 16,
};

enum drm_connector_force {
	DRM_FORCE_UNSPECIFIED = 0,
	DRM_FORCE_OFF = 1,
	DRM_FORCE_ON = 2,
	DRM_FORCE_ON_DIGITAL = 3,
};

enum drm_connector_registration_state {
	DRM_CONNECTOR_INITIALIZING = 0,
	DRM_CONNECTOR_REGISTERED = 1,
	DRM_CONNECTOR_UNREGISTERED = 2,
};

enum drm_connector_status {
	connector_status_connected = 1,
	connector_status_disconnected = 2,
	connector_status_unknown = 3,
};

enum drm_connector_tv_mode {
	DRM_MODE_TV_MODE_NTSC = 0,
	DRM_MODE_TV_MODE_NTSC_443 = 1,
	DRM_MODE_TV_MODE_NTSC_J = 2,
	DRM_MODE_TV_MODE_PAL = 3,
	DRM_MODE_TV_MODE_PAL_M = 4,
	DRM_MODE_TV_MODE_PAL_N = 5,
	DRM_MODE_TV_MODE_SECAM = 6,
	DRM_MODE_TV_MODE_MONOCHROME = 7,
	DRM_MODE_TV_MODE_MAX = 8,
};

enum drm_debug_category {
	DRM_UT_CORE = 0,
	DRM_UT_DRIVER = 1,
	DRM_UT_KMS = 2,
	DRM_UT_PRIME = 3,
	DRM_UT_ATOMIC = 4,
	DRM_UT_VBL = 5,
	DRM_UT_STATE = 6,
	DRM_UT_LEASE = 7,
	DRM_UT_DP = 8,
	DRM_UT_DRMRES = 9,
};

enum drm_dp_dual_mode_type {
	DRM_DP_DUAL_MODE_NONE = 0,
	DRM_DP_DUAL_MODE_UNKNOWN = 1,
	DRM_DP_DUAL_MODE_TYPE1_DVI = 2,
	DRM_DP_DUAL_MODE_TYPE1_HDMI = 3,
	DRM_DP_DUAL_MODE_TYPE2_DVI = 4,
	DRM_DP_DUAL_MODE_TYPE2_HDMI = 5,
	DRM_DP_DUAL_MODE_LSPCON = 6,
};

enum drm_dp_mst_mode {
	DRM_DP_SST = 0,
	DRM_DP_MST = 1,
	DRM_DP_SST_SIDEBAND_MSG = 2,
};

enum drm_dp_mst_payload_allocation {
	DRM_DP_MST_PAYLOAD_ALLOCATION_NONE = 0,
	DRM_DP_MST_PAYLOAD_ALLOCATION_LOCAL = 1,
	DRM_DP_MST_PAYLOAD_ALLOCATION_DFP = 2,
	DRM_DP_MST_PAYLOAD_ALLOCATION_REMOTE = 3,
};

enum drm_dp_phy {
	DP_PHY_DPRX = 0,
	DP_PHY_LTTPR1 = 1,
	DP_PHY_LTTPR2 = 2,
	DP_PHY_LTTPR3 = 3,
	DP_PHY_LTTPR4 = 4,
	DP_PHY_LTTPR5 = 5,
	DP_PHY_LTTPR6 = 6,
	DP_PHY_LTTPR7 = 7,
	DP_PHY_LTTPR8 = 8,
	DP_MAX_LTTPR_COUNT = 8,
};

enum drm_dp_quirk {
	DP_DPCD_QUIRK_CONSTANT_N = 0,
	DP_DPCD_QUIRK_NO_PSR = 1,
	DP_DPCD_QUIRK_NO_SINK_COUNT = 2,
	DP_DPCD_QUIRK_DSC_WITHOUT_VIRTUAL_DPCD = 3,
	DP_DPCD_QUIRK_CAN_DO_MAX_LINK_RATE_3_24_GBPS = 4,
	DP_DPCD_QUIRK_HBLANK_EXPANSION_REQUIRES_DSC = 5,
};

enum drm_driver_feature {
	DRIVER_GEM = 1,
	DRIVER_MODESET = 2,
	DRIVER_RENDER = 8,
	DRIVER_ATOMIC = 16,
	DRIVER_SYNCOBJ = 32,
	DRIVER_SYNCOBJ_TIMELINE = 64,
	DRIVER_COMPUTE_ACCEL = 128,
	DRIVER_GEM_GPUVA = 256,
	DRIVER_CURSOR_HOTSPOT = 512,
	DRIVER_USE_AGP = 33554432,
	DRIVER_LEGACY = 67108864,
	DRIVER_PCI_DMA = 134217728,
	DRIVER_SG = 268435456,
	DRIVER_HAVE_DMA = 536870912,
	DRIVER_HAVE_IRQ = 1073741824,
};

enum drm_dsc_params_type {
	DRM_DSC_1_2_444 = 0,
	DRM_DSC_1_1_PRE_SCR = 1,
	DRM_DSC_1_2_422 = 2,
	DRM_DSC_1_2_420 = 3,
};

enum drm_gem_object_status {
	DRM_GEM_OBJECT_RESIDENT = 1,
	DRM_GEM_OBJECT_PURGEABLE = 2,
	DRM_GEM_OBJECT_ACTIVE = 4,
};

enum drm_gpuva_flags {
	DRM_GPUVA_INVALIDATED = 1,
	DRM_GPUVA_SPARSE = 2,
	DRM_GPUVA_USERBITS = 4,
};

enum drm_gpuva_op_type {
	DRM_GPUVA_OP_MAP = 0,
	DRM_GPUVA_OP_REMAP = 1,
	DRM_GPUVA_OP_UNMAP = 2,
	DRM_GPUVA_OP_PREFETCH = 3,
};

enum drm_gpuvm_flags {
	DRM_GPUVM_RESV_PROTECTED = 1,
	DRM_GPUVM_USERBITS = 2,
};

enum drm_hdmi_broadcast_rgb {
	DRM_HDMI_BROADCAST_RGB_AUTO = 0,
	DRM_HDMI_BROADCAST_RGB_FULL = 1,
	DRM_HDMI_BROADCAST_RGB_LIMITED = 2,
};

enum drm_i915_gem_engine_class {
	I915_ENGINE_CLASS_RENDER = 0,
	I915_ENGINE_CLASS_COPY = 1,
	I915_ENGINE_CLASS_VIDEO = 2,
	I915_ENGINE_CLASS_VIDEO_ENHANCE = 3,
	I915_ENGINE_CLASS_COMPUTE = 4,
	I915_ENGINE_CLASS_INVALID = -1,
};

enum drm_i915_gem_memory_class {
	I915_MEMORY_CLASS_SYSTEM = 0,
	I915_MEMORY_CLASS_DEVICE = 1,
};

enum drm_i915_oa_format {
	I915_OA_FORMAT_A13 = 1,
	I915_OA_FORMAT_A29 = 2,
	I915_OA_FORMAT_A13_B8_C8 = 3,
	I915_OA_FORMAT_B4_C8 = 4,
	I915_OA_FORMAT_A45_B8_C8 = 5,
	I915_OA_FORMAT_B4_C8_A16 = 6,
	I915_OA_FORMAT_C4_B8 = 7,
	I915_OA_FORMAT_A12 = 8,
	I915_OA_FORMAT_A12_B8_C8 = 9,
	I915_OA_FORMAT_A32u40_A4u32_B8_C8 = 10,
	I915_OAR_FORMAT_A32u40_A4u32_B8_C8 = 11,
	I915_OA_FORMAT_A24u40_A14u32_B8_C8 = 12,
	I915_OAM_FORMAT_MPEC8u64_B8_C8 = 13,
	I915_OAM_FORMAT_MPEC8u32_B8_C8 = 14,
	I915_OA_FORMAT_MAX = 15,
};

enum drm_i915_perf_property_id {
	DRM_I915_PERF_PROP_CTX_HANDLE = 1,
	DRM_I915_PERF_PROP_SAMPLE_OA = 2,
	DRM_I915_PERF_PROP_OA_METRICS_SET = 3,
	DRM_I915_PERF_PROP_OA_FORMAT = 4,
	DRM_I915_PERF_PROP_OA_EXPONENT = 5,
	DRM_I915_PERF_PROP_HOLD_PREEMPTION = 6,
	DRM_I915_PERF_PROP_GLOBAL_SSEU = 7,
	DRM_I915_PERF_PROP_POLL_OA_PERIOD = 8,
	DRM_I915_PERF_PROP_OA_ENGINE_CLASS = 9,
	DRM_I915_PERF_PROP_OA_ENGINE_INSTANCE = 10,
	DRM_I915_PERF_PROP_MAX = 11,
};

enum drm_i915_perf_record_type {
	DRM_I915_PERF_RECORD_SAMPLE = 1,
	DRM_I915_PERF_RECORD_OA_REPORT_LOST = 2,
	DRM_I915_PERF_RECORD_OA_BUFFER_LOST = 3,
	DRM_I915_PERF_RECORD_MAX = 4,
};

enum drm_i915_pmu_engine_sample {
	I915_SAMPLE_BUSY = 0,
	I915_SAMPLE_WAIT = 1,
	I915_SAMPLE_SEMA = 2,
};

enum drm_ioctl_flags {
	DRM_AUTH = 1,
	DRM_MASTER = 2,
	DRM_ROOT_ONLY = 4,
	DRM_RENDER_ALLOW = 32,
};

enum drm_link_status {
	DRM_LINK_STATUS_GOOD = 0,
	DRM_LINK_STATUS_BAD = 1,
};

enum drm_lspcon_mode {
	DRM_LSPCON_MODE_INVALID = 0,
	DRM_LSPCON_MODE_LS = 1,
	DRM_LSPCON_MODE_PCON = 2,
};

enum drm_minor_type {
	DRM_MINOR_PRIMARY = 0,
	DRM_MINOR_CONTROL = 1,
	DRM_MINOR_RENDER = 2,
	DRM_MINOR_ACCEL = 32,
};

enum drm_mm_insert_mode {
	DRM_MM_INSERT_BEST = 0,
	DRM_MM_INSERT_LOW = 1,
	DRM_MM_INSERT_HIGH = 2,
	DRM_MM_INSERT_EVICT = 3,
	DRM_MM_INSERT_ONCE = 2147483648,
	DRM_MM_INSERT_HIGHEST = 2147483650,
	DRM_MM_INSERT_LOWEST = 2147483649,
};

enum drm_mode_analog {
	DRM_MODE_ANALOG_NTSC = 0,
	DRM_MODE_ANALOG_PAL = 1,
};

enum drm_mode_status {
	MODE_OK = 0,
	MODE_HSYNC = 1,
	MODE_VSYNC = 2,
	MODE_H_ILLEGAL = 3,
	MODE_V_ILLEGAL = 4,
	MODE_BAD_WIDTH = 5,
	MODE_NOMODE = 6,
	MODE_NO_INTERLACE = 7,
	MODE_NO_DBLESCAN = 8,
	MODE_NO_VSCAN = 9,
	MODE_MEM = 10,
	MODE_VIRTUAL_X = 11,
	MODE_VIRTUAL_Y = 12,
	MODE_MEM_VIRT = 13,
	MODE_NOCLOCK = 14,
	MODE_CLOCK_HIGH = 15,
	MODE_CLOCK_LOW = 16,
	MODE_CLOCK_RANGE = 17,
	MODE_BAD_HVALUE = 18,
	MODE_BAD_VVALUE = 19,
	MODE_BAD_VSCAN = 20,
	MODE_HSYNC_NARROW = 21,
	MODE_HSYNC_WIDE = 22,
	MODE_HBLANK_NARROW = 23,
	MODE_HBLANK_WIDE = 24,
	MODE_VSYNC_NARROW = 25,
	MODE_VSYNC_WIDE = 26,
	MODE_VBLANK_NARROW = 27,
	MODE_VBLANK_WIDE = 28,
	MODE_PANEL = 29,
	MODE_INTERLACE_WIDTH = 30,
	MODE_ONE_WIDTH = 31,
	MODE_ONE_HEIGHT = 32,
	MODE_ONE_SIZE = 33,
	MODE_NO_REDUCED = 34,
	MODE_NO_STEREO = 35,
	MODE_NO_420 = 36,
	MODE_STALE = -3,
	MODE_BAD = -2,
	MODE_ERROR = -1,
};

enum drm_mode_subconnector {
	DRM_MODE_SUBCONNECTOR_Automatic = 0,
	DRM_MODE_SUBCONNECTOR_Unknown = 0,
	DRM_MODE_SUBCONNECTOR_VGA = 1,
	DRM_MODE_SUBCONNECTOR_DVID = 3,
	DRM_MODE_SUBCONNECTOR_DVIA = 4,
	DRM_MODE_SUBCONNECTOR_Composite = 5,
	DRM_MODE_SUBCONNECTOR_SVIDEO = 6,
	DRM_MODE_SUBCONNECTOR_Component = 8,
	DRM_MODE_SUBCONNECTOR_SCART = 9,
	DRM_MODE_SUBCONNECTOR_DisplayPort = 10,
	DRM_MODE_SUBCONNECTOR_HDMIA = 11,
	DRM_MODE_SUBCONNECTOR_Native = 15,
	DRM_MODE_SUBCONNECTOR_Wireless = 18,
};

enum drm_panel_orientation {
	DRM_MODE_PANEL_ORIENTATION_UNKNOWN = -1,
	DRM_MODE_PANEL_ORIENTATION_NORMAL = 0,
	DRM_MODE_PANEL_ORIENTATION_BOTTOM_UP = 1,
	DRM_MODE_PANEL_ORIENTATION_LEFT_UP = 2,
	DRM_MODE_PANEL_ORIENTATION_RIGHT_UP = 3,
};

enum drm_plane_type {
	DRM_PLANE_TYPE_OVERLAY = 0,
	DRM_PLANE_TYPE_PRIMARY = 1,
	DRM_PLANE_TYPE_CURSOR = 2,
};

enum drm_privacy_screen_status {
	PRIVACY_SCREEN_DISABLED = 0,
	PRIVACY_SCREEN_ENABLED = 1,
	PRIVACY_SCREEN_DISABLED_LOCKED = 2,
	PRIVACY_SCREEN_ENABLED_LOCKED = 3,
};

enum drm_scaling_filter {
	DRM_SCALING_FILTER_DEFAULT = 0,
	DRM_SCALING_FILTER_NEAREST_NEIGHBOR = 1,
};

enum drm_stat_type {
	_DRM_STAT_LOCK = 0,
	_DRM_STAT_OPENS = 1,
	_DRM_STAT_CLOSES = 2,
	_DRM_STAT_IOCTLS = 3,
	_DRM_STAT_LOCKS = 4,
	_DRM_STAT_UNLOCKS = 5,
	_DRM_STAT_VALUE = 6,
	_DRM_STAT_BYTE = 7,
	_DRM_STAT_COUNT = 8,
	_DRM_STAT_IRQ = 9,
	_DRM_STAT_PRIMARY = 10,
	_DRM_STAT_SECONDARY = 11,
	_DRM_STAT_DMA = 12,
	_DRM_STAT_SPECIAL = 13,
	_DRM_STAT_MISSED = 14,
};

enum drm_vblank_seq_type {
	_DRM_VBLANK_ABSOLUTE = 0,
	_DRM_VBLANK_RELATIVE = 1,
	_DRM_VBLANK_HIGH_CRTC_MASK = 62,
	_DRM_VBLANK_EVENT = 67108864,
	_DRM_VBLANK_FLIP = 134217728,
	_DRM_VBLANK_NEXTONMISS = 268435456,
	_DRM_VBLANK_SECONDARY = 536870912,
	_DRM_VBLANK_SIGNAL = 1073741824,
};

enum drrs_refresh_rate {
	DRRS_REFRESH_RATE_HIGH = 0,
	DRRS_REFRESH_RATE_LOW = 1,
};

enum drrs_type {
	DRRS_TYPE_NONE = 0,
	DRRS_TYPE_STATIC = 1,
	DRRS_TYPE_SEAMLESS = 2,
};

enum dw_dma_fc {
	DW_DMA_FC_D_M2M = 0,
	DW_DMA_FC_D_M2P = 1,
	DW_DMA_FC_D_P2M = 2,
	DW_DMA_FC_D_P2P = 3,
	DW_DMA_FC_P_P2M = 4,
	DW_DMA_FC_SP_P2P = 5,
	DW_DMA_FC_P_M2P = 6,
	DW_DMA_FC_DP_P2P = 7,
};

enum dw_dmac_flags {
	DW_DMA_IS_CYCLIC = 0,
	DW_DMA_IS_SOFT_LLP = 1,
	DW_DMA_IS_PAUSED = 2,
	DW_DMA_IS_INITIALIZED = 3,
};

enum dynevent_type {
	DYNEVENT_TYPE_SYNTH = 1,
	DYNEVENT_TYPE_KPROBE = 2,
	DYNEVENT_TYPE_NONE = 3,
};

enum e1000_1000t_rx_status {
	e1000_1000t_rx_status_not_ok___2 = 0,
	e1000_1000t_rx_status_ok___2 = 1,
	e1000_1000t_rx_status_undefined___2 = 255,
};

enum e1000_boards {
	board_82571 = 0,
	board_82572 = 1,
	board_82573 = 2,
	board_82574 = 3,
	board_82583 = 4,
	board_80003es2lan = 5,
	board_ich8lan = 6,
	board_ich9lan = 7,
	board_ich10lan = 8,
	board_pchlan = 9,
	board_pch2lan = 10,
	board_pch_lpt = 11,
	board_pch_spt = 12,
	board_pch_cnp = 13,
	board_pch_tgp = 14,
	board_pch_adp = 15,
	board_pch_mtp = 16,
};

enum e1000_bus_width {
	e1000_bus_width_unknown___2 = 0,
	e1000_bus_width_pcie_x1 = 1,
	e1000_bus_width_pcie_x2 = 2,
	e1000_bus_width_pcie_x4 = 4,
	e1000_bus_width_pcie_x8 = 8,
	e1000_bus_width_32___2 = 9,
	e1000_bus_width_64___2 = 10,
	e1000_bus_width_reserved___2 = 11,
};

enum e1000_fc_mode {
	e1000_fc_none = 0,
	e1000_fc_rx_pause = 1,
	e1000_fc_tx_pause = 2,
	e1000_fc_full = 3,
	e1000_fc_default = 255,
};

enum e1000_mac_type {
	e1000_82571 = 0,
	e1000_82572 = 1,
	e1000_82573 = 2,
	e1000_82574 = 3,
	e1000_82583 = 4,
	e1000_80003es2lan = 5,
	e1000_ich8lan = 6,
	e1000_ich9lan = 7,
	e1000_ich10lan = 8,
	e1000_pchlan = 9,
	e1000_pch2lan = 10,
	e1000_pch_lpt = 11,
	e1000_pch_spt = 12,
	e1000_pch_cnp = 13,
	e1000_pch_tgp = 14,
	e1000_pch_adp = 15,
	e1000_pch_mtp = 16,
	e1000_pch_lnp = 17,
	e1000_pch_ptp = 18,
	e1000_pch_nvp = 19,
};

enum e1000_media_type {
	e1000_media_type_unknown = 0,
	e1000_media_type_copper___2 = 1,
	e1000_media_type_fiber___2 = 2,
	e1000_media_type_internal_serdes___2 = 3,
	e1000_num_media_types___2 = 4,
};

enum e1000_mng_mode {
	e1000_mng_mode_none = 0,
	e1000_mng_mode_asf = 1,
	e1000_mng_mode_pt = 2,
	e1000_mng_mode_ipmi = 3,
	e1000_mng_mode_host_if_only = 4,
};

enum e1000_ms_type {
	e1000_ms_hw_default___2 = 0,
	e1000_ms_force_master___2 = 1,
	e1000_ms_force_slave___2 = 2,
	e1000_ms_auto___2 = 3,
};

enum e1000_nvm_override {
	e1000_nvm_override_none = 0,
	e1000_nvm_override_spi_small = 1,
	e1000_nvm_override_spi_large = 2,
};

enum e1000_nvm_type {
	e1000_nvm_unknown = 0,
	e1000_nvm_none = 1,
	e1000_nvm_eeprom_spi = 2,
	e1000_nvm_flash_hw = 3,
	e1000_nvm_flash_sw = 4,
};

enum e1000_phy_type {
	e1000_phy_unknown = 0,
	e1000_phy_none = 1,
	e1000_phy_m88___2 = 2,
	e1000_phy_igp___2 = 3,
	e1000_phy_igp_2 = 4,
	e1000_phy_gg82563 = 5,
	e1000_phy_igp_3 = 6,
	e1000_phy_ife = 7,
	e1000_phy_bm = 8,
	e1000_phy_82578 = 9,
	e1000_phy_82577 = 10,
	e1000_phy_82579 = 11,
	e1000_phy_i217 = 12,
};

enum e1000_rev_polarity {
	e1000_rev_polarity_normal___2 = 0,
	e1000_rev_polarity_reversed___2 = 1,
	e1000_rev_polarity_undefined___2 = 255,
};

enum e1000_serdes_link_state {
	e1000_serdes_link_down = 0,
	e1000_serdes_link_autoneg_progress = 1,
	e1000_serdes_link_autoneg_complete = 2,
	e1000_serdes_link_forced_up = 3,
};

enum e1000_smart_speed {
	e1000_smart_speed_default___2 = 0,
	e1000_smart_speed_on___2 = 1,
	e1000_smart_speed_off___2 = 2,
};

enum e1000_state_t {
	__E1000_TESTING = 0,
	__E1000_RESETTING = 1,
	__E1000_ACCESS_SHARED_RESOURCE = 2,
	__E1000_DOWN = 3,
};

enum e1000_state_t___2 {
	__E1000_TESTING___2 = 0,
	__E1000_RESETTING___2 = 1,
	__E1000_DOWN___2 = 2,
	__E1000_DISABLED = 3,
};

enum e1000_ulp_state {
	e1000_ulp_state_unknown = 0,
	e1000_ulp_state_off = 1,
	e1000_ulp_state_on = 2,
};

enum e820_type {
	E820_TYPE_RAM = 1,
	E820_TYPE_RESERVED = 2,
	E820_TYPE_ACPI = 3,
	E820_TYPE_NVS = 4,
	E820_TYPE_UNUSABLE = 5,
	E820_TYPE_PMEM = 7,
	E820_TYPE_PRAM = 12,
	E820_TYPE_SOFT_RESERVED = 4026531839,
	E820_TYPE_RESERVED_KERN = 128,
};

enum ec_command {
	ACPI_EC_COMMAND_READ = 128,
	ACPI_EC_COMMAND_WRITE = 129,
	ACPI_EC_BURST_ENABLE = 130,
	ACPI_EC_BURST_DISABLE = 131,
	ACPI_EC_COMMAND_QUERY = 132,
};

enum edid_block_status {
	EDID_BLOCK_OK = 0,
	EDID_BLOCK_READ_FAIL = 1,
	EDID_BLOCK_NULL = 2,
	EDID_BLOCK_ZERO = 3,
	EDID_BLOCK_HEADER_CORRUPT = 4,
	EDID_BLOCK_HEADER_REPAIR = 5,
	EDID_BLOCK_HEADER_FIXED = 6,
	EDID_BLOCK_CHECKSUM = 7,
	EDID_BLOCK_VERSION = 8,
};

enum eeprom_cnfg_mdix {
	eeprom_mdix_enabled = 128,
};

enum eeprom_config_asf {
	eeprom_asf = 32768,
	eeprom_gcl = 16384,
};

enum eeprom_ctrl_lo {
	eesk = 1,
	eecs = 2,
	eedi = 4,
	eedo = 8,
};

enum eeprom_id {
	eeprom_id_wol = 32,
};

enum eeprom_offsets {
	eeprom_cnfg_mdix = 3,
	eeprom_phy_iface = 6,
	eeprom_id = 10,
	eeprom_config_asf = 13,
	eeprom_smbus_addr = 144,
};

enum eeprom_op {
	op_write = 5,
	op_read = 6,
	op_ewds = 16,
	op_ewen = 19,
};

enum eeprom_phy_iface {
	NoSuchPhy = 0,
	I82553AB = 1,
	I82553C = 2,
	I82503 = 3,
	DP83840 = 4,
	S80C240 = 5,
	S80C24 = 6,
	I82555 = 7,
	DP83840A = 10,
};

enum efi_rts_ids {
	EFI_NONE = 0,
	EFI_GET_TIME = 1,
	EFI_SET_TIME = 2,
	EFI_GET_WAKEUP_TIME = 3,
	EFI_SET_WAKEUP_TIME = 4,
	EFI_GET_VARIABLE = 5,
	EFI_GET_NEXT_VARIABLE = 6,
	EFI_SET_VARIABLE = 7,
	EFI_QUERY_VARIABLE_INFO = 8,
	EFI_GET_NEXT_HIGH_MONO_COUNT = 9,
	EFI_RESET_SYSTEM = 10,
	EFI_UPDATE_CAPSULE = 11,
	EFI_QUERY_CAPSULE_CAPS = 12,
	EFI_ACPI_PRM_HANDLER = 13,
};

enum efi_secureboot_mode {
	efi_secureboot_mode_unset = 0,
	efi_secureboot_mode_unknown = 1,
	efi_secureboot_mode_disabled = 2,
	efi_secureboot_mode_enabled = 3,
};

enum ehci_hrtimer_event {
	EHCI_HRTIMER_POLL_ASS = 0,
	EHCI_HRTIMER_POLL_PSS = 1,
	EHCI_HRTIMER_POLL_DEAD = 2,
	EHCI_HRTIMER_UNLINK_INTR = 3,
	EHCI_HRTIMER_FREE_ITDS = 4,
	EHCI_HRTIMER_ACTIVE_UNLINK = 5,
	EHCI_HRTIMER_START_UNLINK_INTR = 6,
	EHCI_HRTIMER_ASYNC_UNLINKS = 7,
	EHCI_HRTIMER_IAA_WATCHDOG = 8,
	EHCI_HRTIMER_DISABLE_PERIODIC = 9,
	EHCI_HRTIMER_DISABLE_ASYNC = 10,
	EHCI_HRTIMER_IO_WATCHDOG = 11,
	EHCI_HRTIMER_NUM_EVENTS = 12,
};

enum ehci_rh_state {
	EHCI_RH_HALTED = 0,
	EHCI_RH_SUSPENDED = 1,
	EHCI_RH_RUNNING = 2,
	EHCI_RH_STOPPING = 3,
};

enum elv_merge {
	ELEVATOR_NO_MERGE = 0,
	ELEVATOR_FRONT_MERGE = 1,
	ELEVATOR_BACK_MERGE = 2,
	ELEVATOR_DISCARD_MERGE = 3,
};

enum enable_type {
	undefined = -1,
	user_disabled = 0,
	auto_disabled = 1,
	user_enabled = 2,
	auto_enabled = 3,
};

enum energy_perf_value_index {
	EPB_INDEX_PERFORMANCE = 0,
	EPB_INDEX_BALANCE_PERFORMANCE = 1,
	EPB_INDEX_NORMAL = 2,
	EPB_INDEX_BALANCE_POWERSAVE = 3,
	EPB_INDEX_POWERSAVE = 4,
};

enum energy_perf_value_index___2 {
	EPP_INDEX_DEFAULT = 0,
	EPP_INDEX_PERFORMANCE = 1,
	EPP_INDEX_BALANCE_PERFORMANCE = 2,
	EPP_INDEX_BALANCE_POWERSAVE = 3,
	EPP_INDEX_POWERSAVE = 4,
};

enum environment_cap {
	ENVIRON_ANY = 0,
	ENVIRON_INDOOR = 1,
	ENVIRON_OUTDOOR = 2,
};

enum error_detector {
	ERROR_DETECTOR_KFENCE = 0,
	ERROR_DETECTOR_KASAN = 1,
	ERROR_DETECTOR_WARN = 2,
};

enum ethnl_sock_type {
	ETHTOOL_SOCK_TYPE_MODULE_FW_FLASH = 0,
};

enum ethtool_c33_pse_admin_state {
	ETHTOOL_C33_PSE_ADMIN_STATE_UNKNOWN = 1,
	ETHTOOL_C33_PSE_ADMIN_STATE_DISABLED = 2,
	ETHTOOL_C33_PSE_ADMIN_STATE_ENABLED = 3,
};

enum ethtool_c33_pse_ext_state {
	ETHTOOL_C33_PSE_EXT_STATE_ERROR_CONDITION = 1,
	ETHTOOL_C33_PSE_EXT_STATE_MR_MPS_VALID = 2,
	ETHTOOL_C33_PSE_EXT_STATE_MR_PSE_ENABLE = 3,
	ETHTOOL_C33_PSE_EXT_STATE_OPTION_DETECT_TED = 4,
	ETHTOOL_C33_PSE_EXT_STATE_OPTION_VPORT_LIM = 5,
	ETHTOOL_C33_PSE_EXT_STATE_OVLD_DETECTED = 6,
	ETHTOOL_C33_PSE_EXT_STATE_PD_DLL_POWER_TYPE = 7,
	ETHTOOL_C33_PSE_EXT_STATE_POWER_NOT_AVAILABLE = 8,
	ETHTOOL_C33_PSE_EXT_STATE_SHORT_DETECTED = 9,
};

enum ethtool_c33_pse_ext_substate_error_condition {
	ETHTOOL_C33_PSE_EXT_SUBSTATE_ERROR_CONDITION_NON_EXISTING_PORT = 1,
	ETHTOOL_C33_PSE_EXT_SUBSTATE_ERROR_CONDITION_UNDEFINED_PORT = 2,
	ETHTOOL_C33_PSE_EXT_SUBSTATE_ERROR_CONDITION_INTERNAL_HW_FAULT = 3,
	ETHTOOL_C33_PSE_EXT_SUBSTATE_ERROR_CONDITION_COMM_ERROR_AFTER_FORCE_ON = 4,
	ETHTOOL_C33_PSE_EXT_SUBSTATE_ERROR_CONDITION_UNKNOWN_PORT_STATUS = 5,
	ETHTOOL_C33_PSE_EXT_SUBSTATE_ERROR_CONDITION_HOST_CRASH_TURN_OFF = 6,
	ETHTOOL_C33_PSE_EXT_SUBSTATE_ERROR_CONDITION_HOST_CRASH_FORCE_SHUTDOWN = 7,
	ETHTOOL_C33_PSE_EXT_SUBSTATE_ERROR_CONDITION_CONFIG_CHANGE = 8,
	ETHTOOL_C33_PSE_EXT_SUBSTATE_ERROR_CONDITION_DETECTED_OVER_TEMP = 9,
};

enum ethtool_c33_pse_ext_substate_mr_pse_enable {
	ETHTOOL_C33_PSE_EXT_SUBSTATE_MR_PSE_ENABLE_DISABLE_PIN_ACTIVE = 1,
};

enum ethtool_c33_pse_ext_substate_option_detect_ted {
	ETHTOOL_C33_PSE_EXT_SUBSTATE_OPTION_DETECT_TED_DET_IN_PROCESS = 1,
	ETHTOOL_C33_PSE_EXT_SUBSTATE_OPTION_DETECT_TED_CONNECTION_CHECK_ERROR = 2,
};

enum ethtool_c33_pse_ext_substate_option_vport_lim {
	ETHTOOL_C33_PSE_EXT_SUBSTATE_OPTION_VPORT_LIM_HIGH_VOLTAGE = 1,
	ETHTOOL_C33_PSE_EXT_SUBSTATE_OPTION_VPORT_LIM_LOW_VOLTAGE = 2,
	ETHTOOL_C33_PSE_EXT_SUBSTATE_OPTION_VPORT_LIM_VOLTAGE_INJECTION = 3,
};

enum ethtool_c33_pse_ext_substate_ovld_detected {
	ETHTOOL_C33_PSE_EXT_SUBSTATE_OVLD_DETECTED_OVERLOAD = 1,
};

enum ethtool_c33_pse_ext_substate_power_not_available {
	ETHTOOL_C33_PSE_EXT_SUBSTATE_POWER_NOT_AVAILABLE_BUDGET_EXCEEDED = 1,
	ETHTOOL_C33_PSE_EXT_SUBSTATE_POWER_NOT_AVAILABLE_PORT_PW_LIMIT_EXCEEDS_CONTROLLER_BUDGET = 2,
	ETHTOOL_C33_PSE_EXT_SUBSTATE_POWER_NOT_AVAILABLE_PD_REQUEST_EXCEEDS_PORT_LIMIT = 3,
	ETHTOOL_C33_PSE_EXT_SUBSTATE_POWER_NOT_AVAILABLE_HW_PW_LIMIT = 4,
};

enum ethtool_c33_pse_ext_substate_short_detected {
	ETHTOOL_C33_PSE_EXT_SUBSTATE_SHORT_DETECTED_SHORT_CONDITION = 1,
};

enum ethtool_c33_pse_pw_d_status {
	ETHTOOL_C33_PSE_PW_D_STATUS_UNKNOWN = 1,
	ETHTOOL_C33_PSE_PW_D_STATUS_DISABLED = 2,
	ETHTOOL_C33_PSE_PW_D_STATUS_SEARCHING = 3,
	ETHTOOL_C33_PSE_PW_D_STATUS_DELIVERING = 4,
	ETHTOOL_C33_PSE_PW_D_STATUS_TEST = 5,
	ETHTOOL_C33_PSE_PW_D_STATUS_FAULT = 6,
	ETHTOOL_C33_PSE_PW_D_STATUS_OTHERFAULT = 7,
};

enum ethtool_cmis_cdb_cmd_id {
	ETHTOOL_CMIS_CDB_CMD_QUERY_STATUS = 0,
	ETHTOOL_CMIS_CDB_CMD_MODULE_FEATURES = 64,
	ETHTOOL_CMIS_CDB_CMD_FW_MANAGMENT_FEATURES = 65,
	ETHTOOL_CMIS_CDB_CMD_START_FW_DOWNLOAD = 257,
	ETHTOOL_CMIS_CDB_CMD_WRITE_FW_BLOCK_LPL = 259,
	ETHTOOL_CMIS_CDB_CMD_WRITE_FW_BLOCK_EPL = 260,
	ETHTOOL_CMIS_CDB_CMD_COMPLETE_FW_DOWNLOAD = 263,
	ETHTOOL_CMIS_CDB_CMD_RUN_FW_IMAGE = 265,
	ETHTOOL_CMIS_CDB_CMD_COMMIT_FW_IMAGE = 266,
};

enum ethtool_fec_config_bits {
	ETHTOOL_FEC_NONE_BIT = 0,
	ETHTOOL_FEC_AUTO_BIT = 1,
	ETHTOOL_FEC_OFF_BIT = 2,
	ETHTOOL_FEC_RS_BIT = 3,
	ETHTOOL_FEC_BASER_BIT = 4,
	ETHTOOL_FEC_LLRS_BIT = 5,
};

enum ethtool_flags {
	ETH_FLAG_TXVLAN = 128,
	ETH_FLAG_RXVLAN = 256,
	ETH_FLAG_LRO = 32768,
	ETH_FLAG_NTUPLE = 134217728,
	ETH_FLAG_RXHASH = 268435456,
};

enum ethtool_header_flags {
	ETHTOOL_FLAG_COMPACT_BITSETS = 1,
	ETHTOOL_FLAG_OMIT_REPLY = 2,
	ETHTOOL_FLAG_STATS = 4,
};

enum ethtool_link_ext_state {
	ETHTOOL_LINK_EXT_STATE_AUTONEG = 0,
	ETHTOOL_LINK_EXT_STATE_LINK_TRAINING_FAILURE = 1,
	ETHTOOL_LINK_EXT_STATE_LINK_LOGICAL_MISMATCH = 2,
	ETHTOOL_LINK_EXT_STATE_BAD_SIGNAL_INTEGRITY = 3,
	ETHTOOL_LINK_EXT_STATE_NO_CABLE = 4,
	ETHTOOL_LINK_EXT_STATE_CABLE_ISSUE = 5,
	ETHTOOL_LINK_EXT_STATE_EEPROM_ISSUE = 6,
	ETHTOOL_LINK_EXT_STATE_CALIBRATION_FAILURE = 7,
	ETHTOOL_LINK_EXT_STATE_POWER_BUDGET_EXCEEDED = 8,
	ETHTOOL_LINK_EXT_STATE_OVERHEAT = 9,
	ETHTOOL_LINK_EXT_STATE_MODULE = 10,
};

enum ethtool_link_ext_substate_autoneg {
	ETHTOOL_LINK_EXT_SUBSTATE_AN_NO_PARTNER_DETECTED = 1,
	ETHTOOL_LINK_EXT_SUBSTATE_AN_ACK_NOT_RECEIVED = 2,
	ETHTOOL_LINK_EXT_SUBSTATE_AN_NEXT_PAGE_EXCHANGE_FAILED = 3,
	ETHTOOL_LINK_EXT_SUBSTATE_AN_NO_PARTNER_DETECTED_FORCE_MODE = 4,
	ETHTOOL_LINK_EXT_SUBSTATE_AN_FEC_MISMATCH_DURING_OVERRIDE = 5,
	ETHTOOL_LINK_EXT_SUBSTATE_AN_NO_HCD = 6,
};

enum ethtool_link_ext_substate_bad_signal_integrity {
	ETHTOOL_LINK_EXT_SUBSTATE_BSI_LARGE_NUMBER_OF_PHYSICAL_ERRORS = 1,
	ETHTOOL_LINK_EXT_SUBSTATE_BSI_UNSUPPORTED_RATE = 2,
	ETHTOOL_LINK_EXT_SUBSTATE_BSI_SERDES_REFERENCE_CLOCK_LOST = 3,
	ETHTOOL_LINK_EXT_SUBSTATE_BSI_SERDES_ALOS = 4,
};

enum ethtool_link_ext_substate_cable_issue {
	ETHTOOL_LINK_EXT_SUBSTATE_CI_UNSUPPORTED_CABLE = 1,
	ETHTOOL_LINK_EXT_SUBSTATE_CI_CABLE_TEST_FAILURE = 2,
};

enum ethtool_link_ext_substate_link_logical_mismatch {
	ETHTOOL_LINK_EXT_SUBSTATE_LLM_PCS_DID_NOT_ACQUIRE_BLOCK_LOCK = 1,
	ETHTOOL_LINK_EXT_SUBSTATE_LLM_PCS_DID_NOT_ACQUIRE_AM_LOCK = 2,
	ETHTOOL_LINK_EXT_SUBSTATE_LLM_PCS_DID_NOT_GET_ALIGN_STATUS = 3,
	ETHTOOL_LINK_EXT_SUBSTATE_LLM_FC_FEC_IS_NOT_LOCKED = 4,
	ETHTOOL_LINK_EXT_SUBSTATE_LLM_RS_FEC_IS_NOT_LOCKED = 5,
};

enum ethtool_link_ext_substate_link_training {
	ETHTOOL_LINK_EXT_SUBSTATE_LT_KR_FRAME_LOCK_NOT_ACQUIRED = 1,
	ETHTOOL_LINK_EXT_SUBSTATE_LT_KR_LINK_INHIBIT_TIMEOUT = 2,
	ETHTOOL_LINK_EXT_SUBSTATE_LT_KR_LINK_PARTNER_DID_NOT_SET_RECEIVER_READY = 3,
	ETHTOOL_LINK_EXT_SUBSTATE_LT_REMOTE_FAULT = 4,
};

enum ethtool_link_ext_substate_module {
	ETHTOOL_LINK_EXT_SUBSTATE_MODULE_CMIS_NOT_READY = 1,
};

enum ethtool_link_mode_bit_indices {
	ETHTOOL_LINK_MODE_10baseT_Half_BIT = 0,
	ETHTOOL_LINK_MODE_10baseT_Full_BIT = 1,
	ETHTOOL_LINK_MODE_100baseT_Half_BIT = 2,
	ETHTOOL_LINK_MODE_100baseT_Full_BIT = 3,
	ETHTOOL_LINK_MODE_1000baseT_Half_BIT = 4,
	ETHTOOL_LINK_MODE_1000baseT_Full_BIT = 5,
	ETHTOOL_LINK_MODE_Autoneg_BIT = 6,
	ETHTOOL_LINK_MODE_TP_BIT = 7,
	ETHTOOL_LINK_MODE_AUI_BIT = 8,
	ETHTOOL_LINK_MODE_MII_BIT = 9,
	ETHTOOL_LINK_MODE_FIBRE_BIT = 10,
	ETHTOOL_LINK_MODE_BNC_BIT = 11,
	ETHTOOL_LINK_MODE_10000baseT_Full_BIT = 12,
	ETHTOOL_LINK_MODE_Pause_BIT = 13,
	ETHTOOL_LINK_MODE_Asym_Pause_BIT = 14,
	ETHTOOL_LINK_MODE_2500baseX_Full_BIT = 15,
	ETHTOOL_LINK_MODE_Backplane_BIT = 16,
	ETHTOOL_LINK_MODE_1000baseKX_Full_BIT = 17,
	ETHTOOL_LINK_MODE_10000baseKX4_Full_BIT = 18,
	ETHTOOL_LINK_MODE_10000baseKR_Full_BIT = 19,
	ETHTOOL_LINK_MODE_10000baseR_FEC_BIT = 20,
	ETHTOOL_LINK_MODE_20000baseMLD2_Full_BIT = 21,
	ETHTOOL_LINK_MODE_20000baseKR2_Full_BIT = 22,
	ETHTOOL_LINK_MODE_40000baseKR4_Full_BIT = 23,
	ETHTOOL_LINK_MODE_40000baseCR4_Full_BIT = 24,
	ETHTOOL_LINK_MODE_40000baseSR4_Full_BIT = 25,
	ETHTOOL_LINK_MODE_40000baseLR4_Full_BIT = 26,
	ETHTOOL_LINK_MODE_56000baseKR4_Full_BIT = 27,
	ETHTOOL_LINK_MODE_56000baseCR4_Full_BIT = 28,
	ETHTOOL_LINK_MODE_56000baseSR4_Full_BIT = 29,
	ETHTOOL_LINK_MODE_56000baseLR4_Full_BIT = 30,
	ETHTOOL_LINK_MODE_25000baseCR_Full_BIT = 31,
	ETHTOOL_LINK_MODE_25000baseKR_Full_BIT = 32,
	ETHTOOL_LINK_MODE_25000baseSR_Full_BIT = 33,
	ETHTOOL_LINK_MODE_50000baseCR2_Full_BIT = 34,
	ETHTOOL_LINK_MODE_50000baseKR2_Full_BIT = 35,
	ETHTOOL_LINK_MODE_100000baseKR4_Full_BIT = 36,
	ETHTOOL_LINK_MODE_100000baseSR4_Full_BIT = 37,
	ETHTOOL_LINK_MODE_100000baseCR4_Full_BIT = 38,
	ETHTOOL_LINK_MODE_100000baseLR4_ER4_Full_BIT = 39,
	ETHTOOL_LINK_MODE_50000baseSR2_Full_BIT = 40,
	ETHTOOL_LINK_MODE_1000baseX_Full_BIT = 41,
	ETHTOOL_LINK_MODE_10000baseCR_Full_BIT = 42,
	ETHTOOL_LINK_MODE_10000baseSR_Full_BIT = 43,
	ETHTOOL_LINK_MODE_10000baseLR_Full_BIT = 44,
	ETHTOOL_LINK_MODE_10000baseLRM_Full_BIT = 45,
	ETHTOOL_LINK_MODE_10000baseER_Full_BIT = 46,
	ETHTOOL_LINK_MODE_2500baseT_Full_BIT = 47,
	ETHTOOL_LINK_MODE_5000baseT_Full_BIT = 48,
	ETHTOOL_LINK_MODE_FEC_NONE_BIT = 49,
	ETHTOOL_LINK_MODE_FEC_RS_BIT = 50,
	ETHTOOL_LINK_MODE_FEC_BASER_BIT = 51,
	ETHTOOL_LINK_MODE_50000baseKR_Full_BIT = 52,
	ETHTOOL_LINK_MODE_50000baseSR_Full_BIT = 53,
	ETHTOOL_LINK_MODE_50000baseCR_Full_BIT = 54,
	ETHTOOL_LINK_MODE_50000baseLR_ER_FR_Full_BIT = 55,
	ETHTOOL_LINK_MODE_50000baseDR_Full_BIT = 56,
	ETHTOOL_LINK_MODE_100000baseKR2_Full_BIT = 57,
	ETHTOOL_LINK_MODE_100000baseSR2_Full_BIT = 58,
	ETHTOOL_LINK_MODE_100000baseCR2_Full_BIT = 59,
	ETHTOOL_LINK_MODE_100000baseLR2_ER2_FR2_Full_BIT = 60,
	ETHTOOL_LINK_MODE_100000baseDR2_Full_BIT = 61,
	ETHTOOL_LINK_MODE_200000baseKR4_Full_BIT = 62,
	ETHTOOL_LINK_MODE_200000baseSR4_Full_BIT = 63,
	ETHTOOL_LINK_MODE_200000baseLR4_ER4_FR4_Full_BIT = 64,
	ETHTOOL_LINK_MODE_200000baseDR4_Full_BIT = 65,
	ETHTOOL_LINK_MODE_200000baseCR4_Full_BIT = 66,
	ETHTOOL_LINK_MODE_100baseT1_Full_BIT = 67,
	ETHTOOL_LINK_MODE_1000baseT1_Full_BIT = 68,
	ETHTOOL_LINK_MODE_400000baseKR8_Full_BIT = 69,
	ETHTOOL_LINK_MODE_400000baseSR8_Full_BIT = 70,
	ETHTOOL_LINK_MODE_400000baseLR8_ER8_FR8_Full_BIT = 71,
	ETHTOOL_LINK_MODE_400000baseDR8_Full_BIT = 72,
	ETHTOOL_LINK_MODE_400000baseCR8_Full_BIT = 73,
	ETHTOOL_LINK_MODE_FEC_LLRS_BIT = 74,
	ETHTOOL_LINK_MODE_100000baseKR_Full_BIT = 75,
	ETHTOOL_LINK_MODE_100000baseSR_Full_BIT = 76,
	ETHTOOL_LINK_MODE_100000baseLR_ER_FR_Full_BIT = 77,
	ETHTOOL_LINK_MODE_100000baseCR_Full_BIT = 78,
	ETHTOOL_LINK_MODE_100000baseDR_Full_BIT = 79,
	ETHTOOL_LINK_MODE_200000baseKR2_Full_BIT = 80,
	ETHTOOL_LINK_MODE_200000baseSR2_Full_BIT = 81,
	ETHTOOL_LINK_MODE_200000baseLR2_ER2_FR2_Full_BIT = 82,
	ETHTOOL_LINK_MODE_200000baseDR2_Full_BIT = 83,
	ETHTOOL_LINK_MODE_200000baseCR2_Full_BIT = 84,
	ETHTOOL_LINK_MODE_400000baseKR4_Full_BIT = 85,
	ETHTOOL_LINK_MODE_400000baseSR4_Full_BIT = 86,
	ETHTOOL_LINK_MODE_400000baseLR4_ER4_FR4_Full_BIT = 87,
	ETHTOOL_LINK_MODE_400000baseDR4_Full_BIT = 88,
	ETHTOOL_LINK_MODE_400000baseCR4_Full_BIT = 89,
	ETHTOOL_LINK_MODE_100baseFX_Half_BIT = 90,
	ETHTOOL_LINK_MODE_100baseFX_Full_BIT = 91,
	ETHTOOL_LINK_MODE_10baseT1L_Full_BIT = 92,
	ETHTOOL_LINK_MODE_800000baseCR8_Full_BIT = 93,
	ETHTOOL_LINK_MODE_800000baseKR8_Full_BIT = 94,
	ETHTOOL_LINK_MODE_800000baseDR8_Full_BIT = 95,
	ETHTOOL_LINK_MODE_800000baseDR8_2_Full_BIT = 96,
	ETHTOOL_LINK_MODE_800000baseSR8_Full_BIT = 97,
	ETHTOOL_LINK_MODE_800000baseVR8_Full_BIT = 98,
	ETHTOOL_LINK_MODE_10baseT1S_Full_BIT = 99,
	ETHTOOL_LINK_MODE_10baseT1S_Half_BIT = 100,
	ETHTOOL_LINK_MODE_10baseT1S_P2MP_Half_BIT = 101,
	ETHTOOL_LINK_MODE_10baseT1BRR_Full_BIT = 102,
	__ETHTOOL_LINK_MODE_MASK_NBITS = 103,
};

enum ethtool_mac_stats_src {
	ETHTOOL_MAC_STATS_SRC_AGGREGATE = 0,
	ETHTOOL_MAC_STATS_SRC_EMAC = 1,
	ETHTOOL_MAC_STATS_SRC_PMAC = 2,
};

enum ethtool_mm_verify_status {
	ETHTOOL_MM_VERIFY_STATUS_UNKNOWN = 0,
	ETHTOOL_MM_VERIFY_STATUS_INITIAL = 1,
	ETHTOOL_MM_VERIFY_STATUS_VERIFYING = 2,
	ETHTOOL_MM_VERIFY_STATUS_SUCCEEDED = 3,
	ETHTOOL_MM_VERIFY_STATUS_FAILED = 4,
	ETHTOOL_MM_VERIFY_STATUS_DISABLED = 5,
};

enum ethtool_module_fw_flash_status {
	ETHTOOL_MODULE_FW_FLASH_STATUS_STARTED = 1,
	ETHTOOL_MODULE_FW_FLASH_STATUS_IN_PROGRESS = 2,
	ETHTOOL_MODULE_FW_FLASH_STATUS_COMPLETED = 3,
	ETHTOOL_MODULE_FW_FLASH_STATUS_ERROR = 4,
};

enum ethtool_module_power_mode {
	ETHTOOL_MODULE_POWER_MODE_LOW = 1,
	ETHTOOL_MODULE_POWER_MODE_HIGH = 2,
};

enum ethtool_module_power_mode_policy {
	ETHTOOL_MODULE_POWER_MODE_POLICY_HIGH = 1,
	ETHTOOL_MODULE_POWER_MODE_POLICY_AUTO = 2,
};

enum ethtool_multicast_groups {
	ETHNL_MCGRP_MONITOR = 0,
};

enum ethtool_phys_id_state {
	ETHTOOL_ID_INACTIVE = 0,
	ETHTOOL_ID_ACTIVE = 1,
	ETHTOOL_ID_ON = 2,
	ETHTOOL_ID_OFF = 3,
};

enum ethtool_podl_pse_admin_state {
	ETHTOOL_PODL_PSE_ADMIN_STATE_UNKNOWN = 1,
	ETHTOOL_PODL_PSE_ADMIN_STATE_DISABLED = 2,
	ETHTOOL_PODL_PSE_ADMIN_STATE_ENABLED = 3,
};

enum ethtool_podl_pse_pw_d_status {
	ETHTOOL_PODL_PSE_PW_D_STATUS_UNKNOWN = 1,
	ETHTOOL_PODL_PSE_PW_D_STATUS_DISABLED = 2,
	ETHTOOL_PODL_PSE_PW_D_STATUS_SEARCHING = 3,
	ETHTOOL_PODL_PSE_PW_D_STATUS_DELIVERING = 4,
	ETHTOOL_PODL_PSE_PW_D_STATUS_SLEEP = 5,
	ETHTOOL_PODL_PSE_PW_D_STATUS_IDLE = 6,
	ETHTOOL_PODL_PSE_PW_D_STATUS_ERROR = 7,
};

enum ethtool_reset_flags {
	ETH_RESET_MGMT = 1,
	ETH_RESET_IRQ = 2,
	ETH_RESET_DMA = 4,
	ETH_RESET_FILTER = 8,
	ETH_RESET_OFFLOAD = 16,
	ETH_RESET_MAC = 32,
	ETH_RESET_PHY = 64,
	ETH_RESET_RAM = 128,
	ETH_RESET_AP = 256,
	ETH_RESET_DEDICATED = 65535,
	ETH_RESET_ALL = 4294967295,
};

enum ethtool_sfeatures_retval_bits {
	ETHTOOL_F_UNSUPPORTED__BIT = 0,
	ETHTOOL_F_WISH__BIT = 1,
	ETHTOOL_F_COMPAT__BIT = 2,
};

enum ethtool_stringset {
	ETH_SS_TEST = 0,
	ETH_SS_STATS = 1,
	ETH_SS_PRIV_FLAGS = 2,
	ETH_SS_NTUPLE_FILTERS = 3,
	ETH_SS_FEATURES = 4,
	ETH_SS_RSS_HASH_FUNCS = 5,
	ETH_SS_TUNABLES = 6,
	ETH_SS_PHY_STATS = 7,
	ETH_SS_PHY_TUNABLES = 8,
	ETH_SS_LINK_MODES = 9,
	ETH_SS_MSG_CLASSES = 10,
	ETH_SS_WOL_MODES = 11,
	ETH_SS_SOF_TIMESTAMPING = 12,
	ETH_SS_TS_TX_TYPES = 13,
	ETH_SS_TS_RX_FILTERS = 14,
	ETH_SS_UDP_TUNNEL_TYPES = 15,
	ETH_SS_STATS_STD = 16,
	ETH_SS_STATS_ETH_PHY = 17,
	ETH_SS_STATS_ETH_MAC = 18,
	ETH_SS_STATS_ETH_CTRL = 19,
	ETH_SS_STATS_RMON = 20,
	ETH_SS_STATS_PHY = 21,
	ETH_SS_TS_FLAGS = 22,
	ETH_SS_COUNT = 23,
};

enum ethtool_supported_ring_param {
	ETHTOOL_RING_USE_RX_BUF_LEN = 1,
	ETHTOOL_RING_USE_CQE_SIZE = 2,
	ETHTOOL_RING_USE_TX_PUSH = 4,
	ETHTOOL_RING_USE_RX_PUSH = 8,
	ETHTOOL_RING_USE_TX_PUSH_BUF_LEN = 16,
	ETHTOOL_RING_USE_TCP_DATA_SPLIT = 32,
	ETHTOOL_RING_USE_HDS_THRS = 64,
};

enum ethtool_tcp_data_split {
	ETHTOOL_TCP_DATA_SPLIT_UNKNOWN = 0,
	ETHTOOL_TCP_DATA_SPLIT_DISABLED = 1,
	ETHTOOL_TCP_DATA_SPLIT_ENABLED = 2,
};

enum ethtool_test_flags {
	ETH_TEST_FL_OFFLINE = 1,
	ETH_TEST_FL_FAILED = 2,
	ETH_TEST_FL_EXTERNAL_LB = 4,
	ETH_TEST_FL_EXTERNAL_LB_DONE = 8,
};

enum event_command_flags {
	EVENT_CMD_FL_POST_TRIGGER = 1,
	EVENT_CMD_FL_NEEDS_REC = 2,
};

enum event_trigger_type {
	ETT_NONE = 0,
	ETT_TRACE_ONOFF = 1,
	ETT_SNAPSHOT = 2,
	ETT_STACKTRACE = 4,
	ETT_EVENT_ENABLE = 8,
	ETT_EVENT_HIST = 16,
	ETT_HIST_ENABLE = 32,
	ETT_EVENT_EPROBE = 64,
};

enum event_type_t {
	EVENT_FLEXIBLE = 1,
	EVENT_PINNED = 2,
	EVENT_TIME = 4,
	EVENT_FROZEN = 8,
	EVENT_CPU = 16,
	EVENT_CGROUP = 32,
	EVENT_ALL = 3,
	EVENT_TIME_FROZEN = 12,
};

enum exact_level {
	NOT_EXACT = 0,
	EXACT = 1,
	RANGE_WITHIN = 2,
};

enum exception {
	EXCP_CONTEXT = 1,
	NO_EXCP = 2,
};

enum exception_stack_ordering {
	ESTACK_DF = 0,
	ESTACK_NMI = 1,
	ESTACK_DB = 2,
	ESTACK_MCE = 3,
	ESTACK_VC = 4,
	ESTACK_VC2 = 5,
	N_EXCEPTION_STACKS = 6,
};

enum execmem_range_flags {
	EXECMEM_KASAN_SHADOW = 1,
	EXECMEM_ROX_CACHE = 2,
};

enum execmem_type {
	EXECMEM_DEFAULT = 0,
	EXECMEM_MODULE_TEXT = 0,
	EXECMEM_KPROBES = 1,
	EXECMEM_FTRACE = 2,
	EXECMEM_BPF = 3,
	EXECMEM_MODULE_DATA = 4,
	EXECMEM_TYPE_MAX = 5,
};

enum exit_fastpath_completion {
	EXIT_FASTPATH_NONE = 0,
	EXIT_FASTPATH_REENTER_GUEST = 1,
	EXIT_FASTPATH_EXIT_HANDLED = 2,
	EXIT_FASTPATH_EXIT_USERSPACE = 3,
};

enum ext4_journal_trigger_type {
	EXT4_JTR_ORPHAN_FILE = 0,
	EXT4_JTR_NONE = 1,
};

enum ext4_li_mode {
	EXT4_LI_MODE_PREFETCH_BBITMAP = 0,
	EXT4_LI_MODE_ITABLE = 1,
};

enum extra_reg_type {
	EXTRA_REG_NONE = -1,
	EXTRA_REG_RSP_0 = 0,
	EXTRA_REG_RSP_1 = 1,
	EXTRA_REG_LBR = 2,
	EXTRA_REG_LDLAT = 3,
	EXTRA_REG_FE = 4,
	EXTRA_REG_SNOOP_0 = 5,
	EXTRA_REG_SNOOP_1 = 6,
	EXTRA_REG_MAX = 7,
};

enum fail_dup_mod_reason {
	FAIL_DUP_MOD_BECOMING = 0,
	FAIL_DUP_MOD_LOAD = 1,
};

enum fault_flag {
	FAULT_FLAG_WRITE = 1,
	FAULT_FLAG_MKWRITE = 2,
	FAULT_FLAG_ALLOW_RETRY = 4,
	FAULT_FLAG_RETRY_NOWAIT = 8,
	FAULT_FLAG_KILLABLE = 16,
	FAULT_FLAG_TRIED = 32,
	FAULT_FLAG_USER = 64,
	FAULT_FLAG_REMOTE = 128,
	FAULT_FLAG_INSTRUCTION = 256,
	FAULT_FLAG_INTERRUPTIBLE = 512,
	FAULT_FLAG_UNSHARE = 1024,
	FAULT_FLAG_ORIG_PTE_VALID = 2048,
	FAULT_FLAG_VMA_LOCK = 4096,
};

enum faulttype {
	DMA_REMAP = 0,
	INTR_REMAP = 1,
	UNKNOWN = 2,
};

enum fb_op_origin {
	ORIGIN_CPU = 0,
	ORIGIN_CS = 1,
	ORIGIN_FLIP = 2,
	ORIGIN_DIRTYFB = 3,
	ORIGIN_CURSOR_UPDATE = 4,
};

enum fbq_type {
	regular = 0,
	remote = 1,
	all = 2,
};

enum fetch_op {
	FETCH_OP_NOP = 0,
	FETCH_OP_REG = 1,
	FETCH_OP_STACK = 2,
	FETCH_OP_STACKP = 3,
	FETCH_OP_RETVAL = 4,
	FETCH_OP_IMM = 5,
	FETCH_OP_COMM = 6,
	FETCH_OP_ARG = 7,
	FETCH_OP_FOFFS = 8,
	FETCH_OP_DATA = 9,
	FETCH_OP_EDATA = 10,
	FETCH_OP_DEREF = 11,
	FETCH_OP_UDEREF = 12,
	FETCH_OP_ST_RAW = 13,
	FETCH_OP_ST_MEM = 14,
	FETCH_OP_ST_UMEM = 15,
	FETCH_OP_ST_STRING = 16,
	FETCH_OP_ST_USTRING = 17,
	FETCH_OP_ST_SYMSTR = 18,
	FETCH_OP_ST_EDATA = 19,
	FETCH_OP_MOD_BF = 20,
	FETCH_OP_LP_ARRAY = 21,
	FETCH_OP_TP_ARG = 22,
	FETCH_OP_END = 23,
	FETCH_NOP_SYMBOL = 24,
};

enum fib6_walk_state {
	FWS_L = 0,
	FWS_R = 1,
	FWS_C = 2,
	FWS_U = 3,
};

enum fib_event_type {
	FIB_EVENT_ENTRY_REPLACE = 0,
	FIB_EVENT_ENTRY_APPEND = 1,
	FIB_EVENT_ENTRY_ADD = 2,
	FIB_EVENT_ENTRY_DEL = 3,
	FIB_EVENT_RULE_ADD = 4,
	FIB_EVENT_RULE_DEL = 5,
	FIB_EVENT_NH_ADD = 6,
	FIB_EVENT_NH_DEL = 7,
	FIB_EVENT_VIF_ADD = 8,
	FIB_EVENT_VIF_DEL = 9,
};

enum fid_type {
	FILEID_ROOT = 0,
	FILEID_INO32_GEN = 1,
	FILEID_INO32_GEN_PARENT = 2,
	FILEID_BTRFS_WITHOUT_PARENT = 77,
	FILEID_BTRFS_WITH_PARENT = 78,
	FILEID_BTRFS_WITH_PARENT_ROOT = 79,
	FILEID_UDF_WITHOUT_PARENT = 81,
	FILEID_UDF_WITH_PARENT = 82,
	FILEID_NILFS_WITHOUT_PARENT = 97,
	FILEID_NILFS_WITH_PARENT = 98,
	FILEID_FAT_WITHOUT_PARENT = 113,
	FILEID_FAT_WITH_PARENT = 114,
	FILEID_INO64_GEN = 129,
	FILEID_INO64_GEN_PARENT = 130,
	FILEID_LUSTRE = 151,
	FILEID_BCACHEFS_WITHOUT_PARENT = 177,
	FILEID_BCACHEFS_WITH_PARENT = 178,
	FILEID_KERNFS = 254,
	FILEID_INVALID = 255,
};

enum file_state {
	MEI_FILE_UNINITIALIZED = 0,
	MEI_FILE_INITIALIZING = 1,
	MEI_FILE_CONNECTING = 2,
	MEI_FILE_CONNECTED = 3,
	MEI_FILE_DISCONNECTING = 4,
	MEI_FILE_DISCONNECT_REPLY = 5,
	MEI_FILE_DISCONNECT_REQUIRED = 6,
	MEI_FILE_DISCONNECTED = 7,
};

enum file_time_flags {
	S_ATIME = 1,
	S_MTIME = 2,
	S_CTIME = 4,
	S_VERSION = 8,
};

enum filter_op_ids {
	OP_GLOB = 0,
	OP_NE = 1,
	OP_EQ = 2,
	OP_LE = 3,
	OP_LT = 4,
	OP_GE = 5,
	OP_GT = 6,
	OP_BAND = 7,
	OP_MAX = 8,
};

enum filter_pred_fn {
	FILTER_PRED_FN_NOP = 0,
	FILTER_PRED_FN_64 = 1,
	FILTER_PRED_FN_64_CPUMASK = 2,
	FILTER_PRED_FN_S64 = 3,
	FILTER_PRED_FN_U64 = 4,
	FILTER_PRED_FN_32 = 5,
	FILTER_PRED_FN_32_CPUMASK = 6,
	FILTER_PRED_FN_S32 = 7,
	FILTER_PRED_FN_U32 = 8,
	FILTER_PRED_FN_16 = 9,
	FILTER_PRED_FN_16_CPUMASK = 10,
	FILTER_PRED_FN_S16 = 11,
	FILTER_PRED_FN_U16 = 12,
	FILTER_PRED_FN_8 = 13,
	FILTER_PRED_FN_8_CPUMASK = 14,
	FILTER_PRED_FN_S8 = 15,
	FILTER_PRED_FN_U8 = 16,
	FILTER_PRED_FN_COMM = 17,
	FILTER_PRED_FN_STRING = 18,
	FILTER_PRED_FN_STRLOC = 19,
	FILTER_PRED_FN_STRRELLOC = 20,
	FILTER_PRED_FN_PCHAR_USER = 21,
	FILTER_PRED_FN_PCHAR = 22,
	FILTER_PRED_FN_CPU = 23,
	FILTER_PRED_FN_CPU_CPUMASK = 24,
	FILTER_PRED_FN_CPUMASK = 25,
	FILTER_PRED_FN_CPUMASK_CPU = 26,
	FILTER_PRED_FN_FUNCTION = 27,
	FILTER_PRED_FN_ = 28,
	FILTER_PRED_TEST_VISITED = 29,
};

enum fit_type {
	NOTHING_FIT = 0,
	FL_FIT_TYPE = 1,
	LE_FIT_TYPE = 2,
	RE_FIT_TYPE = 3,
	NE_FIT_TYPE = 4,
};

enum fixed_addresses {
	VSYSCALL_PAGE = 511,
	FIX_DBGP_BASE = 512,
	FIX_EARLYCON_MEM_BASE = 513,
	FIX_OHCI1394_BASE = 514,
	FIX_APIC_BASE = 515,
	FIX_IO_APIC_BASE_0 = 516,
	FIX_IO_APIC_BASE_END = 643,
	__end_of_permanent_fixed_addresses = 644,
	FIX_BTMAP_END = 1024,
	FIX_BTMAP_BEGIN = 1535,
	__end_of_fixed_addresses = 1536,
};

enum flag_bits {
	Faulty = 0,
	In_sync = 1,
	Bitmap_sync = 2,
	WriteMostly = 3,
	AutoDetected = 4,
	Blocked = 5,
	WriteErrorSeen = 6,
	FaultRecorded = 7,
	BlockedBadBlocks = 8,
	WantReplacement = 9,
	Replacement = 10,
	Candidate = 11,
	Journal = 12,
	ClusterRemove = 13,
	ExternalBbl = 14,
	FailFast = 15,
	LastDev = 16,
	CollisionCheck = 17,
	Nonrot = 18,
};

enum flow_action_hw_stats {
	FLOW_ACTION_HW_STATS_IMMEDIATE = 1,
	FLOW_ACTION_HW_STATS_DELAYED = 2,
	FLOW_ACTION_HW_STATS_ANY = 3,
	FLOW_ACTION_HW_STATS_DISABLED = 4,
	FLOW_ACTION_HW_STATS_DONT_CARE = 7,
};

enum flow_action_hw_stats_bit {
	FLOW_ACTION_HW_STATS_IMMEDIATE_BIT = 0,
	FLOW_ACTION_HW_STATS_DELAYED_BIT = 1,
	FLOW_ACTION_HW_STATS_DISABLED_BIT = 2,
	FLOW_ACTION_HW_STATS_NUM_BITS = 3,
};

enum flow_action_id {
	FLOW_ACTION_ACCEPT = 0,
	FLOW_ACTION_DROP = 1,
	FLOW_ACTION_TRAP = 2,
	FLOW_ACTION_GOTO = 3,
	FLOW_ACTION_REDIRECT = 4,
	FLOW_ACTION_MIRRED = 5,
	FLOW_ACTION_REDIRECT_INGRESS = 6,
	FLOW_ACTION_MIRRED_INGRESS = 7,
	FLOW_ACTION_VLAN_PUSH = 8,
	FLOW_ACTION_VLAN_POP = 9,
	FLOW_ACTION_VLAN_MANGLE = 10,
	FLOW_ACTION_TUNNEL_ENCAP = 11,
	FLOW_ACTION_TUNNEL_DECAP = 12,
	FLOW_ACTION_MANGLE = 13,
	FLOW_ACTION_ADD = 14,
	FLOW_ACTION_CSUM = 15,
	FLOW_ACTION_MARK = 16,
	FLOW_ACTION_PTYPE = 17,
	FLOW_ACTION_PRIORITY = 18,
	FLOW_ACTION_RX_QUEUE_MAPPING = 19,
	FLOW_ACTION_WAKE = 20,
	FLOW_ACTION_QUEUE = 21,
	FLOW_ACTION_SAMPLE = 22,
	FLOW_ACTION_POLICE = 23,
	FLOW_ACTION_CT = 24,
	FLOW_ACTION_CT_METADATA = 25,
	FLOW_ACTION_MPLS_PUSH = 26,
	FLOW_ACTION_MPLS_POP = 27,
	FLOW_ACTION_MPLS_MANGLE = 28,
	FLOW_ACTION_GATE = 29,
	FLOW_ACTION_PPPOE_PUSH = 30,
	FLOW_ACTION_JUMP = 31,
	FLOW_ACTION_PIPE = 32,
	FLOW_ACTION_VLAN_PUSH_ETH = 33,
	FLOW_ACTION_VLAN_POP_ETH = 34,
	FLOW_ACTION_CONTINUE = 35,
	NUM_FLOW_ACTIONS = 36,
};

enum flow_action_mangle_base {
	FLOW_ACT_MANGLE_UNSPEC = 0,
	FLOW_ACT_MANGLE_HDR_TYPE_ETH = 1,
	FLOW_ACT_MANGLE_HDR_TYPE_IP4 = 2,
	FLOW_ACT_MANGLE_HDR_TYPE_IP6 = 3,
	FLOW_ACT_MANGLE_HDR_TYPE_TCP = 4,
	FLOW_ACT_MANGLE_HDR_TYPE_UDP = 5,
};

enum flow_block_binder_type {
	FLOW_BLOCK_BINDER_TYPE_UNSPEC = 0,
	FLOW_BLOCK_BINDER_TYPE_CLSACT_INGRESS = 1,
	FLOW_BLOCK_BINDER_TYPE_CLSACT_EGRESS = 2,
	FLOW_BLOCK_BINDER_TYPE_RED_EARLY_DROP = 3,
	FLOW_BLOCK_BINDER_TYPE_RED_MARK = 4,
};

enum flow_block_command {
	FLOW_BLOCK_BIND = 0,
	FLOW_BLOCK_UNBIND = 1,
};

enum flow_control {
	FC_NONE = 0,
	FC_TX = 1,
	FC_RX = 2,
	FC_BOTH = 3,
};

enum flow_dissect_ret {
	FLOW_DISSECT_RET_OUT_GOOD = 0,
	FLOW_DISSECT_RET_OUT_BAD = 1,
	FLOW_DISSECT_RET_PROTO_AGAIN = 2,
	FLOW_DISSECT_RET_IPPROTO_AGAIN = 3,
	FLOW_DISSECT_RET_CONTINUE = 4,
};

enum flow_dissector_ctrl_flags {
	FLOW_DIS_IS_FRAGMENT = 1,
	FLOW_DIS_FIRST_FRAG = 2,
	FLOW_DIS_F_TUNNEL_CSUM = 4,
	FLOW_DIS_F_TUNNEL_DONT_FRAGMENT = 8,
	FLOW_DIS_F_TUNNEL_OAM = 16,
	FLOW_DIS_F_TUNNEL_CRIT_OPT = 32,
	FLOW_DIS_ENCAPSULATION = 64,
};

enum flow_dissector_key_id {
	FLOW_DISSECTOR_KEY_CONTROL = 0,
	FLOW_DISSECTOR_KEY_BASIC = 1,
	FLOW_DISSECTOR_KEY_IPV4_ADDRS = 2,
	FLOW_DISSECTOR_KEY_IPV6_ADDRS = 3,
	FLOW_DISSECTOR_KEY_PORTS = 4,
	FLOW_DISSECTOR_KEY_PORTS_RANGE = 5,
	FLOW_DISSECTOR_KEY_ICMP = 6,
	FLOW_DISSECTOR_KEY_ETH_ADDRS = 7,
	FLOW_DISSECTOR_KEY_TIPC = 8,
	FLOW_DISSECTOR_KEY_ARP = 9,
	FLOW_DISSECTOR_KEY_VLAN = 10,
	FLOW_DISSECTOR_KEY_FLOW_LABEL = 11,
	FLOW_DISSECTOR_KEY_GRE_KEYID = 12,
	FLOW_DISSECTOR_KEY_MPLS_ENTROPY = 13,
	FLOW_DISSECTOR_KEY_ENC_KEYID = 14,
	FLOW_DISSECTOR_KEY_ENC_IPV4_ADDRS = 15,
	FLOW_DISSECTOR_KEY_ENC_IPV6_ADDRS = 16,
	FLOW_DISSECTOR_KEY_ENC_CONTROL = 17,
	FLOW_DISSECTOR_KEY_ENC_PORTS = 18,
	FLOW_DISSECTOR_KEY_MPLS = 19,
	FLOW_DISSECTOR_KEY_TCP = 20,
	FLOW_DISSECTOR_KEY_IP = 21,
	FLOW_DISSECTOR_KEY_CVLAN = 22,
	FLOW_DISSECTOR_KEY_ENC_IP = 23,
	FLOW_DISSECTOR_KEY_ENC_OPTS = 24,
	FLOW_DISSECTOR_KEY_META = 25,
	FLOW_DISSECTOR_KEY_CT = 26,
	FLOW_DISSECTOR_KEY_HASH = 27,
	FLOW_DISSECTOR_KEY_NUM_OF_VLANS = 28,
	FLOW_DISSECTOR_KEY_PPPOE = 29,
	FLOW_DISSECTOR_KEY_L2TPV3 = 30,
	FLOW_DISSECTOR_KEY_CFM = 31,
	FLOW_DISSECTOR_KEY_IPSEC = 32,
	FLOW_DISSECTOR_KEY_MAX = 33,
};

enum flowlabel_reflect {
	FLOWLABEL_REFLECT_ESTABLISHED = 1,
	FLOWLABEL_REFLECT_TCP_RESET = 2,
	FLOWLABEL_REFLECT_ICMPV6_ECHO_REPLIES = 4,
};

enum folio_references {
	FOLIOREF_RECLAIM = 0,
	FOLIOREF_RECLAIM_CLEAN = 1,
	FOLIOREF_KEEP = 2,
	FOLIOREF_ACTIVATE = 3,
};

enum folio_walk_level {
	FW_LEVEL_PTE = 0,
	FW_LEVEL_PMD = 1,
	FW_LEVEL_PUD = 2,
};

enum forcewake_domain_id {
	FW_DOMAIN_ID_RENDER = 0,
	FW_DOMAIN_ID_GT = 1,
	FW_DOMAIN_ID_MEDIA = 2,
	FW_DOMAIN_ID_MEDIA_VDBOX0 = 3,
	FW_DOMAIN_ID_MEDIA_VDBOX1 = 4,
	FW_DOMAIN_ID_MEDIA_VDBOX2 = 5,
	FW_DOMAIN_ID_MEDIA_VDBOX3 = 6,
	FW_DOMAIN_ID_MEDIA_VDBOX4 = 7,
	FW_DOMAIN_ID_MEDIA_VDBOX5 = 8,
	FW_DOMAIN_ID_MEDIA_VDBOX6 = 9,
	FW_DOMAIN_ID_MEDIA_VDBOX7 = 10,
	FW_DOMAIN_ID_MEDIA_VEBOX0 = 11,
	FW_DOMAIN_ID_MEDIA_VEBOX1 = 12,
	FW_DOMAIN_ID_MEDIA_VEBOX2 = 13,
	FW_DOMAIN_ID_MEDIA_VEBOX3 = 14,
	FW_DOMAIN_ID_GSC = 15,
	FW_DOMAIN_ID_COUNT = 16,
};

enum forcewake_domains {
	FORCEWAKE_RENDER = 1,
	FORCEWAKE_GT = 2,
	FORCEWAKE_MEDIA = 4,
	FORCEWAKE_MEDIA_VDBOX0 = 8,
	FORCEWAKE_MEDIA_VDBOX1 = 16,
	FORCEWAKE_MEDIA_VDBOX2 = 32,
	FORCEWAKE_MEDIA_VDBOX3 = 64,
	FORCEWAKE_MEDIA_VDBOX4 = 128,
	FORCEWAKE_MEDIA_VDBOX5 = 256,
	FORCEWAKE_MEDIA_VDBOX6 = 512,
	FORCEWAKE_MEDIA_VDBOX7 = 1024,
	FORCEWAKE_MEDIA_VEBOX0 = 2048,
	FORCEWAKE_MEDIA_VEBOX1 = 4096,
	FORCEWAKE_MEDIA_VEBOX2 = 8192,
	FORCEWAKE_MEDIA_VEBOX3 = 16384,
	FORCEWAKE_GSC = 32768,
	FORCEWAKE_ALL = 65535,
};

enum format_state {
	FORMAT_STATE_NONE = 0,
	FORMAT_STATE_NUM = 1,
	FORMAT_STATE_WIDTH = 2,
	FORMAT_STATE_PRECISION = 3,
	FORMAT_STATE_CHAR = 4,
	FORMAT_STATE_STR = 5,
	FORMAT_STATE_PTR = 6,
	FORMAT_STATE_PERCENT_CHAR = 7,
	FORMAT_STATE_INVALID = 8,
};

enum freeze_holder {
	FREEZE_HOLDER_KERNEL = 1,
	FREEZE_HOLDER_USERSPACE = 2,
	FREEZE_MAY_NEST = 4,
};

enum freezer_state_flags {
	CGROUP_FREEZER_ONLINE = 1,
	CGROUP_FREEZING_SELF = 2,
	CGROUP_FREEZING_PARENT = 4,
	CGROUP_FROZEN = 8,
	CGROUP_FREEZING = 6,
};

enum freq_qos_req_type {
	FREQ_QOS_MIN = 1,
	FREQ_QOS_MAX = 2,
};

enum fs_context_phase {
	FS_CONTEXT_CREATE_PARAMS = 0,
	FS_CONTEXT_CREATING = 1,
	FS_CONTEXT_AWAITING_MOUNT = 2,
	FS_CONTEXT_AWAITING_RECONF = 3,
	FS_CONTEXT_RECONF_PARAMS = 4,
	FS_CONTEXT_RECONFIGURING = 5,
	FS_CONTEXT_FAILED = 6,
};

enum fs_context_purpose {
	FS_CONTEXT_FOR_MOUNT = 0,
	FS_CONTEXT_FOR_SUBMOUNT = 1,
	FS_CONTEXT_FOR_RECONFIGURE = 2,
};

enum fs_value_type {
	fs_value_is_undefined = 0,
	fs_value_is_flag = 1,
	fs_value_is_string = 2,
	fs_value_is_blob = 3,
	fs_value_is_filename = 4,
	fs_value_is_file = 5,
};

enum fscache_cache_state {
	FSCACHE_CACHE_IS_NOT_PRESENT = 0,
	FSCACHE_CACHE_IS_PREPARING = 1,
	FSCACHE_CACHE_IS_ACTIVE = 2,
	FSCACHE_CACHE_GOT_IOERROR = 3,
	FSCACHE_CACHE_IS_WITHDRAWN = 4,
};

enum fscache_cookie_state {
	FSCACHE_COOKIE_STATE_QUIESCENT = 0,
	FSCACHE_COOKIE_STATE_LOOKING_UP = 1,
	FSCACHE_COOKIE_STATE_CREATING = 2,
	FSCACHE_COOKIE_STATE_ACTIVE = 3,
	FSCACHE_COOKIE_STATE_INVALIDATING = 4,
	FSCACHE_COOKIE_STATE_FAILED = 5,
	FSCACHE_COOKIE_STATE_LRU_DISCARDING = 6,
	FSCACHE_COOKIE_STATE_WITHDRAWING = 7,
	FSCACHE_COOKIE_STATE_RELINQUISHING = 8,
	FSCACHE_COOKIE_STATE_DROPPED = 9,
} __attribute__((mode(byte)));

enum fscache_want_state {
	FSCACHE_WANT_PARAMS = 0,
	FSCACHE_WANT_WRITE = 1,
	FSCACHE_WANT_READ = 2,
};

enum fsconfig_command {
	FSCONFIG_SET_FLAG = 0,
	FSCONFIG_SET_STRING = 1,
	FSCONFIG_SET_BINARY = 2,
	FSCONFIG_SET_PATH = 3,
	FSCONFIG_SET_PATH_EMPTY = 4,
	FSCONFIG_SET_FD = 5,
	FSCONFIG_CMD_CREATE = 6,
	FSCONFIG_CMD_RECONFIGURE = 7,
	FSCONFIG_CMD_CREATE_EXCL = 8,
};

enum fsl_mc_pool_type {
	FSL_MC_POOL_DPMCP = 0,
	FSL_MC_POOL_DPBP = 1,
	FSL_MC_POOL_DPCON = 2,
	FSL_MC_POOL_IRQ = 3,
	FSL_MC_NUM_POOL_TYPES = 4,
};

enum fsnotify_data_type {
	FSNOTIFY_EVENT_NONE = 0,
	FSNOTIFY_EVENT_FILE_RANGE = 1,
	FSNOTIFY_EVENT_PATH = 2,
	FSNOTIFY_EVENT_INODE = 3,
	FSNOTIFY_EVENT_DENTRY = 4,
	FSNOTIFY_EVENT_ERROR = 5,
};

enum fsnotify_group_prio {
	FSNOTIFY_PRIO_NORMAL = 0,
	FSNOTIFY_PRIO_CONTENT = 1,
	FSNOTIFY_PRIO_PRE_CONTENT = 2,
	__FSNOTIFY_PRIO_NUM = 3,
};

enum fsnotify_iter_type {
	FSNOTIFY_ITER_TYPE_INODE = 0,
	FSNOTIFY_ITER_TYPE_VFSMOUNT = 1,
	FSNOTIFY_ITER_TYPE_SB = 2,
	FSNOTIFY_ITER_TYPE_PARENT = 3,
	FSNOTIFY_ITER_TYPE_INODE2 = 4,
	FSNOTIFY_ITER_TYPE_COUNT = 5,
};

enum fsnotify_obj_type {
	FSNOTIFY_OBJ_TYPE_ANY = -1,
	FSNOTIFY_OBJ_TYPE_INODE = 0,
	FSNOTIFY_OBJ_TYPE_VFSMOUNT = 1,
	FSNOTIFY_OBJ_TYPE_SB = 2,
	FSNOTIFY_OBJ_TYPE_COUNT = 3,
	FSNOTIFY_OBJ_TYPE_DETACHED = 3,
};

enum ftrace_dump_mode {
	DUMP_NONE = 0,
	DUMP_ALL = 1,
	DUMP_ORIG = 2,
	DUMP_PARAM = 3,
};

enum futex_access {
	FUTEX_READ = 0,
	FUTEX_WRITE = 1,
};

enum fw_hdcp_status {
	FW_HDCP_STATUS_SUCCESS = 0,
	FW_HDCP_STATUS_INTERNAL_ERROR = 4096,
	FW_HDCP_STATUS_UNKNOWN_ERROR = 4097,
	FW_HDCP_STATUS_INCORRECT_API_VERSION = 4098,
	FW_HDCP_STATUS_INVALID_FUNCTION = 4099,
	FW_HDCP_STATUS_INVALID_BUFFER_LENGTH = 4100,
	FW_HDCP_STATUS_INVALID_PARAMS = 4101,
	FW_HDCP_STATUS_AUTHENTICATION_FAILED = 4102,
	FW_HDCP_INVALID_SESSION_STATE = 24576,
	FW_HDCP_SRM_FRAGMENT_UNEXPECTED = 24577,
	FW_HDCP_SRM_INVALID_LENGTH = 24578,
	FW_HDCP_SRM_FRAGMENT_OFFSET_INVALID = 24579,
	FW_HDCP_SRM_VERIFICATION_FAILED = 24580,
	FW_HDCP_SRM_VERSION_TOO_OLD = 24581,
	FW_HDCP_RX_CERT_VERIFICATION_FAILED = 24582,
	FW_HDCP_RX_REVOKED = 24583,
	FW_HDCP_H_VERIFICATION_FAILED = 24584,
	FW_HDCP_REPEATER_CHECK_UNEXPECTED = 24585,
	FW_HDCP_TOPOLOGY_MAX_EXCEEDED = 24586,
	FW_HDCP_V_VERIFICATION_FAILED = 24587,
	FW_HDCP_L_VERIFICATION_FAILED = 24588,
	FW_HDCP_STREAM_KEY_ALLOC_FAILED = 24589,
	FW_HDCP_BASE_KEY_RESET_FAILED = 24590,
	FW_HDCP_NONCE_GENERATION_FAILED = 24591,
	FW_HDCP_STATUS_INVALID_E_KEY_STATE = 24592,
	FW_HDCP_STATUS_INVALID_CS_ICV = 24593,
	FW_HDCP_STATUS_INVALID_KB_KEY_STATE = 24594,
	FW_HDCP_STATUS_INVALID_PAVP_MODE_ICV = 24595,
	FW_HDCP_STATUS_INVALID_PAVP_MODE = 24596,
	FW_HDCP_STATUS_LC_MAX_ATTEMPTS = 24597,
	FW_HDCP_STATUS_MISMATCH_IN_M = 24598,
	FW_HDCP_STATUS_RX_PROV_NOT_ALLOWED = 24599,
	FW_HDCP_STATUS_RX_PROV_WRONG_SUBJECT = 24600,
	FW_HDCP_RX_NEEDS_PROVISIONING = 24601,
	FW_HDCP_BKSV_ICV_AUTH_FAILED = 24608,
	FW_HDCP_STATUS_INVALID_STREAM_ID = 24609,
	FW_HDCP_STATUS_CHAIN_NOT_INITIALIZED = 24610,
	FW_HDCP_FAIL_NOT_EXPECTED = 24611,
	FW_HDCP_FAIL_HDCP_OFF = 24612,
	FW_HDCP_FAIL_INVALID_PAVP_MEMORY_MODE = 24613,
	FW_HDCP_FAIL_AES_ECB_FAILURE = 24614,
	FW_HDCP_FEATURE_NOT_SUPPORTED = 24615,
	FW_HDCP_DMA_READ_ERROR = 24616,
	FW_HDCP_DMA_WRITE_ERROR = 24617,
	FW_HDCP_FAIL_INVALID_PACKET_SIZE = 24624,
	FW_HDCP_H264_PARSING_ERROR = 24625,
	FW_HDCP_HDCP2_ERRATA_VIDEO_VIOLATION = 24626,
	FW_HDCP_HDCP2_ERRATA_AUDIO_VIOLATION = 24627,
	FW_HDCP_TX_ACTIVE_ERROR = 24628,
	FW_HDCP_MODE_CHANGE_ERROR = 24629,
	FW_HDCP_STREAM_TYPE_ERROR = 24630,
	FW_HDCP_STREAM_MANAGE_NOT_POSSIBLE = 24631,
	FW_HDCP_STATUS_PORT_INVALID_COMMAND = 24632,
	FW_HDCP_STATUS_UNSUPPORTED_PROTOCOL = 24633,
	FW_HDCP_STATUS_INVALID_PORT_INDEX = 24634,
	FW_HDCP_STATUS_TX_AUTH_NEEDED = 24635,
	FW_HDCP_STATUS_NOT_INTEGRATED_PORT = 24636,
	FW_HDCP_STATUS_SESSION_MAX_REACHED = 24637,
	FW_HDCP_STATUS_NOT_HDCP_CAPABLE = 24641,
	FW_HDCP_STATUS_INVALID_STREAM_COUNT = 24642,
};

enum fw_opt {
	FW_OPT_UEVENT = 1,
	FW_OPT_NOWAIT = 2,
	FW_OPT_USERHELPER = 4,
	FW_OPT_NO_WARN = 8,
	FW_OPT_NOCACHE = 16,
	FW_OPT_NOFALLBACK_SYSFS = 32,
	FW_OPT_FALLBACK_PLATFORM = 64,
	FW_OPT_PARTIAL = 128,
};

enum fw_status {
	FW_STATUS_UNKNOWN = 0,
	FW_STATUS_LOADING = 1,
	FW_STATUS_DONE = 2,
	FW_STATUS_ABORTED = 3,
};

enum fwdb_flags {
	FWDB_FLAG_NO_OFDM = 1,
	FWDB_FLAG_NO_OUTDOOR = 2,
	FWDB_FLAG_DFS = 4,
	FWDB_FLAG_NO_IR = 8,
	FWDB_FLAG_AUTO_BW = 16,
};

enum g4x_wm_level {
	G4X_WM_LEVEL_NORMAL = 0,
	G4X_WM_LEVEL_SR = 1,
	G4X_WM_LEVEL_HPLL = 2,
	NUM_G4X_WM_LEVELS = 3,
};

enum gds_mitigations {
	GDS_MITIGATION_OFF = 0,
	GDS_MITIGATION_UCODE_NEEDED = 1,
	GDS_MITIGATION_FORCE = 2,
	GDS_MITIGATION_FULL = 3,
	GDS_MITIGATION_FULL_LOCKED = 4,
	GDS_MITIGATION_HYPERVISOR = 5,
};

enum genl_validate_flags {
	GENL_DONT_VALIDATE_STRICT = 1,
	GENL_DONT_VALIDATE_DUMP = 2,
	GENL_DONT_VALIDATE_DUMP_STRICT = 4,
};

enum gmbus_gpio {
	GPIOA = 0,
	GPIOB = 1,
	GPIOC = 2,
	GPIOD = 3,
	GPIOE = 4,
	GPIOF = 5,
	GPIOG = 6,
	GPIOH = 7,
	__GPIOI_UNUSED = 8,
	GPIOJ = 9,
	GPIOK = 10,
	GPIOL = 11,
	GPIOM = 12,
	GPION = 13,
	GPIOO = 14,
};

enum gpio_lookup_flags {
	GPIO_ACTIVE_HIGH = 0,
	GPIO_ACTIVE_LOW = 1,
	GPIO_OPEN_DRAIN = 2,
	GPIO_OPEN_SOURCE = 4,
	GPIO_PERSISTENT = 0,
	GPIO_TRANSITORY = 8,
	GPIO_PULL_UP = 16,
	GPIO_PULL_DOWN = 32,
	GPIO_PULL_DISABLE = 64,
	GPIO_LOOKUP_FLAGS_DEFAULT = 0,
};

enum gpiod_flags {
	GPIOD_ASIS = 0,
	GPIOD_IN = 1,
	GPIOD_OUT_LOW = 3,
	GPIOD_OUT_HIGH = 7,
	GPIOD_OUT_LOW_OPEN_DRAIN = 11,
	GPIOD_OUT_HIGH_OPEN_DRAIN = 15,
};

enum gro_result {
	GRO_MERGED = 0,
	GRO_MERGED_FREE = 1,
	GRO_HELD = 2,
	GRO_NORMAL = 3,
	GRO_CONSUMED = 4,
};

typedef enum gro_result gro_result_t;

enum group_type {
	group_has_spare = 0,
	group_fully_busy = 1,
	group_misfit_task = 2,
	group_smt_balance = 3,
	group_asym_packing = 4,
	group_imbalanced = 5,
	group_overloaded = 6,
};

enum guc_capture_group_types {
	GUC_STATE_CAPTURE_GROUP_TYPE_FULL = 0,
	GUC_STATE_CAPTURE_GROUP_TYPE_PARTIAL = 1,
	GUC_STATE_CAPTURE_GROUP_TYPE_MAX = 2,
};

enum guc_capture_type {
	GUC_CAPTURE_LIST_TYPE_GLOBAL = 0,
	GUC_CAPTURE_LIST_TYPE_ENGINE_CLASS = 1,
	GUC_CAPTURE_LIST_TYPE_ENGINE_INSTANCE = 2,
	GUC_CAPTURE_LIST_TYPE_MAX = 3,
};

enum guc_log_buffer_type {
	GUC_DEBUG_LOG_BUFFER = 0,
	GUC_CRASH_DUMP_LOG_BUFFER = 1,
	GUC_CAPTURE_LOG_BUFFER = 2,
	GUC_MAX_LOG_BUFFER = 3,
};

enum handle_to_path_flags {
	HANDLE_CHECK_PERMS = 1,
	HANDLE_CHECK_SUBTREE = 2,
};

enum handshake_auth {
	HANDSHAKE_AUTH_UNSPEC = 0,
	HANDSHAKE_AUTH_UNAUTH = 1,
	HANDSHAKE_AUTH_PSK = 2,
	HANDSHAKE_AUTH_X509 = 3,
};

enum handshake_handler_class {
	HANDSHAKE_HANDLER_CLASS_NONE = 0,
	HANDSHAKE_HANDLER_CLASS_TLSHD = 1,
	HANDSHAKE_HANDLER_CLASS_MAX = 2,
};

enum handshake_msg_type {
	HANDSHAKE_MSG_TYPE_UNSPEC = 0,
	HANDSHAKE_MSG_TYPE_CLIENTHELLO = 1,
	HANDSHAKE_MSG_TYPE_SERVERHELLO = 2,
};

enum hash_algo {
	HASH_ALGO_MD4 = 0,
	HASH_ALGO_MD5 = 1,
	HASH_ALGO_SHA1 = 2,
	HASH_ALGO_RIPE_MD_160 = 3,
	HASH_ALGO_SHA256 = 4,
	HASH_ALGO_SHA384 = 5,
	HASH_ALGO_SHA512 = 6,
	HASH_ALGO_SHA224 = 7,
	HASH_ALGO_RIPE_MD_128 = 8,
	HASH_ALGO_RIPE_MD_256 = 9,
	HASH_ALGO_RIPE_MD_320 = 10,
	HASH_ALGO_WP_256 = 11,
	HASH_ALGO_WP_384 = 12,
	HASH_ALGO_WP_512 = 13,
	HASH_ALGO_TGR_128 = 14,
	HASH_ALGO_TGR_160 = 15,
	HASH_ALGO_TGR_192 = 16,
	HASH_ALGO_SM3_256 = 17,
	HASH_ALGO_STREEBOG_256 = 18,
	HASH_ALGO_STREEBOG_512 = 19,
	HASH_ALGO_SHA3_256 = 20,
	HASH_ALGO_SHA3_384 = 21,
	HASH_ALGO_SHA3_512 = 22,
	HASH_ALGO__LAST = 23,
};

enum hbm_host_enum_flags {
	MEI_HBM_ENUM_F_ALLOW_ADD = 1,
	MEI_HBM_ENUM_F_IMMEDIATE_ENUM = 2,
};

enum hctx_type {
	HCTX_TYPE_DEFAULT = 0,
	HCTX_TYPE_READ = 1,
	HCTX_TYPE_POLL = 2,
	HCTX_MAX_TYPES = 3,
};

enum hdcp_command_id {
	_WIDI_COMMAND_BASE = 196608,
	WIDI_INITIATE_HDCP2_SESSION = 196608,
	HDCP_GET_SRM_STATUS = 196609,
	HDCP_SEND_SRM_FRAGMENT = 196610,
	_WIRED_COMMAND_BASE = 200704,
	WIRED_INITIATE_HDCP2_SESSION = 200704,
	WIRED_VERIFY_RECEIVER_CERT = 200705,
	WIRED_AKE_SEND_HPRIME = 200706,
	WIRED_AKE_SEND_PAIRING_INFO = 200707,
	WIRED_INIT_LOCALITY_CHECK = 200708,
	WIRED_VALIDATE_LOCALITY = 200709,
	WIRED_GET_SESSION_KEY = 200710,
	WIRED_ENABLE_AUTH = 200711,
	WIRED_VERIFY_REPEATER = 200712,
	WIRED_REPEATER_AUTH_STREAM_REQ = 200713,
	WIRED_CLOSE_SESSION = 200714,
	_WIRED_COMMANDS_COUNT = 200715,
};

enum hdcp_ddi {
	HDCP_DDI_INVALID_PORT = 0,
	HDCP_DDI_B = 1,
	HDCP_DDI_C = 2,
	HDCP_DDI_D = 3,
	HDCP_DDI_E = 4,
	HDCP_DDI_F = 5,
	HDCP_DDI_A = 7,
	HDCP_DDI_RANGE_END = 7,
};

enum hdcp_port_type {
	HDCP_PORT_TYPE_INVALID = 0,
	HDCP_PORT_TYPE_INTEGRATED = 1,
	HDCP_PORT_TYPE_LSPCON = 2,
	HDCP_PORT_TYPE_CPDP = 3,
};

enum hdcp_transcoder {
	HDCP_INVALID_TRANSCODER = 0,
	HDCP_TRANSCODER_EDP = 1,
	HDCP_TRANSCODER_DSI0 = 2,
	HDCP_TRANSCODER_DSI1 = 3,
	HDCP_TRANSCODER_A = 16,
	HDCP_TRANSCODER_B = 17,
	HDCP_TRANSCODER_C = 18,
	HDCP_TRANSCODER_D = 19,
};

enum hdcp_wired_protocol {
	HDCP_PROTOCOL_INVALID = 0,
	HDCP_PROTOCOL_HDMI = 1,
	HDCP_PROTOCOL_DP = 2,
};

enum hdmi_3d_structure {
	HDMI_3D_STRUCTURE_INVALID = -1,
	HDMI_3D_STRUCTURE_FRAME_PACKING = 0,
	HDMI_3D_STRUCTURE_FIELD_ALTERNATIVE = 1,
	HDMI_3D_STRUCTURE_LINE_ALTERNATIVE = 2,
	HDMI_3D_STRUCTURE_SIDE_BY_SIDE_FULL = 3,
	HDMI_3D_STRUCTURE_L_DEPTH = 4,
	HDMI_3D_STRUCTURE_L_DEPTH_GFX_GFX_DEPTH = 5,
	HDMI_3D_STRUCTURE_TOP_AND_BOTTOM = 6,
	HDMI_3D_STRUCTURE_SIDE_BY_SIDE_HALF = 8,
};

enum hdmi_active_aspect {
	HDMI_ACTIVE_ASPECT_16_9_TOP = 2,
	HDMI_ACTIVE_ASPECT_14_9_TOP = 3,
	HDMI_ACTIVE_ASPECT_16_9_CENTER = 4,
	HDMI_ACTIVE_ASPECT_PICTURE = 8,
	HDMI_ACTIVE_ASPECT_4_3 = 9,
	HDMI_ACTIVE_ASPECT_16_9 = 10,
	HDMI_ACTIVE_ASPECT_14_9 = 11,
	HDMI_ACTIVE_ASPECT_4_3_SP_14_9 = 13,
	HDMI_ACTIVE_ASPECT_16_9_SP_14_9 = 14,
	HDMI_ACTIVE_ASPECT_16_9_SP_4_3 = 15,
};

enum hdmi_audio_coding_type {
	HDMI_AUDIO_CODING_TYPE_STREAM = 0,
	HDMI_AUDIO_CODING_TYPE_PCM = 1,
	HDMI_AUDIO_CODING_TYPE_AC3 = 2,
	HDMI_AUDIO_CODING_TYPE_MPEG1 = 3,
	HDMI_AUDIO_CODING_TYPE_MP3 = 4,
	HDMI_AUDIO_CODING_TYPE_MPEG2 = 5,
	HDMI_AUDIO_CODING_TYPE_AAC_LC = 6,
	HDMI_AUDIO_CODING_TYPE_DTS = 7,
	HDMI_AUDIO_CODING_TYPE_ATRAC = 8,
	HDMI_AUDIO_CODING_TYPE_DSD = 9,
	HDMI_AUDIO_CODING_TYPE_EAC3 = 10,
	HDMI_AUDIO_CODING_TYPE_DTS_HD = 11,
	HDMI_AUDIO_CODING_TYPE_MLP = 12,
	HDMI_AUDIO_CODING_TYPE_DST = 13,
	HDMI_AUDIO_CODING_TYPE_WMA_PRO = 14,
	HDMI_AUDIO_CODING_TYPE_CXT = 15,
};

enum hdmi_audio_coding_type_ext {
	HDMI_AUDIO_CODING_TYPE_EXT_CT = 0,
	HDMI_AUDIO_CODING_TYPE_EXT_HE_AAC = 1,
	HDMI_AUDIO_CODING_TYPE_EXT_HE_AAC_V2 = 2,
	HDMI_AUDIO_CODING_TYPE_EXT_MPEG_SURROUND = 3,
	HDMI_AUDIO_CODING_TYPE_EXT_MPEG4_HE_AAC = 4,
	HDMI_AUDIO_CODING_TYPE_EXT_MPEG4_HE_AAC_V2 = 5,
	HDMI_AUDIO_CODING_TYPE_EXT_MPEG4_AAC_LC = 6,
	HDMI_AUDIO_CODING_TYPE_EXT_DRA = 7,
	HDMI_AUDIO_CODING_TYPE_EXT_MPEG4_HE_AAC_SURROUND = 8,
	HDMI_AUDIO_CODING_TYPE_EXT_MPEG4_AAC_LC_SURROUND = 10,
};

enum hdmi_audio_sample_frequency {
	HDMI_AUDIO_SAMPLE_FREQUENCY_STREAM = 0,
	HDMI_AUDIO_SAMPLE_FREQUENCY_32000 = 1,
	HDMI_AUDIO_SAMPLE_FREQUENCY_44100 = 2,
	HDMI_AUDIO_SAMPLE_FREQUENCY_48000 = 3,
	HDMI_AUDIO_SAMPLE_FREQUENCY_88200 = 4,
	HDMI_AUDIO_SAMPLE_FREQUENCY_96000 = 5,
	HDMI_AUDIO_SAMPLE_FREQUENCY_176400 = 6,
	HDMI_AUDIO_SAMPLE_FREQUENCY_192000 = 7,
};

enum hdmi_audio_sample_size {
	HDMI_AUDIO_SAMPLE_SIZE_STREAM = 0,
	HDMI_AUDIO_SAMPLE_SIZE_16 = 1,
	HDMI_AUDIO_SAMPLE_SIZE_20 = 2,
	HDMI_AUDIO_SAMPLE_SIZE_24 = 3,
};

enum hdmi_colorimetry {
	HDMI_COLORIMETRY_NONE = 0,
	HDMI_COLORIMETRY_ITU_601 = 1,
	HDMI_COLORIMETRY_ITU_709 = 2,
	HDMI_COLORIMETRY_EXTENDED = 3,
};

enum hdmi_colorspace {
	HDMI_COLORSPACE_RGB = 0,
	HDMI_COLORSPACE_YUV422 = 1,
	HDMI_COLORSPACE_YUV444 = 2,
	HDMI_COLORSPACE_YUV420 = 3,
	HDMI_COLORSPACE_RESERVED4 = 4,
	HDMI_COLORSPACE_RESERVED5 = 5,
	HDMI_COLORSPACE_RESERVED6 = 6,
	HDMI_COLORSPACE_IDO_DEFINED = 7,
};

enum hdmi_content_type {
	HDMI_CONTENT_TYPE_GRAPHICS = 0,
	HDMI_CONTENT_TYPE_PHOTO = 1,
	HDMI_CONTENT_TYPE_CINEMA = 2,
	HDMI_CONTENT_TYPE_GAME = 3,
};

enum hdmi_eotf {
	HDMI_EOTF_TRADITIONAL_GAMMA_SDR = 0,
	HDMI_EOTF_TRADITIONAL_GAMMA_HDR = 1,
	HDMI_EOTF_SMPTE_ST2084 = 2,
	HDMI_EOTF_BT_2100_HLG = 3,
};

enum hdmi_extended_colorimetry {
	HDMI_EXTENDED_COLORIMETRY_XV_YCC_601 = 0,
	HDMI_EXTENDED_COLORIMETRY_XV_YCC_709 = 1,
	HDMI_EXTENDED_COLORIMETRY_S_YCC_601 = 2,
	HDMI_EXTENDED_COLORIMETRY_OPYCC_601 = 3,
	HDMI_EXTENDED_COLORIMETRY_OPRGB = 4,
	HDMI_EXTENDED_COLORIMETRY_BT2020_CONST_LUM = 5,
	HDMI_EXTENDED_COLORIMETRY_BT2020 = 6,
	HDMI_EXTENDED_COLORIMETRY_RESERVED = 7,
};

enum hdmi_force_audio {
	HDMI_AUDIO_OFF_DVI = -2,
	HDMI_AUDIO_OFF = -1,
	HDMI_AUDIO_AUTO = 0,
	HDMI_AUDIO_ON = 1,
};

enum hdmi_infoframe_type {
	HDMI_INFOFRAME_TYPE_VENDOR = 129,
	HDMI_INFOFRAME_TYPE_AVI = 130,
	HDMI_INFOFRAME_TYPE_SPD = 131,
	HDMI_INFOFRAME_TYPE_AUDIO = 132,
	HDMI_INFOFRAME_TYPE_DRM = 135,
};

enum hdmi_metadata_type {
	HDMI_STATIC_METADATA_TYPE1 = 0,
};

enum hdmi_nups {
	HDMI_NUPS_UNKNOWN = 0,
	HDMI_NUPS_HORIZONTAL = 1,
	HDMI_NUPS_VERTICAL = 2,
	HDMI_NUPS_BOTH = 3,
};

enum hdmi_packet_type {
	HDMI_PACKET_TYPE_NULL = 0,
	HDMI_PACKET_TYPE_AUDIO_CLOCK_REGEN = 1,
	HDMI_PACKET_TYPE_AUDIO_SAMPLE = 2,
	HDMI_PACKET_TYPE_GENERAL_CONTROL = 3,
	HDMI_PACKET_TYPE_ACP = 4,
	HDMI_PACKET_TYPE_ISRC1 = 5,
	HDMI_PACKET_TYPE_ISRC2 = 6,
	HDMI_PACKET_TYPE_ONE_BIT_AUDIO_SAMPLE = 7,
	HDMI_PACKET_TYPE_DST_AUDIO = 8,
	HDMI_PACKET_TYPE_HBR_AUDIO_STREAM = 9,
	HDMI_PACKET_TYPE_GAMUT_METADATA = 10,
};

enum hdmi_picture_aspect {
	HDMI_PICTURE_ASPECT_NONE = 0,
	HDMI_PICTURE_ASPECT_4_3 = 1,
	HDMI_PICTURE_ASPECT_16_9 = 2,
	HDMI_PICTURE_ASPECT_64_27 = 3,
	HDMI_PICTURE_ASPECT_256_135 = 4,
	HDMI_PICTURE_ASPECT_RESERVED = 5,
};

enum hdmi_quantization_range {
	HDMI_QUANTIZATION_RANGE_DEFAULT = 0,
	HDMI_QUANTIZATION_RANGE_LIMITED = 1,
	HDMI_QUANTIZATION_RANGE_FULL = 2,
	HDMI_QUANTIZATION_RANGE_RESERVED = 3,
};

enum hdmi_scan_mode {
	HDMI_SCAN_MODE_NONE = 0,
	HDMI_SCAN_MODE_OVERSCAN = 1,
	HDMI_SCAN_MODE_UNDERSCAN = 2,
	HDMI_SCAN_MODE_RESERVED = 3,
};

enum hdmi_spd_sdi {
	HDMI_SPD_SDI_UNKNOWN = 0,
	HDMI_SPD_SDI_DSTB = 1,
	HDMI_SPD_SDI_DVDP = 2,
	HDMI_SPD_SDI_DVHS = 3,
	HDMI_SPD_SDI_HDDVR = 4,
	HDMI_SPD_SDI_DVC = 5,
	HDMI_SPD_SDI_DSC = 6,
	HDMI_SPD_SDI_VCD = 7,
	HDMI_SPD_SDI_GAME = 8,
	HDMI_SPD_SDI_PC = 9,
	HDMI_SPD_SDI_BD = 10,
	HDMI_SPD_SDI_SACD = 11,
	HDMI_SPD_SDI_HDDVD = 12,
	HDMI_SPD_SDI_PMP = 13,
};

enum hdmi_ycc_quantization_range {
	HDMI_YCC_QUANTIZATION_RANGE_LIMITED = 0,
	HDMI_YCC_QUANTIZATION_RANGE_FULL = 1,
};

enum hid_class_request {
	HID_REQ_GET_REPORT = 1,
	HID_REQ_GET_IDLE = 2,
	HID_REQ_GET_PROTOCOL = 3,
	HID_REQ_SET_REPORT = 9,
	HID_REQ_SET_IDLE = 10,
	HID_REQ_SET_PROTOCOL = 11,
};

enum hid_report_type {
	HID_INPUT_REPORT = 0,
	HID_OUTPUT_REPORT = 1,
	HID_FEATURE_REPORT = 2,
	HID_REPORT_TYPES = 3,
};

enum hid_type {
	HID_TYPE_OTHER = 0,
	HID_TYPE_USBMOUSE = 1,
	HID_TYPE_USBNONE = 2,
};

enum hk_flags {
	HK_FLAG_DOMAIN = 1,
	HK_FLAG_MANAGED_IRQ = 2,
	HK_FLAG_KERNEL_NOISE = 4,
};

enum hk_type {
	HK_TYPE_DOMAIN = 0,
	HK_TYPE_MANAGED_IRQ = 1,
	HK_TYPE_KERNEL_NOISE = 2,
	HK_TYPE_MAX = 3,
	HK_TYPE_TICK = 2,
	HK_TYPE_TIMER = 2,
	HK_TYPE_RCU = 2,
	HK_TYPE_MISC = 2,
	HK_TYPE_WQ = 2,
	HK_TYPE_KTHREAD = 2,
};

enum hn_flags_bits {
	HANDSHAKE_F_NET_DRAINING = 0,
};

enum hp_flags_bits {
	HANDSHAKE_F_PROTO_NOTIFY = 0,
};

enum hpd_pin {
	HPD_NONE = 0,
	HPD_TV = 0,
	HPD_CRT = 1,
	HPD_SDVO_B = 2,
	HPD_SDVO_C = 3,
	HPD_PORT_A = 4,
	HPD_PORT_B = 5,
	HPD_PORT_C = 6,
	HPD_PORT_D = 7,
	HPD_PORT_E = 8,
	HPD_PORT_TC1 = 9,
	HPD_PORT_TC2 = 10,
	HPD_PORT_TC3 = 11,
	HPD_PORT_TC4 = 12,
	HPD_PORT_TC5 = 13,
	HPD_PORT_TC6 = 14,
	HPD_NUM_PINS = 15,
};

enum hpet_mode {
	HPET_MODE_UNUSED = 0,
	HPET_MODE_LEGACY = 1,
	HPET_MODE_CLOCKEVT = 2,
	HPET_MODE_DEVICE = 3,
};

enum hprobe_state {
	HPROBE_LEASED = 0,
	HPROBE_STABLE = 1,
	HPROBE_GONE = 2,
	HPROBE_CONSUMED = 3,
};

enum hpx_type3_cfg_loc {
	HPX_CFG_PCICFG = 0,
	HPX_CFG_PCIE_CAP = 1,
	HPX_CFG_PCIE_CAP_EXT = 2,
	HPX_CFG_VEND_CAP = 3,
	HPX_CFG_DVSEC = 4,
	HPX_CFG_MAX = 5,
};

enum hpx_type3_dev_type {
	HPX_TYPE_ENDPOINT = 1,
	HPX_TYPE_LEG_END = 2,
	HPX_TYPE_RC_END = 4,
	HPX_TYPE_RC_EC = 8,
	HPX_TYPE_ROOT_PORT = 16,
	HPX_TYPE_UPSTREAM = 32,
	HPX_TYPE_DOWNSTREAM = 64,
	HPX_TYPE_PCI_BRIDGE = 128,
	HPX_TYPE_PCIE_BRIDGE = 256,
};

enum hpx_type3_fn_type {
	HPX_FN_NORMAL = 1,
	HPX_FN_SRIOV_PHYS = 2,
	HPX_FN_SRIOV_VIRT = 4,
};

enum hr_flags_bits {
	HANDSHAKE_F_REQ_COMPLETED = 0,
	HANDSHAKE_F_REQ_SESSION = 1,
};

enum hrtimer_base_type {
	HRTIMER_BASE_MONOTONIC = 0,
	HRTIMER_BASE_REALTIME = 1,
	HRTIMER_BASE_BOOTTIME = 2,
	HRTIMER_BASE_TAI = 3,
	HRTIMER_BASE_MONOTONIC_SOFT = 4,
	HRTIMER_BASE_REALTIME_SOFT = 5,
	HRTIMER_BASE_BOOTTIME_SOFT = 6,
	HRTIMER_BASE_TAI_SOFT = 7,
	HRTIMER_MAX_CLOCK_BASES = 8,
};

enum hrtimer_mode {
	HRTIMER_MODE_ABS = 0,
	HRTIMER_MODE_REL = 1,
	HRTIMER_MODE_PINNED = 2,
	HRTIMER_MODE_SOFT = 4,
	HRTIMER_MODE_HARD = 8,
	HRTIMER_MODE_ABS_PINNED = 2,
	HRTIMER_MODE_REL_PINNED = 3,
	HRTIMER_MODE_ABS_SOFT = 4,
	HRTIMER_MODE_REL_SOFT = 5,
	HRTIMER_MODE_ABS_PINNED_SOFT = 6,
	HRTIMER_MODE_REL_PINNED_SOFT = 7,
	HRTIMER_MODE_ABS_HARD = 8,
	HRTIMER_MODE_REL_HARD = 9,
	HRTIMER_MODE_ABS_PINNED_HARD = 10,
	HRTIMER_MODE_REL_PINNED_HARD = 11,
};

enum hrtimer_restart {
	HRTIMER_NORESTART = 0,
	HRTIMER_RESTART = 1,
};

enum hsm_task_states {
	HSM_ST_IDLE = 0,
	HSM_ST_FIRST = 1,
	HSM_ST = 2,
	HSM_ST_LAST = 3,
	HSM_ST_ERR = 4,
};

enum hub_activation_type {
	HUB_INIT = 0,
	HUB_INIT2 = 1,
	HUB_INIT3 = 2,
	HUB_POST_RESET = 3,
	HUB_RESUME = 4,
	HUB_RESET_RESUME = 5,
};

enum hub_led_mode {
	INDICATOR_AUTO = 0,
	INDICATOR_CYCLE = 1,
	INDICATOR_GREEN_BLINK = 2,
	INDICATOR_GREEN_BLINK_OFF = 3,
	INDICATOR_AMBER_BLINK = 4,
	INDICATOR_AMBER_BLINK_OFF = 5,
	INDICATOR_ALT_BLINK = 6,
	INDICATOR_ALT_BLINK_OFF = 7,
} __attribute__((mode(byte)));

enum hub_quiescing_type {
	HUB_DISCONNECT = 0,
	HUB_PRE_RESET = 1,
	HUB_SUSPEND = 2,
};

enum hugetlb_memory_event {
	HUGETLB_MAX = 0,
	HUGETLB_NR_MEMORY_EVENTS = 1,
};

enum hugetlb_page_flags {
	HPG_restore_reserve = 0,
	HPG_migratable = 1,
	HPG_temporary = 2,
	HPG_freed = 3,
	HPG_vmemmap_optimized = 4,
	HPG_raw_hwp_unreliable = 5,
	__NR_HPAGEFLAGS = 6,
};

enum hugetlb_param {
	Opt_gid___7 = 0,
	Opt_min_size = 1,
	Opt_mode___5 = 2,
	Opt_nr_inodes = 3,
	Opt_pagesize = 4,
	Opt_size = 5,
	Opt_uid___7 = 6,
};

enum hugetlbfs_size_type {
	NO_SIZE = 0,
	SIZE_STD = 1,
	SIZE_PERCENT = 2,
};

enum hv_isolation_type {
	HV_ISOLATION_TYPE_NONE = 0,
	HV_ISOLATION_TYPE_VBS = 1,
	HV_ISOLATION_TYPE_SNP = 2,
	HV_ISOLATION_TYPE_TDX = 3,
};

enum hv_tlb_flush_fifos {
	HV_L1_TLB_FLUSH_FIFO = 0,
	HV_L2_TLB_FLUSH_FIFO = 1,
	HV_NR_TLB_FLUSH_FIFOS = 2,
};

enum hwmon_chip_attributes {
	hwmon_chip_temp_reset_history = 0,
	hwmon_chip_in_reset_history = 1,
	hwmon_chip_curr_reset_history = 2,
	hwmon_chip_power_reset_history = 3,
	hwmon_chip_register_tz = 4,
	hwmon_chip_update_interval = 5,
	hwmon_chip_alarms = 6,
	hwmon_chip_samples = 7,
	hwmon_chip_curr_samples = 8,
	hwmon_chip_in_samples = 9,
	hwmon_chip_power_samples = 10,
	hwmon_chip_temp_samples = 11,
	hwmon_chip_beep_enable = 12,
	hwmon_chip_pec = 13,
};

enum hwmon_curr_attributes {
	hwmon_curr_enable = 0,
	hwmon_curr_input = 1,
	hwmon_curr_min = 2,
	hwmon_curr_max = 3,
	hwmon_curr_lcrit = 4,
	hwmon_curr_crit = 5,
	hwmon_curr_average = 6,
	hwmon_curr_lowest = 7,
	hwmon_curr_highest = 8,
	hwmon_curr_reset_history = 9,
	hwmon_curr_label = 10,
	hwmon_curr_alarm = 11,
	hwmon_curr_min_alarm = 12,
	hwmon_curr_max_alarm = 13,
	hwmon_curr_lcrit_alarm = 14,
	hwmon_curr_crit_alarm = 15,
	hwmon_curr_rated_min = 16,
	hwmon_curr_rated_max = 17,
	hwmon_curr_beep = 18,
};

enum hwmon_energy_attributes {
	hwmon_energy_enable = 0,
	hwmon_energy_input = 1,
	hwmon_energy_label = 2,
};

enum hwmon_fan_attributes {
	hwmon_fan_enable = 0,
	hwmon_fan_input = 1,
	hwmon_fan_label = 2,
	hwmon_fan_min = 3,
	hwmon_fan_max = 4,
	hwmon_fan_div = 5,
	hwmon_fan_pulses = 6,
	hwmon_fan_target = 7,
	hwmon_fan_alarm = 8,
	hwmon_fan_min_alarm = 9,
	hwmon_fan_max_alarm = 10,
	hwmon_fan_fault = 11,
	hwmon_fan_beep = 12,
};

enum hwmon_humidity_attributes {
	hwmon_humidity_enable = 0,
	hwmon_humidity_input = 1,
	hwmon_humidity_label = 2,
	hwmon_humidity_min = 3,
	hwmon_humidity_min_hyst = 4,
	hwmon_humidity_max = 5,
	hwmon_humidity_max_hyst = 6,
	hwmon_humidity_alarm = 7,
	hwmon_humidity_fault = 8,
	hwmon_humidity_rated_min = 9,
	hwmon_humidity_rated_max = 10,
	hwmon_humidity_min_alarm = 11,
	hwmon_humidity_max_alarm = 12,
};

enum hwmon_in_attributes {
	hwmon_in_enable = 0,
	hwmon_in_input = 1,
	hwmon_in_min = 2,
	hwmon_in_max = 3,
	hwmon_in_lcrit = 4,
	hwmon_in_crit = 5,
	hwmon_in_average = 6,
	hwmon_in_lowest = 7,
	hwmon_in_highest = 8,
	hwmon_in_reset_history = 9,
	hwmon_in_label = 10,
	hwmon_in_alarm = 11,
	hwmon_in_min_alarm = 12,
	hwmon_in_max_alarm = 13,
	hwmon_in_lcrit_alarm = 14,
	hwmon_in_crit_alarm = 15,
	hwmon_in_rated_min = 16,
	hwmon_in_rated_max = 17,
	hwmon_in_beep = 18,
	hwmon_in_fault = 19,
};

enum hwmon_intrusion_attributes {
	hwmon_intrusion_alarm = 0,
	hwmon_intrusion_beep = 1,
};

enum hwmon_power_attributes {
	hwmon_power_enable = 0,
	hwmon_power_average = 1,
	hwmon_power_average_interval = 2,
	hwmon_power_average_interval_max = 3,
	hwmon_power_average_interval_min = 4,
	hwmon_power_average_highest = 5,
	hwmon_power_average_lowest = 6,
	hwmon_power_average_max = 7,
	hwmon_power_average_min = 8,
	hwmon_power_input = 9,
	hwmon_power_input_highest = 10,
	hwmon_power_input_lowest = 11,
	hwmon_power_reset_history = 12,
	hwmon_power_accuracy = 13,
	hwmon_power_cap = 14,
	hwmon_power_cap_hyst = 15,
	hwmon_power_cap_max = 16,
	hwmon_power_cap_min = 17,
	hwmon_power_min = 18,
	hwmon_power_max = 19,
	hwmon_power_crit = 20,
	hwmon_power_lcrit = 21,
	hwmon_power_label = 22,
	hwmon_power_alarm = 23,
	hwmon_power_cap_alarm = 24,
	hwmon_power_min_alarm = 25,
	hwmon_power_max_alarm = 26,
	hwmon_power_lcrit_alarm = 27,
	hwmon_power_crit_alarm = 28,
	hwmon_power_rated_min = 29,
	hwmon_power_rated_max = 30,
};

enum hwmon_pwm_attributes {
	hwmon_pwm_input = 0,
	hwmon_pwm_enable = 1,
	hwmon_pwm_mode = 2,
	hwmon_pwm_freq = 3,
	hwmon_pwm_auto_channels_temp = 4,
};

enum hwmon_sensor_types {
	hwmon_chip = 0,
	hwmon_temp = 1,
	hwmon_in = 2,
	hwmon_curr = 3,
	hwmon_power = 4,
	hwmon_energy = 5,
	hwmon_humidity = 6,
	hwmon_fan = 7,
	hwmon_pwm = 8,
	hwmon_intrusion = 9,
	hwmon_max = 10,
};

enum hwmon_temp_attributes {
	hwmon_temp_enable = 0,
	hwmon_temp_input = 1,
	hwmon_temp_type = 2,
	hwmon_temp_lcrit = 3,
	hwmon_temp_lcrit_hyst = 4,
	hwmon_temp_min = 5,
	hwmon_temp_min_hyst = 6,
	hwmon_temp_max = 7,
	hwmon_temp_max_hyst = 8,
	hwmon_temp_crit = 9,
	hwmon_temp_crit_hyst = 10,
	hwmon_temp_emergency = 11,
	hwmon_temp_emergency_hyst = 12,
	hwmon_temp_alarm = 13,
	hwmon_temp_lcrit_alarm = 14,
	hwmon_temp_min_alarm = 15,
	hwmon_temp_max_alarm = 16,
	hwmon_temp_crit_alarm = 17,
	hwmon_temp_emergency_alarm = 18,
	hwmon_temp_fault = 19,
	hwmon_temp_offset = 20,
	hwmon_temp_label = 21,
	hwmon_temp_lowest = 22,
	hwmon_temp_highest = 23,
	hwmon_temp_reset_history = 24,
	hwmon_temp_rated_min = 25,
	hwmon_temp_rated_max = 26,
	hwmon_temp_beep = 27,
};

enum hwparam_type {
	hwparam_ioport = 0,
	hwparam_iomem = 1,
	hwparam_ioport_or_iomem = 2,
	hwparam_irq = 3,
	hwparam_dma = 4,
	hwparam_dma_addr = 5,
	hwparam_other = 6,
};

enum hwtstamp_flags {
	HWTSTAMP_FLAG_BONDED_PHC_INDEX = 1,
	HWTSTAMP_FLAG_LAST = 1,
	HWTSTAMP_FLAG_MASK = 1,
};

enum hwtstamp_provider_qualifier {
	HWTSTAMP_PROVIDER_QUALIFIER_PRECISE = 0,
	HWTSTAMP_PROVIDER_QUALIFIER_APPROX = 1,
	HWTSTAMP_PROVIDER_QUALIFIER_CNT = 2,
};

enum hwtstamp_rx_filters {
	HWTSTAMP_FILTER_NONE = 0,
	HWTSTAMP_FILTER_ALL = 1,
	HWTSTAMP_FILTER_SOME = 2,
	HWTSTAMP_FILTER_PTP_V1_L4_EVENT = 3,
	HWTSTAMP_FILTER_PTP_V1_L4_SYNC = 4,
	HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ = 5,
	HWTSTAMP_FILTER_PTP_V2_L4_EVENT = 6,
	HWTSTAMP_FILTER_PTP_V2_L4_SYNC = 7,
	HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ = 8,
	HWTSTAMP_FILTER_PTP_V2_L2_EVENT = 9,
	HWTSTAMP_FILTER_PTP_V2_L2_SYNC = 10,
	HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ = 11,
	HWTSTAMP_FILTER_PTP_V2_EVENT = 12,
	HWTSTAMP_FILTER_PTP_V2_SYNC = 13,
	HWTSTAMP_FILTER_PTP_V2_DELAY_REQ = 14,
	HWTSTAMP_FILTER_NTP_ALL = 15,
	__HWTSTAMP_FILTER_CNT = 16,
};

enum hwtstamp_source {
	HWTSTAMP_SOURCE_UNSPEC = 0,
	HWTSTAMP_SOURCE_NETDEV = 1,
	HWTSTAMP_SOURCE_PHYLIB = 2,
};

enum hwtstamp_tx_types {
	HWTSTAMP_TX_OFF = 0,
	HWTSTAMP_TX_ON = 1,
	HWTSTAMP_TX_ONESTEP_SYNC = 2,
	HWTSTAMP_TX_ONESTEP_P2P = 3,
	__HWTSTAMP_TX_CNT = 4,
};

enum hybrid_cpu_type {
	HYBRID_INTEL_NONE = 0,
	HYBRID_INTEL_ATOM = 32,
	HYBRID_INTEL_CORE = 64,
};

enum hybrid_pmu_type {
	not_hybrid = 0,
	hybrid_small = 1,
	hybrid_big = 2,
	hybrid_tiny = 4,
	hybrid_big_small = 3,
	hybrid_small_tiny = 5,
	hybrid_big_small_tiny = 7,
};

enum i2c_alert_protocol {
	I2C_PROTOCOL_SMBUS_ALERT = 0,
	I2C_PROTOCOL_SMBUS_HOST_NOTIFY = 1,
};

enum i2c_driver_flags {
	I2C_DRV_ACPI_WAIVE_D0_PROBE = 1,
};

enum i8042_controller_reset_mode {
	I8042_RESET_NEVER = 0,
	I8042_RESET_ALWAYS = 1,
	I8042_RESET_ON_S2RAM = 2,
};

enum i915_cache_level {
	I915_CACHE_NONE = 0,
	I915_CACHE_LLC = 1,
	I915_CACHE_L3_LLC = 2,
	I915_CACHE_WT = 3,
	I915_MAX_CACHE_LEVEL = 4,
};

enum i915_component_type {
	I915_COMPONENT_AUDIO = 1,
	I915_COMPONENT_HDCP = 2,
	I915_COMPONENT_PXP = 3,
	I915_COMPONENT_GSC_PROXY = 4,
};

enum i915_gem_engine_type {
	I915_GEM_ENGINE_TYPE_INVALID = 0,
	I915_GEM_ENGINE_TYPE_PHYSICAL = 1,
	I915_GEM_ENGINE_TYPE_BALANCED = 2,
	I915_GEM_ENGINE_TYPE_PARALLEL = 3,
};

enum i915_gtt_view_type {
	I915_GTT_VIEW_NORMAL = 0,
	I915_GTT_VIEW_ROTATED = 24,
	I915_GTT_VIEW_PARTIAL = 12,
	I915_GTT_VIEW_REMAPPED = 52,
};

enum i915_map_type {
	I915_MAP_WB = 0,
	I915_MAP_WC = 1,
	I915_MAP_FORCE_WB = 2147483648,
	I915_MAP_FORCE_WC = 2147483649,
};

enum i915_mmap_type {
	I915_MMAP_TYPE_GTT = 0,
	I915_MMAP_TYPE_WC = 1,
	I915_MMAP_TYPE_WB = 2,
	I915_MMAP_TYPE_UC = 3,
	I915_MMAP_TYPE_FIXED = 4,
};

enum i915_mocs_table_index {
	I915_MOCS_UNCACHED = 0,
	I915_MOCS_PTE = 1,
	I915_MOCS_CACHED = 2,
};

enum i915_pmu_tracked_events {
	__I915_PMU_ACTUAL_FREQUENCY_ENABLED = 0,
	__I915_PMU_REQUESTED_FREQUENCY_ENABLED = 1,
	__I915_PMU_RC6_RESIDENCY_ENABLED = 2,
	__I915_PMU_TRACKED_EVENT_COUNT = 3,
};

enum i915_power_well_id {
	DISP_PW_ID_NONE = 0,
	VLV_DISP_PW_DISP2D = 1,
	BXT_DISP_PW_DPIO_CMN_A = 2,
	VLV_DISP_PW_DPIO_CMN_BC = 3,
	GLK_DISP_PW_DPIO_CMN_C = 4,
	CHV_DISP_PW_DPIO_CMN_D = 5,
	HSW_DISP_PW_GLOBAL = 6,
	SKL_DISP_PW_MISC_IO = 7,
	SKL_DISP_PW_1 = 8,
	SKL_DISP_PW_2 = 9,
	ICL_DISP_PW_3 = 10,
	SKL_DISP_DC_OFF = 11,
	TGL_DISP_PW_TC_COLD_OFF = 12,
};

enum i915_request_state {
	I915_REQUEST_UNKNOWN = 0,
	I915_REQUEST_COMPLETE = 1,
	I915_REQUEST_PENDING = 2,
	I915_REQUEST_QUEUED = 3,
	I915_REQUEST_ACTIVE = 4,
};

enum i915_sw_fence_notify {
	FENCE_COMPLETE = 0,
	FENCE_FREE = 1,
};

enum i9xx_plane_id {
	PLANE_A = 0,
	PLANE_B = 1,
	PLANE_C = 2,
};

enum ib_poll_context {
	IB_POLL_SOFTIRQ = 0,
	IB_POLL_WORKQUEUE = 1,
	IB_POLL_UNBOUND_WORKQUEUE = 2,
	IB_POLL_LAST_POOL_TYPE = 2,
	IB_POLL_DIRECT = 3,
};

enum ib_uverbs_access_flags {
	IB_UVERBS_ACCESS_LOCAL_WRITE = 1,
	IB_UVERBS_ACCESS_REMOTE_WRITE = 2,
	IB_UVERBS_ACCESS_REMOTE_READ = 4,
	IB_UVERBS_ACCESS_REMOTE_ATOMIC = 8,
	IB_UVERBS_ACCESS_MW_BIND = 16,
	IB_UVERBS_ACCESS_ZERO_BASED = 32,
	IB_UVERBS_ACCESS_ON_DEMAND = 64,
	IB_UVERBS_ACCESS_HUGETLB = 128,
	IB_UVERBS_ACCESS_FLUSH_GLOBAL = 256,
	IB_UVERBS_ACCESS_FLUSH_PERSISTENT = 512,
	IB_UVERBS_ACCESS_RELAXED_ORDERING = 1048576,
	IB_UVERBS_ACCESS_OPTIONAL_RANGE = 1072693248,
};

enum ib_uverbs_create_qp_mask {
	IB_UVERBS_CREATE_QP_MASK_IND_TABLE = 1,
};

enum ib_uverbs_device_cap_flags {
	IB_UVERBS_DEVICE_RESIZE_MAX_WR = 1ULL,
	IB_UVERBS_DEVICE_BAD_PKEY_CNTR = 2ULL,
	IB_UVERBS_DEVICE_BAD_QKEY_CNTR = 4ULL,
	IB_UVERBS_DEVICE_RAW_MULTI = 8ULL,
	IB_UVERBS_DEVICE_AUTO_PATH_MIG = 16ULL,
	IB_UVERBS_DEVICE_CHANGE_PHY_PORT = 32ULL,
	IB_UVERBS_DEVICE_UD_AV_PORT_ENFORCE = 64ULL,
	IB_UVERBS_DEVICE_CURR_QP_STATE_MOD = 128ULL,
	IB_UVERBS_DEVICE_SHUTDOWN_PORT = 256ULL,
	IB_UVERBS_DEVICE_PORT_ACTIVE_EVENT = 1024ULL,
	IB_UVERBS_DEVICE_SYS_IMAGE_GUID = 2048ULL,
	IB_UVERBS_DEVICE_RC_RNR_NAK_GEN = 4096ULL,
	IB_UVERBS_DEVICE_SRQ_RESIZE = 8192ULL,
	IB_UVERBS_DEVICE_N_NOTIFY_CQ = 16384ULL,
	IB_UVERBS_DEVICE_MEM_WINDOW = 131072ULL,
	IB_UVERBS_DEVICE_UD_IP_CSUM = 262144ULL,
	IB_UVERBS_DEVICE_XRC = 1048576ULL,
	IB_UVERBS_DEVICE_MEM_MGT_EXTENSIONS = 2097152ULL,
	IB_UVERBS_DEVICE_MEM_WINDOW_TYPE_2A = 8388608ULL,
	IB_UVERBS_DEVICE_MEM_WINDOW_TYPE_2B = 16777216ULL,
	IB_UVERBS_DEVICE_RC_IP_CSUM = 33554432ULL,
	IB_UVERBS_DEVICE_RAW_IP_CSUM = 67108864ULL,
	IB_UVERBS_DEVICE_MANAGED_FLOW_STEERING = 536870912ULL,
	IB_UVERBS_DEVICE_RAW_SCATTER_FCS = 17179869184ULL,
	IB_UVERBS_DEVICE_PCI_WRITE_END_PADDING = 68719476736ULL,
	IB_UVERBS_DEVICE_FLUSH_GLOBAL = 274877906944ULL,
	IB_UVERBS_DEVICE_FLUSH_PERSISTENT = 549755813888ULL,
	IB_UVERBS_DEVICE_ATOMIC_WRITE = 1099511627776ULL,
};

enum ib_uverbs_gid_type {
	IB_UVERBS_GID_TYPE_IB = 0,
	IB_UVERBS_GID_TYPE_ROCE_V1 = 1,
	IB_UVERBS_GID_TYPE_ROCE_V2 = 2,
};

enum ib_uverbs_qp_create_flags {
	IB_UVERBS_QP_CREATE_BLOCK_MULTICAST_LOOPBACK = 2,
	IB_UVERBS_QP_CREATE_SCATTER_FCS = 256,
	IB_UVERBS_QP_CREATE_CVLAN_STRIPPING = 512,
	IB_UVERBS_QP_CREATE_PCI_WRITE_END_PADDING = 2048,
	IB_UVERBS_QP_CREATE_SQ_SIG_ALL = 4096,
};

enum ib_uverbs_qp_type {
	IB_UVERBS_QPT_RC = 2,
	IB_UVERBS_QPT_UC = 3,
	IB_UVERBS_QPT_UD = 4,
	IB_UVERBS_QPT_RAW_PACKET = 8,
	IB_UVERBS_QPT_XRC_INI = 9,
	IB_UVERBS_QPT_XRC_TGT = 10,
	IB_UVERBS_QPT_DRIVER = 255,
};

enum ib_uverbs_raw_packet_caps {
	IB_UVERBS_RAW_PACKET_CAP_CVLAN_STRIPPING = 1,
	IB_UVERBS_RAW_PACKET_CAP_SCATTER_FCS = 2,
	IB_UVERBS_RAW_PACKET_CAP_IP_CSUM = 4,
	IB_UVERBS_RAW_PACKET_CAP_DELAY_DROP = 8,
};

enum ib_uverbs_srq_type {
	IB_UVERBS_SRQT_BASIC = 0,
	IB_UVERBS_SRQT_XRC = 1,
	IB_UVERBS_SRQT_TM = 2,
};

enum ib_uverbs_wc_opcode {
	IB_UVERBS_WC_SEND = 0,
	IB_UVERBS_WC_RDMA_WRITE = 1,
	IB_UVERBS_WC_RDMA_READ = 2,
	IB_UVERBS_WC_COMP_SWAP = 3,
	IB_UVERBS_WC_FETCH_ADD = 4,
	IB_UVERBS_WC_BIND_MW = 5,
	IB_UVERBS_WC_LOCAL_INV = 6,
	IB_UVERBS_WC_TSO = 7,
	IB_UVERBS_WC_FLUSH = 8,
	IB_UVERBS_WC_ATOMIC_WRITE = 9,
};

enum ib_uverbs_wq_flags {
	IB_UVERBS_WQ_FLAGS_CVLAN_STRIPPING = 1,
	IB_UVERBS_WQ_FLAGS_SCATTER_FCS = 2,
	IB_UVERBS_WQ_FLAGS_DELAY_DROP = 4,
	IB_UVERBS_WQ_FLAGS_PCI_WRITE_END_PADDING = 8,
};

enum ib_uverbs_wq_type {
	IB_UVERBS_WQT_RQ = 0,
};

enum ib_uverbs_wr_opcode {
	IB_UVERBS_WR_RDMA_WRITE = 0,
	IB_UVERBS_WR_RDMA_WRITE_WITH_IMM = 1,
	IB_UVERBS_WR_SEND = 2,
	IB_UVERBS_WR_SEND_WITH_IMM = 3,
	IB_UVERBS_WR_RDMA_READ = 4,
	IB_UVERBS_WR_ATOMIC_CMP_AND_SWP = 5,
	IB_UVERBS_WR_ATOMIC_FETCH_AND_ADD = 6,
	IB_UVERBS_WR_LOCAL_INV = 7,
	IB_UVERBS_WR_BIND_MW = 8,
	IB_UVERBS_WR_SEND_WITH_INV = 9,
	IB_UVERBS_WR_TSO = 10,
	IB_UVERBS_WR_RDMA_READ_WITH_INV = 11,
	IB_UVERBS_WR_MASKED_ATOMIC_CMP_AND_SWP = 12,
	IB_UVERBS_WR_MASKED_ATOMIC_FETCH_AND_ADD = 13,
	IB_UVERBS_WR_FLUSH = 14,
	IB_UVERBS_WR_ATOMIC_WRITE = 15,
};

enum ib_uverbs_write_cmds {
	IB_USER_VERBS_CMD_GET_CONTEXT = 0,
	IB_USER_VERBS_CMD_QUERY_DEVICE = 1,
	IB_USER_VERBS_CMD_QUERY_PORT = 2,
	IB_USER_VERBS_CMD_ALLOC_PD = 3,
	IB_USER_VERBS_CMD_DEALLOC_PD = 4,
	IB_USER_VERBS_CMD_CREATE_AH = 5,
	IB_USER_VERBS_CMD_MODIFY_AH = 6,
	IB_USER_VERBS_CMD_QUERY_AH = 7,
	IB_USER_VERBS_CMD_DESTROY_AH = 8,
	IB_USER_VERBS_CMD_REG_MR = 9,
	IB_USER_VERBS_CMD_REG_SMR = 10,
	IB_USER_VERBS_CMD_REREG_MR = 11,
	IB_USER_VERBS_CMD_QUERY_MR = 12,
	IB_USER_VERBS_CMD_DEREG_MR = 13,
	IB_USER_VERBS_CMD_ALLOC_MW = 14,
	IB_USER_VERBS_CMD_BIND_MW = 15,
	IB_USER_VERBS_CMD_DEALLOC_MW = 16,
	IB_USER_VERBS_CMD_CREATE_COMP_CHANNEL = 17,
	IB_USER_VERBS_CMD_CREATE_CQ = 18,
	IB_USER_VERBS_CMD_RESIZE_CQ = 19,
	IB_USER_VERBS_CMD_DESTROY_CQ = 20,
	IB_USER_VERBS_CMD_POLL_CQ = 21,
	IB_USER_VERBS_CMD_PEEK_CQ = 22,
	IB_USER_VERBS_CMD_REQ_NOTIFY_CQ = 23,
	IB_USER_VERBS_CMD_CREATE_QP = 24,
	IB_USER_VERBS_CMD_QUERY_QP = 25,
	IB_USER_VERBS_CMD_MODIFY_QP = 26,
	IB_USER_VERBS_CMD_DESTROY_QP = 27,
	IB_USER_VERBS_CMD_POST_SEND = 28,
	IB_USER_VERBS_CMD_POST_RECV = 29,
	IB_USER_VERBS_CMD_ATTACH_MCAST = 30,
	IB_USER_VERBS_CMD_DETACH_MCAST = 31,
	IB_USER_VERBS_CMD_CREATE_SRQ = 32,
	IB_USER_VERBS_CMD_MODIFY_SRQ = 33,
	IB_USER_VERBS_CMD_QUERY_SRQ = 34,
	IB_USER_VERBS_CMD_DESTROY_SRQ = 35,
	IB_USER_VERBS_CMD_POST_SRQ_RECV = 36,
	IB_USER_VERBS_CMD_OPEN_XRCD = 37,
	IB_USER_VERBS_CMD_CLOSE_XRCD = 38,
	IB_USER_VERBS_CMD_CREATE_XSRQ = 39,
	IB_USER_VERBS_CMD_OPEN_QP = 40,
};

enum ibs_states {
	IBS_ENABLED = 0,
	IBS_STARTED = 1,
	IBS_STOPPING = 2,
	IBS_STOPPED = 3,
	IBS_MAX_STATES = 4,
};

enum icl_port_dpll_id {
	ICL_PORT_DPLL_DEFAULT = 0,
	ICL_PORT_DPLL_MG_PHY = 1,
	ICL_PORT_DPLL_COUNT = 2,
};

enum idle_boot_override {
	IDLE_NO_OVERRIDE = 0,
	IDLE_HALT = 1,
	IDLE_NOMWAIT = 2,
	IDLE_POLL = 3,
};

enum ieee80211_ac_numbers {
	IEEE80211_AC_VO = 0,
	IEEE80211_AC_VI = 1,
	IEEE80211_AC_BE = 2,
	IEEE80211_AC_BK = 3,
};

enum ieee80211_agg_stop_reason {
	AGG_STOP_DECLINED = 0,
	AGG_STOP_LOCAL_REQUEST = 1,
	AGG_STOP_PEER_REQUEST = 2,
	AGG_STOP_DESTROY_STA = 3,
};

enum ieee80211_ampdu_mlme_action {
	IEEE80211_AMPDU_RX_START = 0,
	IEEE80211_AMPDU_RX_STOP = 1,
	IEEE80211_AMPDU_TX_START = 2,
	IEEE80211_AMPDU_TX_STOP_CONT = 3,
	IEEE80211_AMPDU_TX_STOP_FLUSH = 4,
	IEEE80211_AMPDU_TX_STOP_FLUSH_CONT = 5,
	IEEE80211_AMPDU_TX_OPERATIONAL = 6,
};

enum ieee80211_ap_reg_power {
	IEEE80211_REG_UNSET_AP = 0,
	IEEE80211_REG_LPI_AP = 1,
	IEEE80211_REG_SP_AP = 2,
	IEEE80211_REG_VLP_AP = 3,
};

enum ieee80211_back_actioncode {
	WLAN_ACTION_ADDBA_REQ = 0,
	WLAN_ACTION_ADDBA_RESP = 1,
	WLAN_ACTION_DELBA = 2,
};

enum ieee80211_back_parties {
	WLAN_BACK_RECIPIENT = 0,
	WLAN_BACK_INITIATOR = 1,
};

enum ieee80211_bss_change {
	BSS_CHANGED_ASSOC = 1ULL,
	BSS_CHANGED_ERP_CTS_PROT = 2ULL,
	BSS_CHANGED_ERP_PREAMBLE = 4ULL,
	BSS_CHANGED_ERP_SLOT = 8ULL,
	BSS_CHANGED_HT = 16ULL,
	BSS_CHANGED_BASIC_RATES = 32ULL,
	BSS_CHANGED_BEACON_INT = 64ULL,
	BSS_CHANGED_BSSID = 128ULL,
	BSS_CHANGED_BEACON = 256ULL,
	BSS_CHANGED_BEACON_ENABLED = 512ULL,
	BSS_CHANGED_CQM = 1024ULL,
	BSS_CHANGED_IBSS = 2048ULL,
	BSS_CHANGED_ARP_FILTER = 4096ULL,
	BSS_CHANGED_QOS = 8192ULL,
	BSS_CHANGED_IDLE = 16384ULL,
	BSS_CHANGED_SSID = 32768ULL,
	BSS_CHANGED_AP_PROBE_RESP = 65536ULL,
	BSS_CHANGED_PS = 131072ULL,
	BSS_CHANGED_TXPOWER = 262144ULL,
	BSS_CHANGED_P2P_PS = 524288ULL,
	BSS_CHANGED_BEACON_INFO = 1048576ULL,
	BSS_CHANGED_BANDWIDTH = 2097152ULL,
	BSS_CHANGED_OCB = 4194304ULL,
	BSS_CHANGED_MU_GROUPS = 8388608ULL,
	BSS_CHANGED_KEEP_ALIVE = 16777216ULL,
	BSS_CHANGED_MCAST_RATE = 33554432ULL,
	BSS_CHANGED_FTM_RESPONDER = 67108864ULL,
	BSS_CHANGED_TWT = 134217728ULL,
	BSS_CHANGED_HE_OBSS_PD = 268435456ULL,
	BSS_CHANGED_HE_BSS_COLOR = 536870912ULL,
	BSS_CHANGED_FILS_DISCOVERY = 1073741824ULL,
	BSS_CHANGED_UNSOL_BCAST_PROBE_RESP = 2147483648ULL,
	BSS_CHANGED_MLD_VALID_LINKS = 8589934592ULL,
	BSS_CHANGED_MLD_TTLM = 17179869184ULL,
	BSS_CHANGED_TPE = 34359738368ULL,
};

enum ieee80211_bss_corrupt_data_flags {
	IEEE80211_BSS_CORRUPT_BEACON = 1,
	IEEE80211_BSS_CORRUPT_PROBE_RESP = 2,
};

enum ieee80211_bss_type {
	IEEE80211_BSS_TYPE_ESS = 0,
	IEEE80211_BSS_TYPE_PBSS = 1,
	IEEE80211_BSS_TYPE_IBSS = 2,
	IEEE80211_BSS_TYPE_MBSS = 3,
	IEEE80211_BSS_TYPE_ANY = 4,
};

enum ieee80211_bss_valid_data_flags {
	IEEE80211_BSS_VALID_WMM = 2,
	IEEE80211_BSS_VALID_RATES = 4,
	IEEE80211_BSS_VALID_ERP = 8,
};

enum ieee80211_category {
	WLAN_CATEGORY_SPECTRUM_MGMT = 0,
	WLAN_CATEGORY_QOS = 1,
	WLAN_CATEGORY_DLS = 2,
	WLAN_CATEGORY_BACK = 3,
	WLAN_CATEGORY_PUBLIC = 4,
	WLAN_CATEGORY_RADIO_MEASUREMENT = 5,
	WLAN_CATEGORY_FAST_BBS_TRANSITION = 6,
	WLAN_CATEGORY_HT = 7,
	WLAN_CATEGORY_SA_QUERY = 8,
	WLAN_CATEGORY_PROTECTED_DUAL_OF_ACTION = 9,
	WLAN_CATEGORY_WNM = 10,
	WLAN_CATEGORY_WNM_UNPROTECTED = 11,
	WLAN_CATEGORY_TDLS = 12,
	WLAN_CATEGORY_MESH_ACTION = 13,
	WLAN_CATEGORY_MULTIHOP_ACTION = 14,
	WLAN_CATEGORY_SELF_PROTECTED = 15,
	WLAN_CATEGORY_DMG = 16,
	WLAN_CATEGORY_WMM = 17,
	WLAN_CATEGORY_FST = 18,
	WLAN_CATEGORY_UNPROT_DMG = 20,
	WLAN_CATEGORY_VHT = 21,
	WLAN_CATEGORY_S1G = 22,
	WLAN_CATEGORY_PROTECTED_EHT = 37,
	WLAN_CATEGORY_VENDOR_SPECIFIC_PROTECTED = 126,
	WLAN_CATEGORY_VENDOR_SPECIFIC = 127,
};

enum ieee80211_chanctx_change {
	IEEE80211_CHANCTX_CHANGE_WIDTH = 1,
	IEEE80211_CHANCTX_CHANGE_RX_CHAINS = 2,
	IEEE80211_CHANCTX_CHANGE_RADAR = 4,
	IEEE80211_CHANCTX_CHANGE_CHANNEL = 8,
	IEEE80211_CHANCTX_CHANGE_MIN_DEF = 16,
	IEEE80211_CHANCTX_CHANGE_AP = 32,
	IEEE80211_CHANCTX_CHANGE_PUNCTURING = 64,
};

enum ieee80211_chanctx_mode {
	IEEE80211_CHANCTX_SHARED = 0,
	IEEE80211_CHANCTX_EXCLUSIVE = 1,
};

enum ieee80211_chanctx_replace_state {
	IEEE80211_CHANCTX_REPLACE_NONE = 0,
	IEEE80211_CHANCTX_WILL_BE_REPLACED = 1,
	IEEE80211_CHANCTX_REPLACES_OTHER = 2,
};

enum ieee80211_chanctx_switch_mode {
	CHANCTX_SWMODE_REASSIGN_VIF = 0,
	CHANCTX_SWMODE_SWAP_CONTEXTS = 1,
};

enum ieee80211_channel_flags {
	IEEE80211_CHAN_DISABLED = 1,
	IEEE80211_CHAN_NO_IR = 2,
	IEEE80211_CHAN_PSD = 4,
	IEEE80211_CHAN_RADAR = 8,
	IEEE80211_CHAN_NO_HT40PLUS = 16,
	IEEE80211_CHAN_NO_HT40MINUS = 32,
	IEEE80211_CHAN_NO_OFDM = 64,
	IEEE80211_CHAN_NO_80MHZ = 128,
	IEEE80211_CHAN_NO_160MHZ = 256,
	IEEE80211_CHAN_INDOOR_ONLY = 512,
	IEEE80211_CHAN_IR_CONCURRENT = 1024,
	IEEE80211_CHAN_NO_20MHZ = 2048,
	IEEE80211_CHAN_NO_10MHZ = 4096,
	IEEE80211_CHAN_NO_HE = 8192,
	IEEE80211_CHAN_1MHZ = 16384,
	IEEE80211_CHAN_2MHZ = 32768,
	IEEE80211_CHAN_4MHZ = 65536,
	IEEE80211_CHAN_8MHZ = 131072,
	IEEE80211_CHAN_16MHZ = 262144,
	IEEE80211_CHAN_NO_320MHZ = 524288,
	IEEE80211_CHAN_NO_EHT = 1048576,
	IEEE80211_CHAN_DFS_CONCURRENT = 2097152,
	IEEE80211_CHAN_NO_6GHZ_VLP_CLIENT = 4194304,
	IEEE80211_CHAN_NO_6GHZ_AFC_CLIENT = 8388608,
	IEEE80211_CHAN_CAN_MONITOR = 16777216,
	IEEE80211_CHAN_ALLOW_6GHZ_VLP_AP = 33554432,
};

enum ieee80211_conf_changed {
	IEEE80211_CONF_CHANGE_SMPS = 2,
	IEEE80211_CONF_CHANGE_LISTEN_INTERVAL = 4,
	IEEE80211_CONF_CHANGE_MONITOR = 8,
	IEEE80211_CONF_CHANGE_PS = 16,
	IEEE80211_CONF_CHANGE_POWER = 32,
	IEEE80211_CONF_CHANGE_CHANNEL = 64,
	IEEE80211_CONF_CHANGE_RETRY_LIMITS = 128,
	IEEE80211_CONF_CHANGE_IDLE = 256,
};

enum ieee80211_conf_flags {
	IEEE80211_CONF_MONITOR = 1,
	IEEE80211_CONF_PS = 2,
	IEEE80211_CONF_IDLE = 4,
	IEEE80211_CONF_OFFCHANNEL = 8,
};

enum ieee80211_conn_bw_limit {
	IEEE80211_CONN_BW_LIMIT_20 = 0,
	IEEE80211_CONN_BW_LIMIT_40 = 1,
	IEEE80211_CONN_BW_LIMIT_80 = 2,
	IEEE80211_CONN_BW_LIMIT_160 = 3,
	IEEE80211_CONN_BW_LIMIT_320 = 4,
};

enum ieee80211_conn_mode {
	IEEE80211_CONN_MODE_S1G = 0,
	IEEE80211_CONN_MODE_LEGACY = 1,
	IEEE80211_CONN_MODE_HT = 2,
	IEEE80211_CONN_MODE_VHT = 3,
	IEEE80211_CONN_MODE_HE = 4,
	IEEE80211_CONN_MODE_EHT = 5,
};

enum ieee80211_csa_source {
	IEEE80211_CSA_SOURCE_BEACON = 0,
	IEEE80211_CSA_SOURCE_OTHER_LINK = 1,
	IEEE80211_CSA_SOURCE_PROT_ACTION = 2,
	IEEE80211_CSA_SOURCE_UNPROT_ACTION = 3,
};

enum ieee80211_edmg_bw_config {
	IEEE80211_EDMG_BW_CONFIG_4 = 4,
	IEEE80211_EDMG_BW_CONFIG_5 = 5,
	IEEE80211_EDMG_BW_CONFIG_6 = 6,
	IEEE80211_EDMG_BW_CONFIG_7 = 7,
	IEEE80211_EDMG_BW_CONFIG_8 = 8,
	IEEE80211_EDMG_BW_CONFIG_9 = 9,
	IEEE80211_EDMG_BW_CONFIG_10 = 10,
	IEEE80211_EDMG_BW_CONFIG_11 = 11,
	IEEE80211_EDMG_BW_CONFIG_12 = 12,
	IEEE80211_EDMG_BW_CONFIG_13 = 13,
	IEEE80211_EDMG_BW_CONFIG_14 = 14,
	IEEE80211_EDMG_BW_CONFIG_15 = 15,
};

enum ieee80211_eid {
	WLAN_EID_SSID = 0,
	WLAN_EID_SUPP_RATES = 1,
	WLAN_EID_FH_PARAMS = 2,
	WLAN_EID_DS_PARAMS = 3,
	WLAN_EID_CF_PARAMS = 4,
	WLAN_EID_TIM = 5,
	WLAN_EID_IBSS_PARAMS = 6,
	WLAN_EID_COUNTRY = 7,
	WLAN_EID_REQUEST = 10,
	WLAN_EID_QBSS_LOAD = 11,
	WLAN_EID_EDCA_PARAM_SET = 12,
	WLAN_EID_TSPEC = 13,
	WLAN_EID_TCLAS = 14,
	WLAN_EID_SCHEDULE = 15,
	WLAN_EID_CHALLENGE = 16,
	WLAN_EID_PWR_CONSTRAINT = 32,
	WLAN_EID_PWR_CAPABILITY = 33,
	WLAN_EID_TPC_REQUEST = 34,
	WLAN_EID_TPC_REPORT = 35,
	WLAN_EID_SUPPORTED_CHANNELS = 36,
	WLAN_EID_CHANNEL_SWITCH = 37,
	WLAN_EID_MEASURE_REQUEST = 38,
	WLAN_EID_MEASURE_REPORT = 39,
	WLAN_EID_QUIET = 40,
	WLAN_EID_IBSS_DFS = 41,
	WLAN_EID_ERP_INFO = 42,
	WLAN_EID_TS_DELAY = 43,
	WLAN_EID_TCLAS_PROCESSING = 44,
	WLAN_EID_HT_CAPABILITY = 45,
	WLAN_EID_QOS_CAPA = 46,
	WLAN_EID_RSN = 48,
	WLAN_EID_802_15_COEX = 49,
	WLAN_EID_EXT_SUPP_RATES = 50,
	WLAN_EID_AP_CHAN_REPORT = 51,
	WLAN_EID_NEIGHBOR_REPORT = 52,
	WLAN_EID_RCPI = 53,
	WLAN_EID_MOBILITY_DOMAIN = 54,
	WLAN_EID_FAST_BSS_TRANSITION = 55,
	WLAN_EID_TIMEOUT_INTERVAL = 56,
	WLAN_EID_RIC_DATA = 57,
	WLAN_EID_DSE_REGISTERED_LOCATION = 58,
	WLAN_EID_SUPPORTED_REGULATORY_CLASSES = 59,
	WLAN_EID_EXT_CHANSWITCH_ANN = 60,
	WLAN_EID_HT_OPERATION = 61,
	WLAN_EID_SECONDARY_CHANNEL_OFFSET = 62,
	WLAN_EID_BSS_AVG_ACCESS_DELAY = 63,
	WLAN_EID_ANTENNA_INFO = 64,
	WLAN_EID_RSNI = 65,
	WLAN_EID_MEASUREMENT_PILOT_TX_INFO = 66,
	WLAN_EID_BSS_AVAILABLE_CAPACITY = 67,
	WLAN_EID_BSS_AC_ACCESS_DELAY = 68,
	WLAN_EID_TIME_ADVERTISEMENT = 69,
	WLAN_EID_RRM_ENABLED_CAPABILITIES = 70,
	WLAN_EID_MULTIPLE_BSSID = 71,
	WLAN_EID_BSS_COEX_2040 = 72,
	WLAN_EID_BSS_INTOLERANT_CHL_REPORT = 73,
	WLAN_EID_OVERLAP_BSS_SCAN_PARAM = 74,
	WLAN_EID_RIC_DESCRIPTOR = 75,
	WLAN_EID_MMIE = 76,
	WLAN_EID_ASSOC_COMEBACK_TIME = 77,
	WLAN_EID_EVENT_REQUEST = 78,
	WLAN_EID_EVENT_REPORT = 79,
	WLAN_EID_DIAGNOSTIC_REQUEST = 80,
	WLAN_EID_DIAGNOSTIC_REPORT = 81,
	WLAN_EID_LOCATION_PARAMS = 82,
	WLAN_EID_NON_TX_BSSID_CAP = 83,
	WLAN_EID_SSID_LIST = 84,
	WLAN_EID_MULTI_BSSID_IDX = 85,
	WLAN_EID_FMS_DESCRIPTOR = 86,
	WLAN_EID_FMS_REQUEST = 87,
	WLAN_EID_FMS_RESPONSE = 88,
	WLAN_EID_QOS_TRAFFIC_CAPA = 89,
	WLAN_EID_BSS_MAX_IDLE_PERIOD = 90,
	WLAN_EID_TSF_REQUEST = 91,
	WLAN_EID_TSF_RESPOSNE = 92,
	WLAN_EID_WNM_SLEEP_MODE = 93,
	WLAN_EID_TIM_BCAST_REQ = 94,
	WLAN_EID_TIM_BCAST_RESP = 95,
	WLAN_EID_COLL_IF_REPORT = 96,
	WLAN_EID_CHANNEL_USAGE = 97,
	WLAN_EID_TIME_ZONE = 98,
	WLAN_EID_DMS_REQUEST = 99,
	WLAN_EID_DMS_RESPONSE = 100,
	WLAN_EID_LINK_ID = 101,
	WLAN_EID_WAKEUP_SCHEDUL = 102,
	WLAN_EID_CHAN_SWITCH_TIMING = 104,
	WLAN_EID_PTI_CONTROL = 105,
	WLAN_EID_PU_BUFFER_STATUS = 106,
	WLAN_EID_INTERWORKING = 107,
	WLAN_EID_ADVERTISEMENT_PROTOCOL = 108,
	WLAN_EID_EXPEDITED_BW_REQ = 109,
	WLAN_EID_QOS_MAP_SET = 110,
	WLAN_EID_ROAMING_CONSORTIUM = 111,
	WLAN_EID_EMERGENCY_ALERT = 112,
	WLAN_EID_MESH_CONFIG = 113,
	WLAN_EID_MESH_ID = 114,
	WLAN_EID_LINK_METRIC_REPORT = 115,
	WLAN_EID_CONGESTION_NOTIFICATION = 116,
	WLAN_EID_PEER_MGMT = 117,
	WLAN_EID_CHAN_SWITCH_PARAM = 118,
	WLAN_EID_MESH_AWAKE_WINDOW = 119,
	WLAN_EID_BEACON_TIMING = 120,
	WLAN_EID_MCCAOP_SETUP_REQ = 121,
	WLAN_EID_MCCAOP_SETUP_RESP = 122,
	WLAN_EID_MCCAOP_ADVERT = 123,
	WLAN_EID_MCCAOP_TEARDOWN = 124,
	WLAN_EID_GANN = 125,
	WLAN_EID_RANN = 126,
	WLAN_EID_EXT_CAPABILITY = 127,
	WLAN_EID_PREQ = 130,
	WLAN_EID_PREP = 131,
	WLAN_EID_PERR = 132,
	WLAN_EID_PXU = 137,
	WLAN_EID_PXUC = 138,
	WLAN_EID_AUTH_MESH_PEER_EXCH = 139,
	WLAN_EID_MIC = 140,
	WLAN_EID_DESTINATION_URI = 141,
	WLAN_EID_UAPSD_COEX = 142,
	WLAN_EID_WAKEUP_SCHEDULE = 143,
	WLAN_EID_EXT_SCHEDULE = 144,
	WLAN_EID_STA_AVAILABILITY = 145,
	WLAN_EID_DMG_TSPEC = 146,
	WLAN_EID_DMG_AT = 147,
	WLAN_EID_DMG_CAP = 148,
	WLAN_EID_CISCO_VENDOR_SPECIFIC = 150,
	WLAN_EID_DMG_OPERATION = 151,
	WLAN_EID_DMG_BSS_PARAM_CHANGE = 152,
	WLAN_EID_DMG_BEAM_REFINEMENT = 153,
	WLAN_EID_CHANNEL_MEASURE_FEEDBACK = 154,
	WLAN_EID_AWAKE_WINDOW = 157,
	WLAN_EID_MULTI_BAND = 158,
	WLAN_EID_ADDBA_EXT = 159,
	WLAN_EID_NEXT_PCP_LIST = 160,
	WLAN_EID_PCP_HANDOVER = 161,
	WLAN_EID_DMG_LINK_MARGIN = 162,
	WLAN_EID_SWITCHING_STREAM = 163,
	WLAN_EID_SESSION_TRANSITION = 164,
	WLAN_EID_DYN_TONE_PAIRING_REPORT = 165,
	WLAN_EID_CLUSTER_REPORT = 166,
	WLAN_EID_RELAY_CAP = 167,
	WLAN_EID_RELAY_XFER_PARAM_SET = 168,
	WLAN_EID_BEAM_LINK_MAINT = 169,
	WLAN_EID_MULTIPLE_MAC_ADDR = 170,
	WLAN_EID_U_PID = 171,
	WLAN_EID_DMG_LINK_ADAPT_ACK = 172,
	WLAN_EID_MCCAOP_ADV_OVERVIEW = 174,
	WLAN_EID_QUIET_PERIOD_REQ = 175,
	WLAN_EID_QUIET_PERIOD_RESP = 177,
	WLAN_EID_EPAC_POLICY = 182,
	WLAN_EID_CLISTER_TIME_OFF = 183,
	WLAN_EID_INTER_AC_PRIO = 184,
	WLAN_EID_SCS_DESCRIPTOR = 185,
	WLAN_EID_QLOAD_REPORT = 186,
	WLAN_EID_HCCA_TXOP_UPDATE_COUNT = 187,
	WLAN_EID_HL_STREAM_ID = 188,
	WLAN_EID_GCR_GROUP_ADDR = 189,
	WLAN_EID_ANTENNA_SECTOR_ID_PATTERN = 190,
	WLAN_EID_VHT_CAPABILITY = 191,
	WLAN_EID_VHT_OPERATION = 192,
	WLAN_EID_EXTENDED_BSS_LOAD = 193,
	WLAN_EID_WIDE_BW_CHANNEL_SWITCH = 194,
	WLAN_EID_TX_POWER_ENVELOPE = 195,
	WLAN_EID_CHANNEL_SWITCH_WRAPPER = 196,
	WLAN_EID_AID = 197,
	WLAN_EID_QUIET_CHANNEL = 198,
	WLAN_EID_OPMODE_NOTIF = 199,
	WLAN_EID_REDUCED_NEIGHBOR_REPORT = 201,
	WLAN_EID_AID_REQUEST = 210,
	WLAN_EID_AID_RESPONSE = 211,
	WLAN_EID_S1G_BCN_COMPAT = 213,
	WLAN_EID_S1G_SHORT_BCN_INTERVAL = 214,
	WLAN_EID_S1G_TWT = 216,
	WLAN_EID_S1G_CAPABILITIES = 217,
	WLAN_EID_VENDOR_SPECIFIC = 221,
	WLAN_EID_QOS_PARAMETER = 222,
	WLAN_EID_S1G_OPERATION = 232,
	WLAN_EID_CAG_NUMBER = 237,
	WLAN_EID_AP_CSN = 239,
	WLAN_EID_FILS_INDICATION = 240,
	WLAN_EID_DILS = 241,
	WLAN_EID_FRAGMENT = 242,
	WLAN_EID_RSNX = 244,
	WLAN_EID_EXTENSION = 255,
};

enum ieee80211_eid_ext {
	WLAN_EID_EXT_ASSOC_DELAY_INFO = 1,
	WLAN_EID_EXT_FILS_REQ_PARAMS = 2,
	WLAN_EID_EXT_FILS_KEY_CONFIRM = 3,
	WLAN_EID_EXT_FILS_SESSION = 4,
	WLAN_EID_EXT_FILS_HLP_CONTAINER = 5,
	WLAN_EID_EXT_FILS_IP_ADDR_ASSIGN = 6,
	WLAN_EID_EXT_KEY_DELIVERY = 7,
	WLAN_EID_EXT_FILS_WRAPPED_DATA = 8,
	WLAN_EID_EXT_FILS_PUBLIC_KEY = 12,
	WLAN_EID_EXT_FILS_NONCE = 13,
	WLAN_EID_EXT_FUTURE_CHAN_GUIDANCE = 14,
	WLAN_EID_EXT_HE_CAPABILITY = 35,
	WLAN_EID_EXT_HE_OPERATION = 36,
	WLAN_EID_EXT_UORA = 37,
	WLAN_EID_EXT_HE_MU_EDCA = 38,
	WLAN_EID_EXT_HE_SPR = 39,
	WLAN_EID_EXT_NDP_FEEDBACK_REPORT_PARAMSET = 41,
	WLAN_EID_EXT_BSS_COLOR_CHG_ANN = 42,
	WLAN_EID_EXT_QUIET_TIME_PERIOD_SETUP = 43,
	WLAN_EID_EXT_ESS_REPORT = 45,
	WLAN_EID_EXT_OPS = 46,
	WLAN_EID_EXT_HE_BSS_LOAD = 47,
	WLAN_EID_EXT_MAX_CHANNEL_SWITCH_TIME = 52,
	WLAN_EID_EXT_MULTIPLE_BSSID_CONFIGURATION = 55,
	WLAN_EID_EXT_NON_INHERITANCE = 56,
	WLAN_EID_EXT_KNOWN_BSSID = 57,
	WLAN_EID_EXT_SHORT_SSID_LIST = 58,
	WLAN_EID_EXT_HE_6GHZ_CAPA = 59,
	WLAN_EID_EXT_UL_MU_POWER_CAPA = 60,
	WLAN_EID_EXT_EHT_OPERATION = 106,
	WLAN_EID_EXT_EHT_MULTI_LINK = 107,
	WLAN_EID_EXT_EHT_CAPABILITY = 108,
	WLAN_EID_EXT_TID_TO_LINK_MAPPING = 109,
	WLAN_EID_EXT_BANDWIDTH_INDICATION = 135,
};

enum ieee80211_elems_parse_error {
	IEEE80211_PARSE_ERR_INVALID_END = 1,
	IEEE80211_PARSE_ERR_DUP_ELEM = 2,
	IEEE80211_PARSE_ERR_BAD_ELEM_SIZE = 4,
	IEEE80211_PARSE_ERR_UNEXPECTED_ELEM = 8,
	IEEE80211_PARSE_ERR_DUP_NEST_ML_BASIC = 16,
};

enum ieee80211_encrypt {
	ENCRYPT_NO = 0,
	ENCRYPT_MGMT = 1,
	ENCRYPT_DATA = 2,
};

enum ieee80211_event_type {
	RSSI_EVENT = 0,
	MLME_EVENT = 1,
	BAR_RX_EVENT = 2,
	BA_FRAME_TIMEOUT = 3,
};

enum ieee80211_filter_flags {
	FIF_ALLMULTI = 2,
	FIF_FCSFAIL = 4,
	FIF_PLCPFAIL = 8,
	FIF_BCN_PRBRESP_PROMISC = 16,
	FIF_CONTROL = 32,
	FIF_OTHER_BSS = 64,
	FIF_PSPOLL = 128,
	FIF_PROBE_REQ = 256,
	FIF_MCAST_ACTION = 512,
};

enum ieee80211_frame_release_type {
	IEEE80211_FRAME_RELEASE_PSPOLL = 0,
	IEEE80211_FRAME_RELEASE_UAPSD = 1,
};

enum ieee80211_he_mcs_support {
	IEEE80211_HE_MCS_SUPPORT_0_7 = 0,
	IEEE80211_HE_MCS_SUPPORT_0_9 = 1,
	IEEE80211_HE_MCS_SUPPORT_0_11 = 2,
	IEEE80211_HE_MCS_NOT_SUPPORTED = 3,
};

enum ieee80211_ht_actioncode {
	WLAN_HT_ACTION_NOTIFY_CHANWIDTH = 0,
	WLAN_HT_ACTION_SMPS = 1,
	WLAN_HT_ACTION_PSMP = 2,
	WLAN_HT_ACTION_PCO_PHASE = 3,
	WLAN_HT_ACTION_CSI = 4,
	WLAN_HT_ACTION_NONCOMPRESSED_BF = 5,
	WLAN_HT_ACTION_COMPRESSED_BF = 6,
	WLAN_HT_ACTION_ASEL_IDX_FEEDBACK = 7,
};

enum ieee80211_ht_chanwidth_values {
	IEEE80211_HT_CHANWIDTH_20MHZ = 0,
	IEEE80211_HT_CHANWIDTH_ANY = 1,
};

enum ieee80211_hw_flags {
	IEEE80211_HW_HAS_RATE_CONTROL = 0,
	IEEE80211_HW_RX_INCLUDES_FCS = 1,
	IEEE80211_HW_HOST_BROADCAST_PS_BUFFERING = 2,
	IEEE80211_HW_SIGNAL_UNSPEC = 3,
	IEEE80211_HW_SIGNAL_DBM = 4,
	IEEE80211_HW_NEED_DTIM_BEFORE_ASSOC = 5,
	IEEE80211_HW_SPECTRUM_MGMT = 6,
	IEEE80211_HW_AMPDU_AGGREGATION = 7,
	IEEE80211_HW_SUPPORTS_PS = 8,
	IEEE80211_HW_PS_NULLFUNC_STACK = 9,
	IEEE80211_HW_SUPPORTS_DYNAMIC_PS = 10,
	IEEE80211_HW_MFP_CAPABLE = 11,
	IEEE80211_HW_WANT_MONITOR_VIF = 12,
	IEEE80211_HW_NO_VIRTUAL_MONITOR = 13,
	IEEE80211_HW_NO_AUTO_VIF = 14,
	IEEE80211_HW_SW_CRYPTO_CONTROL = 15,
	IEEE80211_HW_SUPPORT_FAST_XMIT = 16,
	IEEE80211_HW_REPORTS_TX_ACK_STATUS = 17,
	IEEE80211_HW_CONNECTION_MONITOR = 18,
	IEEE80211_HW_QUEUE_CONTROL = 19,
	IEEE80211_HW_SUPPORTS_PER_STA_GTK = 20,
	IEEE80211_HW_AP_LINK_PS = 21,
	IEEE80211_HW_TX_AMPDU_SETUP_IN_HW = 22,
	IEEE80211_HW_SUPPORTS_RC_TABLE = 23,
	IEEE80211_HW_P2P_DEV_ADDR_FOR_INTF = 24,
	IEEE80211_HW_TIMING_BEACON_ONLY = 25,
	IEEE80211_HW_SUPPORTS_HT_CCK_RATES = 26,
	IEEE80211_HW_CHANCTX_STA_CSA = 27,
	IEEE80211_HW_SUPPORTS_CLONED_SKBS = 28,
	IEEE80211_HW_SINGLE_SCAN_ON_ALL_BANDS = 29,
	IEEE80211_HW_TDLS_WIDER_BW = 30,
	IEEE80211_HW_SUPPORTS_AMSDU_IN_AMPDU = 31,
	IEEE80211_HW_BEACON_TX_STATUS = 32,
	IEEE80211_HW_NEEDS_UNIQUE_STA_ADDR = 33,
	IEEE80211_HW_SUPPORTS_REORDERING_BUFFER = 34,
	IEEE80211_HW_USES_RSS = 35,
	IEEE80211_HW_TX_AMSDU = 36,
	IEEE80211_HW_TX_FRAG_LIST = 37,
	IEEE80211_HW_REPORTS_LOW_ACK = 38,
	IEEE80211_HW_SUPPORTS_TX_FRAG = 39,
	IEEE80211_HW_SUPPORTS_TDLS_BUFFER_STA = 40,
	IEEE80211_HW_DOESNT_SUPPORT_QOS_NDP = 41,
	IEEE80211_HW_BUFF_MMPDU_TXQ = 42,
	IEEE80211_HW_SUPPORTS_VHT_EXT_NSS_BW = 43,
	IEEE80211_HW_STA_MMPDU_TXQ = 44,
	IEEE80211_HW_TX_STATUS_NO_AMPDU_LEN = 45,
	IEEE80211_HW_SUPPORTS_MULTI_BSSID = 46,
	IEEE80211_HW_SUPPORTS_ONLY_HE_MULTI_BSSID = 47,
	IEEE80211_HW_AMPDU_KEYBORDER_SUPPORT = 48,
	IEEE80211_HW_SUPPORTS_TX_ENCAP_OFFLOAD = 49,
	IEEE80211_HW_SUPPORTS_RX_DECAP_OFFLOAD = 50,
	IEEE80211_HW_SUPPORTS_CONC_MON_RX_DECAP = 51,
	IEEE80211_HW_DETECTS_COLOR_COLLISION = 52,
	IEEE80211_HW_MLO_MCAST_MULTI_LINK_TX = 53,
	IEEE80211_HW_DISALLOW_PUNCTURING = 54,
	IEEE80211_HW_DISALLOW_PUNCTURING_5GHZ = 55,
	IEEE80211_HW_HANDLES_QUIET_CSA = 56,
	NUM_IEEE80211_HW_FLAGS = 57,
};

enum ieee80211_idle_options {
	WLAN_IDLE_OPTIONS_PROTECTED_KEEP_ALIVE = 1,
};

enum ieee80211_interface_iteration_flags {
	IEEE80211_IFACE_ITER_NORMAL = 0,
	IEEE80211_IFACE_ITER_RESUME_ALL = 1,
	IEEE80211_IFACE_ITER_ACTIVE = 2,
	IEEE80211_IFACE_SKIP_SDATA_NOT_IN_DRIVER = 4,
};

enum ieee80211_internal_key_flags {
	KEY_FLAG_UPLOADED_TO_HARDWARE = 1,
	KEY_FLAG_TAINTED = 2,
};

enum ieee80211_internal_tkip_state {
	TKIP_STATE_NOT_INIT = 0,
	TKIP_STATE_PHASE1_DONE = 1,
	TKIP_STATE_PHASE1_HW_UPLOADED = 2,
};

enum ieee80211_key_flags {
	IEEE80211_KEY_FLAG_GENERATE_IV_MGMT = 1,
	IEEE80211_KEY_FLAG_GENERATE_IV = 2,
	IEEE80211_KEY_FLAG_GENERATE_MMIC = 4,
	IEEE80211_KEY_FLAG_PAIRWISE = 8,
	IEEE80211_KEY_FLAG_SW_MGMT_TX = 16,
	IEEE80211_KEY_FLAG_PUT_IV_SPACE = 32,
	IEEE80211_KEY_FLAG_RX_MGMT = 64,
	IEEE80211_KEY_FLAG_RESERVE_TAILROOM = 128,
	IEEE80211_KEY_FLAG_PUT_MIC_SPACE = 256,
	IEEE80211_KEY_FLAG_NO_AUTO_TX = 512,
	IEEE80211_KEY_FLAG_GENERATE_MMIE = 1024,
	IEEE80211_KEY_FLAG_SPP_AMSDU = 2048,
};

enum ieee80211_key_len {
	WLAN_KEY_LEN_WEP40 = 5,
	WLAN_KEY_LEN_WEP104 = 13,
	WLAN_KEY_LEN_CCMP = 16,
	WLAN_KEY_LEN_CCMP_256 = 32,
	WLAN_KEY_LEN_TKIP = 32,
	WLAN_KEY_LEN_AES_CMAC = 16,
	WLAN_KEY_LEN_SMS4 = 32,
	WLAN_KEY_LEN_GCMP = 16,
	WLAN_KEY_LEN_GCMP_256 = 32,
	WLAN_KEY_LEN_BIP_CMAC_256 = 32,
	WLAN_KEY_LEN_BIP_GMAC_128 = 16,
	WLAN_KEY_LEN_BIP_GMAC_256 = 32,
};

enum ieee80211_max_queues {
	IEEE80211_MAX_QUEUES = 16,
	IEEE80211_MAX_QUEUE_MAP = 65535,
};

enum ieee80211_mesh_path_metric {
	IEEE80211_PATH_METRIC_AIRTIME = 1,
	IEEE80211_PATH_METRIC_VENDOR = 255,
};

enum ieee80211_mesh_path_protocol {
	IEEE80211_PATH_PROTOCOL_HWMP = 1,
	IEEE80211_PATH_PROTOCOL_VENDOR = 255,
};

enum ieee80211_mesh_sync_method {
	IEEE80211_SYNC_METHOD_NEIGHBOR_OFFSET = 1,
	IEEE80211_SYNC_METHOD_VENDOR = 255,
};

enum ieee80211_mle_subelems {
	IEEE80211_MLE_SUBELEM_PER_STA_PROFILE = 0,
	IEEE80211_MLE_SUBELEM_FRAGMENT = 254,
};

enum ieee80211_mlme_event_data {
	AUTH_EVENT = 0,
	ASSOC_EVENT = 1,
	DEAUTH_RX_EVENT = 2,
	DEAUTH_TX_EVENT = 3,
};

enum ieee80211_mlme_event_status {
	MLME_SUCCESS = 0,
	MLME_DENIED = 1,
	MLME_TIMEOUT = 2,
};

enum ieee80211_neg_ttlm_res {
	NEG_TTLM_RES_ACCEPT = 0,
	NEG_TTLM_RES_REJECT = 1,
	NEG_TTLM_RES_SUGGEST_PREFERRED = 2,
};

enum ieee80211_offload_flags {
	IEEE80211_OFFLOAD_ENCAP_ENABLED = 1,
	IEEE80211_OFFLOAD_ENCAP_4ADDR = 2,
	IEEE80211_OFFLOAD_DECAP_ENABLED = 4,
};

enum ieee80211_p2p_attr_id {
	IEEE80211_P2P_ATTR_STATUS = 0,
	IEEE80211_P2P_ATTR_MINOR_REASON = 1,
	IEEE80211_P2P_ATTR_CAPABILITY = 2,
	IEEE80211_P2P_ATTR_DEVICE_ID = 3,
	IEEE80211_P2P_ATTR_GO_INTENT = 4,
	IEEE80211_P2P_ATTR_GO_CONFIG_TIMEOUT = 5,
	IEEE80211_P2P_ATTR_LISTEN_CHANNEL = 6,
	IEEE80211_P2P_ATTR_GROUP_BSSID = 7,
	IEEE80211_P2P_ATTR_EXT_LISTEN_TIMING = 8,
	IEEE80211_P2P_ATTR_INTENDED_IFACE_ADDR = 9,
	IEEE80211_P2P_ATTR_MANAGABILITY = 10,
	IEEE80211_P2P_ATTR_CHANNEL_LIST = 11,
	IEEE80211_P2P_ATTR_ABSENCE_NOTICE = 12,
	IEEE80211_P2P_ATTR_DEVICE_INFO = 13,
	IEEE80211_P2P_ATTR_GROUP_INFO = 14,
	IEEE80211_P2P_ATTR_GROUP_ID = 15,
	IEEE80211_P2P_ATTR_INTERFACE = 16,
	IEEE80211_P2P_ATTR_OPER_CHANNEL = 17,
	IEEE80211_P2P_ATTR_INVITE_FLAGS = 18,
	IEEE80211_P2P_ATTR_VENDOR_SPECIFIC = 221,
	IEEE80211_P2P_ATTR_MAX = 222,
};

enum ieee80211_packet_rx_flags {
	IEEE80211_RX_AMSDU = 8,
	IEEE80211_RX_MALFORMED_ACTION_FRM = 16,
	IEEE80211_RX_DEFERRED_RELEASE = 32,
};

enum ieee80211_privacy {
	IEEE80211_PRIVACY_ON = 0,
	IEEE80211_PRIVACY_OFF = 1,
	IEEE80211_PRIVACY_ANY = 2,
};

enum ieee80211_protected_eht_actioncode {
	WLAN_PROTECTED_EHT_ACTION_TTLM_REQ = 0,
	WLAN_PROTECTED_EHT_ACTION_TTLM_RES = 1,
	WLAN_PROTECTED_EHT_ACTION_TTLM_TEARDOWN = 2,
	WLAN_PROTECTED_EHT_ACTION_EPCS_ENABLE_REQ = 3,
	WLAN_PROTECTED_EHT_ACTION_EPCS_ENABLE_RESP = 4,
	WLAN_PROTECTED_EHT_ACTION_EPCS_ENABLE_TEARDOWN = 5,
	WLAN_PROTECTED_EHT_ACTION_EML_OP_MODE_NOTIF = 6,
	WLAN_PROTECTED_EHT_ACTION_LINK_RECOMMEND = 7,
	WLAN_PROTECTED_EHT_ACTION_ML_OP_UPDATE_REQ = 8,
	WLAN_PROTECTED_EHT_ACTION_ML_OP_UPDATE_RESP = 9,
	WLAN_PROTECTED_EHT_ACTION_LINK_RECONFIG_NOTIF = 10,
	WLAN_PROTECTED_EHT_ACTION_LINK_RECONFIG_REQ = 11,
	WLAN_PROTECTED_EHT_ACTION_LINK_RECONFIG_RESP = 12,
};

enum ieee80211_pub_actioncode {
	WLAN_PUB_ACTION_20_40_BSS_COEX = 0,
	WLAN_PUB_ACTION_DSE_ENABLEMENT = 1,
	WLAN_PUB_ACTION_DSE_DEENABLEMENT = 2,
	WLAN_PUB_ACTION_DSE_REG_LOC_ANN = 3,
	WLAN_PUB_ACTION_EXT_CHANSW_ANN = 4,
	WLAN_PUB_ACTION_DSE_MSMT_REQ = 5,
	WLAN_PUB_ACTION_DSE_MSMT_RESP = 6,
	WLAN_PUB_ACTION_MSMT_PILOT = 7,
	WLAN_PUB_ACTION_DSE_PC = 8,
	WLAN_PUB_ACTION_VENDOR_SPECIFIC = 9,
	WLAN_PUB_ACTION_GAS_INITIAL_REQ = 10,
	WLAN_PUB_ACTION_GAS_INITIAL_RESP = 11,
	WLAN_PUB_ACTION_GAS_COMEBACK_REQ = 12,
	WLAN_PUB_ACTION_GAS_COMEBACK_RESP = 13,
	WLAN_PUB_ACTION_TDLS_DISCOVER_RES = 14,
	WLAN_PUB_ACTION_LOC_TRACK_NOTI = 15,
	WLAN_PUB_ACTION_QAB_REQUEST_FRAME = 16,
	WLAN_PUB_ACTION_QAB_RESPONSE_FRAME = 17,
	WLAN_PUB_ACTION_QMF_POLICY = 18,
	WLAN_PUB_ACTION_QMF_POLICY_CHANGE = 19,
	WLAN_PUB_ACTION_QLOAD_REQUEST = 20,
	WLAN_PUB_ACTION_QLOAD_REPORT = 21,
	WLAN_PUB_ACTION_HCCA_TXOP_ADVERT = 22,
	WLAN_PUB_ACTION_HCCA_TXOP_RESPONSE = 23,
	WLAN_PUB_ACTION_PUBLIC_KEY = 24,
	WLAN_PUB_ACTION_CHANNEL_AVAIL_QUERY = 25,
	WLAN_PUB_ACTION_CHANNEL_SCHEDULE_MGMT = 26,
	WLAN_PUB_ACTION_CONTACT_VERI_SIGNAL = 27,
	WLAN_PUB_ACTION_GDD_ENABLEMENT_REQ = 28,
	WLAN_PUB_ACTION_GDD_ENABLEMENT_RESP = 29,
	WLAN_PUB_ACTION_NETWORK_CHANNEL_CONTROL = 30,
	WLAN_PUB_ACTION_WHITE_SPACE_MAP_ANN = 31,
	WLAN_PUB_ACTION_FTM_REQUEST = 32,
	WLAN_PUB_ACTION_FTM_RESPONSE = 33,
	WLAN_PUB_ACTION_FILS_DISCOVERY = 34,
};

enum ieee80211_radiotap_ampdu_flags {
	IEEE80211_RADIOTAP_AMPDU_REPORT_ZEROLEN = 1,
	IEEE80211_RADIOTAP_AMPDU_IS_ZEROLEN = 2,
	IEEE80211_RADIOTAP_AMPDU_LAST_KNOWN = 4,
	IEEE80211_RADIOTAP_AMPDU_IS_LAST = 8,
	IEEE80211_RADIOTAP_AMPDU_DELIM_CRC_ERR = 16,
	IEEE80211_RADIOTAP_AMPDU_DELIM_CRC_KNOWN = 32,
	IEEE80211_RADIOTAP_AMPDU_EOF = 64,
	IEEE80211_RADIOTAP_AMPDU_EOF_KNOWN = 128,
};

enum ieee80211_radiotap_channel_flags {
	IEEE80211_CHAN_CCK = 32,
	IEEE80211_CHAN_OFDM = 64,
	IEEE80211_CHAN_2GHZ = 128,
	IEEE80211_CHAN_5GHZ = 256,
	IEEE80211_CHAN_DYN = 1024,
	IEEE80211_CHAN_HALF = 16384,
	IEEE80211_CHAN_QUARTER = 32768,
};

enum ieee80211_radiotap_flags {
	IEEE80211_RADIOTAP_F_CFP = 1,
	IEEE80211_RADIOTAP_F_SHORTPRE = 2,
	IEEE80211_RADIOTAP_F_WEP = 4,
	IEEE80211_RADIOTAP_F_FRAG = 8,
	IEEE80211_RADIOTAP_F_FCS = 16,
	IEEE80211_RADIOTAP_F_DATAPAD = 32,
	IEEE80211_RADIOTAP_F_BADFCS = 64,
};

enum ieee80211_radiotap_he_bits {
	IEEE80211_RADIOTAP_HE_DATA1_FORMAT_MASK = 3,
	IEEE80211_RADIOTAP_HE_DATA1_FORMAT_SU = 0,
	IEEE80211_RADIOTAP_HE_DATA1_FORMAT_EXT_SU = 1,
	IEEE80211_RADIOTAP_HE_DATA1_FORMAT_MU = 2,
	IEEE80211_RADIOTAP_HE_DATA1_FORMAT_TRIG = 3,
	IEEE80211_RADIOTAP_HE_DATA1_BSS_COLOR_KNOWN = 4,
	IEEE80211_RADIOTAP_HE_DATA1_BEAM_CHANGE_KNOWN = 8,
	IEEE80211_RADIOTAP_HE_DATA1_UL_DL_KNOWN = 16,
	IEEE80211_RADIOTAP_HE_DATA1_DATA_MCS_KNOWN = 32,
	IEEE80211_RADIOTAP_HE_DATA1_DATA_DCM_KNOWN = 64,
	IEEE80211_RADIOTAP_HE_DATA1_CODING_KNOWN = 128,
	IEEE80211_RADIOTAP_HE_DATA1_LDPC_XSYMSEG_KNOWN = 256,
	IEEE80211_RADIOTAP_HE_DATA1_STBC_KNOWN = 512,
	IEEE80211_RADIOTAP_HE_DATA1_SPTL_REUSE_KNOWN = 1024,
	IEEE80211_RADIOTAP_HE_DATA1_SPTL_REUSE2_KNOWN = 2048,
	IEEE80211_RADIOTAP_HE_DATA1_SPTL_REUSE3_KNOWN = 4096,
	IEEE80211_RADIOTAP_HE_DATA1_SPTL_REUSE4_KNOWN = 8192,
	IEEE80211_RADIOTAP_HE_DATA1_BW_RU_ALLOC_KNOWN = 16384,
	IEEE80211_RADIOTAP_HE_DATA1_DOPPLER_KNOWN = 32768,
	IEEE80211_RADIOTAP_HE_DATA2_PRISEC_80_KNOWN = 1,
	IEEE80211_RADIOTAP_HE_DATA2_GI_KNOWN = 2,
	IEEE80211_RADIOTAP_HE_DATA2_NUM_LTF_SYMS_KNOWN = 4,
	IEEE80211_RADIOTAP_HE_DATA2_PRE_FEC_PAD_KNOWN = 8,
	IEEE80211_RADIOTAP_HE_DATA2_TXBF_KNOWN = 16,
	IEEE80211_RADIOTAP_HE_DATA2_PE_DISAMBIG_KNOWN = 32,
	IEEE80211_RADIOTAP_HE_DATA2_TXOP_KNOWN = 64,
	IEEE80211_RADIOTAP_HE_DATA2_MIDAMBLE_KNOWN = 128,
	IEEE80211_RADIOTAP_HE_DATA2_RU_OFFSET = 16128,
	IEEE80211_RADIOTAP_HE_DATA2_RU_OFFSET_KNOWN = 16384,
	IEEE80211_RADIOTAP_HE_DATA2_PRISEC_80_SEC = 32768,
	IEEE80211_RADIOTAP_HE_DATA3_BSS_COLOR = 63,
	IEEE80211_RADIOTAP_HE_DATA3_BEAM_CHANGE = 64,
	IEEE80211_RADIOTAP_HE_DATA3_UL_DL = 128,
	IEEE80211_RADIOTAP_HE_DATA3_DATA_MCS = 3840,
	IEEE80211_RADIOTAP_HE_DATA3_DATA_DCM = 4096,
	IEEE80211_RADIOTAP_HE_DATA3_CODING = 8192,
	IEEE80211_RADIOTAP_HE_DATA3_LDPC_XSYMSEG = 16384,
	IEEE80211_RADIOTAP_HE_DATA3_STBC = 32768,
	IEEE80211_RADIOTAP_HE_DATA4_SU_MU_SPTL_REUSE = 15,
	IEEE80211_RADIOTAP_HE_DATA4_MU_STA_ID = 32752,
	IEEE80211_RADIOTAP_HE_DATA4_TB_SPTL_REUSE1 = 15,
	IEEE80211_RADIOTAP_HE_DATA4_TB_SPTL_REUSE2 = 240,
	IEEE80211_RADIOTAP_HE_DATA4_TB_SPTL_REUSE3 = 3840,
	IEEE80211_RADIOTAP_HE_DATA4_TB_SPTL_REUSE4 = 61440,
	IEEE80211_RADIOTAP_HE_DATA5_DATA_BW_RU_ALLOC = 15,
	IEEE80211_RADIOTAP_HE_DATA5_DATA_BW_RU_ALLOC_20MHZ = 0,
	IEEE80211_RADIOTAP_HE_DATA5_DATA_BW_RU_ALLOC_40MHZ = 1,
	IEEE80211_RADIOTAP_HE_DATA5_DATA_BW_RU_ALLOC_80MHZ = 2,
	IEEE80211_RADIOTAP_HE_DATA5_DATA_BW_RU_ALLOC_160MHZ = 3,
	IEEE80211_RADIOTAP_HE_DATA5_DATA_BW_RU_ALLOC_26T = 4,
	IEEE80211_RADIOTAP_HE_DATA5_DATA_BW_RU_ALLOC_52T = 5,
	IEEE80211_RADIOTAP_HE_DATA5_DATA_BW_RU_ALLOC_106T = 6,
	IEEE80211_RADIOTAP_HE_DATA5_DATA_BW_RU_ALLOC_242T = 7,
	IEEE80211_RADIOTAP_HE_DATA5_DATA_BW_RU_ALLOC_484T = 8,
	IEEE80211_RADIOTAP_HE_DATA5_DATA_BW_RU_ALLOC_996T = 9,
	IEEE80211_RADIOTAP_HE_DATA5_DATA_BW_RU_ALLOC_2x996T = 10,
	IEEE80211_RADIOTAP_HE_DATA5_GI = 48,
	IEEE80211_RADIOTAP_HE_DATA5_GI_0_8 = 0,
	IEEE80211_RADIOTAP_HE_DATA5_GI_1_6 = 1,
	IEEE80211_RADIOTAP_HE_DATA5_GI_3_2 = 2,
	IEEE80211_RADIOTAP_HE_DATA5_LTF_SIZE = 192,
	IEEE80211_RADIOTAP_HE_DATA5_LTF_SIZE_UNKNOWN = 0,
	IEEE80211_RADIOTAP_HE_DATA5_LTF_SIZE_1X = 1,
	IEEE80211_RADIOTAP_HE_DATA5_LTF_SIZE_2X = 2,
	IEEE80211_RADIOTAP_HE_DATA5_LTF_SIZE_4X = 3,
	IEEE80211_RADIOTAP_HE_DATA5_NUM_LTF_SYMS = 1792,
	IEEE80211_RADIOTAP_HE_DATA5_PRE_FEC_PAD = 12288,
	IEEE80211_RADIOTAP_HE_DATA5_TXBF = 16384,
	IEEE80211_RADIOTAP_HE_DATA5_PE_DISAMBIG = 32768,
	IEEE80211_RADIOTAP_HE_DATA6_NSTS = 15,
	IEEE80211_RADIOTAP_HE_DATA6_DOPPLER = 16,
	IEEE80211_RADIOTAP_HE_DATA6_TB_PPDU_BW_KNOWN = 32,
	IEEE80211_RADIOTAP_HE_DATA6_TB_PPDU_BW = 192,
	IEEE80211_RADIOTAP_HE_DATA6_TB_PPDU_BW_20MHZ = 0,
	IEEE80211_RADIOTAP_HE_DATA6_TB_PPDU_BW_40MHZ = 1,
	IEEE80211_RADIOTAP_HE_DATA6_TB_PPDU_BW_80MHZ = 2,
	IEEE80211_RADIOTAP_HE_DATA6_TB_PPDU_BW_160MHZ = 3,
	IEEE80211_RADIOTAP_HE_DATA6_TXOP = 32512,
	IEEE80211_RADIOTAP_HE_DATA6_MIDAMBLE_PDCTY = 32768,
};

enum ieee80211_radiotap_mcs_flags {
	IEEE80211_RADIOTAP_MCS_BW_MASK = 3,
	IEEE80211_RADIOTAP_MCS_BW_20 = 0,
	IEEE80211_RADIOTAP_MCS_BW_40 = 1,
	IEEE80211_RADIOTAP_MCS_BW_20L = 2,
	IEEE80211_RADIOTAP_MCS_BW_20U = 3,
	IEEE80211_RADIOTAP_MCS_SGI = 4,
	IEEE80211_RADIOTAP_MCS_FMT_GF = 8,
	IEEE80211_RADIOTAP_MCS_FEC_LDPC = 16,
	IEEE80211_RADIOTAP_MCS_STBC_MASK = 96,
	IEEE80211_RADIOTAP_MCS_STBC_1 = 1,
	IEEE80211_RADIOTAP_MCS_STBC_2 = 2,
	IEEE80211_RADIOTAP_MCS_STBC_3 = 3,
	IEEE80211_RADIOTAP_MCS_STBC_SHIFT = 5,
};

enum ieee80211_radiotap_mcs_have {
	IEEE80211_RADIOTAP_MCS_HAVE_BW = 1,
	IEEE80211_RADIOTAP_MCS_HAVE_MCS = 2,
	IEEE80211_RADIOTAP_MCS_HAVE_GI = 4,
	IEEE80211_RADIOTAP_MCS_HAVE_FMT = 8,
	IEEE80211_RADIOTAP_MCS_HAVE_FEC = 16,
	IEEE80211_RADIOTAP_MCS_HAVE_STBC = 32,
};

enum ieee80211_radiotap_presence {
	IEEE80211_RADIOTAP_TSFT = 0,
	IEEE80211_RADIOTAP_FLAGS = 1,
	IEEE80211_RADIOTAP_RATE = 2,
	IEEE80211_RADIOTAP_CHANNEL = 3,
	IEEE80211_RADIOTAP_FHSS = 4,
	IEEE80211_RADIOTAP_DBM_ANTSIGNAL = 5,
	IEEE80211_RADIOTAP_DBM_ANTNOISE = 6,
	IEEE80211_RADIOTAP_LOCK_QUALITY = 7,
	IEEE80211_RADIOTAP_TX_ATTENUATION = 8,
	IEEE80211_RADIOTAP_DB_TX_ATTENUATION = 9,
	IEEE80211_RADIOTAP_DBM_TX_POWER = 10,
	IEEE80211_RADIOTAP_ANTENNA = 11,
	IEEE80211_RADIOTAP_DB_ANTSIGNAL = 12,
	IEEE80211_RADIOTAP_DB_ANTNOISE = 13,
	IEEE80211_RADIOTAP_RX_FLAGS = 14,
	IEEE80211_RADIOTAP_TX_FLAGS = 15,
	IEEE80211_RADIOTAP_RTS_RETRIES = 16,
	IEEE80211_RADIOTAP_DATA_RETRIES = 17,
	IEEE80211_RADIOTAP_MCS = 19,
	IEEE80211_RADIOTAP_AMPDU_STATUS = 20,
	IEEE80211_RADIOTAP_VHT = 21,
	IEEE80211_RADIOTAP_TIMESTAMP = 22,
	IEEE80211_RADIOTAP_HE = 23,
	IEEE80211_RADIOTAP_HE_MU = 24,
	IEEE80211_RADIOTAP_ZERO_LEN_PSDU = 26,
	IEEE80211_RADIOTAP_LSIG = 27,
	IEEE80211_RADIOTAP_TLV = 28,
	IEEE80211_RADIOTAP_RADIOTAP_NAMESPACE = 29,
	IEEE80211_RADIOTAP_VENDOR_NAMESPACE = 30,
	IEEE80211_RADIOTAP_EXT = 31,
	IEEE80211_RADIOTAP_EHT_USIG = 33,
	IEEE80211_RADIOTAP_EHT = 34,
};

enum ieee80211_radiotap_rx_flags {
	IEEE80211_RADIOTAP_F_RX_BADPLCP = 2,
};

enum ieee80211_radiotap_timestamp_flags {
	IEEE80211_RADIOTAP_TIMESTAMP_FLAG_64BIT = 0,
	IEEE80211_RADIOTAP_TIMESTAMP_FLAG_32BIT = 1,
	IEEE80211_RADIOTAP_TIMESTAMP_FLAG_ACCURACY = 2,
};

enum ieee80211_radiotap_tx_flags {
	IEEE80211_RADIOTAP_F_TX_FAIL = 1,
	IEEE80211_RADIOTAP_F_TX_CTS = 2,
	IEEE80211_RADIOTAP_F_TX_RTS = 4,
	IEEE80211_RADIOTAP_F_TX_NOACK = 8,
	IEEE80211_RADIOTAP_F_TX_NOSEQNO = 16,
	IEEE80211_RADIOTAP_F_TX_ORDER = 32,
};

enum ieee80211_radiotap_vht_coding {
	IEEE80211_RADIOTAP_CODING_LDPC_USER0 = 1,
	IEEE80211_RADIOTAP_CODING_LDPC_USER1 = 2,
	IEEE80211_RADIOTAP_CODING_LDPC_USER2 = 4,
	IEEE80211_RADIOTAP_CODING_LDPC_USER3 = 8,
};

enum ieee80211_radiotap_vht_flags {
	IEEE80211_RADIOTAP_VHT_FLAG_STBC = 1,
	IEEE80211_RADIOTAP_VHT_FLAG_TXOP_PS_NA = 2,
	IEEE80211_RADIOTAP_VHT_FLAG_SGI = 4,
	IEEE80211_RADIOTAP_VHT_FLAG_SGI_NSYM_M10_9 = 8,
	IEEE80211_RADIOTAP_VHT_FLAG_LDPC_EXTRA_OFDM_SYM = 16,
	IEEE80211_RADIOTAP_VHT_FLAG_BEAMFORMED = 32,
};

enum ieee80211_radiotap_vht_known {
	IEEE80211_RADIOTAP_VHT_KNOWN_STBC = 1,
	IEEE80211_RADIOTAP_VHT_KNOWN_TXOP_PS_NA = 2,
	IEEE80211_RADIOTAP_VHT_KNOWN_GI = 4,
	IEEE80211_RADIOTAP_VHT_KNOWN_SGI_NSYM_DIS = 8,
	IEEE80211_RADIOTAP_VHT_KNOWN_LDPC_EXTRA_OFDM_SYM = 16,
	IEEE80211_RADIOTAP_VHT_KNOWN_BEAMFORMED = 32,
	IEEE80211_RADIOTAP_VHT_KNOWN_BANDWIDTH = 64,
	IEEE80211_RADIOTAP_VHT_KNOWN_GROUP_ID = 128,
	IEEE80211_RADIOTAP_VHT_KNOWN_PARTIAL_AID = 256,
};

enum ieee80211_rate_control_changed {
	IEEE80211_RC_BW_CHANGED = 1,
	IEEE80211_RC_SMPS_CHANGED = 2,
	IEEE80211_RC_SUPP_RATES_CHANGED = 4,
	IEEE80211_RC_NSS_CHANGED = 8,
};

enum ieee80211_rate_flags {
	IEEE80211_RATE_SHORT_PREAMBLE = 1,
	IEEE80211_RATE_MANDATORY_A = 2,
	IEEE80211_RATE_MANDATORY_B = 4,
	IEEE80211_RATE_MANDATORY_G = 8,
	IEEE80211_RATE_ERP_G = 16,
	IEEE80211_RATE_SUPPORTS_5MHZ = 32,
	IEEE80211_RATE_SUPPORTS_10MHZ = 64,
};

enum ieee80211_reasoncode {
	WLAN_REASON_UNSPECIFIED = 1,
	WLAN_REASON_PREV_AUTH_NOT_VALID = 2,
	WLAN_REASON_DEAUTH_LEAVING = 3,
	WLAN_REASON_DISASSOC_DUE_TO_INACTIVITY = 4,
	WLAN_REASON_DISASSOC_AP_BUSY = 5,
	WLAN_REASON_CLASS2_FRAME_FROM_NONAUTH_STA = 6,
	WLAN_REASON_CLASS3_FRAME_FROM_NONASSOC_STA = 7,
	WLAN_REASON_DISASSOC_STA_HAS_LEFT = 8,
	WLAN_REASON_STA_REQ_ASSOC_WITHOUT_AUTH = 9,
	WLAN_REASON_DISASSOC_BAD_POWER = 10,
	WLAN_REASON_DISASSOC_BAD_SUPP_CHAN = 11,
	WLAN_REASON_INVALID_IE = 13,
	WLAN_REASON_MIC_FAILURE = 14,
	WLAN_REASON_4WAY_HANDSHAKE_TIMEOUT = 15,
	WLAN_REASON_GROUP_KEY_HANDSHAKE_TIMEOUT = 16,
	WLAN_REASON_IE_DIFFERENT = 17,
	WLAN_REASON_INVALID_GROUP_CIPHER = 18,
	WLAN_REASON_INVALID_PAIRWISE_CIPHER = 19,
	WLAN_REASON_INVALID_AKMP = 20,
	WLAN_REASON_UNSUPP_RSN_VERSION = 21,
	WLAN_REASON_INVALID_RSN_IE_CAP = 22,
	WLAN_REASON_IEEE8021X_FAILED = 23,
	WLAN_REASON_CIPHER_SUITE_REJECTED = 24,
	WLAN_REASON_TDLS_TEARDOWN_UNREACHABLE = 25,
	WLAN_REASON_TDLS_TEARDOWN_UNSPECIFIED = 26,
	WLAN_REASON_DISASSOC_UNSPECIFIED_QOS = 32,
	WLAN_REASON_DISASSOC_QAP_NO_BANDWIDTH = 33,
	WLAN_REASON_DISASSOC_LOW_ACK = 34,
	WLAN_REASON_DISASSOC_QAP_EXCEED_TXOP = 35,
	WLAN_REASON_QSTA_LEAVE_QBSS = 36,
	WLAN_REASON_QSTA_NOT_USE = 37,
	WLAN_REASON_QSTA_REQUIRE_SETUP = 38,
	WLAN_REASON_QSTA_TIMEOUT = 39,
	WLAN_REASON_QSTA_CIPHER_NOT_SUPP = 45,
	WLAN_REASON_MESH_PEER_CANCELED = 52,
	WLAN_REASON_MESH_MAX_PEERS = 53,
	WLAN_REASON_MESH_CONFIG = 54,
	WLAN_REASON_MESH_CLOSE = 55,
	WLAN_REASON_MESH_MAX_RETRIES = 56,
	WLAN_REASON_MESH_CONFIRM_TIMEOUT = 57,
	WLAN_REASON_MESH_INVALID_GTK = 58,
	WLAN_REASON_MESH_INCONSISTENT_PARAM = 59,
	WLAN_REASON_MESH_INVALID_SECURITY = 60,
	WLAN_REASON_MESH_PATH_ERROR = 61,
	WLAN_REASON_MESH_PATH_NOFORWARD = 62,
	WLAN_REASON_MESH_PATH_DEST_UNREACHABLE = 63,
	WLAN_REASON_MAC_EXISTS_IN_MBSS = 64,
	WLAN_REASON_MESH_CHAN_REGULATORY = 65,
	WLAN_REASON_MESH_CHAN = 66,
};

enum ieee80211_reconfig_type {
	IEEE80211_RECONFIG_TYPE_RESTART = 0,
	IEEE80211_RECONFIG_TYPE_SUSPEND = 1,
};

enum ieee80211_regd_source {
	REGD_SOURCE_INTERNAL_DB = 0,
	REGD_SOURCE_CRDA = 1,
	REGD_SOURCE_CACHED = 2,
};

enum ieee80211_regulatory_flags {
	REGULATORY_CUSTOM_REG = 1,
	REGULATORY_STRICT_REG = 2,
	REGULATORY_DISABLE_BEACON_HINTS = 4,
	REGULATORY_COUNTRY_IE_FOLLOW_POWER = 8,
	REGULATORY_COUNTRY_IE_IGNORE = 16,
	REGULATORY_ENABLE_RELAX_NO_IR = 32,
	REGULATORY_WIPHY_SELF_MANAGED = 128,
};

enum ieee80211_roc_type {
	IEEE80211_ROC_TYPE_NORMAL = 0,
	IEEE80211_ROC_TYPE_MGMT_TX = 1,
};

enum ieee80211_rssi_event_data {
	RSSI_EVENT_HIGH = 0,
	RSSI_EVENT_LOW = 1,
};

enum ieee80211_rx_flags {
	IEEE80211_RX_CMNTR = 1,
	IEEE80211_RX_BEACON_REPORTED = 2,
};

enum ieee80211_s1g_actioncode {
	WLAN_S1G_AID_SWITCH_REQUEST = 0,
	WLAN_S1G_AID_SWITCH_RESPONSE = 1,
	WLAN_S1G_SYNC_CONTROL = 2,
	WLAN_S1G_STA_INFO_ANNOUNCE = 3,
	WLAN_S1G_EDCA_PARAM_SET = 4,
	WLAN_S1G_EL_OPERATION = 5,
	WLAN_S1G_TWT_SETUP = 6,
	WLAN_S1G_TWT_TEARDOWN = 7,
	WLAN_S1G_SECT_GROUP_ID_LIST = 8,
	WLAN_S1G_SECT_ID_FEEDBACK = 9,
	WLAN_S1G_TWT_INFORMATION = 11,
};

enum ieee80211_s1g_chanwidth {
	IEEE80211_S1G_CHANWIDTH_1MHZ = 0,
	IEEE80211_S1G_CHANWIDTH_2MHZ = 1,
	IEEE80211_S1G_CHANWIDTH_4MHZ = 3,
	IEEE80211_S1G_CHANWIDTH_8MHZ = 7,
	IEEE80211_S1G_CHANWIDTH_16MHZ = 15,
};

enum ieee80211_sa_query_action {
	WLAN_ACTION_SA_QUERY_REQUEST = 0,
	WLAN_ACTION_SA_QUERY_RESPONSE = 1,
};

enum ieee80211_sdata_state_bits {
	SDATA_STATE_RUNNING = 0,
	SDATA_STATE_OFFCHANNEL = 1,
	SDATA_STATE_OFFCHANNEL_BEACON_STOPPED = 2,
};

enum ieee80211_self_protected_actioncode {
	WLAN_SP_RESERVED = 0,
	WLAN_SP_MESH_PEERING_OPEN = 1,
	WLAN_SP_MESH_PEERING_CONFIRM = 2,
	WLAN_SP_MESH_PEERING_CLOSE = 3,
	WLAN_SP_MGK_INFORM = 4,
	WLAN_SP_MGK_ACK = 5,
};

enum ieee80211_smps_mode {
	IEEE80211_SMPS_AUTOMATIC = 0,
	IEEE80211_SMPS_OFF = 1,
	IEEE80211_SMPS_STATIC = 2,
	IEEE80211_SMPS_DYNAMIC = 3,
	IEEE80211_SMPS_NUM_MODES = 4,
};

enum ieee80211_spectrum_mgmt_actioncode {
	WLAN_ACTION_SPCT_MSR_REQ = 0,
	WLAN_ACTION_SPCT_MSR_RPRT = 1,
	WLAN_ACTION_SPCT_TPC_REQ = 2,
	WLAN_ACTION_SPCT_TPC_RPRT = 3,
	WLAN_ACTION_SPCT_CHL_SWITCH = 4,
};

enum ieee80211_sta_flags {
	IEEE80211_STA_CONNECTION_POLL = 2,
	IEEE80211_STA_CONTROL_PORT = 4,
	IEEE80211_STA_MFP_ENABLED = 64,
	IEEE80211_STA_UAPSD_ENABLED = 128,
	IEEE80211_STA_NULLFUNC_ACKED = 256,
	IEEE80211_STA_ENABLE_RRM = 32768,
};

enum ieee80211_sta_info_flags {
	WLAN_STA_AUTH = 0,
	WLAN_STA_ASSOC = 1,
	WLAN_STA_PS_STA = 2,
	WLAN_STA_AUTHORIZED = 3,
	WLAN_STA_SHORT_PREAMBLE = 4,
	WLAN_STA_WDS = 5,
	WLAN_STA_CLEAR_PS_FILT = 6,
	WLAN_STA_MFP = 7,
	WLAN_STA_BLOCK_BA = 8,
	WLAN_STA_PS_DRIVER = 9,
	WLAN_STA_PSPOLL = 10,
	WLAN_STA_TDLS_PEER = 11,
	WLAN_STA_TDLS_PEER_AUTH = 12,
	WLAN_STA_TDLS_INITIATOR = 13,
	WLAN_STA_TDLS_CHAN_SWITCH = 14,
	WLAN_STA_TDLS_OFF_CHANNEL = 15,
	WLAN_STA_TDLS_WIDER_BW = 16,
	WLAN_STA_UAPSD = 17,
	WLAN_STA_SP = 18,
	WLAN_STA_4ADDR_EVENT = 19,
	WLAN_STA_INSERTED = 20,
	WLAN_STA_RATE_CONTROL = 21,
	WLAN_STA_TOFFSET_KNOWN = 22,
	WLAN_STA_MPSP_OWNER = 23,
	WLAN_STA_MPSP_RECIPIENT = 24,
	WLAN_STA_PS_DELIVER = 25,
	WLAN_STA_USES_ENCRYPTION = 26,
	WLAN_STA_DECAP_OFFLOAD = 27,
	NUM_WLAN_STA_FLAGS = 28,
};

enum ieee80211_sta_rx_bandwidth {
	IEEE80211_STA_RX_BW_20 = 0,
	IEEE80211_STA_RX_BW_40 = 1,
	IEEE80211_STA_RX_BW_80 = 2,
	IEEE80211_STA_RX_BW_160 = 3,
	IEEE80211_STA_RX_BW_320 = 4,
};

enum ieee80211_sta_state {
	IEEE80211_STA_NOTEXIST = 0,
	IEEE80211_STA_NONE = 1,
	IEEE80211_STA_AUTH = 2,
	IEEE80211_STA_ASSOC = 3,
	IEEE80211_STA_AUTHORIZED = 4,
};

enum ieee80211_status_data {
	IEEE80211_STATUS_TYPE_MASK = 15,
	IEEE80211_STATUS_TYPE_INVALID = 0,
	IEEE80211_STATUS_TYPE_SMPS = 1,
	IEEE80211_STATUS_TYPE_NEG_TTLM = 2,
	IEEE80211_STATUS_SUBDATA_MASK = 8176,
};

enum ieee80211_statuscode {
	WLAN_STATUS_SUCCESS = 0,
	WLAN_STATUS_UNSPECIFIED_FAILURE = 1,
	WLAN_STATUS_CAPS_UNSUPPORTED = 10,
	WLAN_STATUS_REASSOC_NO_ASSOC = 11,
	WLAN_STATUS_ASSOC_DENIED_UNSPEC = 12,
	WLAN_STATUS_NOT_SUPPORTED_AUTH_ALG = 13,
	WLAN_STATUS_UNKNOWN_AUTH_TRANSACTION = 14,
	WLAN_STATUS_CHALLENGE_FAIL = 15,
	WLAN_STATUS_AUTH_TIMEOUT = 16,
	WLAN_STATUS_AP_UNABLE_TO_HANDLE_NEW_STA = 17,
	WLAN_STATUS_ASSOC_DENIED_RATES = 18,
	WLAN_STATUS_ASSOC_DENIED_NOSHORTPREAMBLE = 19,
	WLAN_STATUS_ASSOC_DENIED_NOPBCC = 20,
	WLAN_STATUS_ASSOC_DENIED_NOAGILITY = 21,
	WLAN_STATUS_ASSOC_DENIED_NOSPECTRUM = 22,
	WLAN_STATUS_ASSOC_REJECTED_BAD_POWER = 23,
	WLAN_STATUS_ASSOC_REJECTED_BAD_SUPP_CHAN = 24,
	WLAN_STATUS_ASSOC_DENIED_NOSHORTTIME = 25,
	WLAN_STATUS_ASSOC_DENIED_NODSSSOFDM = 26,
	WLAN_STATUS_ASSOC_REJECTED_TEMPORARILY = 30,
	WLAN_STATUS_ROBUST_MGMT_FRAME_POLICY_VIOLATION = 31,
	WLAN_STATUS_INVALID_IE = 40,
	WLAN_STATUS_INVALID_GROUP_CIPHER = 41,
	WLAN_STATUS_INVALID_PAIRWISE_CIPHER = 42,
	WLAN_STATUS_INVALID_AKMP = 43,
	WLAN_STATUS_UNSUPP_RSN_VERSION = 44,
	WLAN_STATUS_INVALID_RSN_IE_CAP = 45,
	WLAN_STATUS_CIPHER_SUITE_REJECTED = 46,
	WLAN_STATUS_UNSPECIFIED_QOS = 32,
	WLAN_STATUS_ASSOC_DENIED_NOBANDWIDTH = 33,
	WLAN_STATUS_ASSOC_DENIED_LOWACK = 34,
	WLAN_STATUS_ASSOC_DENIED_UNSUPP_QOS = 35,
	WLAN_STATUS_REQUEST_DECLINED = 37,
	WLAN_STATUS_INVALID_QOS_PARAM = 38,
	WLAN_STATUS_CHANGE_TSPEC = 39,
	WLAN_STATUS_WAIT_TS_DELAY = 47,
	WLAN_STATUS_NO_DIRECT_LINK = 48,
	WLAN_STATUS_STA_NOT_PRESENT = 49,
	WLAN_STATUS_STA_NOT_QSTA = 50,
	WLAN_STATUS_ANTI_CLOG_REQUIRED = 76,
	WLAN_STATUS_FCG_NOT_SUPP = 78,
	WLAN_STATUS_STA_NO_TBTT = 78,
	WLAN_STATUS_REJECTED_WITH_SUGGESTED_CHANGES = 39,
	WLAN_STATUS_REJECTED_FOR_DELAY_PERIOD = 47,
	WLAN_STATUS_REJECT_WITH_SCHEDULE = 83,
	WLAN_STATUS_PENDING_ADMITTING_FST_SESSION = 86,
	WLAN_STATUS_PERFORMING_FST_NOW = 87,
	WLAN_STATUS_PENDING_GAP_IN_BA_WINDOW = 88,
	WLAN_STATUS_REJECT_U_PID_SETTING = 89,
	WLAN_STATUS_REJECT_DSE_BAND = 96,
	WLAN_STATUS_DENIED_WITH_SUGGESTED_BAND_AND_CHANNEL = 99,
	WLAN_STATUS_DENIED_DUE_TO_SPECTRUM_MANAGEMENT = 103,
	WLAN_STATUS_FILS_AUTHENTICATION_FAILURE = 108,
	WLAN_STATUS_UNKNOWN_AUTHENTICATION_SERVER = 109,
	WLAN_STATUS_SAE_HASH_TO_ELEMENT = 126,
	WLAN_STATUS_SAE_PK = 127,
	WLAN_STATUS_DENIED_TID_TO_LINK_MAPPING = 133,
	WLAN_STATUS_PREF_TID_TO_LINK_MAPPING_SUGGESTED = 134,
};

enum ieee80211_sub_if_data_flags {
	IEEE80211_SDATA_ALLMULTI = 1,
	IEEE80211_SDATA_DONT_BRIDGE_PACKETS = 8,
	IEEE80211_SDATA_DISCONNECT_RESUME = 16,
	IEEE80211_SDATA_IN_DRIVER = 32,
	IEEE80211_SDATA_DISCONNECT_HW_RESTART = 64,
};

enum ieee80211_tdls_actioncode {
	WLAN_TDLS_SETUP_REQUEST = 0,
	WLAN_TDLS_SETUP_RESPONSE = 1,
	WLAN_TDLS_SETUP_CONFIRM = 2,
	WLAN_TDLS_TEARDOWN = 3,
	WLAN_TDLS_PEER_TRAFFIC_INDICATION = 4,
	WLAN_TDLS_CHANNEL_SWITCH_REQUEST = 5,
	WLAN_TDLS_CHANNEL_SWITCH_RESPONSE = 6,
	WLAN_TDLS_PEER_PSM_REQUEST = 7,
	WLAN_TDLS_PEER_PSM_RESPONSE = 8,
	WLAN_TDLS_PEER_TRAFFIC_RESPONSE = 9,
	WLAN_TDLS_DISCOVERY_REQUEST = 10,
};

enum ieee80211_timeout_interval_type {
	WLAN_TIMEOUT_REASSOC_DEADLINE = 1,
	WLAN_TIMEOUT_KEY_LIFETIME = 2,
	WLAN_TIMEOUT_ASSOC_COMEBACK = 3,
};

enum ieee80211_tpt_led_trigger_flags {
	IEEE80211_TPT_LEDTRIG_FL_RADIO = 1,
	IEEE80211_TPT_LEDTRIG_FL_WORK = 2,
	IEEE80211_TPT_LEDTRIG_FL_CONNECTED = 4,
};

enum ieee80211_twt_setup_cmd {
	TWT_SETUP_CMD_REQUEST = 0,
	TWT_SETUP_CMD_SUGGEST = 1,
	TWT_SETUP_CMD_DEMAND = 2,
	TWT_SETUP_CMD_GROUPING = 3,
	TWT_SETUP_CMD_ACCEPT = 4,
	TWT_SETUP_CMD_ALTERNATE = 5,
	TWT_SETUP_CMD_DICTATE = 6,
	TWT_SETUP_CMD_REJECT = 7,
};

enum ieee80211_tx_power_category_6ghz {
	IEEE80211_TPE_CAT_6GHZ_DEFAULT = 0,
	IEEE80211_TPE_CAT_6GHZ_SUBORDINATE = 1,
};

enum ieee80211_tx_power_intrpt_type {
	IEEE80211_TPE_LOCAL_EIRP = 0,
	IEEE80211_TPE_LOCAL_EIRP_PSD = 1,
	IEEE80211_TPE_REG_CLIENT_EIRP = 2,
	IEEE80211_TPE_REG_CLIENT_EIRP_PSD = 3,
};

enum ieee80211_unprotected_wnm_actioncode {
	WLAN_UNPROTECTED_WNM_ACTION_TIM = 0,
	WLAN_UNPROTECTED_WNM_ACTION_TIMING_MEASUREMENT_RESPONSE = 1,
};

enum ieee80211_vht_actioncode {
	WLAN_VHT_ACTION_COMPRESSED_BF = 0,
	WLAN_VHT_ACTION_GROUPID_MGMT = 1,
	WLAN_VHT_ACTION_OPMODE_NOTIF = 2,
};

enum ieee80211_vht_chanwidth {
	IEEE80211_VHT_CHANWIDTH_USE_HT = 0,
	IEEE80211_VHT_CHANWIDTH_80MHZ = 1,
	IEEE80211_VHT_CHANWIDTH_160MHZ = 2,
	IEEE80211_VHT_CHANWIDTH_80P80MHZ = 3,
};

enum ieee80211_vht_mcs_support {
	IEEE80211_VHT_MCS_SUPPORT_0_7 = 0,
	IEEE80211_VHT_MCS_SUPPORT_0_8 = 1,
	IEEE80211_VHT_MCS_SUPPORT_0_9 = 2,
	IEEE80211_VHT_MCS_NOT_SUPPORTED = 3,
};

enum ieee80211_vht_opmode_bits {
	IEEE80211_OPMODE_NOTIF_CHANWIDTH_MASK = 3,
	IEEE80211_OPMODE_NOTIF_CHANWIDTH_20MHZ = 0,
	IEEE80211_OPMODE_NOTIF_CHANWIDTH_40MHZ = 1,
	IEEE80211_OPMODE_NOTIF_CHANWIDTH_80MHZ = 2,
	IEEE80211_OPMODE_NOTIF_CHANWIDTH_160MHZ = 3,
	IEEE80211_OPMODE_NOTIF_BW_160_80P80 = 4,
	IEEE80211_OPMODE_NOTIF_RX_NSS_MASK = 112,
	IEEE80211_OPMODE_NOTIF_RX_NSS_SHIFT = 4,
	IEEE80211_OPMODE_NOTIF_RX_NSS_TYPE_BF = 128,
};

enum ieee80211_vif_flags {
	IEEE80211_VIF_BEACON_FILTER = 1,
	IEEE80211_VIF_SUPPORTS_CQM_RSSI = 2,
	IEEE80211_VIF_SUPPORTS_UAPSD = 4,
	IEEE80211_VIF_GET_NOA_UPDATE = 8,
	IEEE80211_VIF_EML_ACTIVE = 16,
	IEEE80211_VIF_IGNORE_OFDMA_WIDER_BW = 32,
	IEEE80211_VIF_REMOVE_AP_AFTER_DISASSOC = 64,
};

enum in6_addr_gen_mode {
	IN6_ADDR_GEN_MODE_EUI64 = 0,
	IN6_ADDR_GEN_MODE_NONE = 1,
	IN6_ADDR_GEN_MODE_STABLE_PRIVACY = 2,
	IN6_ADDR_GEN_MODE_RANDOM = 3,
};

enum inet_csk_ack_state_t {
	ICSK_ACK_SCHED = 1,
	ICSK_ACK_TIMER = 2,
	ICSK_ACK_PUSHED = 4,
	ICSK_ACK_PUSHED2 = 8,
	ICSK_ACK_NOW = 16,
	ICSK_ACK_NOMEM = 32,
};

enum inode_i_mutex_lock_class {
	I_MUTEX_NORMAL = 0,
	I_MUTEX_PARENT = 1,
	I_MUTEX_CHILD = 2,
	I_MUTEX_XATTR = 3,
	I_MUTEX_NONDIR2 = 4,
	I_MUTEX_PARENT2 = 5,
};

enum input_clock_type {
	INPUT_CLK_REAL = 0,
	INPUT_CLK_MONO = 1,
	INPUT_CLK_BOOT = 2,
	INPUT_CLK_MAX = 3,
};

enum insn_mmio_type {
	INSN_MMIO_DECODE_FAILED = 0,
	INSN_MMIO_WRITE = 1,
	INSN_MMIO_WRITE_IMM = 2,
	INSN_MMIO_READ = 3,
	INSN_MMIO_READ_ZERO_EXTEND = 4,
	INSN_MMIO_READ_SIGN_EXTEND = 5,
	INSN_MMIO_MOVS = 6,
};

enum insn_mode {
	INSN_MODE_32 = 0,
	INSN_MODE_64 = 1,
	INSN_MODE_KERN = 2,
	INSN_NUM_MODES = 3,
};

enum insn_type {
	CALL = 0,
	NOP = 1,
	JMP = 2,
	RET = 3,
	JCC = 4,
};

enum intel_backlight_type {
	INTEL_BACKLIGHT_PMIC = 0,
	INTEL_BACKLIGHT_LPSS = 1,
	INTEL_BACKLIGHT_DISPLAY_DDI = 2,
	INTEL_BACKLIGHT_DSI_DCS = 3,
	INTEL_BACKLIGHT_PANEL_DRIVER_INTERFACE = 4,
	INTEL_BACKLIGHT_VESA_EDP_AUX_INTERFACE = 5,
};

enum intel_bootrom_load_status {
	INTEL_BOOTROM_STATUS_NO_KEY_FOUND = 19,
	INTEL_BOOTROM_STATUS_AES_PROD_KEY_FOUND = 26,
	INTEL_BOOTROM_STATUS_PROD_KEY_CHECK_FAILURE = 43,
	INTEL_BOOTROM_STATUS_RSA_FAILED = 80,
	INTEL_BOOTROM_STATUS_PAVPC_FAILED = 115,
	INTEL_BOOTROM_STATUS_WOPCM_FAILED = 116,
	INTEL_BOOTROM_STATUS_LOADLOC_FAILED = 117,
	INTEL_BOOTROM_STATUS_JUMP_PASSED = 118,
	INTEL_BOOTROM_STATUS_JUMP_FAILED = 119,
	INTEL_BOOTROM_STATUS_RC6CTXCONFIG_FAILED = 121,
	INTEL_BOOTROM_STATUS_MPUMAP_INCORRECT = 122,
	INTEL_BOOTROM_STATUS_EXCEPTION = 126,
};

enum intel_broadcast_rgb {
	INTEL_BROADCAST_RGB_AUTO = 0,
	INTEL_BROADCAST_RGB_FULL = 1,
	INTEL_BROADCAST_RGB_LIMITED = 2,
};

enum intel_cpu_type {
	INTEL_CPU_TYPE_ATOM = 32,
	INTEL_CPU_TYPE_CORE = 64,
};

enum intel_ddb_partitioning {
	INTEL_DDB_PART_1_2 = 0,
	INTEL_DDB_PART_5_6 = 1,
};

enum intel_display_power_domain {
	POWER_DOMAIN_DISPLAY_CORE = 0,
	POWER_DOMAIN_PIPE_A = 1,
	POWER_DOMAIN_PIPE_B = 2,
	POWER_DOMAIN_PIPE_C = 3,
	POWER_DOMAIN_PIPE_D = 4,
	POWER_DOMAIN_PIPE_PANEL_FITTER_A = 5,
	POWER_DOMAIN_PIPE_PANEL_FITTER_B = 6,
	POWER_DOMAIN_PIPE_PANEL_FITTER_C = 7,
	POWER_DOMAIN_PIPE_PANEL_FITTER_D = 8,
	POWER_DOMAIN_TRANSCODER_A = 9,
	POWER_DOMAIN_TRANSCODER_B = 10,
	POWER_DOMAIN_TRANSCODER_C = 11,
	POWER_DOMAIN_TRANSCODER_D = 12,
	POWER_DOMAIN_TRANSCODER_EDP = 13,
	POWER_DOMAIN_TRANSCODER_DSI_A = 14,
	POWER_DOMAIN_TRANSCODER_DSI_C = 15,
	POWER_DOMAIN_TRANSCODER_VDSC_PW2 = 16,
	POWER_DOMAIN_PORT_DDI_LANES_A = 17,
	POWER_DOMAIN_PORT_DDI_LANES_B = 18,
	POWER_DOMAIN_PORT_DDI_LANES_C = 19,
	POWER_DOMAIN_PORT_DDI_LANES_D = 20,
	POWER_DOMAIN_PORT_DDI_LANES_E = 21,
	POWER_DOMAIN_PORT_DDI_LANES_F = 22,
	POWER_DOMAIN_PORT_DDI_LANES_TC1 = 23,
	POWER_DOMAIN_PORT_DDI_LANES_TC2 = 24,
	POWER_DOMAIN_PORT_DDI_LANES_TC3 = 25,
	POWER_DOMAIN_PORT_DDI_LANES_TC4 = 26,
	POWER_DOMAIN_PORT_DDI_LANES_TC5 = 27,
	POWER_DOMAIN_PORT_DDI_LANES_TC6 = 28,
	POWER_DOMAIN_PORT_DDI_IO_A = 29,
	POWER_DOMAIN_PORT_DDI_IO_B = 30,
	POWER_DOMAIN_PORT_DDI_IO_C = 31,
	POWER_DOMAIN_PORT_DDI_IO_D = 32,
	POWER_DOMAIN_PORT_DDI_IO_E = 33,
	POWER_DOMAIN_PORT_DDI_IO_F = 34,
	POWER_DOMAIN_PORT_DDI_IO_TC1 = 35,
	POWER_DOMAIN_PORT_DDI_IO_TC2 = 36,
	POWER_DOMAIN_PORT_DDI_IO_TC3 = 37,
	POWER_DOMAIN_PORT_DDI_IO_TC4 = 38,
	POWER_DOMAIN_PORT_DDI_IO_TC5 = 39,
	POWER_DOMAIN_PORT_DDI_IO_TC6 = 40,
	POWER_DOMAIN_PORT_DSI = 41,
	POWER_DOMAIN_PORT_CRT = 42,
	POWER_DOMAIN_PORT_OTHER = 43,
	POWER_DOMAIN_VGA = 44,
	POWER_DOMAIN_AUDIO_MMIO = 45,
	POWER_DOMAIN_AUDIO_PLAYBACK = 46,
	POWER_DOMAIN_AUX_IO_A = 47,
	POWER_DOMAIN_AUX_IO_B = 48,
	POWER_DOMAIN_AUX_IO_C = 49,
	POWER_DOMAIN_AUX_IO_D = 50,
	POWER_DOMAIN_AUX_IO_E = 51,
	POWER_DOMAIN_AUX_IO_F = 52,
	POWER_DOMAIN_AUX_A = 53,
	POWER_DOMAIN_AUX_B = 54,
	POWER_DOMAIN_AUX_C = 55,
	POWER_DOMAIN_AUX_D = 56,
	POWER_DOMAIN_AUX_E = 57,
	POWER_DOMAIN_AUX_F = 58,
	POWER_DOMAIN_AUX_USBC1 = 59,
	POWER_DOMAIN_AUX_USBC2 = 60,
	POWER_DOMAIN_AUX_USBC3 = 61,
	POWER_DOMAIN_AUX_USBC4 = 62,
	POWER_DOMAIN_AUX_USBC5 = 63,
	POWER_DOMAIN_AUX_USBC6 = 64,
	POWER_DOMAIN_AUX_TBT1 = 65,
	POWER_DOMAIN_AUX_TBT2 = 66,
	POWER_DOMAIN_AUX_TBT3 = 67,
	POWER_DOMAIN_AUX_TBT4 = 68,
	POWER_DOMAIN_AUX_TBT5 = 69,
	POWER_DOMAIN_AUX_TBT6 = 70,
	POWER_DOMAIN_GMBUS = 71,
	POWER_DOMAIN_GT_IRQ = 72,
	POWER_DOMAIN_DC_OFF = 73,
	POWER_DOMAIN_TC_COLD_OFF = 74,
	POWER_DOMAIN_INIT = 75,
	POWER_DOMAIN_NUM = 76,
	POWER_DOMAIN_INVALID = 76,
};

enum intel_dmc_id {
	DMC_FW_MAIN = 0,
	DMC_FW_PIPEA = 1,
	DMC_FW_PIPEB = 2,
	DMC_FW_PIPEC = 3,
	DMC_FW_PIPED = 4,
	DMC_FW_MAX = 5,
};

enum intel_dp_aux_backlight_modparam {
	INTEL_DP_AUX_BACKLIGHT_AUTO = -1,
	INTEL_DP_AUX_BACKLIGHT_OFF = 0,
	INTEL_DP_AUX_BACKLIGHT_ON = 1,
	INTEL_DP_AUX_BACKLIGHT_FORCE_VESA = 2,
	INTEL_DP_AUX_BACKLIGHT_FORCE_INTEL = 3,
};

enum intel_dpll_id {
	DPLL_ID_PRIVATE = -1,
	DPLL_ID_PCH_PLL_A = 0,
	DPLL_ID_PCH_PLL_B = 1,
	DPLL_ID_WRPLL1 = 0,
	DPLL_ID_WRPLL2 = 1,
	DPLL_ID_SPLL = 2,
	DPLL_ID_LCPLL_810 = 3,
	DPLL_ID_LCPLL_1350 = 4,
	DPLL_ID_LCPLL_2700 = 5,
	DPLL_ID_SKL_DPLL0 = 0,
	DPLL_ID_SKL_DPLL1 = 1,
	DPLL_ID_SKL_DPLL2 = 2,
	DPLL_ID_SKL_DPLL3 = 3,
	DPLL_ID_ICL_DPLL0 = 0,
	DPLL_ID_ICL_DPLL1 = 1,
	DPLL_ID_EHL_DPLL4 = 2,
	DPLL_ID_ICL_TBTPLL = 2,
	DPLL_ID_ICL_MGPLL1 = 3,
	DPLL_ID_ICL_MGPLL2 = 4,
	DPLL_ID_ICL_MGPLL3 = 5,
	DPLL_ID_ICL_MGPLL4 = 6,
	DPLL_ID_TGL_MGPLL5 = 7,
	DPLL_ID_TGL_MGPLL6 = 8,
	DPLL_ID_DG1_DPLL0 = 0,
	DPLL_ID_DG1_DPLL1 = 1,
	DPLL_ID_DG1_DPLL2 = 2,
	DPLL_ID_DG1_DPLL3 = 3,
};

enum intel_dram_type {
	INTEL_DRAM_UNKNOWN = 0,
	INTEL_DRAM_DDR3 = 1,
	INTEL_DRAM_DDR4 = 2,
	INTEL_DRAM_LPDDR3 = 3,
	INTEL_DRAM_LPDDR4 = 4,
	INTEL_DRAM_DDR5 = 5,
	INTEL_DRAM_LPDDR5 = 6,
	INTEL_DRAM_GDDR = 7,
};

enum intel_dsb_id {
	INTEL_DSB_0 = 0,
	INTEL_DSB_1 = 1,
	INTEL_DSB_2 = 2,
	I915_MAX_DSBS = 3,
};

enum intel_engine_id {
	RCS0 = 0,
	BCS0 = 1,
	BCS1 = 2,
	BCS2 = 3,
	BCS3 = 4,
	BCS4 = 5,
	BCS5 = 6,
	BCS6 = 7,
	BCS7 = 8,
	BCS8 = 9,
	VCS0 = 10,
	VCS1 = 11,
	VCS2 = 12,
	VCS3 = 13,
	VCS4 = 14,
	VCS5 = 15,
	VCS6 = 16,
	VCS7 = 17,
	VECS0 = 18,
	VECS1 = 19,
	VECS2 = 20,
	VECS3 = 21,
	CCS0 = 22,
	CCS1 = 23,
	CCS2 = 24,
	CCS3 = 25,
	GSC0 = 26,
	I915_NUM_ENGINES = 27,
};

enum intel_excl_state_type {
	INTEL_EXCL_UNUSED = 0,
	INTEL_EXCL_SHARED = 1,
	INTEL_EXCL_EXCLUSIVE = 2,
};

enum intel_fbc_id {
	INTEL_FBC_A = 0,
	INTEL_FBC_B = 1,
	INTEL_FBC_C = 2,
	INTEL_FBC_D = 3,
	I915_MAX_FBCS = 4,
};

enum intel_gsc_proxy_type {
	GSC_PROXY_MSG_TYPE_PROXY_INVALID = 0,
	GSC_PROXY_MSG_TYPE_PROXY_QUERY = 1,
	GSC_PROXY_MSG_TYPE_PROXY_PAYLOAD = 2,
	GSC_PROXY_MSG_TYPE_PROXY_END = 3,
	GSC_PROXY_MSG_TYPE_PROXY_NOTIFICATION = 4,
};

enum intel_gt_scratch_field {
	INTEL_GT_SCRATCH_FIELD_DEFAULT = 0,
	INTEL_GT_SCRATCH_FIELD_RENDER_FLUSH = 128,
	INTEL_GT_SCRATCH_FIELD_COHERENTL3_WA = 256,
};

enum intel_gt_sysfs_op {
	INTEL_GT_SYSFS_MIN = 0,
	INTEL_GT_SYSFS_MAX = 1,
};

enum intel_gt_type {
	GT_PRIMARY = 0,
	GT_TILE = 1,
	GT_MEDIA = 2,
};

enum intel_guc_action {
	INTEL_GUC_ACTION_DEFAULT = 0,
	INTEL_GUC_ACTION_REQUEST_PREEMPTION = 2,
	INTEL_GUC_ACTION_REQUEST_ENGINE_RESET = 3,
	INTEL_GUC_ACTION_ALLOCATE_DOORBELL = 16,
	INTEL_GUC_ACTION_DEALLOCATE_DOORBELL = 32,
	INTEL_GUC_ACTION_LOG_BUFFER_FILE_FLUSH_COMPLETE = 48,
	INTEL_GUC_ACTION_UK_LOG_ENABLE_LOGGING = 64,
	INTEL_GUC_ACTION_FORCE_LOG_BUFFER_FLUSH = 770,
	INTEL_GUC_ACTION_ENTER_S_STATE = 1281,
	INTEL_GUC_ACTION_EXIT_S_STATE = 1282,
	INTEL_GUC_ACTION_GLOBAL_SCHED_POLICY_CHANGE = 1286,
	INTEL_GUC_ACTION_UPDATE_SCHEDULING_POLICIES_KLV = 1289,
	INTEL_GUC_ACTION_SCHED_CONTEXT = 4096,
	INTEL_GUC_ACTION_SCHED_CONTEXT_MODE_SET = 4097,
	INTEL_GUC_ACTION_SCHED_CONTEXT_MODE_DONE = 4098,
	INTEL_GUC_ACTION_SCHED_ENGINE_MODE_SET = 4099,
	INTEL_GUC_ACTION_SCHED_ENGINE_MODE_DONE = 4100,
	INTEL_GUC_ACTION_V69_SET_CONTEXT_PRIORITY = 4101,
	INTEL_GUC_ACTION_V69_SET_CONTEXT_EXECUTION_QUANTUM = 4102,
	INTEL_GUC_ACTION_V69_SET_CONTEXT_PREEMPTION_TIMEOUT = 4103,
	INTEL_GUC_ACTION_CONTEXT_RESET_NOTIFICATION = 4104,
	INTEL_GUC_ACTION_ENGINE_FAILURE_NOTIFICATION = 4105,
	INTEL_GUC_ACTION_HOST2GUC_UPDATE_CONTEXT_POLICIES = 4107,
	INTEL_GUC_ACTION_SETUP_PC_GUCRC = 12292,
	INTEL_GUC_ACTION_AUTHENTICATE_HUC = 16384,
	INTEL_GUC_ACTION_GET_HWCONFIG = 16640,
	INTEL_GUC_ACTION_REGISTER_CONTEXT = 17666,
	INTEL_GUC_ACTION_DEREGISTER_CONTEXT = 17667,
	INTEL_GUC_ACTION_DEREGISTER_CONTEXT_DONE = 17920,
	INTEL_GUC_ACTION_REGISTER_CONTEXT_MULTI_LRC = 17921,
	INTEL_GUC_ACTION_CLIENT_SOFT_RESET = 21767,
	INTEL_GUC_ACTION_SET_ENG_UTIL_BUFF = 21770,
	INTEL_GUC_ACTION_TLB_INVALIDATION = 28672,
	INTEL_GUC_ACTION_TLB_INVALIDATION_DONE = 28673,
	INTEL_GUC_ACTION_STATE_CAPTURE_NOTIFICATION = 32770,
	INTEL_GUC_ACTION_NOTIFY_FLUSH_LOG_BUFFER_TO_FILE = 32771,
	INTEL_GUC_ACTION_NOTIFY_CRASH_DUMP_POSTED = 32772,
	INTEL_GUC_ACTION_NOTIFY_EXCEPTION = 32773,
	INTEL_GUC_ACTION_LIMIT = 32774,
};

enum intel_guc_load_status {
	INTEL_GUC_LOAD_STATUS_DEFAULT = 0,
	INTEL_GUC_LOAD_STATUS_START = 1,
	INTEL_GUC_LOAD_STATUS_ERROR_DEVID_BUILD_MISMATCH = 2,
	INTEL_GUC_LOAD_STATUS_GUC_PREPROD_BUILD_MISMATCH = 3,
	INTEL_GUC_LOAD_STATUS_ERROR_DEVID_INVALID_GUCTYPE = 4,
	INTEL_GUC_LOAD_STATUS_HWCONFIG_START = 5,
	INTEL_GUC_LOAD_STATUS_HWCONFIG_DONE = 6,
	INTEL_GUC_LOAD_STATUS_HWCONFIG_ERROR = 7,
	INTEL_GUC_LOAD_STATUS_GDT_DONE = 16,
	INTEL_GUC_LOAD_STATUS_IDT_DONE = 32,
	INTEL_GUC_LOAD_STATUS_LAPIC_DONE = 48,
	INTEL_GUC_LOAD_STATUS_GUCINT_DONE = 64,
	INTEL_GUC_LOAD_STATUS_DPC_READY = 80,
	INTEL_GUC_LOAD_STATUS_DPC_ERROR = 96,
	INTEL_GUC_LOAD_STATUS_EXCEPTION = 112,
	INTEL_GUC_LOAD_STATUS_INIT_DATA_INVALID = 113,
	INTEL_GUC_LOAD_STATUS_PXP_TEARDOWN_CTRL_ENABLED = 114,
	INTEL_GUC_LOAD_STATUS_INVALID_INIT_DATA_RANGE_START = 115,
	INTEL_GUC_LOAD_STATUS_MPU_DATA_INVALID = 115,
	INTEL_GUC_LOAD_STATUS_INIT_MMIO_SAVE_RESTORE_INVALID = 116,
	INTEL_GUC_LOAD_STATUS_KLV_WORKAROUND_INIT_ERROR = 117,
	INTEL_GUC_LOAD_STATUS_INVALID_INIT_DATA_RANGE_END = 118,
	INTEL_GUC_LOAD_STATUS_READY = 240,
};

enum intel_guc_rc_options {
	INTEL_GUCRC_HOST_CONTROL = 0,
	INTEL_GUCRC_FIRMWARE_CONTROL = 1,
};

enum intel_guc_recv_message {
	INTEL_GUC_RECV_MSG_CRASH_DUMP_POSTED = 2,
	INTEL_GUC_RECV_MSG_EXCEPTION = 1073741824,
};

enum intel_guc_state_capture_event_status {
	INTEL_GUC_STATE_CAPTURE_EVENT_STATUS_SUCCESS = 0,
	INTEL_GUC_STATE_CAPTURE_EVENT_STATUS_NOSPACE = 1,
};

enum intel_guc_tlb_inval_mode {
	INTEL_GUC_TLB_INVAL_MODE_HEAVY = 0,
	INTEL_GUC_TLB_INVAL_MODE_LITE = 1,
};

enum intel_guc_tlb_invalidation_type {
	INTEL_GUC_TLB_INVAL_ENGINES = 0,
	INTEL_GUC_TLB_INVAL_GUC = 3,
};

enum intel_hotplug_state {
	INTEL_HOTPLUG_UNCHANGED = 0,
	INTEL_HOTPLUG_CHANGED = 1,
	INTEL_HOTPLUG_RETRY = 2,
};

enum intel_huc_authentication_type {
	INTEL_HUC_AUTH_BY_GUC = 0,
	INTEL_HUC_AUTH_BY_GSC = 1,
	INTEL_HUC_AUTH_MAX_MODES = 2,
};

enum intel_huc_delayed_load_status {
	INTEL_HUC_WAITING_ON_GSC = 0,
	INTEL_HUC_WAITING_ON_PXP = 1,
	INTEL_HUC_DELAYED_LOAD_ERROR = 2,
};

enum intel_memory_type {
	INTEL_MEMORY_SYSTEM = 0,
	INTEL_MEMORY_LOCAL = 1,
	INTEL_MEMORY_STOLEN_SYSTEM = 2,
	INTEL_MEMORY_STOLEN_LOCAL = 3,
	INTEL_MEMORY_MOCK = 4,
};

enum intel_output_format {
	INTEL_OUTPUT_FORMAT_RGB = 0,
	INTEL_OUTPUT_FORMAT_YCBCR420 = 1,
	INTEL_OUTPUT_FORMAT_YCBCR444 = 2,
};

enum intel_output_type {
	INTEL_OUTPUT_UNUSED = 0,
	INTEL_OUTPUT_ANALOG = 1,
	INTEL_OUTPUT_DVO = 2,
	INTEL_OUTPUT_SDVO = 3,
	INTEL_OUTPUT_LVDS = 4,
	INTEL_OUTPUT_TVOUT = 5,
	INTEL_OUTPUT_HDMI = 6,
	INTEL_OUTPUT_DP = 7,
	INTEL_OUTPUT_EDP = 8,
	INTEL_OUTPUT_DSI = 9,
	INTEL_OUTPUT_DDI = 10,
	INTEL_OUTPUT_DP_MST = 11,
};

enum intel_pch {
	PCH_NOP = -1,
	PCH_NONE = 0,
	PCH_IBX = 1,
	PCH_CPT = 2,
	PCH_LPT = 3,
	PCH_SPT = 4,
	PCH_CNP = 5,
	PCH_ICP = 6,
	PCH_TGP = 7,
	PCH_ADP = 8,
	PCH_DG1 = 1024,
	PCH_DG2 = 1025,
	PCH_MTL = 1026,
	PCH_LNL = 1027,
};

enum intel_pipe_crc_source {
	INTEL_PIPE_CRC_SOURCE_NONE = 0,
	INTEL_PIPE_CRC_SOURCE_PLANE1 = 1,
	INTEL_PIPE_CRC_SOURCE_PLANE2 = 2,
	INTEL_PIPE_CRC_SOURCE_PLANE3 = 3,
	INTEL_PIPE_CRC_SOURCE_PLANE4 = 4,
	INTEL_PIPE_CRC_SOURCE_PLANE5 = 5,
	INTEL_PIPE_CRC_SOURCE_PLANE6 = 6,
	INTEL_PIPE_CRC_SOURCE_PLANE7 = 7,
	INTEL_PIPE_CRC_SOURCE_PIPE = 8,
	INTEL_PIPE_CRC_SOURCE_TV = 9,
	INTEL_PIPE_CRC_SOURCE_DP_B = 10,
	INTEL_PIPE_CRC_SOURCE_DP_C = 11,
	INTEL_PIPE_CRC_SOURCE_DP_D = 12,
	INTEL_PIPE_CRC_SOURCE_AUTO = 13,
	INTEL_PIPE_CRC_SOURCE_MAX = 14,
};

enum intel_platform {
	INTEL_PLATFORM_UNINITIALIZED = 0,
	INTEL_I830 = 1,
	INTEL_I845G = 2,
	INTEL_I85X = 3,
	INTEL_I865G = 4,
	INTEL_I915G = 5,
	INTEL_I915GM = 6,
	INTEL_I945G = 7,
	INTEL_I945GM = 8,
	INTEL_G33 = 9,
	INTEL_PINEVIEW = 10,
	INTEL_I965G = 11,
	INTEL_I965GM = 12,
	INTEL_G45 = 13,
	INTEL_GM45 = 14,
	INTEL_IRONLAKE = 15,
	INTEL_SANDYBRIDGE = 16,
	INTEL_IVYBRIDGE = 17,
	INTEL_VALLEYVIEW = 18,
	INTEL_HASWELL = 19,
	INTEL_BROADWELL = 20,
	INTEL_CHERRYVIEW = 21,
	INTEL_SKYLAKE = 22,
	INTEL_BROXTON = 23,
	INTEL_KABYLAKE = 24,
	INTEL_GEMINILAKE = 25,
	INTEL_COFFEELAKE = 26,
	INTEL_COMETLAKE = 27,
	INTEL_ICELAKE = 28,
	INTEL_ELKHARTLAKE = 29,
	INTEL_JASPERLAKE = 30,
	INTEL_TIGERLAKE = 31,
	INTEL_ROCKETLAKE = 32,
	INTEL_DG1 = 33,
	INTEL_ALDERLAKE_S = 34,
	INTEL_ALDERLAKE_P = 35,
	INTEL_DG2 = 36,
	INTEL_METEORLAKE = 37,
	INTEL_MAX_PLATFORMS = 38,
};

enum intel_ppgtt_type {
	INTEL_PPGTT_NONE = 0,
	INTEL_PPGTT_ALIASING = 1,
	INTEL_PPGTT_FULL = 2,
};

enum intel_quirk_id {
	QUIRK_BACKLIGHT_PRESENT = 0,
	QUIRK_INCREASE_DDI_DISABLED_TIME = 1,
	QUIRK_INCREASE_T12_DELAY = 2,
	QUIRK_INVERT_BRIGHTNESS = 3,
	QUIRK_LVDS_SSC_DISABLE = 4,
	QUIRK_NO_PPS_BACKLIGHT_POWER_HOOK = 5,
	QUIRK_FW_SYNC_LEN = 6,
};

enum intel_rc6_res_type {
	INTEL_RC6_RES_RC6_LOCKED = 0,
	INTEL_RC6_RES_RC6 = 1,
	INTEL_RC6_RES_RC6p = 2,
	INTEL_RC6_RES_RC6pp = 3,
	INTEL_RC6_RES_MAX = 4,
	INTEL_RC6_RES_VLV_MEDIA = 2,
};

enum intel_region_id {
	INTEL_REGION_SMEM = 0,
	INTEL_REGION_LMEM_0 = 1,
	INTEL_REGION_LMEM_1 = 2,
	INTEL_REGION_LMEM_2 = 3,
	INTEL_REGION_LMEM_3 = 4,
	INTEL_REGION_STOLEN_SMEM = 5,
	INTEL_REGION_STOLEN_LMEM = 6,
	INTEL_REGION_UNKNOWN = 7,
};

enum intel_sbi_destination {
	SBI_ICLK = 0,
	SBI_MPHY = 1,
};

enum intel_steering_type {
	L3BANK = 0,
	MSLICE = 1,
	LNCF = 2,
	GAM = 3,
	DSS = 4,
	OADDRM = 5,
	INSTANCE0 = 6,
	NUM_STEERING_TYPES = 7,
};

enum intel_step {
	STEP_NONE = 0,
	STEP_A0 = 1,
	STEP_A1 = 2,
	STEP_A2 = 3,
	STEP_A3 = 4,
	STEP_B0 = 5,
	STEP_B1 = 6,
	STEP_B2 = 7,
	STEP_B3 = 8,
	STEP_C0 = 9,
	STEP_C1 = 10,
	STEP_C2 = 11,
	STEP_C3 = 12,
	STEP_D0 = 13,
	STEP_D1 = 14,
	STEP_D2 = 15,
	STEP_D3 = 16,
	STEP_E0 = 17,
	STEP_E1 = 18,
	STEP_E2 = 19,
	STEP_E3 = 20,
	STEP_F0 = 21,
	STEP_F1 = 22,
	STEP_F2 = 23,
	STEP_F3 = 24,
	STEP_G0 = 25,
	STEP_G1 = 26,
	STEP_G2 = 27,
	STEP_G3 = 28,
	STEP_H0 = 29,
	STEP_H1 = 30,
	STEP_H2 = 31,
	STEP_H3 = 32,
	STEP_I0 = 33,
	STEP_I1 = 34,
	STEP_I2 = 35,
	STEP_I3 = 36,
	STEP_J0 = 37,
	STEP_J1 = 38,
	STEP_J2 = 39,
	STEP_J3 = 40,
	STEP_FUTURE = 41,
	STEP_FOREVER = 42,
};

enum intel_submission_method {
	INTEL_SUBMISSION_RING = 0,
	INTEL_SUBMISSION_ELSP = 1,
	INTEL_SUBMISSION_GUC = 2,
};

enum intel_uc_fw_status {
	INTEL_UC_FIRMWARE_NOT_SUPPORTED = -1,
	INTEL_UC_FIRMWARE_UNINITIALIZED = 0,
	INTEL_UC_FIRMWARE_DISABLED = 1,
	INTEL_UC_FIRMWARE_SELECTED = 2,
	INTEL_UC_FIRMWARE_MISSING = 3,
	INTEL_UC_FIRMWARE_ERROR = 4,
	INTEL_UC_FIRMWARE_AVAILABLE = 5,
	INTEL_UC_FIRMWARE_INIT_FAIL = 6,
	INTEL_UC_FIRMWARE_LOADABLE = 7,
	INTEL_UC_FIRMWARE_LOAD_FAIL = 8,
	INTEL_UC_FIRMWARE_TRANSFERRED = 9,
	INTEL_UC_FIRMWARE_RUNNING = 10,
};

enum intel_uc_fw_type {
	INTEL_UC_FW_TYPE_GUC = 0,
	INTEL_UC_FW_TYPE_HUC = 1,
	INTEL_UC_FW_TYPE_GSC = 2,
};

enum intercept_words {
	INTERCEPT_CR = 0,
	INTERCEPT_DR = 1,
	INTERCEPT_EXCEPTION = 2,
	INTERCEPT_WORD3 = 3,
	INTERCEPT_WORD4 = 4,
	INTERCEPT_WORD5 = 5,
	MAX_INTERCEPT = 6,
};

enum io_pgtable_caps {
	IO_PGTABLE_CAP_CUSTOM_ALLOCATOR = 1,
};

enum io_pgtable_fmt {
	ARM_32_LPAE_S1 = 0,
	ARM_32_LPAE_S2 = 1,
	ARM_64_LPAE_S1 = 2,
	ARM_64_LPAE_S2 = 3,
	ARM_V7S = 4,
	ARM_MALI_LPAE = 5,
	AMD_IOMMU_V1 = 6,
	AMD_IOMMU_V2 = 7,
	APPLE_DART = 8,
	APPLE_DART2 = 9,
	IO_PGTABLE_NUM_FMTS = 10,
};

enum io_uring_cmd_flags {
	IO_URING_F_COMPLETE_DEFER = 1,
	IO_URING_F_UNLOCKED = 2,
	IO_URING_F_MULTISHOT = 4,
	IO_URING_F_IOWQ = 8,
	IO_URING_F_NONBLOCK = -2147483648,
	IO_URING_F_SQE128 = 256,
	IO_URING_F_CQE32 = 512,
	IO_URING_F_IOPOLL = 1024,
	IO_URING_F_CANCEL = 2048,
	IO_URING_F_COMPAT = 4096,
	IO_URING_F_TASK_DEAD = 8192,
};

enum io_uring_msg_ring_flags {
	IORING_MSG_DATA = 0,
	IORING_MSG_SEND_FD = 1,
};

enum io_uring_napi_op {
	IO_URING_NAPI_REGISTER_OP = 0,
	IO_URING_NAPI_STATIC_ADD_ID = 1,
	IO_URING_NAPI_STATIC_DEL_ID = 2,
};

enum io_uring_napi_tracking_strategy {
	IO_URING_NAPI_TRACKING_DYNAMIC = 0,
	IO_URING_NAPI_TRACKING_STATIC = 1,
	IO_URING_NAPI_TRACKING_INACTIVE = 255,
};

enum io_uring_op {
	IORING_OP_NOP = 0,
	IORING_OP_READV = 1,
	IORING_OP_WRITEV = 2,
	IORING_OP_FSYNC = 3,
	IORING_OP_READ_FIXED = 4,
	IORING_OP_WRITE_FIXED = 5,
	IORING_OP_POLL_ADD = 6,
	IORING_OP_POLL_REMOVE = 7,
	IORING_OP_SYNC_FILE_RANGE = 8,
	IORING_OP_SENDMSG = 9,
	IORING_OP_RECVMSG = 10,
	IORING_OP_TIMEOUT = 11,
	IORING_OP_TIMEOUT_REMOVE = 12,
	IORING_OP_ACCEPT = 13,
	IORING_OP_ASYNC_CANCEL = 14,
	IORING_OP_LINK_TIMEOUT = 15,
	IORING_OP_CONNECT = 16,
	IORING_OP_FALLOCATE = 17,
	IORING_OP_OPENAT = 18,
	IORING_OP_CLOSE = 19,
	IORING_OP_FILES_UPDATE = 20,
	IORING_OP_STATX = 21,
	IORING_OP_READ = 22,
	IORING_OP_WRITE = 23,
	IORING_OP_FADVISE = 24,
	IORING_OP_MADVISE = 25,
	IORING_OP_SEND = 26,
	IORING_OP_RECV = 27,
	IORING_OP_OPENAT2 = 28,
	IORING_OP_EPOLL_CTL = 29,
	IORING_OP_SPLICE = 30,
	IORING_OP_PROVIDE_BUFFERS = 31,
	IORING_OP_REMOVE_BUFFERS = 32,
	IORING_OP_TEE = 33,
	IORING_OP_SHUTDOWN = 34,
	IORING_OP_RENAMEAT = 35,
	IORING_OP_UNLINKAT = 36,
	IORING_OP_MKDIRAT = 37,
	IORING_OP_SYMLINKAT = 38,
	IORING_OP_LINKAT = 39,
	IORING_OP_MSG_RING = 40,
	IORING_OP_FSETXATTR = 41,
	IORING_OP_SETXATTR = 42,
	IORING_OP_FGETXATTR = 43,
	IORING_OP_GETXATTR = 44,
	IORING_OP_SOCKET = 45,
	IORING_OP_URING_CMD = 46,
	IORING_OP_SEND_ZC = 47,
	IORING_OP_SENDMSG_ZC = 48,
	IORING_OP_READ_MULTISHOT = 49,
	IORING_OP_WAITID = 50,
	IORING_OP_FUTEX_WAIT = 51,
	IORING_OP_FUTEX_WAKE = 52,
	IORING_OP_FUTEX_WAITV = 53,
	IORING_OP_FIXED_FD_INSTALL = 54,
	IORING_OP_FTRUNCATE = 55,
	IORING_OP_BIND = 56,
	IORING_OP_LISTEN = 57,
	IORING_OP_LAST = 58,
};

enum io_uring_register_op {
	IORING_REGISTER_BUFFERS = 0,
	IORING_UNREGISTER_BUFFERS = 1,
	IORING_REGISTER_FILES = 2,
	IORING_UNREGISTER_FILES = 3,
	IORING_REGISTER_EVENTFD = 4,
	IORING_UNREGISTER_EVENTFD = 5,
	IORING_REGISTER_FILES_UPDATE = 6,
	IORING_REGISTER_EVENTFD_ASYNC = 7,
	IORING_REGISTER_PROBE = 8,
	IORING_REGISTER_PERSONALITY = 9,
	IORING_UNREGISTER_PERSONALITY = 10,
	IORING_REGISTER_RESTRICTIONS = 11,
	IORING_REGISTER_ENABLE_RINGS = 12,
	IORING_REGISTER_FILES2 = 13,
	IORING_REGISTER_FILES_UPDATE2 = 14,
	IORING_REGISTER_BUFFERS2 = 15,
	IORING_REGISTER_BUFFERS_UPDATE = 16,
	IORING_REGISTER_IOWQ_AFF = 17,
	IORING_UNREGISTER_IOWQ_AFF = 18,
	IORING_REGISTER_IOWQ_MAX_WORKERS = 19,
	IORING_REGISTER_RING_FDS = 20,
	IORING_UNREGISTER_RING_FDS = 21,
	IORING_REGISTER_PBUF_RING = 22,
	IORING_UNREGISTER_PBUF_RING = 23,
	IORING_REGISTER_SYNC_CANCEL = 24,
	IORING_REGISTER_FILE_ALLOC_RANGE = 25,
	IORING_REGISTER_PBUF_STATUS = 26,
	IORING_REGISTER_NAPI = 27,
	IORING_UNREGISTER_NAPI = 28,
	IORING_REGISTER_CLOCK = 29,
	IORING_REGISTER_CLONE_BUFFERS = 30,
	IORING_REGISTER_SEND_MSG_RING = 31,
	IORING_REGISTER_RESIZE_RINGS = 33,
	IORING_REGISTER_MEM_REGION = 34,
	IORING_REGISTER_LAST = 35,
	IORING_REGISTER_USE_REGISTERED_RING = 2147483648,
};

enum io_uring_register_pbuf_ring_flags {
	IOU_PBUF_RING_MMAP = 1,
	IOU_PBUF_RING_INC = 2,
};

enum io_uring_register_restriction_op {
	IORING_RESTRICTION_REGISTER_OP = 0,
	IORING_RESTRICTION_SQE_OP = 1,
	IORING_RESTRICTION_SQE_FLAGS_ALLOWED = 2,
	IORING_RESTRICTION_SQE_FLAGS_REQUIRED = 3,
	IORING_RESTRICTION_LAST = 4,
};

enum io_uring_socket_op {
	SOCKET_URING_OP_SIOCINQ = 0,
	SOCKET_URING_OP_SIOCOUTQ = 1,
	SOCKET_URING_OP_GETSOCKOPT = 2,
	SOCKET_URING_OP_SETSOCKOPT = 3,
};

enum io_uring_sqe_flags_bit {
	IOSQE_FIXED_FILE_BIT = 0,
	IOSQE_IO_DRAIN_BIT = 1,
	IOSQE_IO_LINK_BIT = 2,
	IOSQE_IO_HARDLINK_BIT = 3,
	IOSQE_ASYNC_BIT = 4,
	IOSQE_BUFFER_SELECT_BIT = 5,
	IOSQE_CQE_SKIP_SUCCESS_BIT = 6,
};

enum io_wq_cancel {
	IO_WQ_CANCEL_OK = 0,
	IO_WQ_CANCEL_RUNNING = 1,
	IO_WQ_CANCEL_NOTFOUND = 2,
};

enum io_wq_type {
	IO_WQ_BOUND = 0,
	IO_WQ_UNBOUND = 1,
};

enum ioam6_event_attr {
	IOAM6_EVENT_ATTR_UNSPEC = 0,
	IOAM6_EVENT_ATTR_TRACE_NAMESPACE = 1,
	IOAM6_EVENT_ATTR_TRACE_NODELEN = 2,
	IOAM6_EVENT_ATTR_TRACE_TYPE = 3,
	IOAM6_EVENT_ATTR_TRACE_DATA = 4,
	__IOAM6_EVENT_ATTR_MAX = 5,
};

enum ioam6_event_type {
	IOAM6_EVENT_UNSPEC = 0,
	IOAM6_EVENT_TRACE = 1,
};

enum ioapic_domain_type {
	IOAPIC_DOMAIN_INVALID = 0,
	IOAPIC_DOMAIN_LEGACY = 1,
	IOAPIC_DOMAIN_STRICT = 2,
	IOAPIC_DOMAIN_DYNAMIC = 3,
};

enum ioc_running {
	IOC_IDLE = 0,
	IOC_RUNNING = 1,
	IOC_STOP = 2,
};

enum iommu_cap {
	IOMMU_CAP_CACHE_COHERENCY = 0,
	IOMMU_CAP_NOEXEC = 1,
	IOMMU_CAP_PRE_BOOT_PROTECTION = 2,
	IOMMU_CAP_ENFORCE_CACHE_COHERENCY = 3,
	IOMMU_CAP_DEFERRED_FLUSH = 4,
	IOMMU_CAP_DIRTY_TRACKING = 5,
};

enum iommu_dev_features {
	IOMMU_DEV_FEAT_SVA = 0,
	IOMMU_DEV_FEAT_IOPF = 1,
};

enum iommu_dma_cookie_type {
	IOMMU_DMA_IOVA_COOKIE = 0,
	IOMMU_DMA_MSI_COOKIE = 1,
};

enum iommu_dma_queue_type {
	IOMMU_DMA_OPTS_PER_CPU_QUEUE = 0,
	IOMMU_DMA_OPTS_SINGLE_QUEUE = 1,
};

enum iommu_fault_type {
	IOMMU_FAULT_PAGE_REQ = 1,
};

enum iommu_hw_info_type {
	IOMMU_HW_INFO_TYPE_NONE = 0,
	IOMMU_HW_INFO_TYPE_INTEL_VTD = 1,
	IOMMU_HW_INFO_TYPE_ARM_SMMUV3 = 2,
};

enum iommu_hw_info_vtd_flags {
	IOMMU_HW_INFO_VTD_ERRATA_772415_SPR17 = 1,
};

enum iommu_hwpt_data_type {
	IOMMU_HWPT_DATA_NONE = 0,
	IOMMU_HWPT_DATA_VTD_S1 = 1,
	IOMMU_HWPT_DATA_ARM_SMMUV3 = 2,
};

enum iommu_hwpt_invalidate_data_type {
	IOMMU_HWPT_INVALIDATE_DATA_VTD_S1 = 0,
	IOMMU_VIOMMU_INVALIDATE_DATA_ARM_SMMUV3 = 1,
};

enum iommu_hwpt_vtd_s1_flags {
	IOMMU_VTD_S1_SRE = 1,
	IOMMU_VTD_S1_EAFE = 2,
	IOMMU_VTD_S1_WPE = 4,
};

enum iommu_hwpt_vtd_s1_invalidate_flags {
	IOMMU_VTD_INV_FLAGS_LEAF = 1,
};

enum iommu_init_state {
	IOMMU_START_STATE = 0,
	IOMMU_IVRS_DETECTED = 1,
	IOMMU_ACPI_FINISHED = 2,
	IOMMU_ENABLED = 3,
	IOMMU_PCI_INIT = 4,
	IOMMU_INTERRUPTS_EN = 5,
	IOMMU_INITIALIZED = 6,
	IOMMU_NOT_FOUND = 7,
	IOMMU_INIT_ERROR = 8,
	IOMMU_CMDLINE_DISABLED = 9,
};

enum iommu_page_response_code {
	IOMMU_PAGE_RESP_SUCCESS = 0,
	IOMMU_PAGE_RESP_INVALID = 1,
	IOMMU_PAGE_RESP_FAILURE = 2,
};

enum iommu_resv_type {
	IOMMU_RESV_DIRECT = 0,
	IOMMU_RESV_DIRECT_RELAXABLE = 1,
	IOMMU_RESV_RESERVED = 2,
	IOMMU_RESV_MSI = 3,
	IOMMU_RESV_SW_MSI = 4,
};

enum iommufd_hwpt_alloc_flags {
	IOMMU_HWPT_ALLOC_NEST_PARENT = 1,
	IOMMU_HWPT_ALLOC_DIRTY_TRACKING = 2,
	IOMMU_HWPT_FAULT_ID_VALID = 4,
	IOMMU_HWPT_ALLOC_PASID = 8,
};

enum ip6_defrag_users {
	IP6_DEFRAG_LOCAL_DELIVER = 0,
	IP6_DEFRAG_CONNTRACK_IN = 1,
	__IP6_DEFRAG_CONNTRACK_IN = 65536,
	IP6_DEFRAG_CONNTRACK_OUT = 65537,
	__IP6_DEFRAG_CONNTRACK_OUT = 131072,
	IP6_DEFRAG_CONNTRACK_BRIDGE_IN = 131073,
	__IP6_DEFRAG_CONNTRACK_BRIDGE_IN = 196608,
};

enum ip6t_reject_with {
	IP6T_ICMP6_NO_ROUTE = 0,
	IP6T_ICMP6_ADM_PROHIBITED = 1,
	IP6T_ICMP6_NOT_NEIGHBOUR = 2,
	IP6T_ICMP6_ADDR_UNREACH = 3,
	IP6T_ICMP6_PORT_UNREACH = 4,
	IP6T_ICMP6_ECHOREPLY = 5,
	IP6T_TCP_RESET = 6,
	IP6T_ICMP6_POLICY_FAIL = 7,
	IP6T_ICMP6_REJECT_ROUTE = 8,
};

enum ip_conntrack_dir {
	IP_CT_DIR_ORIGINAL = 0,
	IP_CT_DIR_REPLY = 1,
	IP_CT_DIR_MAX = 2,
};

enum ip_conntrack_events {
	IPCT_NEW = 0,
	IPCT_RELATED = 1,
	IPCT_DESTROY = 2,
	IPCT_REPLY = 3,
	IPCT_ASSURED = 4,
	IPCT_PROTOINFO = 5,
	IPCT_HELPER = 6,
	IPCT_MARK = 7,
	IPCT_SEQADJ = 8,
	IPCT_NATSEQADJ = 8,
	IPCT_SECMARK = 9,
	IPCT_LABEL = 10,
	IPCT_SYNPROXY = 11,
	__IPCT_MAX = 12,
};

enum ip_conntrack_expect_events {
	IPEXP_NEW = 0,
	IPEXP_DESTROY = 1,
};

enum ip_conntrack_info {
	IP_CT_ESTABLISHED = 0,
	IP_CT_RELATED = 1,
	IP_CT_NEW = 2,
	IP_CT_IS_REPLY = 3,
	IP_CT_ESTABLISHED_REPLY = 3,
	IP_CT_RELATED_REPLY = 4,
	IP_CT_NUMBER = 5,
	IP_CT_UNTRACKED = 7,
};

enum ip_conntrack_status {
	IPS_EXPECTED_BIT = 0,
	IPS_EXPECTED = 1,
	IPS_SEEN_REPLY_BIT = 1,
	IPS_SEEN_REPLY = 2,
	IPS_ASSURED_BIT = 2,
	IPS_ASSURED = 4,
	IPS_CONFIRMED_BIT = 3,
	IPS_CONFIRMED = 8,
	IPS_SRC_NAT_BIT = 4,
	IPS_SRC_NAT = 16,
	IPS_DST_NAT_BIT = 5,
	IPS_DST_NAT = 32,
	IPS_NAT_MASK = 48,
	IPS_SEQ_ADJUST_BIT = 6,
	IPS_SEQ_ADJUST = 64,
	IPS_SRC_NAT_DONE_BIT = 7,
	IPS_SRC_NAT_DONE = 128,
	IPS_DST_NAT_DONE_BIT = 8,
	IPS_DST_NAT_DONE = 256,
	IPS_NAT_DONE_MASK = 384,
	IPS_DYING_BIT = 9,
	IPS_DYING = 512,
	IPS_FIXED_TIMEOUT_BIT = 10,
	IPS_FIXED_TIMEOUT = 1024,
	IPS_TEMPLATE_BIT = 11,
	IPS_TEMPLATE = 2048,
	IPS_UNTRACKED_BIT = 12,
	IPS_UNTRACKED = 4096,
	IPS_NAT_CLASH_BIT = 12,
	IPS_NAT_CLASH = 4096,
	IPS_HELPER_BIT = 13,
	IPS_HELPER = 8192,
	IPS_OFFLOAD_BIT = 14,
	IPS_OFFLOAD = 16384,
	IPS_HW_OFFLOAD_BIT = 15,
	IPS_HW_OFFLOAD = 32768,
	IPS_UNCHANGEABLE_MASK = 56313,
	__IPS_MAX_BIT = 16,
};

enum ip_defrag_users {
	IP_DEFRAG_LOCAL_DELIVER = 0,
	IP_DEFRAG_CALL_RA_CHAIN = 1,
	IP_DEFRAG_CONNTRACK_IN = 2,
	__IP_DEFRAG_CONNTRACK_IN_END = 65537,
	IP_DEFRAG_CONNTRACK_OUT = 65538,
	__IP_DEFRAG_CONNTRACK_OUT_END = 131073,
	IP_DEFRAG_CONNTRACK_BRIDGE_IN = 131074,
	__IP_DEFRAG_CONNTRACK_BRIDGE_IN = 196609,
	IP_DEFRAG_VS_IN = 196610,
	IP_DEFRAG_VS_OUT = 196611,
	IP_DEFRAG_VS_FWD = 196612,
	IP_DEFRAG_AF_PACKET = 196613,
	IP_DEFRAG_MACVLAN = 196614,
};

enum ipt_reject_with {
	IPT_ICMP_NET_UNREACHABLE = 0,
	IPT_ICMP_HOST_UNREACHABLE = 1,
	IPT_ICMP_PROT_UNREACHABLE = 2,
	IPT_ICMP_PORT_UNREACHABLE = 3,
	IPT_ICMP_ECHOREPLY = 4,
	IPT_ICMP_NET_PROHIBITED = 5,
	IPT_ICMP_HOST_PROHIBITED = 6,
	IPT_TCP_RESET = 7,
	IPT_ICMP_ADMIN_PROHIBITED = 8,
};

enum irq_alloc_type {
	X86_IRQ_ALLOC_TYPE_IOAPIC = 1,
	X86_IRQ_ALLOC_TYPE_HPET = 2,
	X86_IRQ_ALLOC_TYPE_PCI_MSI = 3,
	X86_IRQ_ALLOC_TYPE_PCI_MSIX = 4,
	X86_IRQ_ALLOC_TYPE_DMAR = 5,
	X86_IRQ_ALLOC_TYPE_AMDVI = 6,
	X86_IRQ_ALLOC_TYPE_UV = 7,
};

enum irq_domain_bus_token {
	DOMAIN_BUS_ANY = 0,
	DOMAIN_BUS_WIRED = 1,
	DOMAIN_BUS_GENERIC_MSI = 2,
	DOMAIN_BUS_PCI_MSI = 3,
	DOMAIN_BUS_PLATFORM_MSI = 4,
	DOMAIN_BUS_NEXUS = 5,
	DOMAIN_BUS_IPI = 6,
	DOMAIN_BUS_FSL_MC_MSI = 7,
	DOMAIN_BUS_TI_SCI_INTA_MSI = 8,
	DOMAIN_BUS_WAKEUP = 9,
	DOMAIN_BUS_VMD_MSI = 10,
	DOMAIN_BUS_PCI_DEVICE_MSI = 11,
	DOMAIN_BUS_PCI_DEVICE_MSIX = 12,
	DOMAIN_BUS_DMAR = 13,
	DOMAIN_BUS_AMDVI = 14,
	DOMAIN_BUS_DEVICE_MSI = 15,
	DOMAIN_BUS_WIRED_TO_MSI = 16,
};

enum irq_gc_flags {
	IRQ_GC_INIT_MASK_CACHE = 1,
	IRQ_GC_INIT_NESTED_LOCK = 2,
	IRQ_GC_MASK_CACHE_PER_TYPE = 4,
	IRQ_GC_NO_MASK = 8,
	IRQ_GC_BE_IO = 16,
};

enum irqchip_irq_state {
	IRQCHIP_STATE_PENDING = 0,
	IRQCHIP_STATE_ACTIVE = 1,
	IRQCHIP_STATE_MASKED = 2,
	IRQCHIP_STATE_LINE_LEVEL = 3,
};

enum irqreturn {
	IRQ_NONE = 0,
	IRQ_HANDLED = 1,
	IRQ_WAKE_THREAD = 2,
};

typedef enum irqreturn irqreturn_t;

enum isofs_file_format {
	isofs_file_normal = 0,
	isofs_file_sparse = 1,
	isofs_file_compressed = 2,
};

enum iter_type {
	ITER_UBUF = 0,
	ITER_IOVEC = 1,
	ITER_BVEC = 2,
	ITER_KVEC = 3,
	ITER_FOLIOQ = 4,
	ITER_XARRAY = 5,
	ITER_DISCARD = 6,
};

enum jbd2_shrink_type {
	JBD2_SHRINK_DESTROY = 0,
	JBD2_SHRINK_BUSY_STOP = 1,
	JBD2_SHRINK_BUSY_SKIP = 2,
};

enum jbd_state_bits {
	BH_JBD = 16,
	BH_JWrite = 17,
	BH_Freed = 18,
	BH_Revoked = 19,
	BH_RevokeValid = 20,
	BH_JBDDirty = 21,
	BH_JournalHead = 22,
	BH_Shadow = 23,
	BH_Verified = 24,
	BH_JBDPrivateStart = 25,
};

enum jump_label_type {
	JUMP_LABEL_NOP = 0,
	JUMP_LABEL_JMP = 1,
};

enum kcmp_type {
	KCMP_FILE = 0,
	KCMP_VM = 1,
	KCMP_FILES = 2,
	KCMP_FS = 3,
	KCMP_SIGHAND = 4,
	KCMP_IO = 5,
	KCMP_SYSVSEM = 6,
	KCMP_EPOLL_TFD = 7,
	KCMP_TYPES = 8,
};

enum kcore_type {
	KCORE_TEXT = 0,
	KCORE_VMALLOC = 1,
	KCORE_RAM = 2,
	KCORE_VMEMMAP = 3,
	KCORE_USER = 4,
};

enum kernel_gp_hint {
	GP_NO_HINT = 0,
	GP_NON_CANONICAL = 1,
	GP_CANONICAL = 2,
};

enum kernel_load_data_id {
	LOADING_UNKNOWN = 0,
	LOADING_FIRMWARE = 1,
	LOADING_MODULE = 2,
	LOADING_KEXEC_IMAGE = 3,
	LOADING_KEXEC_INITRAMFS = 4,
	LOADING_POLICY = 5,
	LOADING_X509_CERTIFICATE = 6,
	LOADING_MAX_ID = 7,
};

enum kernel_pkey_operation {
	kernel_pkey_encrypt = 0,
	kernel_pkey_decrypt = 1,
	kernel_pkey_sign = 2,
	kernel_pkey_verify = 3,
};

enum kernel_read_file_id {
	READING_UNKNOWN = 0,
	READING_FIRMWARE = 1,
	READING_MODULE = 2,
	READING_KEXEC_IMAGE = 3,
	READING_KEXEC_INITRAMFS = 4,
	READING_POLICY = 5,
	READING_X509_CERTIFICATE = 6,
	READING_MAX_ID = 7,
};

enum kernfs_node_flag {
	KERNFS_ACTIVATED = 16,
	KERNFS_NS = 32,
	KERNFS_HAS_SEQ_SHOW = 64,
	KERNFS_HAS_MMAP = 128,
	KERNFS_LOCKDEP = 256,
	KERNFS_HIDDEN = 512,
	KERNFS_SUICIDAL = 1024,
	KERNFS_SUICIDED = 2048,
	KERNFS_EMPTY_DIR = 4096,
	KERNFS_HAS_RELEASE = 8192,
	KERNFS_REMOVING = 16384,
};

enum kernfs_node_type {
	KERNFS_DIR = 1,
	KERNFS_FILE = 2,
	KERNFS_LINK = 4,
};

enum kernfs_root_flag {
	KERNFS_ROOT_CREATE_DEACTIVATED = 1,
	KERNFS_ROOT_EXTRA_OPEN_PERM_CHECK = 2,
	KERNFS_ROOT_SUPPORT_EXPORTOP = 4,
	KERNFS_ROOT_SUPPORT_USER_XATTR = 8,
};

enum key_being_used_for {
	VERIFYING_MODULE_SIGNATURE = 0,
	VERIFYING_FIRMWARE_SIGNATURE = 1,
	VERIFYING_KEXEC_PE_SIGNATURE = 2,
	VERIFYING_KEY_SIGNATURE = 3,
	VERIFYING_KEY_SELF_SIGNATURE = 4,
	VERIFYING_UNSPECIFIED_SIGNATURE = 5,
	NR__KEY_BEING_USED_FOR = 6,
};

enum key_lookup_flag {
	KEY_LOOKUP_CREATE = 1,
	KEY_LOOKUP_PARTIAL = 2,
	KEY_LOOKUP_ALL = 3,
};

enum key_need_perm {
	KEY_NEED_UNSPECIFIED = 0,
	KEY_NEED_VIEW = 1,
	KEY_NEED_READ = 2,
	KEY_NEED_WRITE = 3,
	KEY_NEED_SEARCH = 4,
	KEY_NEED_LINK = 5,
	KEY_NEED_SETATTR = 6,
	KEY_NEED_UNLINK = 7,
	KEY_SYSADMIN_OVERRIDE = 8,
	KEY_AUTHTOKEN_OVERRIDE = 9,
	KEY_DEFER_PERM_CHECK = 10,
};

enum key_notification_subtype {
	NOTIFY_KEY_INSTANTIATED = 0,
	NOTIFY_KEY_UPDATED = 1,
	NOTIFY_KEY_LINKED = 2,
	NOTIFY_KEY_UNLINKED = 3,
	NOTIFY_KEY_CLEARED = 4,
	NOTIFY_KEY_REVOKED = 5,
	NOTIFY_KEY_INVALIDATED = 6,
	NOTIFY_KEY_SETATTR = 7,
};

enum key_state {
	KEY_IS_UNINSTANTIATED = 0,
	KEY_IS_POSITIVE = 1,
};

enum kfunc_ptr_arg_type {
	KF_ARG_PTR_TO_CTX = 0,
	KF_ARG_PTR_TO_ALLOC_BTF_ID = 1,
	KF_ARG_PTR_TO_REFCOUNTED_KPTR = 2,
	KF_ARG_PTR_TO_DYNPTR = 3,
	KF_ARG_PTR_TO_ITER = 4,
	KF_ARG_PTR_TO_LIST_HEAD = 5,
	KF_ARG_PTR_TO_LIST_NODE = 6,
	KF_ARG_PTR_TO_BTF_ID = 7,
	KF_ARG_PTR_TO_MEM = 8,
	KF_ARG_PTR_TO_MEM_SIZE = 9,
	KF_ARG_PTR_TO_CALLBACK = 10,
	KF_ARG_PTR_TO_RB_ROOT = 11,
	KF_ARG_PTR_TO_RB_NODE = 12,
	KF_ARG_PTR_TO_NULL = 13,
	KF_ARG_PTR_TO_CONST_STR = 14,
	KF_ARG_PTR_TO_MAP = 15,
	KF_ARG_PTR_TO_WORKQUEUE = 16,
	KF_ARG_PTR_TO_IRQ_FLAG = 17,
};

enum kmalloc_cache_type {
	KMALLOC_NORMAL = 0,
	KMALLOC_CGROUP = 0,
	KMALLOC_RANDOM_START = 0,
	KMALLOC_RANDOM_END = 0,
	KMALLOC_RECLAIM = 1,
	KMALLOC_DMA = 2,
	NR_KMALLOC_TYPES = 3,
};

enum kmsg_dump_reason {
	KMSG_DUMP_UNDEF = 0,
	KMSG_DUMP_PANIC = 1,
	KMSG_DUMP_OOPS = 2,
	KMSG_DUMP_EMERG = 3,
	KMSG_DUMP_SHUTDOWN = 4,
	KMSG_DUMP_MAX = 5,
};

enum kobj_ns_type {
	KOBJ_NS_TYPE_NONE = 0,
	KOBJ_NS_TYPE_NET = 1,
	KOBJ_NS_TYPES = 2,
};

enum kobject_action {
	KOBJ_ADD = 0,
	KOBJ_REMOVE = 1,
	KOBJ_CHANGE = 2,
	KOBJ_MOVE = 3,
	KOBJ_ONLINE = 4,
	KOBJ_OFFLINE = 5,
	KOBJ_BIND = 6,
	KOBJ_UNBIND = 7,
};

enum kprobe_slot_state {
	SLOT_CLEAN = 0,
	SLOT_DIRTY = 1,
	SLOT_USED = 2,
};

enum kvm_apic_logical_mode {
	KVM_APIC_MODE_SW_DISABLED = 0,
	KVM_APIC_MODE_XAPIC_CLUSTER = 1,
	KVM_APIC_MODE_XAPIC_FLAT = 2,
	KVM_APIC_MODE_X2APIC = 3,
	KVM_APIC_MODE_MAP_DISABLED = 4,
};

enum kvm_bus {
	KVM_MMIO_BUS = 0,
	KVM_PIO_BUS = 1,
	KVM_VIRTIO_CCW_NOTIFY_BUS = 2,
	KVM_FAST_MMIO_BUS = 3,
	KVM_IOCSR_BUS = 4,
	KVM_NR_BUSES = 5,
};

enum kvm_irqchip_mode {
	KVM_IRQCHIP_NONE = 0,
	KVM_IRQCHIP_KERNEL = 1,
	KVM_IRQCHIP_SPLIT = 2,
};

enum kvm_only_cpuid_leafs {
	CPUID_12_EAX = 22,
	CPUID_7_1_EDX = 23,
	CPUID_8000_0007_EDX = 24,
	CPUID_8000_0022_EAX = 25,
	CPUID_7_2_EDX = 26,
	CPUID_24_0_EBX = 27,
	NR_KVM_CPU_CAPS = 28,
	NKVMCAPINTS = 6,
};

enum kvm_reg {
	VCPU_REGS_RAX = 0,
	VCPU_REGS_RCX = 1,
	VCPU_REGS_RDX = 2,
	VCPU_REGS_RBX = 3,
	VCPU_REGS_RSP = 4,
	VCPU_REGS_RBP = 5,
	VCPU_REGS_RSI = 6,
	VCPU_REGS_RDI = 7,
	VCPU_REGS_R8 = 8,
	VCPU_REGS_R9 = 9,
	VCPU_REGS_R10 = 10,
	VCPU_REGS_R11 = 11,
	VCPU_REGS_R12 = 12,
	VCPU_REGS_R13 = 13,
	VCPU_REGS_R14 = 14,
	VCPU_REGS_R15 = 15,
	VCPU_REGS_RIP = 16,
	NR_VCPU_REGS = 17,
	VCPU_EXREG_PDPTR = 17,
	VCPU_EXREG_CR0 = 18,
	VCPU_EXREG_CR3 = 19,
	VCPU_EXREG_CR4 = 20,
	VCPU_EXREG_RFLAGS = 21,
	VCPU_EXREG_SEGMENTS = 22,
	VCPU_EXREG_EXIT_INFO_1 = 23,
	VCPU_EXREG_EXIT_INFO_2 = 24,
};

enum kvm_stat_kind {
	KVM_STAT_VM = 0,
	KVM_STAT_VCPU = 1,
};

enum l1d_flush_mitigations {
	L1D_FLUSH_OFF = 0,
	L1D_FLUSH_ON = 1,
};

enum l1tf_mitigations {
	L1TF_MITIGATION_OFF = 0,
	L1TF_MITIGATION_FLUSH_NOWARN = 1,
	L1TF_MITIGATION_FLUSH = 2,
	L1TF_MITIGATION_FLUSH_NOSMT = 3,
	L1TF_MITIGATION_FULL = 4,
	L1TF_MITIGATION_FULL_FORCE = 5,
};

enum l2tp_debug_flags {
	L2TP_MSG_DEBUG = 1,
	L2TP_MSG_CONTROL = 2,
	L2TP_MSG_SEQ = 4,
	L2TP_MSG_DATA = 8,
};

enum label_initialized {
	LABEL_INVALID = 0,
	LABEL_INITIALIZED = 1,
	LABEL_PENDING = 2,
};

enum latency_count {
	COUNTS_10e2 = 0,
	COUNTS_10e3 = 1,
	COUNTS_10e4 = 2,
	COUNTS_10e5 = 3,
	COUNTS_10e6 = 4,
	COUNTS_10e7 = 5,
	COUNTS_10e8_plus = 6,
	COUNTS_MIN = 7,
	COUNTS_MAX = 8,
	COUNTS_SUM = 9,
	COUNTS_NUM = 10,
};

enum latency_range {
	lowest_latency = 0,
	low_latency = 1,
	bulk_latency = 2,
	latency_invalid = 255,
};

enum latency_type {
	DMAR_LATENCY_INV_IOTLB = 0,
	DMAR_LATENCY_INV_DEVTLB = 1,
	DMAR_LATENCY_INV_IEC = 2,
	DMAR_LATENCY_NUM = 3,
};

enum led_brightness {
	LED_OFF = 0,
	LED_ON = 1,
	LED_HALF = 127,
	LED_FULL = 255,
};

enum led_default_state {
	LEDS_DEFSTATE_OFF = 0,
	LEDS_DEFSTATE_ON = 1,
	LEDS_DEFSTATE_KEEP = 2,
};

enum led_mode {
	MO_LED_NORM = 0,
	MO_LED_BLINK = 1,
	MO_LED_OFF = 2,
	MO_LED_ON = 3,
};

enum led_state {
	led_on = 1,
	led_off = 4,
	led_on_559 = 5,
	led_on_557 = 7,
};

enum led_trigger_netdev_modes {
	TRIGGER_NETDEV_LINK = 0,
	TRIGGER_NETDEV_LINK_10 = 1,
	TRIGGER_NETDEV_LINK_100 = 2,
	TRIGGER_NETDEV_LINK_1000 = 3,
	TRIGGER_NETDEV_LINK_2500 = 4,
	TRIGGER_NETDEV_LINK_5000 = 5,
	TRIGGER_NETDEV_LINK_10000 = 6,
	TRIGGER_NETDEV_HALF_DUPLEX = 7,
	TRIGGER_NETDEV_FULL_DUPLEX = 8,
	TRIGGER_NETDEV_TX = 9,
	TRIGGER_NETDEV_RX = 10,
	TRIGGER_NETDEV_TX_ERR = 11,
	TRIGGER_NETDEV_RX_ERR = 12,
	__TRIGGER_NETDEV_MAX = 13,
};

enum legacy_fs_param {
	LEGACY_FS_UNSET_PARAMS = 0,
	LEGACY_FS_MONOLITHIC_PARAMS = 1,
	LEGACY_FS_INDIVIDUAL_PARAMS = 2,
};

enum lg_g15_led_type {
	LG_G15_KBD_BRIGHTNESS = 0,
	LG_G15_LCD_BRIGHTNESS = 1,
	LG_G15_BRIGHTNESS_MAX = 2,
	LG_G15_MACRO_PRESET1 = 2,
	LG_G15_MACRO_PRESET2 = 3,
	LG_G15_MACRO_PRESET3 = 4,
	LG_G15_MACRO_RECORD = 5,
	LG_G15_LED_MAX = 6,
};

enum lg_g15_model {
	LG_G15 = 0,
	LG_G15_V2 = 1,
	LG_G510 = 2,
	LG_G510_USB_AUDIO = 3,
	LG_Z10 = 4,
};

enum limit_by4 {
	NFS4_LIMIT_SIZE = 1,
	NFS4_LIMIT_BLOCKS = 2,
};

enum link_inband_signalling {
	LINK_INBAND_DISABLE = 1,
	LINK_INBAND_ENABLE = 2,
	LINK_INBAND_BYPASS = 4,
};

enum lock_type4 {
	NFS4_UNLOCK_LT = 0,
	NFS4_READ_LT = 1,
	NFS4_WRITE_LT = 2,
	NFS4_READW_LT = 3,
	NFS4_WRITEW_LT = 4,
};

enum lockdep_ok {
	LOCKDEP_STILL_OK = 0,
	LOCKDEP_NOW_UNRELIABLE = 1,
};

enum lockdown_reason {
	LOCKDOWN_NONE = 0,
	LOCKDOWN_MODULE_SIGNATURE = 1,
	LOCKDOWN_DEV_MEM = 2,
	LOCKDOWN_EFI_TEST = 3,
	LOCKDOWN_KEXEC = 4,
	LOCKDOWN_HIBERNATION = 5,
	LOCKDOWN_PCI_ACCESS = 6,
	LOCKDOWN_IOPORT = 7,
	LOCKDOWN_MSR = 8,
	LOCKDOWN_ACPI_TABLES = 9,
	LOCKDOWN_DEVICE_TREE = 10,
	LOCKDOWN_PCMCIA_CIS = 11,
	LOCKDOWN_TIOCSSERIAL = 12,
	LOCKDOWN_MODULE_PARAMETERS = 13,
	LOCKDOWN_MMIOTRACE = 14,
	LOCKDOWN_DEBUGFS = 15,
	LOCKDOWN_XMON_WR = 16,
	LOCKDOWN_BPF_WRITE_USER = 17,
	LOCKDOWN_DBG_WRITE_KERNEL = 18,
	LOCKDOWN_RTAS_ERROR_INJECTION = 19,
	LOCKDOWN_INTEGRITY_MAX = 20,
	LOCKDOWN_KCORE = 21,
	LOCKDOWN_KPROBES = 22,
	LOCKDOWN_BPF_READ_KERNEL = 23,
	LOCKDOWN_DBG_READ_KERNEL = 24,
	LOCKDOWN_PERF = 25,
	LOCKDOWN_TRACEFS = 26,
	LOCKDOWN_XMON_RW = 27,
	LOCKDOWN_XFRM_SECRET = 28,
	LOCKDOWN_CONFIDENTIALITY_MAX = 29,
};

enum loopback {
	lb_none = 0,
	lb_mac = 1,
	lb_phy = 3,
};

enum lru_list {
	LRU_INACTIVE_ANON = 0,
	LRU_ACTIVE_ANON = 1,
	LRU_INACTIVE_FILE = 2,
	LRU_ACTIVE_FILE = 3,
	LRU_UNEVICTABLE = 4,
	NR_LRU_LISTS = 5,
};

enum lru_status {
	LRU_REMOVED = 0,
	LRU_REMOVED_RETRY = 1,
	LRU_ROTATE = 2,
	LRU_SKIP = 3,
	LRU_RETRY = 4,
	LRU_STOP = 5,
};

enum lruvec_flags {
	LRUVEC_CGROUP_CONGESTED = 0,
	LRUVEC_NODE_CONGESTED = 1,
};

enum lsm_event {
	LSM_POLICY_CHANGE = 0,
};

enum lsm_integrity_type {
	LSM_INT_DMVERITY_SIG_VALID = 0,
	LSM_INT_DMVERITY_ROOTHASH = 1,
	LSM_INT_FSVERITY_BUILTINSIG_VALID = 2,
};

enum lsm_order {
	LSM_ORDER_FIRST = -1,
	LSM_ORDER_MUTABLE = 0,
	LSM_ORDER_LAST = 1,
};

enum lspcon_vendor {
	LSPCON_VENDOR_MCA = 0,
	LSPCON_VENDOR_PARADE = 1,
};

enum lw_bits {
	LW_URGENT = 0,
};

enum lwtunnel_encap_types {
	LWTUNNEL_ENCAP_NONE = 0,
	LWTUNNEL_ENCAP_MPLS = 1,
	LWTUNNEL_ENCAP_IP = 2,
	LWTUNNEL_ENCAP_ILA = 3,
	LWTUNNEL_ENCAP_IP6 = 4,
	LWTUNNEL_ENCAP_SEG6 = 5,
	LWTUNNEL_ENCAP_BPF = 6,
	LWTUNNEL_ENCAP_SEG6_LOCAL = 7,
	LWTUNNEL_ENCAP_RPL = 8,
	LWTUNNEL_ENCAP_IOAM6 = 9,
	LWTUNNEL_ENCAP_XFRM = 10,
	__LWTUNNEL_ENCAP_MAX = 11,
};

enum lwtunnel_ip6_t {
	LWTUNNEL_IP6_UNSPEC = 0,
	LWTUNNEL_IP6_ID = 1,
	LWTUNNEL_IP6_DST = 2,
	LWTUNNEL_IP6_SRC = 3,
	LWTUNNEL_IP6_HOPLIMIT = 4,
	LWTUNNEL_IP6_TC = 5,
	LWTUNNEL_IP6_FLAGS = 6,
	LWTUNNEL_IP6_PAD = 7,
	LWTUNNEL_IP6_OPTS = 8,
	__LWTUNNEL_IP6_MAX = 9,
};

enum lwtunnel_ip_t {
	LWTUNNEL_IP_UNSPEC = 0,
	LWTUNNEL_IP_ID = 1,
	LWTUNNEL_IP_DST = 2,
	LWTUNNEL_IP_SRC = 3,
	LWTUNNEL_IP_TTL = 4,
	LWTUNNEL_IP_TOS = 5,
	LWTUNNEL_IP_FLAGS = 6,
	LWTUNNEL_IP_PAD = 7,
	LWTUNNEL_IP_OPTS = 8,
	__LWTUNNEL_IP_MAX = 9,
};

enum lzma2_seq {
	SEQ_CONTROL = 0,
	SEQ_UNCOMPRESSED_1 = 1,
	SEQ_UNCOMPRESSED_2 = 2,
	SEQ_COMPRESSED_0 = 3,
	SEQ_COMPRESSED_1 = 4,
	SEQ_PROPERTIES = 5,
	SEQ_LZMA_PREPARE = 6,
	SEQ_LZMA_RUN = 7,
	SEQ_COPY = 8,
};

enum lzma_state {
	STATE_LIT_LIT = 0,
	STATE_MATCH_LIT_LIT = 1,
	STATE_REP_LIT_LIT = 2,
	STATE_SHORTREP_LIT_LIT = 3,
	STATE_MATCH_LIT = 4,
	STATE_REP_LIT = 5,
	STATE_SHORTREP_LIT = 6,
	STATE_LIT_MATCH = 7,
	STATE_LIT_LONGREP = 8,
	STATE_LIT_SHORTREP = 9,
	STATE_NONLIT_MATCH = 10,
	STATE_NONLIT_REP = 11,
};

enum mac {
	mac_82557_D100_A = 0,
	mac_82557_D100_B = 1,
	mac_82557_D100_C = 2,
	mac_82558_D101_A4 = 4,
	mac_82558_D101_B0 = 5,
	mac_82559_D101M = 8,
	mac_82559_D101S = 9,
	mac_82550_D102 = 12,
	mac_82550_D102_C = 13,
	mac_82551_E = 14,
	mac_82551_F = 15,
	mac_82551_10 = 16,
	mac_unknown = 255,
};

enum mac80211_drop_reason {
	RX_CONTINUE = 1,
	RX_QUEUED = 0,
	RX_DROP_MONITOR = 131072,
	RX_DROP_M_UNEXPECTED_4ADDR_FRAME = 131073,
	RX_DROP_M_BAD_BCN_KEYIDX = 131074,
	RX_DROP_M_BAD_MGMT_KEYIDX = 131075,
	RX_DROP_U_MIC_FAIL = 65537,
	RX_DROP_U_REPLAY = 65538,
	RX_DROP_U_BAD_MMIE = 65539,
	RX_DROP_U_DUP = 65540,
	RX_DROP_U_SPURIOUS = 65541,
	RX_DROP_U_DECRYPT_FAIL = 65542,
	RX_DROP_U_NO_KEY_ID = 65543,
	RX_DROP_U_BAD_CIPHER = 65544,
	RX_DROP_U_OOM = 65545,
	RX_DROP_U_NONSEQ_PN = 65546,
	RX_DROP_U_BAD_KEY_COLOR = 65547,
	RX_DROP_U_BAD_4ADDR = 65548,
	RX_DROP_U_BAD_AMSDU = 65549,
	RX_DROP_U_BAD_AMSDU_CIPHER = 65550,
	RX_DROP_U_INVALID_8023 = 65551,
	RX_DROP_U_RUNT_ACTION = 65552,
	RX_DROP_U_UNPROT_ACTION = 65553,
	RX_DROP_U_UNPROT_DUAL = 65554,
	RX_DROP_U_UNPROT_UCAST_MGMT = 65555,
	RX_DROP_U_UNPROT_MCAST_MGMT = 65556,
	RX_DROP_U_UNPROT_BEACON = 65557,
	RX_DROP_U_UNPROT_UNICAST_PUB_ACTION = 65558,
	RX_DROP_U_UNPROT_ROBUST_ACTION = 65559,
	RX_DROP_U_ACTION_UNKNOWN_SRC = 65560,
	RX_DROP_U_REJECTED_ACTION_RESPONSE = 65561,
	RX_DROP_U_EXPECT_DEFRAG_PROT = 65562,
	RX_DROP_U_WEP_DEC_FAIL = 65563,
	RX_DROP_U_NO_IV = 65564,
	RX_DROP_U_NO_ICV = 65565,
	RX_DROP_U_AP_RX_GROUPCAST = 65566,
	RX_DROP_U_SHORT_MMIC = 65567,
	RX_DROP_U_MMIC_FAIL = 65568,
	RX_DROP_U_SHORT_TKIP = 65569,
	RX_DROP_U_TKIP_FAIL = 65570,
	RX_DROP_U_SHORT_CCMP = 65571,
	RX_DROP_U_SHORT_CCMP_MIC = 65572,
	RX_DROP_U_SHORT_GCMP = 65573,
	RX_DROP_U_SHORT_GCMP_MIC = 65574,
	RX_DROP_U_SHORT_CMAC = 65575,
	RX_DROP_U_SHORT_CMAC256 = 65576,
	RX_DROP_U_SHORT_GMAC = 65577,
	RX_DROP_U_UNEXPECTED_VLAN_4ADDR = 65578,
	RX_DROP_U_UNEXPECTED_STA_4ADDR = 65579,
	RX_DROP_U_UNEXPECTED_VLAN_MCAST = 65580,
	RX_DROP_U_NOT_PORT_CONTROL = 65581,
	RX_DROP_U_UNKNOWN_ACTION_REJECTED = 65582,
};

enum mac80211_rate_control_flags {
	IEEE80211_TX_RC_USE_RTS_CTS = 1,
	IEEE80211_TX_RC_USE_CTS_PROTECT = 2,
	IEEE80211_TX_RC_USE_SHORT_PREAMBLE = 4,
	IEEE80211_TX_RC_MCS = 8,
	IEEE80211_TX_RC_GREEN_FIELD = 16,
	IEEE80211_TX_RC_40_MHZ_WIDTH = 32,
	IEEE80211_TX_RC_DUP_DATA = 64,
	IEEE80211_TX_RC_SHORT_GI = 128,
	IEEE80211_TX_RC_VHT_MCS = 256,
	IEEE80211_TX_RC_80_MHZ_WIDTH = 512,
	IEEE80211_TX_RC_160_MHZ_WIDTH = 1024,
};

enum mac80211_rx_encoding {
	RX_ENC_LEGACY = 0,
	RX_ENC_HT = 1,
	RX_ENC_VHT = 2,
	RX_ENC_HE = 3,
	RX_ENC_EHT = 4,
};

enum mac80211_rx_encoding_flags {
	RX_ENC_FLAG_SHORTPRE = 1,
	RX_ENC_FLAG_SHORT_GI = 4,
	RX_ENC_FLAG_HT_GF = 8,
	RX_ENC_FLAG_STBC_MASK = 48,
	RX_ENC_FLAG_LDPC = 64,
	RX_ENC_FLAG_BF = 128,
};

enum mac80211_rx_flags {
	RX_FLAG_MMIC_ERROR = 1,
	RX_FLAG_DECRYPTED = 2,
	RX_FLAG_ONLY_MONITOR = 4,
	RX_FLAG_MMIC_STRIPPED = 8,
	RX_FLAG_IV_STRIPPED = 16,
	RX_FLAG_FAILED_FCS_CRC = 32,
	RX_FLAG_FAILED_PLCP_CRC = 64,
	RX_FLAG_MACTIME_IS_RTAP_TS64 = 128,
	RX_FLAG_NO_SIGNAL_VAL = 256,
	RX_FLAG_AMPDU_DETAILS = 512,
	RX_FLAG_PN_VALIDATED = 1024,
	RX_FLAG_DUP_VALIDATED = 2048,
	RX_FLAG_AMPDU_LAST_KNOWN = 4096,
	RX_FLAG_AMPDU_IS_LAST = 8192,
	RX_FLAG_AMPDU_DELIM_CRC_ERROR = 16384,
	RX_FLAG_MACTIME = 196608,
	RX_FLAG_MACTIME_PLCP_START = 65536,
	RX_FLAG_MACTIME_START = 131072,
	RX_FLAG_MACTIME_END = 196608,
	RX_FLAG_SKIP_MONITOR = 262144,
	RX_FLAG_AMSDU_MORE = 524288,
	RX_FLAG_RADIOTAP_TLV_AT_END = 1048576,
	RX_FLAG_MIC_STRIPPED = 2097152,
	RX_FLAG_ALLOW_SAME_PN = 4194304,
	RX_FLAG_ICV_STRIPPED = 8388608,
	RX_FLAG_AMPDU_EOF_BIT = 16777216,
	RX_FLAG_AMPDU_EOF_BIT_KNOWN = 33554432,
	RX_FLAG_RADIOTAP_HE = 67108864,
	RX_FLAG_RADIOTAP_HE_MU = 134217728,
	RX_FLAG_RADIOTAP_LSIG = 268435456,
	RX_FLAG_NO_PSDU = 536870912,
	RX_FLAG_8023 = 1073741824,
};

enum mac80211_scan_flags {
	SCAN_SW_SCANNING = 0,
	SCAN_HW_SCANNING = 1,
	SCAN_ONCHANNEL_SCANNING = 2,
	SCAN_COMPLETED = 3,
	SCAN_ABORTED = 4,
	SCAN_HW_CANCELLED = 5,
	SCAN_BEACON_WAIT = 6,
	SCAN_BEACON_DONE = 7,
};

enum mac80211_scan_state {
	SCAN_DECISION = 0,
	SCAN_SET_CHANNEL = 1,
	SCAN_SEND_PROBE = 2,
	SCAN_SUSPEND = 3,
	SCAN_RESUME = 4,
	SCAN_ABORT = 5,
};

enum mac80211_tx_control_flags {
	IEEE80211_TX_CTRL_PORT_CTRL_PROTO = 1,
	IEEE80211_TX_CTRL_PS_RESPONSE = 2,
	IEEE80211_TX_CTRL_RATE_INJECT = 4,
	IEEE80211_TX_CTRL_AMSDU = 8,
	IEEE80211_TX_CTRL_FAST_XMIT = 16,
	IEEE80211_TX_CTRL_SKIP_MPATH_LOOKUP = 32,
	IEEE80211_TX_INTCFL_NEED_TXPROCESSING = 64,
	IEEE80211_TX_CTRL_NO_SEQNO = 128,
	IEEE80211_TX_CTRL_DONT_REORDER = 256,
	IEEE80211_TX_CTRL_MCAST_MLO_FIRST_TX = 512,
	IEEE80211_TX_CTRL_DONT_USE_RATE_MASK = 1024,
	IEEE80211_TX_CTRL_MLO_LINK = 4026531840,
};

enum mac80211_tx_info_flags {
	IEEE80211_TX_CTL_REQ_TX_STATUS = 1,
	IEEE80211_TX_CTL_ASSIGN_SEQ = 2,
	IEEE80211_TX_CTL_NO_ACK = 4,
	IEEE80211_TX_CTL_CLEAR_PS_FILT = 8,
	IEEE80211_TX_CTL_FIRST_FRAGMENT = 16,
	IEEE80211_TX_CTL_SEND_AFTER_DTIM = 32,
	IEEE80211_TX_CTL_AMPDU = 64,
	IEEE80211_TX_CTL_INJECTED = 128,
	IEEE80211_TX_STAT_TX_FILTERED = 256,
	IEEE80211_TX_STAT_ACK = 512,
	IEEE80211_TX_STAT_AMPDU = 1024,
	IEEE80211_TX_STAT_AMPDU_NO_BACK = 2048,
	IEEE80211_TX_CTL_RATE_CTRL_PROBE = 4096,
	IEEE80211_TX_INTFL_OFFCHAN_TX_OK = 8192,
	IEEE80211_TX_CTL_HW_80211_ENCAP = 16384,
	IEEE80211_TX_INTFL_RETRIED = 32768,
	IEEE80211_TX_INTFL_DONT_ENCRYPT = 65536,
	IEEE80211_TX_CTL_NO_PS_BUFFER = 131072,
	IEEE80211_TX_CTL_MORE_FRAMES = 262144,
	IEEE80211_TX_INTFL_RETRANSMISSION = 524288,
	IEEE80211_TX_INTFL_MLME_CONN_TX = 1048576,
	IEEE80211_TX_INTFL_NL80211_FRAME_TX = 2097152,
	IEEE80211_TX_CTL_LDPC = 4194304,
	IEEE80211_TX_CTL_STBC = 25165824,
	IEEE80211_TX_CTL_TX_OFFCHAN = 33554432,
	IEEE80211_TX_INTFL_TKIP_MIC_FAILURE = 67108864,
	IEEE80211_TX_CTL_NO_CCK_RATE = 134217728,
	IEEE80211_TX_STATUS_EOSP = 268435456,
	IEEE80211_TX_CTL_USE_MINRATE = 536870912,
	IEEE80211_TX_CTL_DONTFRAG = 1073741824,
	IEEE80211_TX_STAT_NOACK_TRANSMITTED = 2147483648,
};

enum mac80211_tx_status_flags {
	IEEE80211_TX_STATUS_ACK_SIGNAL_VALID = 1,
};

enum mac_version {
	RTL_GIGA_MAC_VER_02 = 0,
	RTL_GIGA_MAC_VER_03 = 1,
	RTL_GIGA_MAC_VER_04 = 2,
	RTL_GIGA_MAC_VER_05 = 3,
	RTL_GIGA_MAC_VER_06 = 4,
	RTL_GIGA_MAC_VER_07 = 5,
	RTL_GIGA_MAC_VER_08 = 6,
	RTL_GIGA_MAC_VER_09 = 7,
	RTL_GIGA_MAC_VER_10 = 8,
	RTL_GIGA_MAC_VER_14 = 9,
	RTL_GIGA_MAC_VER_17 = 10,
	RTL_GIGA_MAC_VER_18 = 11,
	RTL_GIGA_MAC_VER_19 = 12,
	RTL_GIGA_MAC_VER_20 = 13,
	RTL_GIGA_MAC_VER_21 = 14,
	RTL_GIGA_MAC_VER_22 = 15,
	RTL_GIGA_MAC_VER_23 = 16,
	RTL_GIGA_MAC_VER_24 = 17,
	RTL_GIGA_MAC_VER_25 = 18,
	RTL_GIGA_MAC_VER_26 = 19,
	RTL_GIGA_MAC_VER_28 = 20,
	RTL_GIGA_MAC_VER_29 = 21,
	RTL_GIGA_MAC_VER_30 = 22,
	RTL_GIGA_MAC_VER_31 = 23,
	RTL_GIGA_MAC_VER_32 = 24,
	RTL_GIGA_MAC_VER_33 = 25,
	RTL_GIGA_MAC_VER_34 = 26,
	RTL_GIGA_MAC_VER_35 = 27,
	RTL_GIGA_MAC_VER_36 = 28,
	RTL_GIGA_MAC_VER_37 = 29,
	RTL_GIGA_MAC_VER_38 = 30,
	RTL_GIGA_MAC_VER_39 = 31,
	RTL_GIGA_MAC_VER_40 = 32,
	RTL_GIGA_MAC_VER_42 = 33,
	RTL_GIGA_MAC_VER_43 = 34,
	RTL_GIGA_MAC_VER_44 = 35,
	RTL_GIGA_MAC_VER_46 = 36,
	RTL_GIGA_MAC_VER_48 = 37,
	RTL_GIGA_MAC_VER_51 = 38,
	RTL_GIGA_MAC_VER_52 = 39,
	RTL_GIGA_MAC_VER_53 = 40,
	RTL_GIGA_MAC_VER_61 = 41,
	RTL_GIGA_MAC_VER_63 = 42,
	RTL_GIGA_MAC_VER_64 = 43,
	RTL_GIGA_MAC_VER_65 = 44,
	RTL_GIGA_MAC_VER_66 = 45,
	RTL_GIGA_MAC_VER_70 = 46,
	RTL_GIGA_MAC_VER_71 = 47,
	RTL_GIGA_MAC_NONE = 48,
};

enum maple_status {
	ma_active = 0,
	ma_start = 1,
	ma_root = 2,
	ma_none = 3,
	ma_pause = 4,
	ma_overflow = 5,
	ma_underflow = 6,
	ma_error = 7,
};

enum maple_type {
	maple_dense = 0,
	maple_leaf_64 = 1,
	maple_range_64 = 2,
	maple_arange_64 = 3,
};

enum mapping_flags {
	AS_EIO = 0,
	AS_ENOSPC = 1,
	AS_MM_ALL_LOCKS = 2,
	AS_UNEVICTABLE = 3,
	AS_EXITING = 4,
	AS_NO_WRITEBACK_TAGS = 5,
	AS_RELEASE_ALWAYS = 6,
	AS_STABLE_WRITES = 7,
	AS_INACCESSIBLE = 8,
	AS_FOLIO_ORDER_BITS = 5,
	AS_FOLIO_ORDER_MIN = 16,
	AS_FOLIO_ORDER_MAX = 21,
};

enum mca_msr {
	MCA_CTL = 0,
	MCA_STATUS = 1,
	MCA_ADDR = 2,
	MCA_MISC = 3,
};

enum mce_notifier_prios {
	MCE_PRIO_LOWEST = 0,
	MCE_PRIO_MCELOG = 1,
	MCE_PRIO_EDAC = 2,
	MCE_PRIO_NFIT = 3,
	MCE_PRIO_EXTLOG = 4,
	MCE_PRIO_UC = 5,
	MCE_PRIO_EARLY = 6,
	MCE_PRIO_CEC = 7,
	MCE_PRIO_HIGHEST = 7,
};

enum mcp_flags {
	MCP_TIMESTAMP = 1,
	MCP_UC = 2,
	MCP_DONTLOG = 4,
	MCP_QUEUE_LOG = 8,
};

enum md_ro_state {
	MD_RDWR = 0,
	MD_RDONLY = 1,
	MD_AUTO_READ = 2,
	MD_MAX_STATE = 3,
};

enum mddev_flags {
	MD_ARRAY_FIRST_USE = 0,
	MD_CLOSING = 1,
	MD_JOURNAL_CLEAN = 2,
	MD_HAS_JOURNAL = 3,
	MD_CLUSTER_RESYNC_LOCKED = 4,
	MD_FAILFAST_SUPPORTED = 5,
	MD_HAS_PPL = 6,
	MD_HAS_MULTIPLE_PPLS = 7,
	MD_NOT_READY = 8,
	MD_BROKEN = 9,
	MD_DELETED = 10,
};

enum mddev_sb_flags {
	MD_SB_CHANGE_DEVS = 0,
	MD_SB_CHANGE_CLEAN = 1,
	MD_SB_CHANGE_PENDING = 2,
	MD_SB_NEED_REWRITE = 3,
};

enum mdi_ctrl {
	mdi_write = 67108864,
	mdi_read = 134217728,
	mdi_ready = 268435456,
};

enum mds_mitigations {
	MDS_MITIGATION_OFF = 0,
	MDS_MITIGATION_FULL = 1,
	MDS_MITIGATION_VMWERV = 2,
};

enum mei_cb_file_ops {
	MEI_FOP_READ = 0,
	MEI_FOP_WRITE = 1,
	MEI_FOP_CONNECT = 2,
	MEI_FOP_DISCONNECT = 3,
	MEI_FOP_DISCONNECT_RSP = 4,
	MEI_FOP_NOTIFY_START = 5,
	MEI_FOP_NOTIFY_STOP = 6,
	MEI_FOP_DMA_MAP = 7,
	MEI_FOP_DMA_UNMAP = 8,
};

enum mei_cfg_idx {
	MEI_ME_UNDEF_CFG = 0,
	MEI_ME_ICH_CFG = 1,
	MEI_ME_ICH10_CFG = 2,
	MEI_ME_PCH6_CFG = 3,
	MEI_ME_PCH7_CFG = 4,
	MEI_ME_PCH_CPT_PBG_CFG = 5,
	MEI_ME_PCH8_CFG = 6,
	MEI_ME_PCH8_ITOUCH_CFG = 7,
	MEI_ME_PCH8_SPS_4_CFG = 8,
	MEI_ME_PCH12_CFG = 9,
	MEI_ME_PCH12_SPS_4_CFG = 10,
	MEI_ME_PCH12_SPS_CFG = 11,
	MEI_ME_PCH12_SPS_ITOUCH_CFG = 12,
	MEI_ME_PCH15_CFG = 13,
	MEI_ME_PCH15_SPS_CFG = 14,
	MEI_ME_GSC_CFG = 15,
	MEI_ME_GSCFI_CFG = 16,
	MEI_ME_NUM_CFG = 17,
};

enum mei_cl_connect_status {
	MEI_CL_CONN_SUCCESS = 0,
	MEI_CL_CONN_NOT_FOUND = 1,
	MEI_CL_CONN_ALREADY_STARTED = 2,
	MEI_CL_CONN_OUT_OF_RESOURCES = 3,
	MEI_CL_CONN_MESSAGE_SMALL = 4,
	MEI_CL_CONN_NOT_ALLOWED = 5,
};

enum mei_cl_disconnect_status {
	MEI_CL_DISCONN_SUCCESS = 0,
};

enum mei_cl_io_mode {
	MEI_CL_IO_TX_BLOCKING = 1,
	MEI_CL_IO_TX_INTERNAL = 2,
	MEI_CL_IO_RX_NONBLOCK = 4,
	MEI_CL_IO_SGL = 8,
};

enum mei_dev_pxp_mode {
	MEI_DEV_PXP_DEFAULT = 0,
	MEI_DEV_PXP_INIT = 1,
	MEI_DEV_PXP_SETUP = 2,
	MEI_DEV_PXP_READY = 3,
};

enum mei_dev_reset_to_pxp {
	MEI_DEV_RESET_TO_PXP_DEFAULT = 0,
	MEI_DEV_RESET_TO_PXP_PERFORMED = 1,
	MEI_DEV_RESET_TO_PXP_DONE = 2,
};

enum mei_dev_state {
	MEI_DEV_INITIALIZING = 0,
	MEI_DEV_INIT_CLIENTS = 1,
	MEI_DEV_ENABLED = 2,
	MEI_DEV_RESETTING = 3,
	MEI_DEV_DISABLED = 4,
	MEI_DEV_POWERING_DOWN = 5,
	MEI_DEV_POWER_DOWN = 6,
	MEI_DEV_POWER_UP = 7,
};

enum mei_ext_hdr_type {
	MEI_EXT_HDR_NONE = 0,
	MEI_EXT_HDR_VTAG = 1,
	MEI_EXT_HDR_GSC = 2,
};

enum mei_file_transaction_states {
	MEI_IDLE = 0,
	MEI_WRITING = 1,
	MEI_WRITE_COMPLETE = 2,
};

enum mei_hbm_state {
	MEI_HBM_IDLE = 0,
	MEI_HBM_STARTING = 1,
	MEI_HBM_CAP_SETUP = 2,
	MEI_HBM_DR_SETUP = 3,
	MEI_HBM_ENUM_CLIENTS = 4,
	MEI_HBM_CLIENT_PROPERTIES = 5,
	MEI_HBM_STARTED = 6,
	MEI_HBM_STOPPED = 7,
};

enum mei_hbm_status {
	MEI_HBMS_SUCCESS = 0,
	MEI_HBMS_CLIENT_NOT_FOUND = 1,
	MEI_HBMS_ALREADY_EXISTS = 2,
	MEI_HBMS_REJECTED = 3,
	MEI_HBMS_INVALID_PARAMETER = 4,
	MEI_HBMS_NOT_ALLOWED = 5,
	MEI_HBMS_ALREADY_STARTED = 6,
	MEI_HBMS_NOT_STARTED = 7,
	MEI_HBMS_MAX = 8,
};

enum mei_pg_event {
	MEI_PG_EVENT_IDLE = 0,
	MEI_PG_EVENT_WAIT = 1,
	MEI_PG_EVENT_RECEIVED = 2,
	MEI_PG_EVENT_INTR_WAIT = 3,
	MEI_PG_EVENT_INTR_RECEIVED = 4,
};

enum mei_pg_state {
	MEI_PG_OFF = 0,
	MEI_PG_ON = 1,
};

enum mei_stop_reason_types {
	DRIVER_STOP_REQUEST = 0,
	DEVICE_D1_ENTRY = 1,
	DEVICE_D2_ENTRY = 2,
	DEVICE_D3_ENTRY = 3,
	SYSTEM_S1_ENTRY = 4,
	SYSTEM_S2_ENTRY = 5,
	SYSTEM_S3_ENTRY = 6,
	SYSTEM_S4_ENTRY = 7,
	SYSTEM_S5_ENTRY = 8,
};

enum membarrier_cmd {
	MEMBARRIER_CMD_QUERY = 0,
	MEMBARRIER_CMD_GLOBAL = 1,
	MEMBARRIER_CMD_GLOBAL_EXPEDITED = 2,
	MEMBARRIER_CMD_REGISTER_GLOBAL_EXPEDITED = 4,
	MEMBARRIER_CMD_PRIVATE_EXPEDITED = 8,
	MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED = 16,
	MEMBARRIER_CMD_PRIVATE_EXPEDITED_SYNC_CORE = 32,
	MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED_SYNC_CORE = 64,
	MEMBARRIER_CMD_PRIVATE_EXPEDITED_RSEQ = 128,
	MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED_RSEQ = 256,
	MEMBARRIER_CMD_GET_REGISTRATIONS = 512,
	MEMBARRIER_CMD_SHARED = 1,
};

enum membarrier_cmd_flag {
	MEMBARRIER_CMD_FLAG_CPU = 1,
};

enum memblock_flags {
	MEMBLOCK_NONE = 0,
	MEMBLOCK_HOTPLUG = 1,
	MEMBLOCK_MIRROR = 2,
	MEMBLOCK_NOMAP = 4,
	MEMBLOCK_DRIVER_MANAGED = 8,
	MEMBLOCK_RSRV_NOINIT = 16,
};

enum memcg_memory_event {
	MEMCG_LOW = 0,
	MEMCG_HIGH = 1,
	MEMCG_MAX = 2,
	MEMCG_OOM = 3,
	MEMCG_OOM_KILL = 4,
	MEMCG_OOM_GROUP_KILL = 5,
	MEMCG_SWAP_HIGH = 6,
	MEMCG_SWAP_MAX = 7,
	MEMCG_SWAP_FAIL = 8,
	MEMCG_NR_MEMORY_EVENTS = 9,
};

enum memcg_stat_item {
	MEMCG_SWAP = 46,
	MEMCG_SOCK = 47,
	MEMCG_PERCPU_B = 48,
	MEMCG_VMALLOC = 49,
	MEMCG_KMEM = 50,
	MEMCG_ZSWAP_B = 51,
	MEMCG_ZSWAPPED = 52,
	MEMCG_NR_STAT = 53,
};

enum meminit_context {
	MEMINIT_EARLY = 0,
	MEMINIT_HOTPLUG = 1,
};

enum memory_type {
	MEMORY_DEVICE_PRIVATE = 1,
	MEMORY_DEVICE_COHERENT = 2,
	MEMORY_DEVICE_FS_DAX = 3,
	MEMORY_DEVICE_GENERIC = 4,
	MEMORY_DEVICE_PCI_P2PDMA = 5,
};

enum mesh_path_flags {
	MESH_PATH_ACTIVE = 1,
	MESH_PATH_RESOLVING = 2,
	MESH_PATH_SN_VALID = 4,
	MESH_PATH_FIXED = 8,
	MESH_PATH_RESOLVED = 16,
	MESH_PATH_REQ_QUEUED = 32,
	MESH_PATH_DELETED = 64,
};

enum metadata_type {
	METADATA_IP_TUNNEL = 0,
	METADATA_HW_PORT_MUX = 1,
	METADATA_MACSEC = 2,
	METADATA_XFRM = 3,
};

enum mf_flags {
	MF_COUNT_INCREASED = 1,
	MF_ACTION_REQUIRED = 2,
	MF_MUST_KILL = 4,
	MF_SOFT_OFFLINE = 8,
	MF_UNPOISON = 16,
	MF_SW_SIMULATED = 32,
	MF_NO_RETRY = 64,
	MF_MEM_PRE_REMOVE = 128,
};

enum migrate_mode {
	MIGRATE_ASYNC = 0,
	MIGRATE_SYNC_LIGHT = 1,
	MIGRATE_SYNC = 2,
};

enum migrate_reason {
	MR_COMPACTION = 0,
	MR_MEMORY_FAILURE = 1,
	MR_MEMORY_HOTPLUG = 2,
	MR_SYSCALL = 3,
	MR_MEMPOLICY_MBIND = 4,
	MR_NUMA_MISPLACED = 5,
	MR_CONTIG_RANGE = 6,
	MR_LONGTERM_PIN = 7,
	MR_DEMOTION = 8,
	MR_DAMON = 9,
	MR_TYPES = 10,
};

enum migratetype {
	MIGRATE_UNMOVABLE = 0,
	MIGRATE_MOVABLE = 1,
	MIGRATE_RECLAIMABLE = 2,
	MIGRATE_PCPTYPES = 3,
	MIGRATE_HIGHATOMIC = 3,
	MIGRATE_TYPES = 4,
};

enum migration_type {
	migrate_load = 0,
	migrate_util = 1,
	migrate_task = 2,
	migrate_misfit = 3,
};

enum minstrel_sample_type {
	MINSTREL_SAMPLE_TYPE_INC = 0,
	MINSTREL_SAMPLE_TYPE_JUMP = 1,
	MINSTREL_SAMPLE_TYPE_SLOW = 2,
	__MINSTREL_SAMPLE_TYPE_MAX = 3,
};

enum mipi_dsi_compression_algo {
	MIPI_DSI_COMPRESSION_DSC = 0,
	MIPI_DSI_COMPRESSION_VENDOR = 3,
};

enum mipi_dsi_dcs_tear_mode {
	MIPI_DSI_DCS_TEAR_MODE_VBLANK = 0,
	MIPI_DSI_DCS_TEAR_MODE_VHBLANK = 1,
};

enum mipi_dsi_pixel_format {
	MIPI_DSI_FMT_RGB888 = 0,
	MIPI_DSI_FMT_RGB666 = 1,
	MIPI_DSI_FMT_RGB666_PACKED = 2,
	MIPI_DSI_FMT_RGB565 = 3,
};

enum mipi_seq {
	MIPI_SEQ_END = 0,
	MIPI_SEQ_DEASSERT_RESET = 1,
	MIPI_SEQ_INIT_OTP = 2,
	MIPI_SEQ_DISPLAY_ON = 3,
	MIPI_SEQ_DISPLAY_OFF = 4,
	MIPI_SEQ_ASSERT_RESET = 5,
	MIPI_SEQ_BACKLIGHT_ON = 6,
	MIPI_SEQ_BACKLIGHT_OFF = 7,
	MIPI_SEQ_TEAR_ON = 8,
	MIPI_SEQ_TEAR_OFF = 9,
	MIPI_SEQ_POWER_ON = 10,
	MIPI_SEQ_POWER_OFF = 11,
	MIPI_SEQ_MAX = 12,
};

enum mipi_seq_element {
	MIPI_SEQ_ELEM_END = 0,
	MIPI_SEQ_ELEM_SEND_PKT = 1,
	MIPI_SEQ_ELEM_DELAY = 2,
	MIPI_SEQ_ELEM_GPIO = 3,
	MIPI_SEQ_ELEM_I2C = 4,
	MIPI_SEQ_ELEM_SPI = 5,
	MIPI_SEQ_ELEM_PMIC = 6,
	MIPI_SEQ_ELEM_MAX = 7,
};

enum misc_res_type {
	MISC_CG_RES_TYPES = 0,
};

enum mm_cid_state {
	MM_CID_UNSET = 4294967295,
	MM_CID_LAZY_PUT = 2147483648,
};

enum mminit_level {
	MMINIT_WARNING = 0,
	MMINIT_VERIFY = 1,
	MMINIT_TRACE = 2,
};

enum mmio_mitigations {
	MMIO_MITIGATION_OFF = 0,
	MMIO_MITIGATION_UCODE_NEEDED = 1,
	MMIO_MITIGATION_VERW = 2,
};

enum mmu_notifier_event {
	MMU_NOTIFY_UNMAP = 0,
	MMU_NOTIFY_CLEAR = 1,
	MMU_NOTIFY_PROTECTION_VMA = 2,
	MMU_NOTIFY_PROTECTION_PAGE = 3,
	MMU_NOTIFY_SOFT_DIRTY = 4,
	MMU_NOTIFY_RELEASE = 5,
	MMU_NOTIFY_MIGRATE = 6,
	MMU_NOTIFY_EXCLUSIVE = 7,
};

enum mnt_tree_flags_t {
	MNT_TREE_MOVE = 1,
	MNT_TREE_BENEATH = 2,
};

enum mod_license {
	NOT_GPL_ONLY = 0,
	GPL_ONLY = 1,
};

enum mod_mem_type {
	MOD_TEXT = 0,
	MOD_DATA = 1,
	MOD_RODATA = 2,
	MOD_RO_AFTER_INIT = 3,
	MOD_INIT_TEXT = 4,
	MOD_INIT_DATA = 5,
	MOD_INIT_RODATA = 6,
	MOD_MEM_NUM_TYPES = 7,
	MOD_INVALID = -1,
};

enum mode_set_atomic {
	LEAVE_ATOMIC_MODE_SET = 0,
	ENTER_ATOMIC_MODE_SET = 1,
};

enum module_state {
	MODULE_STATE_LIVE = 0,
	MODULE_STATE_COMING = 1,
	MODULE_STATE_GOING = 2,
	MODULE_STATE_UNFORMED = 3,
};

enum monitor_flags {
	MONITOR_FLAG_CHANGED = 1,
	MONITOR_FLAG_FCSFAIL = 2,
	MONITOR_FLAG_PLCPFAIL = 4,
	MONITOR_FLAG_CONTROL = 8,
	MONITOR_FLAG_OTHER_BSS = 16,
	MONITOR_FLAG_COOK_FRAMES = 32,
	MONITOR_FLAG_ACTIVE = 64,
	MONITOR_FLAG_SKIP_TX = 128,
};

enum mountstat {
	MNT_OK = 0,
	MNT_EPERM = 1,
	MNT_ENOENT = 2,
	MNT_EACCES = 13,
	MNT_EINVAL = 22,
};

enum mountstat3 {
	MNT3_OK = 0,
	MNT3ERR_PERM = 1,
	MNT3ERR_NOENT = 2,
	MNT3ERR_IO = 5,
	MNT3ERR_ACCES = 13,
	MNT3ERR_NOTDIR = 20,
	MNT3ERR_INVAL = 22,
	MNT3ERR_NAMETOOLONG = 63,
	MNT3ERR_NOTSUPP = 10004,
	MNT3ERR_SERVERFAULT = 10006,
};

enum mp_irq_source_types {
	mp_INT = 0,
	mp_NMI = 1,
	mp_SMI = 2,
	mp_ExtINT = 3,
};

enum mpath_info_flags {
	MPATH_INFO_FRAME_QLEN = 1,
	MPATH_INFO_SN = 2,
	MPATH_INFO_METRIC = 4,
	MPATH_INFO_EXPTIME = 8,
	MPATH_INFO_DISCOVERY_TIMEOUT = 16,
	MPATH_INFO_DISCOVERY_RETRIES = 32,
	MPATH_INFO_FLAGS = 64,
	MPATH_INFO_HOP_COUNT = 128,
	MPATH_INFO_PATH_CHANGE = 256,
};

enum mq_rq_state {
	MQ_RQ_IDLE = 0,
	MQ_RQ_IN_FLIGHT = 1,
	MQ_RQ_COMPLETE = 2,
};

enum msdos_sys_ind {
	DOS_EXTENDED_PARTITION = 5,
	LINUX_EXTENDED_PARTITION = 133,
	WIN98_EXTENDED_PARTITION = 15,
	LINUX_DATA_PARTITION = 131,
	LINUX_LVM_PARTITION = 142,
	LINUX_RAID_PARTITION = 253,
	SOLARIS_X86_PARTITION = 130,
	NEW_SOLARIS_X86_PARTITION = 191,
	DM6_AUX1PARTITION = 81,
	DM6_AUX3PARTITION = 83,
	DM6_PARTITION = 84,
	EZD_PARTITION = 85,
	FREEBSD_PARTITION = 165,
	OPENBSD_PARTITION = 166,
	NETBSD_PARTITION = 169,
	BSDI_PARTITION = 183,
	MINIX_PARTITION = 129,
	UNIXWARE_PARTITION = 99,
};

enum msi_desc_filter {
	MSI_DESC_ALL = 0,
	MSI_DESC_NOTASSOCIATED = 1,
	MSI_DESC_ASSOCIATED = 2,
};

enum msi_domain_ids {
	MSI_DEFAULT_DOMAIN = 0,
	MSI_MAX_DEVICE_IRQDOMAINS = 1,
};

enum mthp_stat_item {
	MTHP_STAT_ANON_FAULT_ALLOC = 0,
	MTHP_STAT_ANON_FAULT_FALLBACK = 1,
	MTHP_STAT_ANON_FAULT_FALLBACK_CHARGE = 2,
	MTHP_STAT_ZSWPOUT = 3,
	MTHP_STAT_SWPIN = 4,
	MTHP_STAT_SWPIN_FALLBACK = 5,
	MTHP_STAT_SWPIN_FALLBACK_CHARGE = 6,
	MTHP_STAT_SWPOUT = 7,
	MTHP_STAT_SWPOUT_FALLBACK = 8,
	MTHP_STAT_SHMEM_ALLOC = 9,
	MTHP_STAT_SHMEM_FALLBACK = 10,
	MTHP_STAT_SHMEM_FALLBACK_CHARGE = 11,
	MTHP_STAT_SPLIT = 12,
	MTHP_STAT_SPLIT_FAILED = 13,
	MTHP_STAT_SPLIT_DEFERRED = 14,
	MTHP_STAT_NR_ANON = 15,
	MTHP_STAT_NR_ANON_PARTIALLY_MAPPED = 16,
	__MTHP_STAT_COUNT = 17,
};

enum multi_stop_state {
	MULTI_STOP_NONE = 0,
	MULTI_STOP_PREPARE = 1,
	MULTI_STOP_DISABLE_IRQ = 2,
	MULTI_STOP_RUN = 3,
	MULTI_STOP_EXIT = 4,
};

enum nbcon_prio {
	NBCON_PRIO_NONE = 0,
	NBCON_PRIO_NORMAL = 1,
	NBCON_PRIO_EMERGENCY = 2,
	NBCON_PRIO_PANIC = 3,
	NBCON_PRIO_MAX = 4,
};

enum net_device_flags {
	IFF_UP = 1,
	IFF_BROADCAST = 2,
	IFF_DEBUG = 4,
	IFF_LOOPBACK = 8,
	IFF_POINTOPOINT = 16,
	IFF_NOTRAILERS = 32,
	IFF_RUNNING = 64,
	IFF_NOARP = 128,
	IFF_PROMISC = 256,
	IFF_ALLMULTI = 512,
	IFF_MASTER = 1024,
	IFF_SLAVE = 2048,
	IFF_MULTICAST = 4096,
	IFF_PORTSEL = 8192,
	IFF_AUTOMEDIA = 16384,
	IFF_DYNAMIC = 32768,
	IFF_LOWER_UP = 65536,
	IFF_DORMANT = 131072,
	IFF_ECHO = 262144,
};

enum net_device_path_type {
	DEV_PATH_ETHERNET = 0,
	DEV_PATH_VLAN = 1,
	DEV_PATH_BRIDGE = 2,
	DEV_PATH_PPPOE = 3,
	DEV_PATH_DSA = 4,
	DEV_PATH_MTK_WDMA = 5,
};

enum net_xmit_qdisc_t {
	__NET_XMIT_STOLEN = 65536,
	__NET_XMIT_BYPASS = 131072,
};

enum netdev_cmd {
	NETDEV_UP = 1,
	NETDEV_DOWN = 2,
	NETDEV_REBOOT = 3,
	NETDEV_CHANGE = 4,
	NETDEV_REGISTER = 5,
	NETDEV_UNREGISTER = 6,
	NETDEV_CHANGEMTU = 7,
	NETDEV_CHANGEADDR = 8,
	NETDEV_PRE_CHANGEADDR = 9,
	NETDEV_GOING_DOWN = 10,
	NETDEV_CHANGENAME = 11,
	NETDEV_FEAT_CHANGE = 12,
	NETDEV_BONDING_FAILOVER = 13,
	NETDEV_PRE_UP = 14,
	NETDEV_PRE_TYPE_CHANGE = 15,
	NETDEV_POST_TYPE_CHANGE = 16,
	NETDEV_POST_INIT = 17,
	NETDEV_PRE_UNINIT = 18,
	NETDEV_RELEASE = 19,
	NETDEV_NOTIFY_PEERS = 20,
	NETDEV_JOIN = 21,
	NETDEV_CHANGEUPPER = 22,
	NETDEV_RESEND_IGMP = 23,
	NETDEV_PRECHANGEMTU = 24,
	NETDEV_CHANGEINFODATA = 25,
	NETDEV_BONDING_INFO = 26,
	NETDEV_PRECHANGEUPPER = 27,
	NETDEV_CHANGELOWERSTATE = 28,
	NETDEV_UDP_TUNNEL_PUSH_INFO = 29,
	NETDEV_UDP_TUNNEL_DROP_INFO = 30,
	NETDEV_CHANGE_TX_QUEUE_LEN = 31,
	NETDEV_CVLAN_FILTER_PUSH_INFO = 32,
	NETDEV_CVLAN_FILTER_DROP_INFO = 33,
	NETDEV_SVLAN_FILTER_PUSH_INFO = 34,
	NETDEV_SVLAN_FILTER_DROP_INFO = 35,
	NETDEV_OFFLOAD_XSTATS_ENABLE = 36,
	NETDEV_OFFLOAD_XSTATS_DISABLE = 37,
	NETDEV_OFFLOAD_XSTATS_REPORT_USED = 38,
	NETDEV_OFFLOAD_XSTATS_REPORT_DELTA = 39,
	NETDEV_XDP_FEAT_CHANGE = 40,
};

enum netdev_lag_hash {
	NETDEV_LAG_HASH_NONE = 0,
	NETDEV_LAG_HASH_L2 = 1,
	NETDEV_LAG_HASH_L34 = 2,
	NETDEV_LAG_HASH_L23 = 3,
	NETDEV_LAG_HASH_E23 = 4,
	NETDEV_LAG_HASH_E34 = 5,
	NETDEV_LAG_HASH_VLAN_SRCMAC = 6,
	NETDEV_LAG_HASH_UNKNOWN = 7,
};

enum netdev_lag_tx_type {
	NETDEV_LAG_TX_TYPE_UNKNOWN = 0,
	NETDEV_LAG_TX_TYPE_RANDOM = 1,
	NETDEV_LAG_TX_TYPE_BROADCAST = 2,
	NETDEV_LAG_TX_TYPE_ROUNDROBIN = 3,
	NETDEV_LAG_TX_TYPE_ACTIVEBACKUP = 4,
	NETDEV_LAG_TX_TYPE_HASH = 5,
};

enum netdev_ml_priv_type {
	ML_PRIV_NONE = 0,
	ML_PRIV_CAN = 1,
};

enum netdev_offload_xstats_type {
	NETDEV_OFFLOAD_XSTATS_TYPE_L3 = 1,
};

enum netdev_priv_flags {
	IFF_802_1Q_VLAN = 1,
	IFF_EBRIDGE = 2,
	IFF_BONDING = 4,
	IFF_ISATAP = 8,
	IFF_WAN_HDLC = 16,
	IFF_XMIT_DST_RELEASE = 32,
	IFF_DONT_BRIDGE = 64,
	IFF_DISABLE_NETPOLL = 128,
	IFF_MACVLAN_PORT = 256,
	IFF_BRIDGE_PORT = 512,
	IFF_OVS_DATAPATH = 1024,
	IFF_TX_SKB_SHARING = 2048,
	IFF_UNICAST_FLT = 4096,
	IFF_TEAM_PORT = 8192,
	IFF_SUPP_NOFCS = 16384,
	IFF_LIVE_ADDR_CHANGE = 32768,
	IFF_MACVLAN = 65536,
	IFF_XMIT_DST_RELEASE_PERM = 131072,
	IFF_L3MDEV_MASTER = 262144,
	IFF_NO_QUEUE = 524288,
	IFF_OPENVSWITCH = 1048576,
	IFF_L3MDEV_SLAVE = 2097152,
	IFF_TEAM = 4194304,
	IFF_RXFH_CONFIGURED = 8388608,
	IFF_PHONY_HEADROOM = 16777216,
	IFF_MACSEC = 33554432,
	IFF_NO_RX_HANDLER = 67108864,
	IFF_FAILOVER = 134217728,
	IFF_FAILOVER_SLAVE = 268435456,
	IFF_L3MDEV_RX_HANDLER = 536870912,
	IFF_NO_ADDRCONF = 1073741824,
	IFF_TX_SKB_NO_LINEAR = 2147483648,
};

enum netdev_qstats_scope {
	NETDEV_QSTATS_SCOPE_QUEUE = 1,
};

enum netdev_queue_state_t {
	__QUEUE_STATE_DRV_XOFF = 0,
	__QUEUE_STATE_STACK_XOFF = 1,
	__QUEUE_STATE_FROZEN = 2,
};

enum netdev_queue_type {
	NETDEV_QUEUE_TYPE_RX = 0,
	NETDEV_QUEUE_TYPE_TX = 1,
};

enum netdev_reg_state {
	NETREG_UNINITIALIZED = 0,
	NETREG_REGISTERED = 1,
	NETREG_UNREGISTERING = 2,
	NETREG_UNREGISTERED = 3,
	NETREG_RELEASED = 4,
	NETREG_DUMMY = 5,
};

enum netdev_stat_type {
	NETDEV_PCPU_STAT_NONE = 0,
	NETDEV_PCPU_STAT_LSTATS = 1,
	NETDEV_PCPU_STAT_TSTATS = 2,
	NETDEV_PCPU_STAT_DSTATS = 3,
};

enum netdev_state_t {
	__LINK_STATE_START = 0,
	__LINK_STATE_PRESENT = 1,
	__LINK_STATE_NOCARRIER = 2,
	__LINK_STATE_LINKWATCH_PENDING = 3,
	__LINK_STATE_DORMANT = 4,
	__LINK_STATE_TESTING = 5,
};

enum netdev_tx {
	__NETDEV_TX_MIN = -2147483648,
	NETDEV_TX_OK = 0,
	NETDEV_TX_BUSY = 16,
};

typedef enum netdev_tx netdev_tx_t;

enum netdev_xdp_act {
	NETDEV_XDP_ACT_BASIC = 1,
	NETDEV_XDP_ACT_REDIRECT = 2,
	NETDEV_XDP_ACT_NDO_XMIT = 4,
	NETDEV_XDP_ACT_XSK_ZEROCOPY = 8,
	NETDEV_XDP_ACT_HW_OFFLOAD = 16,
	NETDEV_XDP_ACT_RX_SG = 32,
	NETDEV_XDP_ACT_NDO_XMIT_SG = 64,
	NETDEV_XDP_ACT_MASK = 127,
};

enum netdev_xdp_rx_metadata {
	NETDEV_XDP_RX_METADATA_TIMESTAMP = 1,
	NETDEV_XDP_RX_METADATA_HASH = 2,
	NETDEV_XDP_RX_METADATA_VLAN_TAG = 4,
};

enum netdev_xsk_flags {
	NETDEV_XSK_FLAGS_TX_TIMESTAMP = 1,
	NETDEV_XSK_FLAGS_TX_CHECKSUM = 2,
};

enum netevent_notif_type {
	NETEVENT_NEIGH_UPDATE = 1,
	NETEVENT_REDIRECT = 2,
	NETEVENT_DELAY_PROBE_TIME_UPDATE = 3,
	NETEVENT_IPV4_MPATH_HASH_UPDATE = 4,
	NETEVENT_IPV6_MPATH_HASH_UPDATE = 5,
	NETEVENT_IPV4_FWD_UPDATE_PRIORITY_UPDATE = 6,
};

enum netfs_collect_contig_trace {
	netfs_contig_trace_collect = 0,
	netfs_contig_trace_jump = 1,
	netfs_contig_trace_unlock = 2,
} __attribute__((mode(byte)));

enum netfs_donate_trace {
	netfs_trace_donate_tail_to_prev = 0,
	netfs_trace_donate_to_prev = 1,
	netfs_trace_donate_to_next = 2,
	netfs_trace_donate_to_deferred_next = 3,
} __attribute__((mode(byte)));

enum netfs_failure {
	netfs_fail_check_write_begin = 0,
	netfs_fail_copy_to_cache = 1,
	netfs_fail_dio_read_short = 2,
	netfs_fail_dio_read_zero = 3,
	netfs_fail_read = 4,
	netfs_fail_short_read = 5,
	netfs_fail_prepare_write = 6,
	netfs_fail_write = 7,
} __attribute__((mode(byte)));

enum netfs_folio_trace {
	netfs_folio_is_uptodate = 0,
	netfs_just_prefetch = 1,
	netfs_whole_folio_modify = 2,
	netfs_modify_and_clear = 3,
	netfs_streaming_write = 4,
	netfs_streaming_write_cont = 5,
	netfs_flush_content = 6,
	netfs_streaming_filled_page = 7,
	netfs_streaming_cont_filled_page = 8,
	netfs_folio_trace_abandon = 9,
	netfs_folio_trace_alloc_buffer = 10,
	netfs_folio_trace_cancel_copy = 11,
	netfs_folio_trace_cancel_store = 12,
	netfs_folio_trace_clear = 13,
	netfs_folio_trace_clear_cc = 14,
	netfs_folio_trace_clear_g = 15,
	netfs_folio_trace_clear_s = 16,
	netfs_folio_trace_copy_to_cache = 17,
	netfs_folio_trace_end_copy = 18,
	netfs_folio_trace_filled_gaps = 19,
	netfs_folio_trace_kill = 20,
	netfs_folio_trace_kill_cc = 21,
	netfs_folio_trace_kill_g = 22,
	netfs_folio_trace_kill_s = 23,
	netfs_folio_trace_mkwrite = 24,
	netfs_folio_trace_mkwrite_plus = 25,
	netfs_folio_trace_not_under_wback = 26,
	netfs_folio_trace_not_locked = 27,
	netfs_folio_trace_put = 28,
	netfs_folio_trace_read = 29,
	netfs_folio_trace_read_done = 30,
	netfs_folio_trace_read_gaps = 31,
	netfs_folio_trace_read_unlock = 32,
	netfs_folio_trace_redirtied = 33,
	netfs_folio_trace_store = 34,
	netfs_folio_trace_store_copy = 35,
	netfs_folio_trace_store_plus = 36,
	netfs_folio_trace_wthru = 37,
	netfs_folio_trace_wthru_plus = 38,
} __attribute__((mode(byte)));

enum netfs_folioq_trace {
	netfs_trace_folioq_alloc_buffer = 0,
	netfs_trace_folioq_clear = 1,
	netfs_trace_folioq_delete = 2,
	netfs_trace_folioq_make_space = 3,
	netfs_trace_folioq_rollbuf_init = 4,
	netfs_trace_folioq_read_progress = 5,
} __attribute__((mode(byte)));

enum netfs_io_origin {
	NETFS_READAHEAD = 0,
	NETFS_READPAGE = 1,
	NETFS_READ_GAPS = 2,
	NETFS_READ_SINGLE = 3,
	NETFS_READ_FOR_WRITE = 4,
	NETFS_DIO_READ = 5,
	NETFS_WRITEBACK = 6,
	NETFS_WRITEBACK_SINGLE = 7,
	NETFS_WRITETHROUGH = 8,
	NETFS_UNBUFFERED_WRITE = 9,
	NETFS_DIO_WRITE = 10,
	NETFS_PGPRIV2_COPY_TO_CACHE = 11,
	nr__netfs_io_origin = 12,
} __attribute__((mode(byte)));

enum netfs_io_source {
	NETFS_SOURCE_UNKNOWN = 0,
	NETFS_FILL_WITH_ZEROES = 1,
	NETFS_DOWNLOAD_FROM_SERVER = 2,
	NETFS_READ_FROM_CACHE = 3,
	NETFS_INVALID_READ = 4,
	NETFS_UPLOAD_TO_SERVER = 5,
	NETFS_WRITE_TO_CACHE = 6,
	NETFS_INVALID_WRITE = 7,
} __attribute__((mode(byte)));

enum netfs_read_from_hole {
	NETFS_READ_HOLE_IGNORE = 0,
	NETFS_READ_HOLE_CLEAR = 1,
	NETFS_READ_HOLE_FAIL = 2,
};

enum netfs_read_trace {
	netfs_read_trace_dio_read = 0,
	netfs_read_trace_expanded = 1,
	netfs_read_trace_readahead = 2,
	netfs_read_trace_readpage = 3,
	netfs_read_trace_read_gaps = 4,
	netfs_read_trace_read_single = 5,
	netfs_read_trace_prefetch_for_write = 6,
	netfs_read_trace_write_begin = 7,
} __attribute__((mode(byte)));

enum netfs_rreq_ref_trace {
	netfs_rreq_trace_get_for_outstanding = 0,
	netfs_rreq_trace_get_subreq = 1,
	netfs_rreq_trace_get_work = 2,
	netfs_rreq_trace_put_complete = 3,
	netfs_rreq_trace_put_discard = 4,
	netfs_rreq_trace_put_failed = 5,
	netfs_rreq_trace_put_no_submit = 6,
	netfs_rreq_trace_put_return = 7,
	netfs_rreq_trace_put_subreq = 8,
	netfs_rreq_trace_put_work = 9,
	netfs_rreq_trace_put_work_complete = 10,
	netfs_rreq_trace_put_work_nq = 11,
	netfs_rreq_trace_see_work = 12,
	netfs_rreq_trace_new = 13,
} __attribute__((mode(byte)));

enum netfs_rreq_trace {
	netfs_rreq_trace_assess = 0,
	netfs_rreq_trace_copy = 1,
	netfs_rreq_trace_collect = 2,
	netfs_rreq_trace_complete = 3,
	netfs_rreq_trace_dirty = 4,
	netfs_rreq_trace_done = 5,
	netfs_rreq_trace_free = 6,
	netfs_rreq_trace_redirty = 7,
	netfs_rreq_trace_resubmit = 8,
	netfs_rreq_trace_set_abandon = 9,
	netfs_rreq_trace_set_pause = 10,
	netfs_rreq_trace_unlock = 11,
	netfs_rreq_trace_unlock_pgpriv2 = 12,
	netfs_rreq_trace_unmark = 13,
	netfs_rreq_trace_wait_ip = 14,
	netfs_rreq_trace_wait_pause = 15,
	netfs_rreq_trace_wait_queue = 16,
	netfs_rreq_trace_wake_ip = 17,
	netfs_rreq_trace_wake_queue = 18,
	netfs_rreq_trace_woke_queue = 19,
	netfs_rreq_trace_unpause = 20,
	netfs_rreq_trace_write_done = 21,
} __attribute__((mode(byte)));

enum netfs_sreq_ref_trace {
	netfs_sreq_trace_get_copy_to_cache = 0,
	netfs_sreq_trace_get_resubmit = 1,
	netfs_sreq_trace_get_submit = 2,
	netfs_sreq_trace_get_short_read = 3,
	netfs_sreq_trace_new = 4,
	netfs_sreq_trace_put_abandon = 5,
	netfs_sreq_trace_put_cancel = 6,
	netfs_sreq_trace_put_clear = 7,
	netfs_sreq_trace_put_consumed = 8,
	netfs_sreq_trace_put_done = 9,
	netfs_sreq_trace_put_failed = 10,
	netfs_sreq_trace_put_merged = 11,
	netfs_sreq_trace_put_no_copy = 12,
	netfs_sreq_trace_put_oom = 13,
	netfs_sreq_trace_put_wip = 14,
	netfs_sreq_trace_put_work = 15,
	netfs_sreq_trace_put_terminated = 16,
} __attribute__((mode(byte)));

enum netfs_sreq_trace {
	netfs_sreq_trace_add_donations = 0,
	netfs_sreq_trace_added = 1,
	netfs_sreq_trace_cache_nowrite = 2,
	netfs_sreq_trace_cache_prepare = 3,
	netfs_sreq_trace_cache_write = 4,
	netfs_sreq_trace_cancel = 5,
	netfs_sreq_trace_clear = 6,
	netfs_sreq_trace_discard = 7,
	netfs_sreq_trace_donate_to_prev = 8,
	netfs_sreq_trace_donate_to_next = 9,
	netfs_sreq_trace_download_instead = 10,
	netfs_sreq_trace_fail = 11,
	netfs_sreq_trace_free = 12,
	netfs_sreq_trace_hit_eof = 13,
	netfs_sreq_trace_io_progress = 14,
	netfs_sreq_trace_limited = 15,
	netfs_sreq_trace_need_clear = 16,
	netfs_sreq_trace_partial_read = 17,
	netfs_sreq_trace_need_retry = 18,
	netfs_sreq_trace_prepare = 19,
	netfs_sreq_trace_prep_failed = 20,
	netfs_sreq_trace_progress = 21,
	netfs_sreq_trace_reprep_failed = 22,
	netfs_sreq_trace_retry = 23,
	netfs_sreq_trace_short = 24,
	netfs_sreq_trace_split = 25,
	netfs_sreq_trace_submit = 26,
	netfs_sreq_trace_superfluous = 27,
	netfs_sreq_trace_terminated = 28,
	netfs_sreq_trace_wait_for = 29,
	netfs_sreq_trace_write = 30,
	netfs_sreq_trace_write_skip = 31,
	netfs_sreq_trace_write_term = 32,
} __attribute__((mode(byte)));

enum netfs_write_trace {
	netfs_write_trace_copy_to_cache = 0,
	netfs_write_trace_dio_write = 1,
	netfs_write_trace_unbuffered_write = 2,
	netfs_write_trace_writeback = 3,
	netfs_write_trace_writethrough = 4,
} __attribute__((mode(byte)));

enum netlink_attribute_type {
	NL_ATTR_TYPE_INVALID = 0,
	NL_ATTR_TYPE_FLAG = 1,
	NL_ATTR_TYPE_U8 = 2,
	NL_ATTR_TYPE_U16 = 3,
	NL_ATTR_TYPE_U32 = 4,
	NL_ATTR_TYPE_U64 = 5,
	NL_ATTR_TYPE_S8 = 6,
	NL_ATTR_TYPE_S16 = 7,
	NL_ATTR_TYPE_S32 = 8,
	NL_ATTR_TYPE_S64 = 9,
	NL_ATTR_TYPE_BINARY = 10,
	NL_ATTR_TYPE_STRING = 11,
	NL_ATTR_TYPE_NUL_STRING = 12,
	NL_ATTR_TYPE_NESTED = 13,
	NL_ATTR_TYPE_NESTED_ARRAY = 14,
	NL_ATTR_TYPE_BITFIELD32 = 15,
	NL_ATTR_TYPE_SINT = 16,
	NL_ATTR_TYPE_UINT = 17,
};

enum netlink_policy_type_attr {
	NL_POLICY_TYPE_ATTR_UNSPEC = 0,
	NL_POLICY_TYPE_ATTR_TYPE = 1,
	NL_POLICY_TYPE_ATTR_MIN_VALUE_S = 2,
	NL_POLICY_TYPE_ATTR_MAX_VALUE_S = 3,
	NL_POLICY_TYPE_ATTR_MIN_VALUE_U = 4,
	NL_POLICY_TYPE_ATTR_MAX_VALUE_U = 5,
	NL_POLICY_TYPE_ATTR_MIN_LENGTH = 6,
	NL_POLICY_TYPE_ATTR_MAX_LENGTH = 7,
	NL_POLICY_TYPE_ATTR_POLICY_IDX = 8,
	NL_POLICY_TYPE_ATTR_POLICY_MAXTYPE = 9,
	NL_POLICY_TYPE_ATTR_BITFIELD32_MASK = 10,
	NL_POLICY_TYPE_ATTR_PAD = 11,
	NL_POLICY_TYPE_ATTR_MASK = 12,
	__NL_POLICY_TYPE_ATTR_MAX = 13,
	NL_POLICY_TYPE_ATTR_MAX = 12,
};

enum netlink_skb_flags {
	NETLINK_SKB_DST = 8,
};

enum netlink_validation {
	NL_VALIDATE_LIBERAL = 0,
	NL_VALIDATE_TRAILING = 1,
	NL_VALIDATE_MAXTYPE = 2,
	NL_VALIDATE_UNSPEC = 4,
	NL_VALIDATE_STRICT_ATTRS = 8,
	NL_VALIDATE_NESTED = 16,
};

enum netns_bpf_attach_type {
	NETNS_BPF_INVALID = -1,
	NETNS_BPF_FLOW_DISSECTOR = 0,
	NETNS_BPF_SK_LOOKUP = 1,
	MAX_NETNS_BPF_ATTACH_TYPE = 2,
};

enum nexthop_event_type {
	NEXTHOP_EVENT_DEL = 0,
	NEXTHOP_EVENT_REPLACE = 1,
	NEXTHOP_EVENT_RES_TABLE_PRE_REPLACE = 2,
	NEXTHOP_EVENT_BUCKET_REPLACE = 3,
	NEXTHOP_EVENT_HW_STATS_REPORT_DELTA = 4,
};

enum nf_ct_ecache_state {
	NFCT_ECACHE_DESTROY_FAIL = 0,
	NFCT_ECACHE_DESTROY_SENT = 1,
};

enum nf_ct_ext_id {
	NF_CT_EXT_HELPER = 0,
	NF_CT_EXT_NAT = 1,
	NF_CT_EXT_SEQADJ = 2,
	NF_CT_EXT_ACCT = 3,
	NF_CT_EXT_NUM = 4,
};

enum nf_ct_ftp_type {
	NF_CT_FTP_PORT = 0,
	NF_CT_FTP_PASV = 1,
	NF_CT_FTP_EPRT = 2,
	NF_CT_FTP_EPSV = 3,
};

enum nf_ct_helper_flags {
	NF_CT_HELPER_F_USERSPACE = 1,
	NF_CT_HELPER_F_CONFIGURED = 2,
};

enum nf_ct_sysctl_index {
	NF_SYSCTL_CT_MAX = 0,
	NF_SYSCTL_CT_COUNT = 1,
	NF_SYSCTL_CT_BUCKETS = 2,
	NF_SYSCTL_CT_CHECKSUM = 3,
	NF_SYSCTL_CT_LOG_INVALID = 4,
	NF_SYSCTL_CT_EXPECT_MAX = 5,
	NF_SYSCTL_CT_ACCT = 6,
	NF_SYSCTL_CT_PROTO_TIMEOUT_GENERIC = 7,
	NF_SYSCTL_CT_PROTO_TIMEOUT_TCP_SYN_SENT = 8,
	NF_SYSCTL_CT_PROTO_TIMEOUT_TCP_SYN_RECV = 9,
	NF_SYSCTL_CT_PROTO_TIMEOUT_TCP_ESTABLISHED = 10,
	NF_SYSCTL_CT_PROTO_TIMEOUT_TCP_FIN_WAIT = 11,
	NF_SYSCTL_CT_PROTO_TIMEOUT_TCP_CLOSE_WAIT = 12,
	NF_SYSCTL_CT_PROTO_TIMEOUT_TCP_LAST_ACK = 13,
	NF_SYSCTL_CT_PROTO_TIMEOUT_TCP_TIME_WAIT = 14,
	NF_SYSCTL_CT_PROTO_TIMEOUT_TCP_CLOSE = 15,
	NF_SYSCTL_CT_PROTO_TIMEOUT_TCP_RETRANS = 16,
	NF_SYSCTL_CT_PROTO_TIMEOUT_TCP_UNACK = 17,
	NF_SYSCTL_CT_PROTO_TCP_LOOSE = 18,
	NF_SYSCTL_CT_PROTO_TCP_LIBERAL = 19,
	NF_SYSCTL_CT_PROTO_TCP_IGNORE_INVALID_RST = 20,
	NF_SYSCTL_CT_PROTO_TCP_MAX_RETRANS = 21,
	NF_SYSCTL_CT_PROTO_TIMEOUT_UDP = 22,
	NF_SYSCTL_CT_PROTO_TIMEOUT_UDP_STREAM = 23,
	NF_SYSCTL_CT_PROTO_TIMEOUT_ICMP = 24,
	NF_SYSCTL_CT_PROTO_TIMEOUT_ICMPV6 = 25,
	NF_SYSCTL_CT_LAST_SYSCTL = 26,
};

enum nf_ct_tcp_action {
	NFCT_TCP_IGNORE = 0,
	NFCT_TCP_INVALID = 1,
	NFCT_TCP_ACCEPT = 2,
};

enum nf_dev_hooks {
	NF_NETDEV_INGRESS = 0,
	NF_NETDEV_EGRESS = 1,
	NF_NETDEV_NUMHOOKS = 2,
};

enum nf_hook_ops_type {
	NF_HOOK_OP_UNDEFINED = 0,
	NF_HOOK_OP_NF_TABLES = 1,
	NF_HOOK_OP_BPF = 2,
};

enum nf_inet_hooks {
	NF_INET_PRE_ROUTING = 0,
	NF_INET_LOCAL_IN = 1,
	NF_INET_FORWARD = 2,
	NF_INET_LOCAL_OUT = 3,
	NF_INET_POST_ROUTING = 4,
	NF_INET_NUMHOOKS = 5,
	NF_INET_INGRESS = 5,
};

enum nf_ip6_hook_priorities {
	NF_IP6_PRI_FIRST = -2147483648,
	NF_IP6_PRI_RAW_BEFORE_DEFRAG = -450,
	NF_IP6_PRI_CONNTRACK_DEFRAG = -400,
	NF_IP6_PRI_RAW = -300,
	NF_IP6_PRI_SELINUX_FIRST = -225,
	NF_IP6_PRI_CONNTRACK = -200,
	NF_IP6_PRI_MANGLE = -150,
	NF_IP6_PRI_NAT_DST = -100,
	NF_IP6_PRI_FILTER = 0,
	NF_IP6_PRI_SECURITY = 50,
	NF_IP6_PRI_NAT_SRC = 100,
	NF_IP6_PRI_SELINUX_LAST = 225,
	NF_IP6_PRI_CONNTRACK_HELPER = 300,
	NF_IP6_PRI_LAST = 2147483647,
};

enum nf_ip_hook_priorities {
	NF_IP_PRI_FIRST = -2147483648,
	NF_IP_PRI_RAW_BEFORE_DEFRAG = -450,
	NF_IP_PRI_CONNTRACK_DEFRAG = -400,
	NF_IP_PRI_RAW = -300,
	NF_IP_PRI_SELINUX_FIRST = -225,
	NF_IP_PRI_CONNTRACK = -200,
	NF_IP_PRI_MANGLE = -150,
	NF_IP_PRI_NAT_DST = -100,
	NF_IP_PRI_FILTER = 0,
	NF_IP_PRI_SECURITY = 50,
	NF_IP_PRI_NAT_SRC = 100,
	NF_IP_PRI_SELINUX_LAST = 225,
	NF_IP_PRI_CONNTRACK_HELPER = 300,
	NF_IP_PRI_CONNTRACK_CONFIRM = 2147483647,
	NF_IP_PRI_LAST = 2147483647,
};

enum nf_log_type {
	NF_LOG_TYPE_LOG = 0,
	NF_LOG_TYPE_ULOG = 1,
	NF_LOG_TYPE_MAX = 2,
};

enum nf_nat_manip_type {
	NF_NAT_MANIP_SRC = 0,
	NF_NAT_MANIP_DST = 1,
};

enum nfnetlink_groups {
	NFNLGRP_NONE = 0,
	NFNLGRP_CONNTRACK_NEW = 1,
	NFNLGRP_CONNTRACK_UPDATE = 2,
	NFNLGRP_CONNTRACK_DESTROY = 3,
	NFNLGRP_CONNTRACK_EXP_NEW = 4,
	NFNLGRP_CONNTRACK_EXP_UPDATE = 5,
	NFNLGRP_CONNTRACK_EXP_DESTROY = 6,
	NFNLGRP_NFTABLES = 7,
	NFNLGRP_ACCT_QUOTA = 8,
	NFNLGRP_NFTRACE = 9,
	__NFNLGRP_MAX = 10,
};

enum nfnl_abort_action {
	NFNL_ABORT_NONE = 0,
	NFNL_ABORT_AUTOLOAD = 1,
	NFNL_ABORT_VALIDATE = 2,
};

enum nfnl_batch_attributes {
	NFNL_BATCH_UNSPEC = 0,
	NFNL_BATCH_GENID = 1,
	__NFNL_BATCH_MAX = 2,
};

enum nfnl_callback_type {
	NFNL_CB_UNSPEC = 0,
	NFNL_CB_MUTEX = 1,
	NFNL_CB_RCU = 2,
	NFNL_CB_BATCH = 3,
};

enum nfs3_createmode {
	NFS3_CREATE_UNCHECKED = 0,
	NFS3_CREATE_GUARDED = 1,
	NFS3_CREATE_EXCLUSIVE = 2,
};

enum nfs3_ftype {
	NF3NON = 0,
	NF3REG = 1,
	NF3DIR = 2,
	NF3BLK = 3,
	NF3CHR = 4,
	NF3LNK = 5,
	NF3SOCK = 6,
	NF3FIFO = 7,
	NF3BAD = 8,
};

enum nfs3_stable_how {
	NFS_UNSTABLE = 0,
	NFS_DATA_SYNC = 1,
	NFS_FILE_SYNC = 2,
	NFS_INVALID_STABLE_HOW = -1,
};

enum nfs4_acl_type {
	NFS4ACL_NONE = 0,
	NFS4ACL_ACL = 1,
	NFS4ACL_DACL = 2,
	NFS4ACL_SACL = 3,
};

enum nfs4_callback_procnum {
	CB_NULL = 0,
	CB_COMPOUND = 1,
};

enum nfs4_change_attr_type {
	NFS4_CHANGE_TYPE_IS_MONOTONIC_INCR = 0,
	NFS4_CHANGE_TYPE_IS_VERSION_COUNTER = 1,
	NFS4_CHANGE_TYPE_IS_VERSION_COUNTER_NOPNFS = 2,
	NFS4_CHANGE_TYPE_IS_TIME_METADATA = 3,
	NFS4_CHANGE_TYPE_IS_UNDEFINED = 4,
};

enum nfs4_client_state {
	NFS4CLNT_MANAGER_RUNNING = 0,
	NFS4CLNT_CHECK_LEASE = 1,
	NFS4CLNT_LEASE_EXPIRED = 2,
	NFS4CLNT_RECLAIM_REBOOT = 3,
	NFS4CLNT_RECLAIM_NOGRACE = 4,
	NFS4CLNT_DELEGRETURN = 5,
	NFS4CLNT_SESSION_RESET = 6,
	NFS4CLNT_LEASE_CONFIRM = 7,
	NFS4CLNT_SERVER_SCOPE_MISMATCH = 8,
	NFS4CLNT_PURGE_STATE = 9,
	NFS4CLNT_BIND_CONN_TO_SESSION = 10,
	NFS4CLNT_MOVED = 11,
	NFS4CLNT_LEASE_MOVED = 12,
	NFS4CLNT_DELEGATION_EXPIRED = 13,
	NFS4CLNT_RUN_MANAGER = 14,
	NFS4CLNT_MANAGER_AVAILABLE = 15,
	NFS4CLNT_RECALL_RUNNING = 16,
	NFS4CLNT_RECALL_ANY_LAYOUT_READ = 17,
	NFS4CLNT_RECALL_ANY_LAYOUT_RW = 18,
	NFS4CLNT_DELEGRETURN_DELAYED = 19,
};

enum nfs4_open_delegation_type4 {
	NFS4_OPEN_DELEGATE_NONE = 0,
	NFS4_OPEN_DELEGATE_READ = 1,
	NFS4_OPEN_DELEGATE_WRITE = 2,
	NFS4_OPEN_DELEGATE_NONE_EXT = 3,
	NFS4_OPEN_DELEGATE_READ_ATTRS_DELEG = 4,
	NFS4_OPEN_DELEGATE_WRITE_ATTRS_DELEG = 5,
};

enum nfs4_slot_tbl_state {
	NFS4_SLOT_TBL_DRAINING = 0,
};

enum nfs_cb_opnum4 {
	OP_CB_GETATTR = 3,
	OP_CB_RECALL = 4,
	OP_CB_LAYOUTRECALL = 5,
	OP_CB_NOTIFY = 6,
	OP_CB_PUSH_DELEG = 7,
	OP_CB_RECALL_ANY = 8,
	OP_CB_RECALLABLE_OBJ_AVAIL = 9,
	OP_CB_RECALL_SLOT = 10,
	OP_CB_SEQUENCE = 11,
	OP_CB_WANTS_CANCELLED = 12,
	OP_CB_NOTIFY_LOCK = 13,
	OP_CB_NOTIFY_DEVICEID = 14,
	OP_CB_OFFLOAD = 15,
	OP_CB_ILLEGAL = 10044,
};

enum nfs_ftype4 {
	NF4BAD = 0,
	NF4REG = 1,
	NF4DIR = 2,
	NF4BLK = 3,
	NF4CHR = 4,
	NF4LNK = 5,
	NF4SOCK = 6,
	NF4FIFO = 7,
	NF4ATTRDIR = 8,
	NF4NAMEDATTR = 9,
};

enum nfs_lock_status {
	NFS_LOCK_NOT_SET = 0,
	NFS_LOCK_LOCK = 1,
	NFS_LOCK_NOLOCK = 2,
};

enum nfs_opnum4 {
	OP_ACCESS = 3,
	OP_CLOSE = 4,
	OP_COMMIT = 5,
	OP_CREATE = 6,
	OP_DELEGPURGE = 7,
	OP_DELEGRETURN = 8,
	OP_GETATTR = 9,
	OP_GETFH = 10,
	OP_LINK = 11,
	OP_LOCK = 12,
	OP_LOCKT = 13,
	OP_LOCKU = 14,
	OP_LOOKUP = 15,
	OP_LOOKUPP = 16,
	OP_NVERIFY = 17,
	OP_OPEN = 18,
	OP_OPENATTR = 19,
	OP_OPEN_CONFIRM = 20,
	OP_OPEN_DOWNGRADE = 21,
	OP_PUTFH = 22,
	OP_PUTPUBFH = 23,
	OP_PUTROOTFH = 24,
	OP_READ = 25,
	OP_READDIR = 26,
	OP_READLINK = 27,
	OP_REMOVE = 28,
	OP_RENAME = 29,
	OP_RENEW = 30,
	OP_RESTOREFH = 31,
	OP_SAVEFH = 32,
	OP_SECINFO = 33,
	OP_SETATTR = 34,
	OP_SETCLIENTID = 35,
	OP_SETCLIENTID_CONFIRM = 36,
	OP_VERIFY = 37,
	OP_WRITE = 38,
	OP_RELEASE_LOCKOWNER = 39,
	OP_BACKCHANNEL_CTL = 40,
	OP_BIND_CONN_TO_SESSION = 41,
	OP_EXCHANGE_ID = 42,
	OP_CREATE_SESSION = 43,
	OP_DESTROY_SESSION = 44,
	OP_FREE_STATEID = 45,
	OP_GET_DIR_DELEGATION = 46,
	OP_GETDEVICEINFO = 47,
	OP_GETDEVICELIST = 48,
	OP_LAYOUTCOMMIT = 49,
	OP_LAYOUTGET = 50,
	OP_LAYOUTRETURN = 51,
	OP_SECINFO_NO_NAME = 52,
	OP_SEQUENCE = 53,
	OP_SET_SSV = 54,
	OP_TEST_STATEID = 55,
	OP_WANT_DELEGATION = 56,
	OP_DESTROY_CLIENTID = 57,
	OP_RECLAIM_COMPLETE = 58,
	OP_ALLOCATE = 59,
	OP_COPY = 60,
	OP_COPY_NOTIFY = 61,
	OP_DEALLOCATE = 62,
	OP_IO_ADVISE = 63,
	OP_LAYOUTERROR = 64,
	OP_LAYOUTSTATS = 65,
	OP_OFFLOAD_CANCEL = 66,
	OP_OFFLOAD_STATUS = 67,
	OP_READ_PLUS = 68,
	OP_SEEK = 69,
	OP_WRITE_SAME = 70,
	OP_CLONE = 71,
	OP_GETXATTR = 72,
	OP_SETXATTR = 73,
	OP_LISTXATTRS = 74,
	OP_REMOVEXATTR = 75,
	OP_ILLEGAL = 10044,
};

enum nfs_param {
	Opt_ac = 0,
	Opt_acdirmax = 1,
	Opt_acdirmin = 2,
	Opt_acl___2 = 3,
	Opt_acregmax = 4,
	Opt_acregmin = 5,
	Opt_actimeo = 6,
	Opt_addr = 7,
	Opt_bg = 8,
	Opt_bsize = 9,
	Opt_clientaddr = 10,
	Opt_cto = 11,
	Opt_alignwrite = 12,
	Opt_fg = 13,
	Opt_fscache = 14,
	Opt_fscache_flag = 15,
	Opt_hard = 16,
	Opt_intr = 17,
	Opt_local_lock = 18,
	Opt_lock = 19,
	Opt_lookupcache = 20,
	Opt_migration = 21,
	Opt_minorversion = 22,
	Opt_mountaddr = 23,
	Opt_mounthost = 24,
	Opt_mountport = 25,
	Opt_mountproto = 26,
	Opt_mountvers = 27,
	Opt_namelen = 28,
	Opt_nconnect = 29,
	Opt_max_connect = 30,
	Opt_port___2 = 31,
	Opt_posix = 32,
	Opt_proto = 33,
	Opt_rdirplus = 34,
	Opt_rdma = 35,
	Opt_resvport = 36,
	Opt_retrans = 37,
	Opt_retry = 38,
	Opt_rsize = 39,
	Opt_sec = 40,
	Opt_sharecache = 41,
	Opt_sloppy = 42,
	Opt_soft = 43,
	Opt_softerr = 44,
	Opt_softreval = 45,
	Opt_source___2 = 46,
	Opt_tcp = 47,
	Opt_timeo = 48,
	Opt_trunkdiscovery = 49,
	Opt_udp = 50,
	Opt_v = 51,
	Opt_vers = 52,
	Opt_wsize = 53,
	Opt_write = 54,
	Opt_xprtsec = 55,
};

enum nfs_stat {
	NFS_OK = 0,
	NFSERR_PERM = 1,
	NFSERR_NOENT = 2,
	NFSERR_IO = 5,
	NFSERR_NXIO = 6,
	NFSERR_EAGAIN = 11,
	NFSERR_ACCES = 13,
	NFSERR_EXIST = 17,
	NFSERR_XDEV = 18,
	NFSERR_NODEV = 19,
	NFSERR_NOTDIR = 20,
	NFSERR_ISDIR = 21,
	NFSERR_INVAL = 22,
	NFSERR_FBIG = 27,
	NFSERR_NOSPC = 28,
	NFSERR_ROFS = 30,
	NFSERR_MLINK = 31,
	NFSERR_NAMETOOLONG = 63,
	NFSERR_NOTEMPTY = 66,
	NFSERR_DQUOT = 69,
	NFSERR_STALE = 70,
	NFSERR_REMOTE = 71,
	NFSERR_WFLUSH = 99,
	NFSERR_BADHANDLE = 10001,
	NFSERR_NOT_SYNC = 10002,
	NFSERR_BAD_COOKIE = 10003,
	NFSERR_NOTSUPP = 10004,
	NFSERR_TOOSMALL = 10005,
	NFSERR_SERVERFAULT = 10006,
	NFSERR_BADTYPE = 10007,
	NFSERR_JUKEBOX = 10008,
	NFSERR_SAME = 10009,
	NFSERR_DENIED = 10010,
	NFSERR_EXPIRED = 10011,
	NFSERR_LOCKED = 10012,
	NFSERR_GRACE = 10013,
	NFSERR_FHEXPIRED = 10014,
	NFSERR_SHARE_DENIED = 10015,
	NFSERR_WRONGSEC = 10016,
	NFSERR_CLID_INUSE = 10017,
	NFSERR_RESOURCE = 10018,
	NFSERR_MOVED = 10019,
	NFSERR_NOFILEHANDLE = 10020,
	NFSERR_MINOR_VERS_MISMATCH = 10021,
	NFSERR_STALE_CLIENTID = 10022,
	NFSERR_STALE_STATEID = 10023,
	NFSERR_OLD_STATEID = 10024,
	NFSERR_BAD_STATEID = 10025,
	NFSERR_BAD_SEQID = 10026,
	NFSERR_NOT_SAME = 10027,
	NFSERR_LOCK_RANGE = 10028,
	NFSERR_SYMLINK = 10029,
	NFSERR_RESTOREFH = 10030,
	NFSERR_LEASE_MOVED = 10031,
	NFSERR_ATTRNOTSUPP = 10032,
	NFSERR_NO_GRACE = 10033,
	NFSERR_RECLAIM_BAD = 10034,
	NFSERR_RECLAIM_CONFLICT = 10035,
	NFSERR_BAD_XDR = 10036,
	NFSERR_LOCKS_HELD = 10037,
	NFSERR_OPENMODE = 10038,
	NFSERR_BADOWNER = 10039,
	NFSERR_BADCHAR = 10040,
	NFSERR_BADNAME = 10041,
	NFSERR_BAD_RANGE = 10042,
	NFSERR_LOCK_NOTSUPP = 10043,
	NFSERR_OP_ILLEGAL = 10044,
	NFSERR_DEADLOCK = 10045,
	NFSERR_FILE_OPEN = 10046,
	NFSERR_ADMIN_REVOKED = 10047,
	NFSERR_CB_PATH_DOWN = 10048,
};

enum nfs_stat_bytecounters {
	NFSIOS_NORMALREADBYTES = 0,
	NFSIOS_NORMALWRITTENBYTES = 1,
	NFSIOS_DIRECTREADBYTES = 2,
	NFSIOS_DIRECTWRITTENBYTES = 3,
	NFSIOS_SERVERREADBYTES = 4,
	NFSIOS_SERVERWRITTENBYTES = 5,
	NFSIOS_READPAGES = 6,
	NFSIOS_WRITEPAGES = 7,
	__NFSIOS_BYTESMAX = 8,
};

enum nfs_stat_eventcounters {
	NFSIOS_INODEREVALIDATE = 0,
	NFSIOS_DENTRYREVALIDATE = 1,
	NFSIOS_DATAINVALIDATE = 2,
	NFSIOS_ATTRINVALIDATE = 3,
	NFSIOS_VFSOPEN = 4,
	NFSIOS_VFSLOOKUP = 5,
	NFSIOS_VFSACCESS = 6,
	NFSIOS_VFSUPDATEPAGE = 7,
	NFSIOS_VFSREADPAGE = 8,
	NFSIOS_VFSREADPAGES = 9,
	NFSIOS_VFSWRITEPAGE = 10,
	NFSIOS_VFSWRITEPAGES = 11,
	NFSIOS_VFSGETDENTS = 12,
	NFSIOS_VFSSETATTR = 13,
	NFSIOS_VFSFLUSH = 14,
	NFSIOS_VFSFSYNC = 15,
	NFSIOS_VFSLOCK = 16,
	NFSIOS_VFSRELEASE = 17,
	NFSIOS_CONGESTIONWAIT = 18,
	NFSIOS_SETATTRTRUNC = 19,
	NFSIOS_EXTENDWRITE = 20,
	NFSIOS_SILLYRENAME = 21,
	NFSIOS_SHORTREAD = 22,
	NFSIOS_SHORTWRITE = 23,
	NFSIOS_DELAY = 24,
	NFSIOS_PNFS_READ = 25,
	NFSIOS_PNFS_WRITE = 26,
	__NFSIOS_COUNTSMAX = 27,
};

enum nfsstat4 {
	NFS4_OK = 0,
	NFS4ERR_PERM = 1,
	NFS4ERR_NOENT = 2,
	NFS4ERR_IO = 5,
	NFS4ERR_NXIO = 6,
	NFS4ERR_ACCESS = 13,
	NFS4ERR_EXIST = 17,
	NFS4ERR_XDEV = 18,
	NFS4ERR_NOTDIR = 20,
	NFS4ERR_ISDIR = 21,
	NFS4ERR_INVAL = 22,
	NFS4ERR_FBIG = 27,
	NFS4ERR_NOSPC = 28,
	NFS4ERR_ROFS = 30,
	NFS4ERR_MLINK = 31,
	NFS4ERR_NAMETOOLONG = 63,
	NFS4ERR_NOTEMPTY = 66,
	NFS4ERR_DQUOT = 69,
	NFS4ERR_STALE = 70,
	NFS4ERR_BADHANDLE = 10001,
	NFS4ERR_BAD_COOKIE = 10003,
	NFS4ERR_NOTSUPP = 10004,
	NFS4ERR_TOOSMALL = 10005,
	NFS4ERR_SERVERFAULT = 10006,
	NFS4ERR_BADTYPE = 10007,
	NFS4ERR_DELAY = 10008,
	NFS4ERR_SAME = 10009,
	NFS4ERR_DENIED = 10010,
	NFS4ERR_EXPIRED = 10011,
	NFS4ERR_LOCKED = 10012,
	NFS4ERR_GRACE = 10013,
	NFS4ERR_FHEXPIRED = 10014,
	NFS4ERR_SHARE_DENIED = 10015,
	NFS4ERR_WRONGSEC = 10016,
	NFS4ERR_CLID_INUSE = 10017,
	NFS4ERR_RESOURCE = 10018,
	NFS4ERR_MOVED = 10019,
	NFS4ERR_NOFILEHANDLE = 10020,
	NFS4ERR_MINOR_VERS_MISMATCH = 10021,
	NFS4ERR_STALE_CLIENTID = 10022,
	NFS4ERR_STALE_STATEID = 10023,
	NFS4ERR_OLD_STATEID = 10024,
	NFS4ERR_BAD_STATEID = 10025,
	NFS4ERR_BAD_SEQID = 10026,
	NFS4ERR_NOT_SAME = 10027,
	NFS4ERR_LOCK_RANGE = 10028,
	NFS4ERR_SYMLINK = 10029,
	NFS4ERR_RESTOREFH = 10030,
	NFS4ERR_LEASE_MOVED = 10031,
	NFS4ERR_ATTRNOTSUPP = 10032,
	NFS4ERR_NO_GRACE = 10033,
	NFS4ERR_RECLAIM_BAD = 10034,
	NFS4ERR_RECLAIM_CONFLICT = 10035,
	NFS4ERR_BADXDR = 10036,
	NFS4ERR_LOCKS_HELD = 10037,
	NFS4ERR_OPENMODE = 10038,
	NFS4ERR_BADOWNER = 10039,
	NFS4ERR_BADCHAR = 10040,
	NFS4ERR_BADNAME = 10041,
	NFS4ERR_BAD_RANGE = 10042,
	NFS4ERR_LOCK_NOTSUPP = 10043,
	NFS4ERR_OP_ILLEGAL = 10044,
	NFS4ERR_DEADLOCK = 10045,
	NFS4ERR_FILE_OPEN = 10046,
	NFS4ERR_ADMIN_REVOKED = 10047,
	NFS4ERR_CB_PATH_DOWN = 10048,
	NFS4ERR_BADIOMODE = 10049,
	NFS4ERR_BADLAYOUT = 10050,
	NFS4ERR_BAD_SESSION_DIGEST = 10051,
	NFS4ERR_BADSESSION = 10052,
	NFS4ERR_BADSLOT = 10053,
	NFS4ERR_COMPLETE_ALREADY = 10054,
	NFS4ERR_CONN_NOT_BOUND_TO_SESSION = 10055,
	NFS4ERR_DELEG_ALREADY_WANTED = 10056,
	NFS4ERR_BACK_CHAN_BUSY = 10057,
	NFS4ERR_LAYOUTTRYLATER = 10058,
	NFS4ERR_LAYOUTUNAVAILABLE = 10059,
	NFS4ERR_NOMATCHING_LAYOUT = 10060,
	NFS4ERR_RECALLCONFLICT = 10061,
	NFS4ERR_UNKNOWN_LAYOUTTYPE = 10062,
	NFS4ERR_SEQ_MISORDERED = 10063,
	NFS4ERR_SEQUENCE_POS = 10064,
	NFS4ERR_REQ_TOO_BIG = 10065,
	NFS4ERR_REP_TOO_BIG = 10066,
	NFS4ERR_REP_TOO_BIG_TO_CACHE = 10067,
	NFS4ERR_RETRY_UNCACHED_REP = 10068,
	NFS4ERR_UNSAFE_COMPOUND = 10069,
	NFS4ERR_TOO_MANY_OPS = 10070,
	NFS4ERR_OP_NOT_IN_SESSION = 10071,
	NFS4ERR_HASH_ALG_UNSUPP = 10072,
	NFS4ERR_CLIENTID_BUSY = 10074,
	NFS4ERR_PNFS_IO_HOLE = 10075,
	NFS4ERR_SEQ_FALSE_RETRY = 10076,
	NFS4ERR_BAD_HIGH_SLOT = 10077,
	NFS4ERR_DEADSESSION = 10078,
	NFS4ERR_ENCR_ALG_UNSUPP = 10079,
	NFS4ERR_PNFS_NO_LAYOUT = 10080,
	NFS4ERR_NOT_ONLY_OP = 10081,
	NFS4ERR_WRONG_CRED = 10082,
	NFS4ERR_WRONG_TYPE = 10083,
	NFS4ERR_DIRDELEG_UNAVAIL = 10084,
	NFS4ERR_REJECT_DELEG = 10085,
	NFS4ERR_RETURNCONFLICT = 10086,
	NFS4ERR_DELEG_REVOKED = 10087,
	NFS4ERR_PARTNER_NOTSUPP = 10088,
	NFS4ERR_PARTNER_NO_AUTH = 10089,
	NFS4ERR_UNION_NOTSUPP = 10090,
	NFS4ERR_OFFLOAD_DENIED = 10091,
	NFS4ERR_WRONG_LFS = 10092,
	NFS4ERR_BADLABEL = 10093,
	NFS4ERR_OFFLOAD_NO_REQS = 10094,
	NFS4ERR_NOXATTR = 10095,
	NFS4ERR_XATTR2BIG = 10096,
	NFS4ERR_FIRST_FREE = 10097,
};

enum nfulnl_attr_config {
	NFULA_CFG_UNSPEC = 0,
	NFULA_CFG_CMD = 1,
	NFULA_CFG_MODE = 2,
	NFULA_CFG_NLBUFSIZ = 3,
	NFULA_CFG_TIMEOUT = 4,
	NFULA_CFG_QTHRESH = 5,
	NFULA_CFG_FLAGS = 6,
	__NFULA_CFG_MAX = 7,
};

enum nfulnl_attr_type {
	NFULA_UNSPEC = 0,
	NFULA_PACKET_HDR = 1,
	NFULA_MARK = 2,
	NFULA_TIMESTAMP = 3,
	NFULA_IFINDEX_INDEV = 4,
	NFULA_IFINDEX_OUTDEV = 5,
	NFULA_IFINDEX_PHYSINDEV = 6,
	NFULA_IFINDEX_PHYSOUTDEV = 7,
	NFULA_HWADDR = 8,
	NFULA_PAYLOAD = 9,
	NFULA_PREFIX = 10,
	NFULA_UID = 11,
	NFULA_SEQ = 12,
	NFULA_SEQ_GLOBAL = 13,
	NFULA_GID = 14,
	NFULA_HWTYPE = 15,
	NFULA_HWHEADER = 16,
	NFULA_HWLEN = 17,
	NFULA_CT = 18,
	NFULA_CT_INFO = 19,
	NFULA_VLAN = 20,
	NFULA_L2HDR = 21,
	__NFULA_MAX = 22,
};

enum nfulnl_msg_config_cmds {
	NFULNL_CFG_CMD_NONE = 0,
	NFULNL_CFG_CMD_BIND = 1,
	NFULNL_CFG_CMD_UNBIND = 2,
	NFULNL_CFG_CMD_PF_BIND = 3,
	NFULNL_CFG_CMD_PF_UNBIND = 4,
};

enum nfulnl_msg_types {
	NFULNL_MSG_PACKET = 0,
	NFULNL_MSG_CONFIG = 1,
	NFULNL_MSG_MAX = 2,
};

enum nfulnl_vlan_attr {
	NFULA_VLAN_UNSPEC = 0,
	NFULA_VLAN_PROTO = 1,
	NFULA_VLAN_TCI = 2,
	__NFULA_VLAN_MAX = 3,
};

enum nh_notifier_info_type {
	NH_NOTIFIER_INFO_TYPE_SINGLE = 0,
	NH_NOTIFIER_INFO_TYPE_GRP = 1,
	NH_NOTIFIER_INFO_TYPE_RES_TABLE = 2,
	NH_NOTIFIER_INFO_TYPE_RES_BUCKET = 3,
	NH_NOTIFIER_INFO_TYPE_GRP_HW_STATS = 4,
};

enum nhlt_device_type {
	NHLT_DEVICE_BT = 0,
	NHLT_DEVICE_DMIC = 1,
	NHLT_DEVICE_I2S = 4,
	NHLT_DEVICE_INVALID = 5,
};

enum nhlt_link_type {
	NHLT_LINK_HDA = 0,
	NHLT_LINK_DSP = 1,
	NHLT_LINK_DMIC = 2,
	NHLT_LINK_SSP = 3,
	NHLT_LINK_INVALID = 4,
};

enum nl80211_ac {
	NL80211_AC_VO = 0,
	NL80211_AC_VI = 1,
	NL80211_AC_BE = 2,
	NL80211_AC_BK = 3,
	NL80211_NUM_ACS = 4,
};

enum nl80211_acl_policy {
	NL80211_ACL_POLICY_ACCEPT_UNLESS_LISTED = 0,
	NL80211_ACL_POLICY_DENY_UNLESS_LISTED = 1,
};

enum nl80211_ap_settings_flags {
	NL80211_AP_SETTINGS_EXTERNAL_AUTH_SUPPORT = 1,
	NL80211_AP_SETTINGS_SA_QUERY_OFFLOAD_SUPPORT = 2,
};

enum nl80211_attr_coalesce_rule {
	__NL80211_COALESCE_RULE_INVALID = 0,
	NL80211_ATTR_COALESCE_RULE_DELAY = 1,
	NL80211_ATTR_COALESCE_RULE_CONDITION = 2,
	NL80211_ATTR_COALESCE_RULE_PKT_PATTERN = 3,
	NUM_NL80211_ATTR_COALESCE_RULE = 4,
	NL80211_ATTR_COALESCE_RULE_MAX = 3,
};

enum nl80211_attr_cqm {
	__NL80211_ATTR_CQM_INVALID = 0,
	NL80211_ATTR_CQM_RSSI_THOLD = 1,
	NL80211_ATTR_CQM_RSSI_HYST = 2,
	NL80211_ATTR_CQM_RSSI_THRESHOLD_EVENT = 3,
	NL80211_ATTR_CQM_PKT_LOSS_EVENT = 4,
	NL80211_ATTR_CQM_TXE_RATE = 5,
	NL80211_ATTR_CQM_TXE_PKTS = 6,
	NL80211_ATTR_CQM_TXE_INTVL = 7,
	NL80211_ATTR_CQM_BEACON_LOSS_EVENT = 8,
	NL80211_ATTR_CQM_RSSI_LEVEL = 9,
	__NL80211_ATTR_CQM_AFTER_LAST = 10,
	NL80211_ATTR_CQM_MAX = 9,
};

enum nl80211_attrs {
	NL80211_ATTR_UNSPEC = 0,
	NL80211_ATTR_WIPHY = 1,
	NL80211_ATTR_WIPHY_NAME = 2,
	NL80211_ATTR_IFINDEX = 3,
	NL80211_ATTR_IFNAME = 4,
	NL80211_ATTR_IFTYPE = 5,
	NL80211_ATTR_MAC = 6,
	NL80211_ATTR_KEY_DATA = 7,
	NL80211_ATTR_KEY_IDX = 8,
	NL80211_ATTR_KEY_CIPHER = 9,
	NL80211_ATTR_KEY_SEQ = 10,
	NL80211_ATTR_KEY_DEFAULT = 11,
	NL80211_ATTR_BEACON_INTERVAL = 12,
	NL80211_ATTR_DTIM_PERIOD = 13,
	NL80211_ATTR_BEACON_HEAD = 14,
	NL80211_ATTR_BEACON_TAIL = 15,
	NL80211_ATTR_STA_AID = 16,
	NL80211_ATTR_STA_FLAGS = 17,
	NL80211_ATTR_STA_LISTEN_INTERVAL = 18,
	NL80211_ATTR_STA_SUPPORTED_RATES = 19,
	NL80211_ATTR_STA_VLAN = 20,
	NL80211_ATTR_STA_INFO = 21,
	NL80211_ATTR_WIPHY_BANDS = 22,
	NL80211_ATTR_MNTR_FLAGS = 23,
	NL80211_ATTR_MESH_ID = 24,
	NL80211_ATTR_STA_PLINK_ACTION = 25,
	NL80211_ATTR_MPATH_NEXT_HOP = 26,
	NL80211_ATTR_MPATH_INFO = 27,
	NL80211_ATTR_BSS_CTS_PROT = 28,
	NL80211_ATTR_BSS_SHORT_PREAMBLE = 29,
	NL80211_ATTR_BSS_SHORT_SLOT_TIME = 30,
	NL80211_ATTR_HT_CAPABILITY = 31,
	NL80211_ATTR_SUPPORTED_IFTYPES = 32,
	NL80211_ATTR_REG_ALPHA2 = 33,
	NL80211_ATTR_REG_RULES = 34,
	NL80211_ATTR_MESH_CONFIG = 35,
	NL80211_ATTR_BSS_BASIC_RATES = 36,
	NL80211_ATTR_WIPHY_TXQ_PARAMS = 37,
	NL80211_ATTR_WIPHY_FREQ = 38,
	NL80211_ATTR_WIPHY_CHANNEL_TYPE = 39,
	NL80211_ATTR_KEY_DEFAULT_MGMT = 40,
	NL80211_ATTR_MGMT_SUBTYPE = 41,
	NL80211_ATTR_IE = 42,
	NL80211_ATTR_MAX_NUM_SCAN_SSIDS = 43,
	NL80211_ATTR_SCAN_FREQUENCIES = 44,
	NL80211_ATTR_SCAN_SSIDS = 45,
	NL80211_ATTR_GENERATION = 46,
	NL80211_ATTR_BSS = 47,
	NL80211_ATTR_REG_INITIATOR = 48,
	NL80211_ATTR_REG_TYPE = 49,
	NL80211_ATTR_SUPPORTED_COMMANDS = 50,
	NL80211_ATTR_FRAME = 51,
	NL80211_ATTR_SSID = 52,
	NL80211_ATTR_AUTH_TYPE = 53,
	NL80211_ATTR_REASON_CODE = 54,
	NL80211_ATTR_KEY_TYPE = 55,
	NL80211_ATTR_MAX_SCAN_IE_LEN = 56,
	NL80211_ATTR_CIPHER_SUITES = 57,
	NL80211_ATTR_FREQ_BEFORE = 58,
	NL80211_ATTR_FREQ_AFTER = 59,
	NL80211_ATTR_FREQ_FIXED = 60,
	NL80211_ATTR_WIPHY_RETRY_SHORT = 61,
	NL80211_ATTR_WIPHY_RETRY_LONG = 62,
	NL80211_ATTR_WIPHY_FRAG_THRESHOLD = 63,
	NL80211_ATTR_WIPHY_RTS_THRESHOLD = 64,
	NL80211_ATTR_TIMED_OUT = 65,
	NL80211_ATTR_USE_MFP = 66,
	NL80211_ATTR_STA_FLAGS2 = 67,
	NL80211_ATTR_CONTROL_PORT = 68,
	NL80211_ATTR_TESTDATA = 69,
	NL80211_ATTR_PRIVACY = 70,
	NL80211_ATTR_DISCONNECTED_BY_AP = 71,
	NL80211_ATTR_STATUS_CODE = 72,
	NL80211_ATTR_CIPHER_SUITES_PAIRWISE = 73,
	NL80211_ATTR_CIPHER_SUITE_GROUP = 74,
	NL80211_ATTR_WPA_VERSIONS = 75,
	NL80211_ATTR_AKM_SUITES = 76,
	NL80211_ATTR_REQ_IE = 77,
	NL80211_ATTR_RESP_IE = 78,
	NL80211_ATTR_PREV_BSSID = 79,
	NL80211_ATTR_KEY = 80,
	NL80211_ATTR_KEYS = 81,
	NL80211_ATTR_PID = 82,
	NL80211_ATTR_4ADDR = 83,
	NL80211_ATTR_SURVEY_INFO = 84,
	NL80211_ATTR_PMKID = 85,
	NL80211_ATTR_MAX_NUM_PMKIDS = 86,
	NL80211_ATTR_DURATION = 87,
	NL80211_ATTR_COOKIE = 88,
	NL80211_ATTR_WIPHY_COVERAGE_CLASS = 89,
	NL80211_ATTR_TX_RATES = 90,
	NL80211_ATTR_FRAME_MATCH = 91,
	NL80211_ATTR_ACK = 92,
	NL80211_ATTR_PS_STATE = 93,
	NL80211_ATTR_CQM = 94,
	NL80211_ATTR_LOCAL_STATE_CHANGE = 95,
	NL80211_ATTR_AP_ISOLATE = 96,
	NL80211_ATTR_WIPHY_TX_POWER_SETTING = 97,
	NL80211_ATTR_WIPHY_TX_POWER_LEVEL = 98,
	NL80211_ATTR_TX_FRAME_TYPES = 99,
	NL80211_ATTR_RX_FRAME_TYPES = 100,
	NL80211_ATTR_FRAME_TYPE = 101,
	NL80211_ATTR_CONTROL_PORT_ETHERTYPE = 102,
	NL80211_ATTR_CONTROL_PORT_NO_ENCRYPT = 103,
	NL80211_ATTR_SUPPORT_IBSS_RSN = 104,
	NL80211_ATTR_WIPHY_ANTENNA_TX = 105,
	NL80211_ATTR_WIPHY_ANTENNA_RX = 106,
	NL80211_ATTR_MCAST_RATE = 107,
	NL80211_ATTR_OFFCHANNEL_TX_OK = 108,
	NL80211_ATTR_BSS_HT_OPMODE = 109,
	NL80211_ATTR_KEY_DEFAULT_TYPES = 110,
	NL80211_ATTR_MAX_REMAIN_ON_CHANNEL_DURATION = 111,
	NL80211_ATTR_MESH_SETUP = 112,
	NL80211_ATTR_WIPHY_ANTENNA_AVAIL_TX = 113,
	NL80211_ATTR_WIPHY_ANTENNA_AVAIL_RX = 114,
	NL80211_ATTR_SUPPORT_MESH_AUTH = 115,
	NL80211_ATTR_STA_PLINK_STATE = 116,
	NL80211_ATTR_WOWLAN_TRIGGERS = 117,
	NL80211_ATTR_WOWLAN_TRIGGERS_SUPPORTED = 118,
	NL80211_ATTR_SCHED_SCAN_INTERVAL = 119,
	NL80211_ATTR_INTERFACE_COMBINATIONS = 120,
	NL80211_ATTR_SOFTWARE_IFTYPES = 121,
	NL80211_ATTR_REKEY_DATA = 122,
	NL80211_ATTR_MAX_NUM_SCHED_SCAN_SSIDS = 123,
	NL80211_ATTR_MAX_SCHED_SCAN_IE_LEN = 124,
	NL80211_ATTR_SCAN_SUPP_RATES = 125,
	NL80211_ATTR_HIDDEN_SSID = 126,
	NL80211_ATTR_IE_PROBE_RESP = 127,
	NL80211_ATTR_IE_ASSOC_RESP = 128,
	NL80211_ATTR_STA_WME = 129,
	NL80211_ATTR_SUPPORT_AP_UAPSD = 130,
	NL80211_ATTR_ROAM_SUPPORT = 131,
	NL80211_ATTR_SCHED_SCAN_MATCH = 132,
	NL80211_ATTR_MAX_MATCH_SETS = 133,
	NL80211_ATTR_PMKSA_CANDIDATE = 134,
	NL80211_ATTR_TX_NO_CCK_RATE = 135,
	NL80211_ATTR_TDLS_ACTION = 136,
	NL80211_ATTR_TDLS_DIALOG_TOKEN = 137,
	NL80211_ATTR_TDLS_OPERATION = 138,
	NL80211_ATTR_TDLS_SUPPORT = 139,
	NL80211_ATTR_TDLS_EXTERNAL_SETUP = 140,
	NL80211_ATTR_DEVICE_AP_SME = 141,
	NL80211_ATTR_DONT_WAIT_FOR_ACK = 142,
	NL80211_ATTR_FEATURE_FLAGS = 143,
	NL80211_ATTR_PROBE_RESP_OFFLOAD = 144,
	NL80211_ATTR_PROBE_RESP = 145,
	NL80211_ATTR_DFS_REGION = 146,
	NL80211_ATTR_DISABLE_HT = 147,
	NL80211_ATTR_HT_CAPABILITY_MASK = 148,
	NL80211_ATTR_NOACK_MAP = 149,
	NL80211_ATTR_INACTIVITY_TIMEOUT = 150,
	NL80211_ATTR_RX_SIGNAL_DBM = 151,
	NL80211_ATTR_BG_SCAN_PERIOD = 152,
	NL80211_ATTR_WDEV = 153,
	NL80211_ATTR_USER_REG_HINT_TYPE = 154,
	NL80211_ATTR_CONN_FAILED_REASON = 155,
	NL80211_ATTR_AUTH_DATA = 156,
	NL80211_ATTR_VHT_CAPABILITY = 157,
	NL80211_ATTR_SCAN_FLAGS = 158,
	NL80211_ATTR_CHANNEL_WIDTH = 159,
	NL80211_ATTR_CENTER_FREQ1 = 160,
	NL80211_ATTR_CENTER_FREQ2 = 161,
	NL80211_ATTR_P2P_CTWINDOW = 162,
	NL80211_ATTR_P2P_OPPPS = 163,
	NL80211_ATTR_LOCAL_MESH_POWER_MODE = 164,
	NL80211_ATTR_ACL_POLICY = 165,
	NL80211_ATTR_MAC_ADDRS = 166,
	NL80211_ATTR_MAC_ACL_MAX = 167,
	NL80211_ATTR_RADAR_EVENT = 168,
	NL80211_ATTR_EXT_CAPA = 169,
	NL80211_ATTR_EXT_CAPA_MASK = 170,
	NL80211_ATTR_STA_CAPABILITY = 171,
	NL80211_ATTR_STA_EXT_CAPABILITY = 172,
	NL80211_ATTR_PROTOCOL_FEATURES = 173,
	NL80211_ATTR_SPLIT_WIPHY_DUMP = 174,
	NL80211_ATTR_DISABLE_VHT = 175,
	NL80211_ATTR_VHT_CAPABILITY_MASK = 176,
	NL80211_ATTR_MDID = 177,
	NL80211_ATTR_IE_RIC = 178,
	NL80211_ATTR_CRIT_PROT_ID = 179,
	NL80211_ATTR_MAX_CRIT_PROT_DURATION = 180,
	NL80211_ATTR_PEER_AID = 181,
	NL80211_ATTR_COALESCE_RULE = 182,
	NL80211_ATTR_CH_SWITCH_COUNT = 183,
	NL80211_ATTR_CH_SWITCH_BLOCK_TX = 184,
	NL80211_ATTR_CSA_IES = 185,
	NL80211_ATTR_CNTDWN_OFFS_BEACON = 186,
	NL80211_ATTR_CNTDWN_OFFS_PRESP = 187,
	NL80211_ATTR_RXMGMT_FLAGS = 188,
	NL80211_ATTR_STA_SUPPORTED_CHANNELS = 189,
	NL80211_ATTR_STA_SUPPORTED_OPER_CLASSES = 190,
	NL80211_ATTR_HANDLE_DFS = 191,
	NL80211_ATTR_SUPPORT_5_MHZ = 192,
	NL80211_ATTR_SUPPORT_10_MHZ = 193,
	NL80211_ATTR_OPMODE_NOTIF = 194,
	NL80211_ATTR_VENDOR_ID = 195,
	NL80211_ATTR_VENDOR_SUBCMD = 196,
	NL80211_ATTR_VENDOR_DATA = 197,
	NL80211_ATTR_VENDOR_EVENTS = 198,
	NL80211_ATTR_QOS_MAP = 199,
	NL80211_ATTR_MAC_HINT = 200,
	NL80211_ATTR_WIPHY_FREQ_HINT = 201,
	NL80211_ATTR_MAX_AP_ASSOC_STA = 202,
	NL80211_ATTR_TDLS_PEER_CAPABILITY = 203,
	NL80211_ATTR_SOCKET_OWNER = 204,
	NL80211_ATTR_CSA_C_OFFSETS_TX = 205,
	NL80211_ATTR_MAX_CSA_COUNTERS = 206,
	NL80211_ATTR_TDLS_INITIATOR = 207,
	NL80211_ATTR_USE_RRM = 208,
	NL80211_ATTR_WIPHY_DYN_ACK = 209,
	NL80211_ATTR_TSID = 210,
	NL80211_ATTR_USER_PRIO = 211,
	NL80211_ATTR_ADMITTED_TIME = 212,
	NL80211_ATTR_SMPS_MODE = 213,
	NL80211_ATTR_OPER_CLASS = 214,
	NL80211_ATTR_MAC_MASK = 215,
	NL80211_ATTR_WIPHY_SELF_MANAGED_REG = 216,
	NL80211_ATTR_EXT_FEATURES = 217,
	NL80211_ATTR_SURVEY_RADIO_STATS = 218,
	NL80211_ATTR_NETNS_FD = 219,
	NL80211_ATTR_SCHED_SCAN_DELAY = 220,
	NL80211_ATTR_REG_INDOOR = 221,
	NL80211_ATTR_MAX_NUM_SCHED_SCAN_PLANS = 222,
	NL80211_ATTR_MAX_SCAN_PLAN_INTERVAL = 223,
	NL80211_ATTR_MAX_SCAN_PLAN_ITERATIONS = 224,
	NL80211_ATTR_SCHED_SCAN_PLANS = 225,
	NL80211_ATTR_PBSS = 226,
	NL80211_ATTR_BSS_SELECT = 227,
	NL80211_ATTR_STA_SUPPORT_P2P_PS = 228,
	NL80211_ATTR_PAD = 229,
	NL80211_ATTR_IFTYPE_EXT_CAPA = 230,
	NL80211_ATTR_MU_MIMO_GROUP_DATA = 231,
	NL80211_ATTR_MU_MIMO_FOLLOW_MAC_ADDR = 232,
	NL80211_ATTR_SCAN_START_TIME_TSF = 233,
	NL80211_ATTR_SCAN_START_TIME_TSF_BSSID = 234,
	NL80211_ATTR_MEASUREMENT_DURATION = 235,
	NL80211_ATTR_MEASUREMENT_DURATION_MANDATORY = 236,
	NL80211_ATTR_MESH_PEER_AID = 237,
	NL80211_ATTR_NAN_MASTER_PREF = 238,
	NL80211_ATTR_BANDS = 239,
	NL80211_ATTR_NAN_FUNC = 240,
	NL80211_ATTR_NAN_MATCH = 241,
	NL80211_ATTR_FILS_KEK = 242,
	NL80211_ATTR_FILS_NONCES = 243,
	NL80211_ATTR_MULTICAST_TO_UNICAST_ENABLED = 244,
	NL80211_ATTR_BSSID = 245,
	NL80211_ATTR_SCHED_SCAN_RELATIVE_RSSI = 246,
	NL80211_ATTR_SCHED_SCAN_RSSI_ADJUST = 247,
	NL80211_ATTR_TIMEOUT_REASON = 248,
	NL80211_ATTR_FILS_ERP_USERNAME = 249,
	NL80211_ATTR_FILS_ERP_REALM = 250,
	NL80211_ATTR_FILS_ERP_NEXT_SEQ_NUM = 251,
	NL80211_ATTR_FILS_ERP_RRK = 252,
	NL80211_ATTR_FILS_CACHE_ID = 253,
	NL80211_ATTR_PMK = 254,
	NL80211_ATTR_SCHED_SCAN_MULTI = 255,
	NL80211_ATTR_SCHED_SCAN_MAX_REQS = 256,
	NL80211_ATTR_WANT_1X_4WAY_HS = 257,
	NL80211_ATTR_PMKR0_NAME = 258,
	NL80211_ATTR_PORT_AUTHORIZED = 259,
	NL80211_ATTR_EXTERNAL_AUTH_ACTION = 260,
	NL80211_ATTR_EXTERNAL_AUTH_SUPPORT = 261,
	NL80211_ATTR_NSS = 262,
	NL80211_ATTR_ACK_SIGNAL = 263,
	NL80211_ATTR_CONTROL_PORT_OVER_NL80211 = 264,
	NL80211_ATTR_TXQ_STATS = 265,
	NL80211_ATTR_TXQ_LIMIT = 266,
	NL80211_ATTR_TXQ_MEMORY_LIMIT = 267,
	NL80211_ATTR_TXQ_QUANTUM = 268,
	NL80211_ATTR_HE_CAPABILITY = 269,
	NL80211_ATTR_FTM_RESPONDER = 270,
	NL80211_ATTR_FTM_RESPONDER_STATS = 271,
	NL80211_ATTR_TIMEOUT = 272,
	NL80211_ATTR_PEER_MEASUREMENTS = 273,
	NL80211_ATTR_AIRTIME_WEIGHT = 274,
	NL80211_ATTR_STA_TX_POWER_SETTING = 275,
	NL80211_ATTR_STA_TX_POWER = 276,
	NL80211_ATTR_SAE_PASSWORD = 277,
	NL80211_ATTR_TWT_RESPONDER = 278,
	NL80211_ATTR_HE_OBSS_PD = 279,
	NL80211_ATTR_WIPHY_EDMG_CHANNELS = 280,
	NL80211_ATTR_WIPHY_EDMG_BW_CONFIG = 281,
	NL80211_ATTR_VLAN_ID = 282,
	NL80211_ATTR_HE_BSS_COLOR = 283,
	NL80211_ATTR_IFTYPE_AKM_SUITES = 284,
	NL80211_ATTR_TID_CONFIG = 285,
	NL80211_ATTR_CONTROL_PORT_NO_PREAUTH = 286,
	NL80211_ATTR_PMK_LIFETIME = 287,
	NL80211_ATTR_PMK_REAUTH_THRESHOLD = 288,
	NL80211_ATTR_RECEIVE_MULTICAST = 289,
	NL80211_ATTR_WIPHY_FREQ_OFFSET = 290,
	NL80211_ATTR_CENTER_FREQ1_OFFSET = 291,
	NL80211_ATTR_SCAN_FREQ_KHZ = 292,
	NL80211_ATTR_HE_6GHZ_CAPABILITY = 293,
	NL80211_ATTR_FILS_DISCOVERY = 294,
	NL80211_ATTR_UNSOL_BCAST_PROBE_RESP = 295,
	NL80211_ATTR_S1G_CAPABILITY = 296,
	NL80211_ATTR_S1G_CAPABILITY_MASK = 297,
	NL80211_ATTR_SAE_PWE = 298,
	NL80211_ATTR_RECONNECT_REQUESTED = 299,
	NL80211_ATTR_SAR_SPEC = 300,
	NL80211_ATTR_DISABLE_HE = 301,
	NL80211_ATTR_OBSS_COLOR_BITMAP = 302,
	NL80211_ATTR_COLOR_CHANGE_COUNT = 303,
	NL80211_ATTR_COLOR_CHANGE_COLOR = 304,
	NL80211_ATTR_COLOR_CHANGE_ELEMS = 305,
	NL80211_ATTR_MBSSID_CONFIG = 306,
	NL80211_ATTR_MBSSID_ELEMS = 307,
	NL80211_ATTR_RADAR_BACKGROUND = 308,
	NL80211_ATTR_AP_SETTINGS_FLAGS = 309,
	NL80211_ATTR_EHT_CAPABILITY = 310,
	NL80211_ATTR_DISABLE_EHT = 311,
	NL80211_ATTR_MLO_LINKS = 312,
	NL80211_ATTR_MLO_LINK_ID = 313,
	NL80211_ATTR_MLD_ADDR = 314,
	NL80211_ATTR_MLO_SUPPORT = 315,
	NL80211_ATTR_MAX_NUM_AKM_SUITES = 316,
	NL80211_ATTR_EML_CAPABILITY = 317,
	NL80211_ATTR_MLD_CAPA_AND_OPS = 318,
	NL80211_ATTR_TX_HW_TIMESTAMP = 319,
	NL80211_ATTR_RX_HW_TIMESTAMP = 320,
	NL80211_ATTR_TD_BITMAP = 321,
	NL80211_ATTR_PUNCT_BITMAP = 322,
	NL80211_ATTR_MAX_HW_TIMESTAMP_PEERS = 323,
	NL80211_ATTR_HW_TIMESTAMP_ENABLED = 324,
	NL80211_ATTR_EMA_RNR_ELEMS = 325,
	NL80211_ATTR_MLO_LINK_DISABLED = 326,
	NL80211_ATTR_BSS_DUMP_INCLUDE_USE_DATA = 327,
	NL80211_ATTR_MLO_TTLM_DLINK = 328,
	NL80211_ATTR_MLO_TTLM_ULINK = 329,
	NL80211_ATTR_ASSOC_SPP_AMSDU = 330,
	NL80211_ATTR_WIPHY_RADIOS = 331,
	NL80211_ATTR_WIPHY_INTERFACE_COMBINATIONS = 332,
	NL80211_ATTR_VIF_RADIO_MASK = 333,
	NL80211_ATTR_SUPPORTED_SELECTORS = 334,
	NL80211_ATTR_MLO_RECONF_REM_LINKS = 335,
	NL80211_ATTR_EPCS = 336,
	__NL80211_ATTR_AFTER_LAST = 337,
	NUM_NL80211_ATTR = 337,
	NL80211_ATTR_MAX = 336,
};

enum nl80211_auth_type {
	NL80211_AUTHTYPE_OPEN_SYSTEM = 0,
	NL80211_AUTHTYPE_SHARED_KEY = 1,
	NL80211_AUTHTYPE_FT = 2,
	NL80211_AUTHTYPE_NETWORK_EAP = 3,
	NL80211_AUTHTYPE_SAE = 4,
	NL80211_AUTHTYPE_FILS_SK = 5,
	NL80211_AUTHTYPE_FILS_SK_PFS = 6,
	NL80211_AUTHTYPE_FILS_PK = 7,
	__NL80211_AUTHTYPE_NUM = 8,
	NL80211_AUTHTYPE_MAX = 7,
	NL80211_AUTHTYPE_AUTOMATIC = 8,
};

enum nl80211_band {
	NL80211_BAND_2GHZ = 0,
	NL80211_BAND_5GHZ = 1,
	NL80211_BAND_60GHZ = 2,
	NL80211_BAND_6GHZ = 3,
	NL80211_BAND_S1GHZ = 4,
	NL80211_BAND_LC = 5,
	NUM_NL80211_BANDS = 6,
};

enum nl80211_band_attr {
	__NL80211_BAND_ATTR_INVALID = 0,
	NL80211_BAND_ATTR_FREQS = 1,
	NL80211_BAND_ATTR_RATES = 2,
	NL80211_BAND_ATTR_HT_MCS_SET = 3,
	NL80211_BAND_ATTR_HT_CAPA = 4,
	NL80211_BAND_ATTR_HT_AMPDU_FACTOR = 5,
	NL80211_BAND_ATTR_HT_AMPDU_DENSITY = 6,
	NL80211_BAND_ATTR_VHT_MCS_SET = 7,
	NL80211_BAND_ATTR_VHT_CAPA = 8,
	NL80211_BAND_ATTR_IFTYPE_DATA = 9,
	NL80211_BAND_ATTR_EDMG_CHANNELS = 10,
	NL80211_BAND_ATTR_EDMG_BW_CONFIG = 11,
	NL80211_BAND_ATTR_S1G_MCS_NSS_SET = 12,
	NL80211_BAND_ATTR_S1G_CAPA = 13,
	__NL80211_BAND_ATTR_AFTER_LAST = 14,
	NL80211_BAND_ATTR_MAX = 13,
};

enum nl80211_band_iftype_attr {
	__NL80211_BAND_IFTYPE_ATTR_INVALID = 0,
	NL80211_BAND_IFTYPE_ATTR_IFTYPES = 1,
	NL80211_BAND_IFTYPE_ATTR_HE_CAP_MAC = 2,
	NL80211_BAND_IFTYPE_ATTR_HE_CAP_PHY = 3,
	NL80211_BAND_IFTYPE_ATTR_HE_CAP_MCS_SET = 4,
	NL80211_BAND_IFTYPE_ATTR_HE_CAP_PPE = 5,
	NL80211_BAND_IFTYPE_ATTR_HE_6GHZ_CAPA = 6,
	NL80211_BAND_IFTYPE_ATTR_VENDOR_ELEMS = 7,
	NL80211_BAND_IFTYPE_ATTR_EHT_CAP_MAC = 8,
	NL80211_BAND_IFTYPE_ATTR_EHT_CAP_PHY = 9,
	NL80211_BAND_IFTYPE_ATTR_EHT_CAP_MCS_SET = 10,
	NL80211_BAND_IFTYPE_ATTR_EHT_CAP_PPE = 11,
	__NL80211_BAND_IFTYPE_ATTR_AFTER_LAST = 12,
	NL80211_BAND_IFTYPE_ATTR_MAX = 11,
};

enum nl80211_bitrate_attr {
	__NL80211_BITRATE_ATTR_INVALID = 0,
	NL80211_BITRATE_ATTR_RATE = 1,
	NL80211_BITRATE_ATTR_2GHZ_SHORTPREAMBLE = 2,
	__NL80211_BITRATE_ATTR_AFTER_LAST = 3,
	NL80211_BITRATE_ATTR_MAX = 2,
};

enum nl80211_bss {
	__NL80211_BSS_INVALID = 0,
	NL80211_BSS_BSSID = 1,
	NL80211_BSS_FREQUENCY = 2,
	NL80211_BSS_TSF = 3,
	NL80211_BSS_BEACON_INTERVAL = 4,
	NL80211_BSS_CAPABILITY = 5,
	NL80211_BSS_INFORMATION_ELEMENTS = 6,
	NL80211_BSS_SIGNAL_MBM = 7,
	NL80211_BSS_SIGNAL_UNSPEC = 8,
	NL80211_BSS_STATUS = 9,
	NL80211_BSS_SEEN_MS_AGO = 10,
	NL80211_BSS_BEACON_IES = 11,
	NL80211_BSS_CHAN_WIDTH = 12,
	NL80211_BSS_BEACON_TSF = 13,
	NL80211_BSS_PRESP_DATA = 14,
	NL80211_BSS_LAST_SEEN_BOOTTIME = 15,
	NL80211_BSS_PAD = 16,
	NL80211_BSS_PARENT_TSF = 17,
	NL80211_BSS_PARENT_BSSID = 18,
	NL80211_BSS_CHAIN_SIGNAL = 19,
	NL80211_BSS_FREQUENCY_OFFSET = 20,
	NL80211_BSS_MLO_LINK_ID = 21,
	NL80211_BSS_MLD_ADDR = 22,
	NL80211_BSS_USE_FOR = 23,
	NL80211_BSS_CANNOT_USE_REASONS = 24,
	__NL80211_BSS_AFTER_LAST = 25,
	NL80211_BSS_MAX = 24,
};

enum nl80211_bss_cannot_use_reasons {
	NL80211_BSS_CANNOT_USE_NSTR_NONPRIMARY = 1,
	NL80211_BSS_CANNOT_USE_6GHZ_PWR_MISMATCH = 2,
};

enum nl80211_bss_color_attributes {
	__NL80211_HE_BSS_COLOR_ATTR_INVALID = 0,
	NL80211_HE_BSS_COLOR_ATTR_COLOR = 1,
	NL80211_HE_BSS_COLOR_ATTR_DISABLED = 2,
	NL80211_HE_BSS_COLOR_ATTR_PARTIAL = 3,
	__NL80211_HE_BSS_COLOR_ATTR_LAST = 4,
	NL80211_HE_BSS_COLOR_ATTR_MAX = 3,
};

enum nl80211_bss_select_attr {
	__NL80211_BSS_SELECT_ATTR_INVALID = 0,
	NL80211_BSS_SELECT_ATTR_RSSI = 1,
	NL80211_BSS_SELECT_ATTR_BAND_PREF = 2,
	NL80211_BSS_SELECT_ATTR_RSSI_ADJUST = 3,
	__NL80211_BSS_SELECT_ATTR_AFTER_LAST = 4,
	NL80211_BSS_SELECT_ATTR_MAX = 3,
};

enum nl80211_bss_status {
	NL80211_BSS_STATUS_AUTHENTICATED = 0,
	NL80211_BSS_STATUS_ASSOCIATED = 1,
	NL80211_BSS_STATUS_IBSS_JOINED = 2,
};

enum nl80211_bss_use_for {
	NL80211_BSS_USE_FOR_NORMAL = 1,
	NL80211_BSS_USE_FOR_MLD_LINK = 2,
};

enum nl80211_chan_width {
	NL80211_CHAN_WIDTH_20_NOHT = 0,
	NL80211_CHAN_WIDTH_20 = 1,
	NL80211_CHAN_WIDTH_40 = 2,
	NL80211_CHAN_WIDTH_80 = 3,
	NL80211_CHAN_WIDTH_80P80 = 4,
	NL80211_CHAN_WIDTH_160 = 5,
	NL80211_CHAN_WIDTH_5 = 6,
	NL80211_CHAN_WIDTH_10 = 7,
	NL80211_CHAN_WIDTH_1 = 8,
	NL80211_CHAN_WIDTH_2 = 9,
	NL80211_CHAN_WIDTH_4 = 10,
	NL80211_CHAN_WIDTH_8 = 11,
	NL80211_CHAN_WIDTH_16 = 12,
	NL80211_CHAN_WIDTH_320 = 13,
};

enum nl80211_channel_type {
	NL80211_CHAN_NO_HT = 0,
	NL80211_CHAN_HT20 = 1,
	NL80211_CHAN_HT40MINUS = 2,
	NL80211_CHAN_HT40PLUS = 3,
};

enum nl80211_coalesce_condition {
	NL80211_COALESCE_CONDITION_MATCH = 0,
	NL80211_COALESCE_CONDITION_NO_MATCH = 1,
};

enum nl80211_commands {
	NL80211_CMD_UNSPEC = 0,
	NL80211_CMD_GET_WIPHY = 1,
	NL80211_CMD_SET_WIPHY = 2,
	NL80211_CMD_NEW_WIPHY = 3,
	NL80211_CMD_DEL_WIPHY = 4,
	NL80211_CMD_GET_INTERFACE = 5,
	NL80211_CMD_SET_INTERFACE = 6,
	NL80211_CMD_NEW_INTERFACE = 7,
	NL80211_CMD_DEL_INTERFACE = 8,
	NL80211_CMD_GET_KEY = 9,
	NL80211_CMD_SET_KEY = 10,
	NL80211_CMD_NEW_KEY = 11,
	NL80211_CMD_DEL_KEY = 12,
	NL80211_CMD_GET_BEACON = 13,
	NL80211_CMD_SET_BEACON = 14,
	NL80211_CMD_START_AP = 15,
	NL80211_CMD_NEW_BEACON = 15,
	NL80211_CMD_STOP_AP = 16,
	NL80211_CMD_DEL_BEACON = 16,
	NL80211_CMD_GET_STATION = 17,
	NL80211_CMD_SET_STATION = 18,
	NL80211_CMD_NEW_STATION = 19,
	NL80211_CMD_DEL_STATION = 20,
	NL80211_CMD_GET_MPATH = 21,
	NL80211_CMD_SET_MPATH = 22,
	NL80211_CMD_NEW_MPATH = 23,
	NL80211_CMD_DEL_MPATH = 24,
	NL80211_CMD_SET_BSS = 25,
	NL80211_CMD_SET_REG = 26,
	NL80211_CMD_REQ_SET_REG = 27,
	NL80211_CMD_GET_MESH_CONFIG = 28,
	NL80211_CMD_SET_MESH_CONFIG = 29,
	NL80211_CMD_SET_MGMT_EXTRA_IE = 30,
	NL80211_CMD_GET_REG = 31,
	NL80211_CMD_GET_SCAN = 32,
	NL80211_CMD_TRIGGER_SCAN = 33,
	NL80211_CMD_NEW_SCAN_RESULTS = 34,
	NL80211_CMD_SCAN_ABORTED = 35,
	NL80211_CMD_REG_CHANGE = 36,
	NL80211_CMD_AUTHENTICATE = 37,
	NL80211_CMD_ASSOCIATE = 38,
	NL80211_CMD_DEAUTHENTICATE = 39,
	NL80211_CMD_DISASSOCIATE = 40,
	NL80211_CMD_MICHAEL_MIC_FAILURE = 41,
	NL80211_CMD_REG_BEACON_HINT = 42,
	NL80211_CMD_JOIN_IBSS = 43,
	NL80211_CMD_LEAVE_IBSS = 44,
	NL80211_CMD_TESTMODE = 45,
	NL80211_CMD_CONNECT = 46,
	NL80211_CMD_ROAM = 47,
	NL80211_CMD_DISCONNECT = 48,
	NL80211_CMD_SET_WIPHY_NETNS = 49,
	NL80211_CMD_GET_SURVEY = 50,
	NL80211_CMD_NEW_SURVEY_RESULTS = 51,
	NL80211_CMD_SET_PMKSA = 52,
	NL80211_CMD_DEL_PMKSA = 53,
	NL80211_CMD_FLUSH_PMKSA = 54,
	NL80211_CMD_REMAIN_ON_CHANNEL = 55,
	NL80211_CMD_CANCEL_REMAIN_ON_CHANNEL = 56,
	NL80211_CMD_SET_TX_BITRATE_MASK = 57,
	NL80211_CMD_REGISTER_FRAME = 58,
	NL80211_CMD_REGISTER_ACTION = 58,
	NL80211_CMD_FRAME = 59,
	NL80211_CMD_ACTION = 59,
	NL80211_CMD_FRAME_TX_STATUS = 60,
	NL80211_CMD_ACTION_TX_STATUS = 60,
	NL80211_CMD_SET_POWER_SAVE = 61,
	NL80211_CMD_GET_POWER_SAVE = 62,
	NL80211_CMD_SET_CQM = 63,
	NL80211_CMD_NOTIFY_CQM = 64,
	NL80211_CMD_SET_CHANNEL = 65,
	NL80211_CMD_SET_WDS_PEER = 66,
	NL80211_CMD_FRAME_WAIT_CANCEL = 67,
	NL80211_CMD_JOIN_MESH = 68,
	NL80211_CMD_LEAVE_MESH = 69,
	NL80211_CMD_UNPROT_DEAUTHENTICATE = 70,
	NL80211_CMD_UNPROT_DISASSOCIATE = 71,
	NL80211_CMD_NEW_PEER_CANDIDATE = 72,
	NL80211_CMD_GET_WOWLAN = 73,
	NL80211_CMD_SET_WOWLAN = 74,
	NL80211_CMD_START_SCHED_SCAN = 75,
	NL80211_CMD_STOP_SCHED_SCAN = 76,
	NL80211_CMD_SCHED_SCAN_RESULTS = 77,
	NL80211_CMD_SCHED_SCAN_STOPPED = 78,
	NL80211_CMD_SET_REKEY_OFFLOAD = 79,
	NL80211_CMD_PMKSA_CANDIDATE = 80,
	NL80211_CMD_TDLS_OPER = 81,
	NL80211_CMD_TDLS_MGMT = 82,
	NL80211_CMD_UNEXPECTED_FRAME = 83,
	NL80211_CMD_PROBE_CLIENT = 84,
	NL80211_CMD_REGISTER_BEACONS = 85,
	NL80211_CMD_UNEXPECTED_4ADDR_FRAME = 86,
	NL80211_CMD_SET_NOACK_MAP = 87,
	NL80211_CMD_CH_SWITCH_NOTIFY = 88,
	NL80211_CMD_START_P2P_DEVICE = 89,
	NL80211_CMD_STOP_P2P_DEVICE = 90,
	NL80211_CMD_CONN_FAILED = 91,
	NL80211_CMD_SET_MCAST_RATE = 92,
	NL80211_CMD_SET_MAC_ACL = 93,
	NL80211_CMD_RADAR_DETECT = 94,
	NL80211_CMD_GET_PROTOCOL_FEATURES = 95,
	NL80211_CMD_UPDATE_FT_IES = 96,
	NL80211_CMD_FT_EVENT = 97,
	NL80211_CMD_CRIT_PROTOCOL_START = 98,
	NL80211_CMD_CRIT_PROTOCOL_STOP = 99,
	NL80211_CMD_GET_COALESCE = 100,
	NL80211_CMD_SET_COALESCE = 101,
	NL80211_CMD_CHANNEL_SWITCH = 102,
	NL80211_CMD_VENDOR = 103,
	NL80211_CMD_SET_QOS_MAP = 104,
	NL80211_CMD_ADD_TX_TS = 105,
	NL80211_CMD_DEL_TX_TS = 106,
	NL80211_CMD_GET_MPP = 107,
	NL80211_CMD_JOIN_OCB = 108,
	NL80211_CMD_LEAVE_OCB = 109,
	NL80211_CMD_CH_SWITCH_STARTED_NOTIFY = 110,
	NL80211_CMD_TDLS_CHANNEL_SWITCH = 111,
	NL80211_CMD_TDLS_CANCEL_CHANNEL_SWITCH = 112,
	NL80211_CMD_WIPHY_REG_CHANGE = 113,
	NL80211_CMD_ABORT_SCAN = 114,
	NL80211_CMD_START_NAN = 115,
	NL80211_CMD_STOP_NAN = 116,
	NL80211_CMD_ADD_NAN_FUNCTION = 117,
	NL80211_CMD_DEL_NAN_FUNCTION = 118,
	NL80211_CMD_CHANGE_NAN_CONFIG = 119,
	NL80211_CMD_NAN_MATCH = 120,
	NL80211_CMD_SET_MULTICAST_TO_UNICAST = 121,
	NL80211_CMD_UPDATE_CONNECT_PARAMS = 122,
	NL80211_CMD_SET_PMK = 123,
	NL80211_CMD_DEL_PMK = 124,
	NL80211_CMD_PORT_AUTHORIZED = 125,
	NL80211_CMD_RELOAD_REGDB = 126,
	NL80211_CMD_EXTERNAL_AUTH = 127,
	NL80211_CMD_STA_OPMODE_CHANGED = 128,
	NL80211_CMD_CONTROL_PORT_FRAME = 129,
	NL80211_CMD_GET_FTM_RESPONDER_STATS = 130,
	NL80211_CMD_PEER_MEASUREMENT_START = 131,
	NL80211_CMD_PEER_MEASUREMENT_RESULT = 132,
	NL80211_CMD_PEER_MEASUREMENT_COMPLETE = 133,
	NL80211_CMD_NOTIFY_RADAR = 134,
	NL80211_CMD_UPDATE_OWE_INFO = 135,
	NL80211_CMD_PROBE_MESH_LINK = 136,
	NL80211_CMD_SET_TID_CONFIG = 137,
	NL80211_CMD_UNPROT_BEACON = 138,
	NL80211_CMD_CONTROL_PORT_FRAME_TX_STATUS = 139,
	NL80211_CMD_SET_SAR_SPECS = 140,
	NL80211_CMD_OBSS_COLOR_COLLISION = 141,
	NL80211_CMD_COLOR_CHANGE_REQUEST = 142,
	NL80211_CMD_COLOR_CHANGE_STARTED = 143,
	NL80211_CMD_COLOR_CHANGE_ABORTED = 144,
	NL80211_CMD_COLOR_CHANGE_COMPLETED = 145,
	NL80211_CMD_SET_FILS_AAD = 146,
	NL80211_CMD_ASSOC_COMEBACK = 147,
	NL80211_CMD_ADD_LINK = 148,
	NL80211_CMD_REMOVE_LINK = 149,
	NL80211_CMD_ADD_LINK_STA = 150,
	NL80211_CMD_MODIFY_LINK_STA = 151,
	NL80211_CMD_REMOVE_LINK_STA = 152,
	NL80211_CMD_SET_HW_TIMESTAMP = 153,
	NL80211_CMD_LINKS_REMOVED = 154,
	NL80211_CMD_SET_TID_TO_LINK_MAPPING = 155,
	NL80211_CMD_ASSOC_MLO_RECONF = 156,
	NL80211_CMD_EPCS_CFG = 157,
	__NL80211_CMD_AFTER_LAST = 158,
	NL80211_CMD_MAX = 157,
};

enum nl80211_connect_failed_reason {
	NL80211_CONN_FAIL_MAX_CLIENTS = 0,
	NL80211_CONN_FAIL_BLOCKED_CLIENT = 1,
};

enum nl80211_cqm_rssi_threshold_event {
	NL80211_CQM_RSSI_THRESHOLD_EVENT_LOW = 0,
	NL80211_CQM_RSSI_THRESHOLD_EVENT_HIGH = 1,
	NL80211_CQM_RSSI_BEACON_LOSS_EVENT = 2,
};

enum nl80211_crit_proto_id {
	NL80211_CRIT_PROTO_UNSPEC = 0,
	NL80211_CRIT_PROTO_DHCP = 1,
	NL80211_CRIT_PROTO_EAPOL = 2,
	NL80211_CRIT_PROTO_APIPA = 3,
	NUM_NL80211_CRIT_PROTO = 4,
};

enum nl80211_dfs_regions {
	NL80211_DFS_UNSET = 0,
	NL80211_DFS_FCC = 1,
	NL80211_DFS_ETSI = 2,
	NL80211_DFS_JP = 3,
};

enum nl80211_dfs_state {
	NL80211_DFS_USABLE = 0,
	NL80211_DFS_UNAVAILABLE = 1,
	NL80211_DFS_AVAILABLE = 2,
};

enum nl80211_eht_gi {
	NL80211_RATE_INFO_EHT_GI_0_8 = 0,
	NL80211_RATE_INFO_EHT_GI_1_6 = 1,
	NL80211_RATE_INFO_EHT_GI_3_2 = 2,
};

enum nl80211_eht_ru_alloc {
	NL80211_RATE_INFO_EHT_RU_ALLOC_26 = 0,
	NL80211_RATE_INFO_EHT_RU_ALLOC_52 = 1,
	NL80211_RATE_INFO_EHT_RU_ALLOC_52P26 = 2,
	NL80211_RATE_INFO_EHT_RU_ALLOC_106 = 3,
	NL80211_RATE_INFO_EHT_RU_ALLOC_106P26 = 4,
	NL80211_RATE_INFO_EHT_RU_ALLOC_242 = 5,
	NL80211_RATE_INFO_EHT_RU_ALLOC_484 = 6,
	NL80211_RATE_INFO_EHT_RU_ALLOC_484P242 = 7,
	NL80211_RATE_INFO_EHT_RU_ALLOC_996 = 8,
	NL80211_RATE_INFO_EHT_RU_ALLOC_996P484 = 9,
	NL80211_RATE_INFO_EHT_RU_ALLOC_996P484P242 = 10,
	NL80211_RATE_INFO_EHT_RU_ALLOC_2x996 = 11,
	NL80211_RATE_INFO_EHT_RU_ALLOC_2x996P484 = 12,
	NL80211_RATE_INFO_EHT_RU_ALLOC_3x996 = 13,
	NL80211_RATE_INFO_EHT_RU_ALLOC_3x996P484 = 14,
	NL80211_RATE_INFO_EHT_RU_ALLOC_4x996 = 15,
};

enum nl80211_ext_feature_index {
	NL80211_EXT_FEATURE_VHT_IBSS = 0,
	NL80211_EXT_FEATURE_RRM = 1,
	NL80211_EXT_FEATURE_MU_MIMO_AIR_SNIFFER = 2,
	NL80211_EXT_FEATURE_SCAN_START_TIME = 3,
	NL80211_EXT_FEATURE_BSS_PARENT_TSF = 4,
	NL80211_EXT_FEATURE_SET_SCAN_DWELL = 5,
	NL80211_EXT_FEATURE_BEACON_RATE_LEGACY = 6,
	NL80211_EXT_FEATURE_BEACON_RATE_HT = 7,
	NL80211_EXT_FEATURE_BEACON_RATE_VHT = 8,
	NL80211_EXT_FEATURE_FILS_STA = 9,
	NL80211_EXT_FEATURE_MGMT_TX_RANDOM_TA = 10,
	NL80211_EXT_FEATURE_MGMT_TX_RANDOM_TA_CONNECTED = 11,
	NL80211_EXT_FEATURE_SCHED_SCAN_RELATIVE_RSSI = 12,
	NL80211_EXT_FEATURE_CQM_RSSI_LIST = 13,
	NL80211_EXT_FEATURE_FILS_SK_OFFLOAD = 14,
	NL80211_EXT_FEATURE_4WAY_HANDSHAKE_STA_PSK = 15,
	NL80211_EXT_FEATURE_4WAY_HANDSHAKE_STA_1X = 16,
	NL80211_EXT_FEATURE_FILS_MAX_CHANNEL_TIME = 17,
	NL80211_EXT_FEATURE_ACCEPT_BCAST_PROBE_RESP = 18,
	NL80211_EXT_FEATURE_OCE_PROBE_REQ_HIGH_TX_RATE = 19,
	NL80211_EXT_FEATURE_OCE_PROBE_REQ_DEFERRAL_SUPPRESSION = 20,
	NL80211_EXT_FEATURE_MFP_OPTIONAL = 21,
	NL80211_EXT_FEATURE_LOW_SPAN_SCAN = 22,
	NL80211_EXT_FEATURE_LOW_POWER_SCAN = 23,
	NL80211_EXT_FEATURE_HIGH_ACCURACY_SCAN = 24,
	NL80211_EXT_FEATURE_DFS_OFFLOAD = 25,
	NL80211_EXT_FEATURE_CONTROL_PORT_OVER_NL80211 = 26,
	NL80211_EXT_FEATURE_ACK_SIGNAL_SUPPORT = 27,
	NL80211_EXT_FEATURE_DATA_ACK_SIGNAL_SUPPORT = 27,
	NL80211_EXT_FEATURE_TXQS = 28,
	NL80211_EXT_FEATURE_SCAN_RANDOM_SN = 29,
	NL80211_EXT_FEATURE_SCAN_MIN_PREQ_CONTENT = 30,
	NL80211_EXT_FEATURE_CAN_REPLACE_PTK0 = 31,
	NL80211_EXT_FEATURE_ENABLE_FTM_RESPONDER = 32,
	NL80211_EXT_FEATURE_AIRTIME_FAIRNESS = 33,
	NL80211_EXT_FEATURE_AP_PMKSA_CACHING = 34,
	NL80211_EXT_FEATURE_SCHED_SCAN_BAND_SPECIFIC_RSSI_THOLD = 35,
	NL80211_EXT_FEATURE_EXT_KEY_ID = 36,
	NL80211_EXT_FEATURE_STA_TX_PWR = 37,
	NL80211_EXT_FEATURE_SAE_OFFLOAD = 38,
	NL80211_EXT_FEATURE_VLAN_OFFLOAD = 39,
	NL80211_EXT_FEATURE_AQL = 40,
	NL80211_EXT_FEATURE_BEACON_PROTECTION = 41,
	NL80211_EXT_FEATURE_CONTROL_PORT_NO_PREAUTH = 42,
	NL80211_EXT_FEATURE_PROTECTED_TWT = 43,
	NL80211_EXT_FEATURE_DEL_IBSS_STA = 44,
	NL80211_EXT_FEATURE_MULTICAST_REGISTRATIONS = 45,
	NL80211_EXT_FEATURE_BEACON_PROTECTION_CLIENT = 46,
	NL80211_EXT_FEATURE_SCAN_FREQ_KHZ = 47,
	NL80211_EXT_FEATURE_CONTROL_PORT_OVER_NL80211_TX_STATUS = 48,
	NL80211_EXT_FEATURE_OPERATING_CHANNEL_VALIDATION = 49,
	NL80211_EXT_FEATURE_4WAY_HANDSHAKE_AP_PSK = 50,
	NL80211_EXT_FEATURE_SAE_OFFLOAD_AP = 51,
	NL80211_EXT_FEATURE_FILS_DISCOVERY = 52,
	NL80211_EXT_FEATURE_UNSOL_BCAST_PROBE_RESP = 53,
	NL80211_EXT_FEATURE_BEACON_RATE_HE = 54,
	NL80211_EXT_FEATURE_SECURE_LTF = 55,
	NL80211_EXT_FEATURE_SECURE_RTT = 56,
	NL80211_EXT_FEATURE_PROT_RANGE_NEGO_AND_MEASURE = 57,
	NL80211_EXT_FEATURE_BSS_COLOR = 58,
	NL80211_EXT_FEATURE_FILS_CRYPTO_OFFLOAD = 59,
	NL80211_EXT_FEATURE_RADAR_BACKGROUND = 60,
	NL80211_EXT_FEATURE_POWERED_ADDR_CHANGE = 61,
	NL80211_EXT_FEATURE_PUNCT = 62,
	NL80211_EXT_FEATURE_SECURE_NAN = 63,
	NL80211_EXT_FEATURE_AUTH_AND_DEAUTH_RANDOM_TA = 64,
	NL80211_EXT_FEATURE_OWE_OFFLOAD = 65,
	NL80211_EXT_FEATURE_OWE_OFFLOAD_AP = 66,
	NL80211_EXT_FEATURE_DFS_CONCURRENT = 67,
	NL80211_EXT_FEATURE_SPP_AMSDU_SUPPORT = 68,
	NUM_NL80211_EXT_FEATURES = 69,
	MAX_NL80211_EXT_FEATURES = 68,
};

enum nl80211_external_auth_action {
	NL80211_EXTERNAL_AUTH_START = 0,
	NL80211_EXTERNAL_AUTH_ABORT = 1,
};

enum nl80211_feature_flags {
	NL80211_FEATURE_SK_TX_STATUS = 1,
	NL80211_FEATURE_HT_IBSS = 2,
	NL80211_FEATURE_INACTIVITY_TIMER = 4,
	NL80211_FEATURE_CELL_BASE_REG_HINTS = 8,
	NL80211_FEATURE_P2P_DEVICE_NEEDS_CHANNEL = 16,
	NL80211_FEATURE_SAE = 32,
	NL80211_FEATURE_LOW_PRIORITY_SCAN = 64,
	NL80211_FEATURE_SCAN_FLUSH = 128,
	NL80211_FEATURE_AP_SCAN = 256,
	NL80211_FEATURE_VIF_TXPOWER = 512,
	NL80211_FEATURE_NEED_OBSS_SCAN = 1024,
	NL80211_FEATURE_P2P_GO_CTWIN = 2048,
	NL80211_FEATURE_P2P_GO_OPPPS = 4096,
	NL80211_FEATURE_ADVERTISE_CHAN_LIMITS = 16384,
	NL80211_FEATURE_FULL_AP_CLIENT_STATE = 32768,
	NL80211_FEATURE_USERSPACE_MPM = 65536,
	NL80211_FEATURE_ACTIVE_MONITOR = 131072,
	NL80211_FEATURE_AP_MODE_CHAN_WIDTH_CHANGE = 262144,
	NL80211_FEATURE_DS_PARAM_SET_IE_IN_PROBES = 524288,
	NL80211_FEATURE_WFA_TPC_IE_IN_PROBES = 1048576,
	NL80211_FEATURE_QUIET = 2097152,
	NL80211_FEATURE_TX_POWER_INSERTION = 4194304,
	NL80211_FEATURE_ACKTO_ESTIMATION = 8388608,
	NL80211_FEATURE_STATIC_SMPS = 16777216,
	NL80211_FEATURE_DYNAMIC_SMPS = 33554432,
	NL80211_FEATURE_SUPPORTS_WMM_ADMISSION = 67108864,
	NL80211_FEATURE_MAC_ON_CREATE = 134217728,
	NL80211_FEATURE_TDLS_CHANNEL_SWITCH = 268435456,
	NL80211_FEATURE_SCAN_RANDOM_MAC_ADDR = 536870912,
	NL80211_FEATURE_SCHED_SCAN_RANDOM_MAC_ADDR = 1073741824,
	NL80211_FEATURE_ND_RANDOM_MAC_ADDR = 2147483648,
};

enum nl80211_fils_discovery_attributes {
	__NL80211_FILS_DISCOVERY_ATTR_INVALID = 0,
	NL80211_FILS_DISCOVERY_ATTR_INT_MIN = 1,
	NL80211_FILS_DISCOVERY_ATTR_INT_MAX = 2,
	NL80211_FILS_DISCOVERY_ATTR_TMPL = 3,
	__NL80211_FILS_DISCOVERY_ATTR_LAST = 4,
	NL80211_FILS_DISCOVERY_ATTR_MAX = 3,
};

enum nl80211_frequency_attr {
	__NL80211_FREQUENCY_ATTR_INVALID = 0,
	NL80211_FREQUENCY_ATTR_FREQ = 1,
	NL80211_FREQUENCY_ATTR_DISABLED = 2,
	NL80211_FREQUENCY_ATTR_NO_IR = 3,
	__NL80211_FREQUENCY_ATTR_NO_IBSS = 4,
	NL80211_FREQUENCY_ATTR_RADAR = 5,
	NL80211_FREQUENCY_ATTR_MAX_TX_POWER = 6,
	NL80211_FREQUENCY_ATTR_DFS_STATE = 7,
	NL80211_FREQUENCY_ATTR_DFS_TIME = 8,
	NL80211_FREQUENCY_ATTR_NO_HT40_MINUS = 9,
	NL80211_FREQUENCY_ATTR_NO_HT40_PLUS = 10,
	NL80211_FREQUENCY_ATTR_NO_80MHZ = 11,
	NL80211_FREQUENCY_ATTR_NO_160MHZ = 12,
	NL80211_FREQUENCY_ATTR_DFS_CAC_TIME = 13,
	NL80211_FREQUENCY_ATTR_INDOOR_ONLY = 14,
	NL80211_FREQUENCY_ATTR_IR_CONCURRENT = 15,
	NL80211_FREQUENCY_ATTR_NO_20MHZ = 16,
	NL80211_FREQUENCY_ATTR_NO_10MHZ = 17,
	NL80211_FREQUENCY_ATTR_WMM = 18,
	NL80211_FREQUENCY_ATTR_NO_HE = 19,
	NL80211_FREQUENCY_ATTR_OFFSET = 20,
	NL80211_FREQUENCY_ATTR_1MHZ = 21,
	NL80211_FREQUENCY_ATTR_2MHZ = 22,
	NL80211_FREQUENCY_ATTR_4MHZ = 23,
	NL80211_FREQUENCY_ATTR_8MHZ = 24,
	NL80211_FREQUENCY_ATTR_16MHZ = 25,
	NL80211_FREQUENCY_ATTR_NO_320MHZ = 26,
	NL80211_FREQUENCY_ATTR_NO_EHT = 27,
	NL80211_FREQUENCY_ATTR_PSD = 28,
	NL80211_FREQUENCY_ATTR_DFS_CONCURRENT = 29,
	NL80211_FREQUENCY_ATTR_NO_6GHZ_VLP_CLIENT = 30,
	NL80211_FREQUENCY_ATTR_NO_6GHZ_AFC_CLIENT = 31,
	NL80211_FREQUENCY_ATTR_CAN_MONITOR = 32,
	NL80211_FREQUENCY_ATTR_ALLOW_6GHZ_VLP_AP = 33,
	__NL80211_FREQUENCY_ATTR_AFTER_LAST = 34,
	NL80211_FREQUENCY_ATTR_MAX = 33,
};

enum nl80211_ftm_responder_attributes {
	__NL80211_FTM_RESP_ATTR_INVALID = 0,
	NL80211_FTM_RESP_ATTR_ENABLED = 1,
	NL80211_FTM_RESP_ATTR_LCI = 2,
	NL80211_FTM_RESP_ATTR_CIVICLOC = 3,
	__NL80211_FTM_RESP_ATTR_LAST = 4,
	NL80211_FTM_RESP_ATTR_MAX = 3,
};

enum nl80211_ftm_responder_stats {
	__NL80211_FTM_STATS_INVALID = 0,
	NL80211_FTM_STATS_SUCCESS_NUM = 1,
	NL80211_FTM_STATS_PARTIAL_NUM = 2,
	NL80211_FTM_STATS_FAILED_NUM = 3,
	NL80211_FTM_STATS_ASAP_NUM = 4,
	NL80211_FTM_STATS_NON_ASAP_NUM = 5,
	NL80211_FTM_STATS_TOTAL_DURATION_MSEC = 6,
	NL80211_FTM_STATS_UNKNOWN_TRIGGERS_NUM = 7,
	NL80211_FTM_STATS_RESCHEDULE_REQUESTS_NUM = 8,
	NL80211_FTM_STATS_OUT_OF_WINDOW_TRIGGERS_NUM = 9,
	NL80211_FTM_STATS_PAD = 10,
	__NL80211_FTM_STATS_AFTER_LAST = 11,
	NL80211_FTM_STATS_MAX = 10,
};

enum nl80211_he_gi {
	NL80211_RATE_INFO_HE_GI_0_8 = 0,
	NL80211_RATE_INFO_HE_GI_1_6 = 1,
	NL80211_RATE_INFO_HE_GI_3_2 = 2,
};

enum nl80211_he_ltf {
	NL80211_RATE_INFO_HE_1XLTF = 0,
	NL80211_RATE_INFO_HE_2XLTF = 1,
	NL80211_RATE_INFO_HE_4XLTF = 2,
};

enum nl80211_he_ru_alloc {
	NL80211_RATE_INFO_HE_RU_ALLOC_26 = 0,
	NL80211_RATE_INFO_HE_RU_ALLOC_52 = 1,
	NL80211_RATE_INFO_HE_RU_ALLOC_106 = 2,
	NL80211_RATE_INFO_HE_RU_ALLOC_242 = 3,
	NL80211_RATE_INFO_HE_RU_ALLOC_484 = 4,
	NL80211_RATE_INFO_HE_RU_ALLOC_996 = 5,
	NL80211_RATE_INFO_HE_RU_ALLOC_2x996 = 6,
};

enum nl80211_hidden_ssid {
	NL80211_HIDDEN_SSID_NOT_IN_USE = 0,
	NL80211_HIDDEN_SSID_ZERO_LEN = 1,
	NL80211_HIDDEN_SSID_ZERO_CONTENTS = 2,
};

enum nl80211_if_combination_attrs {
	NL80211_IFACE_COMB_UNSPEC = 0,
	NL80211_IFACE_COMB_LIMITS = 1,
	NL80211_IFACE_COMB_MAXNUM = 2,
	NL80211_IFACE_COMB_STA_AP_BI_MATCH = 3,
	NL80211_IFACE_COMB_NUM_CHANNELS = 4,
	NL80211_IFACE_COMB_RADAR_DETECT_WIDTHS = 5,
	NL80211_IFACE_COMB_RADAR_DETECT_REGIONS = 6,
	NL80211_IFACE_COMB_BI_MIN_GCD = 7,
	NUM_NL80211_IFACE_COMB = 8,
	MAX_NL80211_IFACE_COMB = 7,
};

enum nl80211_iface_limit_attrs {
	NL80211_IFACE_LIMIT_UNSPEC = 0,
	NL80211_IFACE_LIMIT_MAX = 1,
	NL80211_IFACE_LIMIT_TYPES = 2,
	NUM_NL80211_IFACE_LIMIT = 3,
	MAX_NL80211_IFACE_LIMIT = 2,
};

enum nl80211_iftype {
	NL80211_IFTYPE_UNSPECIFIED = 0,
	NL80211_IFTYPE_ADHOC = 1,
	NL80211_IFTYPE_STATION = 2,
	NL80211_IFTYPE_AP = 3,
	NL80211_IFTYPE_AP_VLAN = 4,
	NL80211_IFTYPE_WDS = 5,
	NL80211_IFTYPE_MONITOR = 6,
	NL80211_IFTYPE_MESH_POINT = 7,
	NL80211_IFTYPE_P2P_CLIENT = 8,
	NL80211_IFTYPE_P2P_GO = 9,
	NL80211_IFTYPE_P2P_DEVICE = 10,
	NL80211_IFTYPE_OCB = 11,
	NL80211_IFTYPE_NAN = 12,
	NUM_NL80211_IFTYPES = 13,
	NL80211_IFTYPE_MAX = 12,
};

enum nl80211_iftype_akm_attributes {
	__NL80211_IFTYPE_AKM_ATTR_INVALID = 0,
	NL80211_IFTYPE_AKM_ATTR_IFTYPES = 1,
	NL80211_IFTYPE_AKM_ATTR_SUITES = 2,
	__NL80211_IFTYPE_AKM_ATTR_LAST = 3,
	NL80211_IFTYPE_AKM_ATTR_MAX = 2,
};

enum nl80211_internal_flags_selector {
	NL80211_IFL_SEL_NONE = 0,
	NL80211_IFL_SEL_WIPHY = 1,
	NL80211_IFL_SEL_WDEV = 2,
	NL80211_IFL_SEL_NETDEV = 3,
	NL80211_IFL_SEL_NETDEV_LINK = 4,
	NL80211_IFL_SEL_NETDEV_NO_MLO = 5,
	NL80211_IFL_SEL_WIPHY_RTNL = 6,
	NL80211_IFL_SEL_WIPHY_RTNL_NOMTX = 7,
	NL80211_IFL_SEL_WDEV_RTNL = 8,
	NL80211_IFL_SEL_NETDEV_RTNL = 9,
	NL80211_IFL_SEL_NETDEV_UP = 10,
	NL80211_IFL_SEL_NETDEV_UP_LINK = 11,
	NL80211_IFL_SEL_NETDEV_UP_NO_MLO = 12,
	NL80211_IFL_SEL_NETDEV_UP_NO_MLO_CLEAR = 13,
	NL80211_IFL_SEL_NETDEV_UP_NOTMX = 14,
	NL80211_IFL_SEL_NETDEV_UP_NOTMX_MLO = 15,
	NL80211_IFL_SEL_NETDEV_UP_CLEAR = 16,
	NL80211_IFL_SEL_WDEV_UP = 17,
	NL80211_IFL_SEL_WDEV_UP_LINK = 18,
	NL80211_IFL_SEL_WDEV_UP_RTNL = 19,
	NL80211_IFL_SEL_WIPHY_CLEAR = 20,
};

enum nl80211_key_attributes {
	__NL80211_KEY_INVALID = 0,
	NL80211_KEY_DATA = 1,
	NL80211_KEY_IDX = 2,
	NL80211_KEY_CIPHER = 3,
	NL80211_KEY_SEQ = 4,
	NL80211_KEY_DEFAULT = 5,
	NL80211_KEY_DEFAULT_MGMT = 6,
	NL80211_KEY_TYPE = 7,
	NL80211_KEY_DEFAULT_TYPES = 8,
	NL80211_KEY_MODE = 9,
	NL80211_KEY_DEFAULT_BEACON = 10,
	__NL80211_KEY_AFTER_LAST = 11,
	NL80211_KEY_MAX = 10,
};

enum nl80211_key_default_types {
	__NL80211_KEY_DEFAULT_TYPE_INVALID = 0,
	NL80211_KEY_DEFAULT_TYPE_UNICAST = 1,
	NL80211_KEY_DEFAULT_TYPE_MULTICAST = 2,
	NUM_NL80211_KEY_DEFAULT_TYPES = 3,
};

enum nl80211_key_mode {
	NL80211_KEY_RX_TX = 0,
	NL80211_KEY_NO_TX = 1,
	NL80211_KEY_SET_TX = 2,
};

enum nl80211_key_type {
	NL80211_KEYTYPE_GROUP = 0,
	NL80211_KEYTYPE_PAIRWISE = 1,
	NL80211_KEYTYPE_PEERKEY = 2,
	NUM_NL80211_KEYTYPES = 3,
};

enum nl80211_mbssid_config_attributes {
	__NL80211_MBSSID_CONFIG_ATTR_INVALID = 0,
	NL80211_MBSSID_CONFIG_ATTR_MAX_INTERFACES = 1,
	NL80211_MBSSID_CONFIG_ATTR_MAX_EMA_PROFILE_PERIODICITY = 2,
	NL80211_MBSSID_CONFIG_ATTR_INDEX = 3,
	NL80211_MBSSID_CONFIG_ATTR_TX_IFINDEX = 4,
	NL80211_MBSSID_CONFIG_ATTR_EMA = 5,
	__NL80211_MBSSID_CONFIG_ATTR_LAST = 6,
	NL80211_MBSSID_CONFIG_ATTR_MAX = 5,
};

enum nl80211_mesh_power_mode {
	NL80211_MESH_POWER_UNKNOWN = 0,
	NL80211_MESH_POWER_ACTIVE = 1,
	NL80211_MESH_POWER_LIGHT_SLEEP = 2,
	NL80211_MESH_POWER_DEEP_SLEEP = 3,
	__NL80211_MESH_POWER_AFTER_LAST = 4,
	NL80211_MESH_POWER_MAX = 3,
};

enum nl80211_mesh_setup_params {
	__NL80211_MESH_SETUP_INVALID = 0,
	NL80211_MESH_SETUP_ENABLE_VENDOR_PATH_SEL = 1,
	NL80211_MESH_SETUP_ENABLE_VENDOR_METRIC = 2,
	NL80211_MESH_SETUP_IE = 3,
	NL80211_MESH_SETUP_USERSPACE_AUTH = 4,
	NL80211_MESH_SETUP_USERSPACE_AMPE = 5,
	NL80211_MESH_SETUP_ENABLE_VENDOR_SYNC = 6,
	NL80211_MESH_SETUP_USERSPACE_MPM = 7,
	NL80211_MESH_SETUP_AUTH_PROTOCOL = 8,
	__NL80211_MESH_SETUP_ATTR_AFTER_LAST = 9,
	NL80211_MESH_SETUP_ATTR_MAX = 8,
};

enum nl80211_meshconf_params {
	__NL80211_MESHCONF_INVALID = 0,
	NL80211_MESHCONF_RETRY_TIMEOUT = 1,
	NL80211_MESHCONF_CONFIRM_TIMEOUT = 2,
	NL80211_MESHCONF_HOLDING_TIMEOUT = 3,
	NL80211_MESHCONF_MAX_PEER_LINKS = 4,
	NL80211_MESHCONF_MAX_RETRIES = 5,
	NL80211_MESHCONF_TTL = 6,
	NL80211_MESHCONF_AUTO_OPEN_PLINKS = 7,
	NL80211_MESHCONF_HWMP_MAX_PREQ_RETRIES = 8,
	NL80211_MESHCONF_PATH_REFRESH_TIME = 9,
	NL80211_MESHCONF_MIN_DISCOVERY_TIMEOUT = 10,
	NL80211_MESHCONF_HWMP_ACTIVE_PATH_TIMEOUT = 11,
	NL80211_MESHCONF_HWMP_PREQ_MIN_INTERVAL = 12,
	NL80211_MESHCONF_HWMP_NET_DIAM_TRVS_TIME = 13,
	NL80211_MESHCONF_HWMP_ROOTMODE = 14,
	NL80211_MESHCONF_ELEMENT_TTL = 15,
	NL80211_MESHCONF_HWMP_RANN_INTERVAL = 16,
	NL80211_MESHCONF_GATE_ANNOUNCEMENTS = 17,
	NL80211_MESHCONF_HWMP_PERR_MIN_INTERVAL = 18,
	NL80211_MESHCONF_FORWARDING = 19,
	NL80211_MESHCONF_RSSI_THRESHOLD = 20,
	NL80211_MESHCONF_SYNC_OFFSET_MAX_NEIGHBOR = 21,
	NL80211_MESHCONF_HT_OPMODE = 22,
	NL80211_MESHCONF_HWMP_PATH_TO_ROOT_TIMEOUT = 23,
	NL80211_MESHCONF_HWMP_ROOT_INTERVAL = 24,
	NL80211_MESHCONF_HWMP_CONFIRMATION_INTERVAL = 25,
	NL80211_MESHCONF_POWER_MODE = 26,
	NL80211_MESHCONF_AWAKE_WINDOW = 27,
	NL80211_MESHCONF_PLINK_TIMEOUT = 28,
	NL80211_MESHCONF_CONNECTED_TO_GATE = 29,
	NL80211_MESHCONF_NOLEARN = 30,
	NL80211_MESHCONF_CONNECTED_TO_AS = 31,
	__NL80211_MESHCONF_ATTR_AFTER_LAST = 32,
	NL80211_MESHCONF_ATTR_MAX = 31,
};

enum nl80211_mfp {
	NL80211_MFP_NO = 0,
	NL80211_MFP_REQUIRED = 1,
	NL80211_MFP_OPTIONAL = 2,
};

enum nl80211_mntr_flags {
	__NL80211_MNTR_FLAG_INVALID = 0,
	NL80211_MNTR_FLAG_FCSFAIL = 1,
	NL80211_MNTR_FLAG_PLCPFAIL = 2,
	NL80211_MNTR_FLAG_CONTROL = 3,
	NL80211_MNTR_FLAG_OTHER_BSS = 4,
	NL80211_MNTR_FLAG_COOK_FRAMES = 5,
	NL80211_MNTR_FLAG_ACTIVE = 6,
	NL80211_MNTR_FLAG_SKIP_TX = 7,
	__NL80211_MNTR_FLAG_AFTER_LAST = 8,
	NL80211_MNTR_FLAG_MAX = 7,
};

enum nl80211_mpath_info {
	__NL80211_MPATH_INFO_INVALID = 0,
	NL80211_MPATH_INFO_FRAME_QLEN = 1,
	NL80211_MPATH_INFO_SN = 2,
	NL80211_MPATH_INFO_METRIC = 3,
	NL80211_MPATH_INFO_EXPTIME = 4,
	NL80211_MPATH_INFO_FLAGS = 5,
	NL80211_MPATH_INFO_DISCOVERY_TIMEOUT = 6,
	NL80211_MPATH_INFO_DISCOVERY_RETRIES = 7,
	NL80211_MPATH_INFO_HOP_COUNT = 8,
	NL80211_MPATH_INFO_PATH_CHANGE = 9,
	__NL80211_MPATH_INFO_AFTER_LAST = 10,
	NL80211_MPATH_INFO_MAX = 9,
};

enum nl80211_multicast_groups {
	NL80211_MCGRP_CONFIG = 0,
	NL80211_MCGRP_SCAN = 1,
	NL80211_MCGRP_REGULATORY = 2,
	NL80211_MCGRP_MLME = 3,
	NL80211_MCGRP_VENDOR = 4,
	NL80211_MCGRP_NAN = 5,
	NL80211_MCGRP_TESTMODE = 6,
};

enum nl80211_nan_func_attributes {
	__NL80211_NAN_FUNC_INVALID = 0,
	NL80211_NAN_FUNC_TYPE = 1,
	NL80211_NAN_FUNC_SERVICE_ID = 2,
	NL80211_NAN_FUNC_PUBLISH_TYPE = 3,
	NL80211_NAN_FUNC_PUBLISH_BCAST = 4,
	NL80211_NAN_FUNC_SUBSCRIBE_ACTIVE = 5,
	NL80211_NAN_FUNC_FOLLOW_UP_ID = 6,
	NL80211_NAN_FUNC_FOLLOW_UP_REQ_ID = 7,
	NL80211_NAN_FUNC_FOLLOW_UP_DEST = 8,
	NL80211_NAN_FUNC_CLOSE_RANGE = 9,
	NL80211_NAN_FUNC_TTL = 10,
	NL80211_NAN_FUNC_SERVICE_INFO = 11,
	NL80211_NAN_FUNC_SRF = 12,
	NL80211_NAN_FUNC_RX_MATCH_FILTER = 13,
	NL80211_NAN_FUNC_TX_MATCH_FILTER = 14,
	NL80211_NAN_FUNC_INSTANCE_ID = 15,
	NL80211_NAN_FUNC_TERM_REASON = 16,
	NUM_NL80211_NAN_FUNC_ATTR = 17,
	NL80211_NAN_FUNC_ATTR_MAX = 16,
};

enum nl80211_nan_func_term_reason {
	NL80211_NAN_FUNC_TERM_REASON_USER_REQUEST = 0,
	NL80211_NAN_FUNC_TERM_REASON_TTL_EXPIRED = 1,
	NL80211_NAN_FUNC_TERM_REASON_ERROR = 2,
};

enum nl80211_nan_function_type {
	NL80211_NAN_FUNC_PUBLISH = 0,
	NL80211_NAN_FUNC_SUBSCRIBE = 1,
	NL80211_NAN_FUNC_FOLLOW_UP = 2,
	__NL80211_NAN_FUNC_TYPE_AFTER_LAST = 3,
	NL80211_NAN_FUNC_MAX_TYPE = 2,
};

enum nl80211_nan_match_attributes {
	__NL80211_NAN_MATCH_INVALID = 0,
	NL80211_NAN_MATCH_FUNC_LOCAL = 1,
	NL80211_NAN_MATCH_FUNC_PEER = 2,
	NUM_NL80211_NAN_MATCH_ATTR = 3,
	NL80211_NAN_MATCH_ATTR_MAX = 2,
};

enum nl80211_nan_publish_type {
	NL80211_NAN_SOLICITED_PUBLISH = 1,
	NL80211_NAN_UNSOLICITED_PUBLISH = 2,
};

enum nl80211_nan_srf_attributes {
	__NL80211_NAN_SRF_INVALID = 0,
	NL80211_NAN_SRF_INCLUDE = 1,
	NL80211_NAN_SRF_BF = 2,
	NL80211_NAN_SRF_BF_IDX = 3,
	NL80211_NAN_SRF_MAC_ADDRS = 4,
	NUM_NL80211_NAN_SRF_ATTR = 5,
	NL80211_NAN_SRF_ATTR_MAX = 4,
};

enum nl80211_obss_pd_attributes {
	__NL80211_HE_OBSS_PD_ATTR_INVALID = 0,
	NL80211_HE_OBSS_PD_ATTR_MIN_OFFSET = 1,
	NL80211_HE_OBSS_PD_ATTR_MAX_OFFSET = 2,
	NL80211_HE_OBSS_PD_ATTR_NON_SRG_MAX_OFFSET = 3,
	NL80211_HE_OBSS_PD_ATTR_BSS_COLOR_BITMAP = 4,
	NL80211_HE_OBSS_PD_ATTR_PARTIAL_BSSID_BITMAP = 5,
	NL80211_HE_OBSS_PD_ATTR_SR_CTRL = 6,
	__NL80211_HE_OBSS_PD_ATTR_LAST = 7,
	NL80211_HE_OBSS_PD_ATTR_MAX = 6,
};

enum nl80211_packet_pattern_attr {
	__NL80211_PKTPAT_INVALID = 0,
	NL80211_PKTPAT_MASK = 1,
	NL80211_PKTPAT_PATTERN = 2,
	NL80211_PKTPAT_OFFSET = 3,
	NUM_NL80211_PKTPAT = 4,
	MAX_NL80211_PKTPAT = 3,
};

enum nl80211_peer_measurement_attrs {
	__NL80211_PMSR_ATTR_INVALID = 0,
	NL80211_PMSR_ATTR_MAX_PEERS = 1,
	NL80211_PMSR_ATTR_REPORT_AP_TSF = 2,
	NL80211_PMSR_ATTR_RANDOMIZE_MAC_ADDR = 3,
	NL80211_PMSR_ATTR_TYPE_CAPA = 4,
	NL80211_PMSR_ATTR_PEERS = 5,
	NUM_NL80211_PMSR_ATTR = 6,
	NL80211_PMSR_ATTR_MAX = 5,
};

enum nl80211_peer_measurement_ftm_capa {
	__NL80211_PMSR_FTM_CAPA_ATTR_INVALID = 0,
	NL80211_PMSR_FTM_CAPA_ATTR_ASAP = 1,
	NL80211_PMSR_FTM_CAPA_ATTR_NON_ASAP = 2,
	NL80211_PMSR_FTM_CAPA_ATTR_REQ_LCI = 3,
	NL80211_PMSR_FTM_CAPA_ATTR_REQ_CIVICLOC = 4,
	NL80211_PMSR_FTM_CAPA_ATTR_PREAMBLES = 5,
	NL80211_PMSR_FTM_CAPA_ATTR_BANDWIDTHS = 6,
	NL80211_PMSR_FTM_CAPA_ATTR_MAX_BURSTS_EXPONENT = 7,
	NL80211_PMSR_FTM_CAPA_ATTR_MAX_FTMS_PER_BURST = 8,
	NL80211_PMSR_FTM_CAPA_ATTR_TRIGGER_BASED = 9,
	NL80211_PMSR_FTM_CAPA_ATTR_NON_TRIGGER_BASED = 10,
	NUM_NL80211_PMSR_FTM_CAPA_ATTR = 11,
	NL80211_PMSR_FTM_CAPA_ATTR_MAX = 10,
};

enum nl80211_peer_measurement_ftm_failure_reasons {
	NL80211_PMSR_FTM_FAILURE_UNSPECIFIED = 0,
	NL80211_PMSR_FTM_FAILURE_NO_RESPONSE = 1,
	NL80211_PMSR_FTM_FAILURE_REJECTED = 2,
	NL80211_PMSR_FTM_FAILURE_WRONG_CHANNEL = 3,
	NL80211_PMSR_FTM_FAILURE_PEER_NOT_CAPABLE = 4,
	NL80211_PMSR_FTM_FAILURE_INVALID_TIMESTAMP = 5,
	NL80211_PMSR_FTM_FAILURE_PEER_BUSY = 6,
	NL80211_PMSR_FTM_FAILURE_BAD_CHANGED_PARAMS = 7,
};

enum nl80211_peer_measurement_ftm_req {
	__NL80211_PMSR_FTM_REQ_ATTR_INVALID = 0,
	NL80211_PMSR_FTM_REQ_ATTR_ASAP = 1,
	NL80211_PMSR_FTM_REQ_ATTR_PREAMBLE = 2,
	NL80211_PMSR_FTM_REQ_ATTR_NUM_BURSTS_EXP = 3,
	NL80211_PMSR_FTM_REQ_ATTR_BURST_PERIOD = 4,
	NL80211_PMSR_FTM_REQ_ATTR_BURST_DURATION = 5,
	NL80211_PMSR_FTM_REQ_ATTR_FTMS_PER_BURST = 6,
	NL80211_PMSR_FTM_REQ_ATTR_NUM_FTMR_RETRIES = 7,
	NL80211_PMSR_FTM_REQ_ATTR_REQUEST_LCI = 8,
	NL80211_PMSR_FTM_REQ_ATTR_REQUEST_CIVICLOC = 9,
	NL80211_PMSR_FTM_REQ_ATTR_TRIGGER_BASED = 10,
	NL80211_PMSR_FTM_REQ_ATTR_NON_TRIGGER_BASED = 11,
	NL80211_PMSR_FTM_REQ_ATTR_LMR_FEEDBACK = 12,
	NL80211_PMSR_FTM_REQ_ATTR_BSS_COLOR = 13,
	NUM_NL80211_PMSR_FTM_REQ_ATTR = 14,
	NL80211_PMSR_FTM_REQ_ATTR_MAX = 13,
};

enum nl80211_peer_measurement_ftm_resp {
	__NL80211_PMSR_FTM_RESP_ATTR_INVALID = 0,
	NL80211_PMSR_FTM_RESP_ATTR_FAIL_REASON = 1,
	NL80211_PMSR_FTM_RESP_ATTR_BURST_INDEX = 2,
	NL80211_PMSR_FTM_RESP_ATTR_NUM_FTMR_ATTEMPTS = 3,
	NL80211_PMSR_FTM_RESP_ATTR_NUM_FTMR_SUCCESSES = 4,
	NL80211_PMSR_FTM_RESP_ATTR_BUSY_RETRY_TIME = 5,
	NL80211_PMSR_FTM_RESP_ATTR_NUM_BURSTS_EXP = 6,
	NL80211_PMSR_FTM_RESP_ATTR_BURST_DURATION = 7,
	NL80211_PMSR_FTM_RESP_ATTR_FTMS_PER_BURST = 8,
	NL80211_PMSR_FTM_RESP_ATTR_RSSI_AVG = 9,
	NL80211_PMSR_FTM_RESP_ATTR_RSSI_SPREAD = 10,
	NL80211_PMSR_FTM_RESP_ATTR_TX_RATE = 11,
	NL80211_PMSR_FTM_RESP_ATTR_RX_RATE = 12,
	NL80211_PMSR_FTM_RESP_ATTR_RTT_AVG = 13,
	NL80211_PMSR_FTM_RESP_ATTR_RTT_VARIANCE = 14,
	NL80211_PMSR_FTM_RESP_ATTR_RTT_SPREAD = 15,
	NL80211_PMSR_FTM_RESP_ATTR_DIST_AVG = 16,
	NL80211_PMSR_FTM_RESP_ATTR_DIST_VARIANCE = 17,
	NL80211_PMSR_FTM_RESP_ATTR_DIST_SPREAD = 18,
	NL80211_PMSR_FTM_RESP_ATTR_LCI = 19,
	NL80211_PMSR_FTM_RESP_ATTR_CIVICLOC = 20,
	NL80211_PMSR_FTM_RESP_ATTR_PAD = 21,
	NUM_NL80211_PMSR_FTM_RESP_ATTR = 22,
	NL80211_PMSR_FTM_RESP_ATTR_MAX = 21,
};

enum nl80211_peer_measurement_peer_attrs {
	__NL80211_PMSR_PEER_ATTR_INVALID = 0,
	NL80211_PMSR_PEER_ATTR_ADDR = 1,
	NL80211_PMSR_PEER_ATTR_CHAN = 2,
	NL80211_PMSR_PEER_ATTR_REQ = 3,
	NL80211_PMSR_PEER_ATTR_RESP = 4,
	NUM_NL80211_PMSR_PEER_ATTRS = 5,
	NL80211_PMSR_PEER_ATTR_MAX = 4,
};

enum nl80211_peer_measurement_req {
	__NL80211_PMSR_REQ_ATTR_INVALID = 0,
	NL80211_PMSR_REQ_ATTR_DATA = 1,
	NL80211_PMSR_REQ_ATTR_GET_AP_TSF = 2,
	NUM_NL80211_PMSR_REQ_ATTRS = 3,
	NL80211_PMSR_REQ_ATTR_MAX = 2,
};

enum nl80211_peer_measurement_resp {
	__NL80211_PMSR_RESP_ATTR_INVALID = 0,
	NL80211_PMSR_RESP_ATTR_DATA = 1,
	NL80211_PMSR_RESP_ATTR_STATUS = 2,
	NL80211_PMSR_RESP_ATTR_HOST_TIME = 3,
	NL80211_PMSR_RESP_ATTR_AP_TSF = 4,
	NL80211_PMSR_RESP_ATTR_FINAL = 5,
	NL80211_PMSR_RESP_ATTR_PAD = 6,
	NUM_NL80211_PMSR_RESP_ATTRS = 7,
	NL80211_PMSR_RESP_ATTR_MAX = 6,
};

enum nl80211_peer_measurement_status {
	NL80211_PMSR_STATUS_SUCCESS = 0,
	NL80211_PMSR_STATUS_REFUSED = 1,
	NL80211_PMSR_STATUS_TIMEOUT = 2,
	NL80211_PMSR_STATUS_FAILURE = 3,
};

enum nl80211_peer_measurement_type {
	NL80211_PMSR_TYPE_INVALID = 0,
	NL80211_PMSR_TYPE_FTM = 1,
	NUM_NL80211_PMSR_TYPES = 2,
	NL80211_PMSR_TYPE_MAX = 1,
};

enum nl80211_plink_action {
	NL80211_PLINK_ACTION_NO_ACTION = 0,
	NL80211_PLINK_ACTION_OPEN = 1,
	NL80211_PLINK_ACTION_BLOCK = 2,
	NUM_NL80211_PLINK_ACTIONS = 3,
};

enum nl80211_plink_state {
	NL80211_PLINK_LISTEN = 0,
	NL80211_PLINK_OPN_SNT = 1,
	NL80211_PLINK_OPN_RCVD = 2,
	NL80211_PLINK_CNF_RCVD = 3,
	NL80211_PLINK_ESTAB = 4,
	NL80211_PLINK_HOLDING = 5,
	NL80211_PLINK_BLOCKED = 6,
	NUM_NL80211_PLINK_STATES = 7,
	MAX_NL80211_PLINK_STATES = 6,
};

enum nl80211_pmksa_candidate_attr {
	__NL80211_PMKSA_CANDIDATE_INVALID = 0,
	NL80211_PMKSA_CANDIDATE_INDEX = 1,
	NL80211_PMKSA_CANDIDATE_BSSID = 2,
	NL80211_PMKSA_CANDIDATE_PREAUTH = 3,
	NUM_NL80211_PMKSA_CANDIDATE = 4,
	MAX_NL80211_PMKSA_CANDIDATE = 3,
};

enum nl80211_preamble {
	NL80211_PREAMBLE_LEGACY = 0,
	NL80211_PREAMBLE_HT = 1,
	NL80211_PREAMBLE_VHT = 2,
	NL80211_PREAMBLE_DMG = 3,
	NL80211_PREAMBLE_HE = 4,
};

enum nl80211_protocol_features {
	NL80211_PROTOCOL_FEATURE_SPLIT_WIPHY_DUMP = 1,
};

enum nl80211_ps_state {
	NL80211_PS_DISABLED = 0,
	NL80211_PS_ENABLED = 1,
};

enum nl80211_radar_event {
	NL80211_RADAR_DETECTED = 0,
	NL80211_RADAR_CAC_FINISHED = 1,
	NL80211_RADAR_CAC_ABORTED = 2,
	NL80211_RADAR_NOP_FINISHED = 3,
	NL80211_RADAR_PRE_CAC_EXPIRED = 4,
	NL80211_RADAR_CAC_STARTED = 5,
};

enum nl80211_rate_info {
	__NL80211_RATE_INFO_INVALID = 0,
	NL80211_RATE_INFO_BITRATE = 1,
	NL80211_RATE_INFO_MCS = 2,
	NL80211_RATE_INFO_40_MHZ_WIDTH = 3,
	NL80211_RATE_INFO_SHORT_GI = 4,
	NL80211_RATE_INFO_BITRATE32 = 5,
	NL80211_RATE_INFO_VHT_MCS = 6,
	NL80211_RATE_INFO_VHT_NSS = 7,
	NL80211_RATE_INFO_80_MHZ_WIDTH = 8,
	NL80211_RATE_INFO_80P80_MHZ_WIDTH = 9,
	NL80211_RATE_INFO_160_MHZ_WIDTH = 10,
	NL80211_RATE_INFO_10_MHZ_WIDTH = 11,
	NL80211_RATE_INFO_5_MHZ_WIDTH = 12,
	NL80211_RATE_INFO_HE_MCS = 13,
	NL80211_RATE_INFO_HE_NSS = 14,
	NL80211_RATE_INFO_HE_GI = 15,
	NL80211_RATE_INFO_HE_DCM = 16,
	NL80211_RATE_INFO_HE_RU_ALLOC = 17,
	NL80211_RATE_INFO_320_MHZ_WIDTH = 18,
	NL80211_RATE_INFO_EHT_MCS = 19,
	NL80211_RATE_INFO_EHT_NSS = 20,
	NL80211_RATE_INFO_EHT_GI = 21,
	NL80211_RATE_INFO_EHT_RU_ALLOC = 22,
	NL80211_RATE_INFO_S1G_MCS = 23,
	NL80211_RATE_INFO_S1G_NSS = 24,
	NL80211_RATE_INFO_1_MHZ_WIDTH = 25,
	NL80211_RATE_INFO_2_MHZ_WIDTH = 26,
	NL80211_RATE_INFO_4_MHZ_WIDTH = 27,
	NL80211_RATE_INFO_8_MHZ_WIDTH = 28,
	NL80211_RATE_INFO_16_MHZ_WIDTH = 29,
	__NL80211_RATE_INFO_AFTER_LAST = 30,
	NL80211_RATE_INFO_MAX = 29,
};

enum nl80211_reg_initiator {
	NL80211_REGDOM_SET_BY_CORE = 0,
	NL80211_REGDOM_SET_BY_USER = 1,
	NL80211_REGDOM_SET_BY_DRIVER = 2,
	NL80211_REGDOM_SET_BY_COUNTRY_IE = 3,
};

enum nl80211_reg_rule_attr {
	__NL80211_REG_RULE_ATTR_INVALID = 0,
	NL80211_ATTR_REG_RULE_FLAGS = 1,
	NL80211_ATTR_FREQ_RANGE_START = 2,
	NL80211_ATTR_FREQ_RANGE_END = 3,
	NL80211_ATTR_FREQ_RANGE_MAX_BW = 4,
	NL80211_ATTR_POWER_RULE_MAX_ANT_GAIN = 5,
	NL80211_ATTR_POWER_RULE_MAX_EIRP = 6,
	NL80211_ATTR_DFS_CAC_TIME = 7,
	NL80211_ATTR_POWER_RULE_PSD = 8,
	__NL80211_REG_RULE_ATTR_AFTER_LAST = 9,
	NL80211_REG_RULE_ATTR_MAX = 8,
};

enum nl80211_reg_rule_flags {
	NL80211_RRF_NO_OFDM = 1,
	NL80211_RRF_NO_CCK = 2,
	NL80211_RRF_NO_INDOOR = 4,
	NL80211_RRF_NO_OUTDOOR = 8,
	NL80211_RRF_DFS = 16,
	NL80211_RRF_PTP_ONLY = 32,
	NL80211_RRF_PTMP_ONLY = 64,
	NL80211_RRF_NO_IR = 128,
	__NL80211_RRF_NO_IBSS = 256,
	NL80211_RRF_AUTO_BW = 2048,
	NL80211_RRF_IR_CONCURRENT = 4096,
	NL80211_RRF_NO_HT40MINUS = 8192,
	NL80211_RRF_NO_HT40PLUS = 16384,
	NL80211_RRF_NO_80MHZ = 32768,
	NL80211_RRF_NO_160MHZ = 65536,
	NL80211_RRF_NO_HE = 131072,
	NL80211_RRF_NO_320MHZ = 262144,
	NL80211_RRF_NO_EHT = 524288,
	NL80211_RRF_PSD = 1048576,
	NL80211_RRF_DFS_CONCURRENT = 2097152,
	NL80211_RRF_NO_6GHZ_VLP_CLIENT = 4194304,
	NL80211_RRF_NO_6GHZ_AFC_CLIENT = 8388608,
	NL80211_RRF_ALLOW_6GHZ_VLP_AP = 16777216,
};

enum nl80211_reg_type {
	NL80211_REGDOM_TYPE_COUNTRY = 0,
	NL80211_REGDOM_TYPE_WORLD = 1,
	NL80211_REGDOM_TYPE_CUSTOM_WORLD = 2,
	NL80211_REGDOM_TYPE_INTERSECTION = 3,
};

enum nl80211_rekey_data {
	__NL80211_REKEY_DATA_INVALID = 0,
	NL80211_REKEY_DATA_KEK = 1,
	NL80211_REKEY_DATA_KCK = 2,
	NL80211_REKEY_DATA_REPLAY_CTR = 3,
	NL80211_REKEY_DATA_AKM = 4,
	NUM_NL80211_REKEY_DATA = 5,
	MAX_NL80211_REKEY_DATA = 4,
};

enum nl80211_sae_pwe_mechanism {
	NL80211_SAE_PWE_UNSPECIFIED = 0,
	NL80211_SAE_PWE_HUNT_AND_PECK = 1,
	NL80211_SAE_PWE_HASH_TO_ELEMENT = 2,
	NL80211_SAE_PWE_BOTH = 3,
};

enum nl80211_sar_attrs {
	__NL80211_SAR_ATTR_INVALID = 0,
	NL80211_SAR_ATTR_TYPE = 1,
	NL80211_SAR_ATTR_SPECS = 2,
	__NL80211_SAR_ATTR_LAST = 3,
	NL80211_SAR_ATTR_MAX = 2,
};

enum nl80211_sar_specs_attrs {
	__NL80211_SAR_ATTR_SPECS_INVALID = 0,
	NL80211_SAR_ATTR_SPECS_POWER = 1,
	NL80211_SAR_ATTR_SPECS_RANGE_INDEX = 2,
	NL80211_SAR_ATTR_SPECS_START_FREQ = 3,
	NL80211_SAR_ATTR_SPECS_END_FREQ = 4,
	__NL80211_SAR_ATTR_SPECS_LAST = 5,
	NL80211_SAR_ATTR_SPECS_MAX = 4,
};

enum nl80211_sar_type {
	NL80211_SAR_TYPE_POWER = 0,
	NUM_NL80211_SAR_TYPE = 1,
};

enum nl80211_scan_flags {
	NL80211_SCAN_FLAG_LOW_PRIORITY = 1,
	NL80211_SCAN_FLAG_FLUSH = 2,
	NL80211_SCAN_FLAG_AP = 4,
	NL80211_SCAN_FLAG_RANDOM_ADDR = 8,
	NL80211_SCAN_FLAG_FILS_MAX_CHANNEL_TIME = 16,
	NL80211_SCAN_FLAG_ACCEPT_BCAST_PROBE_RESP = 32,
	NL80211_SCAN_FLAG_OCE_PROBE_REQ_HIGH_TX_RATE = 64,
	NL80211_SCAN_FLAG_OCE_PROBE_REQ_DEFERRAL_SUPPRESSION = 128,
	NL80211_SCAN_FLAG_LOW_SPAN = 256,
	NL80211_SCAN_FLAG_LOW_POWER = 512,
	NL80211_SCAN_FLAG_HIGH_ACCURACY = 1024,
	NL80211_SCAN_FLAG_RANDOM_SN = 2048,
	NL80211_SCAN_FLAG_MIN_PREQ_CONTENT = 4096,
	NL80211_SCAN_FLAG_FREQ_KHZ = 8192,
	NL80211_SCAN_FLAG_COLOCATED_6GHZ = 16384,
};

enum nl80211_sched_scan_match_attr {
	__NL80211_SCHED_SCAN_MATCH_ATTR_INVALID = 0,
	NL80211_SCHED_SCAN_MATCH_ATTR_SSID = 1,
	NL80211_SCHED_SCAN_MATCH_ATTR_RSSI = 2,
	NL80211_SCHED_SCAN_MATCH_ATTR_RELATIVE_RSSI = 3,
	NL80211_SCHED_SCAN_MATCH_ATTR_RSSI_ADJUST = 4,
	NL80211_SCHED_SCAN_MATCH_ATTR_BSSID = 5,
	NL80211_SCHED_SCAN_MATCH_PER_BAND_RSSI = 6,
	__NL80211_SCHED_SCAN_MATCH_ATTR_AFTER_LAST = 7,
	NL80211_SCHED_SCAN_MATCH_ATTR_MAX = 6,
};

enum nl80211_sched_scan_plan {
	__NL80211_SCHED_SCAN_PLAN_INVALID = 0,
	NL80211_SCHED_SCAN_PLAN_INTERVAL = 1,
	NL80211_SCHED_SCAN_PLAN_ITERATIONS = 2,
	__NL80211_SCHED_SCAN_PLAN_AFTER_LAST = 3,
	NL80211_SCHED_SCAN_PLAN_MAX = 2,
};

enum nl80211_smps_mode {
	NL80211_SMPS_OFF = 0,
	NL80211_SMPS_STATIC = 1,
	NL80211_SMPS_DYNAMIC = 2,
	__NL80211_SMPS_AFTER_LAST = 3,
	NL80211_SMPS_MAX = 2,
};

enum nl80211_sta_bss_param {
	__NL80211_STA_BSS_PARAM_INVALID = 0,
	NL80211_STA_BSS_PARAM_CTS_PROT = 1,
	NL80211_STA_BSS_PARAM_SHORT_PREAMBLE = 2,
	NL80211_STA_BSS_PARAM_SHORT_SLOT_TIME = 3,
	NL80211_STA_BSS_PARAM_DTIM_PERIOD = 4,
	NL80211_STA_BSS_PARAM_BEACON_INTERVAL = 5,
	__NL80211_STA_BSS_PARAM_AFTER_LAST = 6,
	NL80211_STA_BSS_PARAM_MAX = 5,
};

enum nl80211_sta_flags {
	__NL80211_STA_FLAG_INVALID = 0,
	NL80211_STA_FLAG_AUTHORIZED = 1,
	NL80211_STA_FLAG_SHORT_PREAMBLE = 2,
	NL80211_STA_FLAG_WME = 3,
	NL80211_STA_FLAG_MFP = 4,
	NL80211_STA_FLAG_AUTHENTICATED = 5,
	NL80211_STA_FLAG_TDLS_PEER = 6,
	NL80211_STA_FLAG_ASSOCIATED = 7,
	NL80211_STA_FLAG_SPP_AMSDU = 8,
	__NL80211_STA_FLAG_AFTER_LAST = 9,
	NL80211_STA_FLAG_MAX = 8,
};

enum nl80211_sta_info {
	__NL80211_STA_INFO_INVALID = 0,
	NL80211_STA_INFO_INACTIVE_TIME = 1,
	NL80211_STA_INFO_RX_BYTES = 2,
	NL80211_STA_INFO_TX_BYTES = 3,
	NL80211_STA_INFO_LLID = 4,
	NL80211_STA_INFO_PLID = 5,
	NL80211_STA_INFO_PLINK_STATE = 6,
	NL80211_STA_INFO_SIGNAL = 7,
	NL80211_STA_INFO_TX_BITRATE = 8,
	NL80211_STA_INFO_RX_PACKETS = 9,
	NL80211_STA_INFO_TX_PACKETS = 10,
	NL80211_STA_INFO_TX_RETRIES = 11,
	NL80211_STA_INFO_TX_FAILED = 12,
	NL80211_STA_INFO_SIGNAL_AVG = 13,
	NL80211_STA_INFO_RX_BITRATE = 14,
	NL80211_STA_INFO_BSS_PARAM = 15,
	NL80211_STA_INFO_CONNECTED_TIME = 16,
	NL80211_STA_INFO_STA_FLAGS = 17,
	NL80211_STA_INFO_BEACON_LOSS = 18,
	NL80211_STA_INFO_T_OFFSET = 19,
	NL80211_STA_INFO_LOCAL_PM = 20,
	NL80211_STA_INFO_PEER_PM = 21,
	NL80211_STA_INFO_NONPEER_PM = 22,
	NL80211_STA_INFO_RX_BYTES64 = 23,
	NL80211_STA_INFO_TX_BYTES64 = 24,
	NL80211_STA_INFO_CHAIN_SIGNAL = 25,
	NL80211_STA_INFO_CHAIN_SIGNAL_AVG = 26,
	NL80211_STA_INFO_EXPECTED_THROUGHPUT = 27,
	NL80211_STA_INFO_RX_DROP_MISC = 28,
	NL80211_STA_INFO_BEACON_RX = 29,
	NL80211_STA_INFO_BEACON_SIGNAL_AVG = 30,
	NL80211_STA_INFO_TID_STATS = 31,
	NL80211_STA_INFO_RX_DURATION = 32,
	NL80211_STA_INFO_PAD = 33,
	NL80211_STA_INFO_ACK_SIGNAL = 34,
	NL80211_STA_INFO_ACK_SIGNAL_AVG = 35,
	NL80211_STA_INFO_RX_MPDUS = 36,
	NL80211_STA_INFO_FCS_ERROR_COUNT = 37,
	NL80211_STA_INFO_CONNECTED_TO_GATE = 38,
	NL80211_STA_INFO_TX_DURATION = 39,
	NL80211_STA_INFO_AIRTIME_WEIGHT = 40,
	NL80211_STA_INFO_AIRTIME_LINK_METRIC = 41,
	NL80211_STA_INFO_ASSOC_AT_BOOTTIME = 42,
	NL80211_STA_INFO_CONNECTED_TO_AS = 43,
	__NL80211_STA_INFO_AFTER_LAST = 44,
	NL80211_STA_INFO_MAX = 43,
};

enum nl80211_sta_p2p_ps_status {
	NL80211_P2P_PS_UNSUPPORTED = 0,
	NL80211_P2P_PS_SUPPORTED = 1,
	NUM_NL80211_P2P_PS_STATUS = 2,
};

enum nl80211_sta_wme_attr {
	__NL80211_STA_WME_INVALID = 0,
	NL80211_STA_WME_UAPSD_QUEUES = 1,
	NL80211_STA_WME_MAX_SP = 2,
	__NL80211_STA_WME_AFTER_LAST = 3,
	NL80211_STA_WME_MAX = 2,
};

enum nl80211_survey_info {
	__NL80211_SURVEY_INFO_INVALID = 0,
	NL80211_SURVEY_INFO_FREQUENCY = 1,
	NL80211_SURVEY_INFO_NOISE = 2,
	NL80211_SURVEY_INFO_IN_USE = 3,
	NL80211_SURVEY_INFO_TIME = 4,
	NL80211_SURVEY_INFO_TIME_BUSY = 5,
	NL80211_SURVEY_INFO_TIME_EXT_BUSY = 6,
	NL80211_SURVEY_INFO_TIME_RX = 7,
	NL80211_SURVEY_INFO_TIME_TX = 8,
	NL80211_SURVEY_INFO_TIME_SCAN = 9,
	NL80211_SURVEY_INFO_PAD = 10,
	NL80211_SURVEY_INFO_TIME_BSS_RX = 11,
	NL80211_SURVEY_INFO_FREQUENCY_OFFSET = 12,
	__NL80211_SURVEY_INFO_AFTER_LAST = 13,
	NL80211_SURVEY_INFO_MAX = 12,
};

enum nl80211_tdls_operation {
	NL80211_TDLS_DISCOVERY_REQ = 0,
	NL80211_TDLS_SETUP = 1,
	NL80211_TDLS_TEARDOWN = 2,
	NL80211_TDLS_ENABLE_LINK = 3,
	NL80211_TDLS_DISABLE_LINK = 4,
};

enum nl80211_tid_config {
	NL80211_TID_CONFIG_ENABLE = 0,
	NL80211_TID_CONFIG_DISABLE = 1,
};

enum nl80211_tid_config_attr {
	__NL80211_TID_CONFIG_ATTR_INVALID = 0,
	NL80211_TID_CONFIG_ATTR_PAD = 1,
	NL80211_TID_CONFIG_ATTR_VIF_SUPP = 2,
	NL80211_TID_CONFIG_ATTR_PEER_SUPP = 3,
	NL80211_TID_CONFIG_ATTR_OVERRIDE = 4,
	NL80211_TID_CONFIG_ATTR_TIDS = 5,
	NL80211_TID_CONFIG_ATTR_NOACK = 6,
	NL80211_TID_CONFIG_ATTR_RETRY_SHORT = 7,
	NL80211_TID_CONFIG_ATTR_RETRY_LONG = 8,
	NL80211_TID_CONFIG_ATTR_AMPDU_CTRL = 9,
	NL80211_TID_CONFIG_ATTR_RTSCTS_CTRL = 10,
	NL80211_TID_CONFIG_ATTR_AMSDU_CTRL = 11,
	NL80211_TID_CONFIG_ATTR_TX_RATE_TYPE = 12,
	NL80211_TID_CONFIG_ATTR_TX_RATE = 13,
	__NL80211_TID_CONFIG_ATTR_AFTER_LAST = 14,
	NL80211_TID_CONFIG_ATTR_MAX = 13,
};

enum nl80211_tid_stats {
	__NL80211_TID_STATS_INVALID = 0,
	NL80211_TID_STATS_RX_MSDU = 1,
	NL80211_TID_STATS_TX_MSDU = 2,
	NL80211_TID_STATS_TX_MSDU_RETRIES = 3,
	NL80211_TID_STATS_TX_MSDU_FAILED = 4,
	NL80211_TID_STATS_PAD = 5,
	NL80211_TID_STATS_TXQ_STATS = 6,
	NUM_NL80211_TID_STATS = 7,
	NL80211_TID_STATS_MAX = 6,
};

enum nl80211_timeout_reason {
	NL80211_TIMEOUT_UNSPECIFIED = 0,
	NL80211_TIMEOUT_SCAN = 1,
	NL80211_TIMEOUT_AUTH = 2,
	NL80211_TIMEOUT_ASSOC = 3,
};

enum nl80211_tx_power_setting {
	NL80211_TX_POWER_AUTOMATIC = 0,
	NL80211_TX_POWER_LIMITED = 1,
	NL80211_TX_POWER_FIXED = 2,
};

enum nl80211_tx_rate_attributes {
	__NL80211_TXRATE_INVALID = 0,
	NL80211_TXRATE_LEGACY = 1,
	NL80211_TXRATE_HT = 2,
	NL80211_TXRATE_VHT = 3,
	NL80211_TXRATE_GI = 4,
	NL80211_TXRATE_HE = 5,
	NL80211_TXRATE_HE_GI = 6,
	NL80211_TXRATE_HE_LTF = 7,
	__NL80211_TXRATE_AFTER_LAST = 8,
	NL80211_TXRATE_MAX = 7,
};

enum nl80211_tx_rate_setting {
	NL80211_TX_RATE_AUTOMATIC = 0,
	NL80211_TX_RATE_LIMITED = 1,
	NL80211_TX_RATE_FIXED = 2,
};

enum nl80211_txq_attr {
	__NL80211_TXQ_ATTR_INVALID = 0,
	NL80211_TXQ_ATTR_AC = 1,
	NL80211_TXQ_ATTR_TXOP = 2,
	NL80211_TXQ_ATTR_CWMIN = 3,
	NL80211_TXQ_ATTR_CWMAX = 4,
	NL80211_TXQ_ATTR_AIFS = 5,
	__NL80211_TXQ_ATTR_AFTER_LAST = 6,
	NL80211_TXQ_ATTR_MAX = 5,
};

enum nl80211_txq_stats {
	__NL80211_TXQ_STATS_INVALID = 0,
	NL80211_TXQ_STATS_BACKLOG_BYTES = 1,
	NL80211_TXQ_STATS_BACKLOG_PACKETS = 2,
	NL80211_TXQ_STATS_FLOWS = 3,
	NL80211_TXQ_STATS_DROPS = 4,
	NL80211_TXQ_STATS_ECN_MARKS = 5,
	NL80211_TXQ_STATS_OVERLIMIT = 6,
	NL80211_TXQ_STATS_OVERMEMORY = 7,
	NL80211_TXQ_STATS_COLLISIONS = 8,
	NL80211_TXQ_STATS_TX_BYTES = 9,
	NL80211_TXQ_STATS_TX_PACKETS = 10,
	NL80211_TXQ_STATS_MAX_FLOWS = 11,
	NUM_NL80211_TXQ_STATS = 12,
	NL80211_TXQ_STATS_MAX = 11,
};

enum nl80211_txrate_gi {
	NL80211_TXRATE_DEFAULT_GI = 0,
	NL80211_TXRATE_FORCE_SGI = 1,
	NL80211_TXRATE_FORCE_LGI = 2,
};

enum nl80211_unsol_bcast_probe_resp_attributes {
	__NL80211_UNSOL_BCAST_PROBE_RESP_ATTR_INVALID = 0,
	NL80211_UNSOL_BCAST_PROBE_RESP_ATTR_INT = 1,
	NL80211_UNSOL_BCAST_PROBE_RESP_ATTR_TMPL = 2,
	__NL80211_UNSOL_BCAST_PROBE_RESP_ATTR_LAST = 3,
	NL80211_UNSOL_BCAST_PROBE_RESP_ATTR_MAX = 2,
};

enum nl80211_user_reg_hint_type {
	NL80211_USER_REG_HINT_USER = 0,
	NL80211_USER_REG_HINT_CELL_BASE = 1,
	NL80211_USER_REG_HINT_INDOOR = 2,
};

enum nl80211_wiphy_radio_attrs {
	__NL80211_WIPHY_RADIO_ATTR_INVALID = 0,
	NL80211_WIPHY_RADIO_ATTR_INDEX = 1,
	NL80211_WIPHY_RADIO_ATTR_FREQ_RANGE = 2,
	NL80211_WIPHY_RADIO_ATTR_INTERFACE_COMBINATION = 3,
	NL80211_WIPHY_RADIO_ATTR_ANTENNA_MASK = 4,
	__NL80211_WIPHY_RADIO_ATTR_LAST = 5,
	NL80211_WIPHY_RADIO_ATTR_MAX = 4,
};

enum nl80211_wiphy_radio_freq_range {
	__NL80211_WIPHY_RADIO_FREQ_ATTR_INVALID = 0,
	NL80211_WIPHY_RADIO_FREQ_ATTR_START = 1,
	NL80211_WIPHY_RADIO_FREQ_ATTR_END = 2,
	__NL80211_WIPHY_RADIO_FREQ_ATTR_LAST = 3,
	NL80211_WIPHY_RADIO_FREQ_ATTR_MAX = 2,
};

enum nl80211_wmm_rule {
	__NL80211_WMMR_INVALID = 0,
	NL80211_WMMR_CW_MIN = 1,
	NL80211_WMMR_CW_MAX = 2,
	NL80211_WMMR_AIFSN = 3,
	NL80211_WMMR_TXOP = 4,
	__NL80211_WMMR_LAST = 5,
	NL80211_WMMR_MAX = 4,
};

enum nl80211_wowlan_tcp_attrs {
	__NL80211_WOWLAN_TCP_INVALID = 0,
	NL80211_WOWLAN_TCP_SRC_IPV4 = 1,
	NL80211_WOWLAN_TCP_DST_IPV4 = 2,
	NL80211_WOWLAN_TCP_DST_MAC = 3,
	NL80211_WOWLAN_TCP_SRC_PORT = 4,
	NL80211_WOWLAN_TCP_DST_PORT = 5,
	NL80211_WOWLAN_TCP_DATA_PAYLOAD = 6,
	NL80211_WOWLAN_TCP_DATA_PAYLOAD_SEQ = 7,
	NL80211_WOWLAN_TCP_DATA_PAYLOAD_TOKEN = 8,
	NL80211_WOWLAN_TCP_DATA_INTERVAL = 9,
	NL80211_WOWLAN_TCP_WAKE_PAYLOAD = 10,
	NL80211_WOWLAN_TCP_WAKE_MASK = 11,
	NUM_NL80211_WOWLAN_TCP = 12,
	MAX_NL80211_WOWLAN_TCP = 11,
};

enum nl80211_wowlan_triggers {
	__NL80211_WOWLAN_TRIG_INVALID = 0,
	NL80211_WOWLAN_TRIG_ANY = 1,
	NL80211_WOWLAN_TRIG_DISCONNECT = 2,
	NL80211_WOWLAN_TRIG_MAGIC_PKT = 3,
	NL80211_WOWLAN_TRIG_PKT_PATTERN = 4,
	NL80211_WOWLAN_TRIG_GTK_REKEY_SUPPORTED = 5,
	NL80211_WOWLAN_TRIG_GTK_REKEY_FAILURE = 6,
	NL80211_WOWLAN_TRIG_EAP_IDENT_REQUEST = 7,
	NL80211_WOWLAN_TRIG_4WAY_HANDSHAKE = 8,
	NL80211_WOWLAN_TRIG_RFKILL_RELEASE = 9,
	NL80211_WOWLAN_TRIG_WAKEUP_PKT_80211 = 10,
	NL80211_WOWLAN_TRIG_WAKEUP_PKT_80211_LEN = 11,
	NL80211_WOWLAN_TRIG_WAKEUP_PKT_8023 = 12,
	NL80211_WOWLAN_TRIG_WAKEUP_PKT_8023_LEN = 13,
	NL80211_WOWLAN_TRIG_TCP_CONNECTION = 14,
	NL80211_WOWLAN_TRIG_WAKEUP_TCP_MATCH = 15,
	NL80211_WOWLAN_TRIG_WAKEUP_TCP_CONNLOST = 16,
	NL80211_WOWLAN_TRIG_WAKEUP_TCP_NOMORETOKENS = 17,
	NL80211_WOWLAN_TRIG_NET_DETECT = 18,
	NL80211_WOWLAN_TRIG_NET_DETECT_RESULTS = 19,
	NL80211_WOWLAN_TRIG_UNPROTECTED_DEAUTH_DISASSOC = 20,
	NUM_NL80211_WOWLAN_TRIG = 21,
	MAX_NL80211_WOWLAN_TRIG = 20,
};

enum nl80211_wpa_versions {
	NL80211_WPA_VERSION_1 = 1,
	NL80211_WPA_VERSION_2 = 2,
	NL80211_WPA_VERSION_3 = 4,
};

enum nla_policy_validation {
	NLA_VALIDATE_NONE = 0,
	NLA_VALIDATE_RANGE = 1,
	NLA_VALIDATE_RANGE_WARN_TOO_LONG = 2,
	NLA_VALIDATE_MIN = 3,
	NLA_VALIDATE_MAX = 4,
	NLA_VALIDATE_MASK = 5,
	NLA_VALIDATE_RANGE_PTR = 6,
	NLA_VALIDATE_FUNCTION = 7,
};

enum nlmsgerr_attrs {
	NLMSGERR_ATTR_UNUSED = 0,
	NLMSGERR_ATTR_MSG = 1,
	NLMSGERR_ATTR_OFFS = 2,
	NLMSGERR_ATTR_COOKIE = 3,
	NLMSGERR_ATTR_POLICY = 4,
	NLMSGERR_ATTR_MISS_TYPE = 5,
	NLMSGERR_ATTR_MISS_NEST = 6,
	__NLMSGERR_ATTR_MAX = 7,
	NLMSGERR_ATTR_MAX = 6,
};

enum nmi_states {
	NMI_NOT_RUNNING = 0,
	NMI_EXECUTING = 1,
	NMI_LATCHED = 2,
};

enum node_stat_item {
	NR_LRU_BASE = 0,
	NR_INACTIVE_ANON = 0,
	NR_ACTIVE_ANON = 1,
	NR_INACTIVE_FILE = 2,
	NR_ACTIVE_FILE = 3,
	NR_UNEVICTABLE = 4,
	NR_SLAB_RECLAIMABLE_B = 5,
	NR_SLAB_UNRECLAIMABLE_B = 6,
	NR_ISOLATED_ANON = 7,
	NR_ISOLATED_FILE = 8,
	WORKINGSET_NODES = 9,
	WORKINGSET_REFAULT_BASE = 10,
	WORKINGSET_REFAULT_ANON = 10,
	WORKINGSET_REFAULT_FILE = 11,
	WORKINGSET_ACTIVATE_BASE = 12,
	WORKINGSET_ACTIVATE_ANON = 12,
	WORKINGSET_ACTIVATE_FILE = 13,
	WORKINGSET_RESTORE_BASE = 14,
	WORKINGSET_RESTORE_ANON = 14,
	WORKINGSET_RESTORE_FILE = 15,
	WORKINGSET_NODERECLAIM = 16,
	NR_ANON_MAPPED = 17,
	NR_FILE_MAPPED = 18,
	NR_FILE_PAGES = 19,
	NR_FILE_DIRTY = 20,
	NR_WRITEBACK = 21,
	NR_WRITEBACK_TEMP = 22,
	NR_SHMEM = 23,
	NR_SHMEM_THPS = 24,
	NR_SHMEM_PMDMAPPED = 25,
	NR_FILE_THPS = 26,
	NR_FILE_PMDMAPPED = 27,
	NR_ANON_THPS = 28,
	NR_VMSCAN_WRITE = 29,
	NR_VMSCAN_IMMEDIATE = 30,
	NR_DIRTIED = 31,
	NR_WRITTEN = 32,
	NR_THROTTLED_WRITTEN = 33,
	NR_KERNEL_MISC_RECLAIMABLE = 34,
	NR_FOLL_PIN_ACQUIRED = 35,
	NR_FOLL_PIN_RELEASED = 36,
	NR_KERNEL_STACK_KB = 37,
	NR_PAGETABLE = 38,
	NR_SECONDARY_PAGETABLE = 39,
	NR_IOMMU_PAGES = 40,
	NR_SWAPCACHE = 41,
	PGDEMOTE_KSWAPD = 42,
	PGDEMOTE_DIRECT = 43,
	PGDEMOTE_KHUGEPAGED = 44,
	NR_HUGETLB = 45,
	NR_VM_NODE_STAT_ITEMS = 46,
};

enum node_states {
	N_POSSIBLE = 0,
	N_ONLINE = 1,
	N_NORMAL_MEMORY = 2,
	N_HIGH_MEMORY = 2,
	N_MEMORY = 3,
	N_CPU = 4,
	N_GENERIC_INITIATOR = 5,
	NR_NODE_STATES = 6,
};

enum notify_state {
	SECCOMP_NOTIFY_INIT = 0,
	SECCOMP_NOTIFY_SENT = 1,
	SECCOMP_NOTIFY_REPLIED = 2,
};

enum numa_stat_item {
	NUMA_HIT = 0,
	NUMA_MISS = 1,
	NUMA_FOREIGN = 2,
	NUMA_INTERLEAVE_HIT = 3,
	NUMA_LOCAL = 4,
	NUMA_OTHER = 5,
	NR_VM_NUMA_EVENT_ITEMS = 6,
};

enum numa_topology_type {
	NUMA_DIRECT = 0,
	NUMA_GLUELESS_MESH = 1,
	NUMA_BACKPLANE = 2,
};

enum nvmem_type {
	NVMEM_TYPE_UNKNOWN = 0,
	NVMEM_TYPE_EEPROM = 1,
	NVMEM_TYPE_OTP = 2,
	NVMEM_TYPE_BATTERY_BACKED = 3,
	NVMEM_TYPE_FRAM = 4,
};

enum oa_type {
	TYPE_OAG = 0,
	TYPE_OAM = 1,
};

enum ocb_deferred_task_flags {
	OCB_WORK_HOUSEKEEPING = 0,
};

enum offload_act_command {
	FLOW_ACT_REPLACE = 0,
	FLOW_ACT_DESTROY = 1,
	FLOW_ACT_STATS = 2,
};

enum ohci_rh_state {
	OHCI_RH_HALTED = 0,
	OHCI_RH_SUSPENDED = 1,
	OHCI_RH_RUNNING = 2,
};

enum oom_constraint {
	CONSTRAINT_NONE = 0,
	CONSTRAINT_CPUSET = 1,
	CONSTRAINT_MEMORY_POLICY = 2,
	CONSTRAINT_MEMCG = 3,
};

enum open_claim_type4 {
	NFS4_OPEN_CLAIM_NULL = 0,
	NFS4_OPEN_CLAIM_PREVIOUS = 1,
	NFS4_OPEN_CLAIM_DELEGATE_CUR = 2,
	NFS4_OPEN_CLAIM_DELEGATE_PREV = 3,
	NFS4_OPEN_CLAIM_FH = 4,
	NFS4_OPEN_CLAIM_DELEG_CUR_FH = 5,
	NFS4_OPEN_CLAIM_DELEG_PREV_FH = 6,
};

enum opentype4 {
	NFS4_OPEN_NOCREATE = 0,
	NFS4_OPEN_CREATE = 1,
};

enum operation_mode {
	DP_AS_SDP_AVT_DYNAMIC_VTOTAL = 0,
	DP_AS_SDP_AVT_FIXED_VTOTAL = 1,
	DP_AS_SDP_FAVT_TRR_NOT_REACHED = 2,
	DP_AS_SDP_FAVT_TRR_REACHED = 3,
};

enum owner_state {
	OWNER_NULL = 1,
	OWNER_WRITER = 2,
	OWNER_READER = 4,
	OWNER_NONSPINNABLE = 8,
};

enum p9_cache_bits {
	CACHE_NONE = 0,
	CACHE_FILE = 1,
	CACHE_META = 2,
	CACHE_WRITEBACK = 4,
	CACHE_LOOSE = 8,
	CACHE_FSCACHE = 128,
};

enum p9_cache_shortcuts {
	CACHE_SC_NONE = 0,
	CACHE_SC_READAHEAD = 1,
	CACHE_SC_MMAP = 5,
	CACHE_SC_LOOSE = 15,
	CACHE_SC_FSCACHE = 143,
};

enum p9_fid_reftype {
	P9_FID_REF_CREATE = 0,
	P9_FID_REF_GET = 1,
	P9_FID_REF_PUT = 2,
	P9_FID_REF_DESTROY = 3,
} __attribute__((mode(byte)));

enum p9_msg_t {
	P9_TLERROR = 6,
	P9_RLERROR = 7,
	P9_TSTATFS = 8,
	P9_RSTATFS = 9,
	P9_TLOPEN = 12,
	P9_RLOPEN = 13,
	P9_TLCREATE = 14,
	P9_RLCREATE = 15,
	P9_TSYMLINK = 16,
	P9_RSYMLINK = 17,
	P9_TMKNOD = 18,
	P9_RMKNOD = 19,
	P9_TRENAME = 20,
	P9_RRENAME = 21,
	P9_TREADLINK = 22,
	P9_RREADLINK = 23,
	P9_TGETATTR = 24,
	P9_RGETATTR = 25,
	P9_TSETATTR = 26,
	P9_RSETATTR = 27,
	P9_TXATTRWALK = 30,
	P9_RXATTRWALK = 31,
	P9_TXATTRCREATE = 32,
	P9_RXATTRCREATE = 33,
	P9_TREADDIR = 40,
	P9_RREADDIR = 41,
	P9_TFSYNC = 50,
	P9_RFSYNC = 51,
	P9_TLOCK = 52,
	P9_RLOCK = 53,
	P9_TGETLOCK = 54,
	P9_RGETLOCK = 55,
	P9_TLINK = 70,
	P9_RLINK = 71,
	P9_TMKDIR = 72,
	P9_RMKDIR = 73,
	P9_TRENAMEAT = 74,
	P9_RRENAMEAT = 75,
	P9_TUNLINKAT = 76,
	P9_RUNLINKAT = 77,
	P9_TVERSION = 100,
	P9_RVERSION = 101,
	P9_TAUTH = 102,
	P9_RAUTH = 103,
	P9_TATTACH = 104,
	P9_RATTACH = 105,
	P9_TERROR = 106,
	P9_RERROR = 107,
	P9_TFLUSH = 108,
	P9_RFLUSH = 109,
	P9_TWALK = 110,
	P9_RWALK = 111,
	P9_TOPEN = 112,
	P9_ROPEN = 113,
	P9_TCREATE = 114,
	P9_RCREATE = 115,
	P9_TREAD = 116,
	P9_RREAD = 117,
	P9_TWRITE = 118,
	P9_RWRITE = 119,
	P9_TCLUNK = 120,
	P9_RCLUNK = 121,
	P9_TREMOVE = 122,
	P9_RREMOVE = 123,
	P9_TSTAT = 124,
	P9_RSTAT = 125,
	P9_TWSTAT = 126,
	P9_RWSTAT = 127,
};

enum p9_open_mode_t {
	P9_OREAD = 0,
	P9_OWRITE = 1,
	P9_ORDWR = 2,
	P9_OEXEC = 3,
	P9_OTRUNC = 16,
	P9_OREXEC = 32,
	P9_ORCLOSE = 64,
	P9_OAPPEND = 128,
	P9_OEXCL = 4096,
	P9L_MODE_MASK = 8191,
	P9L_DIRECT = 8192,
	P9L_NOWRITECACHE = 16384,
	P9L_LOOSE = 32768,
};

enum p9_perm_t {
	P9_DMDIR = 2147483648,
	P9_DMAPPEND = 1073741824,
	P9_DMEXCL = 536870912,
	P9_DMMOUNT = 268435456,
	P9_DMAUTH = 134217728,
	P9_DMTMP = 67108864,
	P9_DMSYMLINK = 33554432,
	P9_DMLINK = 16777216,
	P9_DMDEVICE = 8388608,
	P9_DMNAMEDPIPE = 2097152,
	P9_DMSOCKET = 1048576,
	P9_DMSETUID = 524288,
	P9_DMSETGID = 262144,
	P9_DMSETVTX = 65536,
};

enum p9_proto_versions {
	p9_proto_legacy = 0,
	p9_proto_2000u = 1,
	p9_proto_2000L = 2,
};

enum p9_req_status_t {
	REQ_STATUS_ALLOC = 0,
	REQ_STATUS_UNSENT = 1,
	REQ_STATUS_SENT = 2,
	REQ_STATUS_RCVD = 3,
	REQ_STATUS_FLSHD = 4,
	REQ_STATUS_ERROR = 5,
};

enum p9_session_flags {
	V9FS_PROTO_2000U = 1,
	V9FS_PROTO_2000L = 2,
	V9FS_ACCESS_SINGLE = 4,
	V9FS_ACCESS_USER = 8,
	V9FS_ACCESS_CLIENT = 16,
	V9FS_POSIX_ACL = 32,
	V9FS_NO_XATTR = 64,
	V9FS_IGNORE_QV = 128,
	V9FS_DIRECT_IO = 256,
	V9FS_SYNC = 512,
};

enum p9_trans_status {
	Connected = 0,
	BeginDisconnect = 1,
	Disconnected = 2,
	Hung = 3,
};

enum packet_sock_flags {
	PACKET_SOCK_ORIGDEV = 0,
	PACKET_SOCK_AUXDATA = 1,
	PACKET_SOCK_TX_HAS_OFF = 2,
	PACKET_SOCK_TP_LOSS = 3,
	PACKET_SOCK_RUNNING = 4,
	PACKET_SOCK_PRESSURE = 5,
	PACKET_SOCK_QDISC_BYPASS = 6,
};

enum page_cache_mode {
	_PAGE_CACHE_MODE_WB = 0,
	_PAGE_CACHE_MODE_WC = 1,
	_PAGE_CACHE_MODE_UC_MINUS = 2,
	_PAGE_CACHE_MODE_UC = 3,
	_PAGE_CACHE_MODE_WT = 4,
	_PAGE_CACHE_MODE_WP = 5,
	_PAGE_CACHE_MODE_NUM = 8,
};

enum page_size_enum {
	__PAGE_SIZE = 4096,
};

enum page_walk_action {
	ACTION_SUBTREE = 0,
	ACTION_CONTINUE = 1,
	ACTION_AGAIN = 2,
};

enum page_walk_lock {
	PGWALK_RDLOCK = 0,
	PGWALK_WRLOCK = 1,
	PGWALK_WRLOCK_VERIFY = 2,
};

enum pageblock_bits {
	PB_migrate = 0,
	PB_migrate_end = 2,
	PB_migrate_skip = 3,
	NR_PAGEBLOCK_BITS = 4,
};

enum pageflags {
	PG_locked = 0,
	PG_writeback = 1,
	PG_referenced = 2,
	PG_uptodate = 3,
	PG_dirty = 4,
	PG_lru = 5,
	PG_head = 6,
	PG_waiters = 7,
	PG_active = 8,
	PG_workingset = 9,
	PG_owner_priv_1 = 10,
	PG_owner_2 = 11,
	PG_arch_1 = 12,
	PG_reserved = 13,
	PG_private = 14,
	PG_private_2 = 15,
	PG_reclaim = 16,
	PG_swapbacked = 17,
	PG_unevictable = 18,
	PG_dropbehind = 19,
	PG_mlocked = 20,
	PG_arch_2 = 21,
	__NR_PAGEFLAGS = 22,
	PG_readahead = 16,
	PG_swapcache = 10,
	PG_checked = 10,
	PG_anon_exclusive = 11,
	PG_mappedtodisk = 11,
	PG_fscache = 15,
	PG_pinned = 10,
	PG_savepinned = 4,
	PG_foreign = 10,
	PG_xen_remapped = 10,
	PG_isolated = 16,
	PG_reported = 3,
	PG_has_hwpoisoned = 8,
	PG_large_rmappable = 9,
	PG_partially_mapped = 16,
};

enum pagetype {
	PGTY_buddy = 240,
	PGTY_offline = 241,
	PGTY_table = 242,
	PGTY_guard = 243,
	PGTY_hugetlb = 244,
	PGTY_slab = 245,
	PGTY_zsmalloc = 246,
	PGTY_unaccepted = 247,
	PGTY_mapcount_underflow = 255,
};

enum panel_type {
	PANEL_TYPE_OPREGION = 0,
	PANEL_TYPE_VBT = 1,
	PANEL_TYPE_PNPID = 2,
	PANEL_TYPE_FALLBACK = 3,
};

enum partition_cmd {
	partcmd_enable = 0,
	partcmd_enablei = 1,
	partcmd_disable = 2,
	partcmd_update = 3,
	partcmd_invalidate = 4,
};

enum passtype {
	PASS_SCAN = 0,
	PASS_REVOKE = 1,
	PASS_REPLAY = 2,
};

enum pci_bar_type {
	pci_bar_unknown = 0,
	pci_bar_io = 1,
	pci_bar_mem32 = 2,
	pci_bar_mem64 = 3,
};

enum pci_bf_sort_state {
	pci_bf_sort_default = 0,
	pci_force_nobf = 1,
	pci_force_bf = 2,
	pci_dmi_bf = 3,
};

enum pci_board_num_t {
	pbn_default = 0,
	pbn_b0_1_115200 = 1,
	pbn_b0_2_115200 = 2,
	pbn_b0_4_115200 = 3,
	pbn_b0_5_115200 = 4,
	pbn_b0_8_115200 = 5,
	pbn_b0_1_921600 = 6,
	pbn_b0_2_921600 = 7,
	pbn_b0_4_921600 = 8,
	pbn_b0_2_1130000 = 9,
	pbn_b0_4_1152000 = 10,
	pbn_b0_4_1250000 = 11,
	pbn_b0_2_1843200 = 12,
	pbn_b0_4_1843200 = 13,
	pbn_b0_1_15625000 = 14,
	pbn_b0_bt_1_115200 = 15,
	pbn_b0_bt_2_115200 = 16,
	pbn_b0_bt_4_115200 = 17,
	pbn_b0_bt_8_115200 = 18,
	pbn_b0_bt_1_460800 = 19,
	pbn_b0_bt_2_460800 = 20,
	pbn_b0_bt_4_460800 = 21,
	pbn_b0_bt_1_921600 = 22,
	pbn_b0_bt_2_921600 = 23,
	pbn_b0_bt_4_921600 = 24,
	pbn_b0_bt_8_921600 = 25,
	pbn_b1_1_115200 = 26,
	pbn_b1_2_115200 = 27,
	pbn_b1_4_115200 = 28,
	pbn_b1_8_115200 = 29,
	pbn_b1_16_115200 = 30,
	pbn_b1_1_921600 = 31,
	pbn_b1_2_921600 = 32,
	pbn_b1_4_921600 = 33,
	pbn_b1_8_921600 = 34,
	pbn_b1_2_1250000 = 35,
	pbn_b1_bt_1_115200 = 36,
	pbn_b1_bt_2_115200 = 37,
	pbn_b1_bt_4_115200 = 38,
	pbn_b1_bt_2_921600 = 39,
	pbn_b1_1_1382400 = 40,
	pbn_b1_2_1382400 = 41,
	pbn_b1_4_1382400 = 42,
	pbn_b1_8_1382400 = 43,
	pbn_b2_1_115200 = 44,
	pbn_b2_2_115200 = 45,
	pbn_b2_4_115200 = 46,
	pbn_b2_8_115200 = 47,
	pbn_b2_1_460800 = 48,
	pbn_b2_4_460800 = 49,
	pbn_b2_8_460800 = 50,
	pbn_b2_16_460800 = 51,
	pbn_b2_1_921600 = 52,
	pbn_b2_4_921600 = 53,
	pbn_b2_8_921600 = 54,
	pbn_b2_8_1152000 = 55,
	pbn_b2_bt_1_115200 = 56,
	pbn_b2_bt_2_115200 = 57,
	pbn_b2_bt_4_115200 = 58,
	pbn_b2_bt_2_921600 = 59,
	pbn_b2_bt_4_921600 = 60,
	pbn_b3_2_115200 = 61,
	pbn_b3_4_115200 = 62,
	pbn_b3_8_115200 = 63,
	pbn_b4_bt_2_921600 = 64,
	pbn_b4_bt_4_921600 = 65,
	pbn_b4_bt_8_921600 = 66,
	pbn_panacom = 67,
	pbn_panacom2 = 68,
	pbn_panacom4 = 69,
	pbn_plx_romulus = 70,
	pbn_oxsemi = 71,
	pbn_oxsemi_1_15625000 = 72,
	pbn_oxsemi_2_15625000 = 73,
	pbn_oxsemi_4_15625000 = 74,
	pbn_oxsemi_8_15625000 = 75,
	pbn_intel_i960 = 76,
	pbn_sgi_ioc3 = 77,
	pbn_computone_4 = 78,
	pbn_computone_6 = 79,
	pbn_computone_8 = 80,
	pbn_sbsxrsio = 81,
	pbn_pasemi_1682M = 82,
	pbn_ni8430_2 = 83,
	pbn_ni8430_4 = 84,
	pbn_ni8430_8 = 85,
	pbn_ni8430_16 = 86,
	pbn_ADDIDATA_PCIe_1_3906250 = 87,
	pbn_ADDIDATA_PCIe_2_3906250 = 88,
	pbn_ADDIDATA_PCIe_4_3906250 = 89,
	pbn_ADDIDATA_PCIe_8_3906250 = 90,
	pbn_ce4100_1_115200 = 91,
	pbn_omegapci = 92,
	pbn_NETMOS9900_2s_115200 = 93,
	pbn_brcm_trumanage = 94,
	pbn_fintek_4 = 95,
	pbn_fintek_8 = 96,
	pbn_fintek_12 = 97,
	pbn_fintek_F81504A = 98,
	pbn_fintek_F81508A = 99,
	pbn_fintek_F81512A = 100,
	pbn_wch382_2 = 101,
	pbn_wch384_4 = 102,
	pbn_wch384_8 = 103,
	pbn_sunix_pci_1s = 104,
	pbn_sunix_pci_2s = 105,
	pbn_sunix_pci_4s = 106,
	pbn_sunix_pci_8s = 107,
	pbn_sunix_pci_16s = 108,
	pbn_titan_1_4000000 = 109,
	pbn_titan_2_4000000 = 110,
	pbn_titan_4_4000000 = 111,
	pbn_titan_8_4000000 = 112,
	pbn_moxa_2 = 113,
	pbn_moxa_4 = 114,
	pbn_moxa_8 = 115,
};

enum pci_bus_flags {
	PCI_BUS_FLAGS_NO_MSI = 1,
	PCI_BUS_FLAGS_NO_MMRBC = 2,
	PCI_BUS_FLAGS_NO_AERSID = 4,
	PCI_BUS_FLAGS_NO_EXTCFG = 8,
};

enum pci_bus_speed {
	PCI_SPEED_33MHz = 0,
	PCI_SPEED_66MHz = 1,
	PCI_SPEED_66MHz_PCIX = 2,
	PCI_SPEED_100MHz_PCIX = 3,
	PCI_SPEED_133MHz_PCIX = 4,
	PCI_SPEED_66MHz_PCIX_ECC = 5,
	PCI_SPEED_100MHz_PCIX_ECC = 6,
	PCI_SPEED_133MHz_PCIX_ECC = 7,
	PCI_SPEED_66MHz_PCIX_266 = 9,
	PCI_SPEED_100MHz_PCIX_266 = 10,
	PCI_SPEED_133MHz_PCIX_266 = 11,
	AGP_UNKNOWN = 12,
	AGP_1X = 13,
	AGP_2X = 14,
	AGP_4X = 15,
	AGP_8X = 16,
	PCI_SPEED_66MHz_PCIX_533 = 17,
	PCI_SPEED_100MHz_PCIX_533 = 18,
	PCI_SPEED_133MHz_PCIX_533 = 19,
	PCIE_SPEED_2_5GT = 20,
	PCIE_SPEED_5_0GT = 21,
	PCIE_SPEED_8_0GT = 22,
	PCIE_SPEED_16_0GT = 23,
	PCIE_SPEED_32_0GT = 24,
	PCIE_SPEED_64_0GT = 25,
	PCI_SPEED_UNKNOWN = 255,
};

enum pci_dev_flags {
	PCI_DEV_FLAGS_MSI_INTX_DISABLE_BUG = 1,
	PCI_DEV_FLAGS_NO_D3 = 2,
	PCI_DEV_FLAGS_ASSIGNED = 4,
	PCI_DEV_FLAGS_ACS_ENABLED_QUIRK = 8,
	PCI_DEV_FLAG_PCIE_BRIDGE_ALIAS = 32,
	PCI_DEV_FLAGS_NO_BUS_RESET = 64,
	PCI_DEV_FLAGS_NO_PM_RESET = 128,
	PCI_DEV_FLAGS_VPD_REF_F0 = 256,
	PCI_DEV_FLAGS_BRIDGE_XLATE_ROOT = 512,
	PCI_DEV_FLAGS_NO_FLR_RESET = 1024,
	PCI_DEV_FLAGS_NO_RELAXED_ORDERING = 2048,
	PCI_DEV_FLAGS_HAS_MSI_MASKING = 4096,
};

enum pci_dev_reg_1 {
	PCI_Y2_PIG_ENA = -2147483648,
	PCI_Y2_DLL_DIS = 1073741824,
	PCI_SW_PWR_ON_RST = 1073741824,
	PCI_Y2_PHY2_COMA = 536870912,
	PCI_Y2_PHY1_COMA = 268435456,
	PCI_Y2_PHY2_POWD = 134217728,
	PCI_Y2_PHY1_POWD = 67108864,
	PCI_Y2_PME_LEGACY = 32768,
	PCI_PHY_LNK_TIM_MSK = 768,
	PCI_ENA_L1_EVENT = 128,
	PCI_ENA_GPHY_LNK = 64,
	PCI_FORCE_PEX_L1 = 32,
};

enum pci_dev_reg_2 {
	PCI_VPD_WR_THR = 4278190080,
	PCI_DEV_SEL = 16646144,
	PCI_VPD_ROM_SZ = 114688,
	PCI_PATCH_DIR = 3840,
	PCI_EXT_PATCHS = 240,
	PCI_EN_DUMMY_RD = 8,
	PCI_REV_DESC = 4,
	PCI_USEDATA64 = 1,
};

enum pci_dev_reg_3 {
	P_CLK_ASF_REGS_DIS = 262144,
	P_CLK_COR_REGS_D0_DIS = 131072,
	P_CLK_MACSEC_DIS = 131072,
	P_CLK_PCI_REGS_D0_DIS = 65536,
	P_CLK_COR_YTB_ARB_DIS = 32768,
	P_CLK_MAC_LNK1_D3_DIS = 16384,
	P_CLK_COR_LNK1_D0_DIS = 8192,
	P_CLK_MAC_LNK1_D0_DIS = 4096,
	P_CLK_COR_LNK1_D3_DIS = 2048,
	P_CLK_PCI_MST_ARB_DIS = 1024,
	P_CLK_COR_REGS_D3_DIS = 512,
	P_CLK_PCI_REGS_D3_DIS = 256,
	P_CLK_REF_LNK1_GM_DIS = 128,
	P_CLK_COR_LNK1_GM_DIS = 64,
	P_CLK_PCI_COMMON_DIS = 32,
	P_CLK_COR_COMMON_DIS = 16,
	P_CLK_PCI_LNK1_BMU_DIS = 8,
	P_CLK_COR_LNK1_BMU_DIS = 4,
	P_CLK_PCI_LNK1_BIU_DIS = 2,
	P_CLK_COR_LNK1_BIU_DIS = 1,
	PCIE_OUR3_WOL_D3_COLD_SET = 406548,
};

enum pci_dev_reg_4 {
	P_PEX_LTSSM_STAT_MSK = 4261412864,
	P_PEX_LTSSM_L1_STAT = 52,
	P_PEX_LTSSM_DET_STAT = 1,
	P_TIMER_VALUE_MSK = 16711680,
	P_FORCE_ASPM_REQUEST = 32768,
	P_ASPM_GPHY_LINK_DOWN = 16384,
	P_ASPM_INT_FIFO_EMPTY = 8192,
	P_ASPM_CLKRUN_REQUEST = 4096,
	P_ASPM_FORCE_CLKREQ_ENA = 16,
	P_ASPM_CLKREQ_PAD_CTL = 8,
	P_ASPM_A1_MODE_SELECT = 4,
	P_CLK_GATE_PEX_UNIT_ENA = 2,
	P_CLK_GATE_ROOT_COR_ENA = 1,
	P_ASPM_CONTROL_MSK = 61440,
};

enum pci_dev_reg_5 {
	P_CTL_DIV_CORE_CLK_ENA = -2147483648,
	P_CTL_SRESET_VMAIN_AV = 1073741824,
	P_CTL_BYPASS_VMAIN_AV = 536870912,
	P_CTL_TIM_VMAIN_AV_MSK = 402653184,
	P_REL_PCIE_RST_DE_ASS = 67108864,
	P_REL_GPHY_REC_PACKET = 33554432,
	P_REL_INT_FIFO_N_EMPTY = 16777216,
	P_REL_MAIN_PWR_AVAIL = 8388608,
	P_REL_CLKRUN_REQ_REL = 4194304,
	P_REL_PCIE_RESET_ASS = 2097152,
	P_REL_PME_ASSERTED = 1048576,
	P_REL_PCIE_EXIT_L1_ST = 524288,
	P_REL_LOADER_NOT_FIN = 262144,
	P_REL_PCIE_RX_EX_IDLE = 131072,
	P_REL_GPHY_LINK_UP = 65536,
	P_GAT_PCIE_RST_ASSERTED = 1024,
	P_GAT_GPHY_N_REC_PACKET = 512,
	P_GAT_INT_FIFO_EMPTY = 256,
	P_GAT_MAIN_PWR_N_AVAIL = 128,
	P_GAT_CLKRUN_REQ_REL = 64,
	P_GAT_PCIE_RESET_ASS = 32,
	P_GAT_PME_DE_ASSERTED = 16,
	P_GAT_PCIE_ENTER_L1_ST = 8,
	P_GAT_LOADER_FINISHED = 4,
	P_GAT_PCIE_RX_EL_IDLE = 2,
	P_GAT_GPHY_LINK_DOWN = 1,
	PCIE_OUR5_EVENT_CLK_D3_SET = 50987786,
};

enum pci_ers_result {
	PCI_ERS_RESULT_NONE = 1,
	PCI_ERS_RESULT_CAN_RECOVER = 2,
	PCI_ERS_RESULT_NEED_RESET = 3,
	PCI_ERS_RESULT_DISCONNECT = 4,
	PCI_ERS_RESULT_RECOVERED = 5,
	PCI_ERS_RESULT_NO_AER_DRIVER = 6,
};

enum pci_fixup_pass {
	pci_fixup_early = 0,
	pci_fixup_header = 1,
	pci_fixup_final = 2,
	pci_fixup_enable = 3,
	pci_fixup_resume = 4,
	pci_fixup_suspend = 5,
	pci_fixup_resume_early = 6,
	pci_fixup_suspend_late = 7,
};

enum pci_irq_reroute_variant {
	INTEL_IRQ_REROUTE_VARIANT = 1,
	MAX_IRQ_REROUTE_VARIANTS = 3,
};

enum pci_mmap_api {
	PCI_MMAP_SYSFS = 0,
	PCI_MMAP_PROCFS = 1,
};

enum pci_mmap_state {
	pci_mmap_io = 0,
	pci_mmap_mem = 1,
};

enum pci_p2pdma_map_type {
	PCI_P2PDMA_MAP_UNKNOWN = 0,
	PCI_P2PDMA_MAP_NOT_SUPPORTED = 1,
	PCI_P2PDMA_MAP_BUS_ADDR = 2,
	PCI_P2PDMA_MAP_THRU_HOST_BRIDGE = 3,
};

enum pcie_bus_config_types {
	PCIE_BUS_TUNE_OFF = 0,
	PCIE_BUS_DEFAULT = 1,
	PCIE_BUS_SAFE = 2,
	PCIE_BUS_PERFORMANCE = 3,
	PCIE_BUS_PEER2PEER = 4,
};

enum pcie_link_width {
	PCIE_LNK_WIDTH_RESRV = 0,
	PCIE_LNK_X1 = 1,
	PCIE_LNK_X2 = 2,
	PCIE_LNK_X4 = 4,
	PCIE_LNK_X8 = 8,
	PCIE_LNK_X12 = 12,
	PCIE_LNK_X16 = 16,
	PCIE_LNK_X32 = 32,
	PCIE_LNK_WIDTH_UNKNOWN = 255,
};

enum pcie_reset_state {
	pcie_deassert_reset = 1,
	pcie_warm_reset = 2,
	pcie_hot_reset = 3,
};

enum pcim_addr_devres_type {
	PCIM_ADDR_DEVRES_TYPE_INVALID = 0,
	PCIM_ADDR_DEVRES_TYPE_REGION = 1,
	PCIM_ADDR_DEVRES_TYPE_REGION_MAPPING = 2,
	PCIM_ADDR_DEVRES_TYPE_MAPPING = 3,
};

enum pcpu_fc {
	PCPU_FC_AUTO = 0,
	PCPU_FC_EMBED = 1,
	PCPU_FC_PAGE = 2,
	PCPU_FC_NR = 3,
};

enum pedit_cmd {
	TCA_PEDIT_KEY_EX_CMD_SET = 0,
	TCA_PEDIT_KEY_EX_CMD_ADD = 1,
	__PEDIT_CMD_MAX = 2,
};

enum pedit_header_type {
	TCA_PEDIT_KEY_EX_HDR_TYPE_NETWORK = 0,
	TCA_PEDIT_KEY_EX_HDR_TYPE_ETH = 1,
	TCA_PEDIT_KEY_EX_HDR_TYPE_IP4 = 2,
	TCA_PEDIT_KEY_EX_HDR_TYPE_IP6 = 3,
	TCA_PEDIT_KEY_EX_HDR_TYPE_TCP = 4,
	TCA_PEDIT_KEY_EX_HDR_TYPE_UDP = 5,
	__PEDIT_HDR_TYPE_MAX = 6,
};

enum perf_addr_filter_action_t {
	PERF_ADDR_FILTER_ACTION_STOP = 0,
	PERF_ADDR_FILTER_ACTION_START = 1,
	PERF_ADDR_FILTER_ACTION_FILTER = 2,
};

enum perf_adl_uncore_imc_freerunning_types {
	ADL_MMIO_UNCORE_IMC_DATA_TOTAL = 0,
	ADL_MMIO_UNCORE_IMC_DATA_READ = 1,
	ADL_MMIO_UNCORE_IMC_DATA_WRITE = 2,
	ADL_MMIO_UNCORE_IMC_FREERUNNING_TYPE_MAX = 3,
};

enum perf_bpf_event_type {
	PERF_BPF_EVENT_UNKNOWN = 0,
	PERF_BPF_EVENT_PROG_LOAD = 1,
	PERF_BPF_EVENT_PROG_UNLOAD = 2,
	PERF_BPF_EVENT_MAX = 3,
};

enum perf_branch_sample_type {
	PERF_SAMPLE_BRANCH_USER = 1,
	PERF_SAMPLE_BRANCH_KERNEL = 2,
	PERF_SAMPLE_BRANCH_HV = 4,
	PERF_SAMPLE_BRANCH_ANY = 8,
	PERF_SAMPLE_BRANCH_ANY_CALL = 16,
	PERF_SAMPLE_BRANCH_ANY_RETURN = 32,
	PERF_SAMPLE_BRANCH_IND_CALL = 64,
	PERF_SAMPLE_BRANCH_ABORT_TX = 128,
	PERF_SAMPLE_BRANCH_IN_TX = 256,
	PERF_SAMPLE_BRANCH_NO_TX = 512,
	PERF_SAMPLE_BRANCH_COND = 1024,
	PERF_SAMPLE_BRANCH_CALL_STACK = 2048,
	PERF_SAMPLE_BRANCH_IND_JUMP = 4096,
	PERF_SAMPLE_BRANCH_CALL = 8192,
	PERF_SAMPLE_BRANCH_NO_FLAGS = 16384,
	PERF_SAMPLE_BRANCH_NO_CYCLES = 32768,
	PERF_SAMPLE_BRANCH_TYPE_SAVE = 65536,
	PERF_SAMPLE_BRANCH_HW_INDEX = 131072,
	PERF_SAMPLE_BRANCH_PRIV_SAVE = 262144,
	PERF_SAMPLE_BRANCH_COUNTERS = 524288,
	PERF_SAMPLE_BRANCH_MAX = 1048576,
};

enum perf_branch_sample_type_shift {
	PERF_SAMPLE_BRANCH_USER_SHIFT = 0,
	PERF_SAMPLE_BRANCH_KERNEL_SHIFT = 1,
	PERF_SAMPLE_BRANCH_HV_SHIFT = 2,
	PERF_SAMPLE_BRANCH_ANY_SHIFT = 3,
	PERF_SAMPLE_BRANCH_ANY_CALL_SHIFT = 4,
	PERF_SAMPLE_BRANCH_ANY_RETURN_SHIFT = 5,
	PERF_SAMPLE_BRANCH_IND_CALL_SHIFT = 6,
	PERF_SAMPLE_BRANCH_ABORT_TX_SHIFT = 7,
	PERF_SAMPLE_BRANCH_IN_TX_SHIFT = 8,
	PERF_SAMPLE_BRANCH_NO_TX_SHIFT = 9,
	PERF_SAMPLE_BRANCH_COND_SHIFT = 10,
	PERF_SAMPLE_BRANCH_CALL_STACK_SHIFT = 11,
	PERF_SAMPLE_BRANCH_IND_JUMP_SHIFT = 12,
	PERF_SAMPLE_BRANCH_CALL_SHIFT = 13,
	PERF_SAMPLE_BRANCH_NO_FLAGS_SHIFT = 14,
	PERF_SAMPLE_BRANCH_NO_CYCLES_SHIFT = 15,
	PERF_SAMPLE_BRANCH_TYPE_SAVE_SHIFT = 16,
	PERF_SAMPLE_BRANCH_HW_INDEX_SHIFT = 17,
	PERF_SAMPLE_BRANCH_PRIV_SAVE_SHIFT = 18,
	PERF_SAMPLE_BRANCH_COUNTERS_SHIFT = 19,
	PERF_SAMPLE_BRANCH_MAX_SHIFT = 20,
};

enum perf_callchain_context {
	PERF_CONTEXT_HV = 18446744073709551584ULL,
	PERF_CONTEXT_KERNEL = 18446744073709551488ULL,
	PERF_CONTEXT_USER = 18446744073709551104ULL,
	PERF_CONTEXT_GUEST = 18446744073709549568ULL,
	PERF_CONTEXT_GUEST_KERNEL = 18446744073709549440ULL,
	PERF_CONTEXT_GUEST_USER = 18446744073709549056ULL,
	PERF_CONTEXT_MAX = 18446744073709547521ULL,
};

enum perf_cstate_core_events {
	PERF_CSTATE_CORE_C1_RES = 0,
	PERF_CSTATE_CORE_C3_RES = 1,
	PERF_CSTATE_CORE_C6_RES = 2,
	PERF_CSTATE_CORE_C7_RES = 3,
	PERF_CSTATE_CORE_EVENT_MAX = 4,
};

enum perf_cstate_module_events {
	PERF_CSTATE_MODULE_C6_RES = 0,
	PERF_CSTATE_MODULE_EVENT_MAX = 1,
};

enum perf_cstate_pkg_events {
	PERF_CSTATE_PKG_C2_RES = 0,
	PERF_CSTATE_PKG_C3_RES = 1,
	PERF_CSTATE_PKG_C6_RES = 2,
	PERF_CSTATE_PKG_C7_RES = 3,
	PERF_CSTATE_PKG_C8_RES = 4,
	PERF_CSTATE_PKG_C9_RES = 5,
	PERF_CSTATE_PKG_C10_RES = 6,
	PERF_CSTATE_PKG_EVENT_MAX = 7,
};

enum perf_event_ioc_flags {
	PERF_IOC_FLAG_GROUP = 1,
};

enum perf_event_read_format {
	PERF_FORMAT_TOTAL_TIME_ENABLED = 1,
	PERF_FORMAT_TOTAL_TIME_RUNNING = 2,
	PERF_FORMAT_ID = 4,
	PERF_FORMAT_GROUP = 8,
	PERF_FORMAT_LOST = 16,
	PERF_FORMAT_MAX = 32,
};

enum perf_event_sample_format {
	PERF_SAMPLE_IP = 1,
	PERF_SAMPLE_TID = 2,
	PERF_SAMPLE_TIME = 4,
	PERF_SAMPLE_ADDR = 8,
	PERF_SAMPLE_READ = 16,
	PERF_SAMPLE_CALLCHAIN = 32,
	PERF_SAMPLE_ID = 64,
	PERF_SAMPLE_CPU = 128,
	PERF_SAMPLE_PERIOD = 256,
	PERF_SAMPLE_STREAM_ID = 512,
	PERF_SAMPLE_RAW = 1024,
	PERF_SAMPLE_BRANCH_STACK = 2048,
	PERF_SAMPLE_REGS_USER = 4096,
	PERF_SAMPLE_STACK_USER = 8192,
	PERF_SAMPLE_WEIGHT = 16384,
	PERF_SAMPLE_DATA_SRC = 32768,
	PERF_SAMPLE_IDENTIFIER = 65536,
	PERF_SAMPLE_TRANSACTION = 131072,
	PERF_SAMPLE_REGS_INTR = 262144,
	PERF_SAMPLE_PHYS_ADDR = 524288,
	PERF_SAMPLE_AUX = 1048576,
	PERF_SAMPLE_CGROUP = 2097152,
	PERF_SAMPLE_DATA_PAGE_SIZE = 4194304,
	PERF_SAMPLE_CODE_PAGE_SIZE = 8388608,
	PERF_SAMPLE_WEIGHT_STRUCT = 16777216,
	PERF_SAMPLE_MAX = 33554432,
};

enum perf_event_state {
	PERF_EVENT_STATE_DEAD = -4,
	PERF_EVENT_STATE_EXIT = -3,
	PERF_EVENT_STATE_ERROR = -2,
	PERF_EVENT_STATE_OFF = -1,
	PERF_EVENT_STATE_INACTIVE = 0,
	PERF_EVENT_STATE_ACTIVE = 1,
};

enum perf_event_task_context {
	perf_invalid_context = -1,
	perf_hw_context = 0,
	perf_sw_context = 1,
	perf_nr_task_contexts = 2,
};

enum perf_event_type {
	PERF_RECORD_MMAP = 1,
	PERF_RECORD_LOST = 2,
	PERF_RECORD_COMM = 3,
	PERF_RECORD_EXIT = 4,
	PERF_RECORD_THROTTLE = 5,
	PERF_RECORD_UNTHROTTLE = 6,
	PERF_RECORD_FORK = 7,
	PERF_RECORD_READ = 8,
	PERF_RECORD_SAMPLE = 9,
	PERF_RECORD_MMAP2 = 10,
	PERF_RECORD_AUX = 11,
	PERF_RECORD_ITRACE_START = 12,
	PERF_RECORD_LOST_SAMPLES = 13,
	PERF_RECORD_SWITCH = 14,
	PERF_RECORD_SWITCH_CPU_WIDE = 15,
	PERF_RECORD_NAMESPACES = 16,
	PERF_RECORD_KSYMBOL = 17,
	PERF_RECORD_BPF_EVENT = 18,
	PERF_RECORD_CGROUP = 19,
	PERF_RECORD_TEXT_POKE = 20,
	PERF_RECORD_AUX_OUTPUT_HW_ID = 21,
	PERF_RECORD_MAX = 22,
};

enum perf_event_x86_regs {
	PERF_REG_X86_AX = 0,
	PERF_REG_X86_BX = 1,
	PERF_REG_X86_CX = 2,
	PERF_REG_X86_DX = 3,
	PERF_REG_X86_SI = 4,
	PERF_REG_X86_DI = 5,
	PERF_REG_X86_BP = 6,
	PERF_REG_X86_SP = 7,
	PERF_REG_X86_IP = 8,
	PERF_REG_X86_FLAGS = 9,
	PERF_REG_X86_CS = 10,
	PERF_REG_X86_SS = 11,
	PERF_REG_X86_DS = 12,
	PERF_REG_X86_ES = 13,
	PERF_REG_X86_FS = 14,
	PERF_REG_X86_GS = 15,
	PERF_REG_X86_R8 = 16,
	PERF_REG_X86_R9 = 17,
	PERF_REG_X86_R10 = 18,
	PERF_REG_X86_R11 = 19,
	PERF_REG_X86_R12 = 20,
	PERF_REG_X86_R13 = 21,
	PERF_REG_X86_R14 = 22,
	PERF_REG_X86_R15 = 23,
	PERF_REG_X86_32_MAX = 16,
	PERF_REG_X86_64_MAX = 24,
	PERF_REG_X86_XMM0 = 32,
	PERF_REG_X86_XMM1 = 34,
	PERF_REG_X86_XMM2 = 36,
	PERF_REG_X86_XMM3 = 38,
	PERF_REG_X86_XMM4 = 40,
	PERF_REG_X86_XMM5 = 42,
	PERF_REG_X86_XMM6 = 44,
	PERF_REG_X86_XMM7 = 46,
	PERF_REG_X86_XMM8 = 48,
	PERF_REG_X86_XMM9 = 50,
	PERF_REG_X86_XMM10 = 52,
	PERF_REG_X86_XMM11 = 54,
	PERF_REG_X86_XMM12 = 56,
	PERF_REG_X86_XMM13 = 58,
	PERF_REG_X86_XMM14 = 60,
	PERF_REG_X86_XMM15 = 62,
	PERF_REG_X86_XMM_MAX = 64,
};

enum perf_hw_cache_id {
	PERF_COUNT_HW_CACHE_L1D = 0,
	PERF_COUNT_HW_CACHE_L1I = 1,
	PERF_COUNT_HW_CACHE_LL = 2,
	PERF_COUNT_HW_CACHE_DTLB = 3,
	PERF_COUNT_HW_CACHE_ITLB = 4,
	PERF_COUNT_HW_CACHE_BPU = 5,
	PERF_COUNT_HW_CACHE_NODE = 6,
	PERF_COUNT_HW_CACHE_MAX = 7,
};

enum perf_hw_cache_op_id {
	PERF_COUNT_HW_CACHE_OP_READ = 0,
	PERF_COUNT_HW_CACHE_OP_WRITE = 1,
	PERF_COUNT_HW_CACHE_OP_PREFETCH = 2,
	PERF_COUNT_HW_CACHE_OP_MAX = 3,
};

enum perf_hw_cache_op_result_id {
	PERF_COUNT_HW_CACHE_RESULT_ACCESS = 0,
	PERF_COUNT_HW_CACHE_RESULT_MISS = 1,
	PERF_COUNT_HW_CACHE_RESULT_MAX = 2,
};

enum perf_hw_id {
	PERF_COUNT_HW_CPU_CYCLES = 0,
	PERF_COUNT_HW_INSTRUCTIONS = 1,
	PERF_COUNT_HW_CACHE_REFERENCES = 2,
	PERF_COUNT_HW_CACHE_MISSES = 3,
	PERF_COUNT_HW_BRANCH_INSTRUCTIONS = 4,
	PERF_COUNT_HW_BRANCH_MISSES = 5,
	PERF_COUNT_HW_BUS_CYCLES = 6,
	PERF_COUNT_HW_STALLED_CYCLES_FRONTEND = 7,
	PERF_COUNT_HW_STALLED_CYCLES_BACKEND = 8,
	PERF_COUNT_HW_REF_CPU_CYCLES = 9,
	PERF_COUNT_HW_MAX = 10,
};

enum perf_msr_id {
	PERF_MSR_TSC = 0,
	PERF_MSR_APERF = 1,
	PERF_MSR_MPERF = 2,
	PERF_MSR_PPERF = 3,
	PERF_MSR_SMI = 4,
	PERF_MSR_PTSC = 5,
	PERF_MSR_IRPERF = 6,
	PERF_MSR_THERM = 7,
	PERF_MSR_EVENT_MAX = 8,
};

enum perf_pmu_scope {
	PERF_PMU_SCOPE_NONE = 0,
	PERF_PMU_SCOPE_CORE = 1,
	PERF_PMU_SCOPE_DIE = 2,
	PERF_PMU_SCOPE_CLUSTER = 3,
	PERF_PMU_SCOPE_PKG = 4,
	PERF_PMU_SCOPE_SYS_WIDE = 5,
	PERF_PMU_MAX_SCOPE = 6,
};

enum perf_probe_config {
	PERF_PROBE_CONFIG_IS_RETPROBE = 1,
	PERF_UPROBE_REF_CTR_OFFSET_BITS = 32,
	PERF_UPROBE_REF_CTR_OFFSET_SHIFT = 32,
};

enum perf_rapl_pkg_events {
	PERF_RAPL_PP0 = 0,
	PERF_RAPL_PKG = 1,
	PERF_RAPL_RAM = 2,
	PERF_RAPL_PP1 = 3,
	PERF_RAPL_PSYS = 4,
	PERF_RAPL_PKG_EVENTS_MAX = 5,
	NR_RAPL_PKG_DOMAINS = 5,
};

enum perf_record_ksymbol_type {
	PERF_RECORD_KSYMBOL_TYPE_UNKNOWN = 0,
	PERF_RECORD_KSYMBOL_TYPE_BPF = 1,
	PERF_RECORD_KSYMBOL_TYPE_OOL = 2,
	PERF_RECORD_KSYMBOL_TYPE_MAX = 3,
};

enum perf_sample_regs_abi {
	PERF_SAMPLE_REGS_ABI_NONE = 0,
	PERF_SAMPLE_REGS_ABI_32 = 1,
	PERF_SAMPLE_REGS_ABI_64 = 2,
};

enum perf_snb_uncore_imc_freerunning_types {
	SNB_PCI_UNCORE_IMC_DATA_READS = 0,
	SNB_PCI_UNCORE_IMC_DATA_WRITES = 1,
	SNB_PCI_UNCORE_IMC_GT_REQUESTS = 2,
	SNB_PCI_UNCORE_IMC_IA_REQUESTS = 3,
	SNB_PCI_UNCORE_IMC_IO_REQUESTS = 4,
	SNB_PCI_UNCORE_IMC_FREERUNNING_TYPE_MAX = 5,
};

enum perf_sw_ids {
	PERF_COUNT_SW_CPU_CLOCK = 0,
	PERF_COUNT_SW_TASK_CLOCK = 1,
	PERF_COUNT_SW_PAGE_FAULTS = 2,
	PERF_COUNT_SW_CONTEXT_SWITCHES = 3,
	PERF_COUNT_SW_CPU_MIGRATIONS = 4,
	PERF_COUNT_SW_PAGE_FAULTS_MIN = 5,
	PERF_COUNT_SW_PAGE_FAULTS_MAJ = 6,
	PERF_COUNT_SW_ALIGNMENT_FAULTS = 7,
	PERF_COUNT_SW_EMULATION_FAULTS = 8,
	PERF_COUNT_SW_DUMMY = 9,
	PERF_COUNT_SW_BPF_OUTPUT = 10,
	PERF_COUNT_SW_CGROUP_SWITCHES = 11,
	PERF_COUNT_SW_MAX = 12,
};

enum perf_tgl_uncore_imc_freerunning_types {
	TGL_MMIO_UNCORE_IMC_DATA_TOTAL = 0,
	TGL_MMIO_UNCORE_IMC_DATA_READ = 1,
	TGL_MMIO_UNCORE_IMC_DATA_WRITE = 2,
	TGL_MMIO_UNCORE_IMC_FREERUNNING_TYPE_MAX = 3,
};

enum perf_type_id {
	PERF_TYPE_HARDWARE = 0,
	PERF_TYPE_SOFTWARE = 1,
	PERF_TYPE_TRACEPOINT = 2,
	PERF_TYPE_HW_CACHE = 3,
	PERF_TYPE_RAW = 4,
	PERF_TYPE_BREAKPOINT = 5,
	PERF_TYPE_MAX = 6,
};

enum perf_uncore_icx_iio_freerunning_type_id {
	ICX_IIO_MSR_IOCLK = 0,
	ICX_IIO_MSR_BW_IN = 1,
	ICX_IIO_FREERUNNING_TYPE_MAX = 2,
};

enum perf_uncore_icx_imc_freerunning_type_id {
	ICX_IMC_DCLK = 0,
	ICX_IMC_DDR = 1,
	ICX_IMC_DDRT = 2,
	ICX_IMC_FREERUNNING_TYPE_MAX = 3,
};

enum perf_uncore_iio_freerunning_type_id {
	SKX_IIO_MSR_IOCLK = 0,
	SKX_IIO_MSR_BW = 1,
	SKX_IIO_MSR_UTIL = 2,
	SKX_IIO_FREERUNNING_TYPE_MAX = 3,
};

enum perf_uncore_snr_iio_freerunning_type_id {
	SNR_IIO_MSR_IOCLK = 0,
	SNR_IIO_MSR_BW_IN = 1,
	SNR_IIO_FREERUNNING_TYPE_MAX = 2,
};

enum perf_uncore_snr_imc_freerunning_type_id {
	SNR_IMC_DCLK = 0,
	SNR_IMC_DDR = 1,
	SNR_IMC_FREERUNNING_TYPE_MAX = 2,
};

enum perf_uncore_spr_iio_freerunning_type_id {
	SPR_IIO_MSR_IOCLK = 0,
	SPR_IIO_MSR_BW_IN = 1,
	SPR_IIO_MSR_BW_OUT = 2,
	SPR_IIO_FREERUNNING_TYPE_MAX = 3,
};

enum perf_uncore_spr_imc_freerunning_type_id {
	SPR_IMC_DCLK = 0,
	SPR_IMC_PQ_CYCLES = 1,
	SPR_IMC_FREERUNNING_TYPE_MAX = 2,
};

enum pg_level {
	PG_LEVEL_NONE = 0,
	PG_LEVEL_4K = 1,
	PG_LEVEL_2M = 2,
	PG_LEVEL_1G = 3,
	PG_LEVEL_512G = 4,
	PG_LEVEL_256T = 5,
	PG_LEVEL_NUM = 6,
};

enum pgdat_flags {
	PGDAT_DIRTY = 0,
	PGDAT_WRITEBACK = 1,
	PGDAT_RECLAIM_LOCKED = 2,
};

enum pgt_entry {
	NORMAL_PMD = 0,
	HPAGE_PMD = 1,
	NORMAL_PUD = 2,
	HPAGE_PUD = 3,
};

enum phy {
	phy_100a = 992,
	phy_100c = 55575208,
	phy_82555_tx = 22020776,
	phy_nsc_tx = 1543512064,
	phy_82562_et = 53478056,
	phy_82562_em = 52429480,
	phy_82562_ek = 51380904,
	phy_82562_eh = 24117928,
	phy_82552_v = 3496017997,
	phy_unknown = 4294967295,
};

enum phy___2 {
	PHY_NONE = -1,
	PHY_A = 0,
	PHY_B = 1,
	PHY_C = 2,
	PHY_D = 3,
	PHY_E = 4,
	PHY_F = 5,
	PHY_G = 6,
	PHY_H = 7,
	PHY_I = 8,
	I915_MAX_PHYS = 9,
};

enum phy_fia {
	FIA1 = 0,
	FIA2 = 1,
	FIA3 = 2,
};

enum phy_media {
	PHY_MEDIA_DEFAULT = 0,
	PHY_MEDIA_SR = 1,
	PHY_MEDIA_DAC = 2,
};

enum phy_mode {
	PHY_MODE_INVALID = 0,
	PHY_MODE_USB_HOST = 1,
	PHY_MODE_USB_HOST_LS = 2,
	PHY_MODE_USB_HOST_FS = 3,
	PHY_MODE_USB_HOST_HS = 4,
	PHY_MODE_USB_HOST_SS = 5,
	PHY_MODE_USB_DEVICE = 6,
	PHY_MODE_USB_DEVICE_LS = 7,
	PHY_MODE_USB_DEVICE_FS = 8,
	PHY_MODE_USB_DEVICE_HS = 9,
	PHY_MODE_USB_DEVICE_SS = 10,
	PHY_MODE_USB_OTG = 11,
	PHY_MODE_UFS_HS_A = 12,
	PHY_MODE_UFS_HS_B = 13,
	PHY_MODE_PCIE = 14,
	PHY_MODE_ETHERNET = 15,
	PHY_MODE_MIPI_DPHY = 16,
	PHY_MODE_SATA = 17,
	PHY_MODE_LVDS = 18,
	PHY_MODE_DP = 19,
};

enum phy_state {
	PHY_DOWN = 0,
	PHY_READY = 1,
	PHY_HALTED = 2,
	PHY_ERROR = 3,
	PHY_UP = 4,
	PHY_RUNNING = 5,
	PHY_NOLINK = 6,
	PHY_CABLETEST = 7,
};

enum phy_state_work {
	PHY_STATE_WORK_NONE = 0,
	PHY_STATE_WORK_ANEG = 1,
	PHY_STATE_WORK_SUSPEND = 2,
};

enum phy_tunable_id {
	ETHTOOL_PHY_ID_UNSPEC = 0,
	ETHTOOL_PHY_DOWNSHIFT = 1,
	ETHTOOL_PHY_FAST_LINK_DOWN = 2,
	ETHTOOL_PHY_EDPD = 3,
	__ETHTOOL_PHY_TUNABLE_COUNT = 4,
};

enum phy_upstream {
	PHY_UPSTREAM_MAC = 0,
	PHY_UPSTREAM_PHY = 1,
};

enum pid_type {
	PIDTYPE_PID = 0,
	PIDTYPE_TGID = 1,
	PIDTYPE_PGID = 2,
	PIDTYPE_SID = 3,
	PIDTYPE_MAX = 4,
};

enum pidcg_event {
	PIDCG_MAX = 0,
	PIDCG_FORKFAIL = 1,
	NR_PIDCG_EVENTS = 2,
};

enum piix_controller_ids {
	piix_pata_mwdma = 0,
	piix_pata_33 = 1,
	ich_pata_33 = 2,
	ich_pata_66 = 3,
	ich_pata_100 = 4,
	ich_pata_100_nomwdma1 = 5,
	ich5_sata = 6,
	ich6_sata = 7,
	ich6m_sata = 8,
	ich8_sata = 9,
	ich8_2port_sata = 10,
	ich8m_apple_sata = 11,
	tolapai_sata = 12,
	piix_pata_vmw = 13,
	ich8_sata_snb = 14,
	ich8_2port_sata_snb = 15,
	ich8_2port_sata_byt = 16,
};

enum pinctrl_map_type {
	PIN_MAP_TYPE_INVALID = 0,
	PIN_MAP_TYPE_DUMMY_STATE = 1,
	PIN_MAP_TYPE_MUX_GROUP = 2,
	PIN_MAP_TYPE_CONFIGS_PIN = 3,
	PIN_MAP_TYPE_CONFIGS_GROUP = 4,
};

enum pipe {
	INVALID_PIPE = -1,
	PIPE_A = 0,
	PIPE_B = 1,
	PIPE_C = 2,
	PIPE_D = 3,
	_PIPE_EDP = 4,
	I915_MAX_PIPES = 4,
};

enum pkcs7_actions {
	ACT_pkcs7_check_content_type = 0,
	ACT_pkcs7_extract_cert = 1,
	ACT_pkcs7_note_OID = 2,
	ACT_pkcs7_note_certificate_list = 3,
	ACT_pkcs7_note_content = 4,
	ACT_pkcs7_note_data = 5,
	ACT_pkcs7_note_signed_info = 6,
	ACT_pkcs7_note_signeddata_version = 7,
	ACT_pkcs7_note_signerinfo_version = 8,
	ACT_pkcs7_sig_note_authenticated_attr = 9,
	ACT_pkcs7_sig_note_digest_algo = 10,
	ACT_pkcs7_sig_note_issuer = 11,
	ACT_pkcs7_sig_note_pkey_algo = 12,
	ACT_pkcs7_sig_note_serial = 13,
	ACT_pkcs7_sig_note_set_of_authattrs = 14,
	ACT_pkcs7_sig_note_signature = 15,
	ACT_pkcs7_sig_note_skid = 16,
	NR__pkcs7_actions = 17,
};

enum pkt_hash_types {
	PKT_HASH_TYPE_NONE = 0,
	PKT_HASH_TYPE_L2 = 1,
	PKT_HASH_TYPE_L3 = 2,
	PKT_HASH_TYPE_L4 = 3,
};

enum plane_id {
	PLANE_1 = 0,
	PLANE_2 = 1,
	PLANE_3 = 2,
	PLANE_4 = 3,
	PLANE_5 = 4,
	PLANE_6 = 5,
	PLANE_7 = 6,
	PLANE_CURSOR = 7,
	I915_MAX_PLANES = 8,
	PLANE_PRIMARY = 0,
	PLANE_SPRITE0 = 1,
	PLANE_SPRITE1 = 2,
};

enum pm_qos_flags_status {
	PM_QOS_FLAGS_UNDEFINED = -1,
	PM_QOS_FLAGS_NONE = 0,
	PM_QOS_FLAGS_SOME = 1,
	PM_QOS_FLAGS_ALL = 2,
};

enum pm_qos_req_action {
	PM_QOS_ADD_REQ = 0,
	PM_QOS_UPDATE_REQ = 1,
	PM_QOS_REMOVE_REQ = 2,
};

enum pm_qos_type {
	PM_QOS_UNITIALIZED = 0,
	PM_QOS_MAX = 1,
	PM_QOS_MIN = 2,
};

enum pmc_type {
	KVM_PMC_GP = 0,
	KVM_PMC_FIXED = 1,
};

enum pnfs_iomode {
	IOMODE_READ = 1,
	IOMODE_RW = 2,
	IOMODE_ANY = 3,
};

enum pnfs_try_status {
	PNFS_ATTEMPTED = 0,
	PNFS_NOT_ATTEMPTED = 1,
	PNFS_TRY_AGAIN = 2,
};

enum poll_time_type {
	PT_TIMEVAL = 0,
	PT_OLD_TIMEVAL = 1,
	PT_TIMESPEC = 2,
	PT_OLD_TIMESPEC = 3,
};

enum pool_workqueue_stats {
	PWQ_STAT_STARTED = 0,
	PWQ_STAT_COMPLETED = 1,
	PWQ_STAT_CPU_TIME = 2,
	PWQ_STAT_CPU_INTENSIVE = 3,
	PWQ_STAT_CM_WAKEUP = 4,
	PWQ_STAT_REPATRIATED = 5,
	PWQ_STAT_MAYDAY = 6,
	PWQ_STAT_RESCUED = 7,
	PWQ_NR_STATS = 8,
};

enum port {
	PORT_NONE = -1,
	PORT_A = 0,
	PORT_B = 1,
	PORT_C = 2,
	PORT_D = 3,
	PORT_E = 4,
	PORT_F = 5,
	PORT_G = 6,
	PORT_H = 7,
	PORT_I = 8,
	PORT_TC1 = 3,
	PORT_TC2 = 4,
	PORT_TC3 = 5,
	PORT_TC4 = 6,
	PORT_TC5 = 7,
	PORT_TC6 = 8,
	PORT_D_XELPD = 7,
	PORT_E_XELPD = 8,
	I915_MAX_PORTS = 9,
};

enum port___2 {
	software_reset = 0,
	selftest = 1,
	selective_reset = 2,
};

enum positive_aop_returns {
	AOP_WRITEPAGE_ACTIVATE = 524288,
	AOP_TRUNCATED_PAGE = 524289,
};

enum posix_timer_state {
	POSIX_TIMER_DISARMED = 0,
	POSIX_TIMER_ARMED = 1,
	POSIX_TIMER_REQUEUE_PENDING = 2,
};

enum power_supply_charge_behaviour {
	POWER_SUPPLY_CHARGE_BEHAVIOUR_AUTO = 0,
	POWER_SUPPLY_CHARGE_BEHAVIOUR_INHIBIT_CHARGE = 1,
	POWER_SUPPLY_CHARGE_BEHAVIOUR_FORCE_DISCHARGE = 2,
};

enum power_supply_charge_type {
	POWER_SUPPLY_CHARGE_TYPE_UNKNOWN = 0,
	POWER_SUPPLY_CHARGE_TYPE_NONE = 1,
	POWER_SUPPLY_CHARGE_TYPE_TRICKLE = 2,
	POWER_SUPPLY_CHARGE_TYPE_FAST = 3,
	POWER_SUPPLY_CHARGE_TYPE_STANDARD = 4,
	POWER_SUPPLY_CHARGE_TYPE_ADAPTIVE = 5,
	POWER_SUPPLY_CHARGE_TYPE_CUSTOM = 6,
	POWER_SUPPLY_CHARGE_TYPE_LONGLIFE = 7,
	POWER_SUPPLY_CHARGE_TYPE_BYPASS = 8,
};

enum power_supply_notifier_events {
	PSY_EVENT_PROP_CHANGED = 0,
};

enum power_supply_property {
	POWER_SUPPLY_PROP_STATUS = 0,
	POWER_SUPPLY_PROP_CHARGE_TYPE = 1,
	POWER_SUPPLY_PROP_CHARGE_TYPES = 2,
	POWER_SUPPLY_PROP_HEALTH = 3,
	POWER_SUPPLY_PROP_PRESENT = 4,
	POWER_SUPPLY_PROP_ONLINE = 5,
	POWER_SUPPLY_PROP_AUTHENTIC = 6,
	POWER_SUPPLY_PROP_TECHNOLOGY = 7,
	POWER_SUPPLY_PROP_CYCLE_COUNT = 8,
	POWER_SUPPLY_PROP_VOLTAGE_MAX = 9,
	POWER_SUPPLY_PROP_VOLTAGE_MIN = 10,
	POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN = 11,
	POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN = 12,
	POWER_SUPPLY_PROP_VOLTAGE_NOW = 13,
	POWER_SUPPLY_PROP_VOLTAGE_AVG = 14,
	POWER_SUPPLY_PROP_VOLTAGE_OCV = 15,
	POWER_SUPPLY_PROP_VOLTAGE_BOOT = 16,
	POWER_SUPPLY_PROP_CURRENT_MAX = 17,
	POWER_SUPPLY_PROP_CURRENT_NOW = 18,
	POWER_SUPPLY_PROP_CURRENT_AVG = 19,
	POWER_SUPPLY_PROP_CURRENT_BOOT = 20,
	POWER_SUPPLY_PROP_POWER_NOW = 21,
	POWER_SUPPLY_PROP_POWER_AVG = 22,
	POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN = 23,
	POWER_SUPPLY_PROP_CHARGE_EMPTY_DESIGN = 24,
	POWER_SUPPLY_PROP_CHARGE_FULL = 25,
	POWER_SUPPLY_PROP_CHARGE_EMPTY = 26,
	POWER_SUPPLY_PROP_CHARGE_NOW = 27,
	POWER_SUPPLY_PROP_CHARGE_AVG = 28,
	POWER_SUPPLY_PROP_CHARGE_COUNTER = 29,
	POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT = 30,
	POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX = 31,
	POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE = 32,
	POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX = 33,
	POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT = 34,
	POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT_MAX = 35,
	POWER_SUPPLY_PROP_CHARGE_CONTROL_START_THRESHOLD = 36,
	POWER_SUPPLY_PROP_CHARGE_CONTROL_END_THRESHOLD = 37,
	POWER_SUPPLY_PROP_CHARGE_BEHAVIOUR = 38,
	POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT = 39,
	POWER_SUPPLY_PROP_INPUT_VOLTAGE_LIMIT = 40,
	POWER_SUPPLY_PROP_INPUT_POWER_LIMIT = 41,
	POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN = 42,
	POWER_SUPPLY_PROP_ENERGY_EMPTY_DESIGN = 43,
	POWER_SUPPLY_PROP_ENERGY_FULL = 44,
	POWER_SUPPLY_PROP_ENERGY_EMPTY = 45,
	POWER_SUPPLY_PROP_ENERGY_NOW = 46,
	POWER_SUPPLY_PROP_ENERGY_AVG = 47,
	POWER_SUPPLY_PROP_CAPACITY = 48,
	POWER_SUPPLY_PROP_CAPACITY_ALERT_MIN = 49,
	POWER_SUPPLY_PROP_CAPACITY_ALERT_MAX = 50,
	POWER_SUPPLY_PROP_CAPACITY_ERROR_MARGIN = 51,
	POWER_SUPPLY_PROP_CAPACITY_LEVEL = 52,
	POWER_SUPPLY_PROP_TEMP = 53,
	POWER_SUPPLY_PROP_TEMP_MAX = 54,
	POWER_SUPPLY_PROP_TEMP_MIN = 55,
	POWER_SUPPLY_PROP_TEMP_ALERT_MIN = 56,
	POWER_SUPPLY_PROP_TEMP_ALERT_MAX = 57,
	POWER_SUPPLY_PROP_TEMP_AMBIENT = 58,
	POWER_SUPPLY_PROP_TEMP_AMBIENT_ALERT_MIN = 59,
	POWER_SUPPLY_PROP_TEMP_AMBIENT_ALERT_MAX = 60,
	POWER_SUPPLY_PROP_TIME_TO_EMPTY_NOW = 61,
	POWER_SUPPLY_PROP_TIME_TO_EMPTY_AVG = 62,
	POWER_SUPPLY_PROP_TIME_TO_FULL_NOW = 63,
	POWER_SUPPLY_PROP_TIME_TO_FULL_AVG = 64,
	POWER_SUPPLY_PROP_TYPE = 65,
	POWER_SUPPLY_PROP_USB_TYPE = 66,
	POWER_SUPPLY_PROP_SCOPE = 67,
	POWER_SUPPLY_PROP_PRECHARGE_CURRENT = 68,
	POWER_SUPPLY_PROP_CHARGE_TERM_CURRENT = 69,
	POWER_SUPPLY_PROP_CALIBRATE = 70,
	POWER_SUPPLY_PROP_MANUFACTURE_YEAR = 71,
	POWER_SUPPLY_PROP_MANUFACTURE_MONTH = 72,
	POWER_SUPPLY_PROP_MANUFACTURE_DAY = 73,
	POWER_SUPPLY_PROP_MODEL_NAME = 74,
	POWER_SUPPLY_PROP_MANUFACTURER = 75,
	POWER_SUPPLY_PROP_SERIAL_NUMBER = 76,
};

enum power_supply_type {
	POWER_SUPPLY_TYPE_UNKNOWN = 0,
	POWER_SUPPLY_TYPE_BATTERY = 1,
	POWER_SUPPLY_TYPE_UPS = 2,
	POWER_SUPPLY_TYPE_MAINS = 3,
	POWER_SUPPLY_TYPE_USB = 4,
	POWER_SUPPLY_TYPE_USB_DCP = 5,
	POWER_SUPPLY_TYPE_USB_CDP = 6,
	POWER_SUPPLY_TYPE_USB_ACA = 7,
	POWER_SUPPLY_TYPE_USB_TYPE_C = 8,
	POWER_SUPPLY_TYPE_USB_PD = 9,
	POWER_SUPPLY_TYPE_USB_PD_DRP = 10,
	POWER_SUPPLY_TYPE_APPLE_BRICK_ID = 11,
	POWER_SUPPLY_TYPE_WIRELESS = 12,
};

enum power_supply_usb_type {
	POWER_SUPPLY_USB_TYPE_UNKNOWN = 0,
	POWER_SUPPLY_USB_TYPE_SDP = 1,
	POWER_SUPPLY_USB_TYPE_DCP = 2,
	POWER_SUPPLY_USB_TYPE_CDP = 3,
	POWER_SUPPLY_USB_TYPE_ACA = 4,
	POWER_SUPPLY_USB_TYPE_C = 5,
	POWER_SUPPLY_USB_TYPE_PD = 6,
	POWER_SUPPLY_USB_TYPE_PD_DRP = 7,
	POWER_SUPPLY_USB_TYPE_PD_PPS = 8,
	POWER_SUPPLY_USB_TYPE_APPLE_BRICK_ID = 9,
};

enum pr_status {
	PR_STS_SUCCESS = 0,
	PR_STS_IOERR = 2,
	PR_STS_RESERVATION_CONFLICT = 24,
	PR_STS_RETRY_PATH_FAILURE = 917504,
	PR_STS_PATH_FAST_FAILED = 983040,
	PR_STS_PATH_FAILED = 65536,
};

enum pr_type {
	PR_WRITE_EXCLUSIVE = 1,
	PR_EXCLUSIVE_ACCESS = 2,
	PR_WRITE_EXCLUSIVE_REG_ONLY = 3,
	PR_EXCLUSIVE_ACCESS_REG_ONLY = 4,
	PR_WRITE_EXCLUSIVE_ALL_REGS = 5,
	PR_EXCLUSIVE_ACCESS_ALL_REGS = 6,
};

enum prep_dispatch {
	PREP_DISPATCH_OK = 0,
	PREP_DISPATCH_NO_TAG = 1,
	PREP_DISPATCH_NO_BUDGET = 2,
};

enum print_line_t {
	TRACE_TYPE_PARTIAL_LINE = 0,
	TRACE_TYPE_HANDLED = 1,
	TRACE_TYPE_UNHANDLED = 2,
	TRACE_TYPE_NO_CONSUME = 3,
};

enum printk_info_flags {
	LOG_FORCE_CON = 1,
	LOG_NEWLINE = 2,
	LOG_CONT = 8,
};

enum prio_policy {
	POLICY_NO_CHANGE = 0,
	POLICY_PROMOTE_TO_RT = 1,
	POLICY_RESTRICT_TO_BE = 2,
	POLICY_ALL_TO_IDLE = 3,
	POLICY_NONE_TO_RT = 4,
};

enum priv_stack_mode {
	PRIV_STACK_UNKNOWN = 0,
	NO_PRIV_STACK = 1,
	PRIV_STACK_ADAPTIVE = 2,
};

enum probe_print_type {
	PROBE_PRINT_NORMAL = 0,
	PROBE_PRINT_RETURN = 1,
	PROBE_PRINT_EVENT = 2,
};

enum probe_type {
	PROBE_DEFAULT_STRATEGY = 0,
	PROBE_PREFER_ASYNCHRONOUS = 1,
	PROBE_FORCE_SYNCHRONOUS = 2,
};

enum proc_cn_event {
	PROC_EVENT_NONE = 0,
	PROC_EVENT_FORK = 1,
	PROC_EVENT_EXEC = 2,
	PROC_EVENT_UID = 4,
	PROC_EVENT_GID = 64,
	PROC_EVENT_SID = 128,
	PROC_EVENT_PTRACE = 256,
	PROC_EVENT_COMM = 512,
	PROC_EVENT_NONZERO_EXIT = 536870912,
	PROC_EVENT_COREDUMP = 1073741824,
	PROC_EVENT_EXIT = 2147483648,
};

enum proc_cn_mcast_op {
	PROC_CN_MCAST_LISTEN = 1,
	PROC_CN_MCAST_IGNORE = 2,
};

enum proc_hidepid {
	HIDEPID_OFF = 0,
	HIDEPID_NO_ACCESS = 1,
	HIDEPID_INVISIBLE = 2,
	HIDEPID_NOT_PTRACEABLE = 4,
};

enum proc_mem_force {
	PROC_MEM_FORCE_ALWAYS = 0,
	PROC_MEM_FORCE_PTRACE = 1,
	PROC_MEM_FORCE_NEVER = 2,
};

enum proc_param {
	Opt_gid___8 = 0,
	Opt_hidepid = 1,
	Opt_subset = 2,
};

enum proc_pidonly {
	PROC_PIDONLY_OFF = 0,
	PROC_PIDONLY_ON = 1,
};

enum procmap_query_flags {
	PROCMAP_QUERY_VMA_READABLE = 1,
	PROCMAP_QUERY_VMA_WRITABLE = 2,
	PROCMAP_QUERY_VMA_EXECUTABLE = 4,
	PROCMAP_QUERY_VMA_SHARED = 8,
	PROCMAP_QUERY_COVERING_OR_NEXT_VMA = 16,
	PROCMAP_QUERY_FILE_BACKED_VMA = 32,
};

enum protection_domain_mode {
	PD_MODE_V1 = 1,
	PD_MODE_V2 = 2,
};

enum prs_errcode {
	PERR_NONE = 0,
	PERR_INVCPUS = 1,
	PERR_INVPARENT = 2,
	PERR_NOTPART = 3,
	PERR_NOTEXCL = 4,
	PERR_NOCPUS = 5,
	PERR_HOTPLUG = 6,
	PERR_CPUSEMPTY = 7,
	PERR_HKEEPING = 8,
	PERR_ACCESS = 9,
};

enum ps2_disposition {
	PS2_PROCESS = 0,
	PS2_IGNORE = 1,
	PS2_ERROR = 2,
};

enum psmouse_scale {
	PSMOUSE_SCALE11 = 0,
	PSMOUSE_SCALE21 = 1,
};

enum psmouse_state {
	PSMOUSE_IGNORE = 0,
	PSMOUSE_INITIALIZING = 1,
	PSMOUSE_RESYNCING = 2,
	PSMOUSE_CMD_MODE = 3,
	PSMOUSE_ACTIVATED = 4,
};

enum psmouse_type {
	PSMOUSE_NONE = 0,
	PSMOUSE_PS2 = 1,
	PSMOUSE_PS2PP = 2,
	PSMOUSE_THINKPS = 3,
	PSMOUSE_GENPS = 4,
	PSMOUSE_IMPS = 5,
	PSMOUSE_IMEX = 6,
	PSMOUSE_SYNAPTICS = 7,
	PSMOUSE_ALPS = 8,
	PSMOUSE_LIFEBOOK = 9,
	PSMOUSE_TRACKPOINT = 10,
	PSMOUSE_TOUCHKIT_PS2 = 11,
	PSMOUSE_CORTRON = 12,
	PSMOUSE_HGPK = 13,
	PSMOUSE_ELANTECH = 14,
	PSMOUSE_FSP = 15,
	PSMOUSE_SYNAPTICS_RELATIVE = 16,
	PSMOUSE_CYPRESS = 17,
	PSMOUSE_FOCALTECH = 18,
	PSMOUSE_VMMOUSE = 19,
	PSMOUSE_BYD = 20,
	PSMOUSE_SYNAPTICS_SMBUS = 21,
	PSMOUSE_ELANTECH_SMBUS = 22,
	PSMOUSE_AUTO = 23,
};

enum pt_capabilities {
	PT_CAP_max_subleaf = 0,
	PT_CAP_cr3_filtering = 1,
	PT_CAP_psb_cyc = 2,
	PT_CAP_ip_filtering = 3,
	PT_CAP_mtc = 4,
	PT_CAP_ptwrite = 5,
	PT_CAP_power_event_trace = 6,
	PT_CAP_event_trace = 7,
	PT_CAP_tnt_disable = 8,
	PT_CAP_topa_output = 9,
	PT_CAP_topa_multiple_entries = 10,
	PT_CAP_single_range_output = 11,
	PT_CAP_output_subsys = 12,
	PT_CAP_payloads_lip = 13,
	PT_CAP_num_address_ranges = 14,
	PT_CAP_mtc_periods = 15,
	PT_CAP_cycle_thresholds = 16,
	PT_CAP_psb_periods = 17,
};

enum pti_clone_level {
	PTI_CLONE_PMD = 0,
	PTI_CLONE_PTE = 1,
};

enum pti_mode {
	PTI_AUTO = 0,
	PTI_FORCE_OFF = 1,
	PTI_FORCE_ON = 2,
};

enum ptp_clock_events {
	PTP_CLOCK_ALARM = 0,
	PTP_CLOCK_EXTTS = 1,
	PTP_CLOCK_EXTOFF = 2,
	PTP_CLOCK_PPS = 3,
	PTP_CLOCK_PPSUSR = 4,
};

enum ptp_pin_function {
	PTP_PF_NONE = 0,
	PTP_PF_EXTTS = 1,
	PTP_PF_PEROUT = 2,
	PTP_PF_PHYSYNC = 3,
};

enum pwm_polarity {
	PWM_POLARITY_NORMAL = 0,
	PWM_POLARITY_INVERSED = 1,
};

enum pxp_status {
	PXP_STATUS_SUCCESS = 0,
	PXP_STATUS_ERROR_API_VERSION = 4098,
	PXP_STATUS_NOT_READY = 4110,
	PXP_STATUS_PLATFCONFIG_KF1_NOVERIF = 4122,
	PXP_STATUS_PLATFCONFIG_KF1_BAD = 4127,
	PXP_STATUS_OP_NOT_PERMITTED = 16403,
};

enum qdisc_class_ops_flags {
	QDISC_CLASS_OPS_DOIT_UNLOCKED = 1,
};

enum qdisc_state2_t {
	__QDISC_STATE2_RUNNING = 0,
};

enum qdisc_state_t {
	__QDISC_STATE_SCHED = 0,
	__QDISC_STATE_DEACTIVATED = 1,
	__QDISC_STATE_MISSED = 2,
	__QDISC_STATE_DRAINING = 3,
};

enum queue_stop_reason {
	IEEE80211_QUEUE_STOP_REASON_DRIVER = 0,
	IEEE80211_QUEUE_STOP_REASON_PS = 1,
	IEEE80211_QUEUE_STOP_REASON_CSA = 2,
	IEEE80211_QUEUE_STOP_REASON_AGGREGATION = 3,
	IEEE80211_QUEUE_STOP_REASON_SUSPEND = 4,
	IEEE80211_QUEUE_STOP_REASON_SKB_ADD = 5,
	IEEE80211_QUEUE_STOP_REASON_OFFCHANNEL = 6,
	IEEE80211_QUEUE_STOP_REASON_FLUSH = 7,
	IEEE80211_QUEUE_STOP_REASON_TDLS_TEARDOWN = 8,
	IEEE80211_QUEUE_STOP_REASON_RESERVE_TID = 9,
	IEEE80211_QUEUE_STOP_REASON_IFTYPE_CHANGE = 10,
	IEEE80211_QUEUE_STOP_REASONS = 11,
};

enum quota_type {
	USRQUOTA = 0,
	GRPQUOTA = 1,
	PRJQUOTA = 2,
};

enum ramfs_param {
	Opt_mode___6 = 0,
};

enum rapl_unit_quirk {
	RAPL_UNIT_QUIRK_NONE = 0,
	RAPL_UNIT_QUIRK_INTEL_HSW = 1,
	RAPL_UNIT_QUIRK_INTEL_SPR = 2,
};

enum rate_control_capabilities {
	RATE_CTRL_CAPA_VHT_EXT_NSS_BW = 1,
	RATE_CTRL_CAPA_AMPDU_TRIGGER = 2,
};

enum rate_info_bw {
	RATE_INFO_BW_20 = 0,
	RATE_INFO_BW_5 = 1,
	RATE_INFO_BW_10 = 2,
	RATE_INFO_BW_40 = 3,
	RATE_INFO_BW_80 = 4,
	RATE_INFO_BW_160 = 5,
	RATE_INFO_BW_HE_RU = 6,
	RATE_INFO_BW_320 = 7,
	RATE_INFO_BW_EHT_RU = 8,
	RATE_INFO_BW_1 = 9,
	RATE_INFO_BW_2 = 10,
	RATE_INFO_BW_4 = 11,
	RATE_INFO_BW_8 = 12,
	RATE_INFO_BW_16 = 13,
};

enum rate_info_flags {
	RATE_INFO_FLAGS_MCS = 1,
	RATE_INFO_FLAGS_VHT_MCS = 2,
	RATE_INFO_FLAGS_SHORT_GI = 4,
	RATE_INFO_FLAGS_DMG = 8,
	RATE_INFO_FLAGS_HE_MCS = 16,
	RATE_INFO_FLAGS_EDMG = 32,
	RATE_INFO_FLAGS_EXTENDED_SC_DMG = 64,
	RATE_INFO_FLAGS_EHT_MCS = 128,
	RATE_INFO_FLAGS_S1G_MCS = 256,
};

enum rc_driver_type {
	RC_DRIVER_SCANCODE = 0,
	RC_DRIVER_IR_RAW = 1,
	RC_DRIVER_IR_RAW_TX = 2,
};

enum rc_proto {
	RC_PROTO_UNKNOWN = 0,
	RC_PROTO_OTHER = 1,
	RC_PROTO_RC5 = 2,
	RC_PROTO_RC5X_20 = 3,
	RC_PROTO_RC5_SZ = 4,
	RC_PROTO_JVC = 5,
	RC_PROTO_SONY12 = 6,
	RC_PROTO_SONY15 = 7,
	RC_PROTO_SONY20 = 8,
	RC_PROTO_NEC = 9,
	RC_PROTO_NECX = 10,
	RC_PROTO_NEC32 = 11,
	RC_PROTO_SANYO = 12,
	RC_PROTO_MCIR2_KBD = 13,
	RC_PROTO_MCIR2_MSE = 14,
	RC_PROTO_RC6_0 = 15,
	RC_PROTO_RC6_6A_20 = 16,
	RC_PROTO_RC6_6A_24 = 17,
	RC_PROTO_RC6_6A_32 = 18,
	RC_PROTO_RC6_MCE = 19,
	RC_PROTO_SHARP = 20,
	RC_PROTO_XMP = 21,
	RC_PROTO_CEC = 22,
	RC_PROTO_IMON = 23,
	RC_PROTO_RCMM12 = 24,
	RC_PROTO_RCMM24 = 25,
	RC_PROTO_RCMM32 = 26,
	RC_PROTO_XBOX_DVD = 27,
	RC_PROTO_MAX = 27,
};

enum rdmacg_file_type {
	RDMACG_RESOURCE_TYPE_MAX = 0,
	RDMACG_RESOURCE_TYPE_STAT = 1,
};

enum rdmacg_resource_type {
	RDMACG_RESOURCE_HCA_HANDLE = 0,
	RDMACG_RESOURCE_HCA_OBJECT = 1,
	RDMACG_RESOURCE_MAX = 2,
};

enum reboot_mode {
	REBOOT_UNDEFINED = -1,
	REBOOT_COLD = 0,
	REBOOT_WARM = 1,
	REBOOT_HARD = 2,
	REBOOT_SOFT = 3,
	REBOOT_GPIO = 4,
};

enum reboot_type {
	BOOT_TRIPLE = 116,
	BOOT_KBD = 107,
	BOOT_BIOS = 98,
	BOOT_ACPI = 97,
	BOOT_EFI = 101,
	BOOT_CF9_FORCE = 112,
	BOOT_CF9_SAFE = 113,
};

enum recovery_flags {
	MD_RECOVERY_NEEDED = 0,
	MD_RECOVERY_RUNNING = 1,
	MD_RECOVERY_INTR = 2,
	MD_RECOVERY_DONE = 3,
	MD_RECOVERY_FROZEN = 4,
	MD_RECOVERY_WAIT = 5,
	MD_RECOVERY_ERROR = 6,
	MD_RECOVERY_SYNC = 7,
	MD_RECOVERY_REQUESTED = 8,
	MD_RECOVERY_CHECK = 9,
	MD_RECOVERY_RECOVER = 10,
	MD_RECOVERY_RESHAPE = 11,
	MD_RESYNCING_REMOTE = 12,
};

enum ref_state_type {
	REF_TYPE_PTR = 1,
	REF_TYPE_IRQ = 2,
	REF_TYPE_LOCK = 3,
};

enum refcount_saturation_type {
	REFCOUNT_ADD_NOT_ZERO_OVF = 0,
	REFCOUNT_ADD_OVF = 1,
	REFCOUNT_ADD_UAF = 2,
	REFCOUNT_SUB_UAF = 3,
	REFCOUNT_DEC_LEAK = 4,
};

enum reg_arg_type {
	SRC_OP = 0,
	DST_OP = 1,
	DST_OP_NO_MARK = 2,
};

enum reg_request_treatment {
	REG_REQ_OK = 0,
	REG_REQ_IGNORE = 1,
	REG_REQ_INTERSECT = 2,
	REG_REQ_ALREADY_SET = 3,
};

enum reg_type {
	REG_TYPE_RM = 0,
	REG_TYPE_REG = 1,
	REG_TYPE_INDEX = 2,
	REG_TYPE_BASE = 3,
};

enum regcache_type {
	REGCACHE_NONE = 0,
	REGCACHE_RBTREE = 1,
	REGCACHE_FLAT = 2,
	REGCACHE_MAPLE = 3,
};

enum regex_type {
	MATCH_FULL = 0,
	MATCH_FRONT_ONLY = 1,
	MATCH_MIDDLE_ONLY = 2,
	MATCH_END_ONLY = 3,
	MATCH_GLOB = 4,
	MATCH_INDEX = 5,
};

enum regmap_endian {
	REGMAP_ENDIAN_DEFAULT = 0,
	REGMAP_ENDIAN_BIG = 1,
	REGMAP_ENDIAN_LITTLE = 2,
	REGMAP_ENDIAN_NATIVE = 3,
};

enum release_type {
	leaf_only = 0,
	whole_subtree = 1,
};

enum report_header {
	HDR_32_BIT = 0,
	HDR_64_BIT = 1,
};

enum req_flag_bits {
	__REQ_FAILFAST_DEV = 8,
	__REQ_FAILFAST_TRANSPORT = 9,
	__REQ_FAILFAST_DRIVER = 10,
	__REQ_SYNC = 11,
	__REQ_META = 12,
	__REQ_PRIO = 13,
	__REQ_NOMERGE = 14,
	__REQ_IDLE = 15,
	__REQ_INTEGRITY = 16,
	__REQ_FUA = 17,
	__REQ_PREFLUSH = 18,
	__REQ_RAHEAD = 19,
	__REQ_BACKGROUND = 20,
	__REQ_NOWAIT = 21,
	__REQ_POLLED = 22,
	__REQ_ALLOC_CACHE = 23,
	__REQ_SWAP = 24,
	__REQ_DRV = 25,
	__REQ_FS_PRIVATE = 26,
	__REQ_ATOMIC = 27,
	__REQ_NOUNMAP = 28,
	__REQ_NR_BITS = 29,
};

enum req_op {
	REQ_OP_READ = 0,
	REQ_OP_WRITE = 1,
	REQ_OP_FLUSH = 2,
	REQ_OP_DISCARD = 3,
	REQ_OP_SECURE_ERASE = 5,
	REQ_OP_ZONE_APPEND = 7,
	REQ_OP_WRITE_ZEROES = 9,
	REQ_OP_ZONE_OPEN = 10,
	REQ_OP_ZONE_CLOSE = 11,
	REQ_OP_ZONE_FINISH = 12,
	REQ_OP_ZONE_RESET = 13,
	REQ_OP_ZONE_RESET_ALL = 15,
	REQ_OP_DRV_IN = 34,
	REQ_OP_DRV_OUT = 35,
	REQ_OP_LAST = 36,
};

enum resctrl_conf_type {
	CDP_NONE = 0,
	CDP_CODE = 1,
	CDP_DATA = 2,
};

enum reset_control_flags {
	RESET_CONTROL_EXCLUSIVE = 4,
	RESET_CONTROL_EXCLUSIVE_DEASSERTED = 12,
	RESET_CONTROL_EXCLUSIVE_RELEASED = 0,
	RESET_CONTROL_SHARED = 1,
	RESET_CONTROL_SHARED_DEASSERTED = 9,
	RESET_CONTROL_OPTIONAL_EXCLUSIVE = 6,
	RESET_CONTROL_OPTIONAL_EXCLUSIVE_DEASSERTED = 14,
	RESET_CONTROL_OPTIONAL_EXCLUSIVE_RELEASED = 2,
	RESET_CONTROL_OPTIONAL_SHARED = 3,
	RESET_CONTROL_OPTIONAL_SHARED_DEASSERTED = 11,
};

enum resolve_mode {
	RESOLVE_TBD = 0,
	RESOLVE_PTR = 1,
	RESOLVE_STRUCT_OR_ARRAY = 2,
};

enum retbleed_mitigation {
	RETBLEED_MITIGATION_NONE = 0,
	RETBLEED_MITIGATION_UNRET = 1,
	RETBLEED_MITIGATION_IBPB = 2,
	RETBLEED_MITIGATION_IBRS = 3,
	RETBLEED_MITIGATION_EIBRS = 4,
	RETBLEED_MITIGATION_STUFF = 5,
};

enum retbleed_mitigation_cmd {
	RETBLEED_CMD_OFF = 0,
	RETBLEED_CMD_AUTO = 1,
	RETBLEED_CMD_UNRET = 2,
	RETBLEED_CMD_IBPB = 3,
	RETBLEED_CMD_STUFF = 4,
};

enum rfds_mitigations {
	RFDS_MITIGATION_OFF = 0,
	RFDS_MITIGATION_VERW = 1,
	RFDS_MITIGATION_UCODE_NEEDED = 2,
};

enum rfkill_hard_block_reasons {
	RFKILL_HARD_BLOCK_SIGNAL = 1,
	RFKILL_HARD_BLOCK_NOT_OWNER = 2,
};

enum rfkill_input_master_mode {
	RFKILL_INPUT_MASTER_UNLOCK = 0,
	RFKILL_INPUT_MASTER_RESTORE = 1,
	RFKILL_INPUT_MASTER_UNBLOCKALL = 2,
	NUM_RFKILL_INPUT_MASTER_MODES = 3,
};

enum rfkill_operation {
	RFKILL_OP_ADD = 0,
	RFKILL_OP_DEL = 1,
	RFKILL_OP_CHANGE = 2,
	RFKILL_OP_CHANGE_ALL = 3,
};

enum rfkill_sched_op {
	RFKILL_GLOBAL_OP_EPO = 0,
	RFKILL_GLOBAL_OP_RESTORE = 1,
	RFKILL_GLOBAL_OP_UNLOCK = 2,
	RFKILL_GLOBAL_OP_UNBLOCK = 3,
};

enum rfkill_type {
	RFKILL_TYPE_ALL = 0,
	RFKILL_TYPE_WLAN = 1,
	RFKILL_TYPE_BLUETOOTH = 2,
	RFKILL_TYPE_UWB = 3,
	RFKILL_TYPE_WIMAX = 4,
	RFKILL_TYPE_WWAN = 5,
	RFKILL_TYPE_GPS = 6,
	RFKILL_TYPE_FM = 7,
	RFKILL_TYPE_NFC = 8,
	NUM_RFKILL_TYPES = 9,
};

enum rfkill_user_states {
	RFKILL_USER_STATE_SOFT_BLOCKED = 0,
	RFKILL_USER_STATE_UNBLOCKED = 1,
	RFKILL_USER_STATE_HARD_BLOCKED = 2,
};

enum ring_buffer_flags {
	RB_FL_OVERWRITE = 1,
};

enum ring_buffer_type {
	RINGBUF_TYPE_DATA_TYPE_LEN_MAX = 28,
	RINGBUF_TYPE_PADDING = 29,
	RINGBUF_TYPE_TIME_EXTEND = 30,
	RINGBUF_TYPE_TIME_STAMP = 31,
};

enum rlimit_type {
	UCOUNT_RLIMIT_NPROC = 0,
	UCOUNT_RLIMIT_MSGQUEUE = 1,
	UCOUNT_RLIMIT_SIGPENDING = 2,
	UCOUNT_RLIMIT_MEMLOCK = 3,
	UCOUNT_RLIMIT_COUNTS = 4,
};

enum rmap_level {
	RMAP_LEVEL_PTE = 0,
	RMAP_LEVEL_PMD = 1,
};

enum rmi_reg_state {
	RMI_REG_STATE_DEFAULT = 0,
	RMI_REG_STATE_OFF = 1,
	RMI_REG_STATE_ON = 2,
};

enum rmi_sensor_type {
	rmi_sensor_default = 0,
	rmi_sensor_touchscreen = 1,
	rmi_sensor_touchpad = 2,
};

enum rmp_flags {
	RMP_LOCKED = 1,
	RMP_USE_SHARED_ZEROPAGE = 2,
};

enum rp_check {
	RP_CHECK_CALL = 0,
	RP_CHECK_CHAIN_CALL = 1,
	RP_CHECK_RET = 2,
};

enum rpc_accept_stat {
	RPC_SUCCESS = 0,
	RPC_PROG_UNAVAIL = 1,
	RPC_PROG_MISMATCH = 2,
	RPC_PROC_UNAVAIL = 3,
	RPC_GARBAGE_ARGS = 4,
	RPC_SYSTEM_ERR = 5,
	RPC_DROP_REPLY = 60000,
};

enum rpc_auth_flavors {
	RPC_AUTH_NULL = 0,
	RPC_AUTH_UNIX = 1,
	RPC_AUTH_SHORT = 2,
	RPC_AUTH_DES = 3,
	RPC_AUTH_KRB = 4,
	RPC_AUTH_GSS = 6,
	RPC_AUTH_TLS = 7,
	RPC_AUTH_MAXFLAVOR = 8,
	RPC_AUTH_GSS_KRB5 = 390003,
	RPC_AUTH_GSS_KRB5I = 390004,
	RPC_AUTH_GSS_KRB5P = 390005,
	RPC_AUTH_GSS_LKEY = 390006,
	RPC_AUTH_GSS_LKEYI = 390007,
	RPC_AUTH_GSS_LKEYP = 390008,
	RPC_AUTH_GSS_SPKM = 390009,
	RPC_AUTH_GSS_SPKMI = 390010,
	RPC_AUTH_GSS_SPKMP = 390011,
};

enum rpc_auth_stat {
	RPC_AUTH_OK = 0,
	RPC_AUTH_BADCRED = 1,
	RPC_AUTH_REJECTEDCRED = 2,
	RPC_AUTH_BADVERF = 3,
	RPC_AUTH_REJECTEDVERF = 4,
	RPC_AUTH_TOOWEAK = 5,
	RPCSEC_GSS_CREDPROBLEM = 13,
	RPCSEC_GSS_CTXPROBLEM = 14,
};

enum rpc_display_format_t {
	RPC_DISPLAY_ADDR = 0,
	RPC_DISPLAY_PORT = 1,
	RPC_DISPLAY_PROTO = 2,
	RPC_DISPLAY_HEX_ADDR = 3,
	RPC_DISPLAY_HEX_PORT = 4,
	RPC_DISPLAY_NETID = 5,
	RPC_DISPLAY_MAX = 6,
};

enum rpc_gss_proc {
	RPC_GSS_PROC_DATA = 0,
	RPC_GSS_PROC_INIT = 1,
	RPC_GSS_PROC_CONTINUE_INIT = 2,
	RPC_GSS_PROC_DESTROY = 3,
};

enum rpc_gss_svc {
	RPC_GSS_SVC_NONE = 1,
	RPC_GSS_SVC_INTEGRITY = 2,
	RPC_GSS_SVC_PRIVACY = 3,
};

enum rpc_msg_type {
	RPC_CALL = 0,
	RPC_REPLY = 1,
};

enum rpc_reject_stat {
	RPC_MISMATCH = 0,
	RPC_AUTH_ERROR = 1,
};

enum rpc_reply_stat {
	RPC_MSG_ACCEPTED = 0,
	RPC_MSG_DENIED = 1,
};

enum rpm_request {
	RPM_REQ_NONE = 0,
	RPM_REQ_IDLE = 1,
	RPM_REQ_SUSPEND = 2,
	RPM_REQ_AUTOSUSPEND = 3,
	RPM_REQ_RESUME = 4,
};

enum rpm_status {
	RPM_INVALID = -1,
	RPM_ACTIVE = 0,
	RPM_RESUMING = 1,
	RPM_SUSPENDED = 2,
	RPM_SUSPENDING = 3,
};

enum rq_end_io_ret {
	RQ_END_IO_NONE = 0,
	RQ_END_IO_FREE = 1,
};

enum rq_qos_id {
	RQ_QOS_WBT = 0,
	RQ_QOS_LATENCY = 1,
	RQ_QOS_COST = 2,
};

enum rqf_flags {
	__RQF_STARTED = 0,
	__RQF_FLUSH_SEQ = 1,
	__RQF_MIXED_MERGE = 2,
	__RQF_DONTPREP = 3,
	__RQF_SCHED_TAGS = 4,
	__RQF_USE_SCHED = 5,
	__RQF_FAILED = 6,
	__RQF_QUIET = 7,
	__RQF_IO_STAT = 8,
	__RQF_PM = 9,
	__RQF_HASHED = 10,
	__RQF_STATS = 11,
	__RQF_SPECIAL_PAYLOAD = 12,
	__RQF_ZONE_WRITE_PLUGGING = 13,
	__RQF_TIMED_OUT = 14,
	__RQF_RESV = 15,
	__RQF_BITS = 16,
};

enum rsaprivkey_actions {
	ACT_rsa_get_d = 0,
	ACT_rsa_get_dp = 1,
	ACT_rsa_get_dq = 2,
	ACT_rsa_get_e = 3,
	ACT_rsa_get_n = 4,
	ACT_rsa_get_p = 5,
	ACT_rsa_get_q = 6,
	ACT_rsa_get_qinv = 7,
	NR__rsaprivkey_actions = 8,
};

enum rsapubkey_actions {
	ACT_rsa_get_e___2 = 0,
	ACT_rsa_get_n___2 = 1,
	NR__rsapubkey_actions = 2,
};

enum rseq_cpu_id_state {
	RSEQ_CPU_ID_UNINITIALIZED = -1,
	RSEQ_CPU_ID_REGISTRATION_FAILED = -2,
};

enum rseq_cs_flags {
	RSEQ_CS_FLAG_NO_RESTART_ON_PREEMPT = 1,
	RSEQ_CS_FLAG_NO_RESTART_ON_SIGNAL = 2,
	RSEQ_CS_FLAG_NO_RESTART_ON_MIGRATE = 4,
};

enum rseq_cs_flags_bit {
	RSEQ_CS_FLAG_NO_RESTART_ON_PREEMPT_BIT = 0,
	RSEQ_CS_FLAG_NO_RESTART_ON_SIGNAL_BIT = 1,
	RSEQ_CS_FLAG_NO_RESTART_ON_MIGRATE_BIT = 2,
};

enum rseq_event_mask_bits {
	RSEQ_EVENT_PREEMPT_BIT = 0,
	RSEQ_EVENT_SIGNAL_BIT = 1,
	RSEQ_EVENT_MIGRATE_BIT = 2,
};

enum rseq_flags {
	RSEQ_FLAG_UNREGISTER = 1,
};

enum rt6_nud_state {
	RT6_NUD_FAIL_HARD = -3,
	RT6_NUD_FAIL_PROBE = -2,
	RT6_NUD_FAIL_DO_RR = -1,
	RT6_NUD_SUCCEED = 1,
};

enum rt_class_t {
	RT_TABLE_UNSPEC = 0,
	RT_TABLE_COMPAT = 252,
	RT_TABLE_DEFAULT = 253,
	RT_TABLE_MAIN = 254,
	RT_TABLE_LOCAL = 255,
	RT_TABLE_MAX = 4294967295,
};

enum rt_scope_t {
	RT_SCOPE_UNIVERSE = 0,
	RT_SCOPE_SITE = 200,
	RT_SCOPE_LINK = 253,
	RT_SCOPE_HOST = 254,
	RT_SCOPE_NOWHERE = 255,
};

enum rtattr_type_t {
	RTA_UNSPEC = 0,
	RTA_DST = 1,
	RTA_SRC = 2,
	RTA_IIF = 3,
	RTA_OIF = 4,
	RTA_GATEWAY = 5,
	RTA_PRIORITY = 6,
	RTA_PREFSRC = 7,
	RTA_METRICS = 8,
	RTA_MULTIPATH = 9,
	RTA_PROTOINFO = 10,
	RTA_FLOW = 11,
	RTA_CACHEINFO = 12,
	RTA_SESSION = 13,
	RTA_MP_ALGO = 14,
	RTA_TABLE = 15,
	RTA_MARK = 16,
	RTA_MFC_STATS = 17,
	RTA_VIA = 18,
	RTA_NEWDST = 19,
	RTA_PREF = 20,
	RTA_ENCAP_TYPE = 21,
	RTA_ENCAP = 22,
	RTA_EXPIRES = 23,
	RTA_PAD = 24,
	RTA_UID = 25,
	RTA_TTL_PROPAGATE = 26,
	RTA_IP_PROTO = 27,
	RTA_SPORT = 28,
	RTA_DPORT = 29,
	RTA_NH_ID = 30,
	RTA_FLOWLABEL = 31,
	__RTA_MAX = 32,
};

enum rtl8125_registers {
	LEDSEL0 = 24,
	INT_CFG0_8125 = 52,
	IntrMask_8125 = 56,
	IntrStatus_8125 = 60,
	INT_CFG1_8125 = 122,
	LEDSEL2 = 132,
	LEDSEL1 = 134,
	TxPoll_8125 = 144,
	LEDSEL3 = 150,
	MAC0_BKP = 6624,
	RSS_CTRL_8125 = 17664,
	Q_NUM_CTRL_8125 = 18432,
	EEE_TXIDLE_TIMER_8125 = 24648,
};

enum rtl8168_8101_registers {
	CSIDR = 100,
	CSIAR = 104,
	PMCH = 111,
	EPHYAR = 128,
	DLLPR = 208,
	DBG_REG = 209,
	TWSI = 210,
	MCU = 211,
	EFUSEAR = 220,
	MISC_1 = 242,
};

enum rtl8168_registers {
	LED_CTRL = 24,
	LED_FREQ = 26,
	EEE_LED = 27,
	ERIDR = 112,
	ERIAR = 116,
	EPHY_RXER_NUM = 124,
	OCPDR = 176,
	OCPAR = 180,
	GPHY_OCP = 184,
	RDSAR1 = 208,
	MISC = 240,
};

enum rtl_dash_type {
	RTL_DASH_NONE = 0,
	RTL_DASH_DP = 1,
	RTL_DASH_EP = 2,
	RTL_DASH_25_BP = 3,
};

enum rtl_desc_bit {
	DescOwn = -2147483648,
	RingEnd = 1073741824,
	FirstFrag = 536870912,
	LastFrag = 268435456,
};

enum rtl_flag {
	RTL_FLAG_TASK_RESET_PENDING = 0,
	RTL_FLAG_TASK_TX_TIMEOUT = 1,
	RTL_FLAG_MAX = 2,
};

enum rtl_fw_opcode {
	PHY_READ = 0,
	PHY_DATA_OR = 1,
	PHY_DATA_AND = 2,
	PHY_BJMPN = 3,
	PHY_MDIO_CHG = 4,
	PHY_CLEAR_READCOUNT = 7,
	PHY_WRITE = 8,
	PHY_READCOUNT_EQ_SKIP = 9,
	PHY_COMP_EQ_SKIPN = 10,
	PHY_COMP_NEQ_SKIPN = 11,
	PHY_WRITE_PREVIOUS = 12,
	PHY_SKIPN = 13,
	PHY_DELAY_MS = 14,
};

enum rtl_register_content {
	SYSErr = 32768,
	PCSTimeout___2 = 16384,
	SWInt = 256,
	TxDescUnavail = 128,
	RxFIFOOver___2 = 64,
	LinkChg = 32,
	RxOverflow___2 = 16,
	TxErr___2 = 8,
	TxOK___2 = 4,
	RxErr___2 = 2,
	RxOK___2 = 1,
	RxRWT = 4194304,
	RxRES = 2097152,
	RxRUNT = 1048576,
	RxCRC = 524288,
	StopReq = 128,
	CmdReset___2 = 16,
	CmdRxEnb___2 = 8,
	CmdTxEnb___2 = 4,
	RxBufEmpty___2 = 1,
	HPQ = 128,
	NPQ = 64,
	FSWInt = 1,
	Cfg9346_Lock___2 = 0,
	Cfg9346_Unlock___2 = 192,
	AcceptErr = 32,
	AcceptRunt = 16,
	AcceptBroadcast = 8,
	AcceptMulticast = 4,
	AcceptMyPhys = 2,
	AcceptAllPhys = 1,
	TxInterFrameGapShift = 24,
	TxDMAShift = 8,
	LEDS1 = 128,
	LEDS0 = 64,
	Speed_down = 16,
	MEMMAP = 8,
	IOMAP = 4,
	VPD = 2,
	PMEnable = 1,
	ClkReqEn = 128,
	MSIEnable = 32,
	PCI_Clock_66MHz = 1,
	PCI_Clock_33MHz = 0,
	MagicPacket = 32,
	LinkUp = 16,
	Jumbo_En0 = 4,
	Rdy_to_L23 = 2,
	Beacon_en = 1,
	Jumbo_En1 = 2,
	BWF = 64,
	MWF = 32,
	UWF = 16,
	Spi_en = 8,
	LanWake = 2,
	PMEStatus = 1,
	ASPM_en = 1,
	EnableBist = 32768,
	Mac_dbgo_oe = 16384,
	EnAnaPLL = 16384,
	Normal_mode = 8192,
	Force_half_dup = 4096,
	Force_rxflow_en = 2048,
	Force_txflow_en = 1024,
	Cxpl_dbg_sel = 512,
	ASF = 256,
	PktCntrDisable = 128,
	Mac_dbgo_sel = 28,
	RxVlan = 64,
	RxChkSum = 32,
	PCIDAC = 16,
	PCIMulRW = 8,
	TBI_Enable = 128,
	TxFlowCtrl = 64,
	RxFlowCtrl = 32,
	_1000bpsF = 16,
	_100bps = 8,
	_10bps = 4,
	LinkStatus = 2,
	FullDup = 1,
	CounterReset = 1,
	CounterDump = 8,
	MagicPacket_v2 = 65536,
};

enum rtl_registers {
	MAC0___2 = 0,
	MAC4 = 4,
	MAR0___2 = 8,
	CounterAddrLow = 16,
	CounterAddrHigh = 20,
	TxDescStartAddrLow = 32,
	TxDescStartAddrHigh = 36,
	TxHDescStartAddrLow = 40,
	TxHDescStartAddrHigh = 44,
	FLASH = 48,
	ERSR = 54,
	ChipCmd___2 = 55,
	TxPoll = 56,
	IntrMask___2 = 60,
	IntrStatus___2 = 62,
	TxConfig___2 = 64,
	RxConfig___2 = 68,
	Cfg9346___2 = 80,
	Config0___2 = 81,
	Config1___2 = 82,
	Config2 = 83,
	Config3___2 = 84,
	Config4___2 = 85,
	Config5___2 = 86,
	PHYAR = 96,
	PHYstatus = 108,
	RxMaxSize = 218,
	CPlusCmd = 224,
	IntrMitigate = 226,
	RxDescAddrLow = 228,
	RxDescAddrHigh = 232,
	EarlyTxThres = 236,
	MaxTxPacketSize = 236,
	FuncEvent = 240,
	FuncEventMask = 244,
	FuncPresetState = 248,
	IBCR0 = 248,
	IBCR2 = 249,
	IBIMR0 = 250,
	IBISR0 = 251,
	FuncForceEvent = 252,
};

enum rtl_rx_desc_bit {
	PID1 = 262144,
	PID0 = 131072,
	IPFail = 65536,
	UDPFail = 32768,
	TCPFail = 16384,
	RxVlanTag = 65536,
};

enum rtl_tx_desc_bit {
	TD_LSO = 134217728,
	TxVlanTag = 131072,
};

enum rtl_tx_desc_bit_0 {
	TD0_TCP_CS = 65536,
	TD0_UDP_CS = 131072,
	TD0_IP_CS = 262144,
};

enum rtl_tx_desc_bit_1 {
	TD1_GTSENV4 = 67108864,
	TD1_GTSENV6 = 33554432,
	TD1_IPv6_CS = 268435456,
	TD1_IPv4_CS = 536870912,
	TD1_TCP_CS = 1073741824,
	TD1_UDP_CS = -2147483648,
};

enum rtmutex_chainwalk {
	RT_MUTEX_MIN_CHAINWALK = 0,
	RT_MUTEX_FULL_CHAINWALK = 1,
};

enum rtnetlink_groups {
	RTNLGRP_NONE = 0,
	RTNLGRP_LINK = 1,
	RTNLGRP_NOTIFY = 2,
	RTNLGRP_NEIGH = 3,
	RTNLGRP_TC = 4,
	RTNLGRP_IPV4_IFADDR = 5,
	RTNLGRP_IPV4_MROUTE = 6,
	RTNLGRP_IPV4_ROUTE = 7,
	RTNLGRP_IPV4_RULE = 8,
	RTNLGRP_IPV6_IFADDR = 9,
	RTNLGRP_IPV6_MROUTE = 10,
	RTNLGRP_IPV6_ROUTE = 11,
	RTNLGRP_IPV6_IFINFO = 12,
	RTNLGRP_DECnet_IFADDR = 13,
	RTNLGRP_NOP2 = 14,
	RTNLGRP_DECnet_ROUTE = 15,
	RTNLGRP_DECnet_RULE = 16,
	RTNLGRP_NOP4 = 17,
	RTNLGRP_IPV6_PREFIX = 18,
	RTNLGRP_IPV6_RULE = 19,
	RTNLGRP_ND_USEROPT = 20,
	RTNLGRP_PHONET_IFADDR = 21,
	RTNLGRP_PHONET_ROUTE = 22,
	RTNLGRP_DCB = 23,
	RTNLGRP_IPV4_NETCONF = 24,
	RTNLGRP_IPV6_NETCONF = 25,
	RTNLGRP_MDB = 26,
	RTNLGRP_MPLS_ROUTE = 27,
	RTNLGRP_NSID = 28,
	RTNLGRP_MPLS_NETCONF = 29,
	RTNLGRP_IPV4_MROUTE_R = 30,
	RTNLGRP_IPV6_MROUTE_R = 31,
	RTNLGRP_NEXTHOP = 32,
	RTNLGRP_BRVLAN = 33,
	RTNLGRP_MCTP_IFADDR = 34,
	RTNLGRP_TUNNEL = 35,
	RTNLGRP_STATS = 36,
	RTNLGRP_IPV4_MCADDR = 37,
	RTNLGRP_IPV6_MCADDR = 38,
	RTNLGRP_IPV6_ACADDR = 39,
	__RTNLGRP_MAX = 40,
};

enum rtnl_kinds {
	RTNL_KIND_NEW = 0,
	RTNL_KIND_DEL = 1,
	RTNL_KIND_GET = 2,
	RTNL_KIND_SET = 3,
};

enum rtnl_link_flags {
	RTNL_FLAG_DOIT_UNLOCKED = 1,
	RTNL_FLAG_BULK_DEL_SUPPORTED = 2,
	RTNL_FLAG_DUMP_UNLOCKED = 4,
	RTNL_FLAG_DUMP_SPLIT_NLM_DONE = 8,
};

enum ru_state {
	RU_SUSPENDED = 0,
	RU_RUNNING = 1,
	RU_UNINITIALIZED = -1,
};

enum rw_hint {
	WRITE_LIFE_NOT_SET = 0,
	WRITE_LIFE_NONE = 1,
	WRITE_LIFE_SHORT = 2,
	WRITE_LIFE_MEDIUM = 3,
	WRITE_LIFE_LONG = 4,
	WRITE_LIFE_EXTREME = 5,
} __attribute__((mode(byte)));

enum rwsem_waiter_type {
	RWSEM_WAITING_FOR_WRITE = 0,
	RWSEM_WAITING_FOR_READ = 1,
};

enum rwsem_wake_type {
	RWSEM_WAKE_ANY = 0,
	RWSEM_WAKE_READERS = 1,
	RWSEM_WAKE_READ_OWNED = 2,
};

enum rx_handler_result {
	RX_HANDLER_CONSUMED = 0,
	RX_HANDLER_ANOTHER = 1,
	RX_HANDLER_EXACT = 2,
	RX_HANDLER_PASS = 3,
};

typedef enum rx_handler_result rx_handler_result_t;

enum rx_mode_bits {
	AcceptErr___2 = 32,
	AcceptRunt___2 = 16,
	AcceptBroadcast___2 = 8,
	AcceptMulticast___2 = 4,
	AcceptMyPhys___2 = 2,
	AcceptAllPhys___2 = 1,
};

enum s2idle_states {
	S2IDLE_STATE_NONE = 0,
	S2IDLE_STATE_ENTER = 1,
	S2IDLE_STATE_WAKE = 2,
};

enum s_alloc {
	sa_rootdomain = 0,
	sa_sd = 1,
	sa_sd_storage = 2,
	sa_none = 3,
};

enum sam_status {
	SAM_STAT_GOOD = 0,
	SAM_STAT_CHECK_CONDITION = 2,
	SAM_STAT_CONDITION_MET = 4,
	SAM_STAT_BUSY = 8,
	SAM_STAT_INTERMEDIATE = 16,
	SAM_STAT_INTERMEDIATE_CONDITION_MET = 20,
	SAM_STAT_RESERVATION_CONFLICT = 24,
	SAM_STAT_COMMAND_TERMINATED = 34,
	SAM_STAT_TASK_SET_FULL = 40,
	SAM_STAT_ACA_ACTIVE = 48,
	SAM_STAT_TASK_ABORTED = 64,
};

enum scan_balance {
	SCAN_EQUAL = 0,
	SCAN_FRACT = 1,
	SCAN_ANON = 2,
	SCAN_FILE = 3,
};

enum scb_cmd_hi {
	irq_mask_none = 0,
	irq_mask_all = 1,
	irq_sw_gen = 2,
};

enum scb_cmd_lo {
	cuc_nop = 0,
	ruc_start = 1,
	ruc_load_base = 6,
	cuc_start = 16,
	cuc_resume = 32,
	cuc_dump_addr = 64,
	cuc_dump_stats = 80,
	cuc_load_base = 96,
	cuc_dump_reset = 112,
};

enum scb_stat_ack {
	stat_ack_not_ours = 0,
	stat_ack_sw_gen = 4,
	stat_ack_rnr = 16,
	stat_ack_cu_idle = 32,
	stat_ack_frame_rx = 64,
	stat_ack_cu_cmd_done = 128,
	stat_ack_not_present = 255,
	stat_ack_rx = 84,
	stat_ack_tx = 160,
};

enum scb_status {
	rus_no_res = 8,
	rus_ready = 16,
	rus_mask = 60,
};

enum sched_tunable_scaling {
	SCHED_TUNABLESCALING_NONE = 0,
	SCHED_TUNABLESCALING_LOG = 1,
	SCHED_TUNABLESCALING_LINEAR = 2,
	SCHED_TUNABLESCALING_END = 3,
};

enum scsi_cmnd_submitter {
	SUBMITTED_BY_BLOCK_LAYER = 0,
	SUBMITTED_BY_SCSI_ERROR_HANDLER = 1,
	SUBMITTED_BY_SCSI_RESET_IOCTL = 2,
} __attribute__((mode(byte)));

enum scsi_device_event {
	SDEV_EVT_MEDIA_CHANGE = 1,
	SDEV_EVT_INQUIRY_CHANGE_REPORTED = 2,
	SDEV_EVT_CAPACITY_CHANGE_REPORTED = 3,
	SDEV_EVT_SOFT_THRESHOLD_REACHED_REPORTED = 4,
	SDEV_EVT_MODE_PARAMETER_CHANGE_REPORTED = 5,
	SDEV_EVT_LUN_CHANGE_REPORTED = 6,
	SDEV_EVT_ALUA_STATE_CHANGE_REPORTED = 7,
	SDEV_EVT_POWER_ON_RESET_OCCURRED = 8,
	SDEV_EVT_FIRST = 1,
	SDEV_EVT_LAST = 8,
	SDEV_EVT_MAXBITS = 9,
};

enum scsi_device_state {
	SDEV_CREATED = 1,
	SDEV_RUNNING = 2,
	SDEV_CANCEL = 3,
	SDEV_DEL = 4,
	SDEV_QUIESCE = 5,
	SDEV_OFFLINE = 6,
	SDEV_TRANSPORT_OFFLINE = 7,
	SDEV_BLOCK = 8,
	SDEV_CREATED_BLOCK = 9,
};

enum scsi_devinfo_key {
	SCSI_DEVINFO_GLOBAL = 0,
	SCSI_DEVINFO_SPI = 1,
};

enum scsi_disposition {
	NEEDS_RETRY = 8193,
	SUCCESS = 8194,
	FAILED = 8195,
	QUEUED = 8196,
	SOFT_ERROR = 8197,
	ADD_TO_MLQUEUE = 8198,
	TIMEOUT_ERROR = 8199,
	SCSI_RETURN_NOT_HANDLED = 8200,
	FAST_IO_FAIL = 8201,
};

enum scsi_host_prot_capabilities {
	SHOST_DIF_TYPE1_PROTECTION = 1,
	SHOST_DIF_TYPE2_PROTECTION = 2,
	SHOST_DIF_TYPE3_PROTECTION = 4,
	SHOST_DIX_TYPE0_PROTECTION = 8,
	SHOST_DIX_TYPE1_PROTECTION = 16,
	SHOST_DIX_TYPE2_PROTECTION = 32,
	SHOST_DIX_TYPE3_PROTECTION = 64,
};

enum scsi_host_state {
	SHOST_CREATED = 1,
	SHOST_RUNNING = 2,
	SHOST_CANCEL = 3,
	SHOST_DEL = 4,
	SHOST_RECOVERY = 5,
	SHOST_CANCEL_RECOVERY = 6,
	SHOST_DEL_RECOVERY = 7,
};

enum scsi_host_status {
	DID_OK = 0,
	DID_NO_CONNECT = 1,
	DID_BUS_BUSY = 2,
	DID_TIME_OUT = 3,
	DID_BAD_TARGET = 4,
	DID_ABORT = 5,
	DID_PARITY = 6,
	DID_ERROR = 7,
	DID_RESET = 8,
	DID_BAD_INTR = 9,
	DID_PASSTHROUGH = 10,
	DID_SOFT_ERROR = 11,
	DID_IMM_RETRY = 12,
	DID_REQUEUE = 13,
	DID_TRANSPORT_DISRUPTED = 14,
	DID_TRANSPORT_FAILFAST = 15,
	DID_TRANSPORT_MARGINAL = 20,
};

enum scsi_ml_status {
	SCSIML_STAT_OK = 0,
	SCSIML_STAT_RESV_CONFLICT = 1,
	SCSIML_STAT_NOSPC = 2,
	SCSIML_STAT_MED_ERROR = 3,
	SCSIML_STAT_TGT_FAILURE = 4,
	SCSIML_STAT_DL_TIMEOUT = 5,
};

enum scsi_msg_byte {
	COMMAND_COMPLETE = 0,
	EXTENDED_MESSAGE = 1,
	SAVE_POINTERS = 2,
	RESTORE_POINTERS = 3,
	DISCONNECT = 4,
	INITIATOR_ERROR = 5,
	ABORT_TASK_SET = 6,
	MESSAGE_REJECT = 7,
	NOP___2 = 8,
	MSG_PARITY_ERROR = 9,
	LINKED_CMD_COMPLETE = 10,
	LINKED_FLG_CMD_COMPLETE = 11,
	TARGET_RESET = 12,
	ABORT_TASK = 13,
	CLEAR_TASK_SET = 14,
	INITIATE_RECOVERY = 15,
	RELEASE_RECOVERY = 16,
	TERMINATE_IO_PROC = 17,
	CLEAR_ACA = 22,
	LOGICAL_UNIT_RESET = 23,
	SIMPLE_QUEUE_TAG = 32,
	HEAD_OF_QUEUE_TAG = 33,
	ORDERED_QUEUE_TAG = 34,
	IGNORE_WIDE_RESIDUE = 35,
	ACA = 36,
	QAS_REQUEST = 85,
	BUS_DEVICE_RESET = 12,
	ABORT = 6,
};

enum scsi_pr_type {
	SCSI_PR_WRITE_EXCLUSIVE = 1,
	SCSI_PR_EXCLUSIVE_ACCESS = 3,
	SCSI_PR_WRITE_EXCLUSIVE_REG_ONLY = 5,
	SCSI_PR_EXCLUSIVE_ACCESS_REG_ONLY = 6,
	SCSI_PR_WRITE_EXCLUSIVE_ALL_REGS = 7,
	SCSI_PR_EXCLUSIVE_ACCESS_ALL_REGS = 8,
};

enum scsi_prot_flags {
	SCSI_PROT_TRANSFER_PI = 1,
	SCSI_PROT_GUARD_CHECK = 2,
	SCSI_PROT_REF_CHECK = 4,
	SCSI_PROT_REF_INCREMENT = 8,
	SCSI_PROT_IP_CHECKSUM = 16,
};

enum scsi_prot_operations {
	SCSI_PROT_NORMAL = 0,
	SCSI_PROT_READ_INSERT = 1,
	SCSI_PROT_WRITE_STRIP = 2,
	SCSI_PROT_READ_STRIP = 3,
	SCSI_PROT_WRITE_INSERT = 4,
	SCSI_PROT_READ_PASS = 5,
	SCSI_PROT_WRITE_PASS = 6,
};

enum scsi_scan_mode {
	SCSI_SCAN_INITIAL = 0,
	SCSI_SCAN_RESCAN = 1,
	SCSI_SCAN_MANUAL = 2,
};

enum scsi_target_state {
	STARGET_CREATED = 1,
	STARGET_RUNNING = 2,
	STARGET_REMOVE = 3,
	STARGET_CREATED_REMOVE = 4,
	STARGET_DEL = 5,
};

enum scsi_timeout_action {
	SCSI_EH_DONE = 0,
	SCSI_EH_RESET_TIMER = 1,
	SCSI_EH_NOT_HANDLED = 2,
};

enum scsi_timeouts {
	SCSI_DEFAULT_EH_TIMEOUT = 10000,
};

enum scsi_vpd_parameters {
	SCSI_VPD_HEADER_SIZE = 4,
	SCSI_VPD_LIST_SIZE = 36,
};

enum sctp_cid {
	SCTP_CID_DATA = 0,
	SCTP_CID_INIT = 1,
	SCTP_CID_INIT_ACK = 2,
	SCTP_CID_SACK = 3,
	SCTP_CID_HEARTBEAT = 4,
	SCTP_CID_HEARTBEAT_ACK = 5,
	SCTP_CID_ABORT = 6,
	SCTP_CID_SHUTDOWN = 7,
	SCTP_CID_SHUTDOWN_ACK = 8,
	SCTP_CID_ERROR = 9,
	SCTP_CID_COOKIE_ECHO = 10,
	SCTP_CID_COOKIE_ACK = 11,
	SCTP_CID_ECN_ECNE = 12,
	SCTP_CID_ECN_CWR = 13,
	SCTP_CID_SHUTDOWN_COMPLETE = 14,
	SCTP_CID_AUTH = 15,
	SCTP_CID_I_DATA = 64,
	SCTP_CID_FWD_TSN = 192,
	SCTP_CID_ASCONF = 193,
	SCTP_CID_I_FWD_TSN = 194,
	SCTP_CID_ASCONF_ACK = 128,
	SCTP_CID_RECONF = 130,
	SCTP_CID_PAD = 132,
};

enum sctp_conntrack {
	SCTP_CONNTRACK_NONE = 0,
	SCTP_CONNTRACK_CLOSED = 1,
	SCTP_CONNTRACK_COOKIE_WAIT = 2,
	SCTP_CONNTRACK_COOKIE_ECHOED = 3,
	SCTP_CONNTRACK_ESTABLISHED = 4,
	SCTP_CONNTRACK_SHUTDOWN_SENT = 5,
	SCTP_CONNTRACK_SHUTDOWN_RECD = 6,
	SCTP_CONNTRACK_SHUTDOWN_ACK_SENT = 7,
	SCTP_CONNTRACK_HEARTBEAT_SENT = 8,
	SCTP_CONNTRACK_HEARTBEAT_ACKED = 9,
	SCTP_CONNTRACK_MAX = 10,
};

enum sctp_endpoint_type {
	SCTP_EP_TYPE_SOCKET = 0,
	SCTP_EP_TYPE_ASSOCIATION = 1,
};

enum sctp_event_timeout {
	SCTP_EVENT_TIMEOUT_NONE = 0,
	SCTP_EVENT_TIMEOUT_T1_COOKIE = 1,
	SCTP_EVENT_TIMEOUT_T1_INIT = 2,
	SCTP_EVENT_TIMEOUT_T2_SHUTDOWN = 3,
	SCTP_EVENT_TIMEOUT_T3_RTX = 4,
	SCTP_EVENT_TIMEOUT_T4_RTO = 5,
	SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD = 6,
	SCTP_EVENT_TIMEOUT_HEARTBEAT = 7,
	SCTP_EVENT_TIMEOUT_RECONF = 8,
	SCTP_EVENT_TIMEOUT_PROBE = 9,
	SCTP_EVENT_TIMEOUT_SACK = 10,
	SCTP_EVENT_TIMEOUT_AUTOCLOSE = 11,
};

enum sctp_msg_flags {
	MSG_NOTIFICATION = 32768,
};

enum sctp_param {
	SCTP_PARAM_HEARTBEAT_INFO = 256,
	SCTP_PARAM_IPV4_ADDRESS = 1280,
	SCTP_PARAM_IPV6_ADDRESS = 1536,
	SCTP_PARAM_STATE_COOKIE = 1792,
	SCTP_PARAM_UNRECOGNIZED_PARAMETERS = 2048,
	SCTP_PARAM_COOKIE_PRESERVATIVE = 2304,
	SCTP_PARAM_HOST_NAME_ADDRESS = 2816,
	SCTP_PARAM_SUPPORTED_ADDRESS_TYPES = 3072,
	SCTP_PARAM_ECN_CAPABLE = 128,
	SCTP_PARAM_RANDOM = 640,
	SCTP_PARAM_CHUNKS = 896,
	SCTP_PARAM_HMAC_ALGO = 1152,
	SCTP_PARAM_SUPPORTED_EXT = 2176,
	SCTP_PARAM_FWD_TSN_SUPPORT = 192,
	SCTP_PARAM_ADD_IP = 448,
	SCTP_PARAM_DEL_IP = 704,
	SCTP_PARAM_ERR_CAUSE = 960,
	SCTP_PARAM_SET_PRIMARY = 1216,
	SCTP_PARAM_SUCCESS_REPORT = 1472,
	SCTP_PARAM_ADAPTATION_LAYER_IND = 1728,
	SCTP_PARAM_RESET_OUT_REQUEST = 3328,
	SCTP_PARAM_RESET_IN_REQUEST = 3584,
	SCTP_PARAM_RESET_TSN_REQUEST = 3840,
	SCTP_PARAM_RESET_RESPONSE = 4096,
	SCTP_PARAM_RESET_ADD_OUT_STREAMS = 4352,
	SCTP_PARAM_RESET_ADD_IN_STREAMS = 4608,
};

enum sctp_scope {
	SCTP_SCOPE_GLOBAL = 0,
	SCTP_SCOPE_PRIVATE = 1,
	SCTP_SCOPE_LINK = 2,
	SCTP_SCOPE_LOOPBACK = 3,
	SCTP_SCOPE_UNUSABLE = 4,
};

enum sctp_socket_type {
	SCTP_SOCKET_UDP = 0,
	SCTP_SOCKET_UDP_HIGH_BANDWIDTH = 1,
	SCTP_SOCKET_TCP = 2,
};

enum sctp_state {
	SCTP_STATE_CLOSED = 0,
	SCTP_STATE_COOKIE_WAIT = 1,
	SCTP_STATE_COOKIE_ECHOED = 2,
	SCTP_STATE_ESTABLISHED = 3,
	SCTP_STATE_SHUTDOWN_PENDING = 4,
	SCTP_STATE_SHUTDOWN_SENT = 5,
	SCTP_STATE_SHUTDOWN_RECEIVED = 6,
	SCTP_STATE_SHUTDOWN_ACK_SENT = 7,
};

enum sdp_header_types {
	SDP_HDR_UNSPEC = 0,
	SDP_HDR_VERSION = 1,
	SDP_HDR_OWNER = 2,
	SDP_HDR_CONNECTION = 3,
	SDP_HDR_MEDIA = 4,
};

enum sel_inos {
	SEL_ROOT_INO = 2,
	SEL_LOAD = 3,
	SEL_ENFORCE = 4,
	SEL_CONTEXT = 5,
	SEL_ACCESS = 6,
	SEL_CREATE = 7,
	SEL_RELABEL = 8,
	SEL_USER = 9,
	SEL_POLICYVERS = 10,
	SEL_COMMIT_BOOLS = 11,
	SEL_MLS = 12,
	SEL_DISABLE = 13,
	SEL_MEMBER = 14,
	SEL_CHECKREQPROT = 15,
	SEL_COMPAT_NET = 16,
	SEL_REJECT_UNKNOWN = 17,
	SEL_DENY_UNKNOWN = 18,
	SEL_STATUS = 19,
	SEL_POLICY = 20,
	SEL_VALIDATE_TRANS = 21,
	SEL_INO_NEXT = 22,
};

enum selinux_nlgroups {
	SELNLGRP_NONE = 0,
	SELNLGRP_AVC = 1,
	__SELNLGRP_MAX = 2,
};

enum ser {
	SER_REQUIRED = 1,
	NO_SER = 2,
};

enum serio_event_type {
	SERIO_RESCAN_PORT = 0,
	SERIO_RECONNECT_PORT = 1,
	SERIO_RECONNECT_SUBTREE = 2,
	SERIO_REGISTER_PORT = 3,
	SERIO_ATTACH_DRIVER = 4,
};

enum set_event_iter_type {
	SET_EVENT_FILE = 0,
	SET_EVENT_MOD = 1,
};

enum set_key_cmd {
	SET_KEY = 0,
	DISABLE_KEY = 1,
};

enum severity_level {
	MCE_NO_SEVERITY = 0,
	MCE_DEFERRED_SEVERITY = 1,
	MCE_UCNA_SEVERITY = 1,
	MCE_KEEP_SEVERITY = 2,
	MCE_SOME_SEVERITY = 3,
	MCE_AO_SEVERITY = 4,
	MCE_UC_SEVERITY = 5,
	MCE_AR_SEVERITY = 6,
	MCE_PANIC_SEVERITY = 7,
};

enum sgp_type {
	SGP_READ = 0,
	SGP_NOALLOC = 1,
	SGP_CACHE = 2,
	SGP_WRITE = 3,
	SGP_FALLOC = 4,
};

enum shmem_param {
	Opt_gid___9 = 0,
	Opt_huge = 1,
	Opt_mode___7 = 2,
	Opt_mpol = 3,
	Opt_nr_blocks = 4,
	Opt_nr_inodes___2 = 5,
	Opt_size___2 = 6,
	Opt_uid___8 = 7,
	Opt_inode32 = 8,
	Opt_inode64 = 9,
	Opt_noswap = 10,
	Opt_quota___2 = 11,
	Opt_usrquota___2 = 12,
	Opt_grpquota___2 = 13,
	Opt_usrquota_block_hardlimit = 14,
	Opt_usrquota_inode_hardlimit = 15,
	Opt_grpquota_block_hardlimit = 16,
	Opt_grpquota_inode_hardlimit = 17,
	Opt_casefold_version = 18,
	Opt_casefold = 19,
	Opt_strict_encoding = 20,
};

enum show_regs_mode {
	SHOW_REGS_SHORT = 0,
	SHOW_REGS_USER = 1,
	SHOW_REGS_ALL = 2,
};

enum sig_handler {
	HANDLER_CURRENT = 0,
	HANDLER_SIG_DFL = 1,
	HANDLER_EXIT = 2,
};

enum siginfo_layout {
	SIL_KILL = 0,
	SIL_TIMER = 1,
	SIL_POLL = 2,
	SIL_FAULT = 3,
	SIL_FAULT_TRAPNO = 4,
	SIL_FAULT_MCEERR = 5,
	SIL_FAULT_BNDERR = 6,
	SIL_FAULT_PKUERR = 7,
	SIL_FAULT_PERF_EVENT = 8,
	SIL_CHLD = 9,
	SIL_RT = 10,
	SIL_SYS = 11,
};

enum sip_expectation_classes {
	SIP_EXPECT_SIGNALLING = 0,
	SIP_EXPECT_AUDIO = 1,
	SIP_EXPECT_VIDEO = 2,
	SIP_EXPECT_IMAGE = 3,
	__SIP_EXPECT_MAX = 4,
};

enum sip_header_types {
	SIP_HDR_CSEQ = 0,
	SIP_HDR_FROM = 1,
	SIP_HDR_TO = 2,
	SIP_HDR_CONTACT = 3,
	SIP_HDR_VIA_UDP = 4,
	SIP_HDR_VIA_TCP = 5,
	SIP_HDR_EXPIRES = 6,
	SIP_HDR_CONTENT_LENGTH = 7,
	SIP_HDR_CALL_ID = 8,
};

enum sk_action {
	SK_DROP = 0,
	SK_PASS = 1,
};

enum sk_pacing {
	SK_PACING_NONE = 0,
	SK_PACING_NEEDED = 1,
	SK_PACING_FQ = 2,
};

enum sk_psock_state_bits {
	SK_PSOCK_TX_ENABLED = 0,
	SK_PSOCK_RX_STRP_ENABLED = 1,
};

enum sk_rst_reason {
	SK_RST_REASON_NOT_SPECIFIED = 0,
	SK_RST_REASON_NO_SOCKET = 1,
	SK_RST_REASON_TCP_INVALID_ACK_SEQUENCE = 2,
	SK_RST_REASON_TCP_RFC7323_PAWS = 3,
	SK_RST_REASON_TCP_TOO_OLD_ACK = 4,
	SK_RST_REASON_TCP_ACK_UNSENT_DATA = 5,
	SK_RST_REASON_TCP_FLAGS = 6,
	SK_RST_REASON_TCP_OLD_ACK = 7,
	SK_RST_REASON_TCP_ABORT_ON_DATA = 8,
	SK_RST_REASON_TCP_TIMEWAIT_SOCKET = 9,
	SK_RST_REASON_INVALID_SYN = 10,
	SK_RST_REASON_TCP_ABORT_ON_CLOSE = 11,
	SK_RST_REASON_TCP_ABORT_ON_LINGER = 12,
	SK_RST_REASON_TCP_ABORT_ON_MEMORY = 13,
	SK_RST_REASON_TCP_STATE = 14,
	SK_RST_REASON_TCP_KEEPALIVE_TIMEOUT = 15,
	SK_RST_REASON_TCP_DISCONNECT_WITH_DATA = 16,
	SK_RST_REASON_MPTCP_RST_EUNSPEC = 17,
	SK_RST_REASON_MPTCP_RST_EMPTCP = 18,
	SK_RST_REASON_MPTCP_RST_ERESOURCE = 19,
	SK_RST_REASON_MPTCP_RST_EPROHIBIT = 20,
	SK_RST_REASON_MPTCP_RST_EWQ2BIG = 21,
	SK_RST_REASON_MPTCP_RST_EBADPERF = 22,
	SK_RST_REASON_MPTCP_RST_EMIDDLEBOX = 23,
	SK_RST_REASON_ERROR = 24,
	SK_RST_REASON_MAX = 25,
};

enum skb_drop_reason {
	SKB_NOT_DROPPED_YET = 0,
	SKB_CONSUMED = 1,
	SKB_DROP_REASON_NOT_SPECIFIED = 2,
	SKB_DROP_REASON_NO_SOCKET = 3,
	SKB_DROP_REASON_SOCKET_CLOSE = 4,
	SKB_DROP_REASON_SOCKET_FILTER = 5,
	SKB_DROP_REASON_SOCKET_RCVBUFF = 6,
	SKB_DROP_REASON_UNIX_DISCONNECT = 7,
	SKB_DROP_REASON_UNIX_SKIP_OOB = 8,
	SKB_DROP_REASON_PKT_TOO_SMALL = 9,
	SKB_DROP_REASON_TCP_CSUM = 10,
	SKB_DROP_REASON_UDP_CSUM = 11,
	SKB_DROP_REASON_NETFILTER_DROP = 12,
	SKB_DROP_REASON_OTHERHOST = 13,
	SKB_DROP_REASON_IP_CSUM = 14,
	SKB_DROP_REASON_IP_INHDR = 15,
	SKB_DROP_REASON_IP_RPFILTER = 16,
	SKB_DROP_REASON_UNICAST_IN_L2_MULTICAST = 17,
	SKB_DROP_REASON_XFRM_POLICY = 18,
	SKB_DROP_REASON_IP_NOPROTO = 19,
	SKB_DROP_REASON_PROTO_MEM = 20,
	SKB_DROP_REASON_TCP_AUTH_HDR = 21,
	SKB_DROP_REASON_TCP_MD5NOTFOUND = 22,
	SKB_DROP_REASON_TCP_MD5UNEXPECTED = 23,
	SKB_DROP_REASON_TCP_MD5FAILURE = 24,
	SKB_DROP_REASON_TCP_AONOTFOUND = 25,
	SKB_DROP_REASON_TCP_AOUNEXPECTED = 26,
	SKB_DROP_REASON_TCP_AOKEYNOTFOUND = 27,
	SKB_DROP_REASON_TCP_AOFAILURE = 28,
	SKB_DROP_REASON_SOCKET_BACKLOG = 29,
	SKB_DROP_REASON_TCP_FLAGS = 30,
	SKB_DROP_REASON_TCP_ABORT_ON_DATA = 31,
	SKB_DROP_REASON_TCP_ZEROWINDOW = 32,
	SKB_DROP_REASON_TCP_OLD_DATA = 33,
	SKB_DROP_REASON_TCP_OVERWINDOW = 34,
	SKB_DROP_REASON_TCP_OFOMERGE = 35,
	SKB_DROP_REASON_TCP_RFC7323_PAWS = 36,
	SKB_DROP_REASON_TCP_RFC7323_PAWS_ACK = 37,
	SKB_DROP_REASON_TCP_OLD_SEQUENCE = 38,
	SKB_DROP_REASON_TCP_INVALID_SEQUENCE = 39,
	SKB_DROP_REASON_TCP_INVALID_ACK_SEQUENCE = 40,
	SKB_DROP_REASON_TCP_RESET = 41,
	SKB_DROP_REASON_TCP_INVALID_SYN = 42,
	SKB_DROP_REASON_TCP_CLOSE = 43,
	SKB_DROP_REASON_TCP_FASTOPEN = 44,
	SKB_DROP_REASON_TCP_OLD_ACK = 45,
	SKB_DROP_REASON_TCP_TOO_OLD_ACK = 46,
	SKB_DROP_REASON_TCP_ACK_UNSENT_DATA = 47,
	SKB_DROP_REASON_TCP_OFO_QUEUE_PRUNE = 48,
	SKB_DROP_REASON_TCP_OFO_DROP = 49,
	SKB_DROP_REASON_IP_OUTNOROUTES = 50,
	SKB_DROP_REASON_BPF_CGROUP_EGRESS = 51,
	SKB_DROP_REASON_IPV6DISABLED = 52,
	SKB_DROP_REASON_NEIGH_CREATEFAIL = 53,
	SKB_DROP_REASON_NEIGH_FAILED = 54,
	SKB_DROP_REASON_NEIGH_QUEUEFULL = 55,
	SKB_DROP_REASON_NEIGH_DEAD = 56,
	SKB_DROP_REASON_TC_EGRESS = 57,
	SKB_DROP_REASON_SECURITY_HOOK = 58,
	SKB_DROP_REASON_QDISC_DROP = 59,
	SKB_DROP_REASON_QDISC_OVERLIMIT = 60,
	SKB_DROP_REASON_QDISC_CONGESTED = 61,
	SKB_DROP_REASON_CAKE_FLOOD = 62,
	SKB_DROP_REASON_FQ_BAND_LIMIT = 63,
	SKB_DROP_REASON_FQ_HORIZON_LIMIT = 64,
	SKB_DROP_REASON_FQ_FLOW_LIMIT = 65,
	SKB_DROP_REASON_CPU_BACKLOG = 66,
	SKB_DROP_REASON_XDP = 67,
	SKB_DROP_REASON_TC_INGRESS = 68,
	SKB_DROP_REASON_UNHANDLED_PROTO = 69,
	SKB_DROP_REASON_SKB_CSUM = 70,
	SKB_DROP_REASON_SKB_GSO_SEG = 71,
	SKB_DROP_REASON_SKB_UCOPY_FAULT = 72,
	SKB_DROP_REASON_DEV_HDR = 73,
	SKB_DROP_REASON_DEV_READY = 74,
	SKB_DROP_REASON_FULL_RING = 75,
	SKB_DROP_REASON_NOMEM = 76,
	SKB_DROP_REASON_HDR_TRUNC = 77,
	SKB_DROP_REASON_TAP_FILTER = 78,
	SKB_DROP_REASON_TAP_TXFILTER = 79,
	SKB_DROP_REASON_ICMP_CSUM = 80,
	SKB_DROP_REASON_INVALID_PROTO = 81,
	SKB_DROP_REASON_IP_INADDRERRORS = 82,
	SKB_DROP_REASON_IP_INNOROUTES = 83,
	SKB_DROP_REASON_IP_LOCAL_SOURCE = 84,
	SKB_DROP_REASON_IP_INVALID_SOURCE = 85,
	SKB_DROP_REASON_IP_LOCALNET = 86,
	SKB_DROP_REASON_IP_INVALID_DEST = 87,
	SKB_DROP_REASON_PKT_TOO_BIG = 88,
	SKB_DROP_REASON_DUP_FRAG = 89,
	SKB_DROP_REASON_FRAG_REASM_TIMEOUT = 90,
	SKB_DROP_REASON_FRAG_TOO_FAR = 91,
	SKB_DROP_REASON_TCP_MINTTL = 92,
	SKB_DROP_REASON_IPV6_BAD_EXTHDR = 93,
	SKB_DROP_REASON_IPV6_NDISC_FRAG = 94,
	SKB_DROP_REASON_IPV6_NDISC_HOP_LIMIT = 95,
	SKB_DROP_REASON_IPV6_NDISC_BAD_CODE = 96,
	SKB_DROP_REASON_IPV6_NDISC_BAD_OPTIONS = 97,
	SKB_DROP_REASON_IPV6_NDISC_NS_OTHERHOST = 98,
	SKB_DROP_REASON_QUEUE_PURGE = 99,
	SKB_DROP_REASON_TC_COOKIE_ERROR = 100,
	SKB_DROP_REASON_PACKET_SOCK_ERROR = 101,
	SKB_DROP_REASON_TC_CHAIN_NOTFOUND = 102,
	SKB_DROP_REASON_TC_RECLASSIFY_LOOP = 103,
	SKB_DROP_REASON_VXLAN_INVALID_HDR = 104,
	SKB_DROP_REASON_VXLAN_VNI_NOT_FOUND = 105,
	SKB_DROP_REASON_MAC_INVALID_SOURCE = 106,
	SKB_DROP_REASON_VXLAN_ENTRY_EXISTS = 107,
	SKB_DROP_REASON_NO_TX_TARGET = 108,
	SKB_DROP_REASON_IP_TUNNEL_ECN = 109,
	SKB_DROP_REASON_TUNNEL_TXINFO = 110,
	SKB_DROP_REASON_LOCAL_MAC = 111,
	SKB_DROP_REASON_ARP_PVLAN_DISABLE = 112,
	SKB_DROP_REASON_MAC_IEEE_MAC_CONTROL = 113,
	SKB_DROP_REASON_BRIDGE_INGRESS_STP_STATE = 114,
	SKB_DROP_REASON_MAX = 115,
	SKB_DROP_REASON_SUBSYS_MASK = 4294901760,
};

enum skb_drop_reason_subsys {
	SKB_DROP_REASON_SUBSYS_CORE = 0,
	SKB_DROP_REASON_SUBSYS_MAC80211_UNUSABLE = 1,
	SKB_DROP_REASON_SUBSYS_MAC80211_MONITOR = 2,
	SKB_DROP_REASON_SUBSYS_OPENVSWITCH = 3,
	SKB_DROP_REASON_SUBSYS_NUM = 4,
};

enum skb_ext_id {
	SKB_EXT_SEC_PATH = 0,
	SKB_EXT_NUM = 1,
};

enum skb_tstamp_type {
	SKB_CLOCK_REALTIME = 0,
	SKB_CLOCK_MONOTONIC = 1,
	SKB_CLOCK_TAI = 2,
	__SKB_CLOCK_MAX = 2,
};

enum skl_power_gate {
	SKL_PG0 = 0,
	SKL_PG1 = 1,
	SKL_PG2 = 2,
	ICL_PG3 = 3,
	ICL_PG4 = 4,
};

enum sknetlink_groups {
	SKNLGRP_NONE = 0,
	SKNLGRP_INET_TCP_DESTROY = 1,
	SKNLGRP_INET_UDP_DESTROY = 2,
	SKNLGRP_INET6_TCP_DESTROY = 3,
	SKNLGRP_INET6_UDP_DESTROY = 4,
	__SKNLGRP_MAX = 5,
};

enum slab_stat_type {
	SL_ALL = 0,
	SL_PARTIAL = 1,
	SL_CPU = 2,
	SL_OBJECTS = 3,
	SL_TOTAL = 4,
};

enum slab_state {
	DOWN = 0,
	PARTIAL = 1,
	UP = 2,
	FULL = 3,
};

enum slpc_event_id {
	SLPC_EVENT_RESET = 0,
	SLPC_EVENT_SHUTDOWN = 1,
	SLPC_EVENT_PLATFORM_INFO_CHANGE = 2,
	SLPC_EVENT_DISPLAY_MODE_CHANGE = 3,
	SLPC_EVENT_FLIP_COMPLETE = 4,
	SLPC_EVENT_QUERY_TASK_STATE = 5,
	SLPC_EVENT_PARAMETER_SET = 6,
	SLPC_EVENT_PARAMETER_UNSET = 7,
};

enum slpc_global_state {
	SLPC_GLOBAL_STATE_NOT_RUNNING = 0,
	SLPC_GLOBAL_STATE_INITIALIZING = 1,
	SLPC_GLOBAL_STATE_RESETTING = 2,
	SLPC_GLOBAL_STATE_RUNNING = 3,
	SLPC_GLOBAL_STATE_SHUTTING_DOWN = 4,
	SLPC_GLOBAL_STATE_ERROR = 5,
};

enum slpc_media_ratio_mode {
	SLPC_MEDIA_RATIO_MODE_DYNAMIC_CONTROL = 0,
	SLPC_MEDIA_RATIO_MODE_FIXED_ONE_TO_ONE = 1,
	SLPC_MEDIA_RATIO_MODE_FIXED_ONE_TO_TWO = 2,
};

enum slpc_param_id {
	SLPC_PARAM_TASK_ENABLE_GTPERF = 0,
	SLPC_PARAM_TASK_DISABLE_GTPERF = 1,
	SLPC_PARAM_TASK_ENABLE_BALANCER = 2,
	SLPC_PARAM_TASK_DISABLE_BALANCER = 3,
	SLPC_PARAM_TASK_ENABLE_DCC = 4,
	SLPC_PARAM_TASK_DISABLE_DCC = 5,
	SLPC_PARAM_GLOBAL_MIN_GT_UNSLICE_FREQ_MHZ = 6,
	SLPC_PARAM_GLOBAL_MAX_GT_UNSLICE_FREQ_MHZ = 7,
	SLPC_PARAM_GLOBAL_MIN_GT_SLICE_FREQ_MHZ = 8,
	SLPC_PARAM_GLOBAL_MAX_GT_SLICE_FREQ_MHZ = 9,
	SLPC_PARAM_GTPERF_THRESHOLD_MAX_FPS = 10,
	SLPC_PARAM_GLOBAL_DISABLE_GT_FREQ_MANAGEMENT = 11,
	SLPC_PARAM_GTPERF_ENABLE_FRAMERATE_STALLING = 12,
	SLPC_PARAM_GLOBAL_DISABLE_RC6_MODE_CHANGE = 13,
	SLPC_PARAM_GLOBAL_OC_UNSLICE_FREQ_MHZ = 14,
	SLPC_PARAM_GLOBAL_OC_SLICE_FREQ_MHZ = 15,
	SLPC_PARAM_GLOBAL_ENABLE_IA_GT_BALANCING = 16,
	SLPC_PARAM_GLOBAL_ENABLE_ADAPTIVE_BURST_TURBO = 17,
	SLPC_PARAM_GLOBAL_ENABLE_EVAL_MODE = 18,
	SLPC_PARAM_GLOBAL_ENABLE_BALANCER_IN_NON_GAMING_MODE = 19,
	SLPC_PARAM_GLOBAL_RT_MODE_TURBO_FREQ_DELTA_MHZ = 20,
	SLPC_PARAM_PWRGATE_RC_MODE = 21,
	SLPC_PARAM_EDR_MODE_COMPUTE_TIMEOUT_MS = 22,
	SLPC_PARAM_EDR_QOS_FREQ_MHZ = 23,
	SLPC_PARAM_MEDIA_FF_RATIO_MODE = 24,
	SLPC_PARAM_ENABLE_IA_FREQ_LIMITING = 25,
	SLPC_PARAM_STRATEGIES = 26,
	SLPC_PARAM_POWER_PROFILE = 27,
	SLPC_PARAM_IGNORE_EFFICIENT_FREQUENCY = 28,
	SLPC_MAX_PARAM = 32,
};

enum smbios_attr_enum {
	SMBIOS_ATTR_NONE = 0,
	SMBIOS_ATTR_LABEL_SHOW = 1,
	SMBIOS_ATTR_INSTANCE_SHOW = 2,
};

enum smca_bank_types {
	SMCA_LS = 0,
	SMCA_LS_V2 = 1,
	SMCA_IF = 2,
	SMCA_L2_CACHE = 3,
	SMCA_DE = 4,
	SMCA_RESERVED = 5,
	SMCA_EX = 6,
	SMCA_FP = 7,
	SMCA_L3_CACHE = 8,
	SMCA_CS = 9,
	SMCA_CS_V2 = 10,
	SMCA_PIE = 11,
	SMCA_UMC = 12,
	SMCA_UMC_V2 = 13,
	SMCA_MA_LLC = 14,
	SMCA_PB = 15,
	SMCA_PSP = 16,
	SMCA_PSP_V2 = 17,
	SMCA_SMU = 18,
	SMCA_SMU_V2 = 19,
	SMCA_MP5 = 20,
	SMCA_MPDMA = 21,
	SMCA_NBIO = 22,
	SMCA_PCIE = 23,
	SMCA_PCIE_V2 = 24,
	SMCA_XGMI_PCS = 25,
	SMCA_NBIF = 26,
	SMCA_SHUB = 27,
	SMCA_SATA = 28,
	SMCA_USB = 29,
	SMCA_USR_DP = 30,
	SMCA_USR_CP = 31,
	SMCA_GMI_PCS = 32,
	SMCA_XGMI_PHY = 33,
	SMCA_WAFL_PHY = 34,
	SMCA_GMI_PHY = 35,
	N_SMCA_BANK_TYPES = 36,
};

enum snd_compr_direction {
	SND_COMPRESS_PLAYBACK = 0,
	SND_COMPRESS_CAPTURE = 1,
	SND_COMPRESS_ACCEL = 2,
};

enum snd_ctl_add_mode {
	CTL_ADD_EXCLUSIVE = 0,
	CTL_REPLACE = 1,
	CTL_ADD_ON_REPLACE = 2,
};

enum snd_device_state {
	SNDRV_DEV_BUILD = 0,
	SNDRV_DEV_REGISTERED = 1,
	SNDRV_DEV_DISCONNECTED = 2,
};

enum snd_device_type {
	SNDRV_DEV_LOWLEVEL = 0,
	SNDRV_DEV_INFO = 1,
	SNDRV_DEV_BUS = 2,
	SNDRV_DEV_CODEC = 3,
	SNDRV_DEV_PCM = 4,
	SNDRV_DEV_COMPRESS = 5,
	SNDRV_DEV_RAWMIDI = 6,
	SNDRV_DEV_TIMER = 7,
	SNDRV_DEV_SEQUENCER = 8,
	SNDRV_DEV_HWDEP = 9,
	SNDRV_DEV_JACK = 10,
	SNDRV_DEV_CONTROL = 11,
};

enum snd_dma_sync_mode {
	SNDRV_DMA_SYNC_CPU = 0,
	SNDRV_DMA_SYNC_DEVICE = 1,
};

enum snd_jack_types {
	SND_JACK_HEADPHONE = 1,
	SND_JACK_MICROPHONE = 2,
	SND_JACK_HEADSET = 3,
	SND_JACK_LINEOUT = 4,
	SND_JACK_MECHANICAL = 8,
	SND_JACK_VIDEOOUT = 16,
	SND_JACK_AVOUT = 20,
	SND_JACK_LINEIN = 32,
	SND_JACK_BTN_0 = 16384,
	SND_JACK_BTN_1 = 8192,
	SND_JACK_BTN_2 = 4096,
	SND_JACK_BTN_3 = 2048,
	SND_JACK_BTN_4 = 1024,
	SND_JACK_BTN_5 = 512,
};

enum sndrv_ctl_event_type {
	SNDRV_CTL_EVENT_ELEM = 0,
	SNDRV_CTL_EVENT_LAST = 0,
};

enum snoop_when {
	SUBMIT = 0,
	COMPLETE = 1,
};

enum sock_flags {
	SOCK_DEAD = 0,
	SOCK_DONE = 1,
	SOCK_URGINLINE = 2,
	SOCK_KEEPOPEN = 3,
	SOCK_LINGER = 4,
	SOCK_DESTROY = 5,
	SOCK_BROADCAST = 6,
	SOCK_TIMESTAMP = 7,
	SOCK_ZAPPED = 8,
	SOCK_USE_WRITE_QUEUE = 9,
	SOCK_DBG = 10,
	SOCK_RCVTSTAMP = 11,
	SOCK_RCVTSTAMPNS = 12,
	SOCK_LOCALROUTE = 13,
	SOCK_MEMALLOC = 14,
	SOCK_TIMESTAMPING_RX_SOFTWARE = 15,
	SOCK_FASYNC = 16,
	SOCK_RXQ_OVFL = 17,
	SOCK_ZEROCOPY = 18,
	SOCK_WIFI_STATUS = 19,
	SOCK_NOFCS = 20,
	SOCK_FILTER_LOCKED = 21,
	SOCK_SELECT_ERR_QUEUE = 22,
	SOCK_RCU_FREE = 23,
	SOCK_TXTIME = 24,
	SOCK_XDP = 25,
	SOCK_TSTAMP_NEW = 26,
	SOCK_RCVMARK = 27,
	SOCK_RCVPRIORITY = 28,
};

enum sock_shutdown_cmd {
	SHUT_RD = 0,
	SHUT_WR = 1,
	SHUT_RDWR = 2,
};

enum sock_type {
	SOCK_STREAM = 1,
	SOCK_DGRAM = 2,
	SOCK_RAW = 3,
	SOCK_RDM = 4,
	SOCK_SEQPACKET = 5,
	SOCK_DCCP = 6,
	SOCK_PACKET = 10,
};

enum sony_worker {
	SONY_WORKER_STATE = 0,
};

enum special_kfunc_type {
	KF_bpf_obj_new_impl = 0,
	KF_bpf_obj_drop_impl = 1,
	KF_bpf_refcount_acquire_impl = 2,
	KF_bpf_list_push_front_impl = 3,
	KF_bpf_list_push_back_impl = 4,
	KF_bpf_list_pop_front = 5,
	KF_bpf_list_pop_back = 6,
	KF_bpf_cast_to_kern_ctx = 7,
	KF_bpf_rdonly_cast = 8,
	KF_bpf_rcu_read_lock = 9,
	KF_bpf_rcu_read_unlock = 10,
	KF_bpf_rbtree_remove = 11,
	KF_bpf_rbtree_add_impl = 12,
	KF_bpf_rbtree_first = 13,
	KF_bpf_dynptr_from_skb = 14,
	KF_bpf_dynptr_from_xdp = 15,
	KF_bpf_dynptr_slice = 16,
	KF_bpf_dynptr_slice_rdwr = 17,
	KF_bpf_dynptr_clone = 18,
	KF_bpf_percpu_obj_new_impl = 19,
	KF_bpf_percpu_obj_drop_impl = 20,
	KF_bpf_throw = 21,
	KF_bpf_wq_set_callback_impl = 22,
	KF_bpf_preempt_disable = 23,
	KF_bpf_preempt_enable = 24,
	KF_bpf_iter_css_task_new = 25,
	KF_bpf_session_cookie = 26,
	KF_bpf_get_kmem_cache = 27,
	KF_bpf_local_irq_save = 28,
	KF_bpf_local_irq_restore = 29,
	KF_bpf_iter_num_new = 30,
	KF_bpf_iter_num_next = 31,
	KF_bpf_iter_num_destroy = 32,
};

enum spectre_v1_mitigation {
	SPECTRE_V1_MITIGATION_NONE = 0,
	SPECTRE_V1_MITIGATION_AUTO = 1,
};

enum spectre_v2_mitigation {
	SPECTRE_V2_NONE = 0,
	SPECTRE_V2_RETPOLINE = 1,
	SPECTRE_V2_LFENCE = 2,
	SPECTRE_V2_EIBRS = 3,
	SPECTRE_V2_EIBRS_RETPOLINE = 4,
	SPECTRE_V2_EIBRS_LFENCE = 5,
	SPECTRE_V2_IBRS = 6,
};

enum spectre_v2_mitigation_cmd {
	SPECTRE_V2_CMD_NONE = 0,
	SPECTRE_V2_CMD_AUTO = 1,
	SPECTRE_V2_CMD_FORCE = 2,
	SPECTRE_V2_CMD_RETPOLINE = 3,
	SPECTRE_V2_CMD_RETPOLINE_GENERIC = 4,
	SPECTRE_V2_CMD_RETPOLINE_LFENCE = 5,
	SPECTRE_V2_CMD_EIBRS = 6,
	SPECTRE_V2_CMD_EIBRS_RETPOLINE = 7,
	SPECTRE_V2_CMD_EIBRS_LFENCE = 8,
	SPECTRE_V2_CMD_IBRS = 9,
};

enum spectre_v2_user_cmd {
	SPECTRE_V2_USER_CMD_NONE = 0,
	SPECTRE_V2_USER_CMD_AUTO = 1,
	SPECTRE_V2_USER_CMD_FORCE = 2,
	SPECTRE_V2_USER_CMD_PRCTL = 3,
	SPECTRE_V2_USER_CMD_PRCTL_IBPB = 4,
	SPECTRE_V2_USER_CMD_SECCOMP = 5,
	SPECTRE_V2_USER_CMD_SECCOMP_IBPB = 6,
};

enum spectre_v2_user_mitigation {
	SPECTRE_V2_USER_NONE = 0,
	SPECTRE_V2_USER_STRICT = 1,
	SPECTRE_V2_USER_STRICT_PREFERRED = 2,
	SPECTRE_V2_USER_PRCTL = 3,
	SPECTRE_V2_USER_SECCOMP = 4,
};

enum spi_compare_returns {
	SPI_COMPARE_SUCCESS = 0,
	SPI_COMPARE_FAILURE = 1,
	SPI_COMPARE_SKIP_TEST = 2,
};

enum spi_signal_type {
	SPI_SIGNAL_UNKNOWN = 1,
	SPI_SIGNAL_SE = 2,
	SPI_SIGNAL_LVD = 3,
	SPI_SIGNAL_HVD = 4,
};

enum split_lock_detect_state {
	sld_off = 0,
	sld_warn = 1,
	sld_fatal = 2,
	sld_ratelimit = 3,
};

enum srbds_mitigations {
	SRBDS_MITIGATION_OFF = 0,
	SRBDS_MITIGATION_UCODE_NEEDED = 1,
	SRBDS_MITIGATION_FULL = 2,
	SRBDS_MITIGATION_TSX_OFF = 3,
	SRBDS_MITIGATION_HYPERVISOR = 4,
};

enum srso_mitigation {
	SRSO_MITIGATION_NONE = 0,
	SRSO_MITIGATION_UCODE_NEEDED = 1,
	SRSO_MITIGATION_SAFE_RET_UCODE_NEEDED = 2,
	SRSO_MITIGATION_MICROCODE = 3,
	SRSO_MITIGATION_SAFE_RET = 4,
	SRSO_MITIGATION_IBPB = 5,
	SRSO_MITIGATION_IBPB_ON_VMEXIT = 6,
};

enum srso_mitigation_cmd {
	SRSO_CMD_OFF = 0,
	SRSO_CMD_MICROCODE = 1,
	SRSO_CMD_SAFE_RET = 2,
	SRSO_CMD_IBPB = 3,
	SRSO_CMD_IBPB_ON_VMEXIT = 4,
};

enum ssb_mitigation {
	SPEC_STORE_BYPASS_NONE = 0,
	SPEC_STORE_BYPASS_DISABLE = 1,
	SPEC_STORE_BYPASS_PRCTL = 2,
	SPEC_STORE_BYPASS_SECCOMP = 3,
};

enum ssb_mitigation_cmd {
	SPEC_STORE_BYPASS_CMD_NONE = 0,
	SPEC_STORE_BYPASS_CMD_AUTO = 1,
	SPEC_STORE_BYPASS_CMD_ON = 2,
	SPEC_STORE_BYPASS_CMD_PRCTL = 3,
	SPEC_STORE_BYPASS_CMD_SECCOMP = 4,
};

enum sta_link_apply_mode {
	STA_LINK_MODE_NEW = 0,
	STA_LINK_MODE_STA_MODIFY = 1,
	STA_LINK_MODE_LINK_MODIFY = 2,
};

enum sta_notify_cmd {
	STA_NOTIFY_SLEEP = 0,
	STA_NOTIFY_AWAKE = 1,
};

enum sta_stats_type {
	STA_STATS_RATE_TYPE_INVALID = 0,
	STA_STATS_RATE_TYPE_LEGACY = 1,
	STA_STATS_RATE_TYPE_HT = 2,
	STA_STATS_RATE_TYPE_VHT = 3,
	STA_STATS_RATE_TYPE_HE = 4,
	STA_STATS_RATE_TYPE_S1G = 5,
	STA_STATS_RATE_TYPE_EHT = 6,
};

enum stack_type {
	STACK_TYPE_UNKNOWN = 0,
	STACK_TYPE_TASK = 1,
	STACK_TYPE_IRQ = 2,
	STACK_TYPE_SOFTIRQ = 3,
	STACK_TYPE_ENTRY = 4,
	STACK_TYPE_EXCEPTION = 5,
	STACK_TYPE_EXCEPTION_LAST = 10,
};

enum stat_group {
	STAT_READ = 0,
	STAT_WRITE = 1,
	STAT_DISCARD = 2,
	STAT_FLUSH = 3,
	NR_STAT_GROUPS = 4,
};

enum stat_item {
	ALLOC_FASTPATH = 0,
	ALLOC_SLOWPATH = 1,
	FREE_FASTPATH = 2,
	FREE_SLOWPATH = 3,
	FREE_FROZEN = 4,
	FREE_ADD_PARTIAL = 5,
	FREE_REMOVE_PARTIAL = 6,
	ALLOC_FROM_PARTIAL = 7,
	ALLOC_SLAB = 8,
	ALLOC_REFILL = 9,
	ALLOC_NODE_MISMATCH = 10,
	FREE_SLAB = 11,
	CPUSLAB_FLUSH = 12,
	DEACTIVATE_FULL = 13,
	DEACTIVATE_EMPTY = 14,
	DEACTIVATE_TO_HEAD = 15,
	DEACTIVATE_TO_TAIL = 16,
	DEACTIVATE_REMOTE_FREES = 17,
	DEACTIVATE_BYPASS = 18,
	ORDER_FALLBACK = 19,
	CMPXCHG_DOUBLE_CPU_FAIL = 20,
	CMPXCHG_DOUBLE_FAIL = 21,
	CPU_PARTIAL_ALLOC = 22,
	CPU_PARTIAL_FREE = 23,
	CPU_PARTIAL_NODE = 24,
	CPU_PARTIAL_DRAIN = 25,
	NR_SLUB_STAT_ITEMS = 26,
};

enum state {
	Start = 0,
	Collect = 1,
	GotHeader = 2,
	SkipIt = 3,
	GotName = 4,
	CopyFile = 5,
	GotSymlink = 6,
	Reset = 7,
};

enum station_parameters_apply_mask {
	STATION_PARAM_APPLY_UAPSD = 1,
	STATION_PARAM_APPLY_CAPABILITY = 2,
	STATION_PARAM_APPLY_PLINK_STATE = 4,
};

enum status_css {
	CSS_TCPUDPCSOK = 128,
	CSS_ISUDP = 64,
	CSS_ISTCP = 32,
	CSS_ISIPFRAG = 16,
	CSS_ISIPV6 = 8,
	CSS_IPV4CSUMOK = 4,
	CSS_ISIPV4 = 2,
	CSS_LINK_BIT = 1,
};

enum store_type {
	wr_invalid = 0,
	wr_new_root = 1,
	wr_store_root = 2,
	wr_exact_fit = 3,
	wr_spanning_store = 4,
	wr_split_store = 5,
	wr_rebalance = 6,
	wr_append = 7,
	wr_node_store = 8,
	wr_slot_store = 9,
};

enum string_size_units {
	STRING_UNITS_10 = 0,
	STRING_UNITS_2 = 1,
	STRING_UNITS_MASK = 1,
	STRING_UNITS_NO_SPACE = 1073741824,
	STRING_UNITS_NO_BYTES = 2147483648,
};

enum subpixel_order {
	SubPixelUnknown = 0,
	SubPixelHorizontalRGB = 1,
	SubPixelHorizontalBGR = 2,
	SubPixelVerticalRGB = 3,
	SubPixelVerticalBGR = 4,
	SubPixelNone = 5,
};

enum sum_check_bits {
	SUM_CHECK_P = 0,
	SUM_CHECK_Q = 1,
};

enum sum_check_flags {
	SUM_CHECK_P_RESULT = 1,
	SUM_CHECK_Q_RESULT = 2,
};

enum support_mode {
	ALLOW_LEGACY = 0,
	DENY_LEGACY = 1,
};

enum survey_info_flags {
	SURVEY_INFO_NOISE_DBM = 1,
	SURVEY_INFO_IN_USE = 2,
	SURVEY_INFO_TIME = 4,
	SURVEY_INFO_TIME_BUSY = 8,
	SURVEY_INFO_TIME_EXT_BUSY = 16,
	SURVEY_INFO_TIME_RX = 32,
	SURVEY_INFO_TIME_TX = 64,
	SURVEY_INFO_TIME_SCAN = 128,
	SURVEY_INFO_TIME_BSS_RX = 256,
};

enum suspend_mode {
	PRESUSPEND = 0,
	PRESUSPEND_UNDO = 1,
	POSTSUSPEND = 2,
};

enum suspend_stat_step {
	SUSPEND_WORKING = 0,
	SUSPEND_FREEZE = 1,
	SUSPEND_PREPARE = 2,
	SUSPEND_SUSPEND = 3,
	SUSPEND_SUSPEND_LATE = 4,
	SUSPEND_SUSPEND_NOIRQ = 5,
	SUSPEND_RESUME_NOIRQ = 6,
	SUSPEND_RESUME_EARLY = 7,
	SUSPEND_RESUME = 8,
};

enum svc_auth_status {
	SVC_GARBAGE = 1,
	SVC_SYSERR = 2,
	SVC_VALID = 3,
	SVC_NEGATIVE = 4,
	SVC_OK = 5,
	SVC_DROP = 6,
	SVC_CLOSE = 7,
	SVC_DENIED = 8,
	SVC_PENDING = 9,
	SVC_COMPLETE = 10,
};

enum sw_activity {
	OFF = 0,
	BLINK_ON = 1,
	BLINK_OFF = 2,
};

enum swap_cluster_flags {
	CLUSTER_FLAG_NONE = 0,
	CLUSTER_FLAG_FREE = 1,
	CLUSTER_FLAG_NONFULL = 2,
	CLUSTER_FLAG_FRAG = 3,
	CLUSTER_FLAG_USABLE = 3,
	CLUSTER_FLAG_FULL = 4,
	CLUSTER_FLAG_DISCARD = 5,
	CLUSTER_FLAG_MAX = 6,
};

enum switch_power_state {
	DRM_SWITCH_POWER_ON = 0,
	DRM_SWITCH_POWER_OFF = 1,
	DRM_SWITCH_POWER_CHANGING = 2,
	DRM_SWITCH_POWER_DYNAMIC_OFF = 3,
};

enum synaptics_pkt_type {
	SYN_NEWABS = 0,
	SYN_NEWABS_STRICT = 1,
	SYN_NEWABS_RELAXED = 2,
	SYN_OLDABS = 3,
};

enum sync {
	DEFAULTSYNC = 0,
	NOSYNC = 1,
	FORCESYNC = 2,
};

enum sync_action {
	ACTION_RESYNC = 0,
	ACTION_RECOVER = 1,
	ACTION_CHECK = 2,
	ACTION_REPAIR = 3,
	ACTION_RESHAPE = 4,
	ACTION_FROZEN = 5,
	ACTION_IDLE = 6,
	NR_SYNC_ACTIONS = 7,
};

enum sys_off_mode {
	SYS_OFF_MODE_POWER_OFF_PREPARE = 0,
	SYS_OFF_MODE_POWER_OFF = 1,
	SYS_OFF_MODE_RESTART_PREPARE = 2,
	SYS_OFF_MODE_RESTART = 3,
};

enum syscall_work_bit {
	SYSCALL_WORK_BIT_SECCOMP = 0,
	SYSCALL_WORK_BIT_SYSCALL_TRACEPOINT = 1,
	SYSCALL_WORK_BIT_SYSCALL_TRACE = 2,
	SYSCALL_WORK_BIT_SYSCALL_EMU = 3,
	SYSCALL_WORK_BIT_SYSCALL_AUDIT = 4,
	SYSCALL_WORK_BIT_SYSCALL_USER_DISPATCH = 5,
	SYSCALL_WORK_BIT_SYSCALL_EXIT_TRAP = 6,
};

enum sysctl_writes_mode {
	SYSCTL_WRITES_LEGACY = -1,
	SYSCTL_WRITES_WARN = 0,
	SYSCTL_WRITES_STRICT = 1,
};

enum system_states {
	SYSTEM_BOOTING = 0,
	SYSTEM_SCHEDULING = 1,
	SYSTEM_FREEING_INITMEM = 2,
	SYSTEM_RUNNING = 3,
	SYSTEM_HALT = 4,
	SYSTEM_POWER_OFF = 5,
	SYSTEM_RESTART = 6,
	SYSTEM_SUSPEND = 7,
};

enum t10_dif_type {
	T10_PI_TYPE0_PROTECTION = 0,
	T10_PI_TYPE1_PROTECTION = 1,
	T10_PI_TYPE2_PROTECTION = 2,
	T10_PI_TYPE3_PROTECTION = 3,
};

enum taa_mitigations {
	TAA_MITIGATION_OFF = 0,
	TAA_MITIGATION_UCODE_NEEDED = 1,
	TAA_MITIGATION_VERW = 2,
	TAA_MITIGATION_TSX_DISABLED = 3,
};

enum task_work_notify_mode {
	TWA_NONE = 0,
	TWA_RESUME = 1,
	TWA_SIGNAL = 2,
	TWA_SIGNAL_NO_IPI = 3,
	TWA_NMI_CURRENT = 4,
};

enum tc_fifo_command {
	TC_FIFO_REPLACE = 0,
	TC_FIFO_DESTROY = 1,
	TC_FIFO_STATS = 2,
};

enum tc_link_layer {
	TC_LINKLAYER_UNAWARE = 0,
	TC_LINKLAYER_ETHERNET = 1,
	TC_LINKLAYER_ATM = 2,
};

enum tc_mq_command {
	TC_MQ_CREATE = 0,
	TC_MQ_DESTROY = 1,
	TC_MQ_STATS = 2,
	TC_MQ_GRAFT = 3,
};

enum tc_port {
	TC_PORT_NONE = -1,
	TC_PORT_1 = 0,
	TC_PORT_2 = 1,
	TC_PORT_3 = 2,
	TC_PORT_4 = 3,
	TC_PORT_5 = 4,
	TC_PORT_6 = 5,
	I915_MAX_TC_PORTS = 6,
};

enum tc_port_mode {
	TC_PORT_DISCONNECTED = 0,
	TC_PORT_TBT_ALT = 1,
	TC_PORT_DP_ALT = 2,
	TC_PORT_LEGACY = 3,
};

enum tc_root_command {
	TC_ROOT_GRAFT = 0,
};

enum tc_setup_type {
	TC_QUERY_CAPS = 0,
	TC_SETUP_QDISC_MQPRIO = 1,
	TC_SETUP_CLSU32 = 2,
	TC_SETUP_CLSFLOWER = 3,
	TC_SETUP_CLSMATCHALL = 4,
	TC_SETUP_CLSBPF = 5,
	TC_SETUP_BLOCK = 6,
	TC_SETUP_QDISC_CBS = 7,
	TC_SETUP_QDISC_RED = 8,
	TC_SETUP_QDISC_PRIO = 9,
	TC_SETUP_QDISC_MQ = 10,
	TC_SETUP_QDISC_ETF = 11,
	TC_SETUP_ROOT_QDISC = 12,
	TC_SETUP_QDISC_GRED = 13,
	TC_SETUP_QDISC_TAPRIO = 14,
	TC_SETUP_FT = 15,
	TC_SETUP_QDISC_ETS = 16,
	TC_SETUP_QDISC_TBF = 17,
	TC_SETUP_QDISC_FIFO = 18,
	TC_SETUP_QDISC_HTB = 19,
	TC_SETUP_ACT = 20,
};

enum tca_id {
	TCA_ID_UNSPEC = 0,
	TCA_ID_POLICE = 1,
	TCA_ID_GACT = 5,
	TCA_ID_IPT = 6,
	TCA_ID_PEDIT = 7,
	TCA_ID_MIRRED = 8,
	TCA_ID_NAT = 9,
	TCA_ID_XT = 10,
	TCA_ID_SKBEDIT = 11,
	TCA_ID_VLAN = 12,
	TCA_ID_BPF = 13,
	TCA_ID_CONNMARK = 14,
	TCA_ID_SKBMOD = 15,
	TCA_ID_CSUM = 16,
	TCA_ID_TUNNEL_KEY = 17,
	TCA_ID_SIMP = 22,
	TCA_ID_IFE = 25,
	TCA_ID_SAMPLE = 26,
	TCA_ID_CTINFO = 27,
	TCA_ID_MPLS = 28,
	TCA_ID_CT = 29,
	TCA_ID_GATE = 30,
	__TCA_ID_MAX = 255,
};

enum tcf_proto_ops_flags {
	TCF_PROTO_OPS_DOIT_UNLOCKED = 1,
};

enum tcp_bit_set {
	TCP_SYN_SET = 0,
	TCP_SYNACK_SET = 1,
	TCP_FIN_SET = 2,
	TCP_ACK_SET = 3,
	TCP_RST_SET = 4,
	TCP_NONE_SET = 5,
};

enum tcp_ca_ack_event_flags {
	CA_ACK_SLOWPATH = 1,
	CA_ACK_WIN_UPDATE = 2,
	CA_ACK_ECE = 4,
};

enum tcp_ca_event {
	CA_EVENT_TX_START = 0,
	CA_EVENT_CWND_RESTART = 1,
	CA_EVENT_COMPLETE_CWR = 2,
	CA_EVENT_LOSS = 3,
	CA_EVENT_ECN_NO_CE = 4,
	CA_EVENT_ECN_IS_CE = 5,
};

enum tcp_ca_state {
	TCP_CA_Open = 0,
	TCP_CA_Disorder = 1,
	TCP_CA_CWR = 2,
	TCP_CA_Recovery = 3,
	TCP_CA_Loss = 4,
};

enum tcp_chrono {
	TCP_CHRONO_UNSPEC = 0,
	TCP_CHRONO_BUSY = 1,
	TCP_CHRONO_RWND_LIMITED = 2,
	TCP_CHRONO_SNDBUF_LIMITED = 3,
	__TCP_CHRONO_MAX = 4,
};

enum tcp_conntrack {
	TCP_CONNTRACK_NONE = 0,
	TCP_CONNTRACK_SYN_SENT = 1,
	TCP_CONNTRACK_SYN_RECV = 2,
	TCP_CONNTRACK_ESTABLISHED = 3,
	TCP_CONNTRACK_FIN_WAIT = 4,
	TCP_CONNTRACK_CLOSE_WAIT = 5,
	TCP_CONNTRACK_LAST_ACK = 6,
	TCP_CONNTRACK_TIME_WAIT = 7,
	TCP_CONNTRACK_CLOSE = 8,
	TCP_CONNTRACK_LISTEN = 9,
	TCP_CONNTRACK_MAX = 10,
	TCP_CONNTRACK_IGNORE = 11,
	TCP_CONNTRACK_RETRANS = 12,
	TCP_CONNTRACK_UNACK = 13,
	TCP_CONNTRACK_TIMEOUT_MAX = 14,
};

enum tcp_fastopen_client_fail {
	TFO_STATUS_UNSPEC = 0,
	TFO_COOKIE_UNAVAILABLE = 1,
	TFO_DATA_NOT_ACKED = 2,
	TFO_SYN_RETRANSMITTED = 3,
};

enum tcp_metric_index {
	TCP_METRIC_RTT = 0,
	TCP_METRIC_RTTVAR = 1,
	TCP_METRIC_SSTHRESH = 2,
	TCP_METRIC_CWND = 3,
	TCP_METRIC_REORDERING = 4,
	TCP_METRIC_RTT_US = 5,
	TCP_METRIC_RTTVAR_US = 6,
	__TCP_METRIC_MAX = 7,
};

enum tcp_queue {
	TCP_FRAG_IN_WRITE_QUEUE = 0,
	TCP_FRAG_IN_RTX_QUEUE = 1,
};

enum tcp_seq_states {
	TCP_SEQ_STATE_LISTENING = 0,
	TCP_SEQ_STATE_ESTABLISHED = 1,
};

enum tcp_skb_cb_sacked_flags {
	TCPCB_SACKED_ACKED = 1,
	TCPCB_SACKED_RETRANS = 2,
	TCPCB_LOST = 4,
	TCPCB_TAGBITS = 7,
	TCPCB_REPAIRED = 16,
	TCPCB_EVER_RETRANS = 128,
	TCPCB_RETRANS = 146,
};

enum tcp_synack_type {
	TCP_SYNACK_NORMAL = 0,
	TCP_SYNACK_FASTOPEN = 1,
	TCP_SYNACK_COOKIE = 2,
};

enum tcp_tw_status {
	TCP_TW_SUCCESS = 0,
	TCP_TW_RST = 1,
	TCP_TW_ACK = 2,
	TCP_TW_SYN = 3,
};

enum tcpa_event_types {
	PREBOOT = 0,
	POST_CODE = 1,
	UNUSED = 2,
	NO_ACTION = 3,
	SEPARATOR = 4,
	ACTION = 5,
	EVENT_TAG = 6,
	SCRTM_CONTENTS = 7,
	SCRTM_VERSION = 8,
	CPU_MICROCODE = 9,
	PLATFORM_CONFIG_FLAGS = 10,
	TABLE_OF_DEVICES = 11,
	COMPACT_HASH = 12,
	IPL = 13,
	IPL_PARTITION_DATA = 14,
	NONHOST_CODE = 15,
	NONHOST_CONFIG = 16,
	NONHOST_INFO = 17,
};

enum tcx_action_base {
	TCX_NEXT = -1,
	TCX_PASS = 0,
	TCX_DROP = 2,
	TCX_REDIRECT = 7,
};

enum thermal_device_mode {
	THERMAL_DEVICE_DISABLED = 0,
	THERMAL_DEVICE_ENABLED = 1,
};

enum thermal_genl_attr {
	THERMAL_GENL_ATTR_UNSPEC = 0,
	THERMAL_GENL_ATTR_TZ = 1,
	THERMAL_GENL_ATTR_TZ_ID = 2,
	THERMAL_GENL_ATTR_TZ_TEMP = 3,
	THERMAL_GENL_ATTR_TZ_TRIP = 4,
	THERMAL_GENL_ATTR_TZ_TRIP_ID = 5,
	THERMAL_GENL_ATTR_TZ_TRIP_TYPE = 6,
	THERMAL_GENL_ATTR_TZ_TRIP_TEMP = 7,
	THERMAL_GENL_ATTR_TZ_TRIP_HYST = 8,
	THERMAL_GENL_ATTR_TZ_MODE = 9,
	THERMAL_GENL_ATTR_TZ_NAME = 10,
	THERMAL_GENL_ATTR_TZ_CDEV_WEIGHT = 11,
	THERMAL_GENL_ATTR_TZ_GOV = 12,
	THERMAL_GENL_ATTR_TZ_GOV_NAME = 13,
	THERMAL_GENL_ATTR_CDEV = 14,
	THERMAL_GENL_ATTR_CDEV_ID = 15,
	THERMAL_GENL_ATTR_CDEV_CUR_STATE = 16,
	THERMAL_GENL_ATTR_CDEV_MAX_STATE = 17,
	THERMAL_GENL_ATTR_CDEV_NAME = 18,
	THERMAL_GENL_ATTR_GOV_NAME = 19,
	THERMAL_GENL_ATTR_CPU_CAPABILITY = 20,
	THERMAL_GENL_ATTR_CPU_CAPABILITY_ID = 21,
	THERMAL_GENL_ATTR_CPU_CAPABILITY_PERFORMANCE = 22,
	THERMAL_GENL_ATTR_CPU_CAPABILITY_EFFICIENCY = 23,
	THERMAL_GENL_ATTR_THRESHOLD = 24,
	THERMAL_GENL_ATTR_THRESHOLD_TEMP = 25,
	THERMAL_GENL_ATTR_THRESHOLD_DIRECTION = 26,
	THERMAL_GENL_ATTR_TZ_PREV_TEMP = 27,
	__THERMAL_GENL_ATTR_MAX = 28,
};

enum thermal_genl_cmd {
	THERMAL_GENL_CMD_UNSPEC = 0,
	THERMAL_GENL_CMD_TZ_GET_ID = 1,
	THERMAL_GENL_CMD_TZ_GET_TRIP = 2,
	THERMAL_GENL_CMD_TZ_GET_TEMP = 3,
	THERMAL_GENL_CMD_TZ_GET_GOV = 4,
	THERMAL_GENL_CMD_TZ_GET_MODE = 5,
	THERMAL_GENL_CMD_CDEV_GET = 6,
	THERMAL_GENL_CMD_THRESHOLD_GET = 7,
	THERMAL_GENL_CMD_THRESHOLD_ADD = 8,
	THERMAL_GENL_CMD_THRESHOLD_DELETE = 9,
	THERMAL_GENL_CMD_THRESHOLD_FLUSH = 10,
	__THERMAL_GENL_CMD_MAX = 11,
};

enum thermal_genl_event {
	THERMAL_GENL_EVENT_UNSPEC = 0,
	THERMAL_GENL_EVENT_TZ_CREATE = 1,
	THERMAL_GENL_EVENT_TZ_DELETE = 2,
	THERMAL_GENL_EVENT_TZ_DISABLE = 3,
	THERMAL_GENL_EVENT_TZ_ENABLE = 4,
	THERMAL_GENL_EVENT_TZ_TRIP_UP = 5,
	THERMAL_GENL_EVENT_TZ_TRIP_DOWN = 6,
	THERMAL_GENL_EVENT_TZ_TRIP_CHANGE = 7,
	THERMAL_GENL_EVENT_TZ_TRIP_ADD = 8,
	THERMAL_GENL_EVENT_TZ_TRIP_DELETE = 9,
	THERMAL_GENL_EVENT_CDEV_ADD = 10,
	THERMAL_GENL_EVENT_CDEV_DELETE = 11,
	THERMAL_GENL_EVENT_CDEV_STATE_UPDATE = 12,
	THERMAL_GENL_EVENT_TZ_GOV_CHANGE = 13,
	THERMAL_GENL_EVENT_CPU_CAPABILITY_CHANGE = 14,
	THERMAL_GENL_EVENT_THRESHOLD_ADD = 15,
	THERMAL_GENL_EVENT_THRESHOLD_DELETE = 16,
	THERMAL_GENL_EVENT_THRESHOLD_FLUSH = 17,
	THERMAL_GENL_EVENT_THRESHOLD_UP = 18,
	THERMAL_GENL_EVENT_THRESHOLD_DOWN = 19,
	__THERMAL_GENL_EVENT_MAX = 20,
};

enum thermal_genl_multicast_groups {
	THERMAL_GENL_SAMPLING_GROUP = 0,
	THERMAL_GENL_EVENT_GROUP = 1,
	THERMAL_GENL_MAX_GROUP = 1,
};

enum thermal_genl_sampling {
	THERMAL_GENL_SAMPLING_TEMP = 0,
	__THERMAL_GENL_SAMPLING_MAX = 1,
};

enum thermal_notify_event {
	THERMAL_EVENT_UNSPECIFIED = 0,
	THERMAL_EVENT_TEMP_SAMPLE = 1,
	THERMAL_TRIP_VIOLATED = 2,
	THERMAL_TRIP_CHANGED = 3,
	THERMAL_DEVICE_DOWN = 4,
	THERMAL_DEVICE_UP = 5,
	THERMAL_DEVICE_POWER_CAPABILITY_CHANGED = 6,
	THERMAL_TABLE_CHANGED = 7,
	THERMAL_EVENT_KEEP_ALIVE = 8,
	THERMAL_TZ_BIND_CDEV = 9,
	THERMAL_TZ_UNBIND_CDEV = 10,
	THERMAL_INSTANCE_WEIGHT_CHANGED = 11,
	THERMAL_TZ_RESUME = 12,
	THERMAL_TZ_ADD_THRESHOLD = 13,
	THERMAL_TZ_DEL_THRESHOLD = 14,
	THERMAL_TZ_FLUSH_THRESHOLDS = 15,
};

enum thermal_trend {
	THERMAL_TREND_STABLE = 0,
	THERMAL_TREND_RAISING = 1,
	THERMAL_TREND_DROPPING = 2,
};

enum thermal_trip_type {
	THERMAL_TRIP_ACTIVE = 0,
	THERMAL_TRIP_PASSIVE = 1,
	THERMAL_TRIP_HOT = 2,
	THERMAL_TRIP_CRITICAL = 3,
};

enum tick_broadcast_mode {
	TICK_BROADCAST_OFF = 0,
	TICK_BROADCAST_ON = 1,
	TICK_BROADCAST_FORCE = 2,
};

enum tick_broadcast_state {
	TICK_BROADCAST_EXIT = 0,
	TICK_BROADCAST_ENTER = 1,
};

enum tick_dep_bits {
	TICK_DEP_BIT_POSIX_TIMER = 0,
	TICK_DEP_BIT_PERF_EVENTS = 1,
	TICK_DEP_BIT_SCHED = 2,
	TICK_DEP_BIT_CLOCK_UNSTABLE = 3,
	TICK_DEP_BIT_RCU = 4,
	TICK_DEP_BIT_RCU_EXP = 5,
};

enum tick_device_mode {
	TICKDEV_MODE_PERIODIC = 0,
	TICKDEV_MODE_ONESHOT = 1,
};

enum timekeeping_adv_mode {
	TK_ADV_TICK = 0,
	TK_ADV_FREQ = 1,
};

enum timer_tread_format {
	TREAD_FORMAT_NONE = 0,
	TREAD_FORMAT_TIME64 = 1,
	TREAD_FORMAT_TIME32 = 2,
};

enum timespec_type {
	TT_NONE = 0,
	TT_NATIVE = 1,
	TT_COMPAT = 2,
};

enum tk_offsets {
	TK_OFFS_REAL = 0,
	TK_OFFS_BOOT = 1,
	TK_OFFS_TAI = 2,
	TK_OFFS_MAX = 3,
};

enum tlb_flush_reason {
	TLB_FLUSH_ON_TASK_SWITCH = 0,
	TLB_REMOTE_SHOOTDOWN = 1,
	TLB_LOCAL_SHOOTDOWN = 2,
	TLB_LOCAL_MM_SHOOTDOWN = 3,
	TLB_REMOTE_SEND_IPI = 4,
	TLB_REMOTE_WRONG_CPU = 5,
	NR_TLB_FLUSH_REASONS = 6,
};

enum tlb_infos {
	ENTRIES = 0,
	NR_INFO = 1,
};

enum topo_types {
	INVALID_TYPE = 0,
	SMT_TYPE = 1,
	CORE_TYPE = 2,
	MAX_TYPE_0B = 3,
	MODULE_TYPE = 3,
	AMD_CCD_TYPE = 3,
	TILE_TYPE = 4,
	AMD_SOCKET_TYPE = 4,
	MAX_TYPE_80000026 = 5,
	DIE_TYPE = 5,
	DIEGRP_TYPE = 6,
	MAX_TYPE_1F = 7,
};

enum tp_func_state {
	TP_FUNC_0 = 0,
	TP_FUNC_1 = 1,
	TP_FUNC_2 = 2,
	TP_FUNC_N = 3,
};

enum tp_transition_sync {
	TP_TRANSITION_SYNC_1_0_1 = 0,
	TP_TRANSITION_SYNC_N_2_1 = 1,
	_NR_TP_TRANSITION_SYNC = 2,
};

enum tpacket_versions {
	TPACKET_V1 = 0,
	TPACKET_V2 = 1,
	TPACKET_V3 = 2,
};

enum tpm_duration {
	TPM_SHORT = 0,
	TPM_MEDIUM = 1,
	TPM_LONG = 2,
	TPM_LONG_LONG = 3,
	TPM_UNDEFINED = 4,
	TPM_NUM_DURATIONS = 4,
};

enum trace_flag_type {
	TRACE_FLAG_IRQS_OFF = 1,
	TRACE_FLAG_NEED_RESCHED_LAZY = 2,
	TRACE_FLAG_NEED_RESCHED = 4,
	TRACE_FLAG_HARDIRQ = 8,
	TRACE_FLAG_SOFTIRQ = 16,
	TRACE_FLAG_PREEMPT_RESCHED = 32,
	TRACE_FLAG_NMI = 64,
	TRACE_FLAG_BH_OFF = 128,
};

enum trace_iter_flags {
	TRACE_FILE_LAT_FMT = 1,
	TRACE_FILE_ANNOTATE = 2,
	TRACE_FILE_TIME_IN_NS = 4,
};

enum trace_iterator_bits {
	TRACE_ITER_PRINT_PARENT_BIT = 0,
	TRACE_ITER_SYM_OFFSET_BIT = 1,
	TRACE_ITER_SYM_ADDR_BIT = 2,
	TRACE_ITER_VERBOSE_BIT = 3,
	TRACE_ITER_RAW_BIT = 4,
	TRACE_ITER_HEX_BIT = 5,
	TRACE_ITER_BIN_BIT = 6,
	TRACE_ITER_BLOCK_BIT = 7,
	TRACE_ITER_FIELDS_BIT = 8,
	TRACE_ITER_PRINTK_BIT = 9,
	TRACE_ITER_ANNOTATE_BIT = 10,
	TRACE_ITER_USERSTACKTRACE_BIT = 11,
	TRACE_ITER_SYM_USEROBJ_BIT = 12,
	TRACE_ITER_PRINTK_MSGONLY_BIT = 13,
	TRACE_ITER_CONTEXT_INFO_BIT = 14,
	TRACE_ITER_LATENCY_FMT_BIT = 15,
	TRACE_ITER_RECORD_CMD_BIT = 16,
	TRACE_ITER_RECORD_TGID_BIT = 17,
	TRACE_ITER_OVERWRITE_BIT = 18,
	TRACE_ITER_STOP_ON_FREE_BIT = 19,
	TRACE_ITER_IRQ_INFO_BIT = 20,
	TRACE_ITER_MARKERS_BIT = 21,
	TRACE_ITER_EVENT_FORK_BIT = 22,
	TRACE_ITER_TRACE_PRINTK_BIT = 23,
	TRACE_ITER_PAUSE_ON_TRACE_BIT = 24,
	TRACE_ITER_HASH_PTR_BIT = 25,
	TRACE_ITER_STACKTRACE_BIT = 26,
	TRACE_ITER_LAST_BIT = 27,
};

enum trace_iterator_flags {
	TRACE_ITER_PRINT_PARENT = 1,
	TRACE_ITER_SYM_OFFSET = 2,
	TRACE_ITER_SYM_ADDR = 4,
	TRACE_ITER_VERBOSE = 8,
	TRACE_ITER_RAW = 16,
	TRACE_ITER_HEX = 32,
	TRACE_ITER_BIN = 64,
	TRACE_ITER_BLOCK = 128,
	TRACE_ITER_FIELDS = 256,
	TRACE_ITER_PRINTK = 512,
	TRACE_ITER_ANNOTATE = 1024,
	TRACE_ITER_USERSTACKTRACE = 2048,
	TRACE_ITER_SYM_USEROBJ = 4096,
	TRACE_ITER_PRINTK_MSGONLY = 8192,
	TRACE_ITER_CONTEXT_INFO = 16384,
	TRACE_ITER_LATENCY_FMT = 32768,
	TRACE_ITER_RECORD_CMD = 65536,
	TRACE_ITER_RECORD_TGID = 131072,
	TRACE_ITER_OVERWRITE = 262144,
	TRACE_ITER_STOP_ON_FREE = 524288,
	TRACE_ITER_IRQ_INFO = 1048576,
	TRACE_ITER_MARKERS = 2097152,
	TRACE_ITER_EVENT_FORK = 4194304,
	TRACE_ITER_TRACE_PRINTK = 8388608,
	TRACE_ITER_PAUSE_ON_TRACE = 16777216,
	TRACE_ITER_HASH_PTR = 33554432,
	TRACE_ITER_STACKTRACE = 67108864,
};

enum trace_reg {
	TRACE_REG_REGISTER = 0,
	TRACE_REG_UNREGISTER = 1,
	TRACE_REG_PERF_REGISTER = 2,
	TRACE_REG_PERF_UNREGISTER = 3,
	TRACE_REG_PERF_OPEN = 4,
	TRACE_REG_PERF_CLOSE = 5,
	TRACE_REG_PERF_ADD = 6,
	TRACE_REG_PERF_DEL = 7,
};

enum trace_type {
	__TRACE_FIRST_TYPE = 0,
	TRACE_FN = 1,
	TRACE_CTX = 2,
	TRACE_WAKE = 3,
	TRACE_STACK = 4,
	TRACE_PRINT = 5,
	TRACE_BPRINT = 6,
	TRACE_MMIO_RW = 7,
	TRACE_MMIO_MAP = 8,
	TRACE_BRANCH = 9,
	TRACE_GRAPH_RET = 10,
	TRACE_GRAPH_ENT = 11,
	TRACE_GRAPH_RETADDR_ENT = 12,
	TRACE_USER_STACK = 13,
	TRACE_BLK = 14,
	TRACE_BPUTS = 15,
	TRACE_HWLAT = 16,
	TRACE_OSNOISE = 17,
	TRACE_TIMERLAT = 18,
	TRACE_RAW_DATA = 19,
	TRACE_FUNC_REPEATS = 20,
	__TRACE_LAST_TYPE = 21,
};

enum track_item {
	TRACK_ALLOC = 0,
	TRACK_FREE = 1,
};

enum transcoder {
	INVALID_TRANSCODER = -1,
	TRANSCODER_A = 0,
	TRANSCODER_B = 1,
	TRANSCODER_C = 2,
	TRANSCODER_D = 3,
	TRANSCODER_EDP = 4,
	TRANSCODER_DSI_0 = 5,
	TRANSCODER_DSI_1 = 6,
	TRANSCODER_DSI_A = 5,
	TRANSCODER_DSI_C = 6,
	I915_MAX_TRANSCODERS = 7,
};

enum translation_map {
	LAT1_MAP = 0,
	GRAF_MAP = 1,
	IBMPC_MAP = 2,
	USER_MAP = 3,
	FIRST_MAP = 0,
	LAST_MAP = 3,
};

enum tsq_enum {
	TSQ_THROTTLED = 0,
	TSQ_QUEUED = 1,
	TCP_TSQ_DEFERRED = 2,
	TCP_WRITE_TIMER_DEFERRED = 3,
	TCP_DELACK_TIMER_DEFERRED = 4,
	TCP_MTU_REDUCED_DEFERRED = 5,
	TCP_ACK_DEFERRED = 6,
};

enum tsq_flags {
	TSQF_THROTTLED = 1,
	TSQF_QUEUED = 2,
	TCPF_TSQ_DEFERRED = 4,
	TCPF_WRITE_TIMER_DEFERRED = 8,
	TCPF_DELACK_TIMER_DEFERRED = 16,
	TCPF_MTU_REDUCED_DEFERRED = 32,
	TCPF_ACK_DEFERRED = 64,
};

enum tsx_ctrl_states {
	TSX_CTRL_ENABLE = 0,
	TSX_CTRL_DISABLE = 1,
	TSX_CTRL_RTM_ALWAYS_ABORT = 2,
	TSX_CTRL_NOT_SUPPORTED = 3,
};

enum ttm_bo_type {
	ttm_bo_type_device = 0,
	ttm_bo_type_kernel = 1,
	ttm_bo_type_sg = 2,
};

enum ttm_caching {
	ttm_uncached = 0,
	ttm_write_combined = 1,
	ttm_cached = 2,
};

enum ttm_lru_item_type {
	TTM_LRU_RESOURCE = 0,
	TTM_LRU_HITCH = 1,
};

enum ttu_flags {
	TTU_SPLIT_HUGE_PMD = 4,
	TTU_IGNORE_MLOCK = 8,
	TTU_SYNC = 16,
	TTU_HWPOISON = 32,
	TTU_BATCH_FLUSH = 64,
	TTU_RMAP_LOCKED = 128,
};

enum tty_flow_change {
	TTY_FLOW_NO_CHANGE = 0,
	TTY_THROTTLE_SAFE = 1,
	TTY_UNTHROTTLE_SAFE = 2,
};

enum tunable_id {
	ETHTOOL_ID_UNSPEC = 0,
	ETHTOOL_RX_COPYBREAK = 1,
	ETHTOOL_TX_COPYBREAK = 2,
	ETHTOOL_PFC_PREVENTION_TOUT = 3,
	ETHTOOL_TX_COPYBREAK_BUF_SIZE = 4,
	__ETHTOOL_TUNABLE_COUNT = 5,
};

enum tunable_type_id {
	ETHTOOL_TUNABLE_UNSPEC = 0,
	ETHTOOL_TUNABLE_U8 = 1,
	ETHTOOL_TUNABLE_U16 = 2,
	ETHTOOL_TUNABLE_U32 = 3,
	ETHTOOL_TUNABLE_U64 = 4,
	ETHTOOL_TUNABLE_STRING = 5,
	ETHTOOL_TUNABLE_S8 = 6,
	ETHTOOL_TUNABLE_S16 = 7,
	ETHTOOL_TUNABLE_S32 = 8,
	ETHTOOL_TUNABLE_S64 = 9,
};

enum tunnel_encap_types {
	TUNNEL_ENCAP_NONE = 0,
	TUNNEL_ENCAP_FOU = 1,
	TUNNEL_ENCAP_GUE = 2,
	TUNNEL_ENCAP_MPLS = 3,
};

enum tx_config_bits {
	TxIFGShift = 24,
	TxIFG84 = 0,
	TxIFG88 = 16777216,
	TxIFG92 = 33554432,
	TxIFG96 = 50331648,
	TxLoopBack = 393216,
	TxCRC = 65536,
	TxClearAbt = 1,
	TxDMAShift___2 = 8,
	TxRetryShift = 4,
	TxVersionMask = 2088763392,
};

enum txq_info_flags {
	IEEE80211_TXQ_STOP = 0,
	IEEE80211_TXQ_AMPDU = 1,
	IEEE80211_TXQ_NO_AMSDU = 2,
	IEEE80211_TXQ_DIRTY = 3,
};

enum txtime_flags {
	SOF_TXTIME_DEADLINE_MODE = 1,
	SOF_TXTIME_REPORT_ERRORS = 2,
	SOF_TXTIME_FLAGS_LAST = 2,
	SOF_TXTIME_FLAGS_MASK = 3,
};

enum uart_pm_state {
	UART_PM_STATE_ON = 0,
	UART_PM_STATE_OFF = 3,
	UART_PM_STATE_UNDEFINED = 4,
};

enum uclamp_id {
	UCLAMP_MIN = 0,
	UCLAMP_MAX = 1,
	UCLAMP_CNT = 2,
};

enum ucode_state {
	UCODE_OK = 0,
	UCODE_NEW = 1,
	UCODE_NEW_SAFE = 2,
	UCODE_UPDATED = 3,
	UCODE_NFOUND = 4,
	UCODE_ERROR = 5,
	UCODE_TIMEOUT = 6,
	UCODE_OFFLINE = 7,
};

enum ucount_type {
	UCOUNT_USER_NAMESPACES = 0,
	UCOUNT_PID_NAMESPACES = 1,
	UCOUNT_UTS_NAMESPACES = 2,
	UCOUNT_IPC_NAMESPACES = 3,
	UCOUNT_NET_NAMESPACES = 4,
	UCOUNT_MNT_NAMESPACES = 5,
	UCOUNT_CGROUP_NAMESPACES = 6,
	UCOUNT_TIME_NAMESPACES = 7,
	UCOUNT_INOTIFY_INSTANCES = 8,
	UCOUNT_INOTIFY_WATCHES = 9,
	UCOUNT_COUNTS = 10,
};

enum udp_conntrack {
	UDP_CT_UNREPLIED = 0,
	UDP_CT_REPLIED = 1,
	UDP_CT_MAX = 2,
};

enum udp_parsable_tunnel_type {
	UDP_TUNNEL_TYPE_VXLAN = 1,
	UDP_TUNNEL_TYPE_GENEVE = 2,
	UDP_TUNNEL_TYPE_VXLAN_GPE = 4,
};

enum udp_tunnel_nic_info_flags {
	UDP_TUNNEL_NIC_INFO_MAY_SLEEP = 1,
	UDP_TUNNEL_NIC_INFO_OPEN_ONLY = 2,
	UDP_TUNNEL_NIC_INFO_IPV4_ONLY = 4,
	UDP_TUNNEL_NIC_INFO_STATIC_IANA_VXLAN = 8,
};

enum uhci_rh_state {
	UHCI_RH_RESET = 0,
	UHCI_RH_SUSPENDED = 1,
	UHCI_RH_AUTO_STOPPED = 2,
	UHCI_RH_RESUMING = 3,
	UHCI_RH_SUSPENDING = 4,
	UHCI_RH_RUNNING = 5,
	UHCI_RH_RUNNING_NODEVS = 6,
};

enum umh_disable_depth {
	UMH_ENABLED = 0,
	UMH_FREEZING = 1,
	UMH_DISABLED = 2,
};

enum umount_tree_flags {
	UMOUNT_SYNC = 1,
	UMOUNT_PROPAGATE = 2,
	UMOUNT_CONNECTED = 4,
};

enum uncore_access_type {
	UNCORE_ACCESS_MSR = 0,
	UNCORE_ACCESS_MMIO = 1,
	UNCORE_ACCESS_PCI = 2,
	UNCORE_ACCESS_MAX = 3,
};

enum unix_vertex_index {
	UNIX_VERTEX_INDEX_MARK1 = 0,
	UNIX_VERTEX_INDEX_MARK2 = 1,
	UNIX_VERTEX_INDEX_START = 2,
};

enum uprobe_task_state {
	UTASK_RUNNING = 0,
	UTASK_SSTEP = 1,
	UTASK_SSTEP_ACK = 2,
	UTASK_SSTEP_TRAPPED = 3,
};

enum usb3_link_state {
	USB3_LPM_U0 = 0,
	USB3_LPM_U1 = 1,
	USB3_LPM_U2 = 2,
	USB3_LPM_U3 = 3,
};

enum usb_charger_state {
	USB_CHARGER_DEFAULT = 0,
	USB_CHARGER_PRESENT = 1,
	USB_CHARGER_ABSENT = 2,
};

enum usb_charger_type {
	UNKNOWN_TYPE = 0,
	SDP_TYPE = 1,
	DCP_TYPE = 2,
	CDP_TYPE = 3,
	ACA_TYPE = 4,
};

enum usb_dev_authorize_policy {
	USB_DEVICE_AUTHORIZE_NONE = 0,
	USB_DEVICE_AUTHORIZE_ALL = 1,
	USB_DEVICE_AUTHORIZE_INTERNAL = 2,
};

enum usb_device_speed {
	USB_SPEED_UNKNOWN = 0,
	USB_SPEED_LOW = 1,
	USB_SPEED_FULL = 2,
	USB_SPEED_HIGH = 3,
	USB_SPEED_WIRELESS = 4,
	USB_SPEED_SUPER = 5,
	USB_SPEED_SUPER_PLUS = 6,
};

enum usb_device_state {
	USB_STATE_NOTATTACHED = 0,
	USB_STATE_ATTACHED = 1,
	USB_STATE_POWERED = 2,
	USB_STATE_RECONNECTING = 3,
	USB_STATE_UNAUTHENTICATED = 4,
	USB_STATE_DEFAULT = 5,
	USB_STATE_ADDRESS = 6,
	USB_STATE_CONFIGURED = 7,
	USB_STATE_SUSPENDED = 8,
};

enum usb_dr_mode {
	USB_DR_MODE_UNKNOWN = 0,
	USB_DR_MODE_HOST = 1,
	USB_DR_MODE_PERIPHERAL = 2,
	USB_DR_MODE_OTG = 3,
};

enum usb_interface_condition {
	USB_INTERFACE_UNBOUND = 0,
	USB_INTERFACE_BINDING = 1,
	USB_INTERFACE_BOUND = 2,
	USB_INTERFACE_UNBINDING = 3,
};

enum usb_led_event {
	USB_LED_EVENT_HOST = 0,
	USB_LED_EVENT_GADGET = 1,
};

enum usb_link_tunnel_mode {
	USB_LINK_UNKNOWN = 0,
	USB_LINK_NATIVE = 1,
	USB_LINK_TUNNELED = 2,
};

enum usb_otg_state {
	OTG_STATE_UNDEFINED = 0,
	OTG_STATE_B_IDLE = 1,
	OTG_STATE_B_SRP_INIT = 2,
	OTG_STATE_B_PERIPHERAL = 3,
	OTG_STATE_B_WAIT_ACON = 4,
	OTG_STATE_B_HOST = 5,
	OTG_STATE_A_IDLE = 6,
	OTG_STATE_A_WAIT_VRISE = 7,
	OTG_STATE_A_WAIT_BCON = 8,
	OTG_STATE_A_HOST = 9,
	OTG_STATE_A_SUSPEND = 10,
	OTG_STATE_A_PERIPHERAL = 11,
	OTG_STATE_A_WAIT_VFALL = 12,
	OTG_STATE_A_VBUS_ERR = 13,
};

enum usb_phy_events {
	USB_EVENT_NONE = 0,
	USB_EVENT_VBUS = 1,
	USB_EVENT_ID = 2,
	USB_EVENT_CHARGER = 3,
	USB_EVENT_ENUMERATED = 4,
};

enum usb_phy_type {
	USB_PHY_TYPE_UNDEFINED = 0,
	USB_PHY_TYPE_USB2 = 1,
	USB_PHY_TYPE_USB3 = 2,
};

enum usb_port_connect_type {
	USB_PORT_CONNECT_TYPE_UNKNOWN = 0,
	USB_PORT_CONNECT_TYPE_HOT_PLUG = 1,
	USB_PORT_CONNECT_TYPE_HARD_WIRED = 2,
	USB_PORT_NOT_USED = 3,
};

enum usb_ssp_rate {
	USB_SSP_GEN_UNKNOWN = 0,
	USB_SSP_GEN_2x1 = 1,
	USB_SSP_GEN_1x2 = 2,
	USB_SSP_GEN_2x2 = 3,
};

enum usb_wireless_status {
	USB_WIRELESS_STATUS_NA = 0,
	USB_WIRELESS_STATUS_DISCONNECTED = 1,
	USB_WIRELESS_STATUS_CONNECTED = 2,
};

enum utf16_endian {
	UTF16_HOST_ENDIAN = 0,
	UTF16_LITTLE_ENDIAN = 1,
	UTF16_BIG_ENDIAN = 2,
};

enum utf8_normalization {
	UTF8_NFDI = 0,
	UTF8_NFDICF = 1,
	UTF8_NMAX = 2,
};

enum uts_proc {
	UTS_PROC_ARCH = 0,
	UTS_PROC_OSTYPE = 1,
	UTS_PROC_OSRELEASE = 2,
	UTS_PROC_VERSION = 3,
	UTS_PROC_HOSTNAME = 4,
	UTS_PROC_DOMAINNAME = 5,
};

enum uv_system_type {
	UV_NONE = 0,
	UV_LEGACY_APIC = 1,
	UV_X2APIC = 2,
};

enum v4l2_av1_segment_feature {
	V4L2_AV1_SEG_LVL_ALT_Q = 0,
	V4L2_AV1_SEG_LVL_ALT_LF_Y_V = 1,
	V4L2_AV1_SEG_LVL_REF_FRAME = 5,
	V4L2_AV1_SEG_LVL_REF_SKIP = 6,
	V4L2_AV1_SEG_LVL_REF_GLOBALMV = 7,
	V4L2_AV1_SEG_LVL_MAX = 8,
};

enum v4l2_fwnode_bus_type {
	V4L2_FWNODE_BUS_TYPE_GUESS = 0,
	V4L2_FWNODE_BUS_TYPE_CSI2_CPHY = 1,
	V4L2_FWNODE_BUS_TYPE_CSI1 = 2,
	V4L2_FWNODE_BUS_TYPE_CCP2 = 3,
	V4L2_FWNODE_BUS_TYPE_CSI2_DPHY = 4,
	V4L2_FWNODE_BUS_TYPE_PARALLEL = 5,
	V4L2_FWNODE_BUS_TYPE_BT656 = 6,
	V4L2_FWNODE_BUS_TYPE_DPI = 7,
	NR_OF_V4L2_FWNODE_BUS_TYPE = 8,
};

enum v4l2_preemphasis {
	V4L2_PREEMPHASIS_DISABLED = 0,
	V4L2_PREEMPHASIS_50_uS = 1,
	V4L2_PREEMPHASIS_75_uS = 2,
};

enum vbt_gmbus_ddi {
	DDC_BUS_DDI_B = 1,
	DDC_BUS_DDI_C = 2,
	DDC_BUS_DDI_D = 3,
	DDC_BUS_DDI_F = 4,
	ICL_DDC_BUS_DDI_A = 1,
	ICL_DDC_BUS_DDI_B = 2,
	TGL_DDC_BUS_DDI_C = 3,
	RKL_DDC_BUS_DDI_D = 3,
	RKL_DDC_BUS_DDI_E = 4,
	ICL_DDC_BUS_PORT_1 = 4,
	ICL_DDC_BUS_PORT_2 = 5,
	ICL_DDC_BUS_PORT_3 = 6,
	ICL_DDC_BUS_PORT_4 = 7,
	TGL_DDC_BUS_PORT_5 = 8,
	TGL_DDC_BUS_PORT_6 = 9,
	ADLS_DDC_BUS_PORT_TC1 = 2,
	ADLS_DDC_BUS_PORT_TC2 = 3,
	ADLS_DDC_BUS_PORT_TC3 = 4,
	ADLS_DDC_BUS_PORT_TC4 = 5,
	ADLP_DDC_BUS_PORT_TC1 = 3,
	ADLP_DDC_BUS_PORT_TC2 = 4,
	ADLP_DDC_BUS_PORT_TC3 = 5,
	ADLP_DDC_BUS_PORT_TC4 = 6,
};

enum vc_ctl_state {
	ESnormal = 0,
	ESesc = 1,
	ESsquare = 2,
	ESgetpars = 3,
	ESfunckey = 4,
	EShash = 5,
	ESsetG0 = 6,
	ESsetG1 = 7,
	ESpercent = 8,
	EScsiignore = 9,
	ESnonstd = 10,
	ESpalette = 11,
	ESosc = 12,
	ESANSI_first = 12,
	ESapc = 13,
	ESpm = 14,
	ESdcs = 15,
	ESANSI_last = 15,
};

enum vc_intensity {
	VCI_HALF_BRIGHT = 0,
	VCI_NORMAL = 1,
	VCI_BOLD = 2,
	VCI_MASK = 3,
};

enum vdso_clock_mode {
	VDSO_CLOCKMODE_NONE = 0,
	VDSO_CLOCKMODE_TSC = 1,
	VDSO_CLOCKMODE_PVCLOCK = 2,
	VDSO_CLOCKMODE_HVCLOCK = 3,
	VDSO_CLOCKMODE_MAX = 4,
	VDSO_CLOCKMODE_TIMENS = 2147483647,
};

enum verifier_phase {
	CHECK_META = 0,
	CHECK_TYPE = 1,
};

enum vesa_blank_mode {
	VESA_NO_BLANKING = 0,
	VESA_VSYNC_SUSPEND = 1,
	VESA_HSYNC_SUSPEND = 2,
	VESA_POWERDOWN = 3,
	VESA_BLANK_MAX = 3,
};

enum vga_switcheroo_client_id {
	VGA_SWITCHEROO_UNKNOWN_ID = 4096,
	VGA_SWITCHEROO_IGD = 0,
	VGA_SWITCHEROO_DIS = 1,
	VGA_SWITCHEROO_MAX_CLIENTS = 2,
};

enum vga_switcheroo_handler_flags_t {
	VGA_SWITCHEROO_CAN_SWITCH_DDC = 1,
	VGA_SWITCHEROO_NEEDS_EDP_CONFIG = 2,
};

enum vga_switcheroo_state {
	VGA_SWITCHEROO_OFF = 0,
	VGA_SWITCHEROO_ON = 1,
	VGA_SWITCHEROO_NOT_FOUND = 2,
};

enum vgt_g2v_type {
	VGT_G2V_PPGTT_L3_PAGE_TABLE_CREATE = 2,
	VGT_G2V_PPGTT_L3_PAGE_TABLE_DESTROY = 3,
	VGT_G2V_PPGTT_L4_PAGE_TABLE_CREATE = 4,
	VGT_G2V_PPGTT_L4_PAGE_TABLE_DESTROY = 5,
	VGT_G2V_EXECLIST_CONTEXT_CREATE = 6,
	VGT_G2V_EXECLIST_CONTEXT_DESTROY = 7,
	VGT_G2V_MAX = 8,
};

enum virtio_gpu_ctrl_type {
	VIRTIO_GPU_UNDEFINED = 0,
	VIRTIO_GPU_CMD_GET_DISPLAY_INFO = 256,
	VIRTIO_GPU_CMD_RESOURCE_CREATE_2D = 257,
	VIRTIO_GPU_CMD_RESOURCE_UNREF = 258,
	VIRTIO_GPU_CMD_SET_SCANOUT = 259,
	VIRTIO_GPU_CMD_RESOURCE_FLUSH = 260,
	VIRTIO_GPU_CMD_TRANSFER_TO_HOST_2D = 261,
	VIRTIO_GPU_CMD_RESOURCE_ATTACH_BACKING = 262,
	VIRTIO_GPU_CMD_RESOURCE_DETACH_BACKING = 263,
	VIRTIO_GPU_CMD_GET_CAPSET_INFO = 264,
	VIRTIO_GPU_CMD_GET_CAPSET = 265,
	VIRTIO_GPU_CMD_GET_EDID = 266,
	VIRTIO_GPU_CMD_RESOURCE_ASSIGN_UUID = 267,
	VIRTIO_GPU_CMD_RESOURCE_CREATE_BLOB = 268,
	VIRTIO_GPU_CMD_SET_SCANOUT_BLOB = 269,
	VIRTIO_GPU_CMD_CTX_CREATE = 512,
	VIRTIO_GPU_CMD_CTX_DESTROY = 513,
	VIRTIO_GPU_CMD_CTX_ATTACH_RESOURCE = 514,
	VIRTIO_GPU_CMD_CTX_DETACH_RESOURCE = 515,
	VIRTIO_GPU_CMD_RESOURCE_CREATE_3D = 516,
	VIRTIO_GPU_CMD_TRANSFER_TO_HOST_3D = 517,
	VIRTIO_GPU_CMD_TRANSFER_FROM_HOST_3D = 518,
	VIRTIO_GPU_CMD_SUBMIT_3D = 519,
	VIRTIO_GPU_CMD_RESOURCE_MAP_BLOB = 520,
	VIRTIO_GPU_CMD_RESOURCE_UNMAP_BLOB = 521,
	VIRTIO_GPU_CMD_UPDATE_CURSOR = 768,
	VIRTIO_GPU_CMD_MOVE_CURSOR = 769,
	VIRTIO_GPU_RESP_OK_NODATA = 4352,
	VIRTIO_GPU_RESP_OK_DISPLAY_INFO = 4353,
	VIRTIO_GPU_RESP_OK_CAPSET_INFO = 4354,
	VIRTIO_GPU_RESP_OK_CAPSET = 4355,
	VIRTIO_GPU_RESP_OK_EDID = 4356,
	VIRTIO_GPU_RESP_OK_RESOURCE_UUID = 4357,
	VIRTIO_GPU_RESP_OK_MAP_INFO = 4358,
	VIRTIO_GPU_RESP_ERR_UNSPEC = 4608,
	VIRTIO_GPU_RESP_ERR_OUT_OF_MEMORY = 4609,
	VIRTIO_GPU_RESP_ERR_INVALID_SCANOUT_ID = 4610,
	VIRTIO_GPU_RESP_ERR_INVALID_RESOURCE_ID = 4611,
	VIRTIO_GPU_RESP_ERR_INVALID_CONTEXT_ID = 4612,
	VIRTIO_GPU_RESP_ERR_INVALID_PARAMETER = 4613,
};

enum virtio_gpu_formats {
	VIRTIO_GPU_FORMAT_B8G8R8A8_UNORM = 1,
	VIRTIO_GPU_FORMAT_B8G8R8X8_UNORM = 2,
	VIRTIO_GPU_FORMAT_A8R8G8B8_UNORM = 3,
	VIRTIO_GPU_FORMAT_X8R8G8B8_UNORM = 4,
	VIRTIO_GPU_FORMAT_R8G8B8A8_UNORM = 67,
	VIRTIO_GPU_FORMAT_X8B8G8R8_UNORM = 68,
	VIRTIO_GPU_FORMAT_A8B8G8R8_UNORM = 121,
	VIRTIO_GPU_FORMAT_R8G8B8X8_UNORM = 134,
};

enum virtio_gpu_shm_id {
	VIRTIO_GPU_SHM_ID_UNDEFINED = 0,
	VIRTIO_GPU_SHM_ID_HOST_VISIBLE = 1,
};

enum virtio_input_config_select {
	VIRTIO_INPUT_CFG_UNSET = 0,
	VIRTIO_INPUT_CFG_ID_NAME = 1,
	VIRTIO_INPUT_CFG_ID_SERIAL = 2,
	VIRTIO_INPUT_CFG_ID_DEVIDS = 3,
	VIRTIO_INPUT_CFG_PROP_BITS = 16,
	VIRTIO_INPUT_CFG_EV_BITS = 17,
	VIRTIO_INPUT_CFG_ABS_INFO = 18,
};

enum virtnet_xmit_type {
	VIRTNET_XMIT_TYPE_SKB = 0,
	VIRTNET_XMIT_TYPE_SKB_ORPHAN = 1,
	VIRTNET_XMIT_TYPE_XDP = 2,
	VIRTNET_XMIT_TYPE_XSK = 3,
};

enum visit_state {
	NOT_VISITED = 0,
	VISITED = 1,
	RESOLVED = 2,
};

enum vlv_wm_level {
	VLV_WM_LEVEL_PM2 = 0,
	VLV_WM_LEVEL_PM5 = 1,
	VLV_WM_LEVEL_DDR_DVFS = 2,
	NUM_VLV_WM_LEVELS = 3,
};

enum vm_event_item {
	PGPGIN = 0,
	PGPGOUT = 1,
	PSWPIN = 2,
	PSWPOUT = 3,
	PGALLOC_DMA = 4,
	PGALLOC_DMA32 = 5,
	PGALLOC_NORMAL = 6,
	PGALLOC_MOVABLE = 7,
	ALLOCSTALL_DMA = 8,
	ALLOCSTALL_DMA32 = 9,
	ALLOCSTALL_NORMAL = 10,
	ALLOCSTALL_MOVABLE = 11,
	PGSCAN_SKIP_DMA = 12,
	PGSCAN_SKIP_DMA32 = 13,
	PGSCAN_SKIP_NORMAL = 14,
	PGSCAN_SKIP_MOVABLE = 15,
	PGFREE = 16,
	PGACTIVATE = 17,
	PGDEACTIVATE = 18,
	PGLAZYFREE = 19,
	PGFAULT = 20,
	PGMAJFAULT = 21,
	PGLAZYFREED = 22,
	PGREFILL = 23,
	PGREUSE = 24,
	PGSTEAL_KSWAPD = 25,
	PGSTEAL_DIRECT = 26,
	PGSTEAL_KHUGEPAGED = 27,
	PGSCAN_KSWAPD = 28,
	PGSCAN_DIRECT = 29,
	PGSCAN_KHUGEPAGED = 30,
	PGSCAN_DIRECT_THROTTLE = 31,
	PGSCAN_ANON = 32,
	PGSCAN_FILE = 33,
	PGSTEAL_ANON = 34,
	PGSTEAL_FILE = 35,
	PGSCAN_ZONE_RECLAIM_SUCCESS = 36,
	PGSCAN_ZONE_RECLAIM_FAILED = 37,
	PGINODESTEAL = 38,
	SLABS_SCANNED = 39,
	KSWAPD_INODESTEAL = 40,
	KSWAPD_LOW_WMARK_HIT_QUICKLY = 41,
	KSWAPD_HIGH_WMARK_HIT_QUICKLY = 42,
	PAGEOUTRUN = 43,
	PGROTATED = 44,
	DROP_PAGECACHE = 45,
	DROP_SLAB = 46,
	OOM_KILL = 47,
	PGMIGRATE_SUCCESS = 48,
	PGMIGRATE_FAIL = 49,
	THP_MIGRATION_SUCCESS = 50,
	THP_MIGRATION_FAIL = 51,
	THP_MIGRATION_SPLIT = 52,
	COMPACTMIGRATE_SCANNED = 53,
	COMPACTFREE_SCANNED = 54,
	COMPACTISOLATED = 55,
	COMPACTSTALL = 56,
	COMPACTFAIL = 57,
	COMPACTSUCCESS = 58,
	KCOMPACTD_WAKE = 59,
	KCOMPACTD_MIGRATE_SCANNED = 60,
	KCOMPACTD_FREE_SCANNED = 61,
	HTLB_BUDDY_PGALLOC = 62,
	HTLB_BUDDY_PGALLOC_FAIL = 63,
	UNEVICTABLE_PGCULLED = 64,
	UNEVICTABLE_PGSCANNED = 65,
	UNEVICTABLE_PGRESCUED = 66,
	UNEVICTABLE_PGMLOCKED = 67,
	UNEVICTABLE_PGMUNLOCKED = 68,
	UNEVICTABLE_PGCLEARED = 69,
	UNEVICTABLE_PGSTRANDED = 70,
	SWAP_RA = 71,
	SWAP_RA_HIT = 72,
	SWPIN_ZERO = 73,
	SWPOUT_ZERO = 74,
	DIRECT_MAP_LEVEL2_SPLIT = 75,
	DIRECT_MAP_LEVEL3_SPLIT = 76,
	KSTACK_1K = 77,
	KSTACK_2K = 78,
	KSTACK_4K = 79,
	KSTACK_8K = 80,
	KSTACK_16K = 81,
	NR_VM_EVENT_ITEMS = 82,
};

enum vm_fault_reason {
	VM_FAULT_OOM = 1,
	VM_FAULT_SIGBUS = 2,
	VM_FAULT_MAJOR = 4,
	VM_FAULT_HWPOISON = 16,
	VM_FAULT_HWPOISON_LARGE = 32,
	VM_FAULT_SIGSEGV = 64,
	VM_FAULT_NOPAGE = 256,
	VM_FAULT_LOCKED = 512,
	VM_FAULT_RETRY = 1024,
	VM_FAULT_FALLBACK = 2048,
	VM_FAULT_DONE_COW = 4096,
	VM_FAULT_NEEDDSYNC = 8192,
	VM_FAULT_COMPLETED = 16384,
	VM_FAULT_HINDEX_MASK = 983040,
};

enum vm_stat_item {
	NR_DIRTY_THRESHOLD = 0,
	NR_DIRTY_BG_THRESHOLD = 1,
	NR_MEMMAP_PAGES = 2,
	NR_MEMMAP_BOOT_PAGES = 3,
	NR_VM_STAT_ITEMS = 4,
};

enum vma_merge_flags {
	VMG_FLAG_DEFAULT = 0,
	VMG_FLAG_JUST_EXPAND = 1,
};

enum vma_merge_state {
	VMA_MERGE_START = 0,
	VMA_MERGE_ERROR_NOMEM = 1,
	VMA_MERGE_NOMERGE = 2,
	VMA_MERGE_SUCCESS = 3,
};

enum vma_resv_mode {
	VMA_NEEDS_RESV = 0,
	VMA_COMMIT_RESV = 1,
	VMA_END_RESV = 2,
	VMA_ADD_RESV = 3,
	VMA_DEL_RESV = 4,
};

enum vmscan_throttle_state {
	VMSCAN_THROTTLE_WRITEBACK = 0,
	VMSCAN_THROTTLE_ISOLATED = 1,
	VMSCAN_THROTTLE_NOPROGRESS = 2,
	VMSCAN_THROTTLE_CONGESTED = 3,
	NR_VMSCAN_THROTTLE = 4,
};

enum vmx_feature_leafs {
	MISC_FEATURES = 0,
	PRIMARY_CTLS = 1,
	SECONDARY_CTLS = 2,
	TERTIARY_CTLS_LOW = 3,
	TERTIARY_CTLS_HIGH = 4,
	NR_VMX_FEATURE_WORDS = 5,
};

enum vmx_l1d_flush_state {
	VMENTER_L1D_FLUSH_AUTO = 0,
	VMENTER_L1D_FLUSH_NEVER = 1,
	VMENTER_L1D_FLUSH_COND = 2,
	VMENTER_L1D_FLUSH_ALWAYS = 3,
	VMENTER_L1D_FLUSH_EPT_DISABLED = 4,
	VMENTER_L1D_FLUSH_NOT_REQUIRED = 5,
};

enum vp_vq_vector_policy {
	VP_VQ_VECTOR_POLICY_EACH = 0,
	VP_VQ_VECTOR_POLICY_SHARED_SLOW = 1,
	VP_VQ_VECTOR_POLICY_SHARED = 2,
};

enum wb_reason {
	WB_REASON_BACKGROUND = 0,
	WB_REASON_VMSCAN = 1,
	WB_REASON_SYNC = 2,
	WB_REASON_PERIODIC = 3,
	WB_REASON_LAPTOP_TIMER = 4,
	WB_REASON_FS_FREE_SPACE = 5,
	WB_REASON_FORKER_THREAD = 6,
	WB_REASON_FOREIGN_FLUSH = 7,
	WB_REASON_MAX = 8,
};

enum wb_stat_item {
	WB_RECLAIMABLE = 0,
	WB_WRITEBACK = 1,
	WB_DIRTIED = 2,
	WB_WRITTEN = 3,
	NR_WB_STAT_ITEMS = 4,
};

enum wb_state {
	WB_registered = 0,
	WB_writeback_running = 1,
	WB_has_dirty_io = 2,
	WB_start_all = 3,
};

enum wd_read_status {
	WD_READ_SUCCESS = 0,
	WD_READ_UNSTABLE = 1,
	WD_READ_SKIP = 2,
};

enum which_selector {
	FS = 0,
	GS = 1,
};

enum why_no_delegation4 {
	WND4_NOT_WANTED = 0,
	WND4_CONTENTION = 1,
	WND4_RESOURCE = 2,
	WND4_NOT_SUPP_FTYPE = 3,
	WND4_WRITE_DELEG_NOT_SUPP_FTYPE = 4,
	WND4_NOT_SUPP_UPGRADE = 5,
	WND4_NOT_SUPP_DOWNGRADE = 6,
	WND4_CANCELLED = 7,
	WND4_IS_DIR = 8,
};

enum wiphy_flags {
	WIPHY_FLAG_SUPPORTS_EXT_KEK_KCK = 1,
	WIPHY_FLAG_SUPPORTS_MLO = 2,
	WIPHY_FLAG_SPLIT_SCAN_6GHZ = 4,
	WIPHY_FLAG_NETNS_OK = 8,
	WIPHY_FLAG_PS_ON_BY_DEFAULT = 16,
	WIPHY_FLAG_4ADDR_AP = 32,
	WIPHY_FLAG_4ADDR_STATION = 64,
	WIPHY_FLAG_CONTROL_PORT_PROTOCOL = 128,
	WIPHY_FLAG_IBSS_RSN = 256,
	WIPHY_FLAG_DISABLE_WEXT = 512,
	WIPHY_FLAG_MESH_AUTH = 1024,
	WIPHY_FLAG_SUPPORTS_EXT_KCK_32 = 2048,
	WIPHY_FLAG_SUPPORTS_NSTR_NONPRIMARY = 4096,
	WIPHY_FLAG_SUPPORTS_FW_ROAM = 8192,
	WIPHY_FLAG_AP_UAPSD = 16384,
	WIPHY_FLAG_SUPPORTS_TDLS = 32768,
	WIPHY_FLAG_TDLS_EXTERNAL_SETUP = 65536,
	WIPHY_FLAG_HAVE_AP_SME = 131072,
	WIPHY_FLAG_REPORTS_OBSS = 262144,
	WIPHY_FLAG_AP_PROBE_RESP_OFFLOAD = 524288,
	WIPHY_FLAG_OFFCHAN_TX = 1048576,
	WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL = 2097152,
	WIPHY_FLAG_SUPPORTS_5_10_MHZ = 4194304,
	WIPHY_FLAG_HAS_CHANNEL_SWITCH = 8388608,
	WIPHY_FLAG_NOTIFY_REGDOM_BY_DRIVER = 16777216,
	WIPHY_FLAG_CHANNEL_CHANGE_ON_BEACON = 33554432,
};

enum wiphy_opmode_flag {
	STA_OPMODE_MAX_BW_CHANGED = 1,
	STA_OPMODE_SMPS_MODE_CHANGED = 2,
	STA_OPMODE_N_SS_CHANGED = 4,
};

enum wiphy_params_flags {
	WIPHY_PARAM_RETRY_SHORT = 1,
	WIPHY_PARAM_RETRY_LONG = 2,
	WIPHY_PARAM_FRAG_THRESHOLD = 4,
	WIPHY_PARAM_RTS_THRESHOLD = 8,
	WIPHY_PARAM_COVERAGE_CLASS = 16,
	WIPHY_PARAM_DYN_ACK = 32,
	WIPHY_PARAM_TXQ_LIMIT = 64,
	WIPHY_PARAM_TXQ_MEMORY_LIMIT = 128,
	WIPHY_PARAM_TXQ_QUANTUM = 256,
};

enum wiphy_vendor_command_flags {
	WIPHY_VENDOR_CMD_NEED_WDEV = 1,
	WIPHY_VENDOR_CMD_NEED_NETDEV = 2,
	WIPHY_VENDOR_CMD_NEED_RUNNING = 4,
};

enum wiphy_wowlan_support_flags {
	WIPHY_WOWLAN_ANY = 1,
	WIPHY_WOWLAN_MAGIC_PKT = 2,
	WIPHY_WOWLAN_DISCONNECT = 4,
	WIPHY_WOWLAN_SUPPORTS_GTK_REKEY = 8,
	WIPHY_WOWLAN_GTK_REKEY_FAILURE = 16,
	WIPHY_WOWLAN_EAP_IDENTITY_REQ = 32,
	WIPHY_WOWLAN_4WAY_HANDSHAKE = 64,
	WIPHY_WOWLAN_RFKILL_RELEASE = 128,
	WIPHY_WOWLAN_NET_DETECT = 256,
};

enum wmi_brightness_method {
	WMI_BRIGHTNESS_METHOD_LEVEL = 1,
	WMI_BRIGHTNESS_METHOD_SOURCE = 2,
	WMI_BRIGHTNESS_METHOD_MAX = 3,
};

enum wmi_brightness_mode {
	WMI_BRIGHTNESS_MODE_GET = 0,
	WMI_BRIGHTNESS_MODE_SET = 1,
	WMI_BRIGHTNESS_MODE_GET_MAX_LEVEL = 2,
	WMI_BRIGHTNESS_MODE_MAX = 3,
};

enum wmi_brightness_source {
	WMI_BRIGHTNESS_SOURCE_GPU = 1,
	WMI_BRIGHTNESS_SOURCE_EC = 2,
	WMI_BRIGHTNESS_SOURCE_AUX = 3,
	WMI_BRIGHTNESS_SOURCE_MAX = 4,
};

enum work_bits {
	WORK_STRUCT_PENDING_BIT = 0,
	WORK_STRUCT_INACTIVE_BIT = 1,
	WORK_STRUCT_PWQ_BIT = 2,
	WORK_STRUCT_LINKED_BIT = 3,
	WORK_STRUCT_FLAG_BITS = 4,
	WORK_STRUCT_COLOR_SHIFT = 4,
	WORK_STRUCT_COLOR_BITS = 4,
	WORK_STRUCT_PWQ_SHIFT = 8,
	WORK_OFFQ_FLAG_SHIFT = 4,
	WORK_OFFQ_BH_BIT = 4,
	WORK_OFFQ_FLAG_END = 5,
	WORK_OFFQ_FLAG_BITS = 1,
	WORK_OFFQ_DISABLE_SHIFT = 5,
	WORK_OFFQ_DISABLE_BITS = 16,
	WORK_OFFQ_POOL_SHIFT = 21,
	WORK_OFFQ_LEFT = 43,
	WORK_OFFQ_POOL_BITS = 31,
};

enum work_cancel_flags {
	WORK_CANCEL_DELAYED = 1,
	WORK_CANCEL_DISABLE = 2,
};

enum work_flags {
	WORK_STRUCT_PENDING = 1,
	WORK_STRUCT_INACTIVE = 2,
	WORK_STRUCT_PWQ = 4,
	WORK_STRUCT_LINKED = 8,
	WORK_STRUCT_STATIC = 0,
};

enum worker_flags {
	WORKER_DIE = 2,
	WORKER_IDLE = 4,
	WORKER_PREP = 8,
	WORKER_CPU_INTENSIVE = 64,
	WORKER_UNBOUND = 128,
	WORKER_REBOUND = 256,
	WORKER_NOT_RUNNING = 456,
};

enum worker_pool_flags {
	POOL_BH = 1,
	POOL_MANAGER_ACTIVE = 2,
	POOL_DISASSOCIATED = 4,
	POOL_BH_DRAINING = 8,
};

enum wq_affn_scope {
	WQ_AFFN_DFL = 0,
	WQ_AFFN_CPU = 1,
	WQ_AFFN_SMT = 2,
	WQ_AFFN_CACHE = 3,
	WQ_AFFN_NUMA = 4,
	WQ_AFFN_SYSTEM = 5,
	WQ_AFFN_NR_TYPES = 6,
};

enum wq_consts {
	WQ_MAX_ACTIVE = 2048,
	WQ_UNBOUND_MAX_ACTIVE = 2048,
	WQ_DFL_ACTIVE = 1024,
	WQ_DFL_MIN_ACTIVE = 8,
};

enum wq_flags {
	WQ_BH = 1,
	WQ_UNBOUND = 2,
	WQ_FREEZABLE = 4,
	WQ_MEM_RECLAIM = 8,
	WQ_HIGHPRI = 16,
	WQ_CPU_INTENSIVE = 32,
	WQ_SYSFS = 64,
	WQ_POWER_EFFICIENT = 128,
	__WQ_DESTROYING = 32768,
	__WQ_DRAINING = 65536,
	__WQ_ORDERED = 131072,
	__WQ_LEGACY = 262144,
	__WQ_BH_ALLOWS = 17,
};

enum wq_internal_consts {
	NR_STD_WORKER_POOLS = 2,
	UNBOUND_POOL_HASH_ORDER = 6,
	BUSY_WORKER_HASH_ORDER = 6,
	MAX_IDLE_WORKERS_RATIO = 4,
	IDLE_WORKER_TIMEOUT = 300000,
	MAYDAY_INITIAL_TIMEOUT = 10,
	MAYDAY_INTERVAL = 100,
	CREATE_COOLDOWN = 1000,
	RESCUER_NICE_LEVEL = -20,
	HIGHPRI_NICE_LEVEL = -20,
	WQ_NAME_LEN = 32,
	WORKER_ID_LEN = 42,
};

enum wq_misc_consts {
	WORK_NR_COLORS = 16,
	WORK_CPU_UNBOUND = 64,
	WORK_BUSY_PENDING = 1,
	WORK_BUSY_RUNNING = 2,
	WORKER_DESC_LEN = 32,
};

enum writeback_sync_modes {
	WB_SYNC_NONE = 0,
	WB_SYNC_ALL = 1,
};

enum x509_actions {
	ACT_x509_extract_key_data = 0,
	ACT_x509_extract_name_segment = 1,
	ACT_x509_note_OID = 2,
	ACT_x509_note_issuer = 3,
	ACT_x509_note_not_after = 4,
	ACT_x509_note_not_before = 5,
	ACT_x509_note_params = 6,
	ACT_x509_note_serial = 7,
	ACT_x509_note_sig_algo = 8,
	ACT_x509_note_signature = 9,
	ACT_x509_note_subject = 10,
	ACT_x509_note_tbs_certificate = 11,
	ACT_x509_process_extension = 12,
	NR__x509_actions = 13,
};

enum x509_akid_actions {
	ACT_x509_akid_note_kid = 0,
	ACT_x509_akid_note_name = 1,
	ACT_x509_akid_note_serial = 2,
	ACT_x509_extract_name_segment___2 = 3,
	ACT_x509_note_OID___2 = 4,
	NR__x509_akid_actions = 5,
};

enum x86_hardware_subarch {
	X86_SUBARCH_PC = 0,
	X86_SUBARCH_LGUEST = 1,
	X86_SUBARCH_XEN = 2,
	X86_SUBARCH_INTEL_MID = 3,
	X86_SUBARCH_CE4100 = 4,
	X86_NR_SUBARCHS = 5,
};

enum x86_hypervisor_type {
	X86_HYPER_NATIVE = 0,
	X86_HYPER_VMWARE = 1,
	X86_HYPER_MS_HYPERV = 2,
	X86_HYPER_XEN_PV = 3,
	X86_HYPER_XEN_HVM = 4,
	X86_HYPER_KVM = 5,
	X86_HYPER_JAILHOUSE = 6,
	X86_HYPER_ACRN = 7,
};

enum x86_intercept_stage;

enum x86_legacy_i8042_state {
	X86_LEGACY_I8042_PLATFORM_ABSENT = 0,
	X86_LEGACY_I8042_FIRMWARE_ABSENT = 1,
	X86_LEGACY_I8042_EXPECTED_PRESENT = 2,
};

enum x86_pf_error_code {
	X86_PF_PROT = 1,
	X86_PF_WRITE = 2,
	X86_PF_USER = 4,
	X86_PF_RSVD = 8,
	X86_PF_INSTR = 16,
	X86_PF_PK = 32,
	X86_PF_SHSTK = 64,
	X86_PF_SGX = 32768,
	X86_PF_RMP = 2147483648,
};

enum x86_regset_32 {
	REGSET32_GENERAL = 0,
	REGSET32_FP = 1,
	REGSET32_XFP = 2,
	REGSET32_XSTATE = 3,
	REGSET32_TLS = 4,
	REGSET32_IOPERM = 5,
};

enum x86_regset_64 {
	REGSET64_GENERAL = 0,
	REGSET64_FP = 1,
	REGSET64_IOPERM = 2,
	REGSET64_XSTATE = 3,
	REGSET64_SSP = 4,
};

enum x86_topology_cpu_type {
	TOPO_CPU_TYPE_PERFORMANCE = 0,
	TOPO_CPU_TYPE_EFFICIENCY = 1,
	TOPO_CPU_TYPE_UNKNOWN = 2,
};

enum x86_topology_domains {
	TOPO_SMT_DOMAIN = 0,
	TOPO_CORE_DOMAIN = 1,
	TOPO_MODULE_DOMAIN = 2,
	TOPO_TILE_DOMAIN = 3,
	TOPO_DIE_DOMAIN = 4,
	TOPO_DIEGRP_DOMAIN = 5,
	TOPO_PKG_DOMAIN = 6,
	TOPO_MAX_DOMAIN = 7,
};

enum xa_lock_type {
	XA_LOCK_IRQ = 1,
	XA_LOCK_BH = 2,
};

enum xdp_action {
	XDP_ABORTED = 0,
	XDP_DROP = 1,
	XDP_PASS = 2,
	XDP_TX = 3,
	XDP_REDIRECT = 4,
};

enum xdp_buff_flags {
	XDP_FLAGS_HAS_FRAGS = 1,
	XDP_FLAGS_FRAGS_PF_MEMALLOC = 2,
};

enum xdp_mem_type {
	MEM_TYPE_PAGE_SHARED = 0,
	MEM_TYPE_PAGE_ORDER0 = 1,
	MEM_TYPE_PAGE_POOL = 2,
	MEM_TYPE_XSK_BUFF_POOL = 3,
	MEM_TYPE_MAX = 4,
};

enum xdp_rss_hash_type {
	XDP_RSS_L3_IPV4 = 1,
	XDP_RSS_L3_IPV6 = 2,
	XDP_RSS_L3_DYNHDR = 4,
	XDP_RSS_L4 = 8,
	XDP_RSS_L4_TCP = 16,
	XDP_RSS_L4_UDP = 32,
	XDP_RSS_L4_SCTP = 64,
	XDP_RSS_L4_IPSEC = 128,
	XDP_RSS_L4_ICMP = 256,
	XDP_RSS_TYPE_NONE = 0,
	XDP_RSS_TYPE_L2 = 0,
	XDP_RSS_TYPE_L3_IPV4 = 1,
	XDP_RSS_TYPE_L3_IPV6 = 2,
	XDP_RSS_TYPE_L3_IPV4_OPT = 5,
	XDP_RSS_TYPE_L3_IPV6_EX = 6,
	XDP_RSS_TYPE_L4_ANY = 8,
	XDP_RSS_TYPE_L4_IPV4_TCP = 25,
	XDP_RSS_TYPE_L4_IPV4_UDP = 41,
	XDP_RSS_TYPE_L4_IPV4_SCTP = 73,
	XDP_RSS_TYPE_L4_IPV4_IPSEC = 137,
	XDP_RSS_TYPE_L4_IPV4_ICMP = 265,
	XDP_RSS_TYPE_L4_IPV6_TCP = 26,
	XDP_RSS_TYPE_L4_IPV6_UDP = 42,
	XDP_RSS_TYPE_L4_IPV6_SCTP = 74,
	XDP_RSS_TYPE_L4_IPV6_IPSEC = 138,
	XDP_RSS_TYPE_L4_IPV6_ICMP = 266,
	XDP_RSS_TYPE_L4_IPV6_TCP_EX = 30,
	XDP_RSS_TYPE_L4_IPV6_UDP_EX = 46,
	XDP_RSS_TYPE_L4_IPV6_SCTP_EX = 78,
};

enum xdp_rx_metadata {
	XDP_METADATA_KFUNC_RX_TIMESTAMP = 0,
	XDP_METADATA_KFUNC_RX_HASH = 1,
	XDP_METADATA_KFUNC_RX_VLAN_TAG = 2,
	MAX_XDP_METADATA_KFUNC = 3,
};

enum xen_domain_type {
	XEN_NATIVE = 0,
	XEN_PV_DOMAIN = 1,
	XEN_HVM_DOMAIN = 2,
};

enum xfeature {
	XFEATURE_FP = 0,
	XFEATURE_SSE = 1,
	XFEATURE_YMM = 2,
	XFEATURE_BNDREGS = 3,
	XFEATURE_BNDCSR = 4,
	XFEATURE_OPMASK = 5,
	XFEATURE_ZMM_Hi256 = 6,
	XFEATURE_Hi16_ZMM = 7,
	XFEATURE_PT_UNIMPLEMENTED_SO_FAR = 8,
	XFEATURE_PKRU = 9,
	XFEATURE_PASID = 10,
	XFEATURE_CET_USER = 11,
	XFEATURE_CET_KERNEL_UNUSED = 12,
	XFEATURE_RSRVD_COMP_13 = 13,
	XFEATURE_RSRVD_COMP_14 = 14,
	XFEATURE_LBR = 15,
	XFEATURE_RSRVD_COMP_16 = 16,
	XFEATURE_XTILE_CFG = 17,
	XFEATURE_XTILE_DATA = 18,
	XFEATURE_MAX = 19,
};

enum xfer_buf_dir {
	TO_XFER_BUF = 0,
	FROM_XFER_BUF = 1,
};

enum xfrm_ae_ftype_t {
	XFRM_AE_UNSPEC = 0,
	XFRM_AE_RTHR = 1,
	XFRM_AE_RVAL = 2,
	XFRM_AE_LVAL = 4,
	XFRM_AE_ETHR = 8,
	XFRM_AE_CR = 16,
	XFRM_AE_CE = 32,
	XFRM_AE_CU = 64,
	__XFRM_AE_MAX = 65,
};

enum xfrm_attr_type_t {
	XFRMA_UNSPEC = 0,
	XFRMA_ALG_AUTH = 1,
	XFRMA_ALG_CRYPT = 2,
	XFRMA_ALG_COMP = 3,
	XFRMA_ENCAP = 4,
	XFRMA_TMPL = 5,
	XFRMA_SA = 6,
	XFRMA_POLICY = 7,
	XFRMA_SEC_CTX = 8,
	XFRMA_LTIME_VAL = 9,
	XFRMA_REPLAY_VAL = 10,
	XFRMA_REPLAY_THRESH = 11,
	XFRMA_ETIMER_THRESH = 12,
	XFRMA_SRCADDR = 13,
	XFRMA_COADDR = 14,
	XFRMA_LASTUSED = 15,
	XFRMA_POLICY_TYPE = 16,
	XFRMA_MIGRATE = 17,
	XFRMA_ALG_AEAD = 18,
	XFRMA_KMADDRESS = 19,
	XFRMA_ALG_AUTH_TRUNC = 20,
	XFRMA_MARK = 21,
	XFRMA_TFCPAD = 22,
	XFRMA_REPLAY_ESN_VAL = 23,
	XFRMA_SA_EXTRA_FLAGS = 24,
	XFRMA_PROTO = 25,
	XFRMA_ADDRESS_FILTER = 26,
	XFRMA_PAD = 27,
	XFRMA_OFFLOAD_DEV = 28,
	XFRMA_SET_MARK = 29,
	XFRMA_SET_MARK_MASK = 30,
	XFRMA_IF_ID = 31,
	XFRMA_MTIMER_THRESH = 32,
	XFRMA_SA_DIR = 33,
	XFRMA_NAT_KEEPALIVE_INTERVAL = 34,
	XFRMA_SA_PCPU = 35,
	XFRMA_IPTFS_DROP_TIME = 36,
	XFRMA_IPTFS_REORDER_WINDOW = 37,
	XFRMA_IPTFS_DONT_FRAG = 38,
	XFRMA_IPTFS_INIT_DELAY = 39,
	XFRMA_IPTFS_MAX_QSIZE = 40,
	XFRMA_IPTFS_PKT_SIZE = 41,
	__XFRMA_MAX = 42,
};

enum xfrm_nlgroups {
	XFRMNLGRP_NONE = 0,
	XFRMNLGRP_ACQUIRE = 1,
	XFRMNLGRP_EXPIRE = 2,
	XFRMNLGRP_SA = 3,
	XFRMNLGRP_POLICY = 4,
	XFRMNLGRP_AEVENTS = 5,
	XFRMNLGRP_REPORT = 6,
	XFRMNLGRP_MIGRATE = 7,
	XFRMNLGRP_MAPPING = 8,
	__XFRMNLGRP_MAX = 9,
};

enum xfrm_pol_inexact_candidate_type {
	XFRM_POL_CAND_BOTH = 0,
	XFRM_POL_CAND_SADDR = 1,
	XFRM_POL_CAND_DADDR = 2,
	XFRM_POL_CAND_ANY = 3,
	XFRM_POL_CAND_MAX = 4,
};

enum xfrm_replay_mode {
	XFRM_REPLAY_MODE_LEGACY = 0,
	XFRM_REPLAY_MODE_BMP = 1,
	XFRM_REPLAY_MODE_ESN = 2,
};

enum xfrm_sa_dir {
	XFRM_SA_DIR_IN = 1,
	XFRM_SA_DIR_OUT = 2,
};

enum xfrm_sadattr_type_t {
	XFRMA_SAD_UNSPEC = 0,
	XFRMA_SAD_CNT = 1,
	XFRMA_SAD_HINFO = 2,
	__XFRMA_SAD_MAX = 3,
};

enum xfrm_spdattr_type_t {
	XFRMA_SPD_UNSPEC = 0,
	XFRMA_SPD_INFO = 1,
	XFRMA_SPD_HINFO = 2,
	XFRMA_SPD_IPV4_HTHRESH = 3,
	XFRMA_SPD_IPV6_HTHRESH = 4,
	__XFRMA_SPD_MAX = 5,
};

enum xhci_cancelled_td_status {
	TD_DIRTY = 0,
	TD_HALTED = 1,
	TD_CLEARING_CACHE = 2,
	TD_CLEARING_CACHE_DEFERRED = 3,
	TD_CLEARED = 4,
};

enum xhci_ep_reset_type {
	EP_HARD_RESET = 0,
	EP_SOFT_RESET = 1,
};

enum xhci_overhead_type {
	LS_OVERHEAD_TYPE = 0,
	FS_OVERHEAD_TYPE = 1,
	HS_OVERHEAD_TYPE = 2,
};

enum xhci_ring_type {
	TYPE_CTRL = 0,
	TYPE_ISOC = 1,
	TYPE_BULK = 2,
	TYPE_INTR = 3,
	TYPE_STREAM = 4,
	TYPE_COMMAND = 5,
	TYPE_EVENT = 6,
};

enum xhci_setup_dev {
	SETUP_CONTEXT_ONLY = 0,
	SETUP_CONTEXT_ADDRESS = 1,
};

enum xprt_transports {
	XPRT_TRANSPORT_UDP = 17,
	XPRT_TRANSPORT_TCP = 6,
	XPRT_TRANSPORT_BC_TCP = -2147483642,
	XPRT_TRANSPORT_RDMA = 256,
	XPRT_TRANSPORT_BC_RDMA = -2147483392,
	XPRT_TRANSPORT_LOCAL = 257,
	XPRT_TRANSPORT_TCP_TLS = 258,
};

enum xprt_xid_rb_cmp {
	XID_RB_EQUAL = 0,
	XID_RB_LEFT = 1,
	XID_RB_RIGHT = 2,
};

enum xprtsec_policies {
	RPC_XPRTSEC_NONE = 0,
	RPC_XPRTSEC_TLS_ANON = 1,
	RPC_XPRTSEC_TLS_X509 = 2,
};

enum xps_map_type {
	XPS_CPUS = 0,
	XPS_RXQS = 1,
	XPS_MAPS_MAX = 2,
};

enum xstate_copy_mode {
	XSTATE_COPY_FP = 0,
	XSTATE_COPY_FX = 1,
	XSTATE_COPY_XSAVE = 2,
};

enum xt_policy_flags {
	XT_POLICY_MATCH_IN = 1,
	XT_POLICY_MATCH_OUT = 2,
	XT_POLICY_MATCH_NONE = 4,
	XT_POLICY_MATCH_STRICT = 8,
};

enum xz_check {
	XZ_CHECK_NONE = 0,
	XZ_CHECK_CRC32 = 1,
	XZ_CHECK_CRC64 = 4,
	XZ_CHECK_SHA256 = 10,
};

enum xz_mode {
	XZ_SINGLE = 0,
	XZ_PREALLOC = 1,
	XZ_DYNALLOC = 2,
};

enum xz_ret {
	XZ_OK = 0,
	XZ_STREAM_END = 1,
	XZ_UNSUPPORTED_CHECK = 2,
	XZ_MEM_ERROR = 3,
	XZ_MEMLIMIT_ERROR = 4,
	XZ_FORMAT_ERROR = 5,
	XZ_OPTIONS_ERROR = 6,
	XZ_DATA_ERROR = 7,
	XZ_BUF_ERROR = 8,
};

enum yukon_ec_rev {
	CHIP_REV_YU_EC_A1 = 0,
	CHIP_REV_YU_EC_A2 = 1,
	CHIP_REV_YU_EC_A3 = 2,
};

enum yukon_ec_u_rev {
	CHIP_REV_YU_EC_U_A0 = 1,
	CHIP_REV_YU_EC_U_A1 = 2,
	CHIP_REV_YU_EC_U_B0 = 3,
	CHIP_REV_YU_EC_U_B1 = 5,
};

enum yukon_ex_rev {
	CHIP_REV_YU_EX_A0 = 1,
	CHIP_REV_YU_EX_B0 = 2,
};

enum yukon_fe_p_rev {
	CHIP_REV_YU_FE2_A0 = 0,
};

enum yukon_prm_rev {
	CHIP_REV_YU_PRM_Z1 = 1,
	CHIP_REV_YU_PRM_A0 = 2,
};

enum yukon_supr_rev {
	CHIP_REV_YU_SU_A0 = 0,
	CHIP_REV_YU_SU_B0 = 1,
	CHIP_REV_YU_SU_B1 = 3,
};

enum yukon_xl_rev {
	CHIP_REV_YU_XL_A0 = 0,
	CHIP_REV_YU_XL_A1 = 1,
	CHIP_REV_YU_XL_A2 = 2,
	CHIP_REV_YU_XL_A3 = 3,
};

enum zone_flags {
	ZONE_BOOSTED_WATERMARK = 0,
	ZONE_RECLAIM_ACTIVE = 1,
	ZONE_BELOW_HIGH = 2,
};

enum zone_stat_item {
	NR_FREE_PAGES = 0,
	NR_ZONE_LRU_BASE = 1,
	NR_ZONE_INACTIVE_ANON = 1,
	NR_ZONE_ACTIVE_ANON = 2,
	NR_ZONE_INACTIVE_FILE = 3,
	NR_ZONE_ACTIVE_FILE = 4,
	NR_ZONE_UNEVICTABLE = 5,
	NR_ZONE_WRITE_PENDING = 6,
	NR_MLOCK = 7,
	NR_BOUNCE = 8,
	NR_FREE_CMA_PAGES = 9,
	NR_VM_ZONE_STAT_ITEMS = 10,
};

enum zone_type {
	ZONE_DMA = 0,
	ZONE_DMA32 = 1,
	ZONE_NORMAL = 2,
	ZONE_MOVABLE = 3,
	__MAX_NR_ZONES = 4,
};

enum zone_watermarks {
	WMARK_MIN = 0,
	WMARK_LOW = 1,
	WMARK_HIGH = 2,
	WMARK_PROMO = 3,
	NR_WMARK = 4,
};

typedef _Bool bool;

typedef __int128 unsigned __u128;

typedef __u128 u128;

typedef u128 freelist_full_t;

typedef char __pad_after_uframe[0];

typedef char __pad_before_u32[0];

typedef char __pad_before_uframe[0];

typedef char acpi_bus_id[8];

typedef char acpi_device_class[20];

typedef char acpi_device_name[40];

typedef char *acpi_string;

typedef const char (* const ethnl_string_array_t)[32];

typedef int __kernel_clockid_t;

typedef int __kernel_daddr_t;

typedef int __kernel_ipc_pid_t;

typedef int __kernel_key_t;

typedef int __kernel_mqd_t;

typedef int __kernel_pid_t;

typedef int __kernel_rwf_t;

typedef int __kernel_timer_t;

typedef int __s32;

typedef int class_get_unused_fd_t;

typedef __kernel_clockid_t clockid_t;

typedef __s32 s32;

typedef s32 compat_clock_t;

typedef s32 compat_daddr_t;

typedef s32 compat_int_t;

typedef s32 compat_key_t;

typedef s32 compat_long_t;

typedef s32 compat_off_t;

typedef s32 compat_pid_t;

typedef s32 compat_ssize_t;

typedef s32 compat_timer_t;

typedef int cydp_t;

typedef s32 dma_cookie_t;

typedef int ext4_grpblk_t;

typedef int folio_walk_flags_t;

typedef int fpb_t;

typedef int fpi_t;

typedef int initcall_entry_t;

typedef int insn_value_t;

typedef s32 int32_t;

typedef int32_t key_serial_t;

typedef __kernel_key_t key_t;

typedef int mpi_size_t;

typedef __kernel_mqd_t mqd_t;

typedef s32 old_time32_t;

typedef int pci_power_t;

typedef __kernel_pid_t pid_t;

typedef int rmap_t;

typedef __kernel_rwf_t rwf_t;

typedef __s32 sctp_assoc_t;

typedef int snd_ctl_elem_iface_t;

typedef int snd_ctl_elem_type_t;

typedef int snd_pcm_access_t;

typedef int snd_pcm_format_t;

typedef int snd_pcm_hw_param_t;

typedef int snd_pcm_state_t;

typedef int snd_pcm_subformat_t;

typedef int snd_seq_client_type_t;

typedef int suspend_state_t;

typedef __kernel_timer_t timer_t;

typedef const int tracepoint_ptr_t;

typedef long int __kernel_long_t;

typedef __kernel_long_t __kernel_clock_t;

typedef __kernel_long_t __kernel_off_t;

typedef __kernel_long_t __kernel_old_time_t;

typedef __kernel_long_t __kernel_ptrdiff_t;

typedef __kernel_long_t __kernel_ssize_t;

typedef __kernel_long_t __kernel_suseconds_t;

typedef __kernel_clock_t clock_t;

typedef long int intptr_t;

typedef long int mpi_limb_signed_t;

typedef __kernel_off_t off_t;

typedef __kernel_ptrdiff_t ptrdiff_t;

typedef long int snd_pcm_sframes_t;

typedef __kernel_ssize_t ssize_t;

typedef __kernel_suseconds_t suseconds_t;

typedef long long int __s64;

typedef __s64 Elf64_Sxword;

typedef long long int __kernel_loff_t;

typedef long long int __kernel_time64_t;

typedef __s64 s64;

typedef s64 compat_loff_t;

typedef s64 int64_t;

typedef s64 ktime_t;

typedef __kernel_loff_t loff_t;

typedef long long int qsize_t;

typedef __s64 time64_t;

typedef long long unsigned int __u64;

typedef __u64 Elf64_Addr;

typedef __u64 Elf64_Off;

typedef __u64 Elf64_Xword;

typedef __u64 u64;

typedef u64 uint64_t;

typedef uint64_t U64;

typedef __u64 __addrpair;

typedef __u64 __be64;

typedef __u64 __le64;

typedef __u64 __virtio64;

typedef u64 acpi_bus_address;

typedef u64 acpi_integer;

typedef u64 acpi_io_address;

typedef u64 acpi_physical_address;

typedef u64 acpi_size;

typedef u64 async_cookie_t;

typedef __u64 blist_flags_t;

typedef u64 blkcnt_t;

typedef u64 clientid4;

typedef u64 compat_u64;

typedef long long unsigned int cycles_t;

typedef u64 dma_addr_t;

typedef long long unsigned int ext4_fsblk_t;

typedef u64 gen8_pte_t;

typedef u64 gfn_t;

typedef u64 gpa_t;

typedef u64 hfn_t;

typedef u64 hpa_t;

typedef u64 io_req_flags_t;

typedef hfn_t kvm_pfn_t;

typedef long long unsigned int llu;

typedef u64 netdev_features_t;

typedef u64 pci_bus_addr_t;

typedef u64 phys_addr_t;

typedef u64 sector_t;

typedef sector_t region_t;

typedef phys_addr_t resource_size_t;

typedef u64 sci_t;

typedef __u64 timeu64_t;

typedef u64 u_int64_t;

typedef u64 upf_t;

typedef uint64_t vli_type;

typedef long unsigned int mpi_limb_t;

typedef mpi_limb_t UWtype;

typedef long unsigned int __kernel_old_dev_t;

typedef long unsigned int __kernel_ulong_t;

typedef __kernel_ulong_t __kernel_size_t;

typedef __kernel_ulong_t aio_context_t;

typedef long unsigned int efi_status_t;

typedef long unsigned int elf_greg_t;

typedef elf_greg_t elf_gregset_t[27];

typedef long unsigned int gva_t;

typedef __kernel_ulong_t ino_t;

typedef long unsigned int irq_hw_number_t;

typedef long unsigned int kernel_ulong_t;

typedef long unsigned int kimage_entry_t;

typedef long unsigned int mce_banks_t[1];

typedef mpi_limb_t *mpi_ptr_t;

typedef long unsigned int netmem_ref;

typedef long unsigned int old_sigset_t;

typedef long unsigned int p4dval_t;

typedef long unsigned int perf_trace_t[1024];

typedef long unsigned int pgdval_t;

typedef long unsigned int pgprotval_t;

typedef long unsigned int pmdval_t;

typedef long unsigned int pte_marker;

typedef long unsigned int pteval_t;

typedef long unsigned int pudval_t;

typedef __kernel_size_t size_t;

typedef long unsigned int snd_pcm_uframes_t;

typedef long unsigned int uLong;

typedef long unsigned int u_long;

typedef long unsigned int uintptr_t;

typedef long unsigned int ulg;

typedef long unsigned int ulong;

typedef uintptr_t uptrval;

typedef long unsigned int vm_flags_t;

typedef short int __s16;

typedef __s16 s16;

typedef s16 int16_t;

typedef int16_t S16;

typedef short unsigned int __u16;

typedef __u16 Elf32_Half;

typedef __u16 Elf64_Half;

typedef short unsigned int ush;

typedef ush Pos;

typedef __u16 u16;

typedef u16 uint16_t;

typedef uint16_t U16;

typedef __u16 __be16;

typedef u16 __compat_gid_t;

typedef u16 __compat_uid_t;

typedef __u16 __hc16;

typedef short unsigned int __kernel_gid16_t;

typedef short unsigned int __kernel_old_gid_t;

typedef short unsigned int __kernel_old_uid_t;

typedef short unsigned int __kernel_sa_family_t;

typedef short unsigned int __kernel_uid16_t;

typedef __u16 __le16;

typedef __u16 __sum16;

typedef __u16 __virtio16;

typedef u16 acpi_owner_id;

typedef u16 acpi_rs_length;

typedef __u16 bitmap_counter_t;

typedef u16 blk_short_t;

typedef __u16 comp_t;

typedef u16 compat_dev_t;

typedef u16 compat_ipc_pid_t;

typedef u16 compat_mode_t;

typedef u16 compat_nlink_t;

typedef u16 compat_ushort_t;

typedef u16 efi_char16_t;

typedef __kernel_gid16_t gid16_t;

typedef u16 hda_nid_t;

typedef __kernel_old_gid_t old_gid_t;

typedef __kernel_old_uid_t old_uid_t;

typedef short unsigned int pci_bus_flags_t;

typedef short unsigned int pci_dev_flags_t;

typedef __kernel_sa_family_t sa_family_t;

typedef u16 u_int16_t;

typedef short unsigned int u_short;

typedef u16 ucs2_char_t;

typedef __kernel_uid16_t uid16_t;

typedef __u16 uio_meta_flags_t;

typedef short unsigned int umode_t;

typedef short unsigned int ushort;

typedef short unsigned int vifi_t;

typedef u16 wchar_t;

typedef signed char __s8;

typedef __s8 s8;

typedef s8 int8_t;

typedef unsigned char __u8;

typedef __u8 u8;

typedef u8 uint8_t;

typedef uint8_t BYTE;

typedef unsigned char Byte;

typedef uint8_t U8;

typedef u8 acpi_adr_space_type;

typedef u8 blk_status_t;

typedef unsigned char cc_t;

typedef unsigned char cisdata_t;

typedef u8 dscp_t;

typedef __u8 dvd_challenge[10];

typedef __u8 dvd_key[5];

typedef u8 efi_bool_t;

typedef unsigned char insn_byte_t;

typedef u8 kprobe_opcode_t;

typedef __u8 mtrr_type;

typedef u8 retpoline_thunk_t[32];

typedef unsigned char snd_seq_event_type_t;

typedef unsigned char u8___2;

typedef unsigned char u_char;

typedef u8 u_int8_t;

typedef unsigned char uch;

typedef u8 uprobe_opcode_t;

typedef __u8 virtio_net_ctrl_ack;

typedef unsigned int __u32;

typedef __u32 Elf32_Addr;

typedef __u32 Elf32_Off;

typedef __u32 Elf32_Word;

typedef __u32 Elf64_Word;

typedef unsigned int FSE_DTable;

typedef __u32 u32;

typedef u32 uint32_t;

typedef uint32_t U32;

typedef U32 HUF_DTable;

typedef unsigned int IPos;

typedef unsigned int OM_uint32;

typedef unsigned int UHWtype;

typedef __u32 __be32;

typedef u32 __compat_gid32_t;

typedef u32 __compat_uid32_t;

typedef __u32 __hc32;

typedef u32 __kernel_dev_t;

typedef unsigned int __kernel_gid32_t;

typedef unsigned int __kernel_gid_t;

typedef unsigned int __kernel_mode_t;

typedef unsigned int __kernel_uid32_t;

typedef unsigned int __kernel_uid_t;

typedef __u32 __le32;

typedef unsigned int __poll_t;

typedef __u32 __portpair;

typedef __u32 __virtio32;

typedef __u32 __wsum;

typedef u32 acpi_event_status;

typedef u32 acpi_mutex_handle;

typedef u32 acpi_name;

typedef u32 acpi_object_type;

typedef u32 acpi_rsdesc_size;

typedef u32 acpi_status;

typedef unsigned int autofs_wqt_t;

typedef unsigned int blk_features_t;

typedef unsigned int blk_flags_t;

typedef unsigned int blk_insert_t;

typedef unsigned int blk_mode_t;

typedef __u32 blk_mq_req_flags_t;

typedef __u32 blk_opf_t;

typedef unsigned int blk_qc_t;

typedef u32 codel_time_t;

typedef __u32 comp2_t;

typedef u32 compat_aio_context_t;

typedef u32 compat_caddr_t;

typedef u32 compat_ino_t;

typedef u32 compat_old_sigset_t;

typedef u32 compat_sigset_word;

typedef u32 compat_size_t;

typedef u32 compat_uint_t;

typedef u32 compat_ulong_t;

typedef u32 compat_uptr_t;

typedef u32 depot_flags_t;

typedef u32 depot_stack_handle_t;

typedef __kernel_dev_t dev_t;

typedef uint32_t drbg_flag_t;

typedef unsigned int drm_magic_t;

typedef u32 errseq_t;

typedef unsigned int ext4_group_t;

typedef __u32 ext4_lblk_t;

typedef unsigned int fgf_t;

typedef unsigned int fmode_t;

typedef unsigned int fop_flags_t;

typedef u32 gen6_pte_t;

typedef unsigned int gfp_t;

typedef __kernel_gid32_t gid_t;

typedef unsigned int ieee80211_rx_result;

typedef unsigned int ieee80211_tx_result;

typedef unsigned int insn_attr_t;

typedef u32 intel_engine_mask_t;

typedef unsigned int ioasid_t;

typedef unsigned int iov_iter_extraction_t;

typedef unsigned int isolate_mode_t;

typedef unsigned int kasan_vmalloc_flags_t;

typedef uint32_t key_perm_t;

typedef __kernel_mode_t mode_t;

typedef u32 nlink_t;

typedef u32 note_buf_t[92];

typedef unsigned int pci_channel_state_t;

typedef unsigned int pci_ers_result_t;

typedef unsigned int pgtbl_mod_mask;

typedef u32 phandle;

typedef u32 phys_cpuid_t;

typedef unsigned int pipe_index_t;

typedef __kernel_uid32_t projid_t;

typedef __kernel_uid32_t qid_t;

typedef U32 rankValCol_t[13];

typedef __u32 req_flags_t;

typedef u32 rpc_authflavor_t;

typedef __be32 rpc_fraghdr;

typedef unsigned int sk_buff_data_t;

typedef unsigned int slab_flags_t;

typedef unsigned int snd_seq_tick_time_t;

typedef unsigned int speed_t;

typedef unsigned int t_key;

typedef unsigned int tcflag_t;

typedef unsigned int tid_t;

typedef unsigned int uInt;

typedef unsigned int u_int;

typedef u32 u_int32_t;

typedef __kernel_uid32_t uid_t;

typedef unsigned int uint;

typedef u32 unicode_t;

typedef unsigned int upstat_t;

typedef u32 usb_port_location_t;

typedef unsigned int vm_fault_t;

typedef unsigned int xa_mark_t;

typedef u32 xdp_features_t;

typedef unsigned int zap_flags_t;

typedef struct {
	size_t bitContainer;
	unsigned int bitsConsumed;
	const char *ptr;
	const char *start;
	const char *limitPtr;
} BIT_DStream_t;

typedef struct {
	BYTE maxTableLog;
	BYTE tableType;
	BYTE tableLog;
	BYTE reserved;
} DTableDesc;

typedef struct {
	size_t state;
	const void *table;
} FSE_DState_t;

typedef struct {
	U16 tableLog;
	U16 fastMode;
} FSE_DTableHeader;

typedef struct {
	short int ncount[256];
	FSE_DTable dtable[0];
} FSE_DecompressWksp;

typedef struct {
	short unsigned int newState;
	unsigned char symbol;
	unsigned char nbBits;
} FSE_decode_t;

typedef struct {
	BYTE nbBits;
	BYTE byte;
} HUF_DEltX1;

typedef struct {
	U16 sequence;
	BYTE nbBits;
	BYTE length;
} HUF_DEltX2;

typedef struct {
	U32 rankVal[13];
	U32 rankStart[13];
	U32 statsWksp[218];
	BYTE symbols[256];
	BYTE huffWeight[256];
} HUF_ReadDTableX1_Workspace;

typedef struct {
	BYTE symbol;
} sortedSymbol_t;

typedef struct {
	U32 rankVal[156];
	U32 rankStats[13];
	U32 rankStart0[15];
	sortedSymbol_t sortedSymbol[256];
	BYTE weightList[256];
	U32 calleeWksp[218];
} HUF_ReadDTableX2_Workspace;

struct buffer_head;

typedef struct {
	__le32 *p;
	__le32 key;
	struct buffer_head *bh;
} Indirect;

typedef struct {
	const uint8_t *externalDict;
	size_t extDictSize;
	const uint8_t *prefixEnd;
	size_t prefixSize;
} LZ4_streamDecode_t_internal;

typedef union {
	long long unsigned int table[4];
	LZ4_streamDecode_t_internal internal_donotuse;
} LZ4_streamDecode_t;

struct list_head {
	struct list_head *next;
	struct list_head *prev;
};

typedef struct {
	int counter;
} atomic_t;

struct refcount_struct {
	atomic_t refs;
};

typedef struct refcount_struct refcount_t;

struct dentry;

struct file;

typedef struct {
	struct list_head list;
	long unsigned int flags;
	int offset;
	int size;
	char *magic;
	char *mask;
	const char *interpreter;
	char *name;
	struct dentry *dentry;
	struct file *interp_file;
	refcount_t users;
} Node;

struct folio;

typedef struct {
	struct folio *v;
} Sector;

struct ZSTD_DDict_s;

typedef struct ZSTD_DDict_s ZSTD_DDict;

typedef struct {
	const ZSTD_DDict **ddictPtrTable;
	size_t ddictPtrTableSize;
	size_t ddictPtrCount;
} ZSTD_DDictHashSet;

typedef struct {
	size_t error;
	int lowerBound;
	int upperBound;
} ZSTD_bounds;

typedef struct {
	U32 f1c;
	U32 f1d;
	U32 f7b;
	U32 f7c;
} ZSTD_cpuid_t;

typedef void * (*ZSTD_allocFunction)(void *, size_t);

typedef void (*ZSTD_freeFunction)(void *, void *);

typedef struct {
	ZSTD_allocFunction customAlloc;
	ZSTD_freeFunction customFree;
	void *opaque;
} ZSTD_customMem;

typedef struct {
	U16 nextState;
	BYTE nbAdditionalBits;
	BYTE nbBits;
	U32 baseValue;
} ZSTD_seqSymbol;

typedef struct {
	ZSTD_seqSymbol LLTable[513];
	ZSTD_seqSymbol OFTable[257];
	ZSTD_seqSymbol MLTable[513];
	HUF_DTable hufTable[4097];
	U32 rep[3];
	U32 workspace[157];
} ZSTD_entropyDTables_t;

typedef struct {
	long long unsigned int frameContentSize;
	long long unsigned int windowSize;
	unsigned int blockSizeMax;
	ZSTD_frameType_e frameType;
	unsigned int headerSize;
	unsigned int dictID;
	unsigned int checksumFlag;
} ZSTD_frameHeader;

typedef struct {
	size_t compressedSize;
	long long unsigned int decompressedBound;
} ZSTD_frameSizeInfo;

typedef struct {
	size_t state;
	const ZSTD_seqSymbol *table;
} ZSTD_fseState;

typedef struct {
	U32 fastMode;
	U32 tableLog;
} ZSTD_seqSymbol_header;

typedef struct {
	long unsigned int fds_bits[16];
} __kernel_fd_set;

typedef struct {
	int val[2];
} __kernel_fsid_t;

typedef struct {
	U32 tableTime;
	U32 decode256Time;
} algo_time_t;

typedef struct {
	s64 counter;
} atomic64_t;

typedef atomic64_t atomic_long_t;

typedef struct {
	__be64 a;
	__be64 b;
} be128;

typedef struct {
	blockType_e blockType;
	U32 lastBlock;
	U32 origSize;
} blockProperties_t;

typedef struct {
	union {
		void *kernel;
		void *user;
	};
	bool is_kernel: 1;
} sockptr_t;

typedef sockptr_t bpfptr_t;

typedef struct {
	unsigned int interval;
	unsigned int timeout;
} cisco_proto;

typedef struct {
	void *lock;
} class_cpus_read_lock_t;

struct rq;

typedef struct {
	struct rq *lock;
	struct rq *lock2;
} class_double_rq_lock_t;

typedef struct {
	void *lock;
	long unsigned int flags;
} class_irqsave_t;

typedef struct {
	void *lock;
} class_jump_label_lock_t;

struct snd_pcm_substream;

typedef struct {
	struct snd_pcm_substream *lock;
} class_pcm_stream_lock_irq_t;

typedef struct {
	struct snd_pcm_substream *lock;
	long unsigned int flags;
} class_pcm_stream_lock_irqsave_t;

typedef struct {
	void *lock;
} class_preempt_notrace_t;

typedef struct {
	void *lock;
} class_preempt_t;

struct raw_spinlock;

typedef struct raw_spinlock raw_spinlock_t;

typedef struct {
	raw_spinlock_t *lock;
} class_raw_spinlock_irq_t;

typedef struct {
	raw_spinlock_t *lock;
	long unsigned int flags;
} class_raw_spinlock_irqsave_t;

typedef struct {
	raw_spinlock_t *lock;
} class_raw_spinlock_t;

typedef struct {
	void *lock;
} class_rcu_t;

typedef struct {
	void *lock;
} class_rcu_tasks_trace_t;

struct qspinlock {
	union {
		atomic_t val;
		struct {
			u8 locked;
			u8 pending;
		};
		struct {
			u16 locked_pending;
			u16 tail;
		};
	};
};

typedef struct qspinlock arch_spinlock_t;

struct qrwlock {
	union {
		atomic_t cnts;
		struct {
			u8 wlocked;
			u8 __lstate[3];
		};
	};
	arch_spinlock_t wait_lock;
};

typedef struct qrwlock arch_rwlock_t;

typedef struct {
	arch_rwlock_t raw_lock;
} rwlock_t;

typedef struct {
	rwlock_t *lock;
	long unsigned int flags;
} class_read_lock_irqsave_t;

typedef struct {
	rwlock_t *lock;
} class_read_lock_t;

struct pin_cookie {};

struct rq_flags {
	long unsigned int flags;
	struct pin_cookie cookie;
};

typedef struct {
	struct rq *lock;
	struct rq_flags rf;
} class_rq_lock_irqsave_t;

typedef struct {
	struct rq *lock;
	struct rq_flags rf;
} class_rq_lock_t;

struct spinlock;

typedef struct spinlock spinlock_t;

typedef struct {
	spinlock_t *lock;
} class_spinlock_irq_t;

typedef struct {
	spinlock_t *lock;
	long unsigned int flags;
} class_spinlock_irqsave_t;

typedef struct {
	spinlock_t *lock;
} class_spinlock_t;

struct srcu_struct;

typedef struct {
	struct srcu_struct *lock;
	int idx;
} class_srcu_t;

struct task_struct;

typedef struct {
	struct task_struct *lock;
	struct rq *rq;
	struct rq_flags rf;
} class_task_rq_lock_t;

typedef struct {
	rwlock_t *lock;
} class_write_lock_irq_t;

typedef struct {
	rwlock_t *lock;
	long unsigned int flags;
} class_write_lock_irqsave_t;

typedef struct {
	unsigned char op;
	unsigned char bits;
	short unsigned int val;
} code;

typedef __kernel_fsid_t compat_fsid_t;

typedef struct {
	compat_sigset_word sig[2];
} compat_sigset_t;

typedef struct {
	__be16 disc_information_length;
	__u8 disc_status: 2;
	__u8 border_status: 2;
	__u8 erasable: 1;
	__u8 reserved1: 3;
	__u8 n_first_track;
	__u8 n_sessions_lsb;
	__u8 first_track_lsb;
	__u8 last_track_lsb;
	__u8 mrw_status: 2;
	__u8 dbit: 1;
	__u8 reserved2: 2;
	__u8 uru: 1;
	__u8 dbc_v: 1;
	__u8 did_v: 1;
	__u8 disc_type;
	__u8 n_sessions_msb;
	__u8 first_track_msb;
	__u8 last_track_msb;
	__u32 disc_id;
	__u32 lead_in;
	__u32 lead_out;
	__u8 disc_bar_code[8];
	__u8 reserved3;
	__u8 n_opc;
} disc_information;

typedef struct {
	long unsigned int bits[1];
} dma_cap_mask_t;

struct dvd_lu_send_agid {
	__u8 type;
	unsigned int agid: 2;
};

struct dvd_host_send_challenge {
	__u8 type;
	unsigned int agid: 2;
	dvd_challenge chal;
};

struct dvd_send_key {
	__u8 type;
	unsigned int agid: 2;
	dvd_key key;
};

struct dvd_lu_send_challenge {
	__u8 type;
	unsigned int agid: 2;
	dvd_challenge chal;
};

struct dvd_lu_send_title_key {
	__u8 type;
	unsigned int agid: 2;
	dvd_key title_key;
	int lba;
	unsigned int cpm: 1;
	unsigned int cp_sec: 1;
	unsigned int cgms: 2;
};

struct dvd_lu_send_asf {
	__u8 type;
	unsigned int agid: 2;
	unsigned int asf: 1;
};

struct dvd_host_send_rpcstate {
	__u8 type;
	__u8 pdrc;
};

struct dvd_lu_send_rpcstate {
	__u8 type: 2;
	__u8 vra: 3;
	__u8 ucca: 3;
	__u8 region_mask;
	__u8 rpc_scheme;
};

typedef union {
	__u8 type;
	struct dvd_lu_send_agid lsa;
	struct dvd_host_send_challenge hsc;
	struct dvd_send_key lsk;
	struct dvd_lu_send_challenge lsc;
	struct dvd_send_key hsk;
	struct dvd_lu_send_title_key lstk;
	struct dvd_lu_send_asf lsasf;
	struct dvd_host_send_rpcstate hrpcs;
	struct dvd_lu_send_rpcstate lrpcs;
} dvd_authinfo;

struct dvd_layer {
	__u8 book_version: 4;
	__u8 book_type: 4;
	__u8 min_rate: 4;
	__u8 disc_size: 4;
	__u8 layer_type: 4;
	__u8 track_path: 1;
	__u8 nlayers: 2;
	char: 1;
	__u8 track_density: 4;
	__u8 linear_density: 4;
	__u8 bca: 1;
	__u32 start_sector;
	__u32 end_sector;
	__u32 end_sector_l0;
};

struct dvd_physical {
	__u8 type;
	__u8 layer_num;
	struct dvd_layer layer[4];
};

struct dvd_copyright {
	__u8 type;
	__u8 layer_num;
	__u8 cpst;
	__u8 rmi;
};

struct dvd_disckey {
	__u8 type;
	unsigned int agid: 2;
	__u8 value[2048];
};

struct dvd_bca {
	__u8 type;
	int len;
	__u8 value[188];
};

struct dvd_manufact {
	__u8 type;
	__u8 layer_num;
	int len;
	__u8 value[2048];
};

typedef union {
	__u8 type;
	struct dvd_physical physical;
	struct dvd_copyright copyright;
	struct dvd_disckey disckey;
	struct dvd_bca bca;
	struct dvd_manufact manufact;
} dvd_struct;

typedef struct {
	__u8 b[16];
} guid_t;

typedef guid_t efi_guid_t;

typedef struct {
	efi_guid_t guid;
	u32 headersize;
	u32 flags;
	u32 imagesize;
} efi_capsule_header_t;

typedef struct {
	efi_guid_t guid;
	u32 table;
} efi_config_table_32_t;

typedef struct {
	efi_guid_t guid;
	u64 table;
} efi_config_table_64_t;

typedef union {
	struct {
		efi_guid_t guid;
		void *table;
	};
	efi_config_table_32_t mixed_mode;
} efi_config_table_t;

typedef struct {
	efi_guid_t guid;
	long unsigned int *ptr;
	const char name[16];
} efi_config_table_type_t;

typedef struct {
	u32 type;
	u32 pad;
	u64 phys_addr;
	u64 virt_addr;
	u64 num_pages;
	u64 attribute;
} efi_memory_desc_t;

typedef struct {
	u32 version;
	u32 num_entries;
	u32 desc_size;
	u32 flags;
	efi_memory_desc_t entry[0];
} efi_memory_attributes_table_t;

typedef struct {
	u16 version;
	u16 length;
	u32 runtime_services_supported;
} efi_rt_properties_table_t;

typedef struct {
	u64 signature;
	u32 revision;
	u32 headersize;
	u32 crc32;
	u32 reserved;
} efi_table_hdr_t;

typedef struct {
	efi_table_hdr_t hdr;
	u32 get_time;
	u32 set_time;
	u32 get_wakeup_time;
	u32 set_wakeup_time;
	u32 set_virtual_address_map;
	u32 convert_pointer;
	u32 get_variable;
	u32 get_next_variable;
	u32 set_variable;
	u32 get_next_high_mono_count;
	u32 reset_system;
	u32 update_capsule;
	u32 query_capsule_caps;
	u32 query_variable_info;
} efi_runtime_services_32_t;

typedef struct {
	u16 year;
	u8 month;
	u8 day;
	u8 hour;
	u8 minute;
	u8 second;
	u8 pad1;
	u32 nanosecond;
	s16 timezone;
	u8 daylight;
	u8 pad2;
} efi_time_t;

typedef struct {
	u32 resolution;
	u32 accuracy;
	u8 sets_to_zero;
} efi_time_cap_t;

typedef union {
	struct {
		efi_table_hdr_t hdr;
		efi_status_t (*get_time)(efi_time_t *, efi_time_cap_t *);
		efi_status_t (*set_time)(efi_time_t *);
		efi_status_t (*get_wakeup_time)(efi_bool_t *, efi_bool_t *, efi_time_t *);
		efi_status_t (*set_wakeup_time)(efi_bool_t, efi_time_t *);
		efi_status_t (*set_virtual_address_map)(long unsigned int, long unsigned int, u32, efi_memory_desc_t *);
		void *convert_pointer;
		efi_status_t (*get_variable)(efi_char16_t *, efi_guid_t *, u32 *, long unsigned int *, void *);
		efi_status_t (*get_next_variable)(long unsigned int *, efi_char16_t *, efi_guid_t *);
		efi_status_t (*set_variable)(efi_char16_t *, efi_guid_t *, u32, long unsigned int, void *);
		efi_status_t (*get_next_high_mono_count)(u32 *);
		void (*reset_system)(int, efi_status_t, long unsigned int, efi_char16_t *);
		efi_status_t (*update_capsule)(efi_capsule_header_t **, long unsigned int, long unsigned int);
		efi_status_t (*query_capsule_caps)(efi_capsule_header_t **, long unsigned int, u64 *, int *);
		efi_status_t (*query_variable_info)(u32, u64 *, u64 *, u64 *);
	};
	efi_runtime_services_32_t mixed_mode;
} efi_runtime_services_t;

typedef struct {
	efi_table_hdr_t hdr;
	u32 fw_vendor;
	u32 fw_revision;
	u32 con_in_handle;
	u32 con_in;
	u32 con_out_handle;
	u32 con_out;
	u32 stderr_handle;
	u32 stderr;
	u32 runtime;
	u32 boottime;
	u32 nr_tables;
	u32 tables;
} efi_system_table_32_t;

typedef struct {
	efi_table_hdr_t hdr;
	u64 fw_vendor;
	u32 fw_revision;
	u32 __pad1;
	u64 con_in_handle;
	u64 con_in;
	u64 con_out_handle;
	u64 con_out;
	u64 stderr_handle;
	u64 stderr;
	u64 runtime;
	u64 boottime;
	u32 nr_tables;
	u32 __pad2;
	u64 tables;
} efi_system_table_64_t;

union efi_simple_text_input_protocol;

typedef union efi_simple_text_input_protocol efi_simple_text_input_protocol_t;

union efi_simple_text_output_protocol;

typedef union efi_simple_text_output_protocol efi_simple_text_output_protocol_t;

union efi_boot_services;

typedef union efi_boot_services efi_boot_services_t;

typedef union {
	struct {
		efi_table_hdr_t hdr;
		long unsigned int fw_vendor;
		u32 fw_revision;
		long unsigned int con_in_handle;
		efi_simple_text_input_protocol_t *con_in;
		long unsigned int con_out_handle;
		efi_simple_text_output_protocol_t *con_out;
		long unsigned int stderr_handle;
		long unsigned int stderr;
		efi_runtime_services_t *runtime;
		efi_boot_services_t *boottime;
		long unsigned int nr_tables;
		long unsigned int tables;
	};
	efi_system_table_32_t mixed_mode;
} efi_system_table_t;

typedef struct {
	__le16 e_tag;
	__le16 e_perm;
	__le32 e_id;
} ext4_acl_entry;

typedef struct {
	__le32 a_version;
} ext4_acl_header;

typedef __kernel_fd_set fd_set;

typedef struct {
	long unsigned int *in;
	long unsigned int *out;
	long unsigned int *ex;
	long unsigned int *res_in;
	long unsigned int *res_out;
	long unsigned int *res_ex;
} fd_set_bits;

typedef struct {
	atomic64_t refcnt;
} file_ref_t;

typedef struct {
	unsigned int t391;
	unsigned int t392;
	unsigned int n391;
	unsigned int n392;
	unsigned int n393;
	short unsigned int lmi;
	short unsigned int dce;
} fr_proto;

typedef struct {
	unsigned int dlci;
} fr_proto_pvc;

typedef struct {
	unsigned int dlci;
	char master[16];
} fr_proto_pvc_info;

typedef union {
	struct {
		void *freelist;
		long unsigned int counter;
	};
	freelist_full_t full;
} freelist_aba_t;

typedef struct {
	long unsigned int v;
} freeptr_t;

typedef struct {
	long unsigned int key[2];
} hsiphash_key_t;

typedef struct {
	u32 reg;
} i915_mcr_reg_t;

typedef struct {
	u32 reg;
} i915_reg_t;

typedef union {
	u8 hsw[3];
	long unsigned int xehp[1];
} intel_sseu_ss_mask_t;

typedef struct {
	unsigned int __nmi_count;
	unsigned int apic_timer_irqs;
	unsigned int irq_spurious_count;
	unsigned int icr_read_retry_count;
	unsigned int x86_platform_ipis;
	unsigned int apic_perf_irqs;
	unsigned int apic_irq_work_irqs;
	unsigned int irq_resched_count;
	unsigned int irq_call_count;
	unsigned int irq_tlb_count;
	unsigned int irq_thermal_count;
	unsigned int irq_threshold_count;
	unsigned int irq_deferred_error_count;
	unsigned int irq_hv_callback_count;
	long: 64;
} irq_cpustat_t;

typedef struct {
	u64 val;
} kernel_cap_t;

typedef struct {
	gid_t val;
} kgid_t;

typedef struct {
	projid_t val;
} kprojid_t;

typedef struct {
	uid_t val;
} kuid_t;

typedef struct {
	__le64 b;
	__le64 a;
} le128;

typedef struct {
	atomic_long_t a;
} local_t;

typedef struct {
	local_t a;
} local64_t;

typedef struct {} local_lock_t;

typedef struct {} lockdep_map_p;

struct optimistic_spin_queue {
	atomic_t tail;
};

struct raw_spinlock {
	arch_spinlock_t raw_lock;
};

struct rw_semaphore {
	atomic_long_t count;
	atomic_long_t owner;
	struct optimistic_spin_queue osq;
	raw_spinlock_t wait_lock;
	struct list_head wait_list;
};

struct mutex {
	atomic_long_t owner;
	raw_spinlock_t wait_lock;
	struct optimistic_spin_queue osq;
	struct list_head wait_list;
};

struct ldt_struct;

struct vdso_image;

typedef struct {
	u64 ctx_id;
	atomic64_t tlb_gen;
	long unsigned int next_trim_cpumask;
	struct rw_semaphore ldt_usr_sem;
	struct ldt_struct *ldt;
	long unsigned int flags;
	struct mutex lock;
	void *vdso;
	const struct vdso_image *vdso_image;
	atomic_t perf_rdpmc_allowed;
	u16 pkey_allocation_map;
	s16 execute_only_pkey;
} mm_context_t;

typedef struct {} netdevice_tracker;

typedef struct {} netns_tracker;

typedef struct {
	char data[8];
} nfs4_verifier;

typedef struct {
	long unsigned int bits[1];
} nodemask_t;

typedef struct {
	p4dval_t p4d;
} p4d_t;

typedef struct {
	u64 pme;
} pagemap_entry_t;

typedef struct {
	u64 val;
} pfn_t;

typedef struct {
	pgdval_t pgd;
} pgd_t;

typedef struct {
	pmdval_t pmd;
} pmd_t;

typedef struct {
	long unsigned int bits[4];
} pnp_irq_mask_t;

struct net;

typedef struct {
	struct net *net;
} possible_net_t;

typedef struct {
	pteval_t pte;
} pte_t;

typedef struct {
	pudval_t pud;
} pud_t;

typedef struct {
	short unsigned int encoding;
	short unsigned int parity;
} raw_hdlc_proto;

typedef struct {
	atomic_t refcnt;
} rcuref_t;

typedef struct {
	size_t written;
	size_t count;
	union {
		char *buf;
		void *data;
	} arg;
	int error;
} read_descriptor_t;

typedef union {
} release_pages_arg;

typedef struct {
	__u16 report_key_length;
	__u8 reserved1;
	__u8 reserved2;
	__u8 ucca: 3;
	__u8 vra: 3;
	__u8 type_code: 2;
	__u8 region_mask;
	__u8 rpc_scheme;
	__u8 reserved3;
} rpc_state_t;

typedef struct {
	BIT_DStream_t DStream;
	ZSTD_fseState stateLL;
	ZSTD_fseState stateOffb;
	ZSTD_fseState stateML;
	size_t prevOffset[3];
} seqState_t;

typedef struct {
	size_t litLength;
	size_t matchLength;
	size_t offset;
} seq_t;

struct seqcount {
	unsigned int sequence;
};

typedef struct seqcount seqcount_t;

typedef struct {
	seqcount_t seqcount;
} seqcount_latch_t;

struct seqcount_spinlock {
	seqcount_t seqcount;
};

typedef struct seqcount_spinlock seqcount_spinlock_t;

struct spinlock {
	union {
		struct raw_spinlock rlock;
	};
};

typedef struct {
	seqcount_spinlock_t seqcount;
	spinlock_t lock;
} seqlock_t;

typedef struct {
	long unsigned int sig[1];
} sigset_t;

typedef struct {
	u64 key[2];
} siphash_key_t;

typedef atomic_t snd_use_lock_t;

struct wait_queue_head {
	spinlock_t lock;
	struct list_head head;
};

typedef struct wait_queue_head wait_queue_head_t;

typedef struct {
	spinlock_t slock;
	int owned;
	wait_queue_head_t wq;
} socket_lock_t;

typedef struct {
	char *from;
	char *to;
} substring_t;

typedef struct {
	long unsigned int val;
} swp_entry_t;

typedef struct {
	unsigned int clock_rate;
	unsigned int clock_type;
	short unsigned int loopback;
} sync_serial_settings;

typedef struct {
	unsigned int clock_rate;
	unsigned int clock_type;
	short unsigned int loopback;
	unsigned int slot_map;
} te1_settings;

struct mm_struct;

typedef struct {
	struct mm_struct *mm;
} temp_mm_state_t;

typedef struct {
	u32 high;
	u32 low;
} tg3_stat64_t;

typedef struct {
	__be16 track_information_length;
	__u8 track_lsb;
	__u8 session_lsb;
	__u8 reserved1;
	__u8 track_mode: 4;
	__u8 copy: 1;
	__u8 damage: 1;
	__u8 reserved2: 2;
	__u8 data_mode: 4;
	__u8 fp: 1;
	__u8 packet: 1;
	__u8 blank: 1;
	__u8 rt: 1;
	__u8 nwa_v: 1;
	__u8 lra_v: 1;
	__u8 reserved3: 6;
	__be32 track_start;
	__be32 next_writable;
	__be32 free_blocks;
	__be32 fixed_packet_size;
	__be32 track_size;
	__be32 last_rec_address;
} track_information;

typedef struct {
	int data;
	int audio;
	int cdi;
	int xa;
	long int error;
} tracktype;

typedef struct {
	local64_t v;
} u64_stats_t;

typedef struct {
	u32 val;
} uint_fixed_16_16_t;

typedef struct {
	__u8 b[16];
} uuid_le;

typedef struct {
	__u8 b[16];
} uuid_t;

typedef struct {
	gid_t val;
} vfsgid_t;

typedef struct {
	uid_t val;
} vfsuid_t;

typedef struct {
	short unsigned int dce;
	unsigned int modulo;
	unsigned int window;
	unsigned int t1;
	unsigned int t2;
	unsigned int n2;
} x25_hdlc_proto;

struct in6_addr {
	union {
		__u8 u6_addr8[16];
		__be16 u6_addr16[8];
		__be32 u6_addr32[4];
	} in6_u;
};

typedef union {
	__be32 a4;
	__be32 a6[4];
	struct in6_addr in6;
} xfrm_address_t;

typedef ZSTD_customMem zstd_custom_mem;

typedef ZSTD_frameHeader zstd_frame_header;

union IO_APIC_reg_00 {
	u32 raw;
	struct {
		u32 __reserved_2: 14;
		u32 LTS: 1;
		u32 delivery_type: 1;
		u32 __reserved_1: 8;
		u32 ID: 8;
	} bits;
};

union IO_APIC_reg_01 {
	u32 raw;
	struct {
		u32 version: 8;
		u32 __reserved_2: 7;
		u32 PRQ: 1;
		u32 entries: 8;
		u32 __reserved_1: 8;
	} bits;
};

union IO_APIC_reg_02 {
	u32 raw;
	struct {
		u32 __reserved_2: 24;
		u32 arbitration: 4;
		u32 __reserved_1: 4;
	} bits;
};

union IO_APIC_reg_03 {
	u32 raw;
	struct {
		u32 boot_DT: 1;
		u32 __reserved_1: 31;
	} bits;
};

struct IO_APIC_route_entry {
	union {
		struct {
			u64 vector: 8;
			u64 delivery_mode: 3;
			u64 dest_mode_logical: 1;
			u64 delivery_status: 1;
			u64 active_low: 1;
			u64 irr: 1;
			u64 is_level: 1;
			u64 masked: 1;
			u64 reserved_0: 15;
			u64 reserved_1: 17;
			u64 virt_destid_8_14: 7;
			u64 destid_0_7: 8;
		};
		struct {
			u64 ir_shared_0: 8;
			u64 ir_zero: 3;
			u64 ir_index_15: 1;
			u64 ir_shared_1: 5;
			u64 ir_reserved_0: 31;
			u64 ir_format: 1;
			u64 ir_index_0_14: 15;
		};
		struct {
			u64 w1: 32;
			u64 w2: 32;
		};
	};
};

struct hlist_node {
	struct hlist_node *next;
	struct hlist_node **pprev;
};

struct sk_buff;

struct sk_buff_list {
	struct sk_buff *next;
	struct sk_buff *prev;
};

struct sk_buff_head {
	union {
		struct {
			struct sk_buff *next;
			struct sk_buff *prev;
		};
		struct sk_buff_list list;
	};
	__u32 qlen;
	spinlock_t lock;
};

struct qdisc_skb_head {
	struct sk_buff *head;
	struct sk_buff *tail;
	__u32 qlen;
	spinlock_t lock;
};

struct u64_stats_sync {};

struct gnet_stats_basic_sync {
	u64_stats_t bytes;
	u64_stats_t packets;
	struct u64_stats_sync syncp;
};

struct gnet_stats_queue {
	__u32 qlen;
	__u32 backlog;
	__u32 drops;
	__u32 requeues;
	__u32 overlimits;
};

struct callback_head {
	struct callback_head *next;
	void (*func)(struct callback_head *);
};

struct lock_class_key {};

struct Qdisc_ops;

struct qdisc_size_table;

struct netdev_queue;

struct net_rate_estimator;

struct Qdisc {
	int (*enqueue)(struct sk_buff *, struct Qdisc *, struct sk_buff **);
	struct sk_buff * (*dequeue)(struct Qdisc *);
	unsigned int flags;
	u32 limit;
	const struct Qdisc_ops *ops;
	struct qdisc_size_table *stab;
	struct hlist_node hash;
	u32 handle;
	u32 parent;
	struct netdev_queue *dev_queue;
	struct net_rate_estimator *rate_est;
	struct gnet_stats_basic_sync *cpu_bstats;
	struct gnet_stats_queue *cpu_qstats;
	int pad;
	refcount_t refcnt;
	long: 64;
	long: 64;
	long: 64;
	struct sk_buff_head gso_skb;
	struct qdisc_skb_head q;
	struct gnet_stats_basic_sync bstats;
	struct gnet_stats_queue qstats;
	int owner;
	long unsigned int state;
	long unsigned int state2;
	struct Qdisc *next_sched;
	struct sk_buff_head skb_bad_txq;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	spinlock_t busylock;
	spinlock_t seqlock;
	struct callback_head rcu;
	netdevice_tracker dev_tracker;
	struct lock_class_key root_lock_key;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long int privdata[0];
};

struct Qdisc_class_common {
	u32 classid;
	unsigned int filter_cnt;
	struct hlist_node hnode;
};

struct hlist_head;

struct Qdisc_class_hash {
	struct hlist_head *hash;
	unsigned int hashsize;
	unsigned int hashmask;
	unsigned int hashelems;
};

struct tcmsg;

struct netlink_ext_ack;

struct nlattr;

struct qdisc_walker;

struct tcf_block;

struct gnet_dump;

struct Qdisc_class_ops {
	unsigned int flags;
	struct netdev_queue * (*select_queue)(struct Qdisc *, struct tcmsg *);
	int (*graft)(struct Qdisc *, long unsigned int, struct Qdisc *, struct Qdisc **, struct netlink_ext_ack *);
	struct Qdisc * (*leaf)(struct Qdisc *, long unsigned int);
	void (*qlen_notify)(struct Qdisc *, long unsigned int);
	long unsigned int (*find)(struct Qdisc *, u32);
	int (*change)(struct Qdisc *, u32, u32, struct nlattr **, long unsigned int *, struct netlink_ext_ack *);
	int (*delete)(struct Qdisc *, long unsigned int, struct netlink_ext_ack *);
	void (*walk)(struct Qdisc *, struct qdisc_walker *);
	struct tcf_block * (*tcf_block)(struct Qdisc *, long unsigned int, struct netlink_ext_ack *);
	long unsigned int (*bind_tcf)(struct Qdisc *, long unsigned int, u32);
	void (*unbind_tcf)(struct Qdisc *, long unsigned int);
	int (*dump)(struct Qdisc *, long unsigned int, struct sk_buff *, struct tcmsg *);
	int (*dump_stats)(struct Qdisc *, long unsigned int, struct gnet_dump *);
};

struct module;

struct Qdisc_ops {
	struct Qdisc_ops *next;
	const struct Qdisc_class_ops *cl_ops;
	char id[16];
	int priv_size;
	unsigned int static_flags;
	int (*enqueue)(struct sk_buff *, struct Qdisc *, struct sk_buff **);
	struct sk_buff * (*dequeue)(struct Qdisc *);
	struct sk_buff * (*peek)(struct Qdisc *);
	int (*init)(struct Qdisc *, struct nlattr *, struct netlink_ext_ack *);
	void (*reset)(struct Qdisc *);
	void (*destroy)(struct Qdisc *);
	int (*change)(struct Qdisc *, struct nlattr *, struct netlink_ext_ack *);
	void (*attach)(struct Qdisc *);
	int (*change_tx_queue_len)(struct Qdisc *, unsigned int);
	void (*change_real_num_tx)(struct Qdisc *, unsigned int);
	int (*dump)(struct Qdisc *, struct sk_buff *);
	int (*dump_stats)(struct Qdisc *, struct gnet_dump *);
	void (*ingress_block_set)(struct Qdisc *, u32);
	void (*egress_block_set)(struct Qdisc *, u32);
	u32 (*ingress_block_get)(struct Qdisc *);
	u32 (*egress_block_get)(struct Qdisc *);
	struct module *owner;
};

struct RR_CL_s {
	__u8 location[8];
};

struct RR_NM_s {
	__u8 flags;
	char name[0];
};

struct RR_PL_s {
	__u8 location[8];
};

struct RR_PN_s {
	__u8 dev_high[8];
	__u8 dev_low[8];
};

struct RR_PX_s {
	__u8 mode[8];
	__u8 n_links[8];
	__u8 uid[8];
	__u8 gid[8];
};

struct RR_RR_s {
	__u8 flags[1];
};

struct SL_component {
	__u8 flags;
	__u8 len;
	__u8 text[0];
};

struct RR_SL_s {
	__u8 flags;
	struct SL_component link;
};

struct stamp {
	__u8 time[7];
};

struct RR_TF_s {
	__u8 flags;
	struct stamp times[0];
};

struct RR_ZF_s {
	__u8 algorithm[2];
	__u8 parms[2];
	__u8 real_size[8];
};

struct RxDesc {
	__le32 opts1;
	__le32 opts2;
	__le64 addr;
};

struct SU_CE_s {
	__u8 extent[8];
	__u8 offset[8];
	__u8 size[8];
};

struct SU_ER_s {
	__u8 len_id;
	__u8 len_des;
	__u8 len_src;
	__u8 ext_ver;
	__u8 data[0];
};

struct SU_SP_s {
	__u8 magic[2];
	__u8 skip;
};

struct kref {
	refcount_t refcount;
};

struct swait_queue_head {
	raw_spinlock_t lock;
	struct list_head task_list;
};

struct completion {
	unsigned int done;
	struct swait_queue_head wait;
};

struct blk_mq_queue_map {
	unsigned int *mq_map;
	unsigned int nr_queues;
	unsigned int queue_offset;
};

struct blk_mq_ops;

struct blk_mq_tags;

struct blk_mq_tag_set {
	const struct blk_mq_ops *ops;
	struct blk_mq_queue_map map[3];
	unsigned int nr_maps;
	unsigned int nr_hw_queues;
	unsigned int queue_depth;
	unsigned int reserved_tags;
	unsigned int cmd_size;
	int numa_node;
	unsigned int timeout;
	unsigned int flags;
	void *driver_data;
	struct blk_mq_tags **tags;
	struct blk_mq_tags *shared_tags;
	struct mutex tag_list_lock;
	struct list_head tag_list;
	struct srcu_struct *srcu;
};

struct kset;

struct kobj_type;

struct kernfs_node;

struct kobject {
	const char *name;
	struct list_head entry;
	struct kobject *parent;
	struct kset *kset;
	const struct kobj_type *ktype;
	struct kernfs_node *sd;
	struct kref kref;
	unsigned int state_initialized: 1;
	unsigned int state_in_sysfs: 1;
	unsigned int state_add_uevent_sent: 1;
	unsigned int state_remove_uevent_sent: 1;
	unsigned int uevent_suppress: 1;
};

struct dev_links_info {
	struct list_head suppliers;
	struct list_head consumers;
	struct list_head defer_sync;
	enum dl_dev_state status;
};

struct pm_message {
	int event;
};

typedef struct pm_message pm_message_t;

struct rb_node {
	long unsigned int __rb_parent_color;
	struct rb_node *rb_right;
	struct rb_node *rb_left;
};

struct timerqueue_node {
	struct rb_node node;
	ktime_t expires;
};

struct hrtimer_clock_base;

struct hrtimer {
	struct timerqueue_node node;
	ktime_t _softexpires;
	enum hrtimer_restart (*function)(struct hrtimer *);
	struct hrtimer_clock_base *base;
	u8 state;
	u8 is_rel;
	u8 is_soft;
	u8 is_hard;
};

struct work_struct;

typedef void (*work_func_t)(struct work_struct *);

struct work_struct {
	atomic_long_t data;
	struct list_head entry;
	work_func_t func;
};

struct wakeup_source;

struct wake_irq;

struct pm_subsys_data;

struct device;

struct dev_pm_qos;

struct dev_pm_info {
	pm_message_t power_state;
	bool can_wakeup: 1;
	bool async_suspend: 1;
	bool in_dpm_list: 1;
	bool is_prepared: 1;
	bool is_suspended: 1;
	bool is_noirq_suspended: 1;
	bool is_late_suspended: 1;
	bool no_pm: 1;
	bool early_init: 1;
	bool direct_complete: 1;
	u32 driver_flags;
	spinlock_t lock;
	struct list_head entry;
	struct completion completion;
	struct wakeup_source *wakeup;
	bool wakeup_path: 1;
	bool syscore: 1;
	bool no_pm_callbacks: 1;
	bool async_in_progress: 1;
	bool must_resume: 1;
	bool set_active: 1;
	bool may_skip_resume: 1;
	struct hrtimer suspend_timer;
	u64 timer_expires;
	struct work_struct work;
	wait_queue_head_t wait_queue;
	struct wake_irq *wakeirq;
	atomic_t usage_count;
	atomic_t child_count;
	unsigned int disable_depth: 3;
	bool idle_notification: 1;
	bool request_pending: 1;
	bool deferred_resume: 1;
	bool needs_force_resume: 1;
	bool runtime_auto: 1;
	bool ignore_children: 1;
	bool no_callbacks: 1;
	bool irq_safe: 1;
	bool use_autosuspend: 1;
	bool timer_autosuspends: 1;
	bool memalloc_noio: 1;
	unsigned int links_count;
	enum rpm_request request;
	enum rpm_status runtime_status;
	enum rpm_status last_status;
	int runtime_error;
	int autosuspend_delay;
	u64 last_busy;
	u64 active_time;
	u64 suspended_time;
	u64 accounting_timestamp;
	struct pm_subsys_data *subsys_data;
	void (*set_latency_tolerance)(struct device *, s32);
	struct dev_pm_qos *qos;
};

struct irq_domain;

struct msi_device_data;

struct dev_msi_info {
	struct irq_domain *domain;
	struct msi_device_data *data;
};

struct dev_archdata {};

struct device_private;

struct device_type;

struct bus_type;

struct device_driver;

struct dev_pm_domain;

struct bus_dma_region;

struct device_dma_parameters;

struct io_tlb_mem;

struct device_node;

struct fwnode_handle;

struct class;

struct attribute_group;

struct iommu_group;

struct dev_iommu;

struct device_physical_location;

struct device {
	struct kobject kobj;
	struct device *parent;
	struct device_private *p;
	const char *init_name;
	const struct device_type *type;
	const struct bus_type *bus;
	struct device_driver *driver;
	void *platform_data;
	void *driver_data;
	struct mutex mutex;
	struct dev_links_info links;
	struct dev_pm_info power;
	struct dev_pm_domain *pm_domain;
	struct dev_msi_info msi;
	u64 *dma_mask;
	u64 coherent_dma_mask;
	u64 bus_dma_limit;
	const struct bus_dma_region *dma_range_map;
	struct device_dma_parameters *dma_parms;
	struct list_head dma_pools;
	struct io_tlb_mem *dma_io_tlb_mem;
	struct dev_archdata archdata;
	struct device_node *of_node;
	struct fwnode_handle *fwnode;
	int numa_node;
	dev_t devt;
	u32 id;
	spinlock_t devres_lock;
	struct list_head devres_head;
	const struct class *class;
	const struct attribute_group **groups;
	void (*release)(struct device *);
	struct iommu_group *iommu_group;
	struct dev_iommu *iommu;
	struct device_physical_location *physical_location;
	enum device_removable removable;
	bool offline_disabled: 1;
	bool offline: 1;
	bool of_node_reused: 1;
	bool state_synced: 1;
	bool can_match: 1;
	bool dma_skip_sync: 1;
	bool dma_iommu: 1;
};

struct scsi_host_template;

struct scsi_transport_template;

struct workqueue_struct;

struct Scsi_Host {
	struct list_head __devices;
	struct list_head __targets;
	struct list_head starved_list;
	spinlock_t default_lock;
	spinlock_t *host_lock;
	struct mutex scan_mutex;
	struct list_head eh_abort_list;
	struct list_head eh_cmd_q;
	struct task_struct *ehandler;
	struct completion *eh_action;
	wait_queue_head_t host_wait;
	const struct scsi_host_template *hostt;
	struct scsi_transport_template *transportt;
	struct kref tagset_refcnt;
	struct completion tagset_freed;
	struct blk_mq_tag_set tag_set;
	atomic_t host_blocked;
	unsigned int host_failed;
	unsigned int host_eh_scheduled;
	unsigned int host_no;
	int eh_deadline;
	long unsigned int last_reset;
	unsigned int max_channel;
	unsigned int max_id;
	u64 max_lun;
	unsigned int unique_id;
	short unsigned int max_cmd_len;
	int this_id;
	int can_queue;
	short int cmd_per_lun;
	short unsigned int sg_tablesize;
	short unsigned int sg_prot_tablesize;
	unsigned int max_sectors;
	unsigned int opt_sectors;
	unsigned int max_segment_size;
	unsigned int dma_alignment;
	long unsigned int dma_boundary;
	long unsigned int virt_boundary_mask;
	unsigned int nr_hw_queues;
	unsigned int nr_maps;
	unsigned int active_mode: 2;
	unsigned int host_self_blocked: 1;
	unsigned int reverse_ordering: 1;
	unsigned int tmf_in_progress: 1;
	unsigned int async_scan: 1;
	unsigned int eh_noresume: 1;
	unsigned int no_write_same: 1;
	unsigned int host_tagset: 1;
	unsigned int queuecommand_may_block: 1;
	unsigned int short_inquiry: 1;
	unsigned int no_scsi2_lun_in_cdb: 1;
	unsigned int no_highmem: 1;
	struct workqueue_struct *work_q;
	struct workqueue_struct *tmf_work_q;
	unsigned int max_host_blocked;
	unsigned int prot_capabilities;
	unsigned char prot_guard_type;
	long unsigned int base;
	long unsigned int io_port;
	unsigned char n_io_port;
	unsigned char dma_channel;
	unsigned int irq;
	enum scsi_host_state shost_state;
	struct device shost_gendev;
	struct device shost_dev;
	void *shost_data;
	struct device *dma_dev;
	int rpm_autosuspend_delay;
	long unsigned int hostdata[0];
};

struct TxDesc {
	__le32 opts1;
	__le32 opts2;
	__le64 addr;
};

struct xxh64_state {
	uint64_t total_len;
	uint64_t v1;
	uint64_t v2;
	uint64_t v3;
	uint64_t v4;
	uint64_t mem64[4];
	uint32_t memsize;
};

struct ZSTD_outBuffer_s {
	void *dst;
	size_t size;
	size_t pos;
};

typedef struct ZSTD_outBuffer_s ZSTD_outBuffer;

struct ZSTD_DCtx_s {
	const ZSTD_seqSymbol *LLTptr;
	const ZSTD_seqSymbol *MLTptr;
	const ZSTD_seqSymbol *OFTptr;
	const HUF_DTable *HUFptr;
	ZSTD_entropyDTables_t entropy;
	U32 workspace[640];
	const void *previousDstEnd;
	const void *prefixStart;
	const void *virtualStart;
	const void *dictEnd;
	size_t expected;
	ZSTD_frameHeader fParams;
	U64 processedCSize;
	U64 decodedSize;
	blockType_e bType;
	ZSTD_dStage stage;
	U32 litEntropy;
	U32 fseEntropy;
	struct xxh64_state xxhState;
	size_t headerSize;
	ZSTD_format_e format;
	ZSTD_forceIgnoreChecksum_e forceIgnoreChecksum;
	U32 validateChecksum;
	const BYTE *litPtr;
	ZSTD_customMem customMem;
	size_t litSize;
	size_t rleSize;
	size_t staticSize;
	int bmi2;
	ZSTD_DDict *ddictLocal;
	const ZSTD_DDict *ddict;
	U32 dictID;
	int ddictIsCold;
	ZSTD_dictUses_e dictUses;
	ZSTD_DDictHashSet *ddictSet;
	ZSTD_refMultipleDDicts_e refMultipleDDicts;
	ZSTD_dStreamStage streamStage;
	char *inBuff;
	size_t inBuffSize;
	size_t inPos;
	size_t maxWindowSize;
	char *outBuff;
	size_t outBuffSize;
	size_t outStart;
	size_t outEnd;
	size_t lhSize;
	U32 hostageByte;
	int noForwardProgress;
	ZSTD_bufferMode_e outBufferMode;
	ZSTD_outBuffer expectedOutBuffer;
	BYTE *litBuffer;
	const BYTE *litBufferEnd;
	ZSTD_litLocation_e litBufferLocation;
	BYTE litExtraBuffer[65568];
	BYTE headerBuffer[18];
	size_t oversizedDuration;
};

typedef struct ZSTD_DCtx_s ZSTD_DCtx;

typedef ZSTD_DCtx ZSTD_DStream;

typedef ZSTD_DCtx zstd_dctx;

typedef ZSTD_DStream zstd_dstream;

struct ZSTD_DDict_s {
	void *dictBuffer;
	const void *dictContent;
	size_t dictSize;
	ZSTD_entropyDTables_t entropy;
	U32 dictID;
	U32 entropyPresent;
	ZSTD_customMem cMem;
};

typedef ZSTD_DDict zstd_ddict;

struct ZSTD_inBuffer_s {
	const void *src;
	size_t size;
	size_t pos;
};

typedef struct ZSTD_inBuffer_s ZSTD_inBuffer;

typedef ZSTD_inBuffer zstd_in_buffer;

typedef ZSTD_outBuffer zstd_out_buffer;

struct __aio_sigset {
	const sigset_t *sigmask;
	size_t sigsetsize;
};

struct __arch_relative_insn {
	u8 op;
	s32 raddr;
} __attribute__((packed));

struct llist_node {
	struct llist_node *next;
};

struct __call_single_node {
	struct llist_node llist;
	union {
		unsigned int u_flags;
		atomic_t a_flags;
	};
	u16 src;
	u16 dst;
};

typedef void (*smp_call_func_t)(void *);

struct __call_single_data {
	struct __call_single_node node;
	smp_call_func_t func;
	void *info;
};

typedef struct __call_single_data call_single_data_t;

struct cpumask;

struct __cmp_key {
	const struct cpumask *cpus;
	struct cpumask ***masks;
	int node;
	int cpu;
	int w;
};

struct __compat_aio_sigset {
	compat_uptr_t sigmask;
	compat_size_t sigsetsize;
};

struct drm_connector;

struct drm_connector_state;

struct __drm_connnectors_state {
	struct drm_connector *ptr;
	struct drm_connector_state *state;
	struct drm_connector_state *old_state;
	struct drm_connector_state *new_state;
	s32 *out_fence_ptr;
};

struct drm_crtc;

struct drm_crtc_state;

struct drm_crtc_commit;

struct __drm_crtcs_state {
	struct drm_crtc *ptr;
	struct drm_crtc_state *state;
	struct drm_crtc_state *old_state;
	struct drm_crtc_state *new_state;
	struct drm_crtc_commit *commit;
	s32 *out_fence_ptr;
	u64 last_vblank_count;
};

struct drm_plane;

struct drm_plane_state;

struct __drm_planes_state {
	struct drm_plane *ptr;
	struct drm_plane_state *state;
	struct drm_plane_state *old_state;
	struct drm_plane_state *new_state;
};

struct drm_private_obj;

struct drm_private_state;

struct __drm_private_objs_state {
	struct drm_private_obj *ptr;
	struct drm_private_state *state;
	struct drm_private_state *old_state;
	struct drm_private_state *new_state;
};

struct __ext_steer_reg {
	const char *name;
	i915_mcr_reg_t reg;
};

struct __fat_dirent {
	long int d_ino;
	__kernel_off_t d_off;
	short unsigned int d_reclen;
	char d_name[256];
};

struct genradix_root;

struct __genradix {
	struct genradix_root *root;
};

struct pmu;

struct cgroup;

struct __group_key {
	int cpu;
	struct pmu *pmu;
	struct cgroup *cgroup;
};

struct guc_mmio_reg_set {
	u32 address;
	u16 count;
	u16 reserved;
};

struct guc_ads {
	struct guc_mmio_reg_set reg_state_list[512];
	u32 reserved0;
	u32 scheduler_policies;
	u32 gt_system_info;
	u32 reserved1;
	u32 control_data;
	u32 golden_context_lrca[16];
	u32 eng_state_size[16];
	u32 private_data;
	u32 reserved2;
	u32 capture_instance[32];
	u32 capture_class[32];
	u32 capture_global[2];
	u32 wa_klv_addr_lo;
	u32 wa_klv_addr_hi;
	u32 wa_klv_size;
	u32 reserved[11];
};

struct guc_policies {
	u32 submission_queue_depth[16];
	u32 dpc_promote_time;
	u32 is_valid;
	u32 max_num_work_items;
	u32 global_flags;
	u32 reserved[4];
};

struct guc_gt_system_info {
	u8 mapping_table[512];
	u32 engine_enabled_masks[16];
	u32 generic_gt_sysinfo[16];
};

struct guc_engine_usage_record {
	u32 current_context_index;
	u32 last_switch_in_stamp;
	u32 reserved0;
	u32 total_runtime;
	u32 reserved1[4];
};

struct guc_engine_usage {
	struct guc_engine_usage_record engines[512];
};

struct guc_mmio_reg {
	u32 offset;
	u32 value;
	u32 flags;
	u32 mask;
};

struct __guc_ads_blob {
	struct guc_ads ads;
	struct guc_policies policies;
	struct guc_gt_system_info system_info;
	struct guc_engine_usage engine_usage;
	struct guc_mmio_reg regset[0];
};

struct __guc_capture_ads_cache {
	bool is_valid;
	void *ptr;
	size_t size;
	int status;
};

struct __guc_capture_bufstate {
	u32 size;
	void *data;
	u32 rd;
	u32 wr;
};

struct gcap_reg_list_info {
	u32 vfid;
	u32 num_regs;
	struct guc_mmio_reg *regs;
};

struct __guc_capture_parsed_output {
	struct list_head link;
	bool is_partial;
	u32 eng_class;
	u32 eng_inst;
	u32 guc_id;
	u32 lrca;
	struct gcap_reg_list_info reginfo[3];
};

struct __guc_mmio_reg_descr {
	i915_reg_t reg;
	u32 flags;
	u32 mask;
	const char *regname;
};

struct __guc_mmio_reg_descr_group {
	const struct __guc_mmio_reg_descr *list;
	u32 num_regs;
	u32 owner;
	u32 type;
	u32 engine;
	struct __guc_mmio_reg_descr *extlist;
};

struct intel_global_obj;

struct intel_global_state;

struct __intel_global_objs_state {
	struct intel_global_obj *ptr;
	struct intel_global_state *state;
	struct intel_global_state *old_state;
	struct intel_global_state *new_state;
};

struct __ip6_tnl_parm {
	char name[16];
	int link;
	__u8 proto;
	__u8 encap_limit;
	__u8 hop_limit;
	bool collect_md;
	__be32 flowinfo;
	__u32 flags;
	struct in6_addr laddr;
	struct in6_addr raddr;
	long unsigned int i_flags[1];
	long unsigned int o_flags[1];
	__be32 i_key;
	__be32 o_key;
	__u32 fwmark;
	__u32 index;
	__u8 erspan_ver;
	__u8 dir;
	__u16 hwid;
};

struct __kernel_timespec {
	__kernel_time64_t tv_sec;
	long long int tv_nsec;
};

struct __kernel_itimerspec {
	struct __kernel_timespec it_interval;
	struct __kernel_timespec it_value;
};

struct __kernel_old_timeval {
	__kernel_long_t tv_sec;
	__kernel_long_t tv_usec;
};

struct __kernel_old_itimerval {
	struct __kernel_old_timeval it_interval;
	struct __kernel_old_timeval it_value;
};

struct __kernel_old_timespec {
	__kernel_old_time_t tv_sec;
	long int tv_nsec;
};

struct __kernel_sock_timeval {
	__s64 tv_sec;
	__s64 tv_usec;
};

struct __kernel_sockaddr_storage {
	union {
		struct {
			__kernel_sa_family_t ss_family;
			char __data[126];
		};
		void *__align;
	};
};

struct __kernel_timex_timeval {
	__kernel_time64_t tv_sec;
	long long int tv_usec;
};

struct __kernel_timex {
	unsigned int modes;
	long long int offset;
	long long int freq;
	long long int maxerror;
	long long int esterror;
	int status;
	long long int constant;
	long long int precision;
	long long int tolerance;
	struct __kernel_timex_timeval time;
	long long int tick;
	long long int ppsfreq;
	long long int jitter;
	int shift;
	long long int stabil;
	long long int jitcnt;
	long long int calcnt;
	long long int errcnt;
	long long int stbcnt;
	int tai;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct __kfifo {
	unsigned int in;
	unsigned int out;
	unsigned int mask;
	unsigned int esize;
	void *data;
};

struct __large_struct {
	long unsigned int buf[100];
};

struct __old_kernel_stat {
	short unsigned int st_dev;
	short unsigned int st_ino;
	short unsigned int st_mode;
	short unsigned int st_nlink;
	short unsigned int st_uid;
	short unsigned int st_gid;
	short unsigned int st_rdev;
	unsigned int st_size;
	unsigned int st_atime;
	unsigned int st_mtime;
	unsigned int st_ctime;
};

union sigval {
	int sival_int;
	void *sival_ptr;
};

typedef union sigval sigval_t;

union __sifields {
	struct {
		__kernel_pid_t _pid;
		__kernel_uid32_t _uid;
	} _kill;
	struct {
		__kernel_timer_t _tid;
		int _overrun;
		sigval_t _sigval;
		int _sys_private;
	} _timer;
	struct {
		__kernel_pid_t _pid;
		__kernel_uid32_t _uid;
		sigval_t _sigval;
	} _rt;
	struct {
		__kernel_pid_t _pid;
		__kernel_uid32_t _uid;
		int _status;
		__kernel_clock_t _utime;
		__kernel_clock_t _stime;
	} _sigchld;
	struct {
		void *_addr;
		union {
			int _trapno;
			short int _addr_lsb;
			struct {
				char _dummy_bnd[8];
				void *_lower;
				void *_upper;
			} _addr_bnd;
			struct {
				char _dummy_pkey[8];
				__u32 _pkey;
			} _addr_pkey;
			struct {
				long unsigned int _data;
				__u32 _type;
				__u32 _flags;
			} _perf;
		};
	} _sigfault;
	struct {
		long int _band;
		int _fd;
	} _sigpoll;
	struct {
		void *_call_addr;
		int _syscall;
		unsigned int _arch;
	} _sigsys;
};

struct bpf_flow_keys;

struct bpf_sock;

struct __sk_buff {
	__u32 len;
	__u32 pkt_type;
	__u32 mark;
	__u32 queue_mapping;
	__u32 protocol;
	__u32 vlan_present;
	__u32 vlan_tci;
	__u32 vlan_proto;
	__u32 priority;
	__u32 ingress_ifindex;
	__u32 ifindex;
	__u32 tc_index;
	__u32 cb[5];
	__u32 hash;
	__u32 tc_classid;
	__u32 data;
	__u32 data_end;
	__u32 napi_id;
	__u32 family;
	__u32 remote_ip4;
	__u32 local_ip4;
	__u32 remote_ip6[4];
	__u32 local_ip6[4];
	__u32 remote_port;
	__u32 local_port;
	__u32 data_meta;
	union {
		struct bpf_flow_keys *flow_keys;
	};
	__u64 tstamp;
	__u32 wire_len;
	__u32 gso_segs;
	union {
		struct bpf_sock *sk;
	};
	__u32 gso_size;
	__u8 tstamp_type;
	__u64 hwtstamp;
};

struct __snd_pcm_mmap_control64_buggy {
	__pad_before_u32 __pad1;
	__u32 appl_ptr;
	__pad_before_u32 __pad2;
	__pad_before_u32 __pad3;
	__u32 avail_min;
	__pad_after_uframe __pad4;
};

struct snd_seq_real_time {
	unsigned int tv_sec;
	unsigned int tv_nsec;
};

union snd_seq_timestamp {
	snd_seq_tick_time_t tick;
	struct snd_seq_real_time time;
};

struct snd_seq_addr {
	unsigned char client;
	unsigned char port;
};

struct snd_seq_ev_note {
	unsigned char channel;
	unsigned char note;
	unsigned char velocity;
	unsigned char off_velocity;
	unsigned int duration;
};

struct snd_seq_ev_ctrl {
	unsigned char channel;
	unsigned char unused1;
	unsigned char unused2;
	unsigned char unused3;
	unsigned int param;
	int value;
};

struct snd_seq_ev_raw8 {
	unsigned char d[12];
};

struct snd_seq_ev_raw32 {
	unsigned int d[3];
};

struct snd_seq_ev_ext {
	unsigned int len;
	void *ptr;
} __attribute__((packed));

struct snd_seq_queue_skew {
	unsigned int value;
	unsigned int base;
};

struct snd_seq_ev_queue_control {
	unsigned char queue;
	unsigned char pad[3];
	union {
		int value;
		union snd_seq_timestamp time;
		unsigned int position;
		struct snd_seq_queue_skew skew;
		unsigned int d32[2];
		unsigned char d8[8];
	} param;
};

struct snd_seq_connect {
	struct snd_seq_addr sender;
	struct snd_seq_addr dest;
};

struct snd_seq_result {
	int event;
	int result;
};

struct snd_seq_event;

struct snd_seq_ev_quote {
	struct snd_seq_addr origin;
	short unsigned int value;
	struct snd_seq_event *event;
} __attribute__((packed));

struct snd_seq_ev_ump_notify {
	unsigned char client;
	unsigned char block;
};

union snd_seq_event_data {
	struct snd_seq_ev_note note;
	struct snd_seq_ev_ctrl control;
	struct snd_seq_ev_raw8 raw8;
	struct snd_seq_ev_raw32 raw32;
	struct snd_seq_ev_ext ext;
	struct snd_seq_ev_queue_control queue;
	union snd_seq_timestamp time;
	struct snd_seq_addr addr;
	struct snd_seq_connect connect;
	struct snd_seq_result result;
	struct snd_seq_ev_quote quote;
	struct snd_seq_ev_ump_notify ump_notify;
};

struct snd_seq_event {
	snd_seq_event_type_t type;
	unsigned char flags;
	char tag;
	unsigned char queue;
	union snd_seq_timestamp time;
	struct snd_seq_addr source;
	struct snd_seq_addr dest;
	union snd_seq_event_data data;
};

union __snd_seq_event {
	struct snd_seq_event legacy;
	struct {
		struct snd_seq_event event;
	} raw;
};

struct __track_dentry_update_args {
	struct dentry *dentry;
	int op;
};

struct __track_range_args {
	ext4_lblk_t start;
	ext4_lblk_t end;
};

union __u128_halves {
	u128 full;
	struct {
		u64 low;
		u64 high;
	};
};

struct __una_u32 {
	u32 x;
};

struct inode;

struct __uprobe_key {
	struct inode *inode;
	loff_t offset;
};

struct __user_cap_data_struct {
	__u32 effective;
	__u32 permitted;
	__u32 inheritable;
};

typedef struct __user_cap_data_struct *cap_user_data_t;

struct __user_cap_header_struct {
	__u32 version;
	int pid;
};

typedef struct __user_cap_header_struct *cap_user_header_t;

struct __va_list_tag {
	unsigned int gp_offset;
	unsigned int fp_offset;
	void *overflow_arg_area;
	void *reg_save_area;
};

typedef __builtin_va_list va_list;

struct drm_mm;

struct drm_mm_node {
	long unsigned int color;
	u64 start;
	u64 size;
	struct drm_mm *mm;
	struct list_head node_list;
	struct list_head hole_stack;
	struct rb_node rb;
	struct rb_node rb_hole_size;
	struct rb_node rb_hole_addr;
	u64 __subtree_last;
	u64 hole_size;
	u64 subtree_max_hole;
	long unsigned int flags;
};

struct _balloon_info_ {
	struct drm_mm_node space[4];
};

struct net_device;

struct _bpf_dtab_netdev {
	struct net_device *dev;
};

struct _cache_table {
	unsigned char descriptor;
	char cache_type;
	short int size;
};

union _cpuid4_leaf_eax {
	struct {
		enum _cache_type type: 5;
		unsigned int level: 3;
		unsigned int is_self_initializing: 1;
		unsigned int is_fully_associative: 1;
		unsigned int reserved: 4;
		unsigned int num_threads_sharing: 12;
		unsigned int num_cores_on_die: 6;
	} split;
	u32 full;
};

union _cpuid4_leaf_ebx {
	struct {
		unsigned int coherency_line_size: 12;
		unsigned int physical_line_partition: 10;
		unsigned int ways_of_associativity: 10;
	} split;
	u32 full;
};

union _cpuid4_leaf_ecx {
	struct {
		unsigned int number_of_sets: 32;
	} split;
	u32 full;
};

struct amd_northbridge;

struct _cpuid4_info_regs {
	union _cpuid4_leaf_eax eax;
	union _cpuid4_leaf_ebx ebx;
	union _cpuid4_leaf_ecx ecx;
	unsigned int id;
	long unsigned int size;
	struct amd_northbridge *nb;
};

struct jump_entry;

struct static_key_mod;

struct static_key {
	atomic_t enabled;
	union {
		long unsigned int type;
		struct jump_entry *entries;
		struct static_key_mod *next;
	};
};

struct static_key_true {
	struct static_key key;
};

struct static_key_false {
	struct static_key key;
};

struct _ddebug {
	const char *modname;
	const char *function;
	const char *filename;
	const char *format;
	unsigned int lineno: 18;
	unsigned int class_id: 6;
	unsigned int flags: 8;
	union {
		struct static_key_true dd_key_true;
		struct static_key_false dd_key_false;
	} key;
};

struct _flow_keys_digest_data {
	__be16 n_proto;
	u8 ip_proto;
	u8 padding;
	__be32 ports;
	__be32 src;
	__be32 dst;
};

struct _fpreg {
	__u16 significand[4];
	__u16 exponent;
};

struct _fpxreg {
	__u16 significand[4];
	__u16 exponent;
	__u16 padding[3];
};

struct _xmmreg {
	__u32 element[4];
};

struct _fpx_sw_bytes {
	__u32 magic1;
	__u32 extended_size;
	__u64 xfeatures;
	__u32 xstate_size;
	__u32 padding[7];
};

struct _fpstate_32 {
	__u32 cw;
	__u32 sw;
	__u32 tag;
	__u32 ipoff;
	__u32 cssel;
	__u32 dataoff;
	__u32 datasel;
	struct _fpreg _st[8];
	__u16 status;
	__u16 magic;
	__u32 _fxsr_env[6];
	__u32 mxcsr;
	__u32 reserved;
	struct _fpxreg _fxsr_st[8];
	struct _xmmreg _xmm[8];
	union {
		__u32 padding1[44];
		__u32 padding[44];
	};
	union {
		__u32 padding2[12];
		struct _fpx_sw_bytes sw_reserved;
	};
};

struct _gpt_entry_attributes {
	u64 required_to_function: 1;
	u64 reserved: 47;
	u64 type_guid_specific: 16;
};

typedef struct _gpt_entry_attributes gpt_entry_attributes;

struct _gpt_entry {
	efi_guid_t partition_type_guid;
	efi_guid_t unique_partition_guid;
	__le64 starting_lba;
	__le64 ending_lba;
	gpt_entry_attributes attributes;
	__le16 partition_name[36];
};

typedef struct _gpt_entry gpt_entry;

struct _gpt_header {
	__le64 signature;
	__le32 revision;
	__le32 header_size;
	__le32 header_crc32;
	__le32 reserved1;
	__le64 my_lba;
	__le64 alternate_lba;
	__le64 first_usable_lba;
	__le64 last_usable_lba;
	efi_guid_t disk_guid;
	__le64 partition_entry_lba;
	__le32 num_partition_entries;
	__le32 sizeof_partition_entry;
	__le32 partition_entry_array_crc32;
} __attribute__((packed));

typedef struct _gpt_header gpt_header;

struct _gpt_mbr_record {
	u8 boot_indicator;
	u8 start_head;
	u8 start_sector;
	u8 start_track;
	u8 os_type;
	u8 end_head;
	u8 end_sector;
	u8 end_track;
	__le32 starting_lba;
	__le32 size_in_lba;
};

typedef struct _gpt_mbr_record gpt_mbr_record;

struct resource {
	resource_size_t start;
	resource_size_t end;
	const char *name;
	long unsigned int flags;
	long unsigned int desc;
	struct resource *parent;
	struct resource *sibling;
	struct resource *child;
};

struct intel_gtt_driver;

struct pci_dev;

struct page;

struct _intel_private {
	const struct intel_gtt_driver *driver;
	struct pci_dev *pcidev;
	struct pci_dev *bridge_dev;
	u8 *registers;
	phys_addr_t gtt_phys_addr;
	u32 PGETBL_save;
	u32 *gtt;
	bool clear_fake_agp;
	int num_dcache_entries;
	void *i9xx_flush_page;
	char *i81x_gtt_table;
	struct resource ifp_resource;
	int resource_valid;
	struct page *scratch_page;
	phys_addr_t scratch_page_dma;
	int refcount;
	unsigned int needs_dmar: 1;
	phys_addr_t gma_bus_addr;
	resource_size_t stolen_size;
	unsigned int gtt_total_entries;
	unsigned int gtt_mappable_entries;
};

struct kvm_stats_desc {
	__u32 flags;
	__s16 exponent;
	__u16 size;
	__u32 offset;
	__u32 bucket_size;
	char name[0];
};

struct _kvm_stats_desc {
	struct kvm_stats_desc desc;
	char name[48];
};

struct _legacy_mbr {
	u8 boot_code[440];
	__le32 unique_mbr_signature;
	__le16 unknown;
	gpt_mbr_record partition_record[4];
	__le16 signature;
} __attribute__((packed));

typedef struct _legacy_mbr legacy_mbr;

struct strp_msg {
	int full_len;
	int offset;
};

struct _strp_msg {
	struct strp_msg strp;
	int accum_len;
};

struct timer_list {
	struct hlist_node entry;
	long unsigned int expires;
	void (*function)(struct timer_list *);
	u32 flags;
};

struct delayed_work {
	struct work_struct work;
	struct timer_list timer;
	struct workqueue_struct *wq;
	int cpu;
};

struct _thermal_state {
	u64 next_check;
	u64 last_interrupt_time;
	struct delayed_work therm_work;
	long unsigned int count;
	long unsigned int last_count;
	long unsigned int max_time_ms;
	long unsigned int total_time_ms;
	bool rate_control_active;
	bool new_event;
	u8 level;
	u8 sample_index;
	u8 sample_count;
	u8 average;
	u8 baseline_temp;
	u8 temp_samples[3];
};

struct _tlb_table {
	unsigned char descriptor;
	char tlb_type;
	unsigned int entries;
	char info[128];
};

struct a4tech_sc {
	long unsigned int quirks;
	unsigned int hw_wheel;
	__s32 delayed_value;
};

struct seq_net_private {
	struct net *net;
	netns_tracker ns_tracker;
};

struct ac6_iter_state {
	struct seq_net_private p;
	struct net_device *dev;
};

struct access_coordinate {
	unsigned int read_bandwidth;
	unsigned int write_bandwidth;
	unsigned int read_latency;
	unsigned int write_latency;
};

struct acct {
	char ac_flag;
	char ac_version;
	__u16 ac_uid16;
	__u16 ac_gid16;
	__u16 ac_tty;
	__u32 ac_btime;
	comp_t ac_utime;
	comp_t ac_stime;
	comp_t ac_etime;
	comp_t ac_mem;
	comp_t ac_io;
	comp_t ac_rw;
	comp_t ac_minflt;
	comp_t ac_majflt;
	comp_t ac_swaps;
	__u16 ac_ahz;
	__u32 ac_exitcode;
	char ac_comm[17];
	__u8 ac_etime_hi;
	__u16 ac_etime_lo;
	__u32 ac_uid;
	__u32 ac_gid;
};

typedef struct acct acct_t;

struct drm_dp_nak_reply {
	guid_t guid;
	u8 reason;
	u8 nak_data;
};

struct drm_dp_link_addr_reply_port {
	bool input_port;
	u8 peer_device_type;
	u8 port_number;
	bool mcs;
	bool ddps;
	bool legacy_device_plug_status;
	u8 dpcd_revision;
	guid_t peer_guid;
	u8 num_sdp_streams;
	u8 num_sdp_stream_sinks;
};

struct drm_dp_link_address_ack_reply {
	guid_t guid;
	u8 nports;
	struct drm_dp_link_addr_reply_port ports[16];
};

struct drm_dp_port_number_rep {
	u8 port_number;
};

struct drm_dp_enum_path_resources_ack_reply {
	u8 port_number;
	bool fec_capable;
	u16 full_payload_bw_number;
	u16 avail_payload_bw_number;
};

struct drm_dp_allocate_payload_ack_reply {
	u8 port_number;
	u8 vcpi;
	u16 allocated_pbn;
};

struct drm_dp_query_payload_ack_reply {
	u8 port_number;
	u16 allocated_pbn;
};

struct drm_dp_remote_dpcd_read_ack_reply {
	u8 port_number;
	u8 num_bytes;
	u8 bytes[255];
};

struct drm_dp_remote_dpcd_write_ack_reply {
	u8 port_number;
};

struct drm_dp_remote_dpcd_write_nak_reply {
	u8 port_number;
	u8 reason;
	u8 bytes_written_before_failure;
};

struct drm_dp_remote_i2c_read_ack_reply {
	u8 port_number;
	u8 num_bytes;
	u8 bytes[255];
};

struct drm_dp_remote_i2c_read_nak_reply {
	u8 port_number;
	u8 nak_reason;
	u8 i2c_nak_transaction;
};

struct drm_dp_remote_i2c_write_ack_reply {
	u8 port_number;
};

struct drm_dp_query_stream_enc_status_ack_reply {
	u8 stream_id;
	bool reply_signed;
	bool unauthorizable_device_present;
	bool legacy_device_present;
	bool query_capable_device_present;
	bool hdcp_1x_device_present;
	bool hdcp_2x_device_present;
	bool auth_completed;
	bool encryption_enabled;
	bool repeater_present;
	u8 state;
};

union ack_replies {
	struct drm_dp_nak_reply nak;
	struct drm_dp_link_address_ack_reply link_addr;
	struct drm_dp_port_number_rep port_number;
	struct drm_dp_enum_path_resources_ack_reply path_resources;
	struct drm_dp_allocate_payload_ack_reply allocate_payload;
	struct drm_dp_query_payload_ack_reply query_payload;
	struct drm_dp_remote_dpcd_read_ack_reply remote_dpcd_read_ack;
	struct drm_dp_remote_dpcd_write_ack_reply remote_dpcd_write_ack;
	struct drm_dp_remote_dpcd_write_nak_reply remote_dpcd_write_nack;
	struct drm_dp_remote_i2c_read_ack_reply remote_i2c_read_ack;
	struct drm_dp_remote_i2c_read_nak_reply remote_i2c_read_nack;
	struct drm_dp_remote_i2c_write_ack_reply remote_i2c_write_ack;
	struct drm_dp_query_stream_enc_status_ack_reply enc_status;
};

struct drm_dp_connection_status_notify {
	guid_t guid;
	u8 port_number;
	bool legacy_device_plug_status;
	bool displayport_device_plug_status;
	bool message_capability_status;
	bool input_port;
	u8 peer_device_type;
};

struct drm_dp_port_number_req {
	u8 port_number;
};

struct drm_dp_resource_status_notify {
	u8 port_number;
	guid_t guid;
	u16 available_pbn;
};

struct drm_dp_query_payload {
	u8 port_number;
	u8 vcpi;
};

struct drm_dp_allocate_payload {
	u8 port_number;
	u8 number_sdp_streams;
	u8 vcpi;
	u16 pbn;
	u8 sdp_stream_sink[16];
};

struct drm_dp_remote_dpcd_read {
	u8 port_number;
	u32 dpcd_address;
	u8 num_bytes;
};

struct drm_dp_remote_dpcd_write {
	u8 port_number;
	u32 dpcd_address;
	u8 num_bytes;
	u8 *bytes;
};

struct drm_dp_remote_i2c_read_tx {
	u8 i2c_dev_id;
	u8 num_bytes;
	u8 *bytes;
	u8 no_stop_bit;
	u8 i2c_transaction_delay;
};

struct drm_dp_remote_i2c_read {
	u8 num_transactions;
	u8 port_number;
	struct drm_dp_remote_i2c_read_tx transactions[4];
	u8 read_i2c_device_id;
	u8 num_bytes_read;
};

struct drm_dp_remote_i2c_write {
	u8 port_number;
	u8 write_i2c_device_id;
	u8 num_bytes;
	u8 *bytes;
};

struct drm_dp_query_stream_enc_status {
	u8 stream_id;
	u8 client_id[7];
	u8 stream_event;
	bool valid_stream_event;
	u8 stream_behavior;
	u8 valid_stream_behavior;
};

union ack_req {
	struct drm_dp_connection_status_notify conn_stat;
	struct drm_dp_port_number_req port_num;
	struct drm_dp_resource_status_notify resource_stat;
	struct drm_dp_query_payload query_payload;
	struct drm_dp_allocate_payload allocate_payload;
	struct drm_dp_remote_dpcd_read dpcd_read;
	struct drm_dp_remote_dpcd_write dpcd_write;
	struct drm_dp_remote_i2c_read i2c_read;
	struct drm_dp_remote_i2c_write i2c_write;
	struct drm_dp_query_stream_enc_status enc_status;
};

struct ack_sample {
	u32 pkts_acked;
	s32 rtt_us;
	u32 in_flight;
};

struct crypto_tfm;

struct cipher_alg {
	unsigned int cia_min_keysize;
	unsigned int cia_max_keysize;
	int (*cia_setkey)(struct crypto_tfm *, const u8 *, unsigned int);
	void (*cia_encrypt)(struct crypto_tfm *, u8 *, const u8 *);
	void (*cia_decrypt)(struct crypto_tfm *, u8 *, const u8 *);
};

struct compress_alg {
	int (*coa_compress)(struct crypto_tfm *, const u8 *, unsigned int, u8 *, unsigned int *);
	int (*coa_decompress)(struct crypto_tfm *, const u8 *, unsigned int, u8 *, unsigned int *);
};

struct crypto_type;

struct crypto_alg {
	struct list_head cra_list;
	struct list_head cra_users;
	u32 cra_flags;
	unsigned int cra_blocksize;
	unsigned int cra_ctxsize;
	unsigned int cra_alignmask;
	int cra_priority;
	refcount_t cra_refcnt;
	char cra_name[128];
	char cra_driver_name[128];
	const struct crypto_type *cra_type;
	union {
		struct cipher_alg cipher;
		struct compress_alg compress;
	} cra_u;
	int (*cra_init)(struct crypto_tfm *);
	void (*cra_exit)(struct crypto_tfm *);
	void (*cra_destroy)(struct crypto_alg *);
	struct module *cra_module;
};

struct comp_alg_common {
	struct crypto_alg base;
};

struct acomp_req;

struct scatterlist;

struct crypto_acomp;

struct acomp_alg {
	int (*compress)(struct acomp_req *);
	int (*decompress)(struct acomp_req *);
	void (*dst_free)(struct scatterlist *);
	int (*init)(struct crypto_acomp *);
	void (*exit)(struct crypto_acomp *);
	unsigned int reqsize;
	union {
		struct {
			struct crypto_alg base;
		};
		struct comp_alg_common calg;
	};
};

typedef void (*crypto_completion_t)(void *, int);

struct crypto_async_request {
	struct list_head list;
	crypto_completion_t complete;
	void *data;
	struct crypto_tfm *tfm;
	u32 flags;
};

struct acomp_req {
	struct crypto_async_request base;
	struct scatterlist *src;
	struct scatterlist *dst;
	unsigned int slen;
	unsigned int dlen;
	u32 flags;
	void *__ctx[0];
};

struct power_supply;

union power_supply_propval;

struct power_supply_desc {
	const char *name;
	enum power_supply_type type;
	u8 charge_behaviours;
	u32 charge_types;
	u32 usb_types;
	const enum power_supply_property *properties;
	size_t num_properties;
	int (*get_property)(struct power_supply *, enum power_supply_property, union power_supply_propval *);
	int (*set_property)(struct power_supply *, enum power_supply_property, const union power_supply_propval *);
	int (*property_is_writeable)(struct power_supply *, enum power_supply_property);
	void (*external_power_changed)(struct power_supply *);
	void (*set_charged)(struct power_supply *);
	bool no_thermal;
	int use_for_apm;
};

struct notifier_block;

typedef int (*notifier_fn_t)(struct notifier_block *, long unsigned int, void *);

struct notifier_block {
	notifier_fn_t notifier_call;
	struct notifier_block *next;
	int priority;
};

struct acpi_device;

struct acpi_ac {
	struct power_supply *charger;
	struct power_supply_desc charger_desc;
	struct acpi_device *device;
	long long unsigned int state;
	struct notifier_block battery_nb;
};

struct acpi_address16_attribute {
	u16 granularity;
	u16 minimum;
	u16 maximum;
	u16 translation_offset;
	u16 address_length;
};

struct acpi_address32_attribute {
	u32 granularity;
	u32 minimum;
	u32 maximum;
	u32 translation_offset;
	u32 address_length;
};

struct acpi_address64_attribute {
	u64 granularity;
	u64 minimum;
	u64 maximum;
	u64 translation_offset;
	u64 address_length;
};

struct acpi_namespace_node;

struct acpi_address_range {
	struct acpi_address_range *next;
	struct acpi_namespace_node *region_node;
	acpi_physical_address start_address;
	acpi_physical_address end_address;
};

struct acpi_battery {
	struct mutex lock;
	struct mutex sysfs_lock;
	struct power_supply *bat;
	struct power_supply_desc bat_desc;
	struct acpi_device *device;
	struct notifier_block pm_nb;
	struct list_head list;
	long unsigned int update_time;
	int revision;
	int rate_now;
	int capacity_now;
	int voltage_now;
	int design_capacity;
	int full_charge_capacity;
	int technology;
	int design_voltage;
	int design_capacity_warning;
	int design_capacity_low;
	int cycle_count;
	int measurement_accuracy;
	int max_sampling_time;
	int min_sampling_time;
	int max_averaging_interval;
	int min_averaging_interval;
	int capacity_granularity_1;
	int capacity_granularity_2;
	int alarm;
	char model_number[64];
	char serial_number[64];
	char type[64];
	char oem_info[64];
	int state;
	int power_unit;
	long unsigned int flags;
};

struct acpi_battery_hook {
	const char *name;
	int (*add_battery)(struct power_supply *, struct acpi_battery_hook *);
	int (*remove_battery)(struct power_supply *, struct acpi_battery_hook *);
	struct list_head list;
};

struct acpi_bit_register_info {
	u8 parent_register;
	u8 bit_position;
	u16 access_bit_mask;
};

struct acpi_buffer {
	acpi_size length;
	void *pointer;
};

struct acpi_bus_event {
	struct list_head node;
	acpi_device_class device_class;
	acpi_bus_id bus_id;
	u32 type;
	u32 data;
};

struct acpi_bus_type {
	struct list_head list;
	const char *name;
	bool (*match)(struct device *);
	struct acpi_device * (*find_companion)(struct device *);
	void (*setup)(struct device *);
};

struct input_dev;

struct acpi_button {
	unsigned int type;
	struct input_dev *input;
	char phys[32];
	long unsigned int pushed;
	int last_state;
	ktime_t last_time;
	bool suspended;
	bool lid_state_initialized;
};

struct acpi_cdat_header {
	u8 type;
	u8 reserved;
	u16 length;
};

struct acpi_cedt_header {
	u8 type;
	u8 reserved;
	u16 length;
};

struct acpi_cedt_cfmws {
	struct acpi_cedt_header header;
	u32 reserved1;
	u64 base_hpa;
	u64 window_size;
	u8 interleave_ways;
	u8 interleave_arithmetic;
	u16 reserved2;
	u32 granularity;
	u16 restrictions;
	u16 qtg_id;
	u32 interleave_targets[0];
} __attribute__((packed));

struct acpi_comment_node {
	char *comment;
	struct acpi_comment_node *next;
};

struct acpi_common_descriptor {
	void *common_pointer;
	u8 descriptor_type;
};

struct acpi_common_state {
	void *next;
	u8 descriptor_type;
	u8 flags;
	u16 value;
	u16 state;
};

struct acpi_connection_info {
	u8 *connection;
	u16 length;
	u8 access_length;
};

union acpi_parse_object;

struct acpi_control_state {
	void *next;
	u8 descriptor_type;
	u8 flags;
	u16 value;
	u16 state;
	u16 opcode;
	union acpi_parse_object *predicate_op;
	u8 *aml_predicate_start;
	u8 *package_end;
	u64 loop_timeout;
};

struct cpumask {
	long unsigned int bits[1];
};

typedef struct cpumask cpumask_var_t[1];

struct acpi_pct_register;

struct acpi_cpufreq_data {
	unsigned int resume;
	unsigned int cpu_feature;
	unsigned int acpi_perf_cpu;
	cpumask_var_t freqdomain_cpus;
	void (*cpu_freq_write)(struct acpi_pct_register *, u32);
	u32 (*cpu_freq_read)(struct acpi_pct_register *);
};

struct acpi_create_field_info {
	struct acpi_namespace_node *region_node;
	struct acpi_namespace_node *field_node;
	struct acpi_namespace_node *register_node;
	struct acpi_namespace_node *data_register_node;
	struct acpi_namespace_node *connection_node;
	u8 *resource_buffer;
	u32 bank_value;
	u32 field_bit_position;
	u32 field_bit_length;
	u16 resource_length;
	u16 pin_number_index;
	u8 field_flags;
	u8 attribute;
	u8 field_type;
	u8 access_length;
};

struct acpi_csrt_group {
	u32 length;
	u32 vendor_id;
	u32 subvendor_id;
	u16 device_id;
	u16 subdevice_id;
	u16 revision;
	u16 reserved;
	u32 shared_info_length;
};

struct acpi_csrt_shared_info {
	u16 major_version;
	u16 minor_version;
	u32 mmio_base_low;
	u32 mmio_base_high;
	u32 gsi_interrupt;
	u8 interrupt_polarity;
	u8 interrupt_mode;
	u8 num_channels;
	u8 dma_address_width;
	u16 base_request_line;
	u16 num_handshake_signals;
	u32 max_block_size;
};

struct attribute {
	const char *name;
	umode_t mode;
};

struct address_space;

struct vm_area_struct;

struct bin_attribute {
	struct attribute attr;
	size_t size;
	void *private;
	struct address_space * (*f_mapping)(void);
	ssize_t (*read)(struct file *, struct kobject *, struct bin_attribute *, char *, loff_t, size_t);
	ssize_t (*read_new)(struct file *, struct kobject *, const struct bin_attribute *, char *, loff_t, size_t);
	ssize_t (*write)(struct file *, struct kobject *, struct bin_attribute *, char *, loff_t, size_t);
	ssize_t (*write_new)(struct file *, struct kobject *, const struct bin_attribute *, char *, loff_t, size_t);
	loff_t (*llseek)(struct file *, struct kobject *, const struct bin_attribute *, loff_t, int);
	int (*mmap)(struct file *, struct kobject *, const struct bin_attribute *, struct vm_area_struct *);
};

struct acpi_data_attr {
	struct bin_attribute attr;
	u64 addr;
};

typedef void *acpi_handle;

struct fwnode_operations;

struct fwnode_handle {
	struct fwnode_handle *secondary;
	const struct fwnode_operations *ops;
	struct device *dev;
	struct list_head suppliers;
	struct list_head consumers;
	u8 flags;
};

union acpi_object;

struct acpi_device_data {
	const union acpi_object *pointer;
	struct list_head properties;
	const union acpi_object *of_compatible;
	struct list_head subnodes;
};

struct acpi_data_node {
	struct list_head sibling;
	const char *name;
	acpi_handle handle;
	struct fwnode_handle fwnode;
	struct fwnode_handle *parent;
	struct acpi_device_data data;
	struct kobject kobj;
	struct completion kobj_done;
};

struct acpi_data_node_attr {
	struct attribute attr;
	ssize_t (*show)(struct acpi_data_node *, char *);
	ssize_t (*store)(struct acpi_data_node *, const char *, size_t);
};

struct acpi_data_obj {
	char *name;
	int (*fn)(void *, struct acpi_data_attr *);
};

struct acpi_data_table_mapping {
	void *pointer;
};

struct acpi_dep_data {
	struct list_head node;
	acpi_handle supplier;
	acpi_handle consumer;
	bool honor_dep;
	bool met;
	bool free_when_met;
};

union acpi_operand_object;

struct acpi_object_common {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
};

struct acpi_object_integer {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	u8 fill[3];
	u64 value;
};

struct acpi_object_string {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	char *pointer;
	u32 length;
};

struct acpi_object_buffer {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	u8 *pointer;
	u32 length;
	u32 aml_length;
	u8 *aml_start;
	struct acpi_namespace_node *node;
};

struct acpi_object_package {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	struct acpi_namespace_node *node;
	union acpi_operand_object **elements;
	u8 *aml_start;
	u32 aml_length;
	u32 count;
};

struct acpi_object_event {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	void *os_semaphore;
};

struct acpi_walk_state;

typedef acpi_status (*acpi_internal_method)(struct acpi_walk_state *);

struct acpi_object_method {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	u8 info_flags;
	u8 param_count;
	u8 sync_level;
	union acpi_operand_object *mutex;
	union acpi_operand_object *node;
	u8 *aml_start;
	union {
		acpi_internal_method implementation;
		union acpi_operand_object *handler;
	} dispatch;
	u32 aml_length;
	acpi_owner_id owner_id;
	u8 thread_count;
};

struct acpi_thread_state;

struct acpi_object_mutex {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	u8 sync_level;
	u16 acquisition_depth;
	void *os_mutex;
	u64 thread_id;
	struct acpi_thread_state *owner_thread;
	union acpi_operand_object *prev;
	union acpi_operand_object *next;
	struct acpi_namespace_node *node;
	u8 original_sync_level;
};

struct acpi_object_region {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	u8 space_id;
	struct acpi_namespace_node *node;
	union acpi_operand_object *handler;
	union acpi_operand_object *next;
	acpi_physical_address address;
	u32 length;
	void *pointer;
};

struct acpi_object_notify_common {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	union acpi_operand_object *notify_list[2];
	union acpi_operand_object *handler;
};

struct acpi_gpe_block_info;

struct acpi_object_device {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	union acpi_operand_object *notify_list[2];
	union acpi_operand_object *handler;
	struct acpi_gpe_block_info *gpe_block;
};

struct acpi_object_power_resource {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	union acpi_operand_object *notify_list[2];
	union acpi_operand_object *handler;
	u32 system_level;
	u32 resource_order;
};

struct acpi_object_processor {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	u8 proc_id;
	u8 length;
	union acpi_operand_object *notify_list[2];
	union acpi_operand_object *handler;
	acpi_io_address address;
};

struct acpi_object_thermal_zone {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	union acpi_operand_object *notify_list[2];
	union acpi_operand_object *handler;
};

struct acpi_object_field_common {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	u8 field_flags;
	u8 attribute;
	u8 access_byte_width;
	struct acpi_namespace_node *node;
	u32 bit_length;
	u32 base_byte_offset;
	u32 value;
	u8 start_field_bit_offset;
	u8 access_length;
	union acpi_operand_object *region_obj;
};

struct acpi_object_region_field {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	u8 field_flags;
	u8 attribute;
	u8 access_byte_width;
	struct acpi_namespace_node *node;
	u32 bit_length;
	u32 base_byte_offset;
	u32 value;
	u8 start_field_bit_offset;
	u8 access_length;
	u16 resource_length;
	union acpi_operand_object *region_obj;
	u8 *resource_buffer;
	u16 pin_number_index;
	u8 *internal_pcc_buffer;
};

struct acpi_object_buffer_field {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	u8 field_flags;
	u8 attribute;
	u8 access_byte_width;
	struct acpi_namespace_node *node;
	u32 bit_length;
	u32 base_byte_offset;
	u32 value;
	u8 start_field_bit_offset;
	u8 access_length;
	u8 is_create_field;
	union acpi_operand_object *buffer_obj;
};

struct acpi_object_bank_field {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	u8 field_flags;
	u8 attribute;
	u8 access_byte_width;
	struct acpi_namespace_node *node;
	u32 bit_length;
	u32 base_byte_offset;
	u32 value;
	u8 start_field_bit_offset;
	u8 access_length;
	union acpi_operand_object *region_obj;
	union acpi_operand_object *bank_obj;
};

struct acpi_object_index_field {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	u8 field_flags;
	u8 attribute;
	u8 access_byte_width;
	struct acpi_namespace_node *node;
	u32 bit_length;
	u32 base_byte_offset;
	u32 value;
	u8 start_field_bit_offset;
	u8 access_length;
	union acpi_operand_object *index_obj;
	union acpi_operand_object *data_obj;
};

typedef void (*acpi_notify_handler)(acpi_handle, u32, void *);

struct acpi_object_notify_handler {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	struct acpi_namespace_node *node;
	u32 handler_type;
	acpi_notify_handler handler;
	void *context;
	union acpi_operand_object *next[2];
};

typedef acpi_status (*acpi_adr_space_handler)(u32, acpi_physical_address, u32, u64 *, void *, void *);

typedef acpi_status (*acpi_adr_space_setup)(acpi_handle, u32, void *, void **);

struct acpi_object_addr_handler {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	u8 space_id;
	u8 handler_flags;
	acpi_adr_space_handler handler;
	struct acpi_namespace_node *node;
	void *context;
	void *context_mutex;
	acpi_adr_space_setup setup;
	union acpi_operand_object *region_list;
	union acpi_operand_object *next;
};

struct acpi_object_reference {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	u8 class;
	u8 target_type;
	u8 resolved;
	void *object;
	struct acpi_namespace_node *node;
	union acpi_operand_object **where;
	u8 *index_pointer;
	u8 *aml;
	u32 value;
};

struct acpi_object_extra {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	struct acpi_namespace_node *method_REG;
	struct acpi_namespace_node *scope_node;
	void *region_context;
	u8 *aml_start;
	u32 aml_length;
};

typedef void (*acpi_object_handler)(acpi_handle, void *);

struct acpi_object_data {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	acpi_object_handler handler;
	void *pointer;
};

struct acpi_object_cache_list {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	union acpi_operand_object *next;
};

union acpi_name_union {
	u32 integer;
	char ascii[4];
};

struct acpi_namespace_node {
	union acpi_operand_object *object;
	u8 descriptor_type;
	u8 type;
	u16 flags;
	union acpi_name_union name;
	struct acpi_namespace_node *parent;
	struct acpi_namespace_node *child;
	struct acpi_namespace_node *peer;
	acpi_owner_id owner_id;
};

union acpi_operand_object {
	struct acpi_object_common common;
	struct acpi_object_integer integer;
	struct acpi_object_string string;
	struct acpi_object_buffer buffer;
	struct acpi_object_package package;
	struct acpi_object_event event;
	struct acpi_object_method method;
	struct acpi_object_mutex mutex;
	struct acpi_object_region region;
	struct acpi_object_notify_common common_notify;
	struct acpi_object_device device;
	struct acpi_object_power_resource power_resource;
	struct acpi_object_processor processor;
	struct acpi_object_thermal_zone thermal_zone;
	struct acpi_object_field_common common_field;
	struct acpi_object_region_field field;
	struct acpi_object_buffer_field buffer_field;
	struct acpi_object_bank_field bank_field;
	struct acpi_object_index_field index_field;
	struct acpi_object_notify_handler notify;
	struct acpi_object_addr_handler address_space;
	struct acpi_object_reference reference;
	struct acpi_object_extra extra;
	struct acpi_object_data data;
	struct acpi_object_cache_list cache;
	struct acpi_namespace_node node;
};

union acpi_parse_value {
	u64 integer;
	u32 size;
	char *string;
	u8 *buffer;
	char *name;
	union acpi_parse_object *arg;
};

struct acpi_parse_obj_common {
	union acpi_parse_object *parent;
	u8 descriptor_type;
	u8 flags;
	u16 aml_opcode;
	u8 *aml;
	union acpi_parse_object *next;
	struct acpi_namespace_node *node;
	union acpi_parse_value value;
	u8 arg_list_length;
};

struct acpi_parse_obj_named {
	union acpi_parse_object *parent;
	u8 descriptor_type;
	u8 flags;
	u16 aml_opcode;
	u8 *aml;
	union acpi_parse_object *next;
	struct acpi_namespace_node *node;
	union acpi_parse_value value;
	u8 arg_list_length;
	char *path;
	u8 *data;
	u32 length;
	u32 name;
};

struct acpi_parse_obj_asl {
	union acpi_parse_object *parent;
	u8 descriptor_type;
	u8 flags;
	u16 aml_opcode;
	u8 *aml;
	union acpi_parse_object *next;
	struct acpi_namespace_node *node;
	union acpi_parse_value value;
	u8 arg_list_length;
	union acpi_parse_object *child;
	union acpi_parse_object *parent_method;
	char *filename;
	u8 file_changed;
	char *parent_filename;
	char *external_name;
	char *namepath;
	char name_seg[4];
	u32 extra_value;
	u32 column;
	u32 line_number;
	u32 logical_line_number;
	u32 logical_byte_offset;
	u32 end_line;
	u32 end_logical_line;
	u32 acpi_btype;
	u32 aml_length;
	u32 aml_subtree_length;
	u32 final_aml_length;
	u32 final_aml_offset;
	u32 compile_flags;
	u16 parse_opcode;
	u8 aml_opcode_length;
	u8 aml_pkg_len_bytes;
	u8 extra;
	char parse_op_name[20];
};

union acpi_parse_object {
	struct acpi_parse_obj_common common;
	struct acpi_parse_obj_named named;
	struct acpi_parse_obj_asl asl;
};

union acpi_descriptor {
	struct acpi_common_descriptor common;
	union acpi_operand_object object;
	struct acpi_namespace_node node;
	union acpi_parse_object op;
};

struct acpi_device_id {
	__u8 id[16];
	kernel_ulong_t driver_data;
	__u32 cls;
	__u32 cls_msk;
};

struct acpi_dev_match_info {
	struct acpi_device_id hid[2];
	const char *uid;
	s64 hrv;
};

struct acpi_dev_walk_context {
	int (*fn)(struct acpi_device *, void *);
	void *data;
};

struct acpi_device_status {
	u32 present: 1;
	u32 enabled: 1;
	u32 show_in_ui: 1;
	u32 functional: 1;
	u32 battery_present: 1;
	u32 reserved: 27;
};

struct acpi_device_flags {
	u32 dynamic_status: 1;
	u32 removable: 1;
	u32 ejectable: 1;
	u32 power_manageable: 1;
	u32 match_driver: 1;
	u32 initialized: 1;
	u32 visited: 1;
	u32 hotplug_notify: 1;
	u32 is_dock_station: 1;
	u32 of_compatible_ok: 1;
	u32 coherent_dma: 1;
	u32 cca_seen: 1;
	u32 enumeration_by_parent: 1;
	u32 honor_deps: 1;
	u32 reserved: 18;
};

struct acpi_pnp_type {
	u32 hardware_id: 1;
	u32 bus_address: 1;
	u32 platform_id: 1;
	u32 backlight: 1;
	u32 reserved: 28;
};

struct acpi_device_pnp {
	acpi_bus_id bus_id;
	int instance_no;
	struct acpi_pnp_type type;
	acpi_bus_address bus_address;
	char *unique_id;
	struct list_head ids;
	acpi_device_name device_name;
	acpi_device_class device_class;
};

struct acpi_device_power_flags {
	u32 explicit_get: 1;
	u32 power_resources: 1;
	u32 inrush_current: 1;
	u32 power_removed: 1;
	u32 ignore_parent: 1;
	u32 dsw_present: 1;
	u32 reserved: 26;
};

struct acpi_device_power_state {
	struct list_head resources;
	struct {
		u8 valid: 1;
		u8 explicit_set: 1;
		u8 reserved: 6;
	} flags;
	int power;
	int latency;
};

struct acpi_device_power {
	int state;
	struct acpi_device_power_flags flags;
	struct acpi_device_power_state states[5];
	u8 state_for_enumeration;
};

struct acpi_device_wakeup_flags {
	u8 valid: 1;
	u8 notifier_present: 1;
};

struct acpi_device_wakeup_context {
	void (*func)(struct acpi_device_wakeup_context *);
	struct device *dev;
};

struct acpi_device_wakeup {
	acpi_handle gpe_device;
	u64 gpe_number;
	u64 sleep_state;
	struct list_head resources;
	struct acpi_device_wakeup_flags flags;
	struct acpi_device_wakeup_context context;
	struct wakeup_source *ws;
	int prepare_count;
	int enable_count;
};

struct acpi_device_perf_flags {
	u8 reserved: 8;
};

struct acpi_device_perf_state;

struct acpi_device_perf {
	int state;
	struct acpi_device_perf_flags flags;
	int state_count;
	struct acpi_device_perf_state *states;
};

struct proc_dir_entry;

struct acpi_device_dir {
	struct proc_dir_entry *entry;
};

struct acpi_scan_handler;

struct acpi_hotplug_context;

struct acpi_device_software_nodes;

struct acpi_gpio_mapping;

struct acpi_device {
	u32 pld_crc;
	int device_type;
	acpi_handle handle;
	struct fwnode_handle fwnode;
	struct list_head wakeup_list;
	struct list_head del_list;
	struct acpi_device_status status;
	struct acpi_device_flags flags;
	struct acpi_device_pnp pnp;
	struct acpi_device_power power;
	struct acpi_device_wakeup wakeup;
	struct acpi_device_perf performance;
	struct acpi_device_dir dir;
	struct acpi_device_data data;
	struct acpi_scan_handler *handler;
	struct acpi_hotplug_context *hp;
	struct acpi_device_software_nodes *swnodes;
	const struct acpi_gpio_mapping *driver_gpios;
	void *driver_data;
	struct device dev;
	unsigned int physical_node_count;
	unsigned int dep_unmet;
	struct list_head physical_node_list;
	struct mutex physical_node_lock;
	void (*remove)(struct acpi_device *);
};

struct xarray {
	spinlock_t xa_lock;
	gfp_t xa_flags;
	void *xa_head;
};

struct ida {
	struct xarray xa;
};

struct acpi_device_bus_id {
	const char *bus_id;
	struct ida instance_ida;
	struct list_head node;
};

struct acpi_pnp_device_id {
	u32 length;
	char *string;
};

struct acpi_pnp_device_id_list {
	u32 count;
	u32 list_size;
	struct acpi_pnp_device_id ids[0];
};

struct acpi_device_info {
	u32 info_size;
	u32 name;
	acpi_object_type type;
	u8 param_count;
	u16 valid;
	u8 flags;
	u8 highest_dstates[4];
	u8 lowest_dstates[5];
	u64 address;
	struct acpi_pnp_device_id hardware_id;
	struct acpi_pnp_device_id unique_id;
	struct acpi_pnp_device_id class_code;
	struct acpi_pnp_device_id_list compatible_id_list;
};

typedef int (*acpi_op_add)(struct acpi_device *);

typedef void (*acpi_op_remove)(struct acpi_device *);

typedef void (*acpi_op_notify)(struct acpi_device *, u32);

struct acpi_device_ops {
	acpi_op_add add;
	acpi_op_remove remove;
	acpi_op_notify notify;
};

struct acpi_device_perf_state {
	struct {
		u8 valid: 1;
		u8 reserved: 7;
	} flags;
	u8 power;
	u8 performance;
	int latency;
};

struct acpi_device_physical_node {
	struct list_head node;
	struct device *dev;
	unsigned int node_id;
	bool put_online: 1;
};

struct acpi_device_properties {
	struct list_head list;
	const guid_t *guid;
	union acpi_object *properties;
	void **bufs;
};

struct property_entry {
	const char *name;
	size_t length;
	bool is_inline;
	enum dev_prop_type type;
	union {
		const void *pointer;
		union {
			u8 u8_data[8];
			u16 u16_data[4];
			u32 u32_data[2];
			u64 u64_data[1];
			const char *str[1];
		} value;
	};
};

struct software_node;

struct software_node_ref_args {
	const struct software_node *node;
	unsigned int nargs;
	u64 args[8];
};

struct acpi_device_software_node_port {
	char port_name[9];
	u32 data_lanes[8];
	u32 lane_polarities[9];
	u64 link_frequencies[8];
	unsigned int port_nr;
	bool crs_csi2_local;
	struct property_entry port_props[2];
	struct property_entry ep_props[8];
	struct software_node_ref_args remote_ep[1];
};

struct acpi_device_software_nodes {
	struct property_entry dev_props[6];
	struct software_node *nodes;
	const struct software_node **nodeptrs;
	struct acpi_device_software_node_port *ports;
	unsigned int num_ports;
};

struct acpi_table_desc;

struct acpi_evaluate_info;

struct acpi_device_walk_info {
	struct acpi_table_desc *table_desc;
	struct acpi_evaluate_info *evaluate_info;
	u32 device_count;
	u32 num_STA;
	u32 num_INI;
};

struct dma_chan;

struct acpi_dma_spec;

struct acpi_dma {
	struct list_head dma_controllers;
	struct device *dev;
	struct dma_chan * (*acpi_dma_xlate)(struct acpi_dma_spec *, struct acpi_dma *);
	void *data;
	short unsigned int base_request_line;
	short unsigned int end_request_line;
};

typedef bool (*dma_filter_fn)(struct dma_chan *, void *);

struct acpi_dma_filter_info {
	dma_cap_mask_t dma_cap;
	dma_filter_fn filter_fn;
};

struct acpi_dma_spec {
	int chan_id;
	int slave_id;
	struct device *dev;
};

struct acpi_dma_parser_data {
	struct acpi_dma_spec dma_spec;
	size_t index;
	size_t n;
};

struct acpi_dmar_header {
	u16 type;
	u16 length;
};

struct acpi_dmar_andd {
	struct acpi_dmar_header header;
	u8 reserved[3];
	u8 device_number;
	union {
		char __pad;
		struct {
			struct {} __Empty_device_name;
			char device_name[0];
		};
	};
} __attribute__((packed));

struct acpi_dmar_atsr {
	struct acpi_dmar_header header;
	u8 flags;
	u8 reserved;
	u16 segment;
};

struct acpi_dmar_device_scope {
	u8 entry_type;
	u8 length;
	u16 reserved;
	u8 enumeration_id;
	u8 bus;
};

struct acpi_dmar_hardware_unit {
	struct acpi_dmar_header header;
	u8 flags;
	u8 size;
	u16 segment;
	u64 address;
};

struct acpi_dmar_pci_path {
	u8 device;
	u8 function;
};

struct acpi_dmar_reserved_memory {
	struct acpi_dmar_header header;
	u16 reserved;
	u16 segment;
	u64 base_address;
	u64 end_address;
};

struct acpi_dmar_rhsa {
	struct acpi_dmar_header header;
	u32 reserved;
	u64 base_address;
	u32 proximity_domain;
} __attribute__((packed));

struct acpi_dmar_satc {
	struct acpi_dmar_header header;
	u8 flags;
	u8 reserved;
	u16 segment;
};

struct of_device_id;

struct dev_pm_ops;

struct driver_private;

struct device_driver {
	const char *name;
	const struct bus_type *bus;
	struct module *owner;
	const char *mod_name;
	bool suppress_bind_attrs;
	enum probe_type probe_type;
	const struct of_device_id *of_match_table;
	const struct acpi_device_id *acpi_match_table;
	int (*probe)(struct device *);
	void (*sync_state)(struct device *);
	int (*remove)(struct device *);
	void (*shutdown)(struct device *);
	int (*suspend)(struct device *, pm_message_t);
	int (*resume)(struct device *);
	const struct attribute_group **groups;
	const struct attribute_group **dev_groups;
	const struct dev_pm_ops *pm;
	void (*coredump)(struct device *);
	struct driver_private *p;
};

struct acpi_driver {
	char name[80];
	char class[80];
	const struct acpi_device_id *ids;
	unsigned int flags;
	struct acpi_device_ops ops;
	struct device_driver drv;
};

struct transaction;

struct acpi_ec {
	acpi_handle handle;
	int gpe;
	int irq;
	long unsigned int command_addr;
	long unsigned int data_addr;
	bool global_lock;
	long unsigned int flags;
	long unsigned int reference_count;
	struct mutex mutex;
	wait_queue_head_t wait;
	struct list_head list;
	struct transaction *curr;
	spinlock_t lock;
	struct work_struct work;
	long unsigned int timestamp;
	enum acpi_ec_event_state event_state;
	unsigned int events_to_process;
	unsigned int events_in_progress;
	unsigned int queries_in_progress;
	bool busy_polling;
	unsigned int polling_guard;
};

struct transaction {
	const u8 *wdata;
	u8 *rdata;
	short unsigned int irq_count;
	u8 command;
	u8 wi;
	u8 ri;
	u8 wlen;
	u8 rlen;
	u8 flags;
};

struct acpi_ec_query_handler;

struct acpi_ec_query {
	struct transaction transaction;
	struct work_struct work;
	struct acpi_ec_query_handler *handler;
	struct acpi_ec *ec;
};

typedef int (*acpi_ec_query_func)(void *);

struct acpi_ec_query_handler {
	struct list_head node;
	acpi_ec_query_func func;
	acpi_handle handle;
	void *data;
	u8 query_bit;
	struct kref kref;
};

union acpi_predefined_info;

struct acpi_evaluate_info {
	struct acpi_namespace_node *prefix_node;
	const char *relative_pathname;
	union acpi_operand_object **parameters;
	struct acpi_namespace_node *node;
	union acpi_operand_object *obj_desc;
	char *full_pathname;
	const union acpi_predefined_info *predefined;
	union acpi_operand_object *return_object;
	union acpi_operand_object *parent_package;
	u32 return_flags;
	u32 return_btype;
	u16 param_count;
	u16 node_flags;
	u8 pass_number;
	u8 return_object_type;
	u8 flags;
};

struct acpi_exception_info {
	char *name;
};

struct acpi_fadt_info {
	const char *name;
	u16 address64;
	u16 address32;
	u16 length;
	u8 default_length;
	u8 flags;
};

struct acpi_generic_address;

struct acpi_fadt_pm_info {
	struct acpi_generic_address *target;
	u16 source;
	u8 register_num;
};

struct acpi_fan_fif {
	u8 revision;
	u8 fine_grain_ctrl;
	u8 step_size;
	u8 low_speed_notification;
};

struct device_attribute {
	struct attribute attr;
	ssize_t (*show)(struct device *, struct device_attribute *, char *);
	ssize_t (*store)(struct device *, struct device_attribute *, const char *, size_t);
};

struct acpi_fan_fps;

struct thermal_cooling_device;

struct acpi_fan {
	bool acpi4;
	struct acpi_fan_fif fif;
	struct acpi_fan_fps *fps;
	int fps_count;
	struct thermal_cooling_device *cdev;
	struct device_attribute fst_speed;
	struct device_attribute fine_grain_control;
};

struct acpi_fan_fps {
	u64 control;
	u64 trip_point;
	u64 speed;
	u64 noise_level;
	u64 power;
	char name[20];
	struct device_attribute dev_attr;
};

struct acpi_fan_fst {
	u64 revision;
	u64 control;
	u64 speed;
};

struct acpi_ffh_info {
	u64 offset;
	u64 length;
};

typedef u32 (*acpi_event_handler)(void *);

struct acpi_fixed_event_handler {
	acpi_event_handler handler;
	void *context;
};

struct acpi_fixed_event_info {
	u8 status_register_id;
	u8 enable_register_id;
	u16 status_bit_mask;
	u16 enable_bit_mask;
};

struct acpi_ged_device {
	struct device *dev;
	struct list_head event_list;
};

struct acpi_ged_event {
	struct list_head node;
	struct device *dev;
	unsigned int gsi;
	unsigned int irq;
	acpi_handle handle;
};

struct acpi_ged_handler_info {
	struct acpi_ged_handler_info *next;
	u32 int_id;
	struct acpi_namespace_node *evt_method;
};

struct acpi_generic_address {
	u8 space_id;
	u8 bit_width;
	u8 bit_offset;
	u8 access_width;
	u64 address;
} __attribute__((packed));

struct acpi_update_state {
	void *next;
	u8 descriptor_type;
	u8 flags;
	u16 value;
	u16 state;
	union acpi_operand_object *object;
};

struct acpi_scope_state {
	void *next;
	u8 descriptor_type;
	u8 flags;
	u16 value;
	u16 state;
	struct acpi_namespace_node *node;
};

struct acpi_pscope_state {
	void *next;
	u8 descriptor_type;
	u8 flags;
	u16 value;
	u16 state;
	u32 arg_count;
	union acpi_parse_object *op;
	u8 *arg_end;
	u8 *pkg_end;
	u32 arg_list;
};

struct acpi_pkg_state {
	void *next;
	u8 descriptor_type;
	u8 flags;
	u16 value;
	u16 state;
	u32 index;
	union acpi_operand_object *source_object;
	union acpi_operand_object *dest_object;
	struct acpi_walk_state *walk_state;
	void *this_target_obj;
	u32 num_packages;
};

struct acpi_thread_state {
	void *next;
	u8 descriptor_type;
	u8 flags;
	u16 value;
	u16 state;
	u8 current_sync_level;
	struct acpi_walk_state *walk_state_list;
	union acpi_operand_object *acquired_mutex_list;
	u64 thread_id;
};

struct acpi_result_values {
	void *next;
	u8 descriptor_type;
	u8 flags;
	u16 value;
	u16 state;
	union acpi_operand_object *obj_desc[8];
};

struct acpi_global_notify_handler;

struct acpi_notify_info {
	void *next;
	u8 descriptor_type;
	u8 flags;
	u16 value;
	u16 state;
	u8 handler_list_id;
	struct acpi_namespace_node *node;
	union acpi_operand_object *handler_list_head;
	struct acpi_global_notify_handler *global;
};

union acpi_generic_state {
	struct acpi_common_state common;
	struct acpi_control_state control;
	struct acpi_update_state update;
	struct acpi_scope_state scope;
	struct acpi_pscope_state parse_scope;
	struct acpi_pkg_state pkg;
	struct acpi_thread_state thread;
	struct acpi_result_values results;
	struct acpi_notify_info notify;
};

struct acpi_genl_event {
	acpi_device_class device_class;
	char bus_id[15];
	u32 type;
	u32 data;
};

typedef acpi_status (*acpi_walk_callback)(acpi_handle, u32, void *, void **);

struct acpi_get_devices_info {
	acpi_walk_callback user_function;
	void *context;
	const char *hid;
};

struct acpi_global_notify_handler {
	acpi_notify_handler handler;
	void *context;
};

struct acpi_gpe_address {
	u8 space_id;
	u64 address;
};

struct acpi_gpe_xrupt_info;

struct acpi_gpe_register_info;

struct acpi_gpe_event_info;

struct acpi_gpe_block_info {
	struct acpi_namespace_node *node;
	struct acpi_gpe_block_info *previous;
	struct acpi_gpe_block_info *next;
	struct acpi_gpe_xrupt_info *xrupt_block;
	struct acpi_gpe_register_info *register_info;
	struct acpi_gpe_event_info *event_info;
	u64 address;
	u32 register_count;
	u16 gpe_count;
	u16 block_base_number;
	u8 space_id;
	u8 initialized;
};

struct acpi_gpe_block_status_context {
	struct acpi_gpe_register_info *gpe_skip_register_info;
	u8 gpe_skip_mask;
	u8 retval;
};

struct acpi_gpe_device_info {
	u32 index;
	u32 next_block_base_index;
	acpi_status status;
	struct acpi_namespace_node *gpe_device;
};

struct acpi_gpe_handler_info;

struct acpi_gpe_notify_info;

union acpi_gpe_dispatch_info {
	struct acpi_namespace_node *method_node;
	struct acpi_gpe_handler_info *handler;
	struct acpi_gpe_notify_info *notify_list;
};

struct acpi_gpe_event_info {
	union acpi_gpe_dispatch_info dispatch;
	struct acpi_gpe_register_info *register_info;
	u8 flags;
	u8 gpe_number;
	u8 runtime_count;
	u8 disable_for_dispatch;
};

typedef u32 (*acpi_gpe_handler)(acpi_handle, u32, void *);

struct acpi_gpe_handler_info {
	acpi_gpe_handler address;
	void *context;
	struct acpi_namespace_node *method_node;
	u8 original_flags;
	u8 originally_enabled;
};

struct acpi_gpe_notify_info {
	struct acpi_namespace_node *device_node;
	struct acpi_gpe_notify_info *next;
};

struct acpi_gpe_register_info {
	struct acpi_gpe_address status_address;
	struct acpi_gpe_address enable_address;
	u16 base_gpe_number;
	u8 enable_for_wake;
	u8 enable_for_run;
	u8 mask_for_run;
	u8 enable_mask;
};

struct acpi_gpe_walk_info {
	struct acpi_namespace_node *gpe_device;
	struct acpi_gpe_block_info *gpe_block;
	u16 count;
	acpi_owner_id owner_id;
	u8 execute_by_owner_id;
};

struct acpi_gpe_xrupt_info {
	struct acpi_gpe_xrupt_info *previous;
	struct acpi_gpe_xrupt_info *next;
	struct acpi_gpe_block_info *gpe_block_list_head;
	u32 interrupt_number;
};

struct acpi_gpio_params;

struct acpi_gpio_mapping {
	const char *name;
	const struct acpi_gpio_params *data;
	unsigned int size;
	unsigned int quirks;
};

struct acpi_gpio_params {
	unsigned int crs_entry_index;
	unsigned int line_index;
	bool active_low;
};

struct acpi_handle_list {
	u32 count;
	acpi_handle *handles;
};

struct acpi_hardware_id {
	struct list_head list;
	const char *id;
};

struct acpi_hmat_structure {
	u16 type;
	u16 reserved;
	u32 length;
};

typedef int (*acpi_hp_notify)(struct acpi_device *, u32);

typedef void (*acpi_hp_uevent)(struct acpi_device *, u32);

typedef void (*acpi_hp_fixup)(struct acpi_device *);

struct acpi_hotplug_context {
	struct acpi_device *self;
	acpi_hp_notify notify;
	acpi_hp_uevent uevent;
	acpi_hp_fixup fixup;
};

struct acpi_hotplug_profile {
	struct kobject kobj;
	int (*scan_dependent)(struct acpi_device *);
	void (*notify_online)(struct acpi_device *);
	bool enabled: 1;
	bool demand_offline: 1;
};

struct acpi_hp_work {
	struct work_struct work;
	struct acpi_device *adev;
	u32 src;
};

struct acpi_init_walk_info {
	u32 table_index;
	u32 object_count;
	u32 method_count;
	u32 serial_method_count;
	u32 non_serial_method_count;
	u32 serialized_method_count;
	u32 device_count;
	u32 op_region_count;
	u32 field_count;
	u32 buffer_count;
	u32 package_count;
	u32 op_region_init;
	u32 field_init;
	u32 buffer_init;
	u32 package_init;
	acpi_owner_id owner_id;
};

struct acpi_interface_info {
	char *name;
	struct acpi_interface_info *next;
	u8 flags;
	u8 value;
};

struct acpi_io_attribute {
	u8 range_type;
	u8 translation;
	u8 translation_type;
	u8 reserved1;
};

struct rcu_work {
	struct work_struct work;
	struct callback_head rcu;
	struct workqueue_struct *wq;
};

struct acpi_ioremap {
	struct list_head list;
	void *virt;
	acpi_physical_address phys;
	acpi_size size;
	union {
		long unsigned int refcount;
		struct rcu_work rwork;
	} track;
};

struct acpi_lpat {
	int temp;
	int raw;
};

struct acpi_lpat_conversion_table {
	struct acpi_lpat *lpat;
	int lpat_count;
};

struct acpi_lpi_state {
	u32 min_residency;
	u32 wake_latency;
	u32 flags;
	u32 arch_flags;
	u32 res_cnt_freq;
	u32 enable_parent_state;
	u64 address;
	u8 index;
	u8 entry_method;
	char desc[32];
};

struct acpi_lpi_states_array {
	unsigned int size;
	unsigned int composite_states_size;
	struct acpi_lpi_state *entries;
	struct acpi_lpi_state *composite_states[8];
};

struct acpi_lpit_header {
	u32 type;
	u32 length;
	u16 unique_id;
	u16 reserved;
	u32 flags;
};

struct acpi_lpit_native {
	struct acpi_lpit_header header;
	struct acpi_generic_address entry_trigger;
	u32 residency;
	u32 latency;
	struct acpi_generic_address residency_counter;
	u64 counter_frequency;
};

struct acpi_subtable_header {
	u8 type;
	u8 length;
};

struct acpi_madt_core_pic {
	struct acpi_subtable_header header;
	u8 version;
	u32 processor_id;
	u32 core_id;
	u32 flags;
} __attribute__((packed));

struct acpi_madt_generic_distributor {
	struct acpi_subtable_header header;
	u16 reserved;
	u32 gic_id;
	u64 base_address;
	u32 global_irq_base;
	u8 version;
	u8 reserved2[3];
};

struct acpi_madt_generic_interrupt {
	struct acpi_subtable_header header;
	u16 reserved;
	u32 cpu_interface_number;
	u32 uid;
	u32 flags;
	u32 parking_version;
	u32 performance_interrupt;
	u64 parked_address;
	u64 base_address;
	u64 gicv_base_address;
	u64 gich_base_address;
	u32 vgic_interrupt;
	u64 gicr_base_address;
	u64 arm_mpidr;
	u8 efficiency_class;
	u8 reserved2[1];
	u16 spe_interrupt;
	u16 trbe_interrupt;
} __attribute__((packed));

struct acpi_madt_interrupt_override {
	struct acpi_subtable_header header;
	u8 bus;
	u8 source_irq;
	u32 global_irq;
	u16 inti_flags;
} __attribute__((packed));

struct acpi_madt_interrupt_source {
	struct acpi_subtable_header header;
	u16 inti_flags;
	u8 type;
	u8 id;
	u8 eid;
	u8 io_sapic_vector;
	u32 global_irq;
	u32 flags;
};

struct acpi_madt_io_apic {
	struct acpi_subtable_header header;
	u8 id;
	u8 reserved;
	u32 address;
	u32 global_irq_base;
};

struct acpi_madt_io_sapic {
	struct acpi_subtable_header header;
	u8 id;
	u8 reserved;
	u32 global_irq_base;
	u64 address;
};

struct acpi_madt_local_apic {
	struct acpi_subtable_header header;
	u8 processor_id;
	u8 id;
	u32 lapic_flags;
};

struct acpi_madt_local_apic_nmi {
	struct acpi_subtable_header header;
	u8 processor_id;
	u16 inti_flags;
	u8 lint;
} __attribute__((packed));

struct acpi_madt_local_apic_override {
	struct acpi_subtable_header header;
	u16 reserved;
	u64 address;
} __attribute__((packed));

struct acpi_madt_local_sapic {
	struct acpi_subtable_header header;
	u8 processor_id;
	u8 id;
	u8 eid;
	u8 reserved[3];
	u32 lapic_flags;
	u32 uid;
	char uid_string[0];
};

struct acpi_madt_local_x2apic {
	struct acpi_subtable_header header;
	u16 reserved;
	u32 local_apic_id;
	u32 lapic_flags;
	u32 uid;
};

struct acpi_madt_local_x2apic_nmi {
	struct acpi_subtable_header header;
	u16 inti_flags;
	u32 uid;
	u8 lint;
	u8 reserved[3];
};

struct acpi_madt_multiproc_wakeup {
	struct acpi_subtable_header header;
	u16 version;
	u32 reserved;
	u64 mailbox_address;
	u64 reset_vector;
};

struct acpi_madt_multiproc_wakeup_mailbox {
	u16 command;
	u16 reserved;
	u32 apic_id;
	u64 wakeup_vector;
	u8 reserved_os[2032];
	u8 reserved_firmware[2048];
};

struct acpi_madt_nmi_source {
	struct acpi_subtable_header header;
	u16 inti_flags;
	u32 global_irq;
};

struct acpi_madt_rintc {
	struct acpi_subtable_header header;
	u8 version;
	u8 reserved;
	u32 flags;
	u64 hart_id;
	u32 uid;
	u32 ext_intc_id;
	u64 imsic_addr;
	u32 imsic_size;
} __attribute__((packed));

struct acpi_mcfg_allocation {
	u64 address;
	u16 pci_segment;
	u8 start_bus_number;
	u8 end_bus_number;
	u32 reserved;
};

struct acpi_mem_mapping {
	acpi_physical_address physical_address;
	u8 *logical_address;
	acpi_size length;
	struct acpi_mem_mapping *next_mm;
};

struct acpi_mem_space_context {
	u32 length;
	acpi_physical_address address;
	struct acpi_mem_mapping *cur_mm;
	struct acpi_mem_mapping *first_mm;
};

struct acpi_memory_attribute {
	u8 write_protect;
	u8 caching;
	u8 range_type;
	u8 translation;
};

struct acpi_mutex_info {
	void *mutex;
	u32 use_count;
	u64 thread_id;
};

struct acpi_name_info {
	char name[4];
	u16 argument_list;
	u8 expected_btypes;
} __attribute__((packed));

struct acpi_namestring_info {
	const char *external_name;
	const char *next_external_char;
	char *internal_name;
	u32 length;
	u32 num_segments;
	u32 num_carats;
	u8 fully_qualified;
};

struct acpi_nhlt_config {
	u32 capabilities_size;
	u8 capabilities[0];
};

struct acpi_nhlt_gendevice_config {
	u8 virtual_slot;
	u8 config_type;
};

struct acpi_nhlt_micdevice_config {
	u8 virtual_slot;
	u8 config_type;
	u8 array_type;
};

struct acpi_nhlt_vendor_mic_config {
	u8 type;
	u8 panel;
	u16 speaker_position_distance;
	u16 horizontal_offset;
	u16 vertical_offset;
	u8 frequency_low_band;
	u8 frequency_high_band;
	u16 direction_angle;
	u16 elevation_angle;
	u16 work_vertical_angle_begin;
	u16 work_vertical_angle_end;
	u16 work_horizontal_angle_begin;
	u16 work_horizontal_angle_end;
};

struct acpi_nhlt_vendor_micdevice_config {
	u8 virtual_slot;
	u8 config_type;
	u8 array_type;
	u8 mics_count;
	struct acpi_nhlt_vendor_mic_config mics[0];
};

union acpi_nhlt_device_config {
	u8 virtual_slot;
	struct acpi_nhlt_gendevice_config gen;
	struct acpi_nhlt_micdevice_config mic;
	struct acpi_nhlt_vendor_micdevice_config vendor_mic;
};

struct acpi_nhlt_endpoint {
	u32 length;
	u8 link_type;
	u8 instance_id;
	u16 vendor_id;
	u16 device_id;
	u16 revision_id;
	u32 subsystem_id;
	u8 device_type;
	u8 direction;
	u8 virtual_bus_id;
} __attribute__((packed));

struct acpi_nhlt_wave_formatext {
	u16 format_tag;
	u16 channel_count;
	u32 samples_per_sec;
	u32 avg_bytes_per_sec;
	u16 block_align;
	u16 bits_per_sample;
	u16 extra_format_size;
	u16 valid_bits_per_sample;
	u32 channel_mask;
	u8 subformat[16];
};

struct acpi_nhlt_format_config {
	struct acpi_nhlt_wave_formatext format;
	struct acpi_nhlt_config config;
};

struct acpi_nhlt_formats_config {
	u8 formats_count;
	struct acpi_nhlt_format_config formats[0];
} __attribute__((packed));

union acpi_object {
	acpi_object_type type;
	struct {
		acpi_object_type type;
		u64 value;
	} integer;
	struct {
		acpi_object_type type;
		u32 length;
		char *pointer;
	} string;
	struct {
		acpi_object_type type;
		u32 length;
		u8 *pointer;
	} buffer;
	struct {
		acpi_object_type type;
		u32 count;
		union acpi_object *elements;
	} package;
	struct {
		acpi_object_type type;
		acpi_object_type actual_type;
		acpi_handle handle;
	} reference;
	struct {
		acpi_object_type type;
		u32 proc_id;
		acpi_io_address pblk_address;
		u32 pblk_length;
	} processor;
	struct {
		acpi_object_type type;
		u32 system_level;
		u32 resource_order;
	} power_resource;
};

struct acpi_object_list {
	u32 count;
	union acpi_object *pointer;
};

struct acpi_offsets {
	size_t offset;
	u8 mode;
};

struct acpi_opcode_info {
	u32 parse_args;
	u32 runtime_args;
	u16 flags;
	u8 object_type;
	u8 class;
	u8 type;
};

typedef void (*acpi_osd_exec_callback)(void *);

struct acpi_os_dpc {
	acpi_osd_exec_callback function;
	void *context;
	struct work_struct work;
};

struct acpi_osc_context {
	char *uuid_str;
	int rev;
	struct acpi_buffer cap;
	struct acpi_buffer ret;
};

struct acpi_osi_config {
	u8 default_disabling;
	unsigned int linux_enable: 1;
	unsigned int linux_dmi: 1;
	unsigned int linux_cmdline: 1;
	unsigned int darwin_enable: 1;
	unsigned int darwin_dmi: 1;
	unsigned int darwin_cmdline: 1;
};

struct acpi_osi_entry {
	char string[64];
	bool enable;
};

struct acpi_package_info {
	u8 type;
	u8 object_type1;
	u8 count1;
	u8 object_type2;
	u8 count2;
	u16 reserved;
} __attribute__((packed));

struct acpi_package_info2 {
	u8 type;
	u8 count;
	u8 object_type[4];
	u8 reserved;
};

struct acpi_package_info3 {
	u8 type;
	u8 count;
	u8 object_type[2];
	u8 tail_object_type;
	u16 reserved;
} __attribute__((packed));

struct acpi_package_info4 {
	u8 type;
	u8 object_type1;
	u8 count1;
	u8 sub_object_types;
	u8 pkg_count;
	u16 reserved;
} __attribute__((packed));

struct acpi_parse_state {
	u8 *aml_start;
	u8 *aml;
	u8 *aml_end;
	u8 *pkg_start;
	u8 *pkg_end;
	union acpi_parse_object *start_op;
	struct acpi_namespace_node *start_node;
	union acpi_generic_state *scope;
	union acpi_parse_object *start_scope;
	u32 aml_size;
};

struct acpi_pcc_info {
	u8 subspace_id;
	u16 length;
	u8 *internal_buffer;
};

struct acpi_pcct_ext_pcc_master {
	struct acpi_subtable_header header;
	u32 platform_interrupt;
	u8 flags;
	u8 reserved1;
	u64 base_address;
	u32 length;
	struct acpi_generic_address doorbell_register;
	u64 preserve_mask;
	u64 write_mask;
	u32 latency;
	u32 max_access_rate;
	u32 min_turnaround_time;
	struct acpi_generic_address platform_ack_register;
	u64 ack_preserve_mask;
	u64 ack_set_mask;
	u64 reserved2;
	struct acpi_generic_address cmd_complete_register;
	u64 cmd_complete_mask;
	struct acpi_generic_address cmd_update_register;
	u64 cmd_update_preserve_mask;
	u64 cmd_update_set_mask;
	struct acpi_generic_address error_status_register;
	u64 error_status_mask;
} __attribute__((packed));

struct acpi_pcct_ext_pcc_shared_memory {
	u32 signature;
	u32 flags;
	u32 length;
	u32 command;
};

struct acpi_pcct_hw_reduced {
	struct acpi_subtable_header header;
	u32 platform_interrupt;
	u8 flags;
	u8 reserved;
	u64 base_address;
	u64 length;
	struct acpi_generic_address doorbell_register;
	u64 preserve_mask;
	u64 write_mask;
	u32 latency;
	u32 max_access_rate;
	u16 min_turnaround_time;
} __attribute__((packed));

struct acpi_pcct_hw_reduced_type2 {
	struct acpi_subtable_header header;
	u32 platform_interrupt;
	u8 flags;
	u8 reserved;
	u64 base_address;
	u64 length;
	struct acpi_generic_address doorbell_register;
	u64 preserve_mask;
	u64 write_mask;
	u32 latency;
	u32 max_access_rate;
	u16 min_turnaround_time;
	struct acpi_generic_address platform_ack_register;
	u64 ack_preserve_mask;
	u64 ack_write_mask;
} __attribute__((packed));

struct acpi_pcct_shared_memory {
	u32 signature;
	u16 command;
	u16 status;
};

struct acpi_pcct_subspace {
	struct acpi_subtable_header header;
	u8 reserved[6];
	u64 base_address;
	u64 length;
	struct acpi_generic_address doorbell_register;
	u64 preserve_mask;
	u64 write_mask;
	u32 latency;
	u32 max_access_rate;
	u16 min_turnaround_time;
} __attribute__((packed));

struct acpi_pci_device {
	acpi_handle device;
	struct acpi_pci_device *next;
};

struct acpi_pci_id {
	u16 segment;
	u16 bus;
	u16 device;
	u16 function;
};

struct acpi_pci_ioapic {
	acpi_handle root_handle;
	acpi_handle handle;
	u32 gsi_base;
	struct resource res;
	struct pci_dev *pdev;
	struct list_head list;
};

struct acpi_pci_link_irq {
	u32 active;
	u8 triggering;
	u8 polarity;
	u8 resource_type;
	u8 possible_count;
	u32 possible[16];
	u8 initialized: 1;
	u8 reserved: 7;
};

struct acpi_pci_link {
	struct list_head list;
	struct acpi_device *device;
	struct acpi_pci_link_irq irq;
	int refcnt;
};

struct pci_bus;

struct acpi_pci_root {
	struct acpi_device *device;
	struct pci_bus *bus;
	u16 segment;
	int bridge_type;
	struct resource secondary;
	u32 osc_support_set;
	u32 osc_control_set;
	u32 osc_ext_support_set;
	u32 osc_ext_control_set;
	phys_addr_t mcfg_addr;
};

struct acpi_pci_root_ops;

struct acpi_pci_root_info {
	struct acpi_pci_root *root;
	struct acpi_device *bridge;
	struct acpi_pci_root_ops *ops;
	struct list_head resources;
	char name[16];
};

struct pci_ops;

struct acpi_pci_root_ops {
	struct pci_ops *pci_ops;
	int (*init_info)(struct acpi_pci_root_info *);
	void (*release_info)(struct acpi_pci_root_info *);
	int (*prepare_resources)(struct acpi_pci_root_info *);
};

struct acpi_pci_routing_table {
	u32 length;
	u32 pin;
	u64 address;
	u32 source_index;
	union {
		char pad[4];
		struct {
			struct {} __Empty_source;
			char source[0];
		};
	};
};

struct acpi_pct_register {
	u8 descriptor;
	u16 length;
	u8 space_id;
	u8 bit_width;
	u8 bit_offset;
	u8 reserved;
	u64 address;
} __attribute__((packed));

struct acpi_pkg_info {
	u8 *free_space;
	acpi_size length;
	u32 object_space;
	u32 num_packages;
};

struct acpi_platform_list {
	char oem_id[7];
	char oem_table_id[9];
	u32 oem_revision;
	char *table;
	enum acpi_predicate pred;
	char *reason;
	u32 data;
};

struct acpi_pld_info {
	u8 revision;
	u8 ignore_color;
	u8 red;
	u8 green;
	u8 blue;
	u16 width;
	u16 height;
	u8 user_visible;
	u8 dock;
	u8 lid;
	u8 panel;
	u8 vertical_position;
	u8 horizontal_position;
	u8 shape;
	u8 group_orientation;
	u8 group_token;
	u8 group_position;
	u8 bay;
	u8 ejectable;
	u8 ospm_eject_required;
	u8 cabinet_number;
	u8 card_cage_number;
	u8 reference;
	u8 rotation;
	u8 order;
	u8 reserved;
	u16 vertical_offset;
	u16 horizontal_offset;
};

struct acpi_port_info {
	char *name;
	u16 start;
	u16 end;
	u8 osi_dependency;
};

struct acpi_power_dependent_device {
	struct device *dev;
	struct list_head node;
};

struct acpi_power_register {
	u8 descriptor;
	u16 length;
	u8 space_id;
	u8 bit_width;
	u8 bit_offset;
	u8 access_size;
	u64 address;
} __attribute__((packed));

struct acpi_power_resource {
	struct acpi_device device;
	struct list_head list_node;
	u32 system_level;
	u32 order;
	unsigned int ref_count;
	u8 state;
	struct mutex resource_lock;
	struct list_head dependents;
};

struct acpi_power_resource_entry {
	struct list_head node;
	struct acpi_power_resource *resource;
};

union acpi_predefined_info {
	struct acpi_name_info info;
	struct acpi_package_info ret_info;
	struct acpi_package_info2 ret_info2;
	struct acpi_package_info3 ret_info3;
	struct acpi_package_info4 ret_info4;
};

struct acpi_predefined_names {
	const char *name;
	u8 type;
	char *val;
};

struct acpi_prmt_handler_info {
	u16 revision;
	u16 length;
	u8 handler_guid[16];
	u64 handler_address;
	u64 static_data_buffer_address;
	u64 acpi_param_buffer_address;
} __attribute__((packed));

struct acpi_prmt_module_header {
	u16 revision;
	u16 length;
};

struct acpi_prmt_module_info {
	u16 revision;
	u16 length;
	u8 module_guid[16];
	u16 major_rev;
	u16 minor_rev;
	u16 handler_info_count;
	u32 handler_info_offset;
	u64 mmio_list_pointer;
} __attribute__((packed));

struct acpi_probe_entry;

typedef bool (*acpi_probe_entry_validate_subtbl)(struct acpi_subtable_header *, struct acpi_probe_entry *);

struct acpi_table_header;

typedef int (*acpi_tbl_table_handler)(struct acpi_table_header *);

union acpi_subtable_headers;

typedef int (*acpi_tbl_entry_handler)(union acpi_subtable_headers *, const long unsigned int);

struct acpi_probe_entry {
	__u8 id[5];
	__u8 type;
	acpi_probe_entry_validate_subtbl subtable_valid;
	union {
		acpi_tbl_table_handler probe_table;
		acpi_tbl_entry_handler probe_subtbl;
	};
	kernel_ulong_t driver_data;
};

struct acpi_processor_flags {
	u8 power: 1;
	u8 performance: 1;
	u8 throttling: 1;
	u8 limit: 1;
	u8 bm_control: 1;
	u8 bm_check: 1;
	u8 has_cst: 1;
	u8 has_lpi: 1;
	u8 power_setup_done: 1;
	u8 bm_rld_set: 1;
	u8 previously_online: 1;
};

struct acpi_processor_cx {
	u8 valid;
	u8 type;
	u32 address;
	u8 entry_method;
	u8 index;
	u32 latency;
	u8 bm_sts_skip;
	char desc[32];
};

struct acpi_processor_power {
	int count;
	union {
		struct acpi_processor_cx states[8];
		struct acpi_lpi_state lpi_states[8];
	};
	int timer_broadcast_on_state;
};

struct acpi_tsd_package {
	u64 num_entries;
	u64 revision;
	u64 domain;
	u64 coord_type;
	u64 num_processors;
};

struct acpi_processor_tx {
	u16 power;
	u16 performance;
};

struct acpi_processor_tx_tss;

struct acpi_processor;

struct acpi_processor_throttling {
	unsigned int state;
	unsigned int platform_limit;
	struct acpi_pct_register control_register;
	struct acpi_pct_register status_register;
	unsigned int state_count;
	struct acpi_processor_tx_tss *states_tss;
	struct acpi_tsd_package domain_info;
	cpumask_var_t shared_cpu_map;
	int (*acpi_processor_get_throttling)(struct acpi_processor *);
	int (*acpi_processor_set_throttling)(struct acpi_processor *, int, bool);
	u32 address;
	u8 duty_offset;
	u8 duty_width;
	u8 tsd_valid_flag;
	unsigned int shared_type;
	struct acpi_processor_tx states[16];
};

struct acpi_processor_lx {
	int px;
	int tx;
};

struct acpi_processor_limit {
	struct acpi_processor_lx state;
	struct acpi_processor_lx thermal;
	struct acpi_processor_lx user;
};

struct plist_node {
	int prio;
	struct list_head prio_list;
	struct list_head node_list;
};

struct freq_constraints;

struct freq_qos_request {
	enum freq_qos_req_type type;
	struct plist_node pnode;
	struct freq_constraints *qos;
};

struct acpi_processor_performance;

struct acpi_processor {
	acpi_handle handle;
	u32 acpi_id;
	phys_cpuid_t phys_id;
	u32 id;
	u32 pblk;
	int performance_platform_limit;
	int throttling_platform_limit;
	struct acpi_processor_flags flags;
	struct acpi_processor_power power;
	struct acpi_processor_performance *performance;
	struct acpi_processor_throttling throttling;
	struct acpi_processor_limit limit;
	struct thermal_cooling_device *cdev;
	struct device *dev;
	struct freq_qos_request perflib_req;
	struct freq_qos_request thermal_req;
};

struct acpi_processor_errata {
	u8 smp;
	struct {
		u8 throttle: 1;
		u8 fdma: 1;
		u8 reserved: 6;
		u32 bmisx;
	} piix4;
};

struct acpi_psd_package {
	u64 num_entries;
	u64 revision;
	u64 domain;
	u64 coord_type;
	u64 num_processors;
};

struct acpi_processor_px;

struct acpi_processor_performance {
	unsigned int state;
	unsigned int platform_limit;
	struct acpi_pct_register control_register;
	struct acpi_pct_register status_register;
	unsigned int state_count;
	struct acpi_processor_px *states;
	struct acpi_psd_package domain_info;
	cpumask_var_t shared_cpu_map;
	unsigned int shared_type;
};

struct acpi_processor_px {
	u64 core_frequency;
	u64 power;
	u64 transition_latency;
	u64 bus_master_latency;
	u64 control;
	u64 status;
};

struct acpi_processor_throttling_arg {
	struct acpi_processor *pr;
	int target_state;
	bool force;
};

struct acpi_processor_tx_tss {
	u64 freqpercentage;
	u64 power;
	u64 transition_latency;
	u64 control;
	u64 status;
};

struct acpi_prt_entry {
	struct acpi_pci_id id;
	u8 pin;
	acpi_handle link;
	u32 index;
};

struct acpi_reg_walk_info {
	u32 function;
	u32 reg_run_count;
	acpi_adr_space_type space_id;
};

typedef acpi_status (*acpi_repair_function)(struct acpi_evaluate_info *, union acpi_operand_object **);

struct acpi_repair_info {
	char name[4];
	acpi_repair_function repair_function;
};

struct acpi_resource_irq {
	u8 descriptor_length;
	u8 triggering;
	u8 polarity;
	u8 shareable;
	u8 wake_capable;
	u8 interrupt_count;
	union {
		u8 interrupt;
		struct {
			struct {} __Empty_interrupts;
			u8 interrupts[0];
		};
	};
};

struct acpi_resource_dma {
	u8 type;
	u8 bus_master;
	u8 transfer;
	u8 channel_count;
	union {
		u8 channel;
		struct {
			struct {} __Empty_channels;
			u8 channels[0];
		};
	};
};

struct acpi_resource_start_dependent {
	u8 descriptor_length;
	u8 compatibility_priority;
	u8 performance_robustness;
};

struct acpi_resource_io {
	u8 io_decode;
	u8 alignment;
	u8 address_length;
	u16 minimum;
	u16 maximum;
} __attribute__((packed));

struct acpi_resource_fixed_io {
	u16 address;
	u8 address_length;
} __attribute__((packed));

struct acpi_resource_fixed_dma {
	u16 request_lines;
	u16 channels;
	u8 width;
} __attribute__((packed));

struct acpi_resource_vendor {
	u16 byte_length;
	u8 byte_data[0];
};

struct acpi_resource_vendor_typed {
	u16 byte_length;
	u8 uuid_subtype;
	u8 uuid[16];
	u8 byte_data[0];
} __attribute__((packed));

struct acpi_resource_end_tag {
	u8 checksum;
};

struct acpi_resource_memory24 {
	u8 write_protect;
	u16 minimum;
	u16 maximum;
	u16 alignment;
	u16 address_length;
} __attribute__((packed));

struct acpi_resource_memory32 {
	u8 write_protect;
	u32 minimum;
	u32 maximum;
	u32 alignment;
	u32 address_length;
} __attribute__((packed));

struct acpi_resource_fixed_memory32 {
	u8 write_protect;
	u32 address;
	u32 address_length;
} __attribute__((packed));

union acpi_resource_attribute {
	struct acpi_memory_attribute mem;
	struct acpi_io_attribute io;
	u8 type_specific;
};

struct acpi_resource_source {
	u8 index;
	u16 string_length;
	char *string_ptr;
} __attribute__((packed));

struct acpi_resource_address16 {
	u8 resource_type;
	u8 producer_consumer;
	u8 decode;
	u8 min_address_fixed;
	u8 max_address_fixed;
	union acpi_resource_attribute info;
	struct acpi_address16_attribute address;
	struct acpi_resource_source resource_source;
} __attribute__((packed));

struct acpi_resource_address32 {
	u8 resource_type;
	u8 producer_consumer;
	u8 decode;
	u8 min_address_fixed;
	u8 max_address_fixed;
	union acpi_resource_attribute info;
	struct acpi_address32_attribute address;
	struct acpi_resource_source resource_source;
} __attribute__((packed));

struct acpi_resource_address64 {
	u8 resource_type;
	u8 producer_consumer;
	u8 decode;
	u8 min_address_fixed;
	u8 max_address_fixed;
	union acpi_resource_attribute info;
	struct acpi_address64_attribute address;
	struct acpi_resource_source resource_source;
} __attribute__((packed));

struct acpi_resource_extended_address64 {
	u8 resource_type;
	u8 producer_consumer;
	u8 decode;
	u8 min_address_fixed;
	u8 max_address_fixed;
	union acpi_resource_attribute info;
	u8 revision_ID;
	struct acpi_address64_attribute address;
	u64 type_specific;
} __attribute__((packed));

struct acpi_resource_extended_irq {
	u8 producer_consumer;
	u8 triggering;
	u8 polarity;
	u8 shareable;
	u8 wake_capable;
	u8 interrupt_count;
	struct acpi_resource_source resource_source;
	union {
		u32 interrupt;
		struct {
			struct {} __Empty_interrupts;
			u32 interrupts[0];
		};
	};
} __attribute__((packed));

struct acpi_resource_generic_register {
	u8 space_id;
	u8 bit_width;
	u8 bit_offset;
	u8 access_size;
	u64 address;
} __attribute__((packed));

struct acpi_resource_gpio {
	u8 revision_id;
	u8 connection_type;
	u8 producer_consumer;
	u8 pin_config;
	u8 shareable;
	u8 wake_capable;
	u8 io_restriction;
	u8 triggering;
	u8 polarity;
	u16 drive_strength;
	u16 debounce_timeout;
	u16 pin_table_length;
	u16 vendor_length;
	struct acpi_resource_source resource_source;
	u16 *pin_table;
	u8 *vendor_data;
} __attribute__((packed));

struct acpi_resource_i2c_serialbus {
	u8 revision_id;
	u8 type;
	u8 producer_consumer;
	u8 slave_mode;
	u8 connection_sharing;
	u8 type_revision_id;
	u16 type_data_length;
	u16 vendor_length;
	struct acpi_resource_source resource_source;
	u8 *vendor_data;
	u8 access_mode;
	u16 slave_address;
	u32 connection_speed;
} __attribute__((packed));

struct acpi_resource_spi_serialbus {
	u8 revision_id;
	u8 type;
	u8 producer_consumer;
	u8 slave_mode;
	u8 connection_sharing;
	u8 type_revision_id;
	u16 type_data_length;
	u16 vendor_length;
	struct acpi_resource_source resource_source;
	u8 *vendor_data;
	u8 wire_mode;
	u8 device_polarity;
	u8 data_bit_length;
	u8 clock_phase;
	u8 clock_polarity;
	u16 device_selection;
	u32 connection_speed;
} __attribute__((packed));

struct acpi_resource_uart_serialbus {
	u8 revision_id;
	u8 type;
	u8 producer_consumer;
	u8 slave_mode;
	u8 connection_sharing;
	u8 type_revision_id;
	u16 type_data_length;
	u16 vendor_length;
	struct acpi_resource_source resource_source;
	u8 *vendor_data;
	u8 endian;
	u8 data_bits;
	u8 stop_bits;
	u8 flow_control;
	u8 parity;
	u8 lines_enabled;
	u16 rx_fifo_size;
	u16 tx_fifo_size;
	u32 default_baud_rate;
} __attribute__((packed));

struct acpi_resource_csi2_serialbus {
	u8 revision_id;
	u8 type;
	u8 producer_consumer;
	u8 slave_mode;
	u8 connection_sharing;
	u8 type_revision_id;
	u16 type_data_length;
	u16 vendor_length;
	struct acpi_resource_source resource_source;
	u8 *vendor_data;
	u8 local_port_instance;
	u8 phy_type;
} __attribute__((packed));

struct acpi_resource_common_serialbus {
	u8 revision_id;
	u8 type;
	u8 producer_consumer;
	u8 slave_mode;
	u8 connection_sharing;
	u8 type_revision_id;
	u16 type_data_length;
	u16 vendor_length;
	struct acpi_resource_source resource_source;
	u8 *vendor_data;
} __attribute__((packed));

struct acpi_resource_pin_function {
	u8 revision_id;
	u8 pin_config;
	u8 shareable;
	u16 function_number;
	u16 pin_table_length;
	u16 vendor_length;
	struct acpi_resource_source resource_source;
	u16 *pin_table;
	u8 *vendor_data;
} __attribute__((packed));

struct acpi_resource_pin_config {
	u8 revision_id;
	u8 producer_consumer;
	u8 shareable;
	u8 pin_config_type;
	u32 pin_config_value;
	u16 pin_table_length;
	u16 vendor_length;
	struct acpi_resource_source resource_source;
	u16 *pin_table;
	u8 *vendor_data;
} __attribute__((packed));

struct acpi_resource_label {
	u16 string_length;
	char *string_ptr;
} __attribute__((packed));

struct acpi_resource_pin_group {
	u8 revision_id;
	u8 producer_consumer;
	u16 pin_table_length;
	u16 vendor_length;
	u16 *pin_table;
	struct acpi_resource_label resource_label;
	u8 *vendor_data;
} __attribute__((packed));

struct acpi_resource_pin_group_function {
	u8 revision_id;
	u8 producer_consumer;
	u8 shareable;
	u16 function_number;
	u16 vendor_length;
	struct acpi_resource_source resource_source;
	struct acpi_resource_label resource_source_label;
	u8 *vendor_data;
} __attribute__((packed));

struct acpi_resource_pin_group_config {
	u8 revision_id;
	u8 producer_consumer;
	u8 shareable;
	u8 pin_config_type;
	u32 pin_config_value;
	u16 vendor_length;
	struct acpi_resource_source resource_source;
	struct acpi_resource_label resource_source_label;
	u8 *vendor_data;
} __attribute__((packed));

struct acpi_resource_clock_input {
	u8 revision_id;
	u8 mode;
	u8 scale;
	u16 frequency_divisor;
	u32 frequency_numerator;
	struct acpi_resource_source resource_source;
} __attribute__((packed));

struct acpi_resource_address {
	u8 resource_type;
	u8 producer_consumer;
	u8 decode;
	u8 min_address_fixed;
	u8 max_address_fixed;
	union acpi_resource_attribute info;
};

union acpi_resource_data {
	struct acpi_resource_irq irq;
	struct acpi_resource_dma dma;
	struct acpi_resource_start_dependent start_dpf;
	struct acpi_resource_io io;
	struct acpi_resource_fixed_io fixed_io;
	struct acpi_resource_fixed_dma fixed_dma;
	struct acpi_resource_vendor vendor;
	struct acpi_resource_vendor_typed vendor_typed;
	struct acpi_resource_end_tag end_tag;
	struct acpi_resource_memory24 memory24;
	struct acpi_resource_memory32 memory32;
	struct acpi_resource_fixed_memory32 fixed_memory32;
	struct acpi_resource_address16 address16;
	struct acpi_resource_address32 address32;
	struct acpi_resource_address64 address64;
	struct acpi_resource_extended_address64 ext_address64;
	struct acpi_resource_extended_irq extended_irq;
	struct acpi_resource_generic_register generic_reg;
	struct acpi_resource_gpio gpio;
	struct acpi_resource_i2c_serialbus i2c_serial_bus;
	struct acpi_resource_spi_serialbus spi_serial_bus;
	struct acpi_resource_uart_serialbus uart_serial_bus;
	struct acpi_resource_csi2_serialbus csi2_serial_bus;
	struct acpi_resource_common_serialbus common_serial_bus;
	struct acpi_resource_pin_function pin_function;
	struct acpi_resource_pin_config pin_config;
	struct acpi_resource_pin_group pin_group;
	struct acpi_resource_pin_group_function pin_group_function;
	struct acpi_resource_pin_group_config pin_group_config;
	struct acpi_resource_clock_input clock_input;
	struct acpi_resource_address address;
};

struct acpi_resource {
	u32 type;
	u32 length;
	union acpi_resource_data data;
};

struct acpi_rsconvert_info {
	u8 opcode;
	u8 resource_offset;
	u8 aml_offset;
	u8 value;
};

struct acpi_rw_lock {
	void *writer_mutex;
	void *reader_mutex;
	u32 num_readers;
};

struct acpi_s2idle_dev_ops {
	struct list_head list_node;
	void (*prepare)(void);
	void (*check)(void);
	void (*restore)(void);
};

struct acpi_scan_clear_dep_work {
	struct work_struct work;
	struct acpi_device *adev;
};

struct acpi_scan_handler {
	struct list_head list_node;
	const struct acpi_device_id *ids;
	bool (*match)(const char *, const struct acpi_device_id **);
	int (*attach)(struct acpi_device *, const struct acpi_device_id *);
	void (*detach)(struct acpi_device *);
	void (*post_eject)(struct acpi_device *);
	void (*bind)(struct device *);
	void (*unbind)(struct device *);
	struct acpi_hotplug_profile hotplug;
};

typedef u32 (*acpi_sci_handler)(void *);

struct acpi_sci_handler_info {
	struct acpi_sci_handler_info *next;
	acpi_sci_handler address;
	void *context;
};

struct acpi_signal_fatal_info {
	u32 type;
	u32 code;
	u32 argument;
};

typedef acpi_status (*acpi_object_converter)(struct acpi_namespace_node *, union acpi_operand_object *, union acpi_operand_object **);

struct acpi_simple_repair_info {
	char name[4];
	u32 unexpected_btypes;
	u32 package_index;
	acpi_object_converter object_converter;
};

struct acpi_srat_cpu_affinity {
	struct acpi_subtable_header header;
	u8 proximity_domain_lo;
	u8 apic_id;
	u32 flags;
	u8 local_sapic_eid;
	u8 proximity_domain_hi[3];
	u32 clock_domain;
};

struct acpi_srat_generic_affinity {
	struct acpi_subtable_header header;
	u8 reserved;
	u8 device_handle_type;
	u32 proximity_domain;
	u8 device_handle[16];
	u32 flags;
	u32 reserved1;
};

struct acpi_srat_gicc_affinity {
	struct acpi_subtable_header header;
	u32 proximity_domain;
	u32 acpi_processor_uid;
	u32 flags;
	u32 clock_domain;
} __attribute__((packed));

struct acpi_srat_mem_affinity {
	struct acpi_subtable_header header;
	u32 proximity_domain;
	u16 reserved;
	u64 base_address;
	u64 length;
	u32 reserved1;
	u32 flags;
	u64 reserved2;
} __attribute__((packed));

struct acpi_srat_rintc_affinity {
	struct acpi_subtable_header header;
	u16 reserved;
	u32 proximity_domain;
	u32 acpi_processor_uid;
	u32 flags;
	u32 clock_domain;
};

struct acpi_srat_x2apic_cpu_affinity {
	struct acpi_subtable_header header;
	u16 reserved;
	u32 proximity_domain;
	u32 apic_id;
	u32 flags;
	u32 clock_domain;
	u32 reserved2;
};

struct acpi_subtable_entry {
	union acpi_subtable_headers *hdr;
	enum acpi_subtable_type type;
};

union acpi_subtable_headers {
	struct acpi_subtable_header common;
	struct acpi_hmat_structure hmat;
	struct acpi_prmt_module_header prmt;
	struct acpi_cedt_header cedt;
	struct acpi_cdat_header cdat;
};

typedef int (*acpi_tbl_entry_handler_arg)(union acpi_subtable_headers *, void *, const long unsigned int);

struct acpi_subtable_proc {
	int id;
	acpi_tbl_entry_handler handler;
	acpi_tbl_entry_handler_arg handler_arg;
	void *arg;
	int count;
};

struct acpi_table_attr {
	struct bin_attribute attr;
	char name[4];
	int instance;
	char filename[8];
	struct list_head node;
};

struct acpi_table_header {
	char signature[4];
	u32 length;
	u8 revision;
	u8 checksum;
	char oem_id[6];
	char oem_table_id[8];
	u32 oem_revision;
	char asl_compiler_id[4];
	u32 asl_compiler_revision;
};

struct acpi_table_bert {
	struct acpi_table_header header;
	u32 region_length;
	u64 address;
};

struct acpi_table_bgrt {
	struct acpi_table_header header;
	u16 version;
	u8 status;
	u8 image_type;
	u64 image_address;
	u32 image_offset_x;
	u32 image_offset_y;
};

struct acpi_table_boot {
	struct acpi_table_header header;
	u8 cmos_index;
	u8 reserved[3];
};

struct acpi_table_ccel {
	struct acpi_table_header header;
	u8 CCtype;
	u8 Ccsub_type;
	u16 reserved;
	u64 log_area_minimum_length;
	u64 log_area_start_address;
};

struct acpi_table_cdat {
	u32 length;
	u8 revision;
	u8 checksum;
	u8 reserved[6];
	u32 sequence;
};

struct acpi_table_csrt {
	struct acpi_table_header header;
};

struct acpi_table_desc {
	acpi_physical_address address;
	struct acpi_table_header *pointer;
	u32 length;
	union acpi_name_union signature;
	acpi_owner_id owner_id;
	u8 flags;
	u16 validation_count;
};

struct acpi_table_dmar {
	struct acpi_table_header header;
	u8 width;
	u8 flags;
	u8 reserved[10];
};

struct acpi_table_ecdt {
	struct acpi_table_header header;
	struct acpi_generic_address control;
	struct acpi_generic_address data;
	u32 uid;
	u8 gpe;
	u8 id[0];
} __attribute__((packed));

struct acpi_table_facs {
	char signature[4];
	u32 length;
	u32 hardware_signature;
	u32 firmware_waking_vector;
	u32 global_lock;
	u32 flags;
	u64 xfirmware_waking_vector;
	u8 version;
	u8 reserved[3];
	u32 ospm_flags;
	u8 reserved1[24];
};

struct acpi_table_fadt {
	struct acpi_table_header header;
	u32 facs;
	u32 dsdt;
	u8 model;
	u8 preferred_profile;
	u16 sci_interrupt;
	u32 smi_command;
	u8 acpi_enable;
	u8 acpi_disable;
	u8 s4_bios_request;
	u8 pstate_control;
	u32 pm1a_event_block;
	u32 pm1b_event_block;
	u32 pm1a_control_block;
	u32 pm1b_control_block;
	u32 pm2_control_block;
	u32 pm_timer_block;
	u32 gpe0_block;
	u32 gpe1_block;
	u8 pm1_event_length;
	u8 pm1_control_length;
	u8 pm2_control_length;
	u8 pm_timer_length;
	u8 gpe0_block_length;
	u8 gpe1_block_length;
	u8 gpe1_base;
	u8 cst_control;
	u16 c2_latency;
	u16 c3_latency;
	u16 flush_size;
	u16 flush_stride;
	u8 duty_offset;
	u8 duty_width;
	u8 day_alarm;
	u8 month_alarm;
	u8 century;
	u16 boot_flags;
	u8 reserved;
	u32 flags;
	struct acpi_generic_address reset_register;
	u8 reset_value;
	u16 arm_boot_flags;
	u8 minor_revision;
	u64 Xfacs;
	u64 Xdsdt;
	struct acpi_generic_address xpm1a_event_block;
	struct acpi_generic_address xpm1b_event_block;
	struct acpi_generic_address xpm1a_control_block;
	struct acpi_generic_address xpm1b_control_block;
	struct acpi_generic_address xpm2_control_block;
	struct acpi_generic_address xpm_timer_block;
	struct acpi_generic_address xgpe0_block;
	struct acpi_generic_address xgpe1_block;
	struct acpi_generic_address sleep_control;
	struct acpi_generic_address sleep_status;
	u64 hypervisor_id;
} __attribute__((packed));

struct acpi_table_hpet {
	struct acpi_table_header header;
	u32 id;
	struct acpi_generic_address address;
	u8 sequence;
	u16 minimum_tick;
	u8 flags;
} __attribute__((packed));

struct acpi_table_list {
	struct acpi_table_desc *tables;
	u32 current_table_count;
	u32 max_table_count;
	u8 flags;
};

struct acpi_table_lpit {
	struct acpi_table_header header;
};

struct acpi_table_madt {
	struct acpi_table_header header;
	u32 address;
	u32 flags;
};

struct acpi_table_mcfg {
	struct acpi_table_header header;
	u8 reserved[8];
};

struct acpi_table_nhlt {
	struct acpi_table_header header;
	u8 endpoints_count;
} __attribute__((packed));

struct acpi_table_pcct {
	struct acpi_table_header header;
	u32 flags;
	u64 reserved;
};

struct acpi_table_rsdp {
	char signature[8];
	u8 checksum;
	char oem_id[6];
	u8 revision;
	u32 rsdt_physical_address;
	u32 length;
	u64 xsdt_physical_address;
	u8 extended_checksum;
	u8 reserved[3];
} __attribute__((packed));

struct acpi_table_slit {
	struct acpi_table_header header;
	u64 locality_count;
	u8 entry[0];
} __attribute__((packed));

struct acpi_table_spcr {
	struct acpi_table_header header;
	u8 interface_type;
	u8 reserved[3];
	struct acpi_generic_address serial_port;
	u8 interrupt_type;
	u8 pc_interrupt;
	u32 interrupt;
	u8 baud_rate;
	u8 parity;
	u8 stop_bits;
	u8 flow_control;
	u8 terminal_type;
	u8 language;
	u16 pci_device_id;
	u16 pci_vendor_id;
	u8 pci_bus;
	u8 pci_device;
	u8 pci_function;
	u32 pci_flags;
	u8 pci_segment;
	u32 uart_clk_freq;
	u32 precise_baudrate;
	u16 name_space_string_length;
	u16 name_space_string_offset;
	char name_space_string[0];
} __attribute__((packed));

struct acpi_table_srat {
	struct acpi_table_header header;
	u32 table_revision;
	u64 reserved;
};

struct acpi_table_stao {
	struct acpi_table_header header;
	u8 ignore_uart;
} __attribute__((packed));

struct acpi_thermal_trip {
	long unsigned int temp_dk;
	struct acpi_handle_list devices;
};

struct acpi_thermal_passive {
	struct acpi_thermal_trip trip;
	long unsigned int tc1;
	long unsigned int tc2;
	long unsigned int delay;
};

struct acpi_thermal_active {
	struct acpi_thermal_trip trip;
};

struct acpi_thermal_trips {
	struct acpi_thermal_passive passive;
	struct acpi_thermal_active active[10];
};

struct thermal_zone_device;

struct acpi_thermal {
	struct acpi_device *device;
	acpi_bus_id name;
	long unsigned int temp_dk;
	long unsigned int last_temp_dk;
	long unsigned int polling_frequency;
	volatile u8 zombie;
	struct acpi_thermal_trips trips;
	struct thermal_zone_device *thermal_zone;
	int kelvin_offset;
	struct work_struct thermal_check_work;
	struct mutex thermal_check_lock;
	refcount_t thermal_check_count;
};

struct acpi_vendor_uuid {
	u8 subtype;
	u8 data[16];
};

struct acpi_vendor_walk_info {
	struct acpi_vendor_uuid *uuid;
	struct acpi_buffer *buffer;
	acpi_status status;
};

struct acpi_video_brightness_flags {
	u8 _BCL_no_ac_battery_levels: 1;
	u8 _BCL_reversed: 1;
	u8 _BQC_use_index: 1;
};

struct acpi_video_bus_cap {
	u8 _DOS: 1;
	u8 _DOD: 1;
	u8 _ROM: 1;
	u8 _GPD: 1;
	u8 _SPD: 1;
	u8 _VPO: 1;
	u8 reserved: 2;
};

struct acpi_video_bus_flags {
	u8 multihead: 1;
	u8 rom: 1;
	u8 post: 1;
	u8 reserved: 5;
};

struct acpi_video_enumerated_device;

struct acpi_video_bus {
	struct acpi_device *device;
	bool backlight_registered;
	u8 dos_setting;
	struct acpi_video_enumerated_device *attached_array;
	u8 attached_count;
	u8 child_count;
	struct acpi_video_bus_cap cap;
	struct acpi_video_bus_flags flags;
	struct list_head video_device_list;
	struct mutex device_list_lock;
	struct list_head entry;
	struct input_dev *input;
	char phys[32];
	struct notifier_block pm_nb;
};

struct acpi_video_device_flags {
	u8 crt: 1;
	u8 lcd: 1;
	u8 tvout: 1;
	u8 dvi: 1;
	u8 bios: 1;
	u8 unknown: 1;
	u8 notify: 1;
	u8 reserved: 1;
};

struct acpi_video_device_cap {
	u8 _ADR: 1;
	u8 _BCL: 1;
	u8 _BCM: 1;
	u8 _BQC: 1;
	u8 _BCQ: 1;
	u8 _DDC: 1;
};

struct acpi_video_device_brightness;

struct backlight_device;

struct acpi_video_device {
	long unsigned int device_id;
	struct acpi_video_device_flags flags;
	struct acpi_video_device_cap cap;
	struct list_head entry;
	struct delayed_work switch_brightness_work;
	int switch_brightness_event;
	struct acpi_video_bus *video;
	struct acpi_device *dev;
	struct acpi_video_device_brightness *brightness;
	struct backlight_device *backlight;
	struct thermal_cooling_device *cooling_dev;
};

struct acpi_video_device_attrib {
	u32 display_index: 4;
	u32 display_port_attachment: 4;
	u32 display_type: 4;
	u32 vendor_specific: 4;
	u32 bios_can_detect: 1;
	u32 depend_on_vga: 1;
	u32 pipe_id: 3;
	u32 reserved: 10;
	u32 device_id_scheme: 1;
};

struct acpi_video_device_brightness {
	int curr;
	int count;
	int *levels;
	struct acpi_video_brightness_flags flags;
};

struct acpi_video_enumerated_device {
	union {
		u32 int_val;
		struct acpi_video_device_attrib attrib;
	} value;
	struct acpi_video_device *bind_info;
};

struct acpi_wakeup_handler {
	struct list_head list_node;
	bool (*wakeup)(void *);
	void *context;
};

typedef acpi_status (*acpi_parse_downwards)(struct acpi_walk_state *, union acpi_parse_object **);

typedef acpi_status (*acpi_parse_upwards)(struct acpi_walk_state *);

struct acpi_walk_state {
	struct acpi_walk_state *next;
	u8 descriptor_type;
	u8 walk_type;
	u16 opcode;
	u8 next_op_info;
	u8 num_operands;
	u8 operand_index;
	acpi_owner_id owner_id;
	u8 last_predicate;
	u8 current_result;
	u8 return_used;
	u8 scope_depth;
	u8 pass_number;
	u8 namespace_override;
	u8 result_size;
	u8 result_count;
	u8 *aml;
	u32 arg_types;
	u32 method_breakpoint;
	u32 user_breakpoint;
	u32 parse_flags;
	struct acpi_parse_state parser_state;
	u32 prev_arg_types;
	u32 arg_count;
	u16 method_nesting_depth;
	u8 method_is_nested;
	struct acpi_namespace_node arguments[7];
	struct acpi_namespace_node local_variables[8];
	union acpi_operand_object *operands[9];
	union acpi_operand_object **params;
	u8 *aml_last_while;
	union acpi_operand_object **caller_return_desc;
	union acpi_generic_state *control_state;
	struct acpi_namespace_node *deferred_node;
	union acpi_operand_object *implicit_return_obj;
	struct acpi_namespace_node *method_call_node;
	union acpi_parse_object *method_call_op;
	union acpi_operand_object *method_desc;
	struct acpi_namespace_node *method_node;
	char *method_pathname;
	union acpi_parse_object *op;
	const struct acpi_opcode_info *op_info;
	union acpi_parse_object *origin;
	union acpi_operand_object *result_obj;
	union acpi_generic_state *results;
	union acpi_operand_object *return_desc;
	union acpi_generic_state *scope_info;
	union acpi_parse_object *prev_op;
	union acpi_parse_object *next_op;
	struct acpi_thread_state *thread;
	acpi_parse_downwards descending_callback;
	acpi_parse_upwards ascending_callback;
};

struct acpihid_map_entry {
	struct list_head list;
	u8 uid[256];
	u8 hid[9];
	u32 devid;
	u32 root_devid;
	bool cmd_line;
	struct iommu_group *group;
};

struct pnp_dev;

struct acpipnp_parse_option_s {
	struct pnp_dev *dev;
	unsigned int option_flags;
};

struct action_cache {
	long unsigned int allow_native[8];
	long unsigned int allow_compat[8];
};

struct action_devres {
	void *data;
	void (*action)(void *);
};

struct action_gate_entry {
	u8 gate_state;
	u32 interval;
	s32 ipv;
	s32 maxoctets;
};

struct action_ops {
	int (*pre_action)(struct snd_pcm_substream *, snd_pcm_state_t);
	int (*do_action)(struct snd_pcm_substream *, snd_pcm_state_t);
	void (*undo_action)(struct snd_pcm_substream *, snd_pcm_state_t);
	void (*post_action)(struct snd_pcm_substream *, snd_pcm_state_t);
};

struct dma_fence;

struct dma_fence_cb;

typedef void (*dma_fence_func_t)(struct dma_fence *, struct dma_fence_cb *);

struct dma_fence_cb {
	struct list_head node;
	dma_fence_func_t func;
};

struct i915_active_fence {
	struct dma_fence *fence;
	struct dma_fence_cb cb;
};

struct i915_active;

struct active_node {
	struct rb_node node;
	struct i915_active_fence base;
	struct i915_active *ref;
	u64 timeline;
};

struct addr_marker {
	long unsigned int start_address;
	const char *name;
	long unsigned int max_lines;
};

struct rb_root {
	struct rb_node *rb_node;
};

struct rb_root_cached {
	struct rb_root rb_root;
	struct rb_node *rb_leftmost;
};

struct address_space_operations;

struct address_space {
	struct inode *host;
	struct xarray i_pages;
	struct rw_semaphore invalidate_lock;
	gfp_t gfp_mask;
	atomic_t i_mmap_writable;
	struct rb_root_cached i_mmap;
	long unsigned int nrpages;
	long unsigned int writeback_index;
	const struct address_space_operations *a_ops;
	long unsigned int flags;
	errseq_t wb_err;
	spinlock_t i_private_lock;
	struct list_head i_private_list;
	struct rw_semaphore i_mmap_rwsem;
	void *i_private_data;
};

struct writeback_control;

struct readahead_control;

struct kiocb;

struct iov_iter;

struct swap_info_struct;

struct address_space_operations {
	int (*writepage)(struct page *, struct writeback_control *);
	int (*read_folio)(struct file *, struct folio *);
	int (*writepages)(struct address_space *, struct writeback_control *);
	bool (*dirty_folio)(struct address_space *, struct folio *);
	void (*readahead)(struct readahead_control *);
	int (*write_begin)(struct file *, struct address_space *, loff_t, unsigned int, struct folio **, void **);
	int (*write_end)(struct file *, struct address_space *, loff_t, unsigned int, unsigned int, struct folio *, void *);
	sector_t (*bmap)(struct address_space *, sector_t);
	void (*invalidate_folio)(struct folio *, size_t, size_t);
	bool (*release_folio)(struct folio *, gfp_t);
	void (*free_folio)(struct folio *);
	ssize_t (*direct_IO)(struct kiocb *, struct iov_iter *);
	int (*migrate_folio)(struct address_space *, struct folio *, struct folio *, enum migrate_mode);
	int (*launder_folio)(struct folio *);
	bool (*is_partially_uptodate)(struct folio *, size_t, size_t);
	void (*is_dirty_writeback)(struct folio *, bool *, bool *);
	int (*error_remove_folio)(struct address_space *, struct folio *);
	int (*swap_activate)(struct swap_info_struct *, struct file *, sector_t *);
	void (*swap_deactivate)(struct file *);
	int (*swap_rw)(struct kiocb *, struct iov_iter *);
};

struct adjust_trip_data {
	struct acpi_thermal *tz;
	u32 event;
};

struct crypto_aead;

struct aead_request;

struct aead_alg {
	int (*setkey)(struct crypto_aead *, const u8 *, unsigned int);
	int (*setauthsize)(struct crypto_aead *, unsigned int);
	int (*encrypt)(struct aead_request *);
	int (*decrypt)(struct aead_request *);
	int (*init)(struct crypto_aead *);
	void (*exit)(struct crypto_aead *);
	unsigned int ivsize;
	unsigned int maxauthsize;
	unsigned int chunksize;
	struct crypto_alg base;
};

struct crypto_sync_skcipher;

struct aead_geniv_ctx {
	spinlock_t lock;
	struct crypto_aead *child;
	struct crypto_sync_skcipher *sknull;
	u8 salt[0];
};

struct crypto_template;

struct crypto_spawn;

struct crypto_instance {
	struct crypto_alg alg;
	struct crypto_template *tmpl;
	union {
		struct hlist_node list;
		struct crypto_spawn *spawns;
	};
	struct work_struct free_work;
	void *__ctx[0];
};

struct aead_instance {
	void (*free)(struct aead_instance *);
	union {
		struct {
			char head[64];
			struct crypto_instance base;
		} s;
		struct aead_alg alg;
	};
};

struct aead_request {
	struct crypto_async_request base;
	unsigned int assoclen;
	unsigned int cryptlen;
	u8 *iv;
	struct scatterlist *src;
	struct scatterlist *dst;
	void *__ctx[0];
};

struct affinity_context {
	const struct cpumask *new_mask;
	struct cpumask *user_mask;
	unsigned int flags;
};

struct component_master_ops;

struct component_match;

struct aggregate_device {
	struct list_head node;
	bool bound;
	const struct component_master_ops *ops;
	struct device *parent;
	struct component_match *match;
};

struct aggressiveness_profile2_entry {
	u8 opst_aggressiveness: 4;
	u8 elp_aggressiveness: 4;
};

struct aggressiveness_profile3_entry {
	u8 apd_aggressiveness: 4;
	u8 pixoptix_aggressiveness: 4;
};

struct aggressiveness_profile4_entry {
	u8 xpst_aggressiveness: 4;
	u8 tcon_aggressiveness: 4;
};

struct aggressiveness_profile_entry {
	u8 dpst_aggressiveness: 4;
	u8 lace_aggressiveness: 4;
};

struct agp_3_5_dev {
	struct list_head list;
	u8 capndx;
	u32 maxbw;
	struct pci_dev *dev;
};

struct agp_version;

struct agp_bridge_driver;

struct vm_operations_struct;

struct agp_bridge_data {
	const struct agp_version *version;
	const struct agp_bridge_driver *driver;
	const struct vm_operations_struct *vm_ops;
	void *previous_size;
	void *current_size;
	void *dev_private_data;
	struct pci_dev *dev;
	u32 *gatt_table;
	u32 *gatt_table_real;
	long unsigned int scratch_page;
	struct page *scratch_page_page;
	dma_addr_t scratch_page_dma;
	long unsigned int gart_bus_addr;
	long unsigned int gatt_bus_addr;
	u32 mode;
	long unsigned int *key_list;
	atomic_t current_memory_agp;
	atomic_t agp_in_use;
	int max_memory_agp;
	int aperture_size_idx;
	int capndx;
	int flags;
	char major_version;
	char minor_version;
	struct list_head list;
	u32 apbase_config;
	struct list_head mapped_list;
	spinlock_t mapped_lock;
};

struct gatt_mask;

struct agp_memory;

struct agp_bridge_driver {
	struct module *owner;
	const void *aperture_sizes;
	int num_aperture_sizes;
	enum aper_size_type size_type;
	bool cant_use_aperture;
	bool needs_scratch_page;
	const struct gatt_mask *masks;
	int (*fetch_size)(void);
	int (*configure)(void);
	void (*agp_enable)(struct agp_bridge_data *, u32);
	void (*cleanup)(void);
	void (*tlb_flush)(struct agp_memory *);
	long unsigned int (*mask_memory)(struct agp_bridge_data *, dma_addr_t, int);
	void (*cache_flush)(void);
	int (*create_gatt_table)(struct agp_bridge_data *);
	int (*free_gatt_table)(struct agp_bridge_data *);
	int (*insert_memory)(struct agp_memory *, off_t, int);
	int (*remove_memory)(struct agp_memory *, off_t, int);
	struct agp_memory * (*alloc_by_type)(size_t, int);
	void (*free_by_type)(struct agp_memory *);
	struct page * (*agp_alloc_page)(struct agp_bridge_data *);
	int (*agp_alloc_pages)(struct agp_bridge_data *, struct agp_memory *, size_t);
	void (*agp_destroy_page)(struct page *, int);
	void (*agp_destroy_pages)(struct agp_memory *);
	int (*agp_type_to_mask_type)(struct agp_bridge_data *, int);
};

struct agp_version {
	u16 major;
	u16 minor;
};

struct agp_kern_info {
	struct agp_version version;
	struct pci_dev *device;
	enum chipset_type chipset;
	long unsigned int mode;
	long unsigned int aper_base;
	size_t aper_size;
	int max_memory;
	int current_memory;
	bool cant_use_aperture;
	long unsigned int page_mask;
	const struct vm_operations_struct *vm_ops;
};

struct agp_memory {
	struct agp_memory *next;
	struct agp_memory *prev;
	struct agp_bridge_data *bridge;
	struct page **pages;
	size_t page_count;
	int key;
	int num_scratch_pages;
	off_t pg_start;
	u32 type;
	u32 physical;
	bool is_bound;
	bool is_flushed;
	struct list_head mapped_list;
	struct scatterlist *sg_list;
	int num_sg;
};

struct crypto_ahash;

struct ah_data {
	int icv_full_len;
	int icv_trunc_len;
	struct crypto_ahash *ahash;
};

struct ip_options {
	__be32 faddr;
	__be32 nexthop;
	unsigned char optlen;
	unsigned char srr;
	unsigned char rr;
	unsigned char ts;
	unsigned char is_strictroute: 1;
	unsigned char srr_is_hit: 1;
	unsigned char is_changed: 1;
	unsigned char rr_needaddr: 1;
	unsigned char ts_needtime: 1;
	unsigned char ts_needaddr: 1;
	unsigned char router_alert;
	unsigned char cipso;
	unsigned char __pad2;
	unsigned char __data[0];
};

struct inet_skb_parm {
	int iif;
	struct ip_options opt;
	u16 flags;
	u16 frag_max_size;
};

struct inet6_skb_parm {
	int iif;
	__be16 ra;
	__u16 dst0;
	__u16 srcrt;
	__u16 dst1;
	__u16 lastopt;
	__u16 nhoff;
	__u16 flags;
	__u16 frag_max_size;
	__u16 srhoff;
};

struct ip_tunnel;

struct ip6_tnl;

struct xfrm_tunnel_skb_cb {
	union {
		struct inet_skb_parm h4;
		struct inet6_skb_parm h6;
	} header;
	union {
		struct ip_tunnel *ip4;
		struct ip6_tnl *ip6;
	} tunnel;
};

struct xfrm_skb_cb {
	struct xfrm_tunnel_skb_cb header;
	union {
		struct {
			__u32 low;
			__u32 hi;
		} output;
		struct {
			__be32 low;
			__be32 hi;
		} input;
	} seq;
};

struct ah_skb_cb {
	struct xfrm_skb_cb xfrm;
	void *tmp;
};

struct hash_alg_common {
	unsigned int digestsize;
	unsigned int statesize;
	struct crypto_alg base;
};

struct ahash_request;

struct ahash_alg {
	int (*init)(struct ahash_request *);
	int (*update)(struct ahash_request *);
	int (*final)(struct ahash_request *);
	int (*finup)(struct ahash_request *);
	int (*digest)(struct ahash_request *);
	int (*export)(struct ahash_request *, void *);
	int (*import)(struct ahash_request *, const void *);
	int (*setkey)(struct crypto_ahash *, const u8 *, unsigned int);
	int (*init_tfm)(struct crypto_ahash *);
	void (*exit_tfm)(struct crypto_ahash *);
	int (*clone_tfm)(struct crypto_ahash *, struct crypto_ahash *);
	struct hash_alg_common halg;
};

struct ahash_instance {
	void (*free)(struct ahash_instance *);
	union {
		struct {
			char head[96];
			struct crypto_instance base;
		} s;
		struct ahash_alg alg;
	};
};

struct ahash_request {
	struct crypto_async_request base;
	unsigned int nbytes;
	struct scatterlist *src;
	u8 *result;
	void *priv;
	void *__ctx[0];
};

struct ahci_cmd_hdr {
	__le32 opts;
	__le32 status;
	__le32 tbl_addr;
	__le32 tbl_addr_hi;
	__le32 reserved[4];
};

struct ata_link;

struct ahci_em_priv {
	enum sw_activity blink_policy;
	struct timer_list timer;
	long unsigned int saved_activity;
	long unsigned int activity;
	long unsigned int led_state;
	struct ata_link *link;
};

struct reset_control;

struct regulator;

struct clk_bulk_data;

struct phy___3;

struct ata_port;

struct ata_host;

struct ahci_host_priv {
	unsigned int flags;
	u32 mask_port_map;
	void *mmio;
	u32 cap;
	u32 cap2;
	u32 version;
	u32 port_map;
	u32 saved_cap;
	u32 saved_cap2;
	u32 saved_port_map;
	u32 saved_port_cap[32];
	u32 em_loc;
	u32 em_buf_sz;
	u32 em_msg_type;
	u32 remapped_nvme;
	bool got_runtime_pm;
	unsigned int n_clks;
	struct clk_bulk_data *clks;
	unsigned int f_rsts;
	struct reset_control *rsts;
	struct regulator **target_pwrs;
	struct regulator *ahci_regulator;
	struct regulator *phy_regulator;
	struct phy___3 **phys;
	unsigned int nports;
	void *plat_data;
	unsigned int irq;
	void (*start_engine)(struct ata_port *);
	int (*stop_engine)(struct ata_port *);
	irqreturn_t (*irq_handler)(int, void *);
	int (*get_irq_vector)(struct ata_host *, int);
};

struct ahci_port_priv {
	struct ata_link *active_link;
	struct ahci_cmd_hdr *cmd_slot;
	dma_addr_t cmd_slot_dma;
	void *cmd_tbl;
	dma_addr_t cmd_tbl_dma;
	void *rx_fis;
	dma_addr_t rx_fis_dma;
	unsigned int ncq_saw_d2h: 1;
	unsigned int ncq_saw_dmas: 1;
	unsigned int ncq_saw_sdb: 1;
	spinlock_t lock;
	u32 intr_mask;
	bool fbs_supported;
	bool fbs_enabled;
	int fbs_last_dev;
	struct ahci_em_priv em_priv[15];
	char *irq_desc;
};

struct ahci_sg {
	__le32 addr;
	__le32 addr_hi;
	__le32 reserved;
	__le32 flags_size;
};

struct wait_page_queue;

struct kiocb {
	struct file *ki_filp;
	loff_t ki_pos;
	void (*ki_complete)(struct kiocb *, long int);
	void *private;
	int ki_flags;
	u16 ki_ioprio;
	union {
		struct wait_page_queue *ki_waitq;
		ssize_t (*dio_complete)(void *);
	};
};

struct cred;

struct fsync_iocb {
	struct file *file;
	struct work_struct work;
	bool datasync;
	struct cred *creds;
};

struct wait_queue_entry;

typedef int (*wait_queue_func_t)(struct wait_queue_entry *, unsigned int, int, void *);

struct wait_queue_entry {
	unsigned int flags;
	void *private;
	wait_queue_func_t func;
	struct list_head entry;
};

struct poll_iocb {
	struct file *file;
	struct wait_queue_head *head;
	__poll_t events;
	bool cancelled;
	bool work_scheduled;
	bool work_need_resched;
	struct wait_queue_entry wait;
	struct work_struct work;
};

typedef int kiocb_cancel_fn(struct kiocb *);

struct io_event {
	__u64 data;
	__u64 obj;
	__s64 res;
	__s64 res2;
};

struct kioctx;

struct eventfd_ctx;

struct aio_kiocb {
	union {
		struct file *ki_filp;
		struct kiocb rw;
		struct fsync_iocb fsync;
		struct poll_iocb poll;
	};
	struct kioctx *ki_ctx;
	kiocb_cancel_fn *ki_cancel;
	struct io_event ki_res;
	struct list_head ki_list;
	refcount_t ki_refcnt;
	struct eventfd_ctx *ki_eventfd;
};

struct poll_table_struct;

typedef void (*poll_queue_proc)(struct file *, wait_queue_head_t *, struct poll_table_struct *);

struct poll_table_struct {
	poll_queue_proc _qproc;
	__poll_t _key;
};

struct aio_poll_table {
	struct poll_table_struct pt;
	struct aio_kiocb *iocb;
	bool queued;
	int error;
};

struct aio_ring {
	unsigned int id;
	unsigned int nr;
	unsigned int head;
	unsigned int tail;
	unsigned int magic;
	unsigned int compat_features;
	unsigned int incompat_features;
	unsigned int header_length;
	struct io_event io_events[0];
};

struct aio_waiter {
	struct wait_queue_entry w;
	size_t min_nr;
};

struct airtime_info {
	u64 rx_airtime;
	u64 tx_airtime;
	long unsigned int last_active;
	s32 deficit;
	atomic_t aql_tx_pending;
	u32 aql_limit_low;
	u32 aql_limit_high;
};

struct akcipher_request;

struct crypto_akcipher;

struct akcipher_alg {
	int (*encrypt)(struct akcipher_request *);
	int (*decrypt)(struct akcipher_request *);
	int (*set_pub_key)(struct crypto_akcipher *, const void *, unsigned int);
	int (*set_priv_key)(struct crypto_akcipher *, const void *, unsigned int);
	unsigned int (*max_size)(struct crypto_akcipher *);
	int (*init)(struct crypto_akcipher *);
	void (*exit)(struct crypto_akcipher *);
	struct crypto_alg base;
};

struct akcipher_instance {
	void (*free)(struct akcipher_instance *);
	union {
		struct {
			char head[56];
			struct crypto_instance base;
		} s;
		struct akcipher_alg alg;
	};
};

struct akcipher_request {
	struct crypto_async_request base;
	struct scatterlist *src;
	struct scatterlist *dst;
	unsigned int src_len;
	unsigned int dst_len;
	void *__ctx[0];
};

struct alarm {
	struct timerqueue_node node;
	struct hrtimer timer;
	void (*function)(struct alarm *, ktime_t);
	enum alarmtimer_type type;
	int state;
	void *data;
};

struct timerqueue_head {
	struct rb_root_cached rb_root;
};

struct timespec64;

struct alarm_base {
	spinlock_t lock;
	struct timerqueue_head timerqueue;
	ktime_t (*get_ktime)(void);
	void (*get_timespec)(struct timespec64 *);
	clockid_t base_clockid;
};

struct alert_data {
	short unsigned int addr;
	enum i2c_alert_protocol type;
	unsigned int data;
};

struct zonelist;

struct zoneref;

struct alloc_context {
	struct zonelist *zonelist;
	nodemask_t *nodemask;
	struct zoneref *preferred_zoneref;
	int migratetype;
	enum zone_type highest_zoneidx;
	bool spread_dirty_pages;
};

struct codetag {
	unsigned int flags;
	unsigned int lineno;
	const char *modname;
	const char *function;
	const char *filename;
};

struct alloc_tag_counters;

struct alloc_tag {
	struct codetag ct;
	struct alloc_tag_counters *counters;
};

struct alloc_tag_counters {
	u64 bytes;
	u64 calls;
};

struct alps_bitmap_point {
	int start_bit;
	int num_bits;
};

struct input_mt_pos {
	s16 x;
	s16 y;
};

struct alps_fields {
	unsigned int x_map;
	unsigned int y_map;
	unsigned int fingers;
	int pressure;
	struct input_mt_pos st;
	struct input_mt_pos mt[4];
	unsigned int first_mp: 1;
	unsigned int is_mp: 1;
	unsigned int left: 1;
	unsigned int right: 1;
	unsigned int middle: 1;
	unsigned int ts_left: 1;
	unsigned int ts_right: 1;
	unsigned int ts_middle: 1;
};

struct psmouse;

struct alps_nibble_commands;

struct alps_data {
	struct psmouse *psmouse;
	struct input_dev *dev2;
	struct input_dev *dev3;
	char phys2[32];
	char phys3[32];
	struct delayed_work dev3_register_work;
	const struct alps_nibble_commands *nibble_commands;
	int addr_command;
	u16 proto_version;
	u8 byte0;
	u8 mask0;
	u8 dev_id[3];
	u8 fw_ver[3];
	int flags;
	int x_max;
	int y_max;
	int x_bits;
	int y_bits;
	unsigned int x_res;
	unsigned int y_res;
	int (*hw_init)(struct psmouse *);
	void (*process_packet)(struct psmouse *);
	int (*decode_fields)(struct alps_fields *, unsigned char *, struct psmouse *);
	void (*set_abs_params)(struct alps_data *, struct input_dev *);
	int prev_fin;
	int multi_packet;
	int second_touch;
	unsigned char multi_data[6];
	struct alps_fields f;
	u8 quirks;
	struct timer_list timer;
};

struct alps_protocol_info {
	u16 version;
	u8 byte0;
	u8 mask0;
	unsigned int flags;
};

struct alps_model_info {
	u8 signature[3];
	struct alps_protocol_info protocol_info;
};

struct alps_nibble_commands {
	int command;
	unsigned char data;
};

struct als_data_entry {
	u16 backlight_adjust;
	u16 lux;
};

struct alt_instr {
	s32 instr_offset;
	s32 repl_offset;
	union {
		struct {
			u32 cpuid: 16;
			u32 flags: 16;
		};
		u32 ft_flags;
	};
	u8 instrlen;
	u8 replacementlen;
} __attribute__((packed));

struct amd_aperf_mperf {
	u64 aperf;
	u64 mperf;
	u64 tsc;
};

struct amd_chipset_type {
	enum amd_chipset_gen gen;
	u8 rev;
};

struct amd_chipset_info {
	struct pci_dev *nb_dev;
	struct pci_dev *smbus_dev;
	int nb_type;
	struct amd_chipset_type sb_type;
	int isoc_reqs;
	int probe_count;
	bool need_pll_quirk;
};

struct amd_cpudata {
	int cpu;
	struct freq_qos_request req[2];
	u64 cppc_req_cached;
	u32 highest_perf;
	u32 nominal_perf;
	u32 lowest_nonlinear_perf;
	u32 lowest_perf;
	u32 prefcore_ranking;
	u32 min_limit_perf;
	u32 max_limit_perf;
	u32 min_limit_freq;
	u32 max_limit_freq;
	u32 max_freq;
	u32 min_freq;
	u32 nominal_freq;
	u32 lowest_nonlinear_freq;
	struct amd_aperf_mperf cur;
	struct amd_aperf_mperf prev;
	u64 freq;
	bool boost_supported;
	bool hw_prefcore;
	s16 epp_cached;
	u32 policy;
	u64 cppc_cap1_cached;
	bool suspended;
	s16 epp_default;
};

struct amd_hostbridge {
	u32 bus;
	u32 slot;
	u32 device;
};

struct iommu_flush_ops;

struct io_pgtable_cfg {
	long unsigned int quirks;
	long unsigned int pgsize_bitmap;
	unsigned int ias;
	unsigned int oas;
	bool coherent_walk;
	const struct iommu_flush_ops *tlb;
	struct device *iommu_dev;
	void * (*alloc)(void *, size_t, gfp_t);
	void (*free)(void *, void *, size_t);
	union {
		struct {
			u64 ttbr;
			struct {
				u32 ips: 3;
				u32 tg: 2;
				u32 sh: 2;
				u32 orgn: 2;
				u32 irgn: 2;
				u32 tsz: 6;
			} tcr;
			u64 mair;
		} arm_lpae_s1_cfg;
		struct {
			u64 vttbr;
			struct {
				u32 ps: 3;
				u32 tg: 2;
				u32 sh: 2;
				u32 orgn: 2;
				u32 irgn: 2;
				u32 sl: 2;
				u32 tsz: 6;
			} vtcr;
		} arm_lpae_s2_cfg;
		struct {
			u32 ttbr;
			u32 tcr;
			u32 nmrr;
			u32 prrr;
		} arm_v7s_cfg;
		struct {
			u64 transtab;
			u64 memattr;
		} arm_mali_lpae_cfg;
		struct {
			u64 ttbr[4];
			u32 n_ttbrs;
		} apple_dart_cfg;
		struct {
			int nid;
		} amd;
	};
};

struct iommu_iotlb_gather;

struct iommu_dirty_bitmap;

struct io_pgtable_ops {
	int (*map_pages)(struct io_pgtable_ops *, long unsigned int, phys_addr_t, size_t, size_t, int, gfp_t, size_t *);
	size_t (*unmap_pages)(struct io_pgtable_ops *, long unsigned int, size_t, size_t, struct iommu_iotlb_gather *);
	phys_addr_t (*iova_to_phys)(struct io_pgtable_ops *, long unsigned int);
	int (*pgtable_walk)(struct io_pgtable_ops *, long unsigned int, void *);
	int (*read_and_clear_dirty)(struct io_pgtable_ops *, long unsigned int, size_t, long unsigned int, struct iommu_dirty_bitmap *);
};

struct io_pgtable {
	enum io_pgtable_fmt fmt;
	void *cookie;
	struct io_pgtable_cfg cfg;
	struct io_pgtable_ops ops;
};

struct amd_io_pgtable {
	struct io_pgtable pgtbl;
	int mode;
	u64 *root;
	u64 *pgd;
};

struct iommu_ops;

struct iommu_device {
	struct list_head list;
	const struct iommu_ops *ops;
	struct fwnode_handle *fwnode;
	struct device *dev;
	struct iommu_group *singleton_group;
	u32 max_pasids;
};

struct amd_iommu_pci_seg;

struct iopf_queue;

struct amd_iommu {
	struct list_head list;
	int index;
	raw_spinlock_t lock;
	struct pci_dev *dev;
	struct pci_dev *root_pdev;
	u64 mmio_phys;
	u64 mmio_phys_end;
	u8 *mmio_base;
	u32 cap;
	u8 acpi_flags;
	u64 features;
	u64 features2;
	u16 devid;
	u16 cap_ptr;
	struct amd_iommu_pci_seg *pci_seg;
	u64 exclusion_start;
	u64 exclusion_length;
	u8 *cmd_buf;
	u32 cmd_buf_head;
	u32 cmd_buf_tail;
	u8 *evt_buf;
	unsigned char evt_irq_name[16];
	u8 *ppr_log;
	unsigned char ppr_irq_name[16];
	u8 *ga_log;
	unsigned char ga_irq_name[16];
	u8 *ga_log_tail;
	bool int_enabled;
	bool need_sync;
	bool irtcachedis_enabled;
	struct iommu_device iommu;
	u32 stored_addr_lo;
	u32 stored_addr_hi;
	u32 stored_l1[108];
	u32 stored_l2[131];
	u8 max_banks;
	u8 max_counters;
	u32 flags;
	volatile u64 *cmd_sem;
	atomic64_t cmd_sem_val;
	struct iopf_queue *iopf_queue;
	unsigned char iopfq_name[32];
};

struct amd_iommu_event_desc {
	struct device_attribute attr;
	const char *event;
};

struct llist_head {
	struct llist_node *first;
};

struct dev_table_entry;

struct irq_remap_table;

struct amd_iommu_pci_seg {
	struct list_head list;
	struct llist_head dev_data_list;
	u16 id;
	u16 last_bdf;
	u32 dev_table_size;
	u32 alias_table_size;
	u32 rlookup_table_size;
	struct dev_table_entry *dev_table;
	struct amd_iommu **rlookup_table;
	struct irq_remap_table **irq_lookup_table;
	struct dev_table_entry *old_dev_tbl_cpy;
	u16 *alias_table;
	struct list_head unity_map;
};

struct amd_l3_cache {
	unsigned int indices;
	u8 subcaches[4];
};

struct amd_lps0_hid_device_data {
	const bool check_off_by_one;
};

struct event_constraint {
	union {
		long unsigned int idxmsk[1];
		u64 idxmsk64;
	};
	u64 code;
	u64 cmask;
	int weight;
	int overlap;
	int flags;
	unsigned int size;
};

struct perf_event;

struct amd_nb {
	int nb_id;
	int refcnt;
	struct perf_event *owners[64];
	struct event_constraint event_constraints[64];
};

struct amd_nb_bus_dev_range {
	u8 bus;
	u8 dev_base;
	u8 dev_limit;
};

struct amd_northbridge {
	struct pci_dev *root;
	struct pci_dev *misc;
	struct pci_dev *link;
	struct amd_l3_cache l3_cache;
};

struct amd_northbridge_info {
	u16 num;
	u64 flags;
	struct amd_northbridge *nb;
};

union amd_uncore_info;

struct amd_uncore_pmu;

struct amd_uncore {
	union amd_uncore_info *info;
	struct amd_uncore_pmu *pmus;
	unsigned int num_pmus;
	bool init_done;
	void (*scan)(struct amd_uncore *, unsigned int);
	int (*init)(struct amd_uncore *, unsigned int);
	void (*move)(struct amd_uncore *, unsigned int);
	void (*free)(struct amd_uncore *, unsigned int);
};

struct amd_uncore_ctx {
	int refcnt;
	int cpu;
	struct perf_event **events;
	struct hlist_node node;
};

union amd_uncore_info {
	struct {
		u64 aux_data: 32;
		u64 num_pmcs: 8;
		u64 gid: 8;
		u64 cid: 8;
	} split;
	u64 full;
};

typedef struct cpumask cpumask_t;

struct perf_cpu_pmu_context;

struct perf_event_pmu_context;

struct kmem_cache;

struct perf_output_handle;

struct pmu {
	struct list_head entry;
	struct module *module;
	struct device *dev;
	struct device *parent;
	const struct attribute_group **attr_groups;
	const struct attribute_group **attr_update;
	const char *name;
	int type;
	int capabilities;
	unsigned int scope;
	int *pmu_disable_count;
	struct perf_cpu_pmu_context *cpu_pmu_context;
	atomic_t exclusive_cnt;
	int task_ctx_nr;
	int hrtimer_interval_ms;
	unsigned int nr_addr_filters;
	void (*pmu_enable)(struct pmu *);
	void (*pmu_disable)(struct pmu *);
	int (*event_init)(struct perf_event *);
	void (*event_mapped)(struct perf_event *, struct mm_struct *);
	void (*event_unmapped)(struct perf_event *, struct mm_struct *);
	int (*add)(struct perf_event *, int);
	void (*del)(struct perf_event *, int);
	void (*start)(struct perf_event *, int);
	void (*stop)(struct perf_event *, int);
	void (*read)(struct perf_event *);
	void (*start_txn)(struct pmu *, unsigned int);
	int (*commit_txn)(struct pmu *);
	void (*cancel_txn)(struct pmu *);
	int (*event_idx)(struct perf_event *);
	void (*sched_task)(struct perf_event_pmu_context *, bool);
	struct kmem_cache *task_ctx_cache;
	void (*swap_task_ctx)(struct perf_event_pmu_context *, struct perf_event_pmu_context *);
	void * (*setup_aux)(struct perf_event *, void **, int, bool);
	void (*free_aux)(void *);
	long int (*snapshot_aux)(struct perf_event *, struct perf_output_handle *, long unsigned int);
	int (*addr_filters_validate)(struct list_head *);
	void (*addr_filters_sync)(struct perf_event *);
	int (*aux_output_match)(struct perf_event *);
	bool (*filter)(struct pmu *, int);
	int (*check_period)(struct perf_event *, u64);
};

struct amd_uncore_pmu {
	char name[16];
	int num_counters;
	int rdpmc_base;
	u32 msr_base;
	int group;
	cpumask_t active_mask;
	struct pmu pmu;
	struct amd_uncore_ctx **ctx;
};

struct aml_resource_small_header {
	u8 descriptor_type;
};

struct aml_resource_large_header {
	u8 descriptor_type;
	u16 resource_length;
} __attribute__((packed));

struct aml_resource_irq {
	u8 descriptor_type;
	u16 irq_mask;
	u8 flags;
} __attribute__((packed));

struct aml_resource_dma {
	u8 descriptor_type;
	u8 dma_channel_mask;
	u8 flags;
};

struct aml_resource_start_dependent {
	u8 descriptor_type;
	u8 flags;
};

struct aml_resource_end_dependent {
	u8 descriptor_type;
};

struct aml_resource_io {
	u8 descriptor_type;
	u8 flags;
	u16 minimum;
	u16 maximum;
	u8 alignment;
	u8 address_length;
};

struct aml_resource_fixed_io {
	u8 descriptor_type;
	u16 address;
	u8 address_length;
} __attribute__((packed));

struct aml_resource_fixed_dma {
	u8 descriptor_type;
	u16 request_lines;
	u16 channels;
	u8 width;
} __attribute__((packed));

struct aml_resource_vendor_small {
	u8 descriptor_type;
};

struct aml_resource_end_tag {
	u8 descriptor_type;
	u8 checksum;
};

struct aml_resource_memory24 {
	u8 descriptor_type;
	u16 resource_length;
	u8 flags;
	u16 minimum;
	u16 maximum;
	u16 alignment;
	u16 address_length;
} __attribute__((packed));

struct aml_resource_generic_register {
	u8 descriptor_type;
	u16 resource_length;
	u8 address_space_id;
	u8 bit_width;
	u8 bit_offset;
	u8 access_size;
	u64 address;
} __attribute__((packed));

struct aml_resource_vendor_large {
	u8 descriptor_type;
	u16 resource_length;
} __attribute__((packed));

struct aml_resource_memory32 {
	u8 descriptor_type;
	u16 resource_length;
	u8 flags;
	u32 minimum;
	u32 maximum;
	u32 alignment;
	u32 address_length;
} __attribute__((packed));

struct aml_resource_fixed_memory32 {
	u8 descriptor_type;
	u16 resource_length;
	u8 flags;
	u32 address;
	u32 address_length;
} __attribute__((packed));

struct aml_resource_address16 {
	u8 descriptor_type;
	u16 resource_length;
	u8 resource_type;
	u8 flags;
	u8 specific_flags;
	u16 granularity;
	u16 minimum;
	u16 maximum;
	u16 translation_offset;
	u16 address_length;
} __attribute__((packed));

struct aml_resource_address32 {
	u8 descriptor_type;
	u16 resource_length;
	u8 resource_type;
	u8 flags;
	u8 specific_flags;
	u32 granularity;
	u32 minimum;
	u32 maximum;
	u32 translation_offset;
	u32 address_length;
} __attribute__((packed));

struct aml_resource_address64 {
	u8 descriptor_type;
	u16 resource_length;
	u8 resource_type;
	u8 flags;
	u8 specific_flags;
	u64 granularity;
	u64 minimum;
	u64 maximum;
	u64 translation_offset;
	u64 address_length;
} __attribute__((packed));

struct aml_resource_extended_address64 {
	u8 descriptor_type;
	u16 resource_length;
	u8 resource_type;
	u8 flags;
	u8 specific_flags;
	u8 revision_ID;
	u8 reserved;
	u64 granularity;
	u64 minimum;
	u64 maximum;
	u64 translation_offset;
	u64 address_length;
	u64 type_specific;
} __attribute__((packed));

struct aml_resource_extended_irq {
	u8 descriptor_type;
	u16 resource_length;
	u8 flags;
	u8 interrupt_count;
	union {
		u32 interrupt;
		struct {
			struct {} __Empty_interrupts;
			u32 interrupts[0];
		};
	};
} __attribute__((packed));

struct aml_resource_gpio {
	u8 descriptor_type;
	u16 resource_length;
	u8 revision_id;
	u8 connection_type;
	u16 flags;
	u16 int_flags;
	u8 pin_config;
	u16 drive_strength;
	u16 debounce_timeout;
	u16 pin_table_offset;
	u8 res_source_index;
	u16 res_source_offset;
	u16 vendor_offset;
	u16 vendor_length;
} __attribute__((packed));

struct aml_resource_i2c_serialbus {
	u8 descriptor_type;
	u16 resource_length;
	u8 revision_id;
	u8 res_source_index;
	u8 type;
	u8 flags;
	u16 type_specific_flags;
	u8 type_revision_id;
	u16 type_data_length;
	u32 connection_speed;
	u16 slave_address;
} __attribute__((packed));

struct aml_resource_spi_serialbus {
	u8 descriptor_type;
	u16 resource_length;
	u8 revision_id;
	u8 res_source_index;
	u8 type;
	u8 flags;
	u16 type_specific_flags;
	u8 type_revision_id;
	u16 type_data_length;
	u32 connection_speed;
	u8 data_bit_length;
	u8 clock_phase;
	u8 clock_polarity;
	u16 device_selection;
} __attribute__((packed));

struct aml_resource_uart_serialbus {
	u8 descriptor_type;
	u16 resource_length;
	u8 revision_id;
	u8 res_source_index;
	u8 type;
	u8 flags;
	u16 type_specific_flags;
	u8 type_revision_id;
	u16 type_data_length;
	u32 default_baud_rate;
	u16 rx_fifo_size;
	u16 tx_fifo_size;
	u8 parity;
	u8 lines_enabled;
} __attribute__((packed));

struct aml_resource_csi2_serialbus {
	u8 descriptor_type;
	u16 resource_length;
	u8 revision_id;
	u8 res_source_index;
	u8 type;
	u8 flags;
	u16 type_specific_flags;
	u8 type_revision_id;
	u16 type_data_length;
} __attribute__((packed));

struct aml_resource_common_serialbus {
	u8 descriptor_type;
	u16 resource_length;
	u8 revision_id;
	u8 res_source_index;
	u8 type;
	u8 flags;
	u16 type_specific_flags;
	u8 type_revision_id;
	u16 type_data_length;
} __attribute__((packed));

struct aml_resource_pin_function {
	u8 descriptor_type;
	u16 resource_length;
	u8 revision_id;
	u16 flags;
	u8 pin_config;
	u16 function_number;
	u16 pin_table_offset;
	u8 res_source_index;
	u16 res_source_offset;
	u16 vendor_offset;
	u16 vendor_length;
} __attribute__((packed));

struct aml_resource_pin_config {
	u8 descriptor_type;
	u16 resource_length;
	u8 revision_id;
	u16 flags;
	u8 pin_config_type;
	u32 pin_config_value;
	u16 pin_table_offset;
	u8 res_source_index;
	u16 res_source_offset;
	u16 vendor_offset;
	u16 vendor_length;
} __attribute__((packed));

struct aml_resource_pin_group {
	u8 descriptor_type;
	u16 resource_length;
	u8 revision_id;
	u16 flags;
	u16 pin_table_offset;
	u16 label_offset;
	u16 vendor_offset;
	u16 vendor_length;
} __attribute__((packed));

struct aml_resource_pin_group_function {
	u8 descriptor_type;
	u16 resource_length;
	u8 revision_id;
	u16 flags;
	u16 function_number;
	u8 res_source_index;
	u16 res_source_offset;
	u16 res_source_label_offset;
	u16 vendor_offset;
	u16 vendor_length;
} __attribute__((packed));

struct aml_resource_pin_group_config {
	u8 descriptor_type;
	u16 resource_length;
	u8 revision_id;
	u16 flags;
	u8 pin_config_type;
	u32 pin_config_value;
	u8 res_source_index;
	u16 res_source_offset;
	u16 res_source_label_offset;
	u16 vendor_offset;
	u16 vendor_length;
} __attribute__((packed));

struct aml_resource_clock_input {
	u8 descriptor_type;
	u16 resource_length;
	u8 revision_id;
	u16 flags;
	u16 frequency_divisor;
	u32 frequency_numerator;
} __attribute__((packed));

struct aml_resource_address {
	u8 descriptor_type;
	u16 resource_length;
	u8 resource_type;
	u8 flags;
	u8 specific_flags;
} __attribute__((packed));

union aml_resource {
	u8 descriptor_type;
	struct aml_resource_small_header small_header;
	struct aml_resource_large_header large_header;
	struct aml_resource_irq irq;
	struct aml_resource_dma dma;
	struct aml_resource_start_dependent start_dpf;
	struct aml_resource_end_dependent end_dpf;
	struct aml_resource_io io;
	struct aml_resource_fixed_io fixed_io;
	struct aml_resource_fixed_dma fixed_dma;
	struct aml_resource_vendor_small vendor_small;
	struct aml_resource_end_tag end_tag;
	struct aml_resource_memory24 memory24;
	struct aml_resource_generic_register generic_reg;
	struct aml_resource_vendor_large vendor_large;
	struct aml_resource_memory32 memory32;
	struct aml_resource_fixed_memory32 fixed_memory32;
	struct aml_resource_address16 address16;
	struct aml_resource_address32 address32;
	struct aml_resource_address64 address64;
	struct aml_resource_extended_address64 ext_address64;
	struct aml_resource_extended_irq extended_irq;
	struct aml_resource_gpio gpio;
	struct aml_resource_i2c_serialbus i2c_serial_bus;
	struct aml_resource_spi_serialbus spi_serial_bus;
	struct aml_resource_uart_serialbus uart_serial_bus;
	struct aml_resource_csi2_serialbus csi2_serial_bus;
	struct aml_resource_common_serialbus common_serial_bus;
	struct aml_resource_pin_function pin_function;
	struct aml_resource_pin_config pin_config;
	struct aml_resource_pin_group pin_group;
	struct aml_resource_pin_group_function pin_group_function;
	struct aml_resource_pin_group_config pin_group_config;
	struct aml_resource_clock_input clock_input;
	struct aml_resource_address address;
	u32 dword_item;
	u16 word_item;
	u8 byte_item;
};

struct analog_param_field {
	unsigned int even;
	unsigned int odd;
};

struct analog_param_range {
	unsigned int min;
	unsigned int typ;
	unsigned int max;
};

struct analog_parameters {
	unsigned int num_lines;
	unsigned int line_duration_ns;
	struct analog_param_range hact_ns;
	struct analog_param_range hfp_ns;
	struct analog_param_range hslen_ns;
	struct analog_param_range hbp_ns;
	struct analog_param_range hblk_ns;
	unsigned int bt601_hfp;
	struct analog_param_field vfp_lines;
	struct analog_param_field vslen_lines;
	struct analog_param_field vbp_lines;
};

struct kobj_uevent_env;

struct kobj_ns_type_operations;

struct class {
	const char *name;
	const struct attribute_group **class_groups;
	const struct attribute_group **dev_groups;
	int (*dev_uevent)(const struct device *, struct kobj_uevent_env *);
	char * (*devnode)(const struct device *, umode_t *);
	void (*class_release)(const struct class *);
	void (*dev_release)(struct device *);
	int (*shutdown_pre)(struct device *);
	const struct kobj_ns_type_operations *ns_type;
	const void * (*namespace)(const struct device *);
	void (*get_ownership)(const struct device *, kuid_t *, kgid_t *);
	const struct dev_pm_ops *pm;
};

struct transport_container;

struct transport_class {
	struct class class;
	int (*setup)(struct transport_container *, struct device *, struct device *);
	int (*configure)(struct transport_container *, struct device *, struct device *);
	int (*remove)(struct transport_container *, struct device *, struct device *);
};

struct klist_node;

struct klist {
	spinlock_t k_lock;
	struct list_head k_list;
	void (*get)(struct klist_node *);
	void (*put)(struct klist_node *);
};

struct attribute_container {
	struct list_head node;
	struct klist containers;
	struct class *class;
	const struct attribute_group *grp;
	struct device_attribute **attrs;
	int (*match)(struct attribute_container *, struct device *);
	long unsigned int flags;
};

struct anon_transport_class {
	struct transport_class tclass;
	struct attribute_container container;
};

struct anon_vma {
	struct anon_vma *root;
	struct rw_semaphore rwsem;
	atomic_t refcount;
	long unsigned int num_children;
	long unsigned int num_active_vmas;
	struct anon_vma *parent;
	struct rb_root_cached rb_root;
};

struct anon_vma_chain {
	struct vm_area_struct *vma;
	struct anon_vma *anon_vma;
	struct list_head same_vma;
	struct rb_node rb;
	long unsigned int rb_subtree_last;
};

struct anon_vma_name {
	struct kref kref;
	char name[0];
};

struct apd_private_data;

struct apd_device_desc {
	unsigned int fixed_clk_rate;
	struct property_entry *properties;
	int (*setup)(struct apd_private_data *);
};

struct clk;

struct apd_private_data {
	struct clk *clk;
	struct acpi_device *adev;
	const struct apd_device_desc *dev_desc;
};

struct aper_size_info_16 {
	int size;
	int num_entries;
	int page_order;
	u16 size_value;
};

struct aper_size_info_32 {
	int size;
	int num_entries;
	int page_order;
	u32 size_value;
};

struct aper_size_info_8 {
	int size;
	int num_entries;
	int page_order;
	u8 size_value;
};

struct aper_size_info_fixed {
	int size;
	int num_entries;
	int page_order;
};

struct aper_size_info_lvl2 {
	int size;
	int num_entries;
	u32 size_value;
};

struct aperfmperf {
	seqcount_t seq;
	long unsigned int last_update;
	u64 acnt;
	u64 mcnt;
	u64 aperf;
	u64 mperf;
};

struct aperture_range {
	struct device *dev;
	resource_size_t base;
	resource_size_t size;
	struct list_head lh;
	void (*detach)(struct device *);
};

struct api_context {
	struct completion done;
	int status;
};

struct apic {
	void (*eoi)(void);
	void (*native_eoi)(void);
	void (*write)(u32, u32);
	u32 (*read)(u32);
	void (*wait_icr_idle)(void);
	u32 (*safe_wait_icr_idle)(void);
	void (*send_IPI)(int, int);
	void (*send_IPI_mask)(const struct cpumask *, int);
	void (*send_IPI_mask_allbutself)(const struct cpumask *, int);
	void (*send_IPI_allbutself)(int);
	void (*send_IPI_all)(int);
	void (*send_IPI_self)(int);
	u32 disable_esr: 1;
	u32 dest_mode_logical: 1;
	u32 x2apic_set_max_apicid: 1;
	u32 nmi_to_offline_cpu: 1;
	u32 (*calc_dest_apicid)(unsigned int);
	u64 (*icr_read)(void);
	void (*icr_write)(u32, u32);
	u32 max_apic_id;
	int (*probe)(void);
	int (*acpi_madt_oem_check)(char *, char *);
	void (*init_apic_ldr)(void);
	u32 (*cpu_present_to_apicid)(int);
	u32 (*get_apic_id)(u32);
	int (*wakeup_secondary_cpu)(u32, long unsigned int);
	int (*wakeup_secondary_cpu_64)(u32, long unsigned int);
	char *name;
};

struct irq_cfg {
	unsigned int dest_apicid;
	unsigned int vector;
};

struct apic_chip_data {
	struct irq_cfg hw_irq_cfg;
	unsigned int vector;
	unsigned int prev_vector;
	unsigned int cpu;
	unsigned int prev_cpu;
	unsigned int irq;
	struct hlist_node clist;
	unsigned int move_in_progress: 1;
	unsigned int is_managed: 1;
	unsigned int can_reserve: 1;
	unsigned int has_reserved: 1;
};

union apic_ir {
	long unsigned int map[4];
	u32 regs[8];
};

struct apic_override {
	void (*eoi)(void);
	void (*native_eoi)(void);
	void (*write)(u32, u32);
	u32 (*read)(u32);
	void (*send_IPI)(int, int);
	void (*send_IPI_mask)(const struct cpumask *, int);
	void (*send_IPI_mask_allbutself)(const struct cpumask *, int);
	void (*send_IPI_allbutself)(int);
	void (*send_IPI_all)(int);
	void (*send_IPI_self)(int);
	u64 (*icr_read)(void);
	void (*icr_write)(u32, u32);
	int (*wakeup_secondary_cpu)(u32, long unsigned int);
	int (*wakeup_secondary_cpu_64)(u32, long unsigned int);
};

struct apm_bios_info {
	__u16 version;
	__u16 cseg;
	__u32 offset;
	__u16 cseg_16;
	__u16 dseg;
	__u16 flags;
	__u16 cseg_len;
	__u16 cseg_16_len;
	__u16 dseg_len;
};

struct apple_backlight_config_report {
	u8 report_id;
	u8 version;
	u16 backlight_off;
	u16 backlight_on_min;
	u16 backlight_on_max;
};

struct apple_backlight_set_report {
	u8 report_id;
	u8 version;
	u16 backlight;
	u16 rate;
};

struct apple_key_translation {
	u16 from;
	u16 to;
	u8 flags;
};

struct led_pattern;

struct led_trigger;

struct led_hw_trigger_type;

struct led_classdev {
	const char *name;
	unsigned int brightness;
	unsigned int max_brightness;
	unsigned int color;
	int flags;
	long unsigned int work_flags;
	void (*brightness_set)(struct led_classdev *, enum led_brightness);
	int (*brightness_set_blocking)(struct led_classdev *, enum led_brightness);
	enum led_brightness (*brightness_get)(struct led_classdev *);
	int (*blink_set)(struct led_classdev *, long unsigned int *, long unsigned int *);
	int (*pattern_set)(struct led_classdev *, struct led_pattern *, u32, int);
	int (*pattern_clear)(struct led_classdev *);
	struct device *dev;
	const struct attribute_group **groups;
	struct list_head node;
	const char *default_trigger;
	long unsigned int blink_delay_on;
	long unsigned int blink_delay_off;
	struct timer_list blink_timer;
	int blink_brightness;
	int new_blink_brightness;
	void (*flash_resume)(struct led_classdev *);
	struct workqueue_struct *wq;
	struct work_struct set_brightness_work;
	int delayed_set_value;
	long unsigned int delayed_delay_on;
	long unsigned int delayed_delay_off;
	struct rw_semaphore trigger_lock;
	struct led_trigger *trigger;
	struct list_head trig_list;
	void *trigger_data;
	bool activated;
	struct led_hw_trigger_type *trigger_type;
	const char *hw_control_trigger;
	int (*hw_control_is_supported)(struct led_classdev *, long unsigned int);
	int (*hw_control_set)(struct led_classdev *, long unsigned int);
	int (*hw_control_get)(struct led_classdev *, long unsigned int *);
	struct device * (*hw_control_get_device)(struct led_classdev *);
	struct mutex led_access;
};

struct hid_report;

struct apple_magic_backlight {
	struct led_classdev cdev;
	struct hid_report *brightness;
	struct hid_report *power;
};

struct apple_non_apple_keyboard {
	char *name;
};

struct hid_device;

struct apple_sc_backlight;

struct apple_sc {
	struct hid_device *hdev;
	long unsigned int quirks;
	unsigned int fn_on;
	unsigned int fn_found;
	long unsigned int pressed_numlock[12];
	struct timer_list battery_timer;
	struct apple_sc_backlight *backlight;
};

struct apple_sc_backlight {
	struct led_classdev cdev;
	struct hid_device *hdev;
};

struct workqueue_attrs;

struct pool_workqueue;

struct apply_wqattrs_ctx {
	struct workqueue_struct *wq;
	struct workqueue_attrs *attrs;
	struct list_head list;
	struct pool_workqueue *dfl_pwq;
	struct pool_workqueue *pwq_tbl[0];
};

struct arc4_ctx {
	u32 S[256];
	u32 x;
	u32 y;
};

struct arch_elf_state {};

struct arch_hw_breakpoint {
	long unsigned int address;
	long unsigned int mask;
	u8 len;
	u8 type;
};

struct arch_hybrid_cpu_scale {
	long unsigned int capacity;
	long unsigned int freq_ratio;
};

struct arch_io_reserve_memtype_wc_devres {
	resource_size_t start;
	resource_size_t size;
};

struct lbr_entry {
	u64 from;
	u64 to;
	u64 info;
};

struct arch_lbr_state {
	u64 lbr_ctl;
	u64 lbr_depth;
	u64 ler_from;
	u64 ler_to;
	u64 ler_info;
	struct lbr_entry entries[0];
};

struct arch_optimized_insn {
	kprobe_opcode_t copied_insn[4];
	kprobe_opcode_t *insn;
	size_t size;
};

struct kprobe;

struct pt_regs;

struct arch_specific_insn {
	kprobe_opcode_t *insn;
	unsigned int boostable: 1;
	unsigned char size;
	union {
		unsigned char opcode;
		struct {
			unsigned char type;
		} jcc;
		struct {
			unsigned char type;
			unsigned char asize;
		} loop;
		struct {
			unsigned char reg;
		} indirect;
	};
	s32 rel32;
	void (*emulate_op)(struct kprobe *, struct pt_regs *);
	int tp_len;
};

struct arch_tlbflush_unmap_batch {
	struct cpumask cpumask;
};

struct uprobe_xol_ops;

struct arch_uprobe {
	union {
		u8 insn[16];
		u8 ixol[16];
	};
	const struct uprobe_xol_ops *ops;
	union {
		struct {
			s32 offs;
			u8 ilen;
			u8 opc1;
		} branch;
		struct {
			u8 fixups;
			u8 ilen;
		} defparam;
		struct {
			u8 reg_offset;
			u8 ilen;
		} push;
	};
};

struct arch_uprobe_task {
	long unsigned int saved_scratch_register;
	unsigned int saved_trap_nr;
	unsigned int saved_tf;
};

struct arch_vdso_time_data {};

struct arg_dev_net_ip {
	struct net *net;
	struct in6_addr *addr;
};

struct arg_netdev_event {
	const struct net_device *dev;
	union {
		unsigned char nh_flags;
		long unsigned int event;
	};
};

struct args_askumount {
	__u32 may_umount;
};

struct args_expire {
	__u32 how;
};

struct args_fail {
	__u32 token;
	__s32 status;
};

struct args_in {
	__u32 type;
};

struct args_out {
	__u32 devid;
	__u32 magic;
};

struct args_ismountpoint {
	union {
		struct args_in in;
		struct args_out out;
	};
};

struct args_openmount {
	__u32 devid;
};

struct args_protosubver {
	__u32 sub_version;
};

struct args_protover {
	__u32 version;
};

struct args_ready {
	__u32 token;
};

struct args_requester {
	__u32 uid;
	__u32 gid;
};

struct args_setpipefd {
	__s32 pipefd;
};

struct args_timeout {
	__u64 timeout;
};

struct arphdr {
	__be16 ar_hrd;
	__be16 ar_pro;
	unsigned char ar_hln;
	unsigned char ar_pln;
	__be16 ar_op;
};

struct sockaddr {
	sa_family_t sa_family;
	union {
		char sa_data_min[14];
		struct {
			struct {} __empty_sa_data;
			char sa_data[0];
		};
	};
};

struct arpreq {
	struct sockaddr arp_pa;
	struct sockaddr arp_ha;
	int arp_flags;
	struct sockaddr arp_netmask;
	char arp_dev[16];
};

struct trace_array;

struct trace_buffer;

struct trace_array_cpu;

struct array_buffer {
	struct trace_array *tr;
	struct trace_buffer *buffer;
	struct trace_array_cpu *data;
	u64 time_start;
	int cpu;
};

typedef int (*asn1_action_t)(void *, size_t, unsigned char, const void *, size_t);

struct asn1_decoder {
	const unsigned char *machine;
	size_t machlen;
	const asn1_action_t *actions;
};

struct assoc_array_ptr;

struct assoc_array {
	struct assoc_array_ptr *root;
	long unsigned int nr_leaves_on_tree;
};

struct assoc_array_node;

struct assoc_array_delete_collapse_context {
	struct assoc_array_node *node;
	const void *skip_leaf;
	int slot;
};

struct assoc_array_ops;

struct assoc_array_edit {
	struct callback_head rcu;
	struct assoc_array *array;
	const struct assoc_array_ops *ops;
	const struct assoc_array_ops *ops_for_excised_subtree;
	struct assoc_array_ptr *leaf;
	struct assoc_array_ptr **leaf_p;
	struct assoc_array_ptr *dead_leaf;
	struct assoc_array_ptr *new_meta[3];
	struct assoc_array_ptr *excised_meta[1];
	struct assoc_array_ptr *excised_subtree;
	struct assoc_array_ptr **set_backpointers[16];
	struct assoc_array_ptr *set_backpointers_to;
	struct assoc_array_node *adjust_count_on;
	long int adjust_count_by;
	struct {
		struct assoc_array_ptr **ptr;
		struct assoc_array_ptr *to;
	} set[2];
	struct {
		u8 *p;
		u8 to;
	} set_parent_slot[1];
	u8 segment_cache[17];
};

struct assoc_array_node {
	struct assoc_array_ptr *back_pointer;
	u8 parent_slot;
	struct assoc_array_ptr *slots[16];
	long unsigned int nr_leaves_on_branch;
};

struct assoc_array_ops {
	long unsigned int (*get_key_chunk)(const void *, int);
	long unsigned int (*get_object_key_chunk)(const void *, int);
	bool (*compare_object)(const void *, const void *);
	int (*diff_objects)(const void *, const void *);
	void (*free_object)(void *);
};

struct assoc_array_shortcut {
	struct assoc_array_ptr *back_pointer;
	int parent_slot;
	int skip_to_level;
	struct assoc_array_ptr *next_node;
	long unsigned int index_key[0];
};

struct assoc_array_walk_result {
	struct {
		struct assoc_array_node *node;
		int level;
		int slot;
	} terminal_node;
	struct {
		struct assoc_array_shortcut *shortcut;
		int level;
		int sc_level;
		long unsigned int sc_segments;
		long unsigned int dissimilarity;
	} wrong_shortcut;
};

struct asym_cap_data {
	struct list_head link;
	struct callback_head rcu;
	long unsigned int capacity;
	long unsigned int cpus[0];
};

struct asymmetric_key_id {
	short unsigned int len;
	unsigned char data[0];
};

struct asymmetric_key_ids {
	void *id[3];
};

struct key_preparsed_payload;

struct asymmetric_key_parser {
	struct list_head link;
	struct module *owner;
	const char *name;
	int (*parse)(struct key_preparsed_payload *);
};

struct key;

struct seq_file;

struct kernel_pkey_params;

struct kernel_pkey_query;

struct public_key_signature;

struct asymmetric_key_subtype {
	struct module *owner;
	const char *name;
	short unsigned int name_len;
	void (*describe)(const struct key *, struct seq_file *);
	void (*destroy)(void *, void *);
	int (*query)(const struct kernel_pkey_params *, struct kernel_pkey_query *);
	int (*eds_op)(struct kernel_pkey_params *, const void *, void *);
	int (*verify_signature)(const struct key *, const struct public_key_signature *);
};

struct usb_dev_state;

struct pid;

struct urb;

struct usb_memory;

struct async {
	struct list_head asynclist;
	struct usb_dev_state *ps;
	struct pid *pid;
	const struct cred *cred;
	unsigned int signr;
	unsigned int ifnum;
	void *userbuffer;
	void *userurb;
	sigval_t userurb_sigval;
	struct urb *urb;
	struct usb_memory *usbm;
	unsigned int mem_usage;
	int status;
	u8 bulk_addr;
	u8 bulk_status;
};

struct async_domain {
	struct list_head pending;
	unsigned int registered: 1;
};

typedef void (*async_func_t)(void *, async_cookie_t);

struct async_entry {
	struct list_head domain_list;
	struct list_head global_list;
	struct work_struct work;
	async_cookie_t cookie;
	async_func_t func;
	void *data;
	struct async_domain *domain;
};

struct io_poll {
	struct file *file;
	struct wait_queue_head *head;
	__poll_t events;
	int retries;
	struct wait_queue_entry wait;
};

struct async_poll {
	struct io_poll poll;
	struct io_poll *double_poll;
};

struct async_scan_data {
	struct list_head list;
	struct Scsi_Host *shost;
	struct completion prev_finished;
};

struct ata_acpi_drive {
	u32 pio;
	u32 dma;
};

struct ata_acpi_gtf {
	u8 tf[7];
};

struct ata_acpi_gtm {
	struct ata_acpi_drive drive[2];
	u32 flags;
};

struct ata_device;

struct ata_acpi_hotplug_context {
	struct acpi_hotplug_context hp;
	union {
		struct ata_port *ap;
		struct ata_device *dev;
	} data;
};

struct ata_bmdma_prd {
	__le32 addr;
	__le32 flags_len;
};

struct ata_cdl {
	u8 desc_log_buf[512];
	u8 ncq_sense_log_buf[1024];
};

struct ata_cpr {
	u8 num;
	u8 num_storage_elements;
	u64 start_lba;
	u64 num_lbas;
};

struct ata_cpr_log {
	u8 nr_cpr;
	struct ata_cpr cpr[0];
};

struct ata_dev_quirks_entry {
	const char *model_num;
	const char *model_rev;
	unsigned int quirks;
};

struct ata_ering_entry {
	unsigned int eflags;
	unsigned int err_mask;
	u64 timestamp;
};

struct ata_ering {
	int cursor;
	struct ata_ering_entry ring[32];
};

struct scsi_device;

struct ata_device {
	struct ata_link *link;
	unsigned int devno;
	unsigned int quirks;
	long unsigned int flags;
	struct scsi_device *sdev;
	void *private_data;
	union acpi_object *gtf_cache;
	unsigned int gtf_filter;
	struct device tdev;
	u64 n_sectors;
	u64 n_native_sectors;
	unsigned int class;
	long unsigned int unpark_deadline;
	u8 pio_mode;
	u8 dma_mode;
	u8 xfer_mode;
	unsigned int xfer_shift;
	unsigned int multi_count;
	unsigned int max_sectors;
	unsigned int cdb_len;
	unsigned int pio_mask;
	unsigned int mwdma_mask;
	unsigned int udma_mask;
	u16 cylinders;
	u16 heads;
	u16 sectors;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	union {
		u16 id[256];
		u32 gscr[128];
	};
	u8 devslp_timing[8];
	u8 ncq_send_recv_cmds[20];
	u8 ncq_non_data_cmds[64];
	u32 zac_zoned_cap;
	u32 zac_zones_optimal_open;
	u32 zac_zones_optimal_nonseq;
	u32 zac_zones_max_open;
	struct ata_cpr_log *cpr_log;
	struct ata_cdl *cdl;
	int spdn_cnt;
	struct ata_ering ering;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	u8 sector_buf[512];
};

struct ata_eh_cmd_timeout_ent {
	const u8 *commands;
	const unsigned int *timeouts;
};

struct ata_eh_info {
	struct ata_device *dev;
	u32 serror;
	unsigned int err_mask;
	unsigned int action;
	unsigned int dev_action[2];
	unsigned int flags;
	unsigned int probe_mask;
	char desc[80];
	int desc_len;
};

struct ata_eh_context {
	struct ata_eh_info i;
	int tries[2];
	int cmd_timeout_idx[16];
	unsigned int classes[2];
	unsigned int did_probe_mask;
	unsigned int unloaded_mask;
	unsigned int saved_ncq_enabled;
	u8 saved_xfer_mode[2];
	long unsigned int last_reset;
};

struct ata_force_param {
	const char *name;
	u8 cbl;
	u8 spd_limit;
	unsigned int xfer_mask;
	unsigned int quirk_on;
	unsigned int quirk_off;
	u16 lflags_on;
	u16 lflags_off;
};

struct ata_force_ent {
	int port;
	int device;
	struct ata_force_param param;
};

struct ata_port_operations;

struct ata_host {
	spinlock_t lock;
	struct device *dev;
	void * const *iomap;
	unsigned int n_ports;
	unsigned int n_tags;
	void *private_data;
	struct ata_port_operations *ops;
	long unsigned int flags;
	struct kref kref;
	struct mutex eh_mutex;
	struct task_struct *eh_owner;
	struct ata_port *simplex_claimed;
	struct ata_port *ports[0];
};

struct transport_container {
	struct attribute_container ac;
	const struct attribute_group *statistics;
};

struct scsi_transport_template {
	struct transport_container host_attrs;
	struct transport_container target_attrs;
	struct transport_container device_attrs;
	int (*user_scan)(struct Scsi_Host *, uint, uint, u64);
	int device_size;
	int device_private_offset;
	int target_size;
	int target_private_offset;
	int host_size;
	unsigned int create_work_queue: 1;
	void (*eh_strategy_handler)(struct Scsi_Host *);
};

struct ata_internal {
	struct scsi_transport_template t;
	struct device_attribute private_port_attrs[3];
	struct device_attribute private_link_attrs[3];
	struct device_attribute private_dev_attrs[9];
	struct transport_container link_attr_cont;
	struct transport_container dev_attr_cont;
	struct device_attribute *link_attrs[4];
	struct device_attribute *port_attrs[4];
	struct device_attribute *dev_attrs[10];
};

struct ata_ioports {
	void *cmd_addr;
	void *data_addr;
	void *error_addr;
	void *feature_addr;
	void *nsect_addr;
	void *lbal_addr;
	void *lbam_addr;
	void *lbah_addr;
	void *device_addr;
	void *status_addr;
	void *command_addr;
	void *altstatus_addr;
	void *ctl_addr;
	void *bmdma_addr;
	void *scr_addr;
};

struct ata_link {
	struct ata_port *ap;
	int pmp;
	struct device tdev;
	unsigned int active_tag;
	u32 sactive;
	unsigned int flags;
	u32 saved_scontrol;
	unsigned int hw_sata_spd_limit;
	unsigned int sata_spd_limit;
	unsigned int sata_spd;
	enum ata_lpm_policy lpm_policy;
	struct ata_eh_info eh_info;
	struct ata_eh_context eh_context;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct ata_device device[2];
	long unsigned int last_lpm_change;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct ata_taskfile {
	long unsigned int flags;
	u8 protocol;
	u8 ctl;
	u8 hob_feature;
	u8 hob_nsect;
	u8 hob_lbal;
	u8 hob_lbam;
	u8 hob_lbah;
	union {
		u8 error;
		u8 feature;
	};
	u8 nsect;
	u8 lbal;
	u8 lbam;
	u8 lbah;
	u8 device;
	union {
		u8 status;
		u8 command;
	};
	u32 auxiliary;
};

struct scatterlist {
	long unsigned int page_link;
	unsigned int offset;
	unsigned int length;
	dma_addr_t dma_address;
	unsigned int dma_length;
	unsigned int dma_flags;
};

struct ata_queued_cmd;

typedef void (*ata_qc_cb_t)(struct ata_queued_cmd *);

struct scsi_cmnd;

struct ata_queued_cmd {
	struct ata_port *ap;
	struct ata_device *dev;
	struct scsi_cmnd *scsicmd;
	void (*scsidone)(struct scsi_cmnd *);
	struct ata_taskfile tf;
	u8 cdb[16];
	long unsigned int flags;
	unsigned int tag;
	unsigned int hw_tag;
	unsigned int n_elem;
	unsigned int orig_n_elem;
	int dma_dir;
	unsigned int sect_size;
	unsigned int nbytes;
	unsigned int extrabytes;
	unsigned int curbytes;
	struct scatterlist sgent;
	struct scatterlist *sg;
	struct scatterlist *cursg;
	unsigned int cursg_ofs;
	unsigned int err_mask;
	struct ata_taskfile result_tf;
	ata_qc_cb_t complete_fn;
	void *private_data;
	void *lldd_task;
};

struct ata_port_stats {
	long unsigned int unhandled_irq;
	long unsigned int idle_irq;
	long unsigned int rw_reqbuf;
};

struct ata_port {
	struct Scsi_Host *scsi_host;
	struct ata_port_operations *ops;
	spinlock_t *lock;
	long unsigned int flags;
	unsigned int pflags;
	unsigned int print_id;
	unsigned int port_no;
	struct ata_ioports ioaddr;
	u8 ctl;
	u8 last_ctl;
	struct ata_link *sff_pio_task_link;
	struct delayed_work sff_pio_task;
	struct ata_bmdma_prd *bmdma_prd;
	dma_addr_t bmdma_prd_dma;
	unsigned int pio_mask;
	unsigned int mwdma_mask;
	unsigned int udma_mask;
	unsigned int cbl;
	struct ata_queued_cmd qcmd[33];
	u64 qc_active;
	int nr_active_links;
	long: 64;
	long: 64;
	struct ata_link link;
	struct ata_link *slave_link;
	int nr_pmp_links;
	struct ata_link *pmp_link;
	struct ata_link *excl_link;
	struct ata_port_stats stats;
	struct ata_host *host;
	struct device *dev;
	struct device tdev;
	struct mutex scsi_scan_mutex;
	struct delayed_work hotplug_task;
	struct delayed_work scsi_rescan_task;
	unsigned int hsm_task_state;
	struct list_head eh_done_q;
	wait_queue_head_t eh_wait_q;
	int eh_tries;
	struct completion park_req_pending;
	pm_message_t pm_mesg;
	enum ata_lpm_policy target_lpm_policy;
	struct timer_list fastdrain_timer;
	unsigned int fastdrain_cnt;
	async_cookie_t cookie;
	int em_message_type;
	void *private_data;
	struct ata_acpi_gtm __acpi_init_gtm;
	long: 64;
	long: 64;
	long: 64;
};

struct ata_port_info {
	long unsigned int flags;
	long unsigned int link_flags;
	unsigned int pio_mask;
	unsigned int mwdma_mask;
	unsigned int udma_mask;
	struct ata_port_operations *port_ops;
	void *private_data;
};

typedef int (*ata_prereset_fn_t)(struct ata_link *, long unsigned int);

typedef int (*ata_reset_fn_t)(struct ata_link *, unsigned int *, long unsigned int);

typedef void (*ata_postreset_fn_t)(struct ata_link *, unsigned int *);

struct ata_port_operations {
	int (*qc_defer)(struct ata_queued_cmd *);
	int (*check_atapi_dma)(struct ata_queued_cmd *);
	enum ata_completion_errors (*qc_prep)(struct ata_queued_cmd *);
	unsigned int (*qc_issue)(struct ata_queued_cmd *);
	void (*qc_fill_rtf)(struct ata_queued_cmd *);
	void (*qc_ncq_fill_rtf)(struct ata_port *, u64);
	int (*cable_detect)(struct ata_port *);
	unsigned int (*mode_filter)(struct ata_device *, unsigned int);
	void (*set_piomode)(struct ata_port *, struct ata_device *);
	void (*set_dmamode)(struct ata_port *, struct ata_device *);
	int (*set_mode)(struct ata_link *, struct ata_device **);
	unsigned int (*read_id)(struct ata_device *, struct ata_taskfile *, __le16 *);
	void (*dev_config)(struct ata_device *);
	void (*freeze)(struct ata_port *);
	void (*thaw)(struct ata_port *);
	ata_prereset_fn_t prereset;
	ata_reset_fn_t softreset;
	ata_reset_fn_t hardreset;
	ata_postreset_fn_t postreset;
	ata_prereset_fn_t pmp_prereset;
	ata_reset_fn_t pmp_softreset;
	ata_reset_fn_t pmp_hardreset;
	ata_postreset_fn_t pmp_postreset;
	void (*error_handler)(struct ata_port *);
	void (*lost_interrupt)(struct ata_port *);
	void (*post_internal_cmd)(struct ata_queued_cmd *);
	void (*sched_eh)(struct ata_port *);
	void (*end_eh)(struct ata_port *);
	int (*scr_read)(struct ata_link *, unsigned int, u32 *);
	int (*scr_write)(struct ata_link *, unsigned int, u32);
	void (*pmp_attach)(struct ata_port *);
	void (*pmp_detach)(struct ata_port *);
	int (*set_lpm)(struct ata_link *, enum ata_lpm_policy, unsigned int);
	int (*port_suspend)(struct ata_port *, pm_message_t);
	int (*port_resume)(struct ata_port *);
	int (*port_start)(struct ata_port *);
	void (*port_stop)(struct ata_port *);
	void (*host_stop)(struct ata_host *);
	void (*sff_dev_select)(struct ata_port *, unsigned int);
	void (*sff_set_devctl)(struct ata_port *, u8);
	u8 (*sff_check_status)(struct ata_port *);
	u8 (*sff_check_altstatus)(struct ata_port *);
	void (*sff_tf_load)(struct ata_port *, const struct ata_taskfile *);
	void (*sff_tf_read)(struct ata_port *, struct ata_taskfile *);
	void (*sff_exec_command)(struct ata_port *, const struct ata_taskfile *);
	unsigned int (*sff_data_xfer)(struct ata_queued_cmd *, unsigned char *, unsigned int, int);
	void (*sff_irq_on)(struct ata_port *);
	bool (*sff_irq_check)(struct ata_port *);
	void (*sff_irq_clear)(struct ata_port *);
	void (*sff_drain_fifo)(struct ata_queued_cmd *);
	void (*bmdma_setup)(struct ata_queued_cmd *);
	void (*bmdma_start)(struct ata_queued_cmd *);
	void (*bmdma_stop)(struct ata_queued_cmd *);
	u8 (*bmdma_status)(struct ata_port *);
	ssize_t (*em_show)(struct ata_port *, char *);
	ssize_t (*em_store)(struct ata_port *, const char *, size_t);
	ssize_t (*sw_activity_show)(struct ata_device *, char *);
	ssize_t (*sw_activity_store)(struct ata_device *, enum sw_activity);
	ssize_t (*transmit_led_message)(struct ata_port *, u32, ssize_t);
	const struct ata_port_operations *inherits;
};

struct ata_show_ering_arg {
	char *buf;
	int written;
};

struct ata_timing {
	short unsigned int mode;
	short unsigned int setup;
	short unsigned int act8b;
	short unsigned int rec8b;
	short unsigned int cyc8b;
	short unsigned int active;
	short unsigned int recover;
	short unsigned int dmack_hold;
	short unsigned int cycle;
	short unsigned int udma;
};

struct ata_xfer_ent {
	int shift;
	int bits;
	u8 base;
};

struct ps2dev;

typedef enum ps2_disposition (*ps2_pre_receive_handler_t)(struct ps2dev *, u8, unsigned int);

typedef void (*ps2_receive_handler_t)(struct ps2dev *, u8);

struct serio;

struct ps2dev {
	struct serio *serio;
	struct mutex cmd_mutex;
	wait_queue_head_t wait;
	long unsigned int flags;
	u8 cmdbuf[8];
	u8 cmdcnt;
	u8 nak;
	ps2_pre_receive_handler_t pre_receive_handler;
	ps2_receive_handler_t receive_handler;
};

struct vivaldi_data {
	u32 function_row_physmap[24];
	unsigned int num_function_row_keys;
};

struct atkbd {
	struct ps2dev ps2dev;
	struct input_dev *dev;
	char name[64];
	char phys[32];
	short unsigned int id;
	short unsigned int keycode[512];
	long unsigned int force_release_mask[8];
	unsigned char set;
	bool translated;
	bool extra;
	bool write;
	bool softrepeat;
	bool softraw;
	bool scroll;
	bool enabled;
	unsigned char emul;
	bool resend;
	bool release;
	long unsigned int xl_bit;
	unsigned int last;
	long unsigned int time;
	long unsigned int err_count;
	struct delayed_work event_work;
	long unsigned int event_jiffies;
	long unsigned int event_mask;
	struct mutex mutex;
	struct vivaldi_data vdata;
};

struct atomic_notifier_head {
	spinlock_t lock;
	struct notifier_block *head;
};

struct attribute_group {
	const char *name;
	umode_t (*is_visible)(struct kobject *, struct attribute *, int);
	umode_t (*is_bin_visible)(struct kobject *, const struct bin_attribute *, int);
	size_t (*bin_size)(struct kobject *, const struct bin_attribute *, int);
	struct attribute **attrs;
	union {
		struct bin_attribute **bin_attrs;
		const struct bin_attribute * const *bin_attrs_new;
	};
};

struct aud_ts_cdclk_m_n {
	u8 m;
	u16 n;
};

struct audit_aux_data {
	struct audit_aux_data *next;
	int type;
};

struct audit_cap_data {
	kernel_cap_t permitted;
	kernel_cap_t inheritable;
	union {
		unsigned int fE;
		kernel_cap_t effective;
	};
	kernel_cap_t ambient;
	kuid_t rootid;
};

struct audit_aux_data_bprm_fcaps {
	struct audit_aux_data d;
	struct audit_cap_data fcap;
	unsigned int fcap_ver;
	struct audit_cap_data old_pcap;
	struct audit_cap_data new_pcap;
};

struct lsm_prop_selinux {
	u32 secid;
};

struct lsm_prop_smack {};

struct lsm_prop_apparmor {};

struct lsm_prop_bpf {};

struct lsm_prop {
	struct lsm_prop_selinux selinux;
	struct lsm_prop_smack smack;
	struct lsm_prop_apparmor apparmor;
	struct lsm_prop_bpf bpf;
};

struct audit_aux_data_pids {
	struct audit_aux_data d;
	pid_t target_pid[16];
	kuid_t target_auid[16];
	kuid_t target_uid[16];
	unsigned int target_sessionid[16];
	struct lsm_prop target_ref[16];
	char target_comm[256];
	int pid_count;
};

struct audit_context;

struct audit_buffer {
	struct sk_buff *skb;
	struct audit_context *ctx;
	gfp_t gfp_mask;
};

struct audit_tree;

struct audit_node {
	struct list_head list;
	struct audit_tree *owner;
	unsigned int index;
};

struct fsnotify_mark;

struct audit_chunk {
	struct list_head hash;
	long unsigned int key;
	struct fsnotify_mark *mark;
	struct list_head trees;
	int count;
	atomic_long_t refs;
	struct callback_head head;
	struct audit_node owners[0];
};

struct timespec64 {
	time64_t tv_sec;
	long int tv_nsec;
};

struct filename;

struct audit_names {
	struct list_head list;
	struct filename *name;
	int name_len;
	bool hidden;
	long unsigned int ino;
	dev_t dev;
	umode_t mode;
	kuid_t uid;
	kgid_t gid;
	dev_t rdev;
	struct lsm_prop oprop;
	struct audit_cap_data fcap;
	unsigned int fcap_ver;
	unsigned char type;
	bool should_free;
};

struct vfsmount;

struct path {
	struct vfsmount *mnt;
	struct dentry *dentry;
};

struct mq_attr {
	__kernel_long_t mq_flags;
	__kernel_long_t mq_maxmsg;
	__kernel_long_t mq_msgsize;
	__kernel_long_t mq_curmsgs;
	__kernel_long_t __reserved[4];
};

struct open_how {
	__u64 flags;
	__u64 mode;
	__u64 resolve;
};

struct audit_ntp_val {
	long long int oldval;
	long long int newval;
};

struct audit_ntp_data {
	struct audit_ntp_val vals[6];
};

struct audit_proctitle {
	int len;
	char *value;
};

struct audit_tree_refs;

struct audit_context {
	int dummy;
	enum {
		AUDIT_CTX_UNUSED = 0,
		AUDIT_CTX_SYSCALL = 1,
		AUDIT_CTX_URING = 2,
	} context;
	enum audit_state state;
	enum audit_state current_state;
	unsigned int serial;
	int major;
	int uring_op;
	struct timespec64 ctime;
	long unsigned int argv[4];
	long int return_code;
	u64 prio;
	int return_valid;
	struct audit_names preallocated_names[5];
	int name_count;
	struct list_head names_list;
	char *filterkey;
	struct path pwd;
	struct audit_aux_data *aux;
	struct audit_aux_data *aux_pids;
	struct __kernel_sockaddr_storage *sockaddr;
	size_t sockaddr_len;
	pid_t ppid;
	kuid_t uid;
	kuid_t euid;
	kuid_t suid;
	kuid_t fsuid;
	kgid_t gid;
	kgid_t egid;
	kgid_t sgid;
	kgid_t fsgid;
	long unsigned int personality;
	int arch;
	pid_t target_pid;
	kuid_t target_auid;
	kuid_t target_uid;
	unsigned int target_sessionid;
	struct lsm_prop target_ref;
	char target_comm[16];
	struct audit_tree_refs *trees;
	struct audit_tree_refs *first_trees;
	struct list_head killed_trees;
	int tree_count;
	int type;
	union {
		struct {
			int nargs;
			long int args[6];
		} socketcall;
		struct {
			kuid_t uid;
			kgid_t gid;
			umode_t mode;
			struct lsm_prop oprop;
			int has_perm;
			uid_t perm_uid;
			gid_t perm_gid;
			umode_t perm_mode;
			long unsigned int qbytes;
		} ipc;
		struct {
			mqd_t mqdes;
			struct mq_attr mqstat;
		} mq_getsetattr;
		struct {
			mqd_t mqdes;
			int sigev_signo;
		} mq_notify;
		struct {
			mqd_t mqdes;
			size_t msg_len;
			unsigned int msg_prio;
			struct timespec64 abs_timeout;
		} mq_sendrecv;
		struct {
			int oflag;
			umode_t mode;
			struct mq_attr attr;
		} mq_open;
		struct {
			pid_t pid;
			struct audit_cap_data cap;
		} capset;
		struct {
			int fd;
			int flags;
		} mmap;
		struct open_how openat2;
		struct {
			int argc;
		} execve;
		struct {
			char *name;
		} module;
		struct {
			struct audit_ntp_data ntp_data;
			struct timespec64 tk_injoffset;
		} time;
	};
	int fds[2];
	struct audit_proctitle proctitle;
};

struct audit_ctl_mutex {
	struct mutex lock;
	void *owner;
};

struct audit_field;

struct audit_watch;

struct audit_fsnotify_mark;

struct audit_krule {
	u32 pflags;
	u32 flags;
	u32 listnr;
	u32 action;
	u32 mask[64];
	u32 buflen;
	u32 field_count;
	char *filterkey;
	struct audit_field *fields;
	struct audit_field *arch_f;
	struct audit_field *inode_f;
	struct audit_watch *watch;
	struct audit_tree *tree;
	struct audit_fsnotify_mark *exe;
	struct list_head rlist;
	struct list_head list;
	u64 prio;
};

struct audit_entry {
	struct list_head list;
	struct callback_head rcu;
	struct audit_krule rule;
};

struct audit_features {
	__u32 vers;
	__u32 mask;
	__u32 features;
	__u32 lock;
};

struct audit_field {
	u32 type;
	union {
		u32 val;
		kuid_t uid;
		kgid_t gid;
		struct {
			char *lsm_str;
			void *lsm_rule;
		};
	};
	u32 op;
};

struct fsnotify_group;

struct fsnotify_mark_connector;

struct fsnotify_mark {
	__u32 mask;
	refcount_t refcnt;
	struct fsnotify_group *group;
	struct list_head g_list;
	spinlock_t lock;
	struct hlist_node obj_list;
	struct fsnotify_mark_connector *connector;
	__u32 ignore_mask;
	unsigned int flags;
};

struct audit_fsnotify_mark {
	dev_t dev;
	long unsigned int ino;
	char *path;
	struct fsnotify_mark mark;
	struct audit_krule *rule;
};

struct sock;

struct audit_net {
	struct sock *sk;
};

struct audit_netlink_list {
	__u32 portid;
	struct net *net;
	struct sk_buff_head q;
};

struct audit_nfcfgop_tab {
	enum audit_nfcfgop op;
	const char *s;
};

struct audit_parent {
	struct list_head watches;
	struct fsnotify_mark mark;
};

struct audit_reply {
	__u32 portid;
	struct net *net;
	struct sk_buff *skb;
};

struct audit_rule_data {
	__u32 flags;
	__u32 action;
	__u32 field_count;
	__u32 mask[64];
	__u32 fields[64];
	__u32 values[64];
	__u32 fieldflags[64];
	__u32 buflen;
	char buf[0];
};

struct audit_sig_info {
	uid_t uid;
	pid_t pid;
	char ctx[0];
};

struct audit_status {
	__u32 mask;
	__u32 enabled;
	__u32 failure;
	__u32 pid;
	__u32 rate_limit;
	__u32 backlog_limit;
	__u32 lost;
	__u32 backlog;
	union {
		__u32 version;
		__u32 feature_bitmap;
	};
	__u32 backlog_wait_time;
	__u32 backlog_wait_time_actual;
};

struct audit_tree {
	refcount_t count;
	int goner;
	struct audit_chunk *root;
	struct list_head chunks;
	struct list_head rules;
	struct list_head list;
	struct list_head same_root;
	struct callback_head head;
	char pathname[0];
};

struct audit_tree_mark {
	struct fsnotify_mark mark;
	struct audit_chunk *chunk;
};

struct audit_tree_refs {
	struct audit_tree_refs *next;
	struct audit_chunk *c[31];
};

struct audit_tty_status {
	__u32 enabled;
	__u32 log_passwd;
};

struct audit_watch {
	refcount_t count;
	dev_t dev;
	char *path;
	long unsigned int ino;
	struct audit_parent *parent;
	struct list_head wlist;
	struct list_head rules;
};

struct auditd_connection {
	struct pid *pid;
	u32 portid;
	struct net *net;
	struct callback_head rcu;
};

struct auth_cred {
	const struct cred *cred;
	const char *principal;
};

struct auth_ops;

struct auth_domain {
	struct kref ref;
	struct hlist_node hash;
	char *name;
	struct auth_ops *flavour;
	struct callback_head callback_head;
};

struct svc_rqst;

struct auth_ops {
	char *name;
	struct module *owner;
	int flavour;
	enum svc_auth_status (*accept)(struct svc_rqst *);
	int (*release)(struct svc_rqst *);
	void (*domain_release)(struct auth_domain *);
	enum svc_auth_status (*set_client)(struct svc_rqst *);
	rpc_authflavor_t (*pseudoflavor)(struct svc_rqst *);
};

struct crypto_spawn {
	struct list_head list;
	struct crypto_alg *alg;
	union {
		struct crypto_instance *inst;
		struct crypto_spawn *next;
	};
	const struct crypto_type *frontend;
	u32 mask;
	bool dead;
	bool registered;
};

struct crypto_ahash_spawn {
	struct crypto_spawn base;
};

struct crypto_skcipher_spawn {
	struct crypto_spawn base;
};

struct authenc_esn_instance_ctx {
	struct crypto_ahash_spawn auth;
	struct crypto_skcipher_spawn enc;
};

struct authenc_esn_request_ctx {
	struct scatterlist src[2];
	struct scatterlist dst[2];
	char tail[0];
};

struct authenc_instance_ctx {
	struct crypto_ahash_spawn auth;
	struct crypto_skcipher_spawn enc;
	unsigned int reqoff;
};

struct authenc_request_ctx {
	struct scatterlist src[2];
	struct scatterlist dst[2];
	char tail[0];
};

struct i915_active {
	atomic_t count;
	struct mutex mutex;
	spinlock_t tree_lock;
	struct active_node *cache;
	struct rb_root tree;
	struct i915_active_fence excl;
	long unsigned int flags;
	int (*active)(struct i915_active *);
	void (*retire)(struct i915_active *);
	struct work_struct work;
	struct llist_head preallocated_barriers;
};

struct auto_active {
	struct i915_active base;
	struct kref ref;
};

struct auto_out_pin {
	hda_nid_t pin;
	short int seq;
};

struct auto_pin_cfg_item {
	hda_nid_t pin;
	int type;
	unsigned int is_headset_mic: 1;
	unsigned int is_headphone_mic: 1;
	unsigned int has_boost_on_pin: 1;
	int order;
};

struct auto_pin_cfg {
	int line_outs;
	hda_nid_t line_out_pins[5];
	int speaker_outs;
	hda_nid_t speaker_pins[5];
	int hp_outs;
	int line_out_type;
	hda_nid_t hp_pins[5];
	int num_inputs;
	struct auto_pin_cfg_item inputs[18];
	int dig_outs;
	hda_nid_t dig_out_pins[2];
	hda_nid_t dig_in_pin;
	hda_nid_t mono_out_pin;
	int dig_out_type[2];
	int dig_in_type;
};

struct autofs_dev_ioctl {
	__u32 ver_major;
	__u32 ver_minor;
	__u32 size;
	__s32 ioctlfd;
	union {
		struct args_protover protover;
		struct args_protosubver protosubver;
		struct args_openmount openmount;
		struct args_ready ready;
		struct args_fail fail;
		struct args_setpipefd setpipefd;
		struct args_timeout timeout;
		struct args_requester requester;
		struct args_expire expire;
		struct args_askumount askumount;
		struct args_ismountpoint ismountpoint;
	};
	char path[0];
};

struct autofs_fs_context {
	kuid_t uid;
	kgid_t gid;
	int pgrp;
	bool pgrp_set;
};

struct autofs_sb_info;

struct autofs_info {
	struct dentry *dentry;
	int flags;
	struct completion expire_complete;
	struct list_head active;
	struct list_head expiring;
	struct autofs_sb_info *sbi;
	long unsigned int exp_timeout;
	long unsigned int last_used;
	int count;
	kuid_t uid;
	kgid_t gid;
	struct callback_head rcu;
};

struct autofs_packet_hdr {
	int proto_version;
	int type;
};

struct autofs_packet_expire {
	struct autofs_packet_hdr hdr;
	int len;
	char name[256];
};

struct autofs_packet_expire_multi {
	struct autofs_packet_hdr hdr;
	autofs_wqt_t wait_queue_token;
	int len;
	char name[256];
};

struct autofs_packet_missing {
	struct autofs_packet_hdr hdr;
	autofs_wqt_t wait_queue_token;
	int len;
	char name[256];
};

union autofs_packet_union {
	struct autofs_packet_hdr hdr;
	struct autofs_packet_missing missing;
	struct autofs_packet_expire expire;
	struct autofs_packet_expire_multi expire_multi;
};

struct super_block;

struct autofs_wait_queue;

struct autofs_sb_info {
	u32 magic;
	int pipefd;
	struct file *pipe;
	struct pid *oz_pgrp;
	int version;
	int sub_version;
	int min_proto;
	int max_proto;
	unsigned int flags;
	long unsigned int exp_timeout;
	unsigned int type;
	struct super_block *sb;
	struct mutex wq_mutex;
	struct mutex pipe_mutex;
	spinlock_t fs_lock;
	struct autofs_wait_queue *queues;
	spinlock_t lookup_lock;
	struct list_head active_list;
	struct list_head expiring_list;
	struct callback_head rcu;
};

struct autofs_v5_packet {
	struct autofs_packet_hdr hdr;
	autofs_wqt_t wait_queue_token;
	__u32 dev;
	__u64 ino;
	__u32 uid;
	__u32 gid;
	__u32 pid;
	__u32 tgid;
	__u32 len;
	char name[256];
};

typedef struct autofs_v5_packet autofs_packet_expire_direct_t;

typedef struct autofs_v5_packet autofs_packet_expire_indirect_t;

typedef struct autofs_v5_packet autofs_packet_missing_direct_t;

typedef struct autofs_v5_packet autofs_packet_missing_indirect_t;

union autofs_v5_packet_union {
	struct autofs_packet_hdr hdr;
	struct autofs_v5_packet v5_packet;
	autofs_packet_missing_indirect_t missing_indirect;
	autofs_packet_expire_indirect_t expire_indirect;
	autofs_packet_missing_direct_t missing_direct;
	autofs_packet_expire_direct_t expire_direct;
};

struct qstr {
	union {
		struct {
			u32 hash;
			u32 len;
		};
		u64 hash_len;
	};
	const unsigned char *name;
};

struct autofs_wait_queue {
	wait_queue_head_t queue;
	struct autofs_wait_queue *next;
	autofs_wqt_t wait_queue_token;
	struct qstr name;
	u32 offset;
	u32 dev;
	u64 ino;
	kuid_t uid;
	kgid_t gid;
	pid_t pid;
	pid_t tgid;
	int status;
	unsigned int wait_ctr;
};

struct auxiliary_device {
	struct device dev;
	const char *name;
	u32 id;
	struct {
		struct xarray irqs;
		struct mutex lock;
		bool irq_dir_exists;
	} sysfs;
};

struct auxiliary_device_id {
	char name[32];
	kernel_ulong_t driver_data;
};

struct auxiliary_driver {
	int (*probe)(struct auxiliary_device *, const struct auxiliary_device_id *);
	void (*remove)(struct auxiliary_device *);
	void (*shutdown)(struct auxiliary_device *);
	int (*suspend)(struct auxiliary_device *, pm_message_t);
	int (*resume)(struct auxiliary_device *);
	const char *name;
	struct device_driver driver;
	const struct auxiliary_device_id *id_table;
};

struct auxiliary_irq_info {
	struct device_attribute sysfs_attr;
	char name[11];
};

struct av_decision {
	u32 allowed;
	u32 auditallow;
	u32 auditdeny;
	u32 seqno;
	u32 flags;
};

struct hlist_head {
	struct hlist_node *first;
};

struct avc_cache {
	struct hlist_head slots[512];
	spinlock_t slots_lock[512];
	atomic_t lru_hint;
	atomic_t active_nodes;
	u32 latest_notif;
};

struct avc_cache_stats {
	unsigned int lookups;
	unsigned int misses;
	unsigned int allocations;
	unsigned int reclaims;
	unsigned int frees;
};

struct avc_callback_node {
	int (*callback)(u32);
	u32 events;
	struct avc_callback_node *next;
};

struct avc_xperms_node;

struct avc_entry {
	u32 ssid;
	u32 tsid;
	u16 tclass;
	struct av_decision avd;
	struct avc_xperms_node *xp_node;
};

struct avc_node {
	struct avc_entry ae;
	struct hlist_node list;
	struct callback_head rhead;
};

struct extended_perms_data;

struct extended_perms_decision {
	u8 used;
	u8 driver;
	u8 base_perm;
	struct extended_perms_data *allowed;
	struct extended_perms_data *auditallow;
	struct extended_perms_data *dontaudit;
};

struct avc_xperms_decision_node {
	struct extended_perms_decision xpd;
	struct list_head xpd_list;
};

struct extended_perms_data {
	u32 p[8];
};

struct extended_perms {
	u16 len;
	u8 base_perms;
	struct extended_perms_data drivers;
};

struct avc_xperms_node {
	struct extended_perms xp;
	struct list_head xpd_head;
};

struct avtab_node;

struct avtab {
	struct avtab_node **htable;
	u32 nel;
	u32 nslot;
	u32 mask;
};

struct avtab_extended_perms;

struct avtab_datum {
	union {
		u32 data;
		struct avtab_extended_perms *xperms;
	} u;
};

struct avtab_extended_perms {
	u8 specified;
	u8 driver;
	struct extended_perms_data perms;
};

struct avtab_key {
	u16 source_type;
	u16 target_type;
	u16 target_class;
	u16 specified;
};

struct avtab_node {
	struct avtab_key key;
	struct avtab_datum datum;
	struct avtab_node *next;
};

struct hdac_rb {
	__le32 *buf;
	dma_addr_t addr;
	short unsigned int rp;
	short unsigned int wp;
	int cmds[8];
	u32 res[8];
};

struct snd_dma_device {
	int type;
	enum dma_data_direction dir;
	bool need_sync;
	struct device *dev;
};

struct snd_dma_buffer {
	struct snd_dma_device dev;
	unsigned char *area;
	dma_addr_t addr;
	size_t bytes;
	void *private_data;
};

struct hdac_bus_ops;

struct hdac_ext_bus_ops;

struct hdac_device;

struct drm_audio_component;

struct hdac_bus {
	struct device *dev;
	const struct hdac_bus_ops *ops;
	const struct hdac_ext_bus_ops *ext_ops;
	long unsigned int addr;
	void *remap_addr;
	int irq;
	void *ppcap;
	void *spbcap;
	void *mlcap;
	void *gtscap;
	void *drsmcap;
	struct list_head codec_list;
	unsigned int num_codecs;
	struct hdac_device *caddr_tbl[16];
	u32 unsol_queue[128];
	unsigned int unsol_rp;
	unsigned int unsol_wp;
	struct work_struct unsol_work;
	long unsigned int codec_mask;
	long unsigned int codec_powered;
	struct hdac_rb corb;
	struct hdac_rb rirb;
	unsigned int last_cmd[8];
	wait_queue_head_t rirb_wq;
	struct snd_dma_buffer rb;
	struct snd_dma_buffer posbuf;
	int dma_type;
	struct list_head stream_list;
	bool chip_init: 1;
	bool aligned_mmio: 1;
	bool sync_write: 1;
	bool use_posbuf: 1;
	bool snoop: 1;
	bool align_bdle_4k: 1;
	bool reverse_assign: 1;
	bool corbrp_self_clear: 1;
	bool polling_mode: 1;
	bool needs_damn_long_delay: 1;
	bool not_use_interrupts: 1;
	bool access_sdnctl_in_dword: 1;
	bool use_pio_for_commands: 1;
	int poll_count;
	int bdl_pos_adj;
	unsigned int dma_stop_delay;
	spinlock_t reg_lock;
	struct mutex cmd_mutex;
	struct mutex lock;
	struct drm_audio_component *audio_component;
	long int display_power_status;
	long unsigned int display_power_active;
	int num_streams;
	int idx;
	struct list_head hlink_list;
	bool cmd_dma_state;
	unsigned int sdo_limit;
};

struct snd_card;

struct hda_bus {
	struct hdac_bus core;
	struct snd_card *card;
	struct pci_dev *pci;
	const char *modelname;
	struct mutex prepare_mutex;
	long unsigned int pcm_dev_bits[1];
	unsigned int allow_bus_reset: 1;
	unsigned int shutdown: 1;
	unsigned int response_reset: 1;
	unsigned int in_reset: 1;
	unsigned int no_response_fallback: 1;
	unsigned int bus_probing: 1;
	unsigned int keep_power: 1;
	unsigned int jackpoll_in_suspend: 1;
	int primary_dig_out_type;
	unsigned int mixer_assigned;
};

struct azx;

struct azx_dev;

typedef unsigned int (*azx_get_pos_callback_t)(struct azx *, struct azx_dev *);

typedef int (*azx_get_delay_callback_t)(struct azx *, struct azx_dev *, unsigned int);

struct hda_controller_ops;

struct azx {
	struct hda_bus bus;
	struct snd_card *card;
	struct pci_dev *pci;
	int dev_index;
	int driver_type;
	unsigned int driver_caps;
	int playback_streams;
	int playback_index_offset;
	int capture_streams;
	int capture_index_offset;
	int num_streams;
	int jackpoll_interval;
	const struct hda_controller_ops *ops;
	azx_get_pos_callback_t get_position[2];
	azx_get_delay_callback_t get_delay[2];
	struct mutex open_mutex;
	struct list_head pcm_list;
	int codec_probe_mask;
	unsigned int beep_mode;
	bool ctl_dev_id;
	int bdl_pos_adj;
	unsigned int running: 1;
	unsigned int fallback_to_single_cmd: 1;
	unsigned int single_cmd: 1;
	unsigned int msi: 1;
	unsigned int probing: 1;
	unsigned int snoop: 1;
	unsigned int uc_buffer: 1;
	unsigned int align_buffer_size: 1;
	unsigned int disabled: 1;
	unsigned int pm_prepared: 1;
	unsigned int gts_present: 1;
};

struct cyclecounter;

struct timecounter {
	const struct cyclecounter *cc;
	u64 cycle_last;
	u64 nsec;
	u64 mask;
	u64 frac;
};

struct cyclecounter {
	u64 (*read)(const struct cyclecounter *);
	u64 mask;
	u32 mult;
	u32 shift;
};

struct snd_compr_stream;

struct hdac_stream {
	struct hdac_bus *bus;
	struct snd_dma_buffer bdl;
	__le32 *posbuf;
	int direction;
	unsigned int bufsize;
	unsigned int period_bytes;
	unsigned int frags;
	unsigned int fifo_size;
	void *sd_addr;
	void *spib_addr;
	void *fifo_addr;
	void *dpibr_addr;
	u32 dpib;
	u32 lpib;
	u32 sd_int_sta_mask;
	struct snd_pcm_substream *substream;
	struct snd_compr_stream *cstream;
	unsigned int format_val;
	unsigned char stream_tag;
	unsigned char index;
	int assigned_key;
	bool opened: 1;
	bool running: 1;
	bool prepared: 1;
	bool no_period_wakeup: 1;
	bool locked: 1;
	bool stripe: 1;
	u64 curr_pos;
	long unsigned int start_wallclk;
	long unsigned int period_wallclk;
	struct timecounter tc;
	struct cyclecounter cc;
	int delay_negative_threshold;
	struct list_head list;
};

struct azx_dev {
	struct hdac_stream core;
	unsigned int irq_pending: 1;
	unsigned int insufficient: 1;
};

struct snd_pcm;

struct hda_codec;

struct hda_pcm;

struct azx_pcm {
	struct azx *chip;
	struct snd_pcm *pcm;
	struct hda_codec *codec;
	struct hda_pcm *info;
	struct list_head list;
};

struct percpu_counter {
	raw_spinlock_t lock;
	s64 count;
	struct list_head list;
	s32 *counters;
};

struct fprop_local_percpu {
	struct percpu_counter events;
	unsigned int period;
	raw_spinlock_t lock;
};

struct backing_dev_info;

struct bdi_writeback {
	struct backing_dev_info *bdi;
	long unsigned int state;
	long unsigned int last_old_flush;
	struct list_head b_dirty;
	struct list_head b_io;
	struct list_head b_more_io;
	struct list_head b_dirty_time;
	spinlock_t list_lock;
	atomic_t writeback_inodes;
	struct percpu_counter stat[4];
	long unsigned int bw_time_stamp;
	long unsigned int dirtied_stamp;
	long unsigned int written_stamp;
	long unsigned int write_bandwidth;
	long unsigned int avg_write_bandwidth;
	long unsigned int dirty_ratelimit;
	long unsigned int balanced_dirty_ratelimit;
	struct fprop_local_percpu completions;
	int dirty_exceeded;
	enum wb_reason start_all_reason;
	spinlock_t work_lock;
	struct list_head work_list;
	struct delayed_work dwork;
	struct delayed_work bw_dwork;
	struct list_head bdi_node;
};

struct backing_dev_info {
	u64 id;
	struct rb_node rb_node;
	struct list_head bdi_list;
	long unsigned int ra_pages;
	long unsigned int io_pages;
	struct kref refcnt;
	unsigned int capabilities;
	unsigned int min_ratio;
	unsigned int max_ratio;
	unsigned int max_prop_frac;
	atomic_long_t tot_write_bandwidth;
	long unsigned int last_bdp_sleep;
	struct bdi_writeback wb;
	struct list_head wb_list;
	wait_queue_head_t wb_waitq;
	struct device *dev;
	char dev_name[64];
	struct device *owner;
	struct timer_list laptop_mode_wb_timer;
	struct dentry *debug_dir;
};

struct file_ra_state {
	long unsigned int start;
	unsigned int size;
	unsigned int async_size;
	unsigned int ra_pages;
	unsigned int mmap_miss;
	loff_t prev_pos;
};

struct file_operations;

struct fown_struct;

struct file {
	file_ref_t f_ref;
	spinlock_t f_lock;
	fmode_t f_mode;
	const struct file_operations *f_op;
	struct address_space *f_mapping;
	void *private_data;
	struct inode *f_inode;
	unsigned int f_flags;
	unsigned int f_iocb_flags;
	const struct cred *f_cred;
	struct path f_path;
	union {
		struct mutex f_pos_lock;
		u64 f_pipe;
	};
	loff_t f_pos;
	void *f_security;
	struct fown_struct *f_owner;
	errseq_t f_wb_err;
	errseq_t f_sb_err;
	struct hlist_head *f_ep;
	union {
		struct callback_head f_task_work;
		struct llist_node f_llist;
		struct file_ra_state f_ra;
		freeptr_t f_freeptr;
	};
};

struct backing_file {
	struct file file;
	union {
		struct path user_path;
		freeptr_t bf_freeptr;
	};
};

struct backlight_properties {
	int brightness;
	int max_brightness;
	int power;
	enum backlight_type type;
	unsigned int state;
	enum backlight_scale scale;
};

struct backlight_ops;

struct backlight_device {
	struct backlight_properties props;
	struct mutex update_lock;
	struct mutex ops_lock;
	const struct backlight_ops *ops;
	struct notifier_block fb_notif;
	struct list_head entry;
	struct device dev;
	bool fb_bl_on[32];
	int use_count;
};

struct backlight_ops {
	unsigned int options;
	int (*update_status)(struct backlight_device *);
	int (*get_brightness)(struct backlight_device *);
	bool (*controls_device)(struct backlight_device *, struct device *);
};

struct bpf_verifier_env;

struct backtrack_state {
	struct bpf_verifier_env *env;
	u32 frame;
	u32 reg_masks[8];
	u64 stack_masks[8];
};

struct badblocks {
	struct device *dev;
	int count;
	int unacked_exist;
	int shift;
	u64 *page;
	int changed;
	seqlock_t lock;
	sector_t sector;
	sector_t size;
};

struct badblocks_context {
	sector_t start;
	sector_t len;
	int ack;
};

struct balance_callback {
	struct balance_callback *next;
	void (*func)(struct rq *);
};

struct batadv_unicast_packet {
	__u8 packet_type;
	__u8 version;
	__u8 ttl;
	__u8 ttvn;
	__u8 dest[6];
};

struct i915_vma;

struct batch_chunk {
	struct i915_vma *vma;
	u32 offset;
	u32 *start;
	u32 *end;
	u32 max_items;
};

struct batch_u16 {
	u16 entropy[48];
	local_lock_t lock;
	long unsigned int generation;
	unsigned int position;
};

struct batch_u32 {
	u32 entropy[24];
	local_lock_t lock;
	long unsigned int generation;
	unsigned int position;
};

struct batch_u64 {
	u64 entropy[12];
	local_lock_t lock;
	long unsigned int generation;
	unsigned int position;
};

struct batch_u8 {
	u8 entropy[96];
	local_lock_t lock;
	long unsigned int generation;
	unsigned int position;
};

struct batch_vals {
	u32 max_threads;
	u32 state_start;
	u32 surface_start;
	u32 surface_height;
	u32 surface_width;
	u32 size;
};

struct bd_holder_disk {
	struct list_head list;
	struct kobject *holder_dir;
	int refcnt;
};

struct bdb_block_entry {
	struct list_head node;
	enum bdb_block_id section_id;
	u8 data[0];
};

struct dsc_compression_parameters_entry {
	u8 version_major: 4;
	u8 version_minor: 4;
	u8 rc_buffer_block_size: 2;
	u8 reserved1: 6;
	u8 rc_buffer_size;
	u32 slices_per_line;
	u8 line_buffer_depth: 4;
	u8 reserved2: 4;
	u8 block_prediction_enable: 1;
	u8 reserved3: 7;
	u8 max_bpp;
	u8 reserved4: 1;
	u8 support_8bpc: 1;
	u8 support_10bpc: 1;
	u8 support_12bpc: 1;
	u8 reserved5: 4;
	u16 slice_height;
} __attribute__((packed));

struct bdb_compression_parameters {
	u16 entry_size;
	struct dsc_compression_parameters_entry data[16];
};

struct bdb_driver_features {
	u8 boot_dev_algorithm: 1;
	u8 allow_display_switch_dvd: 1;
	u8 allow_display_switch_dos: 1;
	u8 hotplug_dvo: 1;
	u8 dual_view_zoom: 1;
	u8 int15h_hook: 1;
	u8 sprite_in_clone: 1;
	u8 primary_lfp_id: 1;
	u16 boot_mode_x;
	u16 boot_mode_y;
	u8 boot_mode_bpp;
	u8 boot_mode_refresh;
	u16 enable_lfp_primary: 1;
	u16 selective_mode_pruning: 1;
	u16 dual_frequency: 1;
	u16 render_clock_freq: 1;
	u16 nt_clone_support: 1;
	u16 power_scheme_ui: 1;
	u16 sprite_display_assign: 1;
	u16 cui_aspect_scaling: 1;
	u16 preserve_aspect_ratio: 1;
	u16 sdvo_device_power_down: 1;
	u16 crt_hotplug: 1;
	u16 lvds_config: 2;
	u16 tv_hotplug: 1;
	u16 hdmi_config: 2;
	u8 static_display: 1;
	u8 embedded_platform: 1;
	u8 display_subsystem_enable: 1;
	u8 reserved0: 5;
	u16 legacy_crt_max_x;
	u16 legacy_crt_max_y;
	u8 legacy_crt_max_refresh;
	u8 hdmi_termination: 1;
	u8 cea861d_hdmi_support: 1;
	u8 self_refresh_enable: 1;
	u8 reserved1: 5;
	u8 custom_vbt_version;
	u16 rmpm_enabled: 1;
	u16 s2ddt_enabled: 1;
	u16 dpst_enabled: 1;
	u16 bltclt_enabled: 1;
	u16 adb_enabled: 1;
	u16 drrs_enabled: 1;
	u16 grs_enabled: 1;
	u16 gpmt_enabled: 1;
	u16 tbt_enabled: 1;
	u16 psr_enabled: 1;
	u16 ips_enabled: 1;
	u16 dfps_enabled: 1;
	u16 dmrrs_enabled: 1;
	u16 adt_enabled: 1;
	u16 hpd_wake: 1;
	u16 pc_feature_valid: 1;
} __attribute__((packed));

struct bdb_edid_dtd {
	u16 clock;
	u8 hactive_lo;
	u8 hblank_lo;
	u8 hblank_hi: 4;
	u8 hactive_hi: 4;
	u8 vactive_lo;
	u8 vblank_lo;
	u8 vblank_hi: 4;
	u8 vactive_hi: 4;
	u8 hsync_off_lo;
	u8 hsync_pulse_width_lo;
	u8 vsync_pulse_width_lo: 4;
	u8 vsync_off_lo: 4;
	u8 vsync_pulse_width_hi: 2;
	u8 vsync_off_hi: 2;
	u8 hsync_pulse_width_hi: 2;
	u8 hsync_off_hi: 2;
	u8 himage_lo;
	u8 vimage_lo;
	u8 vimage_hi: 4;
	u8 himage_hi: 4;
	u8 h_border;
	u8 v_border;
	u8 rsvd1: 3;
	u8 digital: 2;
	u8 vsync_positive: 1;
	u8 hsync_positive: 1;
	u8 non_interlaced: 1;
};

struct bdb_edid_pnp_id {
	u16 mfg_name;
	u16 product_code;
	u32 serial;
	u8 mfg_week;
	u8 mfg_year;
} __attribute__((packed));

struct bdb_edid_product_name {
	char name[13];
};

struct edp_power_seq {
	u16 t1_t3;
	u16 t8;
	u16 t9;
	u16 t10;
	u16 t11_t12;
};

struct edp_fast_link_params {
	u8 rate: 4;
	u8 lanes: 4;
	u8 preemphasis: 4;
	u8 vswing: 4;
};

struct edp_pwm_delays {
	u16 pwm_on_to_backlight_enable;
	u16 backlight_disable_to_pwm_off;
};

struct edp_full_link_params {
	u8 preemphasis: 4;
	u8 vswing: 4;
};

struct edp_apical_params {
	u32 panel_oui;
	u32 dpcd_base_address;
	u32 dpcd_idridix_control_0;
	u32 dpcd_option_select;
	u32 dpcd_backlight;
	u32 ambient_light;
	u32 backlight_scale;
};

struct bdb_edp {
	struct edp_power_seq power_seqs[16];
	u32 color_depth;
	struct edp_fast_link_params fast_link_params[16];
	u32 sdrrs_msa_timing_delay;
	u16 edp_s3d_feature;
	u16 edp_t3_optimization;
	u64 edp_vswing_preemph;
	u16 fast_link_training;
	u16 dpcd_600h_write_required;
	struct edp_pwm_delays pwm_delays[16];
	u16 full_link_params_provided;
	struct edp_full_link_params full_link_params[16];
	u16 apical_enable;
	struct edp_apical_params apical_params[16];
	u16 edp_fast_link_training_rate[16];
	u16 edp_max_port_link_rate[16];
	u16 edp_dsc_disable;
	u16 t6_delay_support;
	u16 link_idle_time[16];
} __attribute__((packed));

struct bdb_general_definitions {
	u8 crt_ddc_gmbus_pin;
	u8 dpms_non_acpi: 1;
	u8 skip_boot_crt_detect: 1;
	u8 dpms_aim: 1;
	u8 rsvd1: 5;
	u8 boot_display[2];
	u8 child_dev_size;
	u8 devices[0];
};

struct bdb_general_features {
	u8 panel_fitting: 2;
	u8 flexaim: 1;
	u8 msg_enable: 1;
	u8 clear_screen: 3;
	u8 color_flip: 1;
	u8 download_ext_vbt: 1;
	u8 enable_ssc: 1;
	u8 ssc_freq: 1;
	u8 enable_lfp_on_override: 1;
	u8 disable_ssc_ddt: 1;
	u8 underscan_vga_timings: 1;
	u8 display_clock_mode: 1;
	u8 vbios_hotplug_support: 1;
	u8 disable_smooth_vision: 1;
	u8 single_dvi: 1;
	u8 rotate_180: 1;
	u8 fdi_rx_polarity_inverted: 1;
	u8 vbios_extended_mode: 1;
	u8 copy_ilfp_dtd_to_sdvo_lvds_dtd: 1;
	u8 panel_best_fit_timing: 1;
	u8 ignore_strap_state: 1;
	u8 legacy_monitor_detect;
	u8 int_crt_support: 1;
	u8 int_tv_support: 1;
	u8 int_efp_support: 1;
	u8 dp_ssc_enable: 1;
	u8 dp_ssc_freq: 1;
	u8 dp_ssc_dongle_supported: 1;
	u8 rsvd11: 2;
	u8 tc_hpd_retry_timeout: 7;
	u8 rsvd12: 1;
	u8 afc_startup_config: 2;
	u8 rsvd13: 6;
};

struct generic_dtd_entry {
	u32 pixel_clock;
	u16 hactive;
	u16 hblank;
	u16 hfront_porch;
	u16 hsync;
	u16 vactive;
	u16 vblank;
	u16 vfront_porch;
	u16 vsync;
	u16 width_mm;
	u16 height_mm;
	u8 rsvd_flags: 6;
	u8 vsync_positive_polarity: 1;
	u8 hsync_positive_polarity: 1;
	u8 rsvd[3];
};

struct bdb_generic_dtd {
	u16 gdtd_size;
	struct generic_dtd_entry dtd[0];
} __attribute__((packed));

struct bdb_header {
	u8 signature[16];
	u16 version;
	u16 header_size;
	u16 bdb_size;
};

struct lfp_backlight_data_entry {
	u8 type: 2;
	u8 active_low_pwm: 1;
	u8 i2c_pin: 3;
	u8 i2c_speed: 2;
	u16 pwm_freq_hz;
	u8 min_brightness;
	u8 i2c_address;
	u8 i2c_command;
} __attribute__((packed));

struct lfp_backlight_control_method {
	u8 type: 4;
	u8 controller: 4;
};

struct lfp_brightness_level {
	u16 level;
	u16 reserved;
};

struct bdb_lfp_backlight {
	u8 entry_size;
	struct lfp_backlight_data_entry data[16];
	u8 level[16];
	struct lfp_backlight_control_method backlight_control[16];
	struct lfp_brightness_level brightness_level[16];
	struct lfp_brightness_level brightness_min_level[16];
	u8 brightness_precision_bits[16];
	u16 hdr_dpcd_refresh_timeout[16];
} __attribute__((packed));

struct fp_timing {
	u16 x_res;
	u16 y_res;
	u32 lvds_reg;
	u32 lvds_reg_val;
	u32 pp_on_reg;
	u32 pp_on_reg_val;
	u32 pp_off_reg;
	u32 pp_off_reg_val;
	u32 pp_cycle_reg;
	u32 pp_cycle_reg_val;
	u32 pfit_reg;
	u32 pfit_reg_val;
	u16 terminator;
} __attribute__((packed));

struct lfp_data_entry {
	struct fp_timing fp_timing;
	struct bdb_edid_dtd dvo_timing;
	struct bdb_edid_pnp_id pnp_id;
};

struct bdb_lfp_data {
	struct lfp_data_entry data[16];
};

struct lfp_data_ptr_table {
	u16 offset;
	u8 table_size;
} __attribute__((packed));

struct lfp_data_ptr {
	struct lfp_data_ptr_table fp_timing;
	struct lfp_data_ptr_table dvo_timing;
	struct lfp_data_ptr_table panel_pnp_id;
};

struct bdb_lfp_data_ptrs {
	u8 num_entries;
	struct lfp_data_ptr ptr[16];
	struct lfp_data_ptr_table panel_name;
};

struct lfp_black_border {
	u8 top;
	u8 bottom;
	u8 left;
	u8 right;
};

struct bdb_lfp_data_tail {
	struct bdb_edid_product_name panel_name[16];
	u16 scaling_enable;
	u8 seamless_drrs_min_refresh_rate[16];
	u8 pixel_overlap_count[16];
	struct lfp_black_border black_border[16];
	u16 dual_lfp_port_sync_enable;
	u16 gpu_dithering_for_banding_artifacts;
};

struct bdb_lfp_options {
	u8 panel_type;
	u8 panel_type2;
	u8 pfit_mode: 2;
	u8 pfit_text_mode_enhanced: 1;
	u8 pfit_gfx_mode_enhanced: 1;
	u8 pfit_ratio_auto: 1;
	u8 pixel_dither: 1;
	u8 lvds_edid: 1;
	u8 rsvd2: 1;
	u8 rsvd4;
	u32 lvds_panel_channel_bits;
	u16 ssc_bits;
	u16 ssc_freq;
	u16 ssc_ddt;
	u16 panel_color_depth;
	u32 dps_panel_type_bits;
	u32 blt_control_type_bits;
	u16 lcdvcc_s0_enable;
	u32 rotation;
	u32 position;
} __attribute__((packed));

struct lfp_power_features {
	u8 dpst_support: 1;
	u8 power_conservation_pref: 3;
	u8 reserved2: 1;
	u8 lace_enabled_status: 1;
	u8 lace_support: 1;
	u8 als_enable: 1;
};

struct panel_identification {
	u8 panel_technology: 4;
	u8 reserved: 4;
};

struct bdb_lfp_power {
	struct lfp_power_features features;
	struct als_data_entry als[5];
	u8 lace_aggressiveness_profile: 3;
	u8 reserved1: 5;
	u16 dpst;
	u16 psr;
	u16 drrs;
	u16 lace_support;
	u16 adt;
	u16 dmrrs;
	u16 adb;
	u16 lace_enabled_status;
	struct aggressiveness_profile_entry aggressiveness[16];
	u16 hobl;
	u16 vrr_feature_enabled;
	u16 elp;
	u16 opst;
	struct aggressiveness_profile2_entry aggressiveness2[16];
	u16 apd;
	u16 pixoptix;
	struct aggressiveness_profile3_entry aggressiveness3[16];
	struct panel_identification panel_identification[16];
	u16 xpst_support;
	u16 tcon_based_backlight_optimization;
	struct aggressiveness_profile4_entry aggressiveness4[16];
	u16 tcon_backlight_xpst_coexistence;
} __attribute__((packed));

struct mipi_config {
	u16 panel_id;
	u32 enable_dithering: 1;
	u32 rsvd1: 1;
	u32 is_bridge: 1;
	u32 panel_arch_type: 2;
	u32 is_cmd_mode: 1;
	u32 video_transfer_mode: 2;
	u32 cabc_supported: 1;
	u32 pwm_blc: 1;
	u32 videomode_color_format: 4;
	u32 rotation: 2;
	u32 bta_enabled: 1;
	u32 rsvd2: 15;
	u16 dual_link: 2;
	u16 lane_cnt: 2;
	u16 pixel_overlap: 3;
	u16 rgb_flip: 1;
	u16 dl_dcs_cabc_ports: 2;
	u16 dl_dcs_backlight_ports: 2;
	u16 rsvd3: 4;
	u16 rsvd4;
	u8 rsvd5;
	u32 target_burst_mode_freq;
	u32 dsi_ddr_clk;
	u32 bridge_ref_clk;
	u8 byte_clk_sel: 2;
	u8 rsvd6: 6;
	u16 dphy_param_valid: 1;
	u16 eot_pkt_disabled: 1;
	u16 enable_clk_stop: 1;
	u16 rsvd7: 13;
	u32 hs_tx_timeout;
	u32 lp_rx_timeout;
	u32 turn_around_timeout;
	u32 device_reset_timer;
	u32 master_init_timer;
	u32 dbi_bw_timer;
	u32 lp_byte_clk_val;
	u32 prepare_cnt: 6;
	u32 rsvd8: 2;
	u32 clk_zero_cnt: 8;
	u32 trail_cnt: 5;
	u32 rsvd9: 3;
	u32 exit_zero_cnt: 6;
	u32 rsvd10: 2;
	u32 clk_lane_switch_cnt;
	u32 hl_switch_cnt;
	u32 rsvd11[6];
	u8 tclk_miss;
	u8 tclk_post;
	u8 rsvd12;
	u8 tclk_pre;
	u8 tclk_prepare;
	u8 tclk_settle;
	u8 tclk_term_enable;
	u8 tclk_trail;
	u16 tclk_prepare_clkzero;
	u8 rsvd13;
	u8 td_term_enable;
	u8 teot;
	u8 ths_exit;
	u8 ths_prepare;
	u16 ths_prepare_hszero;
	u8 rsvd14;
	u8 ths_settle;
	u8 ths_skip;
	u8 ths_trail;
	u8 tinit;
	u8 tlpx;
	u8 rsvd15[3];
	u8 panel_enable;
	u8 bl_enable;
	u8 pwm_enable;
	u8 reset_r_n;
	u8 pwr_down_r;
	u8 stdby_r_n;
} __attribute__((packed));

struct mipi_pps_data {
	u16 panel_on_delay;
	u16 bl_enable_delay;
	u16 bl_disable_delay;
	u16 panel_off_delay;
	u16 panel_power_cycle_delay;
};

struct bdb_mipi_config {
	struct mipi_config config[6];
	struct mipi_pps_data pps[6];
	struct edp_pwm_delays pwm_delays[6];
	u8 pmic_i2c_bus_number[6];
};

struct bdb_mipi_sequence {
	u8 version;
	u8 data[0];
};

struct psr_table {
	u8 full_link: 1;
	u8 require_aux_to_wakeup: 1;
	u8 feature_bits_rsvd: 6;
	u8 idle_frames: 4;
	u8 lines_to_wait: 3;
	u8 wait_times_rsvd: 1;
	u16 tp1_wakeup_time;
	u16 tp2_tp3_wakeup_time;
};

struct bdb_psr {
	struct psr_table psr_table[16];
	u32 psr2_tp2_tp3_wakeup_time;
};

struct bdb_sdvo_lvds_dtd {
	struct bdb_edid_dtd dtd[4];
};

struct bdb_sdvo_lvds_options {
	u8 panel_backlight;
	u8 h40_set_panel_type;
	u8 panel_type;
	u8 ssc_clk_freq;
	u16 als_low_trip;
	u16 als_high_trip;
	u8 sclalarcoeff_tab_row_num;
	u8 sclalarcoeff_tab_row_size;
	u8 coefficient[8];
	u8 panel_misc_bits_1;
	u8 panel_misc_bits_2;
	u8 panel_misc_bits_3;
	u8 panel_misc_bits_4;
};

struct gendisk;

struct request_queue;

struct disk_stats;

struct blk_holder_ops;

struct partition_meta_info;

struct block_device {
	sector_t bd_start_sect;
	sector_t bd_nr_sectors;
	struct gendisk *bd_disk;
	struct request_queue *bd_queue;
	struct disk_stats *bd_stats;
	long unsigned int bd_stamp;
	atomic_t __bd_flags;
	dev_t bd_dev;
	struct address_space *bd_mapping;
	atomic_t bd_openers;
	spinlock_t bd_size_lock;
	void *bd_claiming;
	void *bd_holder;
	const struct blk_holder_ops *bd_holder_ops;
	struct mutex bd_holder_lock;
	int bd_holders;
	struct kobject *bd_holder_dir;
	atomic_t bd_fsfreeze_count;
	struct mutex bd_fsfreeze_mutex;
	struct partition_meta_info *bd_meta_info;
	int bd_writers;
	void *bd_security;
	struct device bd_device;
};

struct posix_acl;

struct inode_operations;

struct file_lock_context;

struct pipe_inode_info;

struct cdev;

struct inode {
	umode_t i_mode;
	short unsigned int i_opflags;
	kuid_t i_uid;
	kgid_t i_gid;
	unsigned int i_flags;
	struct posix_acl *i_acl;
	struct posix_acl *i_default_acl;
	const struct inode_operations *i_op;
	struct super_block *i_sb;
	struct address_space *i_mapping;
	void *i_security;
	long unsigned int i_ino;
	union {
		const unsigned int i_nlink;
		unsigned int __i_nlink;
	};
	dev_t i_rdev;
	loff_t i_size;
	time64_t i_atime_sec;
	time64_t i_mtime_sec;
	time64_t i_ctime_sec;
	u32 i_atime_nsec;
	u32 i_mtime_nsec;
	u32 i_ctime_nsec;
	u32 i_generation;
	spinlock_t i_lock;
	short unsigned int i_bytes;
	u8 i_blkbits;
	enum rw_hint i_write_hint;
	blkcnt_t i_blocks;
	u32 i_state;
	struct rw_semaphore i_rwsem;
	long unsigned int dirtied_when;
	long unsigned int dirtied_time_when;
	struct hlist_node i_hash;
	struct list_head i_io_list;
	struct list_head i_lru;
	struct list_head i_sb_list;
	struct list_head i_wb_list;
	union {
		struct hlist_head i_dentry;
		struct callback_head i_rcu;
	};
	atomic64_t i_version;
	atomic64_t i_sequence;
	atomic_t i_count;
	atomic_t i_dio_count;
	atomic_t i_writecount;
	atomic_t i_readcount;
	union {
		const struct file_operations *i_fop;
		void (*free_inode)(struct inode *);
	};
	struct file_lock_context *i_flctx;
	struct address_space i_data;
	union {
		struct list_head i_devices;
		int i_linklen;
	};
	union {
		struct pipe_inode_info *i_pipe;
		struct cdev *i_cdev;
		char *i_link;
		unsigned int i_dir_seq;
	};
	__u32 i_fsnotify_mask;
	struct fsnotify_mark_connector *i_fsnotify_marks;
	void *i_private;
};

struct bdev_inode {
	struct block_device bdev;
	struct inode vfs_inode;
};

struct ieee80211_meshconf_ie;

struct cfg80211_mbssid_elems;

struct cfg80211_rnr_elems;

struct beacon_data {
	u8 *head;
	u8 *tail;
	int head_len;
	int tail_len;
	struct ieee80211_meshconf_ie *meshconf;
	u16 cntdwn_counter_offsets[2];
	u8 cntdwn_current_counter;
	struct cfg80211_mbssid_elems *mbssid_ies;
	struct cfg80211_rnr_elems *rnr_ies;
	struct callback_head callback_head;
};

struct bgl_lock {
	spinlock_t lock;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct bh_accounting {
	int nr;
	int ratelimit;
};

struct bh_lru {
	struct buffer_head *bhs[16];
};

struct bictcp {
	u32 cnt;
	u32 last_max_cwnd;
	u32 last_cwnd;
	u32 last_time;
	u32 bic_origin_point;
	u32 bic_K;
	u32 delay_min;
	u32 epoch_start;
	u32 ack_cnt;
	u32 tcp_cwnd;
	u16 unused;
	u8 sample_cnt;
	u8 found;
	u32 round_start;
	u32 end_seq;
	u32 last_ack;
	u32 curr_rtt;
};

struct binfmt_misc {
	struct list_head entries;
	rwlock_t entries_lock;
	bool enabled;
};

struct bvec_iter {
	sector_t bi_sector;
	unsigned int bi_size;
	unsigned int bi_idx;
	unsigned int bi_bvec_done;
} __attribute__((packed));

struct bio;

typedef void bio_end_io_t(struct bio *);

struct bio_issue {
	u64 value;
};

struct bio_vec {
	struct page *bv_page;
	unsigned int bv_len;
	unsigned int bv_offset;
};

struct blkcg_gq;

struct bio_set;

struct bio {
	struct bio *bi_next;
	struct block_device *bi_bdev;
	blk_opf_t bi_opf;
	short unsigned int bi_flags;
	short unsigned int bi_ioprio;
	enum rw_hint bi_write_hint;
	blk_status_t bi_status;
	atomic_t __bi_remaining;
	struct bvec_iter bi_iter;
	union {
		blk_qc_t bi_cookie;
		unsigned int __bi_nr_segments;
	};
	bio_end_io_t *bi_end_io;
	void *bi_private;
	struct blkcg_gq *bi_blkg;
	struct bio_issue bi_issue;
	u64 bi_iocost_cost;
	short unsigned int bi_vcnt;
	short unsigned int bi_max_vecs;
	atomic_t __bi_cnt;
	struct bio_vec *bi_io_vec;
	struct bio_set *bi_pool;
	struct bio_vec bi_inline_vecs[0];
};

struct bio_alloc_cache {
	struct bio *free_list;
	struct bio *free_list_irq;
	unsigned int nr;
	unsigned int nr_irq;
};

struct bio_integrity_payload {
	struct bio *bip_bio;
	struct bvec_iter bip_iter;
	short unsigned int bip_vcnt;
	short unsigned int bip_max_vcnt;
	short unsigned int bip_flags;
	u16 app_tag;
	struct bvec_iter bio_iter;
	struct work_struct bip_work;
	struct bio_vec *bip_vec;
	struct bio_vec bip_inline_vecs[0];
};

struct bio_list {
	struct bio *head;
	struct bio *tail;
};

struct iovec {
	void *iov_base;
	__kernel_size_t iov_len;
};

struct kvec;

struct folio_queue;

struct iov_iter {
	u8 iter_type;
	bool nofault;
	bool data_source;
	size_t iov_offset;
	union {
		struct iovec __ubuf_iovec;
		struct {
			union {
				const struct iovec *__iov;
				const struct kvec *kvec;
				const struct bio_vec *bvec;
				const struct folio_queue *folioq;
				struct xarray *xarray;
				void *ubuf;
			};
			size_t count;
		};
	};
	union {
		long unsigned int nr_segs;
		u8 folioq_slot;
		loff_t xarray_start;
	};
};

struct bio_map_data {
	bool is_our_pages: 1;
	bool is_null_mapped: 1;
	struct iov_iter iter;
	struct iovec iov[0];
};

struct bio_post_read_ctx {
	struct bio *bio;
	struct work_struct work;
	unsigned int cur_step;
	unsigned int enabled_steps;
};

typedef void *mempool_alloc_t(gfp_t, void *);

typedef void mempool_free_t(void *, void *);

struct mempool_s {
	spinlock_t lock;
	int min_nr;
	int curr_nr;
	void **elements;
	void *pool_data;
	mempool_alloc_t *alloc;
	mempool_free_t *free;
	wait_queue_head_t wait;
};

typedef struct mempool_s mempool_t;

struct bio_set {
	struct kmem_cache *bio_slab;
	unsigned int front_pad;
	struct bio_alloc_cache *cache;
	mempool_t bio_pool;
	mempool_t bvec_pool;
	unsigned int back_pad;
	spinlock_t rescue_lock;
	struct bio_list rescue_list;
	struct work_struct rescue_work;
	struct workqueue_struct *rescue_workqueue;
	struct hlist_node cpuhp_dead;
};

struct bio_slab {
	struct kmem_cache *slab;
	unsigned int slab_ref;
	unsigned int slab_size;
	char name[12];
};

struct biovec_slab {
	int nr_vecs;
	char *name;
	struct kmem_cache *slab;
};

struct bitmap_page;

struct bitmap_counts {
	spinlock_t lock;
	struct bitmap_page *bp;
	long unsigned int pages;
	long unsigned int missing_pages;
	long unsigned int chunkshift;
	long unsigned int chunks;
};

struct bitmap_storage {
	struct file *file;
	struct page *sb_page;
	long unsigned int sb_index;
	struct page **filemap;
	long unsigned int *filemap_attr;
	long unsigned int file_pages;
	long unsigned int bytes;
};

struct mddev;

struct bitmap {
	struct bitmap_counts counts;
	struct mddev *mddev;
	__u64 events_cleared;
	int need_sync;
	struct bitmap_storage storage;
	long unsigned int flags;
	int allclean;
	atomic_t behind_writes;
	long unsigned int behind_writes_used;
	long unsigned int daemon_lastrun;
	long unsigned int last_end_sync;
	atomic_t pending_writes;
	wait_queue_head_t write_wait;
	wait_queue_head_t overflow_wait;
	wait_queue_head_t behind_wait;
	struct kernfs_node *sysfs_can_clear;
	int cluster_slot;
};

struct md_bitmap_stats;

struct bitmap_operations {
	bool (*enabled)(struct mddev *);
	int (*create)(struct mddev *, int);
	int (*resize)(struct mddev *, sector_t, int, bool);
	int (*load)(struct mddev *);
	void (*destroy)(struct mddev *);
	void (*flush)(struct mddev *);
	void (*write_all)(struct mddev *);
	void (*dirty_bits)(struct mddev *, long unsigned int, long unsigned int);
	void (*unplug)(struct mddev *, bool);
	void (*daemon_work)(struct mddev *);
	void (*start_behind_write)(struct mddev *);
	void (*end_behind_write)(struct mddev *);
	void (*wait_behind_writes)(struct mddev *);
	int (*startwrite)(struct mddev *, sector_t, long unsigned int);
	void (*endwrite)(struct mddev *, sector_t, long unsigned int);
	bool (*start_sync)(struct mddev *, sector_t, sector_t *, bool);
	void (*end_sync)(struct mddev *, sector_t, sector_t *);
	void (*cond_end_sync)(struct mddev *, sector_t, bool);
	void (*close_sync)(struct mddev *);
	void (*update_sb)(void *);
	int (*get_stats)(void *, struct md_bitmap_stats *);
	void (*sync_with_cluster)(struct mddev *, sector_t, sector_t, sector_t, sector_t);
	void * (*get_from_slot)(struct mddev *, int);
	int (*copy_from_slot)(struct mddev *, int, sector_t *, sector_t *, bool);
	void (*set_pages)(void *, long unsigned int);
	void (*free)(void *);
};

struct bitmap_page {
	char *map;
	unsigned int hijacked: 1;
	unsigned int pending: 1;
	unsigned int count: 30;
};

struct bitmap_super_s {
	__le32 magic;
	__le32 version;
	__u8 uuid[16];
	__le64 events;
	__le64 events_cleared;
	__le64 sync_size;
	__le32 state;
	__le32 chunksize;
	__le32 daemon_sleep;
	__le32 write_behind;
	__le32 sectors_reserved;
	__le32 nodes;
	__u8 cluster_name[64];
	__u8 pad[120];
};

typedef struct bitmap_super_s bitmap_super_t;

struct bitmap_unplug_work {
	struct work_struct work;
	struct bitmap *bitmap;
	struct completion *done;
};

struct bl_dev_msg {
	int32_t status;
	uint32_t major;
	uint32_t minor;
};

struct blacklist_entry {
	struct list_head next;
	char *buf;
};

struct blake2s_state {
	u32 h[8];
	u32 t[2];
	u32 f[2];
	u8 buf[64];
	unsigned int buflen;
	unsigned int outlen;
};

struct blk_crypto_config {
	enum blk_crypto_mode_num crypto_mode;
	unsigned int data_unit_size;
	unsigned int dun_bytes;
};

struct blk_crypto_key {
	struct blk_crypto_config crypto_cfg;
	unsigned int data_unit_size_bits;
	unsigned int size;
	u8 raw[64];
};

struct blk_crypto_profile;

struct blk_crypto_ll_ops {
	int (*keyslot_program)(struct blk_crypto_profile *, const struct blk_crypto_key *, unsigned int);
	int (*keyslot_evict)(struct blk_crypto_profile *, const struct blk_crypto_key *, unsigned int);
};

struct blk_crypto_keyslot;

struct blk_crypto_profile {
	struct blk_crypto_ll_ops ll_ops;
	unsigned int max_dun_bytes_supported;
	unsigned int modes_supported[5];
	struct device *dev;
	unsigned int num_slots;
	struct rw_semaphore lock;
	struct lock_class_key lockdep_key;
	wait_queue_head_t idle_slots_wait_queue;
	struct list_head idle_slots;
	spinlock_t idle_slots_lock;
	struct hlist_head *slot_hashtable;
	unsigned int log_slot_ht_size;
	struct blk_crypto_keyslot *slots;
};

struct blk_expired_data {
	bool has_timedout_rq;
	long unsigned int next;
	long unsigned int timeout_start;
};

struct request;

struct blk_flush_queue {
	spinlock_t mq_flush_lock;
	unsigned int flush_pending_idx: 1;
	unsigned int flush_running_idx: 1;
	blk_status_t rq_status;
	long unsigned int flush_pending_since;
	struct list_head flush_queue[2];
	long unsigned int flush_data_in_flight;
	struct request *flush_rq;
};

struct blk_holder_ops {
	void (*mark_dead)(struct block_device *, bool);
	void (*sync)(struct block_device *);
	int (*freeze)(struct block_device *);
	int (*thaw)(struct block_device *);
};

struct blk_independent_access_range;

struct blk_ia_range_sysfs_entry {
	struct attribute attr;
	ssize_t (*show)(struct blk_independent_access_range *, char *);
};

struct blk_independent_access_range {
	struct kobject kobj;
	sector_t sector;
	sector_t nr_sectors;
};

struct blk_independent_access_ranges {
	struct kobject kobj;
	bool sysfs_registered;
	unsigned int nr_ia_ranges;
	struct blk_independent_access_range ia_range[0];
};

struct blk_integrity {
	unsigned char flags;
	enum blk_integrity_checksum csum_type;
	unsigned char tuple_size;
	unsigned char pi_offset;
	unsigned char interval_exp;
	unsigned char tag_size;
};

struct blk_io_trace {
	__u32 magic;
	__u32 sequence;
	__u64 time;
	__u64 sector;
	__u32 bytes;
	__u32 action;
	__u32 pid;
	__u32 device;
	__u32 cpu;
	__u16 error;
	__u16 pdu_len;
};

struct blk_io_trace_remap {
	__be32 device_from;
	__be32 device_to;
	__be64 sector_from;
};

struct rq_qos_ops;

struct rq_qos {
	const struct rq_qos_ops *ops;
	struct gendisk *disk;
	enum rq_qos_id id;
	struct rq_qos *next;
	struct dentry *debugfs_dir;
};

struct blk_iolatency {
	struct rq_qos rqos;
	struct timer_list timer;
	bool enabled;
	atomic_t enable_cnt;
	struct work_struct enable_work;
};

struct blk_iou_cmd {
	int res;
	bool nowait;
};

struct blk_major_name {
	struct blk_major_name *next;
	int major;
	char name[16];
	void (*probe)(dev_t);
};

struct rq_list;

struct blk_mq_ctx;

struct blk_mq_hw_ctx;

struct blk_mq_alloc_data {
	struct request_queue *q;
	blk_mq_req_flags_t flags;
	unsigned int shallow_depth;
	blk_opf_t cmd_flags;
	req_flags_t rq_flags;
	unsigned int nr_tags;
	struct rq_list *cached_rqs;
	struct blk_mq_ctx *ctx;
	struct blk_mq_hw_ctx *hctx;
};

struct blk_mq_ctxs;

struct blk_mq_ctx {
	struct {
		spinlock_t lock;
		struct list_head rq_lists[3];
		long: 64;
	};
	unsigned int cpu;
	short unsigned int index_hw[3];
	struct blk_mq_hw_ctx *hctxs[3];
	struct request_queue *queue;
	struct blk_mq_ctxs *ctxs;
	struct kobject kobj;
	long: 64;
};

struct blk_mq_ctxs {
	struct kobject kobj;
	struct blk_mq_ctx *queue_ctx;
};

struct seq_operations;

struct blk_mq_debugfs_attr {
	const char *name;
	umode_t mode;
	int (*show)(void *, struct seq_file *);
	ssize_t (*write)(void *, const char *, size_t, loff_t *);
	const struct seq_operations *seq_ops;
};

struct sbitmap_word;

struct sbitmap {
	unsigned int depth;
	unsigned int shift;
	unsigned int map_nr;
	bool round_robin;
	struct sbitmap_word *map;
	unsigned int *alloc_hint;
};

typedef struct wait_queue_entry wait_queue_entry_t;

struct blk_mq_hw_ctx {
	struct {
		spinlock_t lock;
		struct list_head dispatch;
		long unsigned int state;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
	};
	struct delayed_work run_work;
	cpumask_var_t cpumask;
	int next_cpu;
	int next_cpu_batch;
	long unsigned int flags;
	void *sched_data;
	struct request_queue *queue;
	struct blk_flush_queue *fq;
	void *driver_data;
	struct sbitmap ctx_map;
	struct blk_mq_ctx *dispatch_from;
	unsigned int dispatch_busy;
	short unsigned int type;
	short unsigned int nr_ctx;
	struct blk_mq_ctx **ctxs;
	spinlock_t dispatch_wait_lock;
	wait_queue_entry_t dispatch_wait;
	atomic_t wait_index;
	struct blk_mq_tags *tags;
	struct blk_mq_tags *sched_tags;
	unsigned int numa_node;
	unsigned int queue_num;
	atomic_t nr_active;
	struct hlist_node cpuhp_online;
	struct hlist_node cpuhp_dead;
	struct kobject kobj;
	struct dentry *debugfs_dir;
	struct dentry *sched_debugfs_dir;
	struct list_head hctx_list;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct blk_mq_hw_ctx_sysfs_entry {
	struct attribute attr;
	ssize_t (*show)(struct blk_mq_hw_ctx *, char *);
};

struct blk_mq_queue_data;

struct io_comp_batch;

struct blk_mq_ops {
	blk_status_t (*queue_rq)(struct blk_mq_hw_ctx *, const struct blk_mq_queue_data *);
	void (*commit_rqs)(struct blk_mq_hw_ctx *);
	void (*queue_rqs)(struct rq_list *);
	int (*get_budget)(struct request_queue *);
	void (*put_budget)(struct request_queue *, int);
	void (*set_rq_budget_token)(struct request *, int);
	int (*get_rq_budget_token)(struct request *);
	enum blk_eh_timer_return (*timeout)(struct request *);
	int (*poll)(struct blk_mq_hw_ctx *, struct io_comp_batch *);
	void (*complete)(struct request *);
	int (*init_hctx)(struct blk_mq_hw_ctx *, void *, unsigned int);
	void (*exit_hctx)(struct blk_mq_hw_ctx *, unsigned int);
	int (*init_request)(struct blk_mq_tag_set *, struct request *, unsigned int, unsigned int);
	void (*exit_request)(struct blk_mq_tag_set *, struct request *, unsigned int);
	void (*cleanup_rq)(struct request *);
	bool (*busy)(struct request_queue *);
	void (*map_queues)(struct blk_mq_tag_set *);
	void (*show_rq)(struct seq_file *, struct request *);
};

struct elevator_type;

struct blk_mq_qe_pair {
	struct list_head node;
	struct request_queue *q;
	struct elevator_type *type;
};

struct blk_mq_queue_data {
	struct request *rq;
	bool last;
};

struct sbq_wait_state;

struct sbitmap_queue {
	struct sbitmap sb;
	unsigned int wake_batch;
	atomic_t wake_index;
	struct sbq_wait_state *ws;
	atomic_t ws_active;
	unsigned int min_shallow_depth;
	atomic_t completion_cnt;
	atomic_t wakeup_cnt;
};

struct blk_mq_tags {
	unsigned int nr_tags;
	unsigned int nr_reserved_tags;
	unsigned int active_queues;
	struct sbitmap_queue bitmap_tags;
	struct sbitmap_queue breserved_tags;
	struct request **rqs;
	struct request **static_rqs;
	struct list_head page_list;
	spinlock_t lock;
};

struct rq_list {
	struct request *head;
	struct request *tail;
};

struct blk_plug {
	struct rq_list mq_list;
	struct rq_list cached_rqs;
	u64 cur_ktime;
	short unsigned int nr_ios;
	short unsigned int rq_count;
	bool multiple_queues;
	bool has_elevator;
	struct list_head cb_list;
};

struct blk_plug_cb;

typedef void (*blk_plug_cb_fn)(struct blk_plug_cb *, bool);

struct blk_plug_cb {
	struct list_head list;
	blk_plug_cb_fn callback;
	void *data;
};

struct blk_queue_stats {
	struct list_head callbacks;
	spinlock_t lock;
	int accounting;
};

struct blk_rq_stat {
	u64 mean;
	u64 min;
	u64 max;
	u32 nr_samples;
	u64 batch;
};

struct blk_rq_wait {
	struct completion done;
	blk_status_t ret;
};

struct blk_stat_callback {
	struct list_head list;
	struct timer_list timer;
	struct blk_rq_stat *cpu_stat;
	int (*bucket_fn)(const struct request *);
	unsigned int buckets;
	struct blk_rq_stat *stat;
	void (*timer_fn)(struct blk_stat_callback *);
	void *data;
	struct callback_head rcu;
};

struct rchan;

struct blk_trace {
	int trace_state;
	struct rchan *rchan;
	long unsigned int *sequence;
	unsigned char *msg_data;
	u16 act_mask;
	u64 start_lba;
	u64 end_lba;
	u32 pid;
	u32 dev;
	struct dentry *dir;
	struct list_head running_list;
	atomic_t dropped;
};

struct blk_user_trace_setup {
	char name[32];
	__u16 act_mask;
	__u32 buf_size;
	__u32 buf_nr;
	__u64 start_lba;
	__u64 end_lba;
	__u32 pid;
};

struct blk_zone {
	__u64 start;
	__u64 len;
	__u64 wp;
	__u8 type;
	__u8 cond;
	__u8 non_seq;
	__u8 reset;
	__u8 resv[4];
	__u64 capacity;
	__u8 reserved[24];
};

struct percpu_ref_data;

struct percpu_ref {
	long unsigned int percpu_count_ptr;
	struct percpu_ref_data *data;
};

struct cgroup_subsys;

struct cgroup_subsys_state {
	struct cgroup *cgroup;
	struct cgroup_subsys *ss;
	struct percpu_ref refcnt;
	struct list_head sibling;
	struct list_head children;
	struct list_head rstat_css_node;
	int id;
	unsigned int flags;
	u64 serial_nr;
	atomic_t online_cnt;
	struct work_struct destroy_work;
	struct rcu_work destroy_rwork;
	struct cgroup_subsys_state *parent;
	int nr_descendants;
};

struct blkcg_policy_data;

struct blkcg {
	struct cgroup_subsys_state css;
	spinlock_t lock;
	refcount_t online_pin;
	atomic_t congestion_count;
	struct xarray blkg_tree;
	struct blkcg_gq *blkg_hint;
	struct hlist_head blkg_list;
	struct blkcg_policy_data *cpd[6];
	struct list_head all_blkcgs_node;
	struct llist_head *lhead;
};

struct blkg_iostat {
	u64 bytes[3];
	u64 ios[3];
};

struct blkg_iostat_set {
	struct u64_stats_sync sync;
	struct blkcg_gq *blkg;
	struct llist_node lnode;
	int lqueued;
	struct blkg_iostat cur;
	struct blkg_iostat last;
};

struct blkg_policy_data;

struct blkcg_gq {
	struct request_queue *q;
	struct list_head q_node;
	struct hlist_node blkcg_node;
	struct blkcg *blkcg;
	struct blkcg_gq *parent;
	struct percpu_ref refcnt;
	bool online;
	struct blkg_iostat_set *iostat_cpu;
	struct blkg_iostat_set iostat;
	struct blkg_policy_data *pd[6];
	union {
		struct work_struct async_bio_work;
		struct work_struct free_work;
	};
	atomic_t use_delay;
	atomic64_t delay_nsec;
	atomic64_t delay_start;
	u64 last_delay;
	int last_use;
	struct callback_head callback_head;
};

typedef struct blkcg_policy_data *blkcg_pol_alloc_cpd_fn(gfp_t);

typedef void blkcg_pol_free_cpd_fn(struct blkcg_policy_data *);

typedef struct blkg_policy_data *blkcg_pol_alloc_pd_fn(struct gendisk *, struct blkcg *, gfp_t);

typedef void blkcg_pol_init_pd_fn(struct blkg_policy_data *);

typedef void blkcg_pol_online_pd_fn(struct blkg_policy_data *);

typedef void blkcg_pol_offline_pd_fn(struct blkg_policy_data *);

typedef void blkcg_pol_free_pd_fn(struct blkg_policy_data *);

typedef void blkcg_pol_reset_pd_stats_fn(struct blkg_policy_data *);

typedef void blkcg_pol_stat_pd_fn(struct blkg_policy_data *, struct seq_file *);

struct cftype;

struct blkcg_policy {
	int plid;
	struct cftype *dfl_cftypes;
	struct cftype *legacy_cftypes;
	blkcg_pol_alloc_cpd_fn *cpd_alloc_fn;
	blkcg_pol_free_cpd_fn *cpd_free_fn;
	blkcg_pol_alloc_pd_fn *pd_alloc_fn;
	blkcg_pol_init_pd_fn *pd_init_fn;
	blkcg_pol_online_pd_fn *pd_online_fn;
	blkcg_pol_offline_pd_fn *pd_offline_fn;
	blkcg_pol_free_pd_fn *pd_free_fn;
	blkcg_pol_reset_pd_stats_fn *pd_reset_stats_fn;
	blkcg_pol_stat_pd_fn *pd_stat_fn;
};

struct blkcg_policy_data {
	struct blkcg *blkcg;
	int plid;
};

struct blkdev_dio {
	union {
		struct kiocb *iocb;
		struct task_struct *waiter;
	};
	size_t size;
	atomic_t ref;
	unsigned int flags;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct bio bio;
	long: 64;
};

struct blkg_conf_ctx {
	char *input;
	char *body;
	struct block_device *bdev;
	struct blkcg_gq *blkg;
};

struct blkg_policy_data {
	struct blkcg_gq *blkg;
	int plid;
	bool online;
};

struct blkpg_ioctl_arg {
	int op;
	int flags;
	int datalen;
	void *data;
};

struct blkpg_partition {
	long long int start;
	long long int length;
	int pno;
	char devname[64];
	char volname[64];
};

typedef int (*report_zones_cb)(struct blk_zone *, unsigned int, void *);

struct hd_geometry;

struct pr_ops;

struct block_device_operations {
	void (*submit_bio)(struct bio *);
	int (*poll_bio)(struct bio *, struct io_comp_batch *, unsigned int);
	int (*open)(struct gendisk *, blk_mode_t);
	void (*release)(struct gendisk *);
	int (*ioctl)(struct block_device *, blk_mode_t, unsigned int, long unsigned int);
	int (*compat_ioctl)(struct block_device *, blk_mode_t, unsigned int, long unsigned int);
	unsigned int (*check_events)(struct gendisk *, unsigned int);
	void (*unlock_native_capacity)(struct gendisk *);
	int (*getgeo)(struct block_device *, struct hd_geometry *);
	int (*set_read_only)(struct block_device *, bool);
	void (*free_disk)(struct gendisk *);
	void (*swap_slot_free_notify)(struct block_device *, long unsigned int);
	int (*report_zones)(struct gendisk *, sector_t, unsigned int, report_zones_cb, void *);
	char * (*devnode)(struct gendisk *, umode_t *);
	int (*get_unique_id)(struct gendisk *, u8 *, enum blk_unique_id);
	struct module *owner;
	const struct pr_ops *pr_ops;
	int (*alternative_gpt_sector)(struct gendisk *, sector_t *);
};

struct blockgroup_lock {
	struct bgl_lock locks[128];
};

struct blocking_notifier_head {
	struct rw_semaphore rwsem;
	struct notifier_block *head;
};

struct mem_zone_bm_rtree;

struct rtree_node;

struct bm_position {
	struct mem_zone_bm_rtree *zone;
	struct rtree_node *node;
	long unsigned int node_pfn;
	long unsigned int cur_pfn;
	int node_bit;
};

struct bmp_header {
	u16 id;
	u32 size;
} __attribute__((packed));

struct boot_e820_entry {
	__u64 addr;
	__u64 size;
	__u32 type;
} __attribute__((packed));

struct screen_info {
	__u8 orig_x;
	__u8 orig_y;
	__u16 ext_mem_k;
	__u16 orig_video_page;
	__u8 orig_video_mode;
	__u8 orig_video_cols;
	__u8 flags;
	__u8 unused2;
	__u16 orig_video_ega_bx;
	__u16 unused3;
	__u8 orig_video_lines;
	__u8 orig_video_isVGA;
	__u16 orig_video_points;
	__u16 lfb_width;
	__u16 lfb_height;
	__u16 lfb_depth;
	__u32 lfb_base;
	__u32 lfb_size;
	__u16 cl_magic;
	__u16 cl_offset;
	__u16 lfb_linelength;
	__u8 red_size;
	__u8 red_pos;
	__u8 green_size;
	__u8 green_pos;
	__u8 blue_size;
	__u8 blue_pos;
	__u8 rsvd_size;
	__u8 rsvd_pos;
	__u16 vesapm_seg;
	__u16 vesapm_off;
	__u16 pages;
	__u16 vesa_attributes;
	__u32 capabilities;
	__u32 ext_lfb_base;
	__u8 _reserved[2];
} __attribute__((packed));

struct ist_info {
	__u32 signature;
	__u32 command;
	__u32 event;
	__u32 perf_level;
};

struct sys_desc_table {
	__u16 length;
	__u8 table[14];
};

struct olpc_ofw_header {
	__u32 ofw_magic;
	__u32 ofw_version;
	__u32 cif_handler;
	__u32 irq_desc_table;
};

struct edid_info {
	unsigned char dummy[128];
};

struct efi_info {
	__u32 efi_loader_signature;
	__u32 efi_systab;
	__u32 efi_memdesc_size;
	__u32 efi_memdesc_version;
	__u32 efi_memmap;
	__u32 efi_memmap_size;
	__u32 efi_systab_hi;
	__u32 efi_memmap_hi;
};

struct setup_header {
	__u8 setup_sects;
	__u16 root_flags;
	__u32 syssize;
	__u16 ram_size;
	__u16 vid_mode;
	__u16 root_dev;
	__u16 boot_flag;
	__u16 jump;
	__u32 header;
	__u16 version;
	__u32 realmode_swtch;
	__u16 start_sys_seg;
	__u16 kernel_version;
	__u8 type_of_loader;
	__u8 loadflags;
	__u16 setup_move_size;
	__u32 code32_start;
	__u32 ramdisk_image;
	__u32 ramdisk_size;
	__u32 bootsect_kludge;
	__u16 heap_end_ptr;
	__u8 ext_loader_ver;
	__u8 ext_loader_type;
	__u32 cmd_line_ptr;
	__u32 initrd_addr_max;
	__u32 kernel_alignment;
	__u8 relocatable_kernel;
	__u8 min_alignment;
	__u16 xloadflags;
	__u32 cmdline_size;
	__u32 hardware_subarch;
	__u64 hardware_subarch_data;
	__u32 payload_offset;
	__u32 payload_length;
	__u64 setup_data;
	__u64 pref_address;
	__u32 init_size;
	__u32 handover_offset;
	__u32 kernel_info_offset;
} __attribute__((packed));

struct edd_device_params {
	__u16 length;
	__u16 info_flags;
	__u32 num_default_cylinders;
	__u32 num_default_heads;
	__u32 sectors_per_track;
	__u64 number_of_sectors;
	__u16 bytes_per_sector;
	__u32 dpte_ptr;
	__u16 key;
	__u8 device_path_info_length;
	__u8 reserved2;
	__u16 reserved3;
	__u8 host_bus_type[4];
	__u8 interface_type[8];
	union {
		struct {
			__u16 base_address;
			__u16 reserved1;
			__u32 reserved2;
		} isa;
		struct {
			__u8 bus;
			__u8 slot;
			__u8 function;
			__u8 channel;
			__u32 reserved;
		} pci;
		struct {
			__u64 reserved;
		} ibnd;
		struct {
			__u64 reserved;
		} xprs;
		struct {
			__u64 reserved;
		} htpt;
		struct {
			__u64 reserved;
		} unknown;
	} interface_path;
	union {
		struct {
			__u8 device;
			__u8 reserved1;
			__u16 reserved2;
			__u32 reserved3;
			__u64 reserved4;
		} ata;
		struct {
			__u8 device;
			__u8 lun;
			__u8 reserved1;
			__u8 reserved2;
			__u32 reserved3;
			__u64 reserved4;
		} atapi;
		struct {
			__u16 id;
			__u64 lun;
			__u16 reserved1;
			__u32 reserved2;
		} __attribute__((packed)) scsi;
		struct {
			__u64 serial_number;
			__u64 reserved;
		} usb;
		struct {
			__u64 eui;
			__u64 reserved;
		} i1394;
		struct {
			__u64 wwid;
			__u64 lun;
		} fibre;
		struct {
			__u64 identity_tag;
			__u64 reserved;
		} i2o;
		struct {
			__u32 array_number;
			__u32 reserved1;
			__u64 reserved2;
		} raid;
		struct {
			__u8 device;
			__u8 reserved1;
			__u16 reserved2;
			__u32 reserved3;
			__u64 reserved4;
		} sata;
		struct {
			__u64 reserved1;
			__u64 reserved2;
		} unknown;
	} device_path;
	__u8 reserved4;
	__u8 checksum;
} __attribute__((packed));

struct edd_info {
	__u8 device;
	__u8 version;
	__u16 interface_support;
	__u16 legacy_max_cylinder;
	__u8 legacy_max_head;
	__u8 legacy_sectors_per_track;
	struct edd_device_params params;
};

struct boot_params {
	struct screen_info screen_info;
	struct apm_bios_info apm_bios_info;
	__u8 _pad2[4];
	__u64 tboot_addr;
	struct ist_info ist_info;
	__u64 acpi_rsdp_addr;
	__u8 _pad3[8];
	__u8 hd0_info[16];
	__u8 hd1_info[16];
	struct sys_desc_table sys_desc_table;
	struct olpc_ofw_header olpc_ofw_header;
	__u32 ext_ramdisk_image;
	__u32 ext_ramdisk_size;
	__u32 ext_cmd_line_ptr;
	__u8 _pad4[112];
	__u32 cc_blob_address;
	struct edid_info edid_info;
	struct efi_info efi_info;
	__u32 alt_mem_k;
	__u32 scratch;
	__u8 e820_entries;
	__u8 eddbuf_entries;
	__u8 edd_mbr_sig_buf_entries;
	__u8 kbd_status;
	__u8 secure_boot;
	__u8 _pad5[2];
	__u8 sentinel;
	__u8 _pad6[1];
	struct setup_header hdr;
	__u8 _pad7[36];
	__u32 edd_mbr_sig_buffer[16];
	struct boot_e820_entry e820_table[128];
	__u8 _pad8[48];
	struct edd_info eddbuf[6];
	__u8 _pad9[276];
};

struct boot_params_to_save {
	unsigned int start;
	unsigned int len;
};

struct boot_triggers {
	const char *event;
	char *trigger;
};

struct iphdr {
	__u8 ihl: 4;
	__u8 version: 4;
	__u8 tos;
	__be16 tot_len;
	__be16 id;
	__be16 frag_off;
	__u8 ttl;
	__u8 protocol;
	__sum16 check;
	union {
		struct {
			__be32 saddr;
			__be32 daddr;
		};
		struct {
			__be32 saddr;
			__be32 daddr;
		} addrs;
	};
};

struct udphdr {
	__be16 source;
	__be16 dest;
	__be16 len;
	__sum16 check;
};

struct bootp_pkt {
	struct iphdr iph;
	struct udphdr udph;
	u8 op;
	u8 htype;
	u8 hlen;
	u8 hops;
	__be32 xid;
	__be16 secs;
	__be16 flags;
	__be32 client_ip;
	__be32 your_ip;
	__be32 server_ip;
	__be32 relay_ip;
	u8 hw_addr[16];
	u8 serv_name[64];
	u8 boot_file[128];
	u8 exten[312];
};

struct bp_slots_histogram {
	atomic_t count[4];
};

struct bp_cpuinfo {
	unsigned int cpu_pinned;
	struct bp_slots_histogram tsk_pinned;
};

struct text_poke_loc;

struct bp_patching_desc {
	struct text_poke_loc *vec;
	int nr_entries;
	atomic_t refs;
};

struct bpf_map_ops;

struct btf_record;

struct btf;

struct btf_type;

struct bpf_map {
	const struct bpf_map_ops *ops;
	struct bpf_map *inner_map_meta;
	void *security;
	enum bpf_map_type map_type;
	u32 key_size;
	u32 value_size;
	u32 max_entries;
	u64 map_extra;
	u32 map_flags;
	u32 id;
	struct btf_record *record;
	int numa_node;
	u32 btf_key_type_id;
	u32 btf_value_type_id;
	u32 btf_vmlinux_value_type_id;
	struct btf *btf;
	char name[16];
	struct mutex freeze_mutex;
	atomic64_t refcnt;
	atomic64_t usercnt;
	union {
		struct work_struct work;
		struct callback_head rcu;
	};
	atomic64_t writecnt;
	struct {
		const struct btf_type *attach_func_proto;
		spinlock_t lock;
		enum bpf_prog_type type;
		bool jited;
		bool xdp_has_frags;
	} owner;
	bool bypass_spec_v1;
	bool frozen;
	bool free_after_mult_rcu_gp;
	bool free_after_rcu_gp;
	atomic64_t sleepable_refcnt;
	s64 *elem_count;
};

struct range_tree {
	struct rb_root_cached it_root;
	struct rb_root_cached range_size_root;
};

struct vm_struct;

struct bpf_arena {
	struct bpf_map map;
	u64 user_vm_start;
	u64 user_vm_end;
	struct vm_struct *kern_vm;
	struct range_tree rt;
	struct list_head vma_list;
	struct mutex lock;
};

struct bpf_array_aux;

struct bpf_array {
	struct bpf_map map;
	u32 elem_size;
	u32 index_mask;
	struct bpf_array_aux *aux;
	union {
		struct {
			struct {} __empty_value;
			char value[0];
		};
		struct {
			struct {} __empty_ptrs;
			void *ptrs[0];
		};
		struct {
			struct {} __empty_pptrs;
			void *pptrs[0];
		};
	};
};

struct bpf_array_aux {
	struct list_head poke_progs;
	struct bpf_map *map;
	struct mutex poke_mutex;
	struct work_struct work;
};

struct bpf_prog;

struct bpf_async_cb {
	struct bpf_map *map;
	struct bpf_prog *prog;
	void *callback_fn;
	void *value;
	union {
		struct callback_head rcu;
		struct work_struct delete_work;
	};
	u64 flags;
};

struct bpf_spin_lock {
	__u32 val;
};

struct bpf_hrtimer;

struct bpf_work;

struct bpf_async_kern {
	union {
		struct bpf_async_cb *cb;
		struct bpf_hrtimer *timer;
		struct bpf_work *work;
	};
	struct bpf_spin_lock lock;
};

struct btf_func_model {
	u8 ret_size;
	u8 ret_flags;
	u8 nr_args;
	u8 arg_size[12];
	u8 arg_flags[12];
};

struct bpf_attach_target_info {
	struct btf_func_model fmodel;
	long int tgt_addr;
	struct module *tgt_mod;
	const char *tgt_name;
	const struct btf_type *tgt_type;
};

union bpf_attr {
	struct {
		__u32 map_type;
		__u32 key_size;
		__u32 value_size;
		__u32 max_entries;
		__u32 map_flags;
		__u32 inner_map_fd;
		__u32 numa_node;
		char map_name[16];
		__u32 map_ifindex;
		__u32 btf_fd;
		__u32 btf_key_type_id;
		__u32 btf_value_type_id;
		__u32 btf_vmlinux_value_type_id;
		__u64 map_extra;
		__s32 value_type_btf_obj_fd;
		__s32 map_token_fd;
	};
	struct {
		__u32 map_fd;
		__u64 key;
		union {
			__u64 value;
			__u64 next_key;
		};
		__u64 flags;
	};
	struct {
		__u64 in_batch;
		__u64 out_batch;
		__u64 keys;
		__u64 values;
		__u32 count;
		__u32 map_fd;
		__u64 elem_flags;
		__u64 flags;
	} batch;
	struct {
		__u32 prog_type;
		__u32 insn_cnt;
		__u64 insns;
		__u64 license;
		__u32 log_level;
		__u32 log_size;
		__u64 log_buf;
		__u32 kern_version;
		__u32 prog_flags;
		char prog_name[16];
		__u32 prog_ifindex;
		__u32 expected_attach_type;
		__u32 prog_btf_fd;
		__u32 func_info_rec_size;
		__u64 func_info;
		__u32 func_info_cnt;
		__u32 line_info_rec_size;
		__u64 line_info;
		__u32 line_info_cnt;
		__u32 attach_btf_id;
		union {
			__u32 attach_prog_fd;
			__u32 attach_btf_obj_fd;
		};
		__u32 core_relo_cnt;
		__u64 fd_array;
		__u64 core_relos;
		__u32 core_relo_rec_size;
		__u32 log_true_size;
		__s32 prog_token_fd;
		__u32 fd_array_cnt;
	};
	struct {
		__u64 pathname;
		__u32 bpf_fd;
		__u32 file_flags;
		__s32 path_fd;
	};
	struct {
		union {
			__u32 target_fd;
			__u32 target_ifindex;
		};
		__u32 attach_bpf_fd;
		__u32 attach_type;
		__u32 attach_flags;
		__u32 replace_bpf_fd;
		union {
			__u32 relative_fd;
			__u32 relative_id;
		};
		__u64 expected_revision;
	};
	struct {
		__u32 prog_fd;
		__u32 retval;
		__u32 data_size_in;
		__u32 data_size_out;
		__u64 data_in;
		__u64 data_out;
		__u32 repeat;
		__u32 duration;
		__u32 ctx_size_in;
		__u32 ctx_size_out;
		__u64 ctx_in;
		__u64 ctx_out;
		__u32 flags;
		__u32 cpu;
		__u32 batch_size;
	} test;
	struct {
		union {
			__u32 start_id;
			__u32 prog_id;
			__u32 map_id;
			__u32 btf_id;
			__u32 link_id;
		};
		__u32 next_id;
		__u32 open_flags;
	};
	struct {
		__u32 bpf_fd;
		__u32 info_len;
		__u64 info;
	} info;
	struct {
		union {
			__u32 target_fd;
			__u32 target_ifindex;
		};
		__u32 attach_type;
		__u32 query_flags;
		__u32 attach_flags;
		__u64 prog_ids;
		union {
			__u32 prog_cnt;
			__u32 count;
		};
		__u64 prog_attach_flags;
		__u64 link_ids;
		__u64 link_attach_flags;
		__u64 revision;
	} query;
	struct {
		__u64 name;
		__u32 prog_fd;
		__u64 cookie;
	} raw_tracepoint;
	struct {
		__u64 btf;
		__u64 btf_log_buf;
		__u32 btf_size;
		__u32 btf_log_size;
		__u32 btf_log_level;
		__u32 btf_log_true_size;
		__u32 btf_flags;
		__s32 btf_token_fd;
	};
	struct {
		__u32 pid;
		__u32 fd;
		__u32 flags;
		__u32 buf_len;
		__u64 buf;
		__u32 prog_id;
		__u32 fd_type;
		__u64 probe_offset;
		__u64 probe_addr;
	} task_fd_query;
	struct {
		union {
			__u32 prog_fd;
			__u32 map_fd;
		};
		union {
			__u32 target_fd;
			__u32 target_ifindex;
		};
		__u32 attach_type;
		__u32 flags;
		union {
			__u32 target_btf_id;
			struct {
				__u64 iter_info;
				__u32 iter_info_len;
			};
			struct {
				__u64 bpf_cookie;
			} perf_event;
			struct {
				__u32 flags;
				__u32 cnt;
				__u64 syms;
				__u64 addrs;
				__u64 cookies;
			} kprobe_multi;
			struct {
				__u32 target_btf_id;
				__u64 cookie;
			} tracing;
			struct {
				__u32 pf;
				__u32 hooknum;
				__s32 priority;
				__u32 flags;
			} netfilter;
			struct {
				union {
					__u32 relative_fd;
					__u32 relative_id;
				};
				__u64 expected_revision;
			} tcx;
			struct {
				__u64 path;
				__u64 offsets;
				__u64 ref_ctr_offsets;
				__u64 cookies;
				__u32 cnt;
				__u32 flags;
				__u32 pid;
			} uprobe_multi;
			struct {
				union {
					__u32 relative_fd;
					__u32 relative_id;
				};
				__u64 expected_revision;
			} netkit;
		};
	} link_create;
	struct {
		__u32 link_fd;
		union {
			__u32 new_prog_fd;
			__u32 new_map_fd;
		};
		__u32 flags;
		union {
			__u32 old_prog_fd;
			__u32 old_map_fd;
		};
	} link_update;
	struct {
		__u32 link_fd;
	} link_detach;
	struct {
		__u32 type;
	} enable_stats;
	struct {
		__u32 link_fd;
		__u32 flags;
	} iter_create;
	struct {
		__u32 prog_fd;
		__u32 map_fd;
		__u32 flags;
	} prog_bind_map;
	struct {
		__u32 flags;
		__u32 bpffs_fd;
	} token_create;
};

struct bpf_bloom_filter {
	struct bpf_map map;
	u32 bitset_mask;
	u32 hash_seed;
	u32 nr_hash_funcs;
	long unsigned int bitset[0];
};

struct bpf_bprintf_buffers {
	char bin_args[512];
	char buf[1024];
};

struct bpf_bprintf_data {
	u32 *bin_args;
	char *buf;
	bool get_bin_args;
	bool get_buf;
};

struct bpf_btf_info {
	__u64 btf;
	__u32 btf_size;
	__u32 id;
	__u64 name;
	__u32 name_len;
	__u32 kernel_btf;
};

struct btf_field;

struct bpf_call_arg_meta {
	struct bpf_map *map_ptr;
	bool raw_mode;
	bool pkt_access;
	u8 release_regno;
	int regno;
	int access_size;
	int mem_size;
	u64 msize_max_value;
	int ref_obj_id;
	int dynptr_id;
	int map_uid;
	int func_id;
	struct btf *btf;
	u32 btf_id;
	struct btf *ret_btf;
	u32 ret_btf_id;
	u32 subprogno;
	struct btf_field *kptr_field;
	s64 const_map_key;
};

struct bpf_cand_cache {
	const char *name;
	u32 name_len;
	u16 kind;
	u16 cnt;
	struct {
		const struct btf *btf;
		u32 id;
	} cands[0];
};

struct bpf_run_ctx {};

struct bpf_prog_array_item;

struct bpf_cg_run_ctx {
	struct bpf_run_ctx run_ctx;
	const struct bpf_prog_array_item *prog_item;
	int retval;
};

struct bpf_lru_list {
	struct list_head lists[3];
	unsigned int counts[2];
	struct list_head *next_inactive_rotation;
	raw_spinlock_t lock;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct bpf_lru_locallist;

struct bpf_common_lru {
	struct bpf_lru_list lru_list;
	struct bpf_lru_locallist *local_list;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct bpf_core_accessor {
	__u32 type_id;
	__u32 idx;
	const char *name;
};

struct bpf_core_cand {
	const struct btf *btf;
	__u32 id;
};

struct bpf_core_cand_list {
	struct bpf_core_cand *cands;
	int len;
};

struct bpf_verifier_log;

struct bpf_core_ctx {
	struct bpf_verifier_log *log;
	const struct btf *btf;
};

struct bpf_core_relo {
	__u32 insn_off;
	__u32 type_id;
	__u32 access_str_off;
	enum bpf_core_relo_kind kind;
};

struct bpf_core_relo_res {
	__u64 orig_val;
	__u64 new_val;
	bool poison;
	bool validate;
	bool fail_memsz_adjust;
	__u32 orig_sz;
	__u32 orig_type_id;
	__u32 new_sz;
	__u32 new_type_id;
};

struct bpf_core_spec {
	const struct btf *btf;
	struct bpf_core_accessor spec[64];
	__u32 root_type_id;
	enum bpf_core_relo_kind relo_kind;
	int len;
	int raw_spec[64];
	int raw_len;
	__u32 bit_offset;
};

struct bpf_cpu_map_entry;

struct bpf_cpu_map {
	struct bpf_map map;
	struct bpf_cpu_map_entry **cpu_map;
};

struct bpf_cpumap_val {
	__u32 qsize;
	union {
		int fd;
		__u32 id;
	} bpf_prog;
};

struct xdp_bulk_queue;

struct ptr_ring;

struct bpf_cpu_map_entry {
	u32 cpu;
	int map_id;
	struct xdp_bulk_queue *bulkq;
	struct ptr_ring *queue;
	struct task_struct *kthread;
	struct bpf_cpumap_val value;
	struct bpf_prog *prog;
	struct completion kthread_running;
	struct rcu_work free_work;
};

struct bpf_crypto_type;

struct bpf_crypto_ctx {
	const struct bpf_crypto_type *type;
	void *tfm;
	u32 siv_len;
	struct callback_head rcu;
	refcount_t usage;
};

struct bpf_crypto_params {
	char type[14];
	u8 reserved[2];
	char algo[128];
	u8 key[256];
	u32 key_len;
	u32 authsize;
};

struct bpf_crypto_type {
	void * (*alloc_tfm)(const char *);
	void (*free_tfm)(void *);
	int (*has_algo)(const char *);
	int (*setkey)(void *, const u8 *, unsigned int);
	int (*setauthsize)(void *, unsigned int);
	int (*encrypt)(void *, const u8 *, u8 *, unsigned int, u8 *);
	int (*decrypt)(void *, const u8 *, u8 *, unsigned int, u8 *);
	unsigned int (*ivsize)(void *);
	unsigned int (*statesize)(void *);
	u32 (*get_flags)(void *);
	struct module *owner;
	char name[14];
};

struct bpf_crypto_type_list {
	const struct bpf_crypto_type *type;
	struct list_head list;
};

struct bpf_ct_opts {
	s32 netns_id;
	s32 error;
	u8 l4proto;
	u8 dir;
	u16 ct_zone_id;
	u8 ct_zone_dir;
	u8 reserved[3];
};

struct bpf_ctx_arg_aux {
	u32 offset;
	enum bpf_reg_type reg_type;
	struct btf *btf;
	u32 btf_id;
};

struct skb_ext;

struct sk_buff {
	union {
		struct {
			struct sk_buff *next;
			struct sk_buff *prev;
			union {
				struct net_device *dev;
				long unsigned int dev_scratch;
			};
		};
		struct rb_node rbnode;
		struct list_head list;
		struct llist_node ll_node;
	};
	struct sock *sk;
	union {
		ktime_t tstamp;
		u64 skb_mstamp_ns;
	};
	char cb[48];
	union {
		struct {
			long unsigned int _skb_refdst;
			void (*destructor)(struct sk_buff *);
		};
		struct list_head tcp_tsorted_anchor;
		long unsigned int _sk_redir;
	};
	long unsigned int _nfct;
	unsigned int len;
	unsigned int data_len;
	__u16 mac_len;
	__u16 hdr_len;
	__u16 queue_mapping;
	__u8 __cloned_offset[0];
	__u8 cloned: 1;
	__u8 nohdr: 1;
	__u8 fclone: 2;
	__u8 peeked: 1;
	__u8 head_frag: 1;
	__u8 pfmemalloc: 1;
	__u8 pp_recycle: 1;
	__u8 active_extensions;
	union {
		struct {
			__u8 __pkt_type_offset[0];
			__u8 pkt_type: 3;
			__u8 ignore_df: 1;
			__u8 dst_pending_confirm: 1;
			__u8 ip_summed: 2;
			__u8 ooo_okay: 1;
			__u8 __mono_tc_offset[0];
			__u8 tstamp_type: 2;
			__u8 tc_at_ingress: 1;
			__u8 tc_skip_classify: 1;
			__u8 remcsum_offload: 1;
			__u8 csum_complete_sw: 1;
			__u8 csum_level: 2;
			__u8 inner_protocol_type: 1;
			__u8 l4_hash: 1;
			__u8 sw_hash: 1;
			__u8 wifi_acked_valid: 1;
			__u8 wifi_acked: 1;
			__u8 no_fcs: 1;
			__u8 encapsulation: 1;
			__u8 encap_hdr_csum: 1;
			__u8 csum_valid: 1;
			__u8 ndisc_nodetype: 2;
			__u8 redirected: 1;
			__u8 nf_skip_egress: 1;
			__u8 slow_gro: 1;
			__u8 unreadable: 1;
			__u16 tc_index;
			u16 alloc_cpu;
			union {
				__wsum csum;
				struct {
					__u16 csum_start;
					__u16 csum_offset;
				};
			};
			__u32 priority;
			int skb_iif;
			__u32 hash;
			union {
				u32 vlan_all;
				struct {
					__be16 vlan_proto;
					__u16 vlan_tci;
				};
			};
			union {
				unsigned int napi_id;
				unsigned int sender_cpu;
			};
			__u32 secmark;
			union {
				__u32 mark;
				__u32 reserved_tailroom;
			};
			union {
				__be16 inner_protocol;
				__u8 inner_ipproto;
			};
			__u16 inner_transport_header;
			__u16 inner_network_header;
			__u16 inner_mac_header;
			__be16 protocol;
			__u16 transport_header;
			__u16 network_header;
			__u16 mac_header;
		};
		struct {
			__u8 __pkt_type_offset[0];
			__u8 pkt_type: 3;
			__u8 ignore_df: 1;
			__u8 dst_pending_confirm: 1;
			__u8 ip_summed: 2;
			__u8 ooo_okay: 1;
			__u8 __mono_tc_offset[0];
			__u8 tstamp_type: 2;
			__u8 tc_at_ingress: 1;
			__u8 tc_skip_classify: 1;
			__u8 remcsum_offload: 1;
			__u8 csum_complete_sw: 1;
			__u8 csum_level: 2;
			__u8 inner_protocol_type: 1;
			__u8 l4_hash: 1;
			__u8 sw_hash: 1;
			__u8 wifi_acked_valid: 1;
			__u8 wifi_acked: 1;
			__u8 no_fcs: 1;
			__u8 encapsulation: 1;
			__u8 encap_hdr_csum: 1;
			__u8 csum_valid: 1;
			__u8 ndisc_nodetype: 2;
			__u8 redirected: 1;
			__u8 nf_skip_egress: 1;
			__u8 slow_gro: 1;
			__u8 unreadable: 1;
			__u16 tc_index;
			u16 alloc_cpu;
			union {
				__wsum csum;
				struct {
					__u16 csum_start;
					__u16 csum_offset;
				};
			};
			__u32 priority;
			int skb_iif;
			__u32 hash;
			union {
				u32 vlan_all;
				struct {
					__be16 vlan_proto;
					__u16 vlan_tci;
				};
			};
			union {
				unsigned int napi_id;
				unsigned int sender_cpu;
			};
			__u32 secmark;
			union {
				__u32 mark;
				__u32 reserved_tailroom;
			};
			union {
				__be16 inner_protocol;
				__u8 inner_ipproto;
			};
			__u16 inner_transport_header;
			__u16 inner_network_header;
			__u16 inner_mac_header;
			__be16 protocol;
			__u16 transport_header;
			__u16 network_header;
			__u16 mac_header;
		} headers;
	};
	sk_buff_data_t tail;
	sk_buff_data_t end;
	unsigned char *head;
	unsigned char *data;
	unsigned int truesize;
	refcount_t users;
	struct skb_ext *extensions;
};

struct xdp_md {
	__u32 data;
	__u32 data_end;
	__u32 data_meta;
	__u32 ingress_ifindex;
	__u32 rx_queue_index;
	__u32 egress_ifindex;
};

struct xdp_rxq_info;

struct xdp_txq_info;

struct xdp_buff {
	void *data;
	void *data_end;
	void *data_meta;
	void *data_hard_start;
	struct xdp_rxq_info *rxq;
	struct xdp_txq_info *txq;
	u32 frame_sz;
	u32 flags;
};

struct bpf_sock_ops {
	__u32 op;
	union {
		__u32 args[4];
		__u32 reply;
		__u32 replylong[4];
	};
	__u32 family;
	__u32 remote_ip4;
	__u32 local_ip4;
	__u32 remote_ip6[4];
	__u32 local_ip6[4];
	__u32 remote_port;
	__u32 local_port;
	__u32 is_fullsock;
	__u32 snd_cwnd;
	__u32 srtt_us;
	__u32 bpf_sock_ops_cb_flags;
	__u32 state;
	__u32 rtt_min;
	__u32 snd_ssthresh;
	__u32 rcv_nxt;
	__u32 snd_nxt;
	__u32 snd_una;
	__u32 mss_cache;
	__u32 ecn_flags;
	__u32 rate_delivered;
	__u32 rate_interval_us;
	__u32 packets_out;
	__u32 retrans_out;
	__u32 total_retrans;
	__u32 segs_in;
	__u32 data_segs_in;
	__u32 segs_out;
	__u32 data_segs_out;
	__u32 lost_out;
	__u32 sacked_out;
	__u32 sk_txhash;
	__u64 bytes_received;
	__u64 bytes_acked;
	union {
		struct bpf_sock *sk;
	};
	union {
		void *skb_data;
	};
	union {
		void *skb_data_end;
	};
	__u32 skb_len;
	__u32 skb_tcp_flags;
	__u64 skb_hwtstamp;
};

struct bpf_sock_ops_kern {
	struct sock *sk;
	union {
		u32 args[4];
		u32 reply;
		u32 replylong[4];
	};
	struct sk_buff *syn_skb;
	struct sk_buff *skb;
	void *skb_data_end;
	u8 op;
	u8 is_fullsock;
	u8 remaining_opt_len;
	u64 temp;
};

struct sk_msg_md {
	union {
		void *data;
	};
	union {
		void *data_end;
	};
	__u32 family;
	__u32 remote_ip4;
	__u32 local_ip4;
	__u32 remote_ip6[4];
	__u32 local_ip6[4];
	__u32 remote_port;
	__u32 local_port;
	__u32 size;
	union {
		struct bpf_sock *sk;
	};
};

struct sk_msg_sg {
	u32 start;
	u32 curr;
	u32 end;
	u32 size;
	u32 copybreak;
	long unsigned int copy[1];
	struct scatterlist data[19];
};

struct sk_msg {
	struct sk_msg_sg sg;
	void *data;
	void *data_end;
	u32 apply_bytes;
	u32 cork_bytes;
	u32 flags;
	struct sk_buff *skb;
	struct sock *sk_redir;
	struct sock *sk;
	struct list_head list;
};

struct bpf_flow_dissector {
	struct bpf_flow_keys *flow_keys;
	const struct sk_buff *skb;
	const void *data;
	const void *data_end;
};

struct fred_cs {
	u64 cs: 16;
	u64 sl: 2;
	u64 wfe: 1;
};

struct fred_ss {
	u64 ss: 16;
	u64 sti: 1;
	u64 swevent: 1;
	u64 nmi: 1;
	int: 13;
	u64 vector: 8;
	short: 8;
	u64 type: 4;
	char: 4;
	u64 enclave: 1;
	u64 lm: 1;
	u64 nested: 1;
	char: 1;
	u64 insnlen: 4;
};

struct pt_regs {
	long unsigned int r15;
	long unsigned int r14;
	long unsigned int r13;
	long unsigned int r12;
	long unsigned int bp;
	long unsigned int bx;
	long unsigned int r11;
	long unsigned int r10;
	long unsigned int r9;
	long unsigned int r8;
	long unsigned int ax;
	long unsigned int cx;
	long unsigned int dx;
	long unsigned int si;
	long unsigned int di;
	long unsigned int orig_ax;
	long unsigned int ip;
	union {
		u16 cs;
		u64 csx;
		struct fred_cs fred_cs;
	};
	long unsigned int flags;
	long unsigned int sp;
	union {
		u16 ss;
		u64 ssx;
		struct fred_ss fred_ss;
	};
};

typedef struct pt_regs bpf_user_pt_regs_t;

struct bpf_perf_event_data {
	bpf_user_pt_regs_t regs;
	__u64 sample_period;
	__u64 addr;
};

struct perf_sample_data;

struct bpf_perf_event_data_kern {
	bpf_user_pt_regs_t *regs;
	struct perf_sample_data *data;
	struct perf_event *event;
};

struct bpf_raw_tracepoint_args {
	__u64 args[0];
};

struct sk_reuseport_md {
	union {
		void *data;
	};
	union {
		void *data_end;
	};
	__u32 len;
	__u32 eth_protocol;
	__u32 ip_protocol;
	__u32 bind_inany;
	__u32 hash;
	union {
		struct bpf_sock *sk;
	};
	union {
		struct bpf_sock *migrating_sk;
	};
};

struct sk_reuseport_kern {
	struct sk_buff *skb;
	struct sock *sk;
	struct sock *selected_sk;
	struct sock *migrating_sk;
	void *data_end;
	u32 hash;
	u32 reuseport_id;
	bool bind_inany;
};

struct bpf_sk_lookup {
	union {
		union {
			struct bpf_sock *sk;
		};
		__u64 cookie;
	};
	__u32 family;
	__u32 protocol;
	__u32 remote_ip4;
	__u32 remote_ip6[4];
	__be16 remote_port;
	__u32 local_ip4;
	__u32 local_ip6[4];
	__u32 local_port;
	__u32 ingress_ifindex;
};

struct bpf_sk_lookup_kern {
	u16 family;
	u16 protocol;
	__be16 sport;
	u16 dport;
	struct {
		__be32 saddr;
		__be32 daddr;
	} v4;
	struct {
		const struct in6_addr *saddr;
		const struct in6_addr *daddr;
	} v6;
	struct sock *selected_sk;
	u32 ingress_ifindex;
	bool no_reuseport;
};

struct nf_hook_state;

struct bpf_nf_ctx {
	const struct nf_hook_state *state;
	struct sk_buff *skb;
};

struct bpf_ctx_convert {
	struct __sk_buff BPF_PROG_TYPE_SOCKET_FILTER_prog;
	struct sk_buff BPF_PROG_TYPE_SOCKET_FILTER_kern;
	struct __sk_buff BPF_PROG_TYPE_SCHED_CLS_prog;
	struct sk_buff BPF_PROG_TYPE_SCHED_CLS_kern;
	struct __sk_buff BPF_PROG_TYPE_SCHED_ACT_prog;
	struct sk_buff BPF_PROG_TYPE_SCHED_ACT_kern;
	struct xdp_md BPF_PROG_TYPE_XDP_prog;
	struct xdp_buff BPF_PROG_TYPE_XDP_kern;
	struct __sk_buff BPF_PROG_TYPE_LWT_IN_prog;
	struct sk_buff BPF_PROG_TYPE_LWT_IN_kern;
	struct __sk_buff BPF_PROG_TYPE_LWT_OUT_prog;
	struct sk_buff BPF_PROG_TYPE_LWT_OUT_kern;
	struct __sk_buff BPF_PROG_TYPE_LWT_XMIT_prog;
	struct sk_buff BPF_PROG_TYPE_LWT_XMIT_kern;
	struct __sk_buff BPF_PROG_TYPE_LWT_SEG6LOCAL_prog;
	struct sk_buff BPF_PROG_TYPE_LWT_SEG6LOCAL_kern;
	struct bpf_sock_ops BPF_PROG_TYPE_SOCK_OPS_prog;
	struct bpf_sock_ops_kern BPF_PROG_TYPE_SOCK_OPS_kern;
	struct __sk_buff BPF_PROG_TYPE_SK_SKB_prog;
	struct sk_buff BPF_PROG_TYPE_SK_SKB_kern;
	struct sk_msg_md BPF_PROG_TYPE_SK_MSG_prog;
	struct sk_msg BPF_PROG_TYPE_SK_MSG_kern;
	struct __sk_buff BPF_PROG_TYPE_FLOW_DISSECTOR_prog;
	struct bpf_flow_dissector BPF_PROG_TYPE_FLOW_DISSECTOR_kern;
	bpf_user_pt_regs_t BPF_PROG_TYPE_KPROBE_prog;
	struct pt_regs BPF_PROG_TYPE_KPROBE_kern;
	__u64 BPF_PROG_TYPE_TRACEPOINT_prog;
	u64 BPF_PROG_TYPE_TRACEPOINT_kern;
	struct bpf_perf_event_data BPF_PROG_TYPE_PERF_EVENT_prog;
	struct bpf_perf_event_data_kern BPF_PROG_TYPE_PERF_EVENT_kern;
	struct bpf_raw_tracepoint_args BPF_PROG_TYPE_RAW_TRACEPOINT_prog;
	u64 BPF_PROG_TYPE_RAW_TRACEPOINT_kern;
	struct bpf_raw_tracepoint_args BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE_prog;
	u64 BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE_kern;
	void *BPF_PROG_TYPE_TRACING_prog;
	void *BPF_PROG_TYPE_TRACING_kern;
	struct sk_reuseport_md BPF_PROG_TYPE_SK_REUSEPORT_prog;
	struct sk_reuseport_kern BPF_PROG_TYPE_SK_REUSEPORT_kern;
	struct bpf_sk_lookup BPF_PROG_TYPE_SK_LOOKUP_prog;
	struct bpf_sk_lookup_kern BPF_PROG_TYPE_SK_LOOKUP_kern;
	void *BPF_PROG_TYPE_SYSCALL_prog;
	void *BPF_PROG_TYPE_SYSCALL_kern;
	struct bpf_nf_ctx BPF_PROG_TYPE_NETFILTER_prog;
	struct bpf_nf_ctx BPF_PROG_TYPE_NETFILTER_kern;
};

struct bpf_devmap_val {
	__u32 ifindex;
	union {
		int fd;
		__u32 id;
	} bpf_prog;
};

struct bpf_dispatcher_prog {
	struct bpf_prog *prog;
	refcount_t users;
};

struct latch_tree_node {
	struct rb_node node[2];
};

struct bpf_ksym {
	long unsigned int start;
	long unsigned int end;
	char name[512];
	struct list_head lnode;
	struct latch_tree_node tnode;
	bool prog;
};

struct static_call_key;

struct bpf_dispatcher {
	struct mutex mutex;
	void *func;
	struct bpf_dispatcher_prog progs[48];
	int num_progs;
	void *image;
	void *rw_image;
	u32 image_off;
	struct bpf_ksym ksym;
	struct static_call_key *sc_key;
	void *sc_tramp;
};

struct bpf_dtab_netdev;

struct bpf_dtab {
	struct bpf_map map;
	struct bpf_dtab_netdev **netdev_map;
	struct list_head list;
	struct hlist_head *dev_index_head;
	spinlock_t index_lock;
	unsigned int items;
	u32 n_buckets;
};

struct bpf_dtab_netdev {
	struct net_device *dev;
	struct hlist_node index_hlist;
	struct bpf_prog *xdp_prog;
	struct callback_head rcu;
	unsigned int idx;
	struct bpf_devmap_val val;
};

struct bpf_dynptr {
	__u64 __opaque[2];
};

struct bpf_dynptr_kern {
	void *data;
	u32 size;
	u32 offset;
};

struct bpf_cgroup_storage;

struct bpf_prog_array_item {
	struct bpf_prog *prog;
	union {
		struct bpf_cgroup_storage *cgroup_storage[2];
		u64 bpf_cookie;
	};
};

struct bpf_prog_array {
	struct callback_head rcu;
	struct bpf_prog_array_item items[0];
};

struct bpf_empty_prog_array {
	struct bpf_prog_array hdr;
	struct bpf_prog *null_prog;
};

struct bpf_event_entry {
	struct perf_event *event;
	struct file *perf_file;
	struct file *map_file;
	struct callback_head rcu;
};

struct bpf_fentry_test_t {
	struct bpf_fentry_test_t *a;
};

struct bpf_fib_lookup {
	__u8 family;
	__u8 l4_protocol;
	__be16 sport;
	__be16 dport;
	union {
		__u16 tot_len;
		__u16 mtu_result;
	};
	__u32 ifindex;
	union {
		__u8 tos;
		__be32 flowinfo;
		__u32 rt_metric;
	};
	union {
		__be32 ipv4_src;
		__u32 ipv6_src[4];
	};
	union {
		__be32 ipv4_dst;
		__u32 ipv6_dst[4];
	};
	union {
		struct {
			__be16 h_vlan_proto;
			__be16 h_vlan_TCI;
		};
		__u32 tbid;
	};
	union {
		struct {
			__u32 mark;
		};
		struct {
			__u8 smac[6];
			__u8 dmac[6];
		};
	};
};

struct bpf_flow_keys {
	__u16 nhoff;
	__u16 thoff;
	__u16 addr_proto;
	__u8 is_frag;
	__u8 is_first_frag;
	__u8 is_encap;
	__u8 ip_proto;
	__be16 n_proto;
	__be16 sport;
	__be16 dport;
	union {
		struct {
			__be32 ipv4_src;
			__be32 ipv4_dst;
		};
		struct {
			__u32 ipv6_src[4];
			__u32 ipv6_dst[4];
		};
	};
	__u32 flags;
	__be32 flow_label;
};

struct bpf_func_info {
	__u32 insn_off;
	__u32 type_id;
};

struct bpf_func_info_aux {
	u16 linkage;
	bool unreliable;
	bool called: 1;
	bool verified: 1;
};

struct bpf_func_proto {
	u64 (*func)(u64, u64, u64, u64, u64);
	bool gpl_only;
	bool pkt_access;
	bool might_sleep;
	bool allow_fastcall;
	enum bpf_return_type ret_type;
	union {
		struct {
			enum bpf_arg_type arg1_type;
			enum bpf_arg_type arg2_type;
			enum bpf_arg_type arg3_type;
			enum bpf_arg_type arg4_type;
			enum bpf_arg_type arg5_type;
		};
		enum bpf_arg_type arg_type[5];
	};
	union {
		struct {
			u32 *arg1_btf_id;
			u32 *arg2_btf_id;
			u32 *arg3_btf_id;
			u32 *arg4_btf_id;
			u32 *arg5_btf_id;
		};
		u32 *arg_btf_id[5];
		struct {
			size_t arg1_size;
			size_t arg2_size;
			size_t arg3_size;
			size_t arg4_size;
			size_t arg5_size;
		};
		size_t arg_size[5];
	};
	int *ret_btf_id;
	bool (*allowed)(const struct bpf_prog *);
};

struct tnum {
	u64 value;
	u64 mask;
};

struct bpf_reg_state {
	enum bpf_reg_type type;
	s32 off;
	union {
		int range;
		struct {
			struct bpf_map *map_ptr;
			u32 map_uid;
		};
		struct {
			struct btf *btf;
			u32 btf_id;
		};
		struct {
			u32 mem_size;
			u32 dynptr_id;
		};
		struct {
			enum bpf_dynptr_type type;
			bool first_slot;
		} dynptr;
		struct {
			struct btf *btf;
			u32 btf_id;
			enum bpf_iter_state state: 2;
			int depth: 30;
		} iter;
		struct {
			long unsigned int raw1;
			long unsigned int raw2;
		} raw;
		u32 subprogno;
	};
	struct tnum var_off;
	s64 smin_value;
	s64 smax_value;
	u64 umin_value;
	u64 umax_value;
	s32 s32_min_value;
	s32 s32_max_value;
	u32 u32_min_value;
	u32 u32_max_value;
	u32 id;
	u32 ref_obj_id;
	struct bpf_reg_state *parent;
	u32 frameno;
	s32 subreg_def;
	enum bpf_reg_liveness live;
	bool precise;
};

struct bpf_retval_range {
	s32 minval;
	s32 maxval;
};

struct bpf_stack_state;

struct bpf_func_state {
	struct bpf_reg_state regs[11];
	int callsite;
	u32 frameno;
	u32 subprogno;
	u32 async_entry_cnt;
	struct bpf_retval_range callback_ret_range;
	bool in_callback_fn;
	bool in_async_callback_fn;
	bool in_exception_callback_fn;
	u32 callback_depth;
	struct bpf_stack_state *stack;
	int allocated_stack;
};

struct bpf_hrtimer {
	struct bpf_async_cb cb;
	struct hrtimer timer;
	atomic_t cancelling;
};

struct obj_cgroup;

struct bpf_mem_caches;

struct bpf_mem_cache;

struct bpf_mem_alloc {
	struct bpf_mem_caches *caches;
	struct bpf_mem_cache *cache;
	struct obj_cgroup *objcg;
	bool percpu;
	struct work_struct work;
};

struct pcpu_freelist_node;

struct pcpu_freelist_head {
	struct pcpu_freelist_node *first;
	raw_spinlock_t lock;
};

struct pcpu_freelist {
	struct pcpu_freelist_head *freelist;
	struct pcpu_freelist_head extralist;
};

struct bpf_lru_node;

typedef bool (*del_from_htab_func)(void *, struct bpf_lru_node *);

struct bpf_lru {
	union {
		struct bpf_common_lru common_lru;
		struct bpf_lru_list *percpu_lru;
	};
	del_from_htab_func del_from_htab;
	void *del_arg;
	unsigned int hash_offset;
	unsigned int nr_scans;
	bool percpu;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct bucket;

struct htab_elem;

struct bpf_htab {
	struct bpf_map map;
	struct bpf_mem_alloc ma;
	struct bpf_mem_alloc pcpu_ma;
	struct bucket *buckets;
	void *elems;
	union {
		struct pcpu_freelist freelist;
		struct bpf_lru lru;
	};
	struct htab_elem **extra_elems;
	struct percpu_counter pcount;
	atomic_t count;
	bool use_percpu_counter;
	u32 n_buckets;
	u32 elem_size;
	u32 hashrnd;
	struct lock_class_key lockdep_key;
	int *map_locked[8];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct bpf_id_pair {
	u32 old;
	u32 cur;
};

struct bpf_idmap {
	u32 tmp_id_gen;
	struct bpf_id_pair map[600];
};

struct bpf_idset {
	u32 count;
	u32 ids[600];
};

struct bpf_insn {
	__u8 code;
	__u8 dst_reg: 4;
	__u8 src_reg: 4;
	__s16 off;
	__s32 imm;
};

struct bpf_insn_access_aux {
	enum bpf_reg_type reg_type;
	bool is_ldsx;
	union {
		int ctx_field_size;
		struct {
			struct btf *btf;
			u32 btf_id;
		};
	};
	struct bpf_verifier_log *log;
	bool is_retval;
};

struct bpf_map_ptr_state {
	struct bpf_map *map_ptr;
	bool poison;
	bool unpriv;
};

struct bpf_loop_inline_state {
	unsigned int initialized: 1;
	unsigned int fit_for_inline: 1;
	u32 callback_subprogno;
};

struct btf_struct_meta;

struct bpf_insn_aux_data {
	union {
		enum bpf_reg_type ptr_type;
		struct bpf_map_ptr_state map_ptr_state;
		s32 call_imm;
		u32 alu_limit;
		struct {
			u32 map_index;
			u32 map_off;
		};
		struct {
			enum bpf_reg_type reg_type;
			union {
				struct {
					struct btf *btf;
					u32 btf_id;
				};
				u32 mem_size;
			};
		} btf_var;
		struct bpf_loop_inline_state loop_inline_state;
	};
	union {
		u64 obj_new_size;
		u64 insert_off;
	};
	struct btf_struct_meta *kptr_struct_meta;
	u64 map_key_state;
	int ctx_field_size;
	u32 seen;
	bool sanitize_stack_spill;
	bool zext_dst;
	bool needs_zext;
	bool storage_get_func_atomic;
	bool is_iter_next;
	bool call_with_percpu_alloc_ptr;
	u8 alu_state;
	u8 fastcall_pattern: 1;
	u8 fastcall_spills_num: 3;
	unsigned int orig_idx;
	bool jmp_point;
	bool prune_point;
	bool force_checkpoint;
	bool calls_callback;
};

typedef void (*bpf_insn_print_t)(void *, const char *, ...);

typedef const char * (*bpf_insn_revmap_call_t)(void *, const struct bpf_insn *);

typedef const char * (*bpf_insn_print_imm_t)(void *, const struct bpf_insn *, __u64);

struct bpf_insn_cbs {
	bpf_insn_print_t cb_print;
	bpf_insn_revmap_call_t cb_call;
	bpf_insn_print_imm_t cb_imm;
	void *private_data;
};

struct bpf_insn_hist_entry {
	u32 idx;
	u32 prev_idx: 22;
	u32 flags: 10;
	u64 linked_regs;
};

struct bpf_iter_meta;

struct bpf_link;

struct bpf_iter__bpf_link {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct bpf_link *link;
	};
};

struct bpf_iter__bpf_map {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct bpf_map *map;
	};
};

struct bpf_iter__bpf_map_elem {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct bpf_map *map;
	};
	union {
		void *key;
	};
	union {
		void *value;
	};
};

struct bpf_iter__bpf_prog {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct bpf_prog *prog;
	};
};

struct bpf_iter__bpf_sk_storage_map {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct bpf_map *map;
	};
	union {
		struct sock *sk;
	};
	union {
		void *value;
	};
};

struct bpf_iter__cgroup {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct cgroup *cgroup;
	};
};

struct fib6_info;

struct bpf_iter__ipv6_route {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct fib6_info *rt;
	};
};

struct bpf_iter__kmem_cache {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct kmem_cache *s;
	};
};

struct kallsym_iter;

struct bpf_iter__ksym {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct kallsym_iter *ksym;
	};
};

struct netlink_sock;

struct bpf_iter__netlink {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct netlink_sock *sk;
	};
};

struct bpf_iter__sockmap {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct bpf_map *map;
	};
	union {
		void *key;
	};
	union {
		struct sock *sk;
	};
};

struct bpf_iter__task {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct task_struct *task;
	};
};

struct bpf_iter__task__safe_trusted {
	struct bpf_iter_meta *meta;
	struct task_struct *task;
};

struct bpf_iter__task_file {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct task_struct *task;
	};
	u32 fd;
	union {
		struct file *file;
	};
};

struct bpf_iter__task_vma {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct task_struct *task;
	};
	union {
		struct vm_area_struct *vma;
	};
};

struct sock_common;

struct bpf_iter__tcp {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct sock_common *sk_common;
	};
	uid_t uid;
};

struct udp_sock;

struct bpf_iter__udp {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct udp_sock *udp_sk;
	};
	uid_t uid;
	long: 0;
	int bucket;
};

struct unix_sock;

struct bpf_iter__unix {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct unix_sock *unix_sk;
	};
	uid_t uid;
};

struct bpf_iter_aux_info {
	struct bpf_map *map;
	struct {
		struct cgroup *start;
		enum bpf_cgroup_iter_order order;
	} cgroup;
	struct {
		enum bpf_iter_task_type type;
		u32 pid;
	} task;
};

struct bpf_iter_bits {
	__u64 __opaque[2];
};

struct bpf_iter_bits_kern {
	union {
		__u64 *bits;
		__u64 bits_copy;
	};
	int nr_bits;
	int bit;
};

struct bpf_iter_css {
	__u64 __opaque[3];
};

struct bpf_iter_css_kern {
	struct cgroup_subsys_state *start;
	struct cgroup_subsys_state *pos;
	unsigned int flags;
};

struct bpf_iter_css_task {
	__u64 __opaque[1];
};

struct css_task_iter;

struct bpf_iter_css_task_kern {
	struct css_task_iter *css_it;
};

struct bpf_iter_kmem_cache {
	__u64 __opaque[1];
};

struct bpf_iter_kmem_cache_kern {
	struct kmem_cache *pos;
};

struct bpf_link_ops;

struct bpf_link {
	atomic64_t refcnt;
	u32 id;
	enum bpf_link_type type;
	const struct bpf_link_ops *ops;
	struct bpf_prog *prog;
	bool sleepable;
	union {
		struct callback_head rcu;
		struct work_struct work;
	};
};

struct bpf_iter_target_info;

struct bpf_iter_link {
	struct bpf_link link;
	struct bpf_iter_aux_info aux;
	struct bpf_iter_target_info *tinfo;
};

union bpf_iter_link_info {
	struct {
		__u32 map_fd;
	} map;
	struct {
		enum bpf_cgroup_iter_order order;
		__u32 cgroup_fd;
		__u64 cgroup_id;
	} cgroup;
	struct {
		__u32 tid;
		__u32 pid;
		__u32 pid_fd;
	} task;
};

struct bpf_iter_meta {
	union {
		struct seq_file *seq;
	};
	u64 session_id;
	u64 seq_num;
};

struct bpf_iter_meta__safe_trusted {
	struct seq_file *seq;
};

struct bpf_iter_num {
	__u64 __opaque[1];
};

struct bpf_iter_num_kern {
	int cur;
	int end;
};

struct bpf_iter_seq_info;

struct bpf_iter_priv_data {
	struct bpf_iter_target_info *tinfo;
	const struct bpf_iter_seq_info *seq_info;
	struct bpf_prog *prog;
	u64 session_id;
	u64 seq_num;
	bool done_stop;
	long: 0;
	u8 target_private[0];
};

typedef int (*bpf_iter_attach_target_t)(struct bpf_prog *, union bpf_iter_link_info *, struct bpf_iter_aux_info *);

typedef void (*bpf_iter_detach_target_t)(struct bpf_iter_aux_info *);

typedef void (*bpf_iter_show_fdinfo_t)(const struct bpf_iter_aux_info *, struct seq_file *);

struct bpf_link_info;

typedef int (*bpf_iter_fill_link_info_t)(const struct bpf_iter_aux_info *, struct bpf_link_info *);

typedef const struct bpf_func_proto * (*bpf_iter_get_func_proto_t)(enum bpf_func_id, const struct bpf_prog *);

struct bpf_iter_reg {
	const char *target;
	bpf_iter_attach_target_t attach_target;
	bpf_iter_detach_target_t detach_target;
	bpf_iter_show_fdinfo_t show_fdinfo;
	bpf_iter_fill_link_info_t fill_link_info;
	bpf_iter_get_func_proto_t get_func_proto;
	u32 ctx_arg_info_size;
	u32 feature;
	struct bpf_ctx_arg_aux ctx_arg_info[2];
	const struct bpf_iter_seq_info *seq_info;
};

struct bpf_iter_seq_array_map_info {
	struct bpf_map *map;
	void *percpu_value_buf;
	u32 index;
};

struct bpf_iter_seq_hash_map_info {
	struct bpf_map *map;
	struct bpf_htab *htab;
	void *percpu_value_buf;
	u32 bucket_id;
	u32 skip_elems;
};

typedef int (*bpf_iter_init_seq_priv_t)(void *, struct bpf_iter_aux_info *);

typedef void (*bpf_iter_fini_seq_priv_t)(void *);

struct bpf_iter_seq_info {
	const struct seq_operations *seq_ops;
	bpf_iter_init_seq_priv_t init_seq_private;
	bpf_iter_fini_seq_priv_t fini_seq_private;
	u32 seq_priv_size;
};

struct bpf_iter_seq_link_info {
	u32 link_id;
};

struct bpf_iter_seq_map_info {
	u32 map_id;
};

struct bpf_iter_seq_prog_info {
	u32 prog_id;
};

struct bpf_iter_seq_sk_storage_map_info {
	struct bpf_map *map;
	unsigned int bucket_id;
	unsigned int skip_elems;
};

struct pid_namespace;

struct bpf_iter_seq_task_common {
	struct pid_namespace *ns;
	enum bpf_iter_task_type type;
	u32 pid;
	u32 pid_visiting;
};

struct bpf_iter_seq_task_file_info {
	struct bpf_iter_seq_task_common common;
	struct task_struct *task;
	u32 tid;
	u32 fd;
};

struct bpf_iter_seq_task_info {
	struct bpf_iter_seq_task_common common;
	u32 tid;
};

struct bpf_iter_seq_task_vma_info {
	struct bpf_iter_seq_task_common common;
	struct task_struct *task;
	struct mm_struct *mm;
	struct vm_area_struct *vma;
	u32 tid;
	long unsigned int prev_vm_start;
	long unsigned int prev_vm_end;
};

struct bpf_iter_target_info {
	struct list_head list;
	const struct bpf_iter_reg *reg_info;
	u32 btf_id;
};

struct bpf_iter_task {
	__u64 __opaque[3];
};

struct bpf_iter_task_kern {
	struct task_struct *task;
	struct task_struct *pos;
	unsigned int flags;
};

struct bpf_iter_task_vma {
	__u64 __opaque[1];
};

struct bpf_iter_task_vma_kern_data;

struct bpf_iter_task_vma_kern {
	struct bpf_iter_task_vma_kern_data *data;
};

struct maple_enode;

struct maple_tree;

struct maple_alloc;

struct ma_state {
	struct maple_tree *tree;
	long unsigned int index;
	long unsigned int last;
	struct maple_enode *node;
	long unsigned int min;
	long unsigned int max;
	struct maple_alloc *alloc;
	enum maple_status status;
	unsigned char depth;
	unsigned char offset;
	unsigned char mas_flags;
	unsigned char end;
	enum store_type store_type;
};

struct vma_iterator {
	struct ma_state mas;
};

struct mmap_unlock_irq_work;

struct bpf_iter_task_vma_kern_data {
	struct task_struct *task;
	struct mm_struct *mm;
	struct mmap_unlock_irq_work *work;
	struct vma_iterator vmi;
};

struct bpf_jit_poke_descriptor {
	void *tailcall_target;
	void *tailcall_bypass;
	void *bypass_addr;
	void *aux;
	union {
		struct {
			struct bpf_map *map;
			u32 key;
		} tail_call;
	};
	bool tailcall_target_stable;
	u8 adj_off;
	u16 reason;
	u32 insn_idx;
};

struct bpf_key {
	struct key *key;
	bool has_ref;
};

struct bpf_kfunc_btf {
	struct btf *btf;
	struct module *module;
	u16 offset;
};

struct bpf_kfunc_btf_tab {
	struct bpf_kfunc_btf descs[256];
	u32 nr_descs;
};

struct bpf_kfunc_call_arg_meta {
	struct btf *btf;
	u32 func_id;
	u32 kfunc_flags;
	const struct btf_type *func_proto;
	const char *func_name;
	u32 ref_obj_id;
	u8 release_regno;
	bool r0_rdonly;
	u32 ret_btf_id;
	u64 r0_size;
	u32 subprogno;
	struct {
		u64 value;
		bool found;
	} arg_constant;
	struct btf *arg_btf;
	u32 arg_btf_id;
	bool arg_owning_ref;
	struct {
		struct btf_field *field;
	} arg_list_head;
	struct {
		struct btf_field *field;
	} arg_rbtree_root;
	struct {
		enum bpf_dynptr_type type;
		u32 id;
		u32 ref_obj_id;
	} initialized_dynptr;
	struct {
		u8 spi;
		u8 frameno;
	} iter;
	struct {
		struct bpf_map *ptr;
		int uid;
	} map;
	u64 mem_size;
};

struct bpf_kfunc_desc {
	struct btf_func_model func_model;
	u32 func_id;
	s32 imm;
	u16 offset;
	long unsigned int addr;
};

struct bpf_kfunc_desc_tab {
	struct bpf_kfunc_desc descs[256];
	u32 nr_descs;
};

struct bpf_line_info {
	__u32 insn_off;
	__u32 file_name_off;
	__u32 line_off;
	__u32 line_col;
};

struct bpf_link_info {
	__u32 type;
	__u32 id;
	__u32 prog_id;
	union {
		struct {
			__u64 tp_name;
			__u32 tp_name_len;
		} raw_tracepoint;
		struct {
			__u32 attach_type;
			__u32 target_obj_id;
			__u32 target_btf_id;
		} tracing;
		struct {
			__u64 cgroup_id;
			__u32 attach_type;
		} cgroup;
		struct {
			__u64 target_name;
			__u32 target_name_len;
			union {
				struct {
					__u32 map_id;
				} map;
			};
			union {
				struct {
					__u64 cgroup_id;
					__u32 order;
				} cgroup;
				struct {
					__u32 tid;
					__u32 pid;
				} task;
			};
		} iter;
		struct {
			__u32 netns_ino;
			__u32 attach_type;
		} netns;
		struct {
			__u32 ifindex;
		} xdp;
		struct {
			__u32 map_id;
		} struct_ops;
		struct {
			__u32 pf;
			__u32 hooknum;
			__s32 priority;
			__u32 flags;
		} netfilter;
		struct {
			__u64 addrs;
			__u32 count;
			__u32 flags;
			__u64 missed;
			__u64 cookies;
		} kprobe_multi;
		struct {
			__u64 path;
			__u64 offsets;
			__u64 ref_ctr_offsets;
			__u64 cookies;
			__u32 path_size;
			__u32 count;
			__u32 flags;
			__u32 pid;
		} uprobe_multi;
		struct {
			__u32 type;
			union {
				struct {
					__u64 file_name;
					__u32 name_len;
					__u32 offset;
					__u64 cookie;
				} uprobe;
				struct {
					__u64 func_name;
					__u32 name_len;
					__u32 offset;
					__u64 addr;
					__u64 missed;
					__u64 cookie;
				} kprobe;
				struct {
					__u64 tp_name;
					__u32 name_len;
					__u64 cookie;
				} tracepoint;
				struct {
					__u64 config;
					__u32 type;
					__u64 cookie;
				} event;
			};
		} perf_event;
		struct {
			__u32 ifindex;
			__u32 attach_type;
		} tcx;
		struct {
			__u32 ifindex;
			__u32 attach_type;
		} netkit;
		struct {
			__u32 map_id;
			__u32 attach_type;
		} sockmap;
	};
};

struct bpf_link_ops {
	void (*release)(struct bpf_link *);
	void (*dealloc)(struct bpf_link *);
	void (*dealloc_deferred)(struct bpf_link *);
	int (*detach)(struct bpf_link *);
	int (*update_prog)(struct bpf_link *, struct bpf_prog *, struct bpf_prog *);
	void (*show_fdinfo)(const struct bpf_link *, struct seq_file *);
	int (*fill_link_info)(const struct bpf_link *, struct bpf_link_info *);
	int (*update_map)(struct bpf_link *, struct bpf_map *, struct bpf_map *);
	__poll_t (*poll)(struct file *, struct poll_table_struct *);
};

struct bpf_link_primer {
	struct bpf_link *link;
	struct file *file;
	int fd;
	u32 id;
};

struct bpf_list_head {
	__u64 __opaque[2];
};

struct bpf_list_node {
	__u64 __opaque[3];
};

struct bpf_list_node_kern {
	struct list_head list_head;
	void *owner;
};

struct bpf_local_storage_data;

struct bpf_local_storage_map;

struct bpf_local_storage {
	struct bpf_local_storage_data *cache[16];
	struct bpf_local_storage_map *smap;
	struct hlist_head list;
	void *owner;
	struct callback_head rcu;
	raw_spinlock_t lock;
};

struct bpf_local_storage_cache {
	spinlock_t idx_lock;
	u64 idx_usage_counts[16];
};

struct bpf_local_storage_data {
	struct bpf_local_storage_map *smap;
	u8 data[0];
};

struct bpf_local_storage_elem {
	struct hlist_node map_node;
	struct hlist_node snode;
	struct bpf_local_storage *local_storage;
	union {
		struct callback_head rcu;
		struct hlist_node free_node;
	};
	long: 64;
	struct bpf_local_storage_data sdata;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct bpf_local_storage_map_bucket;

struct bpf_local_storage_map {
	struct bpf_map map;
	struct bpf_local_storage_map_bucket *buckets;
	u32 bucket_log;
	u16 elem_size;
	u16 cache_idx;
	struct bpf_mem_alloc selem_ma;
	struct bpf_mem_alloc storage_ma;
	bool bpf_ma;
};

struct bpf_local_storage_map_bucket {
	struct hlist_head list;
	raw_spinlock_t lock;
};

struct bpf_lpm_trie_key_hdr {
	__u32 prefixlen;
};

struct bpf_lpm_trie_key_u8 {
	union {
		struct bpf_lpm_trie_key_hdr hdr;
		__u32 prefixlen;
	};
	__u8 data[0];
};

struct bpf_lru_locallist {
	struct list_head lists[2];
	u16 next_steal;
	raw_spinlock_t lock;
};

struct bpf_lru_node {
	struct list_head list;
	u16 cpu;
	u8 type;
	u8 ref;
};

struct bpf_offloaded_map;

struct bpf_map_dev_ops {
	int (*map_get_next_key)(struct bpf_offloaded_map *, void *, void *);
	int (*map_lookup_elem)(struct bpf_offloaded_map *, void *, void *);
	int (*map_update_elem)(struct bpf_offloaded_map *, void *, void *, u64);
	int (*map_delete_elem)(struct bpf_offloaded_map *, void *);
};

struct bpf_map_info {
	__u32 type;
	__u32 id;
	__u32 key_size;
	__u32 value_size;
	__u32 max_entries;
	__u32 map_flags;
	char name[16];
	__u32 ifindex;
	__u32 btf_vmlinux_value_type_id;
	__u64 netns_dev;
	__u64 netns_ino;
	__u32 btf_id;
	__u32 btf_key_type_id;
	__u32 btf_value_type_id;
	__u32 btf_vmlinux_id;
	__u64 map_extra;
};

typedef u64 (*bpf_callback_t)(u64, u64, u64, u64, u64);

struct bpf_prog_aux;

struct bpf_map_ops {
	int (*map_alloc_check)(union bpf_attr *);
	struct bpf_map * (*map_alloc)(union bpf_attr *);
	void (*map_release)(struct bpf_map *, struct file *);
	void (*map_free)(struct bpf_map *);
	int (*map_get_next_key)(struct bpf_map *, void *, void *);
	void (*map_release_uref)(struct bpf_map *);
	void * (*map_lookup_elem_sys_only)(struct bpf_map *, void *);
	int (*map_lookup_batch)(struct bpf_map *, const union bpf_attr *, union bpf_attr *);
	int (*map_lookup_and_delete_elem)(struct bpf_map *, void *, void *, u64);
	int (*map_lookup_and_delete_batch)(struct bpf_map *, const union bpf_attr *, union bpf_attr *);
	int (*map_update_batch)(struct bpf_map *, struct file *, const union bpf_attr *, union bpf_attr *);
	int (*map_delete_batch)(struct bpf_map *, const union bpf_attr *, union bpf_attr *);
	void * (*map_lookup_elem)(struct bpf_map *, void *);
	long int (*map_update_elem)(struct bpf_map *, void *, void *, u64);
	long int (*map_delete_elem)(struct bpf_map *, void *);
	long int (*map_push_elem)(struct bpf_map *, void *, u64);
	long int (*map_pop_elem)(struct bpf_map *, void *);
	long int (*map_peek_elem)(struct bpf_map *, void *);
	void * (*map_lookup_percpu_elem)(struct bpf_map *, void *, u32);
	void * (*map_fd_get_ptr)(struct bpf_map *, struct file *, int);
	void (*map_fd_put_ptr)(struct bpf_map *, void *, bool);
	int (*map_gen_lookup)(struct bpf_map *, struct bpf_insn *);
	u32 (*map_fd_sys_lookup_elem)(void *);
	void (*map_seq_show_elem)(struct bpf_map *, void *, struct seq_file *);
	int (*map_check_btf)(const struct bpf_map *, const struct btf *, const struct btf_type *, const struct btf_type *);
	int (*map_poke_track)(struct bpf_map *, struct bpf_prog_aux *);
	void (*map_poke_untrack)(struct bpf_map *, struct bpf_prog_aux *);
	void (*map_poke_run)(struct bpf_map *, u32, struct bpf_prog *, struct bpf_prog *);
	int (*map_direct_value_addr)(const struct bpf_map *, u64 *, u32);
	int (*map_direct_value_meta)(const struct bpf_map *, u64, u32 *);
	int (*map_mmap)(struct bpf_map *, struct vm_area_struct *);
	__poll_t (*map_poll)(struct bpf_map *, struct file *, struct poll_table_struct *);
	long unsigned int (*map_get_unmapped_area)(struct file *, long unsigned int, long unsigned int, long unsigned int, long unsigned int);
	int (*map_local_storage_charge)(struct bpf_local_storage_map *, void *, u32);
	void (*map_local_storage_uncharge)(struct bpf_local_storage_map *, void *, u32);
	struct bpf_local_storage ** (*map_owner_storage_ptr)(void *);
	long int (*map_redirect)(struct bpf_map *, u64, u64);
	bool (*map_meta_equal)(const struct bpf_map *, const struct bpf_map *);
	int (*map_set_for_each_callback_args)(struct bpf_verifier_env *, struct bpf_func_state *, struct bpf_func_state *);
	long int (*map_for_each_callback)(struct bpf_map *, bpf_callback_t, void *, u64);
	u64 (*map_mem_usage)(const struct bpf_map *);
	int *map_btf_id;
	const struct bpf_iter_seq_info *iter_seq_info;
};

struct rcuwait {
	struct task_struct *task;
};

struct irq_work {
	struct __call_single_node node;
	void (*func)(struct irq_work *);
	struct rcuwait irqwait;
};

struct bpf_mem_cache {
	struct llist_head free_llist;
	local_t active;
	struct llist_head free_llist_extra;
	struct irq_work refill_work;
	struct obj_cgroup *objcg;
	int unit_size;
	int free_cnt;
	int low_watermark;
	int high_watermark;
	int batch;
	int percpu_size;
	bool draining;
	struct bpf_mem_cache *tgt;
	struct llist_head free_by_rcu;
	struct llist_node *free_by_rcu_tail;
	struct llist_head waiting_for_gp;
	struct llist_node *waiting_for_gp_tail;
	struct callback_head rcu;
	atomic_t call_rcu_in_progress;
	struct llist_head free_llist_extra_rcu;
	struct llist_head free_by_rcu_ttrace;
	struct llist_head waiting_for_gp_ttrace;
	struct callback_head rcu_ttrace;
	atomic_t call_rcu_ttrace_in_progress;
};

struct bpf_mem_caches {
	struct bpf_mem_cache cache[11];
};

struct bpf_mount_opts {
	kuid_t uid;
	kgid_t gid;
	umode_t mode;
	u64 delegate_cmds;
	u64 delegate_maps;
	u64 delegate_progs;
	u64 delegate_attachs;
};

struct bpf_mprog_fp {
	struct bpf_prog *prog;
};

struct bpf_mprog_bundle;

struct bpf_mprog_entry {
	struct bpf_mprog_fp fp_items[64];
	struct bpf_mprog_bundle *parent;
};

struct bpf_mprog_cp {
	struct bpf_link *link;
};

struct bpf_mprog_bundle {
	struct bpf_mprog_entry a;
	struct bpf_mprog_entry b;
	struct bpf_mprog_cp cp_items[64];
	struct bpf_prog *ref;
	atomic64_t revision;
	u32 count;
};

struct bpf_nested_pt_regs {
	struct pt_regs regs[3];
};

struct bpf_nh_params {
	u32 nh_family;
	union {
		u32 ipv4_nh;
		struct in6_addr ipv6_nh;
	};
};

struct bpf_redirect_info {
	u64 tgt_index;
	void *tgt_value;
	struct bpf_map *map;
	u32 flags;
	u32 map_id;
	enum bpf_map_type map_type;
	struct bpf_nh_params nh;
	u32 kern_flags;
};

struct bpf_net_context {
	struct bpf_redirect_info ri;
	struct list_head cpu_map_flush_list;
	struct list_head dev_map_flush_list;
	struct list_head xskmap_map_flush_list;
};

struct bpf_netns_link {
	struct bpf_link link;
	enum bpf_attach_type type;
	enum netns_bpf_attach_type netns_type;
	struct net *net;
	struct list_head node;
};

typedef unsigned int nf_hookfn(void *, struct sk_buff *, const struct nf_hook_state *);

struct nf_hook_ops {
	nf_hookfn *hook;
	struct net_device *dev;
	void *priv;
	u8 pf;
	enum nf_hook_ops_type hook_ops_type: 8;
	unsigned int hooknum;
	int priority;
};

struct nf_defrag_hook;

struct bpf_nf_link {
	struct bpf_link link;
	struct nf_hook_ops hook_ops;
	netns_tracker ns_tracker;
	struct net *net;
	u32 dead;
	const struct nf_defrag_hook *defrag_hook;
};

struct bpf_prog_offload_ops;

struct bpf_offload_dev {
	const struct bpf_prog_offload_ops *ops;
	struct list_head netdevs;
	void *priv;
};

struct rhash_head {
	struct rhash_head *next;
};

struct bpf_offload_netdev {
	struct rhash_head l;
	struct net_device *netdev;
	struct bpf_offload_dev *offdev;
	struct list_head progs;
	struct list_head maps;
	struct list_head offdev_netdevs;
};

struct bpf_offloaded_map {
	struct bpf_map map;
	struct net_device *netdev;
	const struct bpf_map_dev_ops *dev_ops;
	void *dev_priv;
	struct list_head offloads;
};

struct bpf_perf_event_value {
	__u64 counter;
	__u64 enabled;
	__u64 running;
};

struct bpf_perf_link {
	struct bpf_link link;
	struct file *perf_file;
};

struct bpf_pidns_info {
	__u32 pid;
	__u32 tgid;
};

struct bpf_preload_info {
	char link_name[16];
	struct bpf_link *link;
};

struct bpf_preload_ops {
	int (*preload)(struct bpf_preload_info *);
	struct module *owner;
};

struct sock_filter {
	__u16 code;
	__u8 jt;
	__u8 jf;
	__u32 k;
};

struct bpf_prog_stats;

struct sock_fprog_kern;

struct bpf_prog {
	u16 pages;
	u16 jited: 1;
	u16 jit_requested: 1;
	u16 gpl_compatible: 1;
	u16 cb_access: 1;
	u16 dst_needed: 1;
	u16 blinding_requested: 1;
	u16 blinded: 1;
	u16 is_func: 1;
	u16 kprobe_override: 1;
	u16 has_callchain_buf: 1;
	u16 enforce_expected_attach_type: 1;
	u16 call_get_stack: 1;
	u16 call_get_func_ip: 1;
	u16 tstamp_type_access: 1;
	u16 sleepable: 1;
	enum bpf_prog_type type;
	enum bpf_attach_type expected_attach_type;
	u32 len;
	u32 jited_len;
	u8 tag[8];
	struct bpf_prog_stats *stats;
	int *active;
	unsigned int (*bpf_func)(const void *, const struct bpf_insn *);
	struct bpf_prog_aux *aux;
	struct sock_fprog_kern *orig_prog;
	union {
		struct {
			struct {} __empty_insns;
			struct sock_filter insns[0];
		};
		struct {
			struct {} __empty_insnsi;
			struct bpf_insn insnsi[0];
		};
	};
};

struct bpf_trampoline;

struct bpf_prog_ops;

struct btf_mod_pair;

struct user_struct;

struct bpf_token;

struct bpf_prog_offload;

struct exception_table_entry;

struct bpf_prog_aux {
	atomic64_t refcnt;
	u32 used_map_cnt;
	u32 used_btf_cnt;
	u32 max_ctx_offset;
	u32 max_pkt_offset;
	u32 max_tp_access;
	u32 stack_depth;
	u32 id;
	u32 func_cnt;
	u32 real_func_cnt;
	u32 func_idx;
	u32 attach_btf_id;
	u32 ctx_arg_info_size;
	u32 max_rdonly_access;
	u32 max_rdwr_access;
	struct btf *attach_btf;
	const struct bpf_ctx_arg_aux *ctx_arg_info;
	void *priv_stack_ptr;
	struct mutex dst_mutex;
	struct bpf_prog *dst_prog;
	struct bpf_trampoline *dst_trampoline;
	enum bpf_prog_type saved_dst_prog_type;
	enum bpf_attach_type saved_dst_attach_type;
	bool verifier_zext;
	bool dev_bound;
	bool offload_requested;
	bool attach_btf_trace;
	bool attach_tracing_prog;
	bool func_proto_unreliable;
	bool tail_call_reachable;
	bool xdp_has_frags;
	bool exception_cb;
	bool exception_boundary;
	bool is_extended;
	bool jits_use_priv_stack;
	bool priv_stack_requested;
	bool changes_pkt_data;
	u64 prog_array_member_cnt;
	struct mutex ext_mutex;
	struct bpf_arena *arena;
	void (*recursion_detected)(struct bpf_prog *);
	const struct btf_type *attach_func_proto;
	const char *attach_func_name;
	struct bpf_prog **func;
	void *jit_data;
	struct bpf_jit_poke_descriptor *poke_tab;
	struct bpf_kfunc_desc_tab *kfunc_tab;
	struct bpf_kfunc_btf_tab *kfunc_btf_tab;
	u32 size_poke_tab;
	struct bpf_ksym ksym;
	const struct bpf_prog_ops *ops;
	struct bpf_map **used_maps;
	struct mutex used_maps_mutex;
	struct btf_mod_pair *used_btfs;
	struct bpf_prog *prog;
	struct user_struct *user;
	u64 load_time;
	u32 verified_insns;
	int cgroup_atype;
	struct bpf_map *cgroup_storage[2];
	char name[16];
	u64 (*bpf_exception_cb)(u64, u64, u64, u64, u64);
	void *security;
	struct bpf_token *token;
	struct bpf_prog_offload *offload;
	struct btf *btf;
	struct bpf_func_info *func_info;
	struct bpf_func_info_aux *func_info_aux;
	struct bpf_line_info *linfo;
	void **jited_linfo;
	u32 func_info_cnt;
	u32 nr_linfo;
	u32 linfo_idx;
	struct module *mod;
	u32 num_exentries;
	struct exception_table_entry *extable;
	union {
		struct work_struct work;
		struct callback_head rcu;
	};
};

struct bpf_prog_dummy {
	struct bpf_prog prog;
};

struct bpf_prog_info {
	__u32 type;
	__u32 id;
	__u8 tag[8];
	__u32 jited_prog_len;
	__u32 xlated_prog_len;
	__u64 jited_prog_insns;
	__u64 xlated_prog_insns;
	__u64 load_time;
	__u32 created_by_uid;
	__u32 nr_map_ids;
	__u64 map_ids;
	char name[16];
	__u32 ifindex;
	__u32 gpl_compatible: 1;
	__u64 netns_dev;
	__u64 netns_ino;
	__u32 nr_jited_ksyms;
	__u32 nr_jited_func_lens;
	__u64 jited_ksyms;
	__u64 jited_func_lens;
	__u32 btf_id;
	__u32 func_info_rec_size;
	__u64 func_info;
	__u32 nr_func_info;
	__u32 nr_line_info;
	__u64 line_info;
	__u64 jited_line_info;
	__u32 nr_jited_line_info;
	__u32 line_info_rec_size;
	__u32 jited_line_info_rec_size;
	__u32 nr_prog_tags;
	__u64 prog_tags;
	__u64 run_time_ns;
	__u64 run_cnt;
	__u64 recursion_misses;
	__u32 verified_insns;
	__u32 attach_btf_obj_id;
	__u32 attach_btf_id;
};

struct bpf_prog_kstats {
	u64 nsecs;
	u64 cnt;
	u64 misses;
};

struct bpf_prog_offload {
	struct bpf_prog *prog;
	struct net_device *netdev;
	struct bpf_offload_dev *offdev;
	void *dev_priv;
	struct list_head offloads;
	bool dev_state;
	bool opt_failed;
	void *jited_image;
	u32 jited_len;
};

struct bpf_prog_offload_ops {
	int (*insn_hook)(struct bpf_verifier_env *, int, int);
	int (*finalize)(struct bpf_verifier_env *);
	int (*replace_insn)(struct bpf_verifier_env *, u32, struct bpf_insn *);
	int (*remove_insns)(struct bpf_verifier_env *, u32, u32);
	int (*prepare)(struct bpf_prog *);
	int (*translate)(struct bpf_prog *);
	void (*destroy)(struct bpf_prog *);
};

struct bpf_prog_ops {
	int (*test_run)(struct bpf_prog *, const union bpf_attr *, union bpf_attr *);
};

struct bpf_prog_stats {
	u64_stats_t cnt;
	u64_stats_t nsecs;
	u64_stats_t misses;
	struct u64_stats_sync syncp;
	long: 64;
};

struct bpf_queue_stack {
	struct bpf_map map;
	raw_spinlock_t lock;
	u32 head;
	u32 tail;
	u32 size;
	char elements[0];
};

struct tracepoint;

struct bpf_raw_event_map {
	struct tracepoint *tp;
	void *bpf_func;
	u32 num_args;
	u32 writable_size;
	long: 64;
};

struct bpf_raw_tp_link {
	struct bpf_link link;
	struct bpf_raw_event_map *btp;
	u64 cookie;
};

struct bpf_raw_tp_null_args {
	const char *func;
	u64 mask;
};

struct bpf_raw_tp_regs {
	struct pt_regs regs[3];
};

struct bpf_raw_tp_test_run_info {
	struct bpf_prog *prog;
	void *ctx;
	u32 retval;
};

struct bpf_rb_node {
	__u64 __opaque[4];
};

struct bpf_rb_node_kern {
	struct rb_node rb_node;
	void *owner;
};

struct bpf_rb_root {
	__u64 __opaque[2];
};

struct bpf_redir_neigh {
	__u32 nh_family;
	union {
		__be32 ipv4_nh;
		__u32 ipv6_nh[4];
	};
};

struct bpf_refcount {
	__u32 __opaque[1];
};

struct bpf_reference_state {
	enum ref_state_type type;
	int id;
	int insn_idx;
	void *ptr;
};

struct bpf_reg_types {
	const enum bpf_reg_type types[10];
	u32 *btf_id;
};

struct bpf_ringbuf {
	wait_queue_head_t waitq;
	struct irq_work work;
	u64 mask;
	struct page **pages;
	int nr_pages;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	raw_spinlock_t spinlock;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	atomic_t busy;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long unsigned int consumer_pos;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long unsigned int producer_pos;
	long unsigned int pending_pos;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	char data[0];
};

struct bpf_ringbuf_hdr {
	u32 len;
	u32 pg_off;
};

struct bpf_ringbuf_map {
	struct bpf_map map;
	struct bpf_ringbuf *rb;
};

struct bpf_sanitize_info {
	struct bpf_insn_aux_data aux;
	bool mask_to_left;
};

struct bpf_security_struct {
	u32 sid;
};

struct bpf_session_run_ctx {
	struct bpf_run_ctx run_ctx;
	bool is_return;
	void *data;
};

struct sk_psock_progs {
	struct bpf_prog *msg_parser;
	struct bpf_prog *stream_parser;
	struct bpf_prog *stream_verdict;
	struct bpf_prog *skb_verdict;
	struct bpf_link *msg_parser_link;
	struct bpf_link *stream_parser_link;
	struct bpf_link *stream_verdict_link;
	struct bpf_link *skb_verdict_link;
};

struct bpf_shtab_bucket;

struct bpf_shtab {
	struct bpf_map map;
	struct bpf_shtab_bucket *buckets;
	u32 buckets_num;
	u32 elem_size;
	struct sk_psock_progs progs;
	atomic_t count;
};

struct bpf_shtab_bucket {
	struct hlist_head head;
	spinlock_t lock;
};

struct bpf_shtab_elem {
	struct callback_head rcu;
	u32 hash;
	struct sock *sk;
	struct hlist_node node;
	u8 key[0];
};

struct bpf_sk_storage_diag {
	u32 nr_maps;
	struct bpf_map *maps[0];
};

struct qdisc_skb_cb {
	struct {
		unsigned int pkt_len;
		u16 slave_dev_queue_mapping;
		u16 tc_classid;
	};
	unsigned char data[20];
};

struct bpf_skb_data_end {
	struct qdisc_skb_cb qdisc_cb;
	void *data_meta;
	void *data_end;
};

struct bpf_sock {
	__u32 bound_dev_if;
	__u32 family;
	__u32 type;
	__u32 protocol;
	__u32 mark;
	__u32 priority;
	__u32 src_ip4;
	__u32 src_ip6[4];
	__u32 src_port;
	__be16 dst_port;
	__u32 dst_ip4;
	__u32 dst_ip6[4];
	__u32 state;
	__s32 rx_queue_mapping;
};

struct bpf_sock_addr {
	__u32 user_family;
	__u32 user_ip4;
	__u32 user_ip6[4];
	__u32 user_port;
	__u32 family;
	__u32 type;
	__u32 protocol;
	__u32 msg_src_ip4;
	__u32 msg_src_ip6[4];
	union {
		struct bpf_sock *sk;
	};
};

struct bpf_sock_addr_kern {
	struct sock *sk;
	struct sockaddr *uaddr;
	u64 tmp_reg;
	void *t_ctx;
	u32 uaddrlen;
};

struct bpf_sock_tuple {
	union {
		struct {
			__be32 saddr;
			__be32 daddr;
			__be16 sport;
			__be16 dport;
		} ipv4;
		struct {
			__be32 saddr[4];
			__be32 daddr[4];
			__be16 sport;
			__be16 dport;
		} ipv6;
	};
};

struct bpf_stab {
	struct bpf_map map;
	struct sock **sks;
	struct sk_psock_progs progs;
	spinlock_t lock;
};

struct bpf_stack_build_id {
	__s32 status;
	unsigned char build_id[20];
	union {
		__u64 offset;
		__u64 ip;
	};
};

struct stack_map_bucket;

struct bpf_stack_map {
	struct bpf_map map;
	void *elems;
	struct pcpu_freelist freelist;
	u32 n_buckets;
	struct stack_map_bucket *buckets[0];
};

struct bpf_stack_state {
	struct bpf_reg_state spilled_ptr;
	u8 slot_type[8];
};

struct bpf_verifier_ops;

struct btf_member;

struct bpf_struct_ops {
	const struct bpf_verifier_ops *verifier_ops;
	int (*init)(struct btf *);
	int (*check_member)(const struct btf_type *, const struct btf_member *, const struct bpf_prog *);
	int (*init_member)(const struct btf_type *, const struct btf_member *, void *, const void *);
	int (*reg)(void *, struct bpf_link *);
	void (*unreg)(void *, struct bpf_link *);
	int (*update)(void *, void *, struct bpf_link *);
	int (*validate)(void *);
	void *cfi_stubs;
	struct module *owner;
	const char *name;
	struct btf_func_model func_models[64];
};

struct bpf_struct_ops_arg_info {
	struct bpf_ctx_arg_aux *info;
	u32 cnt;
};

struct bpf_struct_ops_desc {
	struct bpf_struct_ops *st_ops;
	const struct btf_type *type;
	const struct btf_type *value_type;
	u32 type_id;
	u32 value_id;
	struct bpf_struct_ops_arg_info *arg_info;
};

struct bpf_subprog_arg_info {
	enum bpf_arg_type arg_type;
	union {
		u32 mem_size;
		u32 btf_id;
	};
};

struct bpf_subprog_info {
	u32 start;
	u32 linfo_idx;
	u16 stack_depth;
	u16 stack_extra;
	s16 fastcall_stack_off;
	bool has_tail_call: 1;
	bool tail_call_reachable: 1;
	bool has_ld_abs: 1;
	bool is_cb: 1;
	bool is_async_cb: 1;
	bool is_exception_cb: 1;
	bool args_cached: 1;
	bool keep_fastcall_stack: 1;
	bool changes_pkt_data: 1;
	enum priv_stack_mode priv_stack_mode;
	u8 arg_cnt;
	struct bpf_subprog_arg_info args[5];
};

struct tcp_iter_state {
	struct seq_net_private p;
	enum tcp_seq_states state;
	struct sock *syn_wait_sk;
	int bucket;
	int offset;
	int sbucket;
	int num;
	loff_t last_pos;
};

struct bpf_tcp_iter_state {
	struct tcp_iter_state state;
	unsigned int cur_sk;
	unsigned int end_sk;
	unsigned int max_sk;
	struct sock **batch;
	bool st_bucket_done;
};

struct bpf_tcp_req_attrs {
	u32 rcv_tsval;
	u32 rcv_tsecr;
	u16 mss;
	u8 rcv_wscale;
	u8 snd_wscale;
	u8 ecn_ok;
	u8 wscale_ok;
	u8 sack_ok;
	u8 tstamp_ok;
	u8 usec_ts_ok;
	u8 reserved[3];
};

struct bpf_tcp_sock {
	__u32 snd_cwnd;
	__u32 srtt_us;
	__u32 rtt_min;
	__u32 snd_ssthresh;
	__u32 rcv_nxt;
	__u32 snd_nxt;
	__u32 snd_una;
	__u32 mss_cache;
	__u32 ecn_flags;
	__u32 rate_delivered;
	__u32 rate_interval_us;
	__u32 packets_out;
	__u32 retrans_out;
	__u32 total_retrans;
	__u32 segs_in;
	__u32 data_segs_in;
	__u32 segs_out;
	__u32 data_segs_out;
	__u32 lost_out;
	__u32 sacked_out;
	__u64 bytes_received;
	__u64 bytes_acked;
	__u32 dsack_dups;
	__u32 delivered;
	__u32 delivered_ce;
	__u32 icsk_retransmits;
};

struct bpf_test_timer {
	enum {
		NO_PREEMPT = 0,
		NO_MIGRATE = 1,
	} mode;
	u32 i;
	u64 time_start;
	u64 time_spent;
};

struct bpf_throw_ctx {
	struct bpf_prog_aux *aux;
	u64 sp;
	u64 bp;
	int cnt;
};

struct bpf_timer {
	__u64 __opaque[2];
};

struct user_namespace;

struct bpf_token {
	struct work_struct work;
	atomic64_t refcnt;
	struct user_namespace *userns;
	u64 allowed_cmds;
	u64 allowed_maps;
	u64 allowed_progs;
	u64 allowed_attachs;
	void *security;
};

struct bpf_trace_module {
	struct module *module;
	struct list_head list;
};

struct bpf_trace_run_ctx {
	struct bpf_run_ctx run_ctx;
	u64 bpf_cookie;
	bool is_uprobe;
};

union perf_sample_weight {
	__u64 full;
	struct {
		__u32 var1_dw;
		__u16 var2_w;
		__u16 var3_w;
	};
};

union perf_mem_data_src {
	__u64 val;
	struct {
		__u64 mem_op: 5;
		__u64 mem_lvl: 14;
		__u64 mem_snoop: 5;
		__u64 mem_lock: 2;
		__u64 mem_dtlb: 7;
		__u64 mem_lvl_num: 4;
		__u64 mem_remote: 1;
		__u64 mem_snoopx: 2;
		__u64 mem_blk: 3;
		__u64 mem_hops: 3;
		__u64 mem_rsvd: 18;
	};
};

struct perf_regs {
	__u64 abi;
	struct pt_regs *regs;
};

struct perf_callchain_entry;

struct perf_raw_record;

struct perf_branch_stack;

struct perf_sample_data {
	u64 sample_flags;
	u64 period;
	u64 dyn_size;
	u64 type;
	struct {
		u32 pid;
		u32 tid;
	} tid_entry;
	u64 time;
	u64 id;
	struct {
		u32 cpu;
		u32 reserved;
	} cpu_entry;
	u64 ip;
	struct perf_callchain_entry *callchain;
	struct perf_raw_record *raw;
	struct perf_branch_stack *br_stack;
	u64 *br_stack_cntr;
	union perf_sample_weight weight;
	union perf_mem_data_src data_src;
	u64 txn;
	struct perf_regs regs_user;
	struct perf_regs regs_intr;
	u64 stack_user_size;
	u64 stream_id;
	u64 cgroup;
	u64 addr;
	u64 phys_addr;
	u64 data_page_size;
	u64 code_page_size;
	u64 aux_size;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct bpf_trace_sample_data {
	struct perf_sample_data sds[3];
};

struct bpf_tramp_link {
	struct bpf_link link;
	struct hlist_node tramp_hlist;
	u64 cookie;
};

struct bpf_tracing_link {
	struct bpf_tramp_link link;
	enum bpf_attach_type attach_type;
	struct bpf_trampoline *trampoline;
	struct bpf_prog *tgt_prog;
};

struct bpf_tramp_image {
	void *image;
	int size;
	struct bpf_ksym ksym;
	struct percpu_ref pcref;
	void *ip_after_call;
	void *ip_epilogue;
	union {
		struct callback_head rcu;
		struct work_struct work;
	};
};

struct bpf_tramp_run_ctx {
	struct bpf_run_ctx run_ctx;
	u64 bpf_cookie;
	struct bpf_run_ctx *saved_run_ctx;
};

struct ftrace_ops;

struct bpf_trampoline {
	struct hlist_node hlist;
	struct ftrace_ops *fops;
	struct mutex mutex;
	refcount_t refcnt;
	u32 flags;
	u64 key;
	struct {
		struct btf_func_model model;
		void *addr;
		bool ftrace_managed;
	} func;
	struct bpf_prog *extension_prog;
	struct hlist_head progs_hlist[3];
	int progs_cnt[3];
	struct bpf_tramp_image *cur_image;
};

struct bpf_tunnel_key {
	__u32 tunnel_id;
	union {
		__u32 remote_ipv4;
		__u32 remote_ipv6[4];
	};
	__u8 tunnel_tos;
	__u8 tunnel_ttl;
	union {
		__u16 tunnel_ext;
		__be16 tunnel_flags;
	};
	__u32 tunnel_label;
	union {
		__u32 local_ipv4;
		__u32 local_ipv6[4];
	};
};

struct bpf_tuple {
	struct bpf_prog *prog;
	struct bpf_link *link;
};

struct udp_iter_state {
	struct seq_net_private p;
	int bucket;
};

struct bpf_udp_iter_state {
	struct udp_iter_state state;
	unsigned int cur_sk;
	unsigned int end_sk;
	unsigned int max_sk;
	int offset;
	struct sock **batch;
	bool st_bucket_done;
};

struct bpf_unix_iter_state {
	struct seq_net_private p;
	unsigned int cur_sk;
	unsigned int end_sk;
	unsigned int max_sk;
	struct sock **batch;
	bool st_bucket_done;
};

struct uprobe_consumer {
	int (*handler)(struct uprobe_consumer *, struct pt_regs *, __u64 *);
	int (*ret_handler)(struct uprobe_consumer *, long unsigned int, struct pt_regs *, __u64 *);
	bool (*filter)(struct uprobe_consumer *, struct mm_struct *);
	struct list_head cons_node;
	__u64 id;
};

struct bpf_uprobe_multi_link;

struct uprobe;

struct bpf_uprobe {
	struct bpf_uprobe_multi_link *link;
	loff_t offset;
	long unsigned int ref_ctr_offset;
	u64 cookie;
	struct uprobe *uprobe;
	struct uprobe_consumer consumer;
	bool session;
};

struct bpf_uprobe_multi_link {
	struct path path;
	struct bpf_link link;
	u32 cnt;
	u32 flags;
	struct bpf_uprobe *uprobes;
	struct task_struct *task;
};

struct bpf_uprobe_multi_run_ctx {
	struct bpf_session_run_ctx session_ctx;
	long unsigned int entry_ip;
	struct bpf_uprobe *uprobe;
};

struct btf_mod_pair {
	struct btf *btf;
	struct module *module;
};

struct bpf_verifier_log {
	u64 start_pos;
	u64 end_pos;
	char *ubuf;
	u32 level;
	u32 len_total;
	u32 len_max;
	char kbuf[1024];
};

struct bpf_verifier_stack_elem;

struct bpf_verifier_state;

struct bpf_verifier_state_list;

struct bpf_verifier_env {
	u32 insn_idx;
	u32 prev_insn_idx;
	struct bpf_prog *prog;
	const struct bpf_verifier_ops *ops;
	struct module *attach_btf_mod;
	struct bpf_verifier_stack_elem *head;
	int stack_size;
	bool strict_alignment;
	bool test_state_freq;
	bool test_reg_invariants;
	struct bpf_verifier_state *cur_state;
	struct bpf_verifier_state_list **explored_states;
	struct bpf_verifier_state_list *free_list;
	struct bpf_map *used_maps[64];
	struct btf_mod_pair used_btfs[64];
	u32 used_map_cnt;
	u32 used_btf_cnt;
	u32 id_gen;
	u32 hidden_subprog_cnt;
	int exception_callback_subprog;
	bool explore_alu_limits;
	bool allow_ptr_leaks;
	bool allow_uninit_stack;
	bool bpf_capable;
	bool bypass_spec_v1;
	bool bypass_spec_v4;
	bool seen_direct_write;
	bool seen_exception;
	struct bpf_insn_aux_data *insn_aux_data;
	const struct bpf_line_info *prev_linfo;
	struct bpf_verifier_log log;
	struct bpf_subprog_info subprog_info[258];
	union {
		struct bpf_idmap idmap_scratch;
		struct bpf_idset idset_scratch;
	};
	struct {
		int *insn_state;
		int *insn_stack;
		int cur_stack;
	} cfg;
	struct backtrack_state bt;
	struct bpf_insn_hist_entry *insn_hist;
	struct bpf_insn_hist_entry *cur_hist_ent;
	u32 insn_hist_cap;
	u32 pass_cnt;
	u32 subprog_cnt;
	u32 prev_insn_processed;
	u32 insn_processed;
	u32 prev_jmps_processed;
	u32 jmps_processed;
	u64 verification_time;
	u32 max_states_per_insn;
	u32 total_states;
	u32 peak_states;
	u32 longest_mark_read_walk;
	bpfptr_t fd_array;
	u32 scratched_regs;
	u64 scratched_stack_slots;
	u64 prev_log_pos;
	u64 prev_insn_print_pos;
	struct bpf_reg_state fake_reg[2];
	char tmp_str_buf[320];
	struct bpf_insn insn_buf[32];
	struct bpf_insn epilogue_buf[32];
};

struct bpf_verifier_ops {
	const struct bpf_func_proto * (*get_func_proto)(enum bpf_func_id, const struct bpf_prog *);
	bool (*is_valid_access)(int, int, enum bpf_access_type, const struct bpf_prog *, struct bpf_insn_access_aux *);
	int (*gen_prologue)(struct bpf_insn *, bool, const struct bpf_prog *);
	int (*gen_epilogue)(struct bpf_insn *, const struct bpf_prog *, s16);
	int (*gen_ld_abs)(const struct bpf_insn *, struct bpf_insn *);
	u32 (*convert_ctx_access)(enum bpf_access_type, const struct bpf_insn *, struct bpf_insn *, struct bpf_prog *, u32 *);
	int (*btf_struct_access)(struct bpf_verifier_log *, const struct bpf_reg_state *, int, int);
};

struct bpf_verifier_state {
	struct bpf_func_state *frame[8];
	struct bpf_verifier_state *parent;
	struct bpf_reference_state *refs;
	u32 branches;
	u32 insn_idx;
	u32 curframe;
	u32 acquired_refs;
	u32 active_locks;
	u32 active_preempt_locks;
	u32 active_irq_id;
	bool active_rcu_lock;
	bool speculative;
	bool used_as_loop_entry;
	bool in_sleepable;
	u32 first_insn_idx;
	u32 last_insn_idx;
	struct bpf_verifier_state *loop_entry;
	u32 insn_hist_start;
	u32 insn_hist_end;
	u32 dfs_depth;
	u32 callback_unroll_depth;
	u32 may_goto_depth;
};

struct bpf_verifier_stack_elem {
	struct bpf_verifier_state st;
	int insn_idx;
	int prev_insn_idx;
	struct bpf_verifier_stack_elem *next;
	u32 log_pos;
};

struct bpf_verifier_state_list {
	struct bpf_verifier_state state;
	struct bpf_verifier_state_list *next;
	int miss_cnt;
	int hit_cnt;
};

struct bpf_work {
	struct bpf_async_cb cb;
	struct work_struct work;
	struct work_struct delete_work;
};

struct bpf_wq {
	__u64 __opaque[2];
};

struct bpf_xdp_link;

struct bpf_xdp_entity {
	struct bpf_prog *prog;
	struct bpf_xdp_link *link;
};

struct bpf_xdp_link {
	struct bpf_link link;
	struct net_device *dev;
	int flags;
};

struct bpf_xdp_sock {
	__u32 queue_id;
};

struct bpf_xfrm_state {
	__u32 reqid;
	__u32 spi;
	__u16 family;
	__u16 ext;
	union {
		__u32 remote_ipv4;
		__u32 remote_ipv6[4];
	};
};

struct bpf_xfrm_state_opts {
	s32 error;
	s32 netns_id;
	u32 mark;
	xfrm_address_t daddr;
	__be32 spi;
	u8 proto;
	u16 family;
};

struct bpffs_btf_enums {
	const struct btf *btf;
	const struct btf_type *cmd_t;
	const struct btf_type *map_t;
	const struct btf_type *prog_t;
	const struct btf_type *attach_t;
};

struct trace_entry {
	short unsigned int type;
	unsigned char flags;
	unsigned char preempt_count;
	int pid;
};

struct bprint_entry {
	struct trace_entry ent;
	long unsigned int ip;
	const char *fmt;
	u32 buf[0];
};

struct bputs_entry {
	struct trace_entry ent;
	long unsigned int ip;
	const char *str;
};

struct br_input_skb_cb {
	struct net_device *brdev;
	u16 frag_max_size;
	u8 proxyarp_replied: 1;
	u8 src_port_isolated: 1;
	u8 promisc: 1;
	u32 backup_nhid;
};

struct br_mdb_entry {
	__u32 ifindex;
	__u8 state;
	__u8 flags;
	__u16 vid;
	struct {
		union {
			__be32 ip4;
			struct in6_addr ip6;
			unsigned char mac_addr[6];
		} u;
		__be16 proto;
	} addr;
};

struct br_port_msg {
	__u8 family;
	__u32 ifindex;
};

struct branch_entry {
	union {
		struct {
			u64 ip: 58;
			u64 ip_sign_ext: 5;
			u64 mispredict: 1;
		} split;
		u64 full;
	} from;
	union {
		struct {
			u64 ip: 58;
			u64 ip_sign_ext: 3;
			u64 reserved: 1;
			u64 spec: 1;
			u64 valid: 1;
		} split;
		u64 full;
	} to;
};

struct broadcast_sk {
	struct sock *sk;
	struct work_struct work;
};

struct fs_pin {
	wait_queue_head_t wait;
	int done;
	struct hlist_node s_list;
	struct hlist_node m_list;
	void (*kill)(struct fs_pin *);
};

struct bsd_acct_struct {
	struct fs_pin pin;
	atomic_long_t count;
	struct callback_head rcu;
	struct mutex lock;
	bool active;
	bool check_space;
	long unsigned int needcheck;
	struct file *file;
	struct pid_namespace *ns;
	struct work_struct work;
	struct completion done;
	acct_t ac;
};

struct cdev {
	struct kobject kobj;
	struct module *owner;
	const struct file_operations *ops;
	struct list_head list;
	dev_t dev;
	unsigned int count;
};

struct sg_io_v4;

typedef int bsg_sg_io_fn(struct request_queue *, struct sg_io_v4 *, bool, unsigned int);

struct bsg_device {
	struct request_queue *queue;
	struct device device;
	struct cdev cdev;
	int max_queue;
	unsigned int timeout;
	unsigned int reserved_size;
	bsg_sg_io_fn *sg_io_fn;
};

struct bss_parameters {
	int link_id;
	int use_cts_prot;
	int use_short_preamble;
	int use_short_slot_time;
	const u8 *basic_rates;
	u8 basic_rates_len;
	int ap_isolate;
	int ht_opmode;
	s8 p2p_ctwindow;
	s8 p2p_opp_ps;
};

typedef bool busy_tag_iter_fn(struct request *, void *);

struct bt_iter_data {
	struct blk_mq_hw_ctx *hctx;
	struct request_queue *q;
	busy_tag_iter_fn *fn;
	void *data;
	bool reserved;
};

struct bt_tags_iter_data {
	struct blk_mq_tags *tags;
	busy_tag_iter_fn *fn;
	void *data;
	unsigned int flags;
};

struct btf_header {
	__u16 magic;
	__u8 version;
	__u8 flags;
	__u32 hdr_len;
	__u32 type_off;
	__u32 type_len;
	__u32 str_off;
	__u32 str_len;
};

struct btf_kfunc_set_tab;

struct btf_id_dtor_kfunc_tab;

struct btf_struct_metas;

struct btf_struct_ops_tab;

struct btf {
	void *data;
	struct btf_type **types;
	u32 *resolved_ids;
	u32 *resolved_sizes;
	const char *strings;
	void *nohdr_data;
	struct btf_header hdr;
	u32 nr_types;
	u32 types_size;
	u32 data_size;
	refcount_t refcnt;
	u32 id;
	struct callback_head rcu;
	struct btf_kfunc_set_tab *kfunc_set_tab;
	struct btf_id_dtor_kfunc_tab *dtor_kfunc_tab;
	struct btf_struct_metas *struct_meta_tab;
	struct btf_struct_ops_tab *struct_ops_tab;
	struct btf *base_btf;
	u32 start_id;
	u32 start_str_off;
	char name[56];
	bool kernel_btf;
	__u32 *base_id_map;
};

struct btf_anon_stack {
	u32 tid;
	u32 offset;
};

struct btf_array {
	__u32 type;
	__u32 index_type;
	__u32 nelems;
};

struct btf_decl_tag {
	__s32 component_idx;
};

struct btf_enum {
	__u32 name_off;
	__s32 val;
};

struct btf_enum64 {
	__u32 name_off;
	__u32 val_lo32;
	__u32 val_hi32;
};

typedef void (*btf_dtor_kfunc_t)(void *);

struct btf_field_kptr {
	struct btf *btf;
	struct module *module;
	btf_dtor_kfunc_t dtor;
	u32 btf_id;
};

struct btf_field_graph_root {
	struct btf *btf;
	u32 value_btf_id;
	u32 node_offset;
	struct btf_record *value_rec;
};

struct btf_field {
	u32 offset;
	u32 size;
	enum btf_field_type type;
	union {
		struct btf_field_kptr kptr;
		struct btf_field_graph_root graph_root;
	};
};

struct btf_field_desc {
	int t_off_cnt;
	int t_offs[2];
	int m_sz;
	int m_off_cnt;
	int m_offs[1];
};

struct btf_field_info {
	enum btf_field_type type;
	u32 off;
	union {
		struct {
			u32 type_id;
		} kptr;
		struct {
			const char *node_name;
			u32 value_btf_id;
		} graph_root;
	};
};

struct btf_field_iter {
	struct btf_field_desc desc;
	void *p;
	int m_idx;
	int off_idx;
	int vlen;
};

struct btf_id_dtor_kfunc {
	u32 btf_id;
	u32 kfunc_btf_id;
};

struct btf_id_dtor_kfunc_tab {
	u32 cnt;
	struct btf_id_dtor_kfunc dtors[0];
};

struct btf_id_set {
	u32 cnt;
	u32 ids[0];
};

struct btf_id_set8 {
	u32 cnt;
	u32 flags;
	struct {
		u32 id;
		u32 flags;
	} pairs[0];
};

typedef int (*btf_kfunc_filter_t)(const struct bpf_prog *, u32);

struct btf_kfunc_hook_filter {
	btf_kfunc_filter_t filters[16];
	u32 nr_filters;
};

struct btf_kfunc_id_set {
	struct module *owner;
	struct btf_id_set8 *set;
	btf_kfunc_filter_t filter;
};

struct btf_kfunc_set_tab {
	struct btf_id_set8 *sets[14];
	struct btf_kfunc_hook_filter hook_filters[14];
};

struct btf_verifier_env;

struct resolve_vertex;

struct btf_show;

struct btf_kind_operations {
	s32 (*check_meta)(struct btf_verifier_env *, const struct btf_type *, u32);
	int (*resolve)(struct btf_verifier_env *, const struct resolve_vertex *);
	int (*check_member)(struct btf_verifier_env *, const struct btf_type *, const struct btf_member *, const struct btf_type *);
	int (*check_kflag_member)(struct btf_verifier_env *, const struct btf_type *, const struct btf_member *, const struct btf_type *);
	void (*log_details)(struct btf_verifier_env *, const struct btf_type *);
	void (*show)(const struct btf *, const struct btf_type *, u32, void *, u8, struct btf_show *);
};

struct btf_member {
	__u32 name_off;
	__u32 type;
	__u32 offset;
};

struct btf_module {
	struct list_head list;
	struct module *module;
	struct btf *btf;
	struct bin_attribute *sysfs_attr;
	int flags;
};

struct btf_name_info {
	const char *name;
	bool needs_size: 1;
	unsigned int size: 31;
	__u32 id;
};

struct btf_param {
	__u32 name_off;
	__u32 type;
};

struct btf_ptr {
	void *ptr;
	__u32 type_id;
	__u32 flags;
};

struct btf_record {
	u32 cnt;
	u32 field_mask;
	int spin_lock_off;
	int timer_off;
	int wq_off;
	int refcount_off;
	struct btf_field fields[0];
};

struct btf_relocate {
	struct btf *btf;
	const struct btf *base_btf;
	const struct btf *dist_base_btf;
	unsigned int nr_base_types;
	unsigned int nr_split_types;
	unsigned int nr_dist_base_types;
	int dist_str_len;
	int base_str_len;
	__u32 *id_map;
	__u32 *str_map;
};

struct btf_sec_info {
	u32 off;
	u32 len;
};

struct btf_show {
	u64 flags;
	void *target;
	void (*showfn)(struct btf_show *, const char *, struct __va_list_tag *);
	const struct btf *btf;
	struct {
		u8 depth;
		u8 depth_to_show;
		u8 depth_check;
		u8 array_member: 1;
		u8 array_terminated: 1;
		u16 array_encoding;
		u32 type_id;
		int status;
		const struct btf_type *type;
		const struct btf_member *member;
		char name[80];
	} state;
	struct {
		u32 size;
		void *head;
		void *data;
		u8 safe[32];
	} obj;
};

struct btf_show_snprintf {
	struct btf_show show;
	int len_left;
	int len;
};

struct btf_struct_meta {
	u32 btf_id;
	struct btf_record *record;
};

struct btf_struct_metas {
	u32 cnt;
	struct btf_struct_meta types[0];
};

struct btf_struct_ops_tab {
	u32 cnt;
	u32 capacity;
	struct bpf_struct_ops_desc ops[0];
};

struct btf_type {
	__u32 name_off;
	__u32 info;
	union {
		__u32 size;
		__u32 type;
	};
};

struct btf_var {
	__u32 linkage;
};

struct btf_var_secinfo {
	__u32 type;
	__u32 offset;
	__u32 size;
};

struct resolve_vertex {
	const struct btf_type *t;
	u32 type_id;
	u16 next_member;
};

struct btf_verifier_env {
	struct btf *btf;
	u8 *visit_states;
	struct resolve_vertex stack[32];
	struct bpf_verifier_log log;
	u32 log_type_id;
	u32 top_stack;
	enum verifier_phase phase;
	enum resolve_mode resolve_mode;
};

struct bts_phys {
	struct page *page;
	long unsigned int size;
	long unsigned int offset;
	long unsigned int displacement;
};

struct bts_buffer {
	size_t real_size;
	unsigned int nr_pages;
	unsigned int nr_bufs;
	unsigned int cur_buf;
	bool snapshot;
	local_t data_size;
	local_t head;
	long unsigned int end;
	void **data_pages;
	struct bts_phys buf[0];
};

struct perf_buffer;

struct perf_output_handle {
	struct perf_event *event;
	struct perf_buffer *rb;
	long unsigned int wakeup;
	long unsigned int size;
	u64 aux_flags;
	union {
		void *addr;
		long unsigned int head;
	};
	int page;
};

struct debug_store {
	u64 bts_buffer_base;
	u64 bts_index;
	u64 bts_absolute_maximum;
	u64 bts_interrupt_threshold;
	u64 pebs_buffer_base;
	u64 pebs_index;
	u64 pebs_absolute_maximum;
	u64 pebs_interrupt_threshold;
	u64 pebs_event_reset[48];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct bts_ctx {
	struct perf_output_handle handle;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct debug_store ds_back;
	int state;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct bts_record {
	u64 from;
	u64 to;
	u64 flags;
};

struct hlist_nulls_node;

struct hlist_nulls_head {
	struct hlist_nulls_node *first;
};

struct bucket {
	struct hlist_nulls_head head;
	raw_spinlock_t raw_lock;
};

struct lockdep_map {};

struct rhash_lock_head;

struct bucket_table {
	unsigned int size;
	unsigned int nest;
	u32 hash_rnd;
	struct list_head walkers;
	struct callback_head rcu;
	struct bucket_table *future_tbl;
	struct lockdep_map dep_map;
	long: 64;
	struct rhash_lock_head *buckets[0];
};

struct buddy_page_mask {
	u32 page_mask;
	u8 type;
	u8 num_channels;
};

struct buf_sel_arg {
	struct iovec *iovs;
	size_t out_len;
	size_t max_len;
	short unsigned int nr_iovs;
	short unsigned int mode;
};

struct buffer_data_page {
	u64 time_stamp;
	local_t commit;
	unsigned char data[0];
};

struct buffer_data_read_page {
	unsigned int order;
	struct buffer_data_page *data;
};

typedef void bh_end_io_t(struct buffer_head *, int);

struct buffer_head {
	long unsigned int b_state;
	struct buffer_head *b_this_page;
	union {
		struct page *b_page;
		struct folio *b_folio;
	};
	sector_t b_blocknr;
	size_t b_size;
	char *b_data;
	struct block_device *b_bdev;
	bh_end_io_t *b_end_io;
	void *b_private;
	struct list_head b_assoc_buffers;
	struct address_space *b_assoc_map;
	atomic_t b_count;
	spinlock_t b_uptodate_lock;
};

struct buffer_page {
	struct list_head list;
	local_t write;
	unsigned int read;
	local_t entries;
	long unsigned int real_end;
	unsigned int order;
	u32 id: 30;
	u32 range: 1;
	struct buffer_data_page *page;
};

struct buffer_ref {
	struct trace_buffer *buffer;
	void *page;
	int cpu;
	refcount_t refcount;
};

struct bug_entry {
	int bug_addr_disp;
	int file_disp;
	short unsigned int line;
	short unsigned int flags;
};

struct builtin_fw {
	char *name;
	void *data;
	long unsigned int size;
};

struct bulk_cb_wrap {
	__le32 Signature;
	__u32 Tag;
	__le32 DataTransferLength;
	__u8 Flags;
	__u8 Lun;
	__u8 Length;
	__u8 CDB[16];
};

struct bulk_cs_wrap {
	__le32 Signature;
	__u32 Tag;
	__le32 Residue;
	__u8 Status;
};

struct group_data {
	int limit[21];
	int base[20];
	int permute[258];
	int minLen;
	int maxLen;
};

struct bunzip_data {
	int writeCopies;
	int writePos;
	int writeRunCountdown;
	int writeCount;
	int writeCurrent;
	long int (*fill)(void *, long unsigned int);
	long int inbufCount;
	long int inbufPos;
	unsigned char *inbuf;
	unsigned int inbufBitCount;
	unsigned int inbufBits;
	unsigned int crc32Table[256];
	unsigned int headerCRC;
	unsigned int totalCRC;
	unsigned int writeCRC;
	unsigned int *dbuf;
	unsigned int dbufSize;
	unsigned char selectors[32768];
	struct group_data groups[6];
	int io_error;
	int byteCount[256];
	unsigned char symToByte[256];
	unsigned char mtfSymbol[256];
};

struct bus_attribute {
	struct attribute attr;
	ssize_t (*show)(const struct bus_type *, char *);
	ssize_t (*store)(const struct bus_type *, const char *, size_t);
};

struct bus_dma_region {
	phys_addr_t cpu_start;
	dma_addr_t dma_start;
	u64 size;
};

struct bus_type {
	const char *name;
	const char *dev_name;
	const struct attribute_group **bus_groups;
	const struct attribute_group **dev_groups;
	const struct attribute_group **drv_groups;
	int (*match)(struct device *, const struct device_driver *);
	int (*uevent)(const struct device *, struct kobj_uevent_env *);
	int (*probe)(struct device *);
	void (*sync_state)(struct device *);
	void (*remove)(struct device *);
	void (*shutdown)(struct device *);
	const struct cpumask * (*irq_get_affinity)(struct device *, unsigned int);
	int (*online)(struct device *);
	int (*offline)(struct device *);
	int (*suspend)(struct device *, pm_message_t);
	int (*resume)(struct device *);
	int (*num_vf)(struct device *);
	int (*dma_configure)(struct device *);
	void (*dma_cleanup)(struct device *);
	const struct dev_pm_ops *pm;
	bool need_parent_lock;
};

struct bvec_iter_all {
	struct bio_vec bv;
	int idx;
	unsigned int done;
};

struct bxt_ddi_buf_trans {
	u8 margin;
	u8 scale;
	u8 enable;
	u8 deemphasis;
};

struct bxt_dpio_phy_info {
	bool dual_channel;
	enum dpio_phy rcomp_phy;
	int reset_delay;
	u32 pwron_mask;
	struct {
		enum port port;
	} channel[2];
};

struct bxt_dpll_hw_state {
	u32 ebb0;
	u32 ebb4;
	u32 pll0;
	u32 pll1;
	u32 pll2;
	u32 pll3;
	u32 pll6;
	u32 pll8;
	u32 pll9;
	u32 pll10;
	u32 pcsdw12;
};

struct byd_data {
	struct timer_list timer;
	struct psmouse *psmouse;
	s32 abs_x;
	s32 abs_y;
	volatile long unsigned int last_touch_time;
	bool btn_left;
	bool btn_right;
	bool touch;
};

struct cache_head;

struct cache_deferred_req {
	struct hlist_node hash;
	struct list_head recent;
	struct cache_head *item;
	void *owner;
	void (*revisit)(struct cache_deferred_req *, int);
};

struct cache_detail {
	struct module *owner;
	int hash_size;
	struct hlist_head *hash_table;
	spinlock_t hash_lock;
	char *name;
	void (*cache_put)(struct kref *);
	int (*cache_upcall)(struct cache_detail *, struct cache_head *);
	void (*cache_request)(struct cache_detail *, struct cache_head *, char **, int *);
	int (*cache_parse)(struct cache_detail *, char *, int);
	int (*cache_show)(struct seq_file *, struct cache_detail *, struct cache_head *);
	void (*warn_no_listener)(struct cache_detail *, int);
	struct cache_head * (*alloc)(void);
	void (*flush)(void);
	int (*match)(struct cache_head *, struct cache_head *);
	void (*init)(struct cache_head *, struct cache_head *);
	void (*update)(struct cache_head *, struct cache_head *);
	time64_t flush_time;
	struct list_head others;
	time64_t nextcheck;
	int entries;
	struct list_head queue;
	atomic_t writers;
	time64_t last_close;
	time64_t last_warn;
	union {
		struct proc_dir_entry *procfs;
		struct dentry *pipefs;
	};
	struct net *net;
};

struct cache_head {
	struct hlist_node cache_list;
	time64_t expiry_time;
	time64_t last_refresh;
	struct kref ref;
	long unsigned int flags;
};

struct cache_map {
	u64 start;
	u64 end;
	u64 flags;
	u64 type: 8;
	u64 fixed: 1;
};

struct cache_queue {
	struct list_head list;
	int reader;
};

struct cache_reader {
	struct cache_queue q;
	int offset;
};

struct cache_req {
	struct cache_deferred_req * (*defer)(struct cache_req *);
	long unsigned int thread_wait;
};

struct cache_request {
	struct cache_queue q;
	struct cache_head *item;
	char *buf;
	int len;
	int readers;
};

struct intel_iommu;

struct cache_tag {
	struct list_head node;
	enum cache_tag_type type;
	struct intel_iommu *iommu;
	struct device *dev;
	u16 domain_id;
	ioasid_t pasid;
	unsigned int users;
};

struct cacheinfo {
	unsigned int id;
	enum cache_type type;
	unsigned int level;
	unsigned int coherency_line_size;
	unsigned int number_of_sets;
	unsigned int ways_of_associativity;
	unsigned int physical_line_partition;
	unsigned int size;
	cpumask_t shared_cpu_map;
	unsigned int attributes;
	void *fw_token;
	bool disable_sysfs;
	void *priv;
};

struct cacheline_padding {
	char x[0];
};

struct cachestat {
	__u64 nr_cache;
	__u64 nr_dirty;
	__u64 nr_writeback;
	__u64 nr_evicted;
	__u64 nr_recently_evicted;
};

struct cachestat_range {
	__u64 off;
	__u64 len;
};

struct calipso_doi {
	u32 doi;
	u32 type;
	refcount_t refcount;
	struct list_head list;
	struct callback_head rcu;
};

struct calipso_map_cache_bkt {
	spinlock_t lock;
	u32 size;
	struct list_head list;
};

struct netlbl_lsm_cache;

struct calipso_map_cache_entry {
	u32 hash;
	unsigned char *key;
	size_t key_len;
	struct netlbl_lsm_cache *lsm_data;
	u32 activity;
	struct list_head list;
};

struct call_function_data {
	call_single_data_t *csd;
	cpumask_var_t cpumask;
	cpumask_var_t cpumask_ipi;
};

struct cb_process_state;

struct xdr_stream;

struct callback_op {
	__be32 (*process_op)(void *, void *, struct cb_process_state *);
	__be32 (*decode_args)(struct svc_rqst *, struct xdr_stream *, void *);
	__be32 (*encode_res)(struct svc_rqst *, struct xdr_stream *, const void *);
	long int res_maxsize;
};

struct callchain_cpus_entries {
	struct callback_head callback_head;
	struct perf_callchain_entry *cpu_entries[0];
};

struct callthunk_sites {
	s32 *call_start;
	s32 *call_end;
	struct alt_instr *alt_start;
	struct alt_instr *alt_end;
};

struct compact_control;

struct capture_control {
	struct compact_control *cc;
	struct page *page;
};

struct yenta_socket;

struct cardbus_type {
	int (*override)(struct yenta_socket *);
	void (*save_state)(struct yenta_socket *);
	void (*restore_state)(struct yenta_socket *);
	int (*sock_init)(struct yenta_socket *);
};

struct cat_datum {
	u32 value;
	unsigned char isalias;
};

struct config {
	u8 byte_count: 6;
	u8 pad0: 2;
	u8 rx_fifo_limit: 4;
	u8 tx_fifo_limit: 3;
	u8 pad1: 1;
	u8 adaptive_ifs;
	u8 mwi_enable: 1;
	u8 type_enable: 1;
	u8 read_align_enable: 1;
	u8 term_write_cache_line: 1;
	u8 pad3: 4;
	u8 rx_dma_max_count: 7;
	u8 pad4: 1;
	u8 tx_dma_max_count: 7;
	u8 dma_max_count_enable: 1;
	u8 late_scb_update: 1;
	u8 direct_rx_dma: 1;
	u8 tno_intr: 1;
	u8 cna_intr: 1;
	u8 standard_tcb: 1;
	u8 standard_stat_counter: 1;
	u8 rx_save_overruns: 1;
	u8 rx_save_bad_frames: 1;
	u8 rx_discard_short_frames: 1;
	u8 tx_underrun_retry: 2;
	u8 pad7: 2;
	u8 rx_extended_rfd: 1;
	u8 tx_two_frames_in_fifo: 1;
	u8 tx_dynamic_tbd: 1;
	u8 mii_mode: 1;
	u8 pad8: 6;
	u8 csma_disabled: 1;
	u8 rx_tcpudp_checksum: 1;
	u8 pad9: 3;
	u8 vlan_arp_tco: 1;
	u8 link_status_wake: 1;
	u8 arp_wake: 1;
	u8 mcmatch_wake: 1;
	u8 pad10: 3;
	u8 no_source_addr_insertion: 1;
	u8 preamble_length: 2;
	u8 loopback: 2;
	u8 linear_priority: 3;
	u8 pad11: 5;
	u8 linear_priority_mode: 1;
	u8 pad12: 3;
	u8 ifs: 4;
	u8 ip_addr_lo;
	u8 ip_addr_hi;
	u8 promiscuous_mode: 1;
	u8 broadcast_disabled: 1;
	u8 wait_after_win: 1;
	u8 pad15_1: 1;
	u8 ignore_ul_bit: 1;
	u8 crc_16_bit: 1;
	u8 pad15_2: 1;
	u8 crs_or_cdt: 1;
	u8 fc_delay_lo;
	u8 fc_delay_hi;
	u8 rx_stripping: 1;
	u8 tx_padding: 1;
	u8 rx_crc_transfer: 1;
	u8 rx_long_ok: 1;
	u8 fc_priority_threshold: 3;
	u8 pad18: 1;
	u8 addr_wake: 1;
	u8 magic_packet_disable: 1;
	u8 fc_disable: 1;
	u8 fc_restop: 1;
	u8 fc_restart: 1;
	u8 fc_reject: 1;
	u8 full_duplex_force: 1;
	u8 full_duplex_pin: 1;
	u8 pad20_1: 5;
	u8 fc_priority_location: 1;
	u8 multi_ia: 1;
	u8 pad20_2: 1;
	u8 pad21_1: 3;
	u8 multicast_all: 1;
	u8 pad21_2: 4;
	u8 rx_d102_mode: 1;
	u8 rx_vlan_drop: 1;
	u8 pad22: 6;
	u8 pad_d102[9];
};

struct multi {
	__le16 count;
	u8 addr[386];
};

struct cb {
	__le16 status;
	__le16 command;
	__le32 link;
	union {
		u8 iaaddr[6];
		__le32 ucode[134];
		struct config config;
		struct multi multi;
		struct {
			u32 tbd_array;
			u16 tcb_byte_count;
			u8 threshold;
			u8 tbd_count;
			struct {
				__le32 buf_addr;
				__le16 size;
				u16 eol;
			} tbd;
		} tcb;
		__le32 dump_buffer_addr;
	} u;
	struct cb *next;
	struct cb *prev;
	dma_addr_t dma_addr;
	struct sk_buff *skb;
};

struct cb_compound_hdr_arg {
	unsigned int taglen;
	const char *tag;
	unsigned int minorversion;
	unsigned int cb_ident;
	unsigned int nops;
};

struct cb_compound_hdr_res {
	__be32 *status;
	unsigned int taglen;
	const char *tag;
	__be32 *nops;
};

struct nfs_fh {
	short unsigned int size;
	unsigned char data[128];
};

struct cb_getattrargs {
	struct nfs_fh fh;
	uint32_t bitmap[3];
};

struct cb_getattrres {
	__be32 status;
	uint32_t bitmap[3];
	uint64_t size;
	uint64_t change_attr;
	struct timespec64 atime;
	struct timespec64 ctime;
	struct timespec64 mtime;
};

struct cb_id {
	__u32 idx;
	__u32 val;
};

struct cb_kernel {
	const void *data;
	u32 size;
};

struct nfs_client;

struct nfs4_slot;

struct cb_process_state {
	struct nfs_client *clp;
	struct nfs4_slot *slot;
	struct net *net;
	u32 minorversion;
	__be32 drc_status;
	unsigned int referring_calls;
};

struct nfs4_stateid_struct {
	union {
		char data[16];
		struct {
			__be32 seqid;
			char other[12];
		};
	};
	enum {
		NFS4_INVALID_STATEID_TYPE = 0,
		NFS4_SPECIAL_STATEID_TYPE = 1,
		NFS4_OPEN_STATEID_TYPE = 2,
		NFS4_LOCK_STATEID_TYPE = 3,
		NFS4_DELEGATION_STATEID_TYPE = 4,
		NFS4_LAYOUT_STATEID_TYPE = 5,
		NFS4_PNFS_DS_STATEID_TYPE = 6,
		NFS4_REVOKED_STATEID_TYPE = 7,
	} type;
};

typedef struct nfs4_stateid_struct nfs4_stateid;

struct cb_recallargs {
	struct nfs_fh fh;
	nfs4_stateid stateid;
	uint32_t truncate;
};

struct cbcmac_desc_ctx {
	unsigned int len;
	u8 dg[0];
};

struct crypto_cipher;

struct cbcmac_tfm_ctx {
	struct crypto_cipher *child;
};

struct ccm_instance_ctx {
	struct crypto_skcipher_spawn ctr;
	struct crypto_ahash_spawn mac;
};

struct ccs_modesel_head {
	__u8 _r1;
	__u8 medium;
	__u8 _r2;
	__u8 block_desc_length;
	__u8 density;
	__u8 number_blocks_hi;
	__u8 number_blocks_med;
	__u8 number_blocks_lo;
	__u8 _r3;
	__u8 block_length_hi;
	__u8 block_length_med;
	__u8 block_length_lo;
};

struct cdrom_msf0 {
	__u8 minute;
	__u8 second;
	__u8 frame;
};

union cdrom_addr {
	struct cdrom_msf0 msf;
	int lba;
};

struct cdrom_blk {
	unsigned int from;
	short unsigned int len;
};

struct cdrom_mechstat_header {
	__u8 curslot: 5;
	__u8 changer_state: 2;
	__u8 fault: 1;
	__u8 reserved1: 4;
	__u8 door_open: 1;
	__u8 mech_state: 3;
	__u8 curlba[3];
	__u8 nslots;
	__u16 slot_tablelen;
};

struct cdrom_slot {
	__u8 change: 1;
	__u8 reserved1: 6;
	__u8 disc_present: 1;
	__u8 reserved2[3];
};

struct cdrom_changer_info {
	struct cdrom_mechstat_header hdr;
	struct cdrom_slot slots[256];
};

struct cdrom_device_ops;

struct cdrom_device_info {
	const struct cdrom_device_ops *ops;
	struct list_head list;
	struct gendisk *disk;
	void *handle;
	int mask;
	int speed;
	int capacity;
	unsigned int options: 30;
	unsigned int mc_flags: 2;
	unsigned int vfs_events;
	unsigned int ioctl_events;
	int use_count;
	char name[20];
	__u8 sanyo_slot: 2;
	__u8 keeplocked: 1;
	__u8 reserved: 5;
	int cdda_method;
	__u8 last_sense;
	__u8 media_written;
	short unsigned int mmc3_profile;
	int (*exit)(struct cdrom_device_info *);
	int mrw_mode_page;
	bool opened_for_data;
	__s64 last_media_change_ms;
};

struct cdrom_multisession;

struct cdrom_mcn;

struct packet_command;

struct cdrom_device_ops {
	int (*open)(struct cdrom_device_info *, int);
	void (*release)(struct cdrom_device_info *);
	int (*drive_status)(struct cdrom_device_info *, int);
	unsigned int (*check_events)(struct cdrom_device_info *, unsigned int, int);
	int (*tray_move)(struct cdrom_device_info *, int);
	int (*lock_door)(struct cdrom_device_info *, int);
	int (*select_speed)(struct cdrom_device_info *, long unsigned int);
	int (*get_last_session)(struct cdrom_device_info *, struct cdrom_multisession *);
	int (*get_mcn)(struct cdrom_device_info *, struct cdrom_mcn *);
	int (*reset)(struct cdrom_device_info *);
	int (*audio_ioctl)(struct cdrom_device_info *, unsigned int, void *);
	int (*generic_packet)(struct cdrom_device_info *, struct packet_command *);
	int (*read_cdda_bpc)(struct cdrom_device_info *, void *, u32, u32, u8 *);
	const int capability;
};

struct request_sense;

struct cdrom_generic_command {
	unsigned char cmd[12];
	unsigned char *buffer;
	unsigned int buflen;
	int stat;
	struct request_sense *sense;
	unsigned char data_direction;
	int quiet;
	int timeout;
	union {
		void *reserved[1];
		void *unused;
	};
};

struct cdrom_mcn {
	__u8 medium_catalog_number[14];
};

struct cdrom_msf {
	__u8 cdmsf_min0;
	__u8 cdmsf_sec0;
	__u8 cdmsf_frame0;
	__u8 cdmsf_min1;
	__u8 cdmsf_sec1;
	__u8 cdmsf_frame1;
};

struct cdrom_multisession {
	union cdrom_addr addr;
	__u8 xa_flag;
	__u8 addr_format;
};

struct cdrom_read_audio {
	union cdrom_addr addr;
	__u8 addr_format;
	int nframes;
	__u8 *buf;
};

struct cdrom_subchnl {
	__u8 cdsc_format;
	__u8 cdsc_audiostatus;
	__u8 cdsc_adr: 4;
	__u8 cdsc_ctrl: 4;
	__u8 cdsc_trk;
	__u8 cdsc_ind;
	union cdrom_addr cdsc_absaddr;
	union cdrom_addr cdsc_reladdr;
};

struct cdrom_sysctl_settings {
	char info[1000];
	int autoclose;
	int autoeject;
	int debug;
	int lock;
	int check;
};

struct cdrom_ti {
	__u8 cdti_trk0;
	__u8 cdti_ind0;
	__u8 cdti_trk1;
	__u8 cdti_ind1;
};

struct cdrom_timed_media_change_info {
	__s64 last_media_change;
	__u64 media_flags;
};

struct cdrom_tocentry {
	__u8 cdte_track;
	__u8 cdte_adr: 4;
	__u8 cdte_ctrl: 4;
	__u8 cdte_format;
	union cdrom_addr cdte_addr;
	__u8 cdte_datamode;
};

struct cdrom_tochdr {
	__u8 cdth_trk0;
	__u8 cdth_trk1;
};

struct cdrom_volctrl {
	__u8 channel0;
	__u8 channel1;
	__u8 channel2;
	__u8 channel3;
};

struct clock_event_device;

struct ce_unbind {
	struct clock_event_device *ce;
	int res;
};

struct cea_db {
	u8 tag_length;
	u8 data[0];
};

struct drm_edid;

struct drm_edid_iter {
	const struct drm_edid *drm_edid;
	int index;
};

struct displayid_iter {
	const struct drm_edid *drm_edid;
	const u8 *section;
	int length;
	int idx;
	int ext_index;
	u8 version;
	u8 primary_use;
};

struct cea_db_iter {
	struct drm_edid_iter edid_iter;
	struct displayid_iter displayid_iter;
	const u8 *collection;
	int index;
	int end;
};

struct cea_exception_stacks {
	char DF_stack_guard[4096];
	char DF_stack[8192];
	char NMI_stack_guard[4096];
	char NMI_stack[8192];
	char DB_stack_guard[4096];
	char DB_stack[8192];
	char MCE_stack_guard[4096];
	char MCE_stack[8192];
	char VC_stack_guard[4096];
	char VC_stack[8192];
	char VC2_stack_guard[4096];
	char VC2_stack[8192];
	char IST_top_guard[4096];
};

struct cea_sad {
	u8 format;
	u8 channels;
	u8 freq;
	u8 byte2;
};

struct cec_adapter;

struct cec_msg;

struct cec_adap_ops {
	int (*adap_enable)(struct cec_adapter *, bool);
	int (*adap_monitor_all_enable)(struct cec_adapter *, bool);
	int (*adap_monitor_pin_enable)(struct cec_adapter *, bool);
	int (*adap_log_addr)(struct cec_adapter *, u8);
	void (*adap_unconfigured)(struct cec_adapter *);
	int (*adap_transmit)(struct cec_adapter *, u8, u32, struct cec_msg *);
	void (*adap_nb_transmit_canceled)(struct cec_adapter *, const struct cec_msg *);
	void (*adap_status)(struct cec_adapter *, struct seq_file *);
	void (*adap_free)(struct cec_adapter *);
	int (*error_inj_show)(struct cec_adapter *, struct seq_file *);
	bool (*error_inj_parse_line)(struct cec_adapter *, char *);
	void (*configured)(struct cec_adapter *);
	int (*received)(struct cec_adapter *, struct cec_msg *);
};

struct cec_devnode {
	struct device dev;
	struct cdev cdev;
	int minor;
	struct mutex lock;
	bool registered;
	bool unregistered;
	struct mutex lock_fhs;
	struct list_head fhs;
};

struct cec_log_addrs {
	__u8 log_addr[4];
	__u16 log_addr_mask;
	__u8 cec_version;
	__u8 num_log_addrs;
	__u32 vendor_id;
	__u32 flags;
	char osd_name[15];
	__u8 primary_device_type[4];
	__u8 log_addr_type[4];
	__u8 all_device_types[4];
	__u8 features[48];
};

struct cec_drm_connector_info {
	__u32 card_no;
	__u32 connector_id;
};

struct cec_connector_info {
	__u32 type;
	union {
		struct cec_drm_connector_info drm;
		__u32 raw[16];
	};
};

struct rc_dev;

struct cec_data;

struct cec_fh;

struct cec_adapter {
	struct module *owner;
	char name[32];
	struct cec_devnode devnode;
	struct mutex lock;
	struct rc_dev *rc;
	struct list_head transmit_queue;
	unsigned int transmit_queue_sz;
	struct list_head wait_queue;
	struct cec_data *transmitting;
	bool transmit_in_progress;
	bool transmit_in_progress_aborted;
	unsigned int xfer_timeout_ms;
	struct task_struct *kthread_config;
	struct completion config_completion;
	struct task_struct *kthread;
	wait_queue_head_t kthread_waitq;
	const struct cec_adap_ops *ops;
	void *priv;
	u32 capabilities;
	u8 available_log_addrs;
	u16 phys_addr;
	bool needs_hpd;
	bool is_enabled;
	bool is_claiming_log_addrs;
	bool is_configuring;
	bool must_reconfigure;
	bool is_configured;
	bool cec_pin_is_high;
	bool adap_controls_phys_addr;
	u8 last_initiator;
	u32 monitor_all_cnt;
	u32 monitor_pin_cnt;
	u32 follower_cnt;
	struct cec_fh *cec_follower;
	struct cec_fh *cec_initiator;
	bool passthrough;
	struct cec_log_addrs log_addrs;
	struct cec_connector_info conn_info;
	u32 tx_timeout_cnt;
	u32 tx_low_drive_cnt;
	u32 tx_error_cnt;
	u32 tx_arb_lost_cnt;
	u32 tx_low_drive_log_cnt;
	u32 tx_error_log_cnt;
	struct dentry *cec_dir;
	u32 sequence;
	char input_phys[40];
};

struct cec_msg {
	__u64 tx_ts;
	__u64 rx_ts;
	__u32 len;
	__u32 timeout;
	__u32 sequence;
	__u32 flags;
	__u8 msg[16];
	__u8 reply;
	__u8 rx_status;
	__u8 tx_status;
	__u8 tx_arb_lost_cnt;
	__u8 tx_nack_cnt;
	__u8 tx_low_drive_cnt;
	__u8 tx_error_cnt;
};

struct cec_data {
	struct list_head list;
	struct list_head xfer_list;
	struct cec_adapter *adap;
	struct cec_msg msg;
	u8 match_len;
	u8 match_reply[5];
	struct cec_fh *fh;
	struct delayed_work work;
	struct completion c;
	u8 attempts;
	bool blocking;
	bool completed;
};

struct cec_event_state_change {
	__u16 phys_addr;
	__u16 log_addr_mask;
	__u16 have_conn_info;
};

struct cec_event_lost_msgs {
	__u32 lost_msgs;
};

struct cec_event {
	__u64 ts;
	__u32 event;
	__u32 flags;
	union {
		struct cec_event_state_change state_change;
		struct cec_event_lost_msgs lost_msgs;
		__u32 raw[16];
	};
};

struct cec_event_entry {
	struct list_head list;
	struct cec_event ev;
};

struct cec_fh {
	struct list_head list;
	struct list_head xfer_list;
	struct cec_adapter *adap;
	u8 mode_initiator;
	u8 mode_follower;
	wait_queue_head_t wait;
	struct mutex lock;
	struct list_head events[8];
	u16 queued_events[8];
	unsigned int total_queued_events;
	struct cec_event_entry core_events[2];
	struct list_head msgs;
	unsigned int queued_msgs;
};

struct mac_address {
	u8 addr[6];
};

struct cfg80211_acl_data {
	enum nl80211_acl_policy acl_policy;
	int n_acl_entries;
	struct mac_address mac_addrs[0];
};

struct ieee80211_edmg {
	u8 channels;
	enum ieee80211_edmg_bw_config bw_config;
};

struct ieee80211_channel;

struct cfg80211_chan_def {
	struct ieee80211_channel *chan;
	enum nl80211_chan_width width;
	u32 center_freq1;
	u32 center_freq2;
	struct ieee80211_edmg edmg;
	u16 freq1_offset;
	u16 punctured;
};

struct cfg80211_he_bss_color {
	u8 color;
	bool enabled;
	bool partial;
};

struct cfg80211_beacon_data {
	unsigned int link_id;
	const u8 *head;
	const u8 *tail;
	const u8 *beacon_ies;
	const u8 *proberesp_ies;
	const u8 *assocresp_ies;
	const u8 *probe_resp;
	const u8 *lci;
	const u8 *civicloc;
	struct cfg80211_mbssid_elems *mbssid_ies;
	struct cfg80211_rnr_elems *rnr_ies;
	s8 ftm_responder;
	size_t head_len;
	size_t tail_len;
	size_t beacon_ies_len;
	size_t proberesp_ies_len;
	size_t assocresp_ies_len;
	size_t probe_resp_len;
	size_t lci_len;
	size_t civicloc_len;
	struct cfg80211_he_bss_color he_bss_color;
	bool he_bss_color_valid;
};

struct cfg80211_crypto_settings {
	u32 wpa_versions;
	u32 cipher_group;
	int n_ciphers_pairwise;
	u32 ciphers_pairwise[5];
	int n_akm_suites;
	u32 akm_suites[10];
	bool control_port;
	__be16 control_port_ethertype;
	bool control_port_no_encrypt;
	bool control_port_over_nl80211;
	bool control_port_no_preauth;
	const u8 *psk;
	const u8 *sae_pwd;
	u8 sae_pwd_len;
	enum nl80211_sae_pwe_mechanism sae_pwe;
};

struct cfg80211_bitrate_mask {
	struct {
		u32 legacy;
		u8 ht_mcs[10];
		u16 vht_mcs[8];
		u16 he_mcs[8];
		enum nl80211_txrate_gi gi;
		enum nl80211_he_gi he_gi;
		enum nl80211_he_ltf he_ltf;
	} control[6];
};

struct ieee80211_he_obss_pd {
	bool enable;
	u8 sr_ctrl;
	u8 non_srg_max_offset;
	u8 min_offset;
	u8 max_offset;
	u8 bss_color_bitmap[8];
	u8 partial_bssid_bitmap[8];
};

struct cfg80211_fils_discovery {
	bool update;
	u32 min_interval;
	u32 max_interval;
	size_t tmpl_len;
	const u8 *tmpl;
};

struct cfg80211_unsol_bcast_probe_resp {
	bool update;
	u32 interval;
	size_t tmpl_len;
	const u8 *tmpl;
};

struct wireless_dev;

struct cfg80211_mbssid_config {
	struct wireless_dev *tx_wdev;
	u8 index;
	bool ema;
};

struct ieee80211_ht_cap;

struct ieee80211_vht_cap;

struct ieee80211_he_cap_elem;

struct ieee80211_he_operation;

struct ieee80211_eht_cap_elem;

struct ieee80211_eht_operation;

struct cfg80211_ap_settings {
	struct cfg80211_chan_def chandef;
	struct cfg80211_beacon_data beacon;
	int beacon_interval;
	int dtim_period;
	const u8 *ssid;
	size_t ssid_len;
	enum nl80211_hidden_ssid hidden_ssid;
	struct cfg80211_crypto_settings crypto;
	bool privacy;
	enum nl80211_auth_type auth_type;
	int inactivity_timeout;
	u8 p2p_ctwindow;
	bool p2p_opp_ps;
	const struct cfg80211_acl_data *acl;
	bool pbss;
	struct cfg80211_bitrate_mask beacon_rate;
	const struct ieee80211_ht_cap *ht_cap;
	const struct ieee80211_vht_cap *vht_cap;
	const struct ieee80211_he_cap_elem *he_cap;
	const struct ieee80211_he_operation *he_oper;
	const struct ieee80211_eht_cap_elem *eht_cap;
	const struct ieee80211_eht_operation *eht_oper;
	bool ht_required;
	bool vht_required;
	bool he_required;
	bool sae_h2e_required;
	bool twt_responder;
	u32 flags;
	struct ieee80211_he_obss_pd he_obss_pd;
	struct cfg80211_fils_discovery fils_discovery;
	struct cfg80211_unsol_bcast_probe_resp unsol_bcast_probe_resp;
	struct cfg80211_mbssid_config mbssid_config;
};

struct cfg80211_ap_update {
	struct cfg80211_beacon_data beacon;
	struct cfg80211_fils_discovery fils_discovery;
	struct cfg80211_unsol_bcast_probe_resp unsol_bcast_probe_resp;
};

struct cfg80211_bss;

struct cfg80211_assoc_failure {
	const u8 *ap_mld_addr;
	struct cfg80211_bss *bss[15];
	bool timeout;
};

struct cfg80211_assoc_link {
	struct cfg80211_bss *bss;
	const u8 *elems;
	size_t elems_len;
	bool disabled;
	int error;
};

struct ieee80211_mcs_info {
	u8 rx_mask[10];
	__le16 rx_highest;
	u8 tx_params;
	u8 reserved[3];
};

struct ieee80211_ht_cap {
	__le16 cap_info;
	u8 ampdu_params_info;
	struct ieee80211_mcs_info mcs;
	__le16 extended_ht_cap_info;
	__le32 tx_BF_cap_info;
	u8 antenna_selection_info;
} __attribute__((packed));

struct ieee80211_vht_mcs_info {
	__le16 rx_mcs_map;
	__le16 rx_highest;
	__le16 tx_mcs_map;
	__le16 tx_highest;
};

struct ieee80211_vht_cap {
	__le32 vht_cap_info;
	struct ieee80211_vht_mcs_info supp_mcs;
};

struct ieee80211_s1g_cap {
	u8 capab_info[10];
	u8 supp_mcs_nss[5];
};

struct cfg80211_assoc_request {
	struct cfg80211_bss *bss;
	const u8 *ie;
	const u8 *prev_bssid;
	size_t ie_len;
	struct cfg80211_crypto_settings crypto;
	bool use_mfp;
	int: 0;
	u32 flags;
	const u8 *supported_selectors;
	u8 supported_selectors_len;
	struct ieee80211_ht_cap ht_capa;
	struct ieee80211_ht_cap ht_capa_mask;
	struct ieee80211_vht_cap vht_capa;
	struct ieee80211_vht_cap vht_capa_mask;
	long: 0;
	const u8 *fils_kek;
	size_t fils_kek_len;
	const u8 *fils_nonces;
	struct ieee80211_s1g_cap s1g_capa;
	struct ieee80211_s1g_cap s1g_capa_mask;
	long: 0;
	struct cfg80211_assoc_link links[15];
	const u8 *ap_mld_addr;
	s8 link_id;
	long: 0;
} __attribute__((packed));

struct cfg80211_auth_request {
	struct cfg80211_bss *bss;
	const u8 *ie;
	size_t ie_len;
	const u8 *supported_selectors;
	u8 supported_selectors_len;
	enum nl80211_auth_type auth_type;
	const u8 *key;
	u8 key_len;
	s8 key_idx;
	const u8 *auth_data;
	size_t auth_data_len;
	s8 link_id;
	const u8 *ap_mld_addr;
};

struct cfg80211_beacon_registration {
	struct list_head list;
	u32 nlportid;
};

struct cfg80211_beaconing_check_config {
	enum nl80211_iftype iftype;
	enum ieee80211_ap_reg_power reg_power;
	bool relax;
};

struct cfg80211_bss_ies;

struct cfg80211_bss {
	struct ieee80211_channel *channel;
	const struct cfg80211_bss_ies *ies;
	const struct cfg80211_bss_ies *beacon_ies;
	const struct cfg80211_bss_ies *proberesp_ies;
	struct cfg80211_bss *hidden_beacon_bss;
	struct cfg80211_bss *transmitted_bss;
	struct list_head nontrans_list;
	s32 signal;
	u16 beacon_interval;
	u16 capability;
	u8 bssid[6];
	u8 chains;
	s8 chain_signal[4];
	u8 proberesp_ecsa_stuck: 1;
	u8 bssid_index;
	u8 max_bssid_indicator;
	u8 use_for;
	u8 cannot_use_reasons;
	u8 priv[0];
};

struct cfg80211_bss_ies {
	u64 tsf;
	struct callback_head callback_head;
	int len;
	bool from_beacon;
	u8 data[0];
};

struct cfg80211_bss_select_adjust {
	enum nl80211_band band;
	s8 delta;
};

struct cfg80211_bss_selection {
	enum nl80211_bss_select_attr behaviour;
	union {
		enum nl80211_band band_pref;
		struct cfg80211_bss_select_adjust adjust;
	} param;
};

struct key_params {
	const u8 *key;
	const u8 *seq;
	int key_len;
	int seq_len;
	u16 vlan_id;
	u32 cipher;
	enum nl80211_key_mode mode;
};

struct cfg80211_cached_keys {
	struct key_params params[4];
	u8 data[52];
	int def;
};

struct cfg80211_pkt_pattern;

struct cfg80211_coalesce_rules {
	int delay;
	enum nl80211_coalesce_condition condition;
	struct cfg80211_pkt_pattern *patterns;
	int n_patterns;
};

struct cfg80211_coalesce {
	int n_rules;
	struct cfg80211_coalesce_rules rules[0];
};

struct cfg80211_colocated_ap {
	struct list_head list;
	u8 bssid[6];
	u8 ssid[32];
	size_t ssid_len;
	u32 short_ssid;
	u32 center_freq;
	u8 unsolicited_probe: 1;
	u8 oct_recommended: 1;
	u8 same_ssid: 1;
	u8 multi_bss: 1;
	u8 transmitted_bssid: 1;
	u8 colocated_ess: 1;
	u8 short_ssid_valid: 1;
	s8 psd_20;
};

struct cfg80211_color_change_settings {
	struct cfg80211_beacon_data beacon_color_change;
	u16 counter_offset_beacon;
	u16 counter_offset_presp;
	struct cfg80211_beacon_data beacon_next;
	u8 count;
	u8 color;
	u8 link_id;
};

struct cfg80211_connect_params {
	struct ieee80211_channel *channel;
	struct ieee80211_channel *channel_hint;
	const u8 *bssid;
	const u8 *bssid_hint;
	const u8 *ssid;
	size_t ssid_len;
	enum nl80211_auth_type auth_type;
	const u8 *ie;
	size_t ie_len;
	bool privacy;
	enum nl80211_mfp mfp;
	struct cfg80211_crypto_settings crypto;
	const u8 *key;
	u8 key_len;
	u8 key_idx;
	u32 flags;
	int bg_scan_period;
	struct ieee80211_ht_cap ht_capa;
	struct ieee80211_ht_cap ht_capa_mask;
	struct ieee80211_vht_cap vht_capa;
	struct ieee80211_vht_cap vht_capa_mask;
	bool pbss;
	struct cfg80211_bss_selection bss_select;
	const u8 *prev_bssid;
	const u8 *fils_erp_username;
	size_t fils_erp_username_len;
	const u8 *fils_erp_realm;
	size_t fils_erp_realm_len;
	u16 fils_erp_next_seq_num;
	const u8 *fils_erp_rrk;
	size_t fils_erp_rrk_len;
	bool want_1x;
	struct ieee80211_edmg edmg;
};

struct cfg80211_conn {
	struct cfg80211_connect_params params;
	enum {
		CFG80211_CONN_SCANNING = 0,
		CFG80211_CONN_SCAN_AGAIN = 1,
		CFG80211_CONN_AUTHENTICATE_NEXT = 2,
		CFG80211_CONN_AUTHENTICATING = 3,
		CFG80211_CONN_AUTH_FAILED_TIMEOUT = 4,
		CFG80211_CONN_ASSOCIATE_NEXT = 5,
		CFG80211_CONN_ASSOCIATING = 6,
		CFG80211_CONN_ASSOC_FAILED = 7,
		CFG80211_CONN_ASSOC_FAILED_TIMEOUT = 8,
		CFG80211_CONN_DEAUTH = 9,
		CFG80211_CONN_ABANDON = 10,
		CFG80211_CONN_CONNECTED = 11,
	} state;
	u8 bssid[6];
	u8 prev_bssid[6];
	const u8 *ie;
	size_t ie_len;
	bool auto_auth;
	bool prev_bssid_valid;
};

struct cfg80211_fils_resp_params {
	const u8 *kek;
	size_t kek_len;
	bool update_erp_next_seq_num;
	u16 erp_next_seq_num;
	const u8 *pmk;
	size_t pmk_len;
	const u8 *pmkid;
};

struct cfg80211_connect_resp_params {
	int status;
	const u8 *req_ie;
	size_t req_ie_len;
	const u8 *resp_ie;
	size_t resp_ie_len;
	struct cfg80211_fils_resp_params fils;
	enum nl80211_timeout_reason timeout_reason;
	const u8 *ap_mld_addr;
	u16 valid_links;
	struct {
		const u8 *addr;
		const u8 *bssid;
		struct cfg80211_bss *bss;
		u16 status;
	} links[15];
};

struct cfg80211_cqm_config {
	struct callback_head callback_head;
	u32 rssi_hyst;
	s32 last_rssi_event_value;
	enum nl80211_cqm_rssi_threshold_event last_rssi_event_type;
	bool use_range_api;
	int n_rssi_thresholds;
	s32 rssi_thresholds[0];
};

struct cfg80211_csa_settings {
	struct cfg80211_chan_def chandef;
	struct cfg80211_beacon_data beacon_csa;
	const u16 *counter_offsets_beacon;
	const u16 *counter_offsets_presp;
	unsigned int n_counter_offsets_beacon;
	unsigned int n_counter_offsets_presp;
	struct cfg80211_beacon_data beacon_after;
	bool radar_required;
	bool block_tx;
	u8 count;
	u8 link_id;
};

struct cfg80211_deauth_request {
	const u8 *bssid;
	const u8 *ie;
	size_t ie_len;
	u16 reason_code;
	bool local_state_change;
};

struct cfg80211_disassoc_request {
	const u8 *ap_addr;
	const u8 *ie;
	size_t ie_len;
	u16 reason_code;
	bool local_state_change;
};

struct cfg80211_dscp_exception {
	u8 dscp;
	u8 up;
};

struct cfg80211_dscp_range {
	u8 low;
	u8 high;
};

struct cfg80211_roam_info {
	const u8 *req_ie;
	size_t req_ie_len;
	const u8 *resp_ie;
	size_t resp_ie_len;
	struct cfg80211_fils_resp_params fils;
	const u8 *ap_mld_addr;
	u16 valid_links;
	struct {
		const u8 *addr;
		const u8 *bssid;
		struct ieee80211_channel *channel;
		struct cfg80211_bss *bss;
	} links[15];
};

struct cfg80211_event {
	struct list_head list;
	enum cfg80211_event_type type;
	union {
		struct cfg80211_connect_resp_params cr;
		struct cfg80211_roam_info rm;
		struct {
			const u8 *ie;
			size_t ie_len;
			u16 reason;
			bool locally_generated;
		} dc;
		struct {
			u8 bssid[6];
			struct ieee80211_channel *channel;
		} ij;
		struct {
			u8 peer_addr[6];
			const u8 *td_bitmap;
			u8 td_bitmap_len;
		} pa;
	};
};

struct cfg80211_ssid {
	u8 ssid[32];
	u8 ssid_len;
};

struct cfg80211_external_auth_params {
	enum nl80211_external_auth_action action;
	u8 bssid[6];
	struct cfg80211_ssid ssid;
	unsigned int key_mgmt_suite;
	u16 status;
	const u8 *pmkid;
	u8 mld_addr[6];
};

struct cfg80211_fils_aad {
	const u8 *macaddr;
	const u8 *kek;
	u8 kek_len;
	const u8 *snonce;
	const u8 *anonce;
};

struct cfg80211_ft_event_params {
	const u8 *ies;
	size_t ies_len;
	const u8 *target_ap;
	const u8 *ric_ies;
	size_t ric_ies_len;
};

struct cfg80211_ftm_responder_stats {
	u32 filled;
	u32 success_num;
	u32 partial_num;
	u32 failed_num;
	u32 asap_num;
	u32 non_asap_num;
	u64 total_duration_ms;
	u32 unknown_triggers_num;
	u32 reschedule_requests_num;
	u32 out_of_window_triggers_num;
};

struct cfg80211_gtk_rekey_data {
	const u8 *kek;
	const u8 *kck;
	const u8 *replay_ctr;
	u32 akm;
	u8 kek_len;
	u8 kck_len;
};

struct cfg80211_ibss_params {
	const u8 *ssid;
	const u8 *bssid;
	struct cfg80211_chan_def chandef;
	const u8 *ie;
	u8 ssid_len;
	u8 ie_len;
	u16 beacon_interval;
	u32 basic_rates;
	bool channel_fixed;
	bool privacy;
	bool control_port;
	bool control_port_over_nl80211;
	bool userspace_handles_dfs;
	int mcast_rate[6];
	struct ieee80211_ht_cap ht_capa;
	struct ieee80211_ht_cap ht_capa_mask;
	struct key_params *wep_keys;
	int wep_tx_key;
};

struct cfg80211_inform_bss {
	struct ieee80211_channel *chan;
	s32 signal;
	u64 boottime_ns;
	u64 parent_tsf;
	u8 parent_bssid[6];
	u8 chains;
	s8 chain_signal[4];
	u8 restrict_use: 1;
	u8 use_for: 7;
	u8 cannot_use_reasons;
	void *drv_data;
};

struct cfg80211_inform_single_bss_data {
	struct cfg80211_inform_bss *drv_data;
	enum cfg80211_bss_frame_type ftype;
	struct ieee80211_channel *channel;
	u8 bssid[6];
	u64 tsf;
	u16 capability;
	u16 beacon_interval;
	const u8 *ie;
	size_t ielen;
	enum bss_source_type bss_source;
	struct cfg80211_bss *source_bss;
	u8 max_bssid_indicator;
	u8 bssid_index;
	u8 use_for;
	u64 cannot_use_reasons;
};

struct cfg80211_internal_bss {
	struct list_head list;
	struct list_head hidden_list;
	struct rb_node rbn;
	u64 ts_boottime;
	long unsigned int ts;
	long unsigned int refcount;
	atomic_t hold;
	u64 parent_tsf;
	u8 parent_bssid[6];
	enum bss_source_type bss_source;
	struct cfg80211_bss pub;
};

struct cfg80211_match_set {
	struct cfg80211_ssid ssid;
	u8 bssid[6];
	s32 rssi_thold;
};

struct cfg80211_mbssid_elems {
	u8 cnt;
	struct {
		const u8 *data;
		size_t len;
	} elem[0];
};

struct cfg80211_mgmt_registration {
	struct list_head list;
	struct wireless_dev *wdev;
	u32 nlportid;
	int match_len;
	__le16 frame_type;
	bool multicast_rx;
	u8 match[0];
};

struct cfg80211_mgmt_tx_params {
	struct ieee80211_channel *chan;
	bool offchan;
	unsigned int wait;
	const u8 *buf;
	size_t len;
	bool no_cck;
	bool dont_wait_for_ack;
	int n_csa_offsets;
	const u16 *csa_offsets;
	int link_id;
};

struct ieee80211_multi_link_elem;

struct ieee80211_mle_per_sta_profile;

struct cfg80211_mle {
	struct ieee80211_multi_link_elem *mle;
	struct ieee80211_mle_per_sta_profile *sta_prof[15];
	ssize_t sta_prof_len[15];
	u8 data[0];
};

struct cfg80211_mlo_reconf_done_data {
	const u8 *buf;
	size_t len;
	u16 added_links;
	struct {
		struct cfg80211_bss *bss;
	} links[15];
};

struct cfg80211_nan_conf {
	u8 master_pref;
	u8 bands;
};

struct cfg80211_nan_func_filter;

struct cfg80211_nan_func {
	enum nl80211_nan_function_type type;
	u8 service_id[6];
	u8 publish_type;
	bool close_range;
	bool publish_bcast;
	bool subscribe_active;
	u8 followup_id;
	u8 followup_reqid;
	struct mac_address followup_dest;
	u32 ttl;
	const u8 *serv_spec_info;
	u8 serv_spec_info_len;
	bool srf_include;
	const u8 *srf_bf;
	u8 srf_bf_len;
	u8 srf_bf_idx;
	struct mac_address *srf_macs;
	int srf_num_macs;
	struct cfg80211_nan_func_filter *rx_filters;
	struct cfg80211_nan_func_filter *tx_filters;
	u8 num_tx_filters;
	u8 num_rx_filters;
	u8 instance_id;
	u64 cookie;
};

struct cfg80211_nan_func_filter {
	const u8 *filter;
	u8 len;
};

struct cfg80211_nan_match_params {
	enum nl80211_nan_function_type type;
	u8 inst_id;
	u8 peer_inst_id;
	const u8 *addr;
	u8 info_len;
	const u8 *info;
	u64 cookie;
};

struct wiphy;

struct cfg80211_wowlan;

struct vif_params;

struct station_parameters;

struct station_del_parameters;

struct station_info;

struct mpath_info;

struct mesh_config;

struct mesh_setup;

struct ocb_setup;

struct ieee80211_txq_params;

struct cfg80211_scan_request;

struct survey_info;

struct cfg80211_pmksa;

struct mgmt_frame_regs;

struct cfg80211_sched_scan_request;

struct cfg80211_update_ft_ies_params;

struct cfg80211_qos_map;

struct cfg80211_txq_stats;

struct cfg80211_pmk_conf;

struct cfg80211_pmsr_request;

struct cfg80211_update_owe_info;

struct cfg80211_tid_config;

struct cfg80211_sar_specs;

struct link_station_parameters;

struct link_station_del_parameters;

struct cfg80211_set_hw_timestamp;

struct cfg80211_ttlm_params;

struct cfg80211_ops {
	int (*suspend)(struct wiphy *, struct cfg80211_wowlan *);
	int (*resume)(struct wiphy *);
	void (*set_wakeup)(struct wiphy *, bool);
	struct wireless_dev * (*add_virtual_intf)(struct wiphy *, const char *, unsigned char, enum nl80211_iftype, struct vif_params *);
	int (*del_virtual_intf)(struct wiphy *, struct wireless_dev *);
	int (*change_virtual_intf)(struct wiphy *, struct net_device *, enum nl80211_iftype, struct vif_params *);
	int (*add_intf_link)(struct wiphy *, struct wireless_dev *, unsigned int);
	void (*del_intf_link)(struct wiphy *, struct wireless_dev *, unsigned int);
	int (*add_key)(struct wiphy *, struct net_device *, int, u8, bool, const u8 *, struct key_params *);
	int (*get_key)(struct wiphy *, struct net_device *, int, u8, bool, const u8 *, void *, void (*)(void *, struct key_params *));
	int (*del_key)(struct wiphy *, struct net_device *, int, u8, bool, const u8 *);
	int (*set_default_key)(struct wiphy *, struct net_device *, int, u8, bool, bool);
	int (*set_default_mgmt_key)(struct wiphy *, struct net_device *, int, u8);
	int (*set_default_beacon_key)(struct wiphy *, struct net_device *, int, u8);
	int (*start_ap)(struct wiphy *, struct net_device *, struct cfg80211_ap_settings *);
	int (*change_beacon)(struct wiphy *, struct net_device *, struct cfg80211_ap_update *);
	int (*stop_ap)(struct wiphy *, struct net_device *, unsigned int);
	int (*add_station)(struct wiphy *, struct net_device *, const u8 *, struct station_parameters *);
	int (*del_station)(struct wiphy *, struct net_device *, struct station_del_parameters *);
	int (*change_station)(struct wiphy *, struct net_device *, const u8 *, struct station_parameters *);
	int (*get_station)(struct wiphy *, struct net_device *, const u8 *, struct station_info *);
	int (*dump_station)(struct wiphy *, struct net_device *, int, u8 *, struct station_info *);
	int (*add_mpath)(struct wiphy *, struct net_device *, const u8 *, const u8 *);
	int (*del_mpath)(struct wiphy *, struct net_device *, const u8 *);
	int (*change_mpath)(struct wiphy *, struct net_device *, const u8 *, const u8 *);
	int (*get_mpath)(struct wiphy *, struct net_device *, u8 *, u8 *, struct mpath_info *);
	int (*dump_mpath)(struct wiphy *, struct net_device *, int, u8 *, u8 *, struct mpath_info *);
	int (*get_mpp)(struct wiphy *, struct net_device *, u8 *, u8 *, struct mpath_info *);
	int (*dump_mpp)(struct wiphy *, struct net_device *, int, u8 *, u8 *, struct mpath_info *);
	int (*get_mesh_config)(struct wiphy *, struct net_device *, struct mesh_config *);
	int (*update_mesh_config)(struct wiphy *, struct net_device *, u32, const struct mesh_config *);
	int (*join_mesh)(struct wiphy *, struct net_device *, const struct mesh_config *, const struct mesh_setup *);
	int (*leave_mesh)(struct wiphy *, struct net_device *);
	int (*join_ocb)(struct wiphy *, struct net_device *, struct ocb_setup *);
	int (*leave_ocb)(struct wiphy *, struct net_device *);
	int (*change_bss)(struct wiphy *, struct net_device *, struct bss_parameters *);
	void (*inform_bss)(struct wiphy *, struct cfg80211_bss *, const struct cfg80211_bss_ies *, void *);
	int (*set_txq_params)(struct wiphy *, struct net_device *, struct ieee80211_txq_params *);
	int (*libertas_set_mesh_channel)(struct wiphy *, struct net_device *, struct ieee80211_channel *);
	int (*set_monitor_channel)(struct wiphy *, struct net_device *, struct cfg80211_chan_def *);
	int (*scan)(struct wiphy *, struct cfg80211_scan_request *);
	void (*abort_scan)(struct wiphy *, struct wireless_dev *);
	int (*auth)(struct wiphy *, struct net_device *, struct cfg80211_auth_request *);
	int (*assoc)(struct wiphy *, struct net_device *, struct cfg80211_assoc_request *);
	int (*deauth)(struct wiphy *, struct net_device *, struct cfg80211_deauth_request *);
	int (*disassoc)(struct wiphy *, struct net_device *, struct cfg80211_disassoc_request *);
	int (*connect)(struct wiphy *, struct net_device *, struct cfg80211_connect_params *);
	int (*update_connect_params)(struct wiphy *, struct net_device *, struct cfg80211_connect_params *, u32);
	int (*disconnect)(struct wiphy *, struct net_device *, u16);
	int (*join_ibss)(struct wiphy *, struct net_device *, struct cfg80211_ibss_params *);
	int (*leave_ibss)(struct wiphy *, struct net_device *);
	int (*set_mcast_rate)(struct wiphy *, struct net_device *, int *);
	int (*set_wiphy_params)(struct wiphy *, u32);
	int (*set_tx_power)(struct wiphy *, struct wireless_dev *, enum nl80211_tx_power_setting, int);
	int (*get_tx_power)(struct wiphy *, struct wireless_dev *, unsigned int, int *);
	void (*rfkill_poll)(struct wiphy *);
	int (*set_bitrate_mask)(struct wiphy *, struct net_device *, unsigned int, const u8 *, const struct cfg80211_bitrate_mask *);
	int (*dump_survey)(struct wiphy *, struct net_device *, int, struct survey_info *);
	int (*set_pmksa)(struct wiphy *, struct net_device *, struct cfg80211_pmksa *);
	int (*del_pmksa)(struct wiphy *, struct net_device *, struct cfg80211_pmksa *);
	int (*flush_pmksa)(struct wiphy *, struct net_device *);
	int (*remain_on_channel)(struct wiphy *, struct wireless_dev *, struct ieee80211_channel *, unsigned int, u64 *);
	int (*cancel_remain_on_channel)(struct wiphy *, struct wireless_dev *, u64);
	int (*mgmt_tx)(struct wiphy *, struct wireless_dev *, struct cfg80211_mgmt_tx_params *, u64 *);
	int (*mgmt_tx_cancel_wait)(struct wiphy *, struct wireless_dev *, u64);
	int (*set_power_mgmt)(struct wiphy *, struct net_device *, bool, int);
	int (*set_cqm_rssi_config)(struct wiphy *, struct net_device *, s32, u32);
	int (*set_cqm_rssi_range_config)(struct wiphy *, struct net_device *, s32, s32);
	int (*set_cqm_txe_config)(struct wiphy *, struct net_device *, u32, u32, u32);
	void (*update_mgmt_frame_registrations)(struct wiphy *, struct wireless_dev *, struct mgmt_frame_regs *);
	int (*set_antenna)(struct wiphy *, u32, u32);
	int (*get_antenna)(struct wiphy *, u32 *, u32 *);
	int (*sched_scan_start)(struct wiphy *, struct net_device *, struct cfg80211_sched_scan_request *);
	int (*sched_scan_stop)(struct wiphy *, struct net_device *, u64);
	int (*set_rekey_data)(struct wiphy *, struct net_device *, struct cfg80211_gtk_rekey_data *);
	int (*tdls_mgmt)(struct wiphy *, struct net_device *, const u8 *, int, u8, u8, u16, u32, bool, const u8 *, size_t);
	int (*tdls_oper)(struct wiphy *, struct net_device *, const u8 *, enum nl80211_tdls_operation);
	int (*probe_client)(struct wiphy *, struct net_device *, const u8 *, u64 *);
	int (*set_noack_map)(struct wiphy *, struct net_device *, u16);
	int (*get_channel)(struct wiphy *, struct wireless_dev *, unsigned int, struct cfg80211_chan_def *);
	int (*start_p2p_device)(struct wiphy *, struct wireless_dev *);
	void (*stop_p2p_device)(struct wiphy *, struct wireless_dev *);
	int (*set_mac_acl)(struct wiphy *, struct net_device *, const struct cfg80211_acl_data *);
	int (*start_radar_detection)(struct wiphy *, struct net_device *, struct cfg80211_chan_def *, u32, int);
	void (*end_cac)(struct wiphy *, struct net_device *, unsigned int);
	int (*update_ft_ies)(struct wiphy *, struct net_device *, struct cfg80211_update_ft_ies_params *);
	int (*crit_proto_start)(struct wiphy *, struct wireless_dev *, enum nl80211_crit_proto_id, u16);
	void (*crit_proto_stop)(struct wiphy *, struct wireless_dev *);
	int (*set_coalesce)(struct wiphy *, struct cfg80211_coalesce *);
	int (*channel_switch)(struct wiphy *, struct net_device *, struct cfg80211_csa_settings *);
	int (*set_qos_map)(struct wiphy *, struct net_device *, struct cfg80211_qos_map *);
	int (*set_ap_chanwidth)(struct wiphy *, struct net_device *, unsigned int, struct cfg80211_chan_def *);
	int (*add_tx_ts)(struct wiphy *, struct net_device *, u8, const u8 *, u8, u16);
	int (*del_tx_ts)(struct wiphy *, struct net_device *, u8, const u8 *);
	int (*tdls_channel_switch)(struct wiphy *, struct net_device *, const u8 *, u8, struct cfg80211_chan_def *);
	void (*tdls_cancel_channel_switch)(struct wiphy *, struct net_device *, const u8 *);
	int (*start_nan)(struct wiphy *, struct wireless_dev *, struct cfg80211_nan_conf *);
	void (*stop_nan)(struct wiphy *, struct wireless_dev *);
	int (*add_nan_func)(struct wiphy *, struct wireless_dev *, struct cfg80211_nan_func *);
	void (*del_nan_func)(struct wiphy *, struct wireless_dev *, u64);
	int (*nan_change_conf)(struct wiphy *, struct wireless_dev *, struct cfg80211_nan_conf *, u32);
	int (*set_multicast_to_unicast)(struct wiphy *, struct net_device *, const bool);
	int (*get_txq_stats)(struct wiphy *, struct wireless_dev *, struct cfg80211_txq_stats *);
	int (*set_pmk)(struct wiphy *, struct net_device *, const struct cfg80211_pmk_conf *);
	int (*del_pmk)(struct wiphy *, struct net_device *, const u8 *);
	int (*external_auth)(struct wiphy *, struct net_device *, struct cfg80211_external_auth_params *);
	int (*tx_control_port)(struct wiphy *, struct net_device *, const u8 *, size_t, const u8 *, const __be16, const bool, int, u64 *);
	int (*get_ftm_responder_stats)(struct wiphy *, struct net_device *, struct cfg80211_ftm_responder_stats *);
	int (*start_pmsr)(struct wiphy *, struct wireless_dev *, struct cfg80211_pmsr_request *);
	void (*abort_pmsr)(struct wiphy *, struct wireless_dev *, struct cfg80211_pmsr_request *);
	int (*update_owe_info)(struct wiphy *, struct net_device *, struct cfg80211_update_owe_info *);
	int (*probe_mesh_link)(struct wiphy *, struct net_device *, const u8 *, size_t);
	int (*set_tid_config)(struct wiphy *, struct net_device *, struct cfg80211_tid_config *);
	int (*reset_tid_config)(struct wiphy *, struct net_device *, const u8 *, u8);
	int (*set_sar_specs)(struct wiphy *, struct cfg80211_sar_specs *);
	int (*color_change)(struct wiphy *, struct net_device *, struct cfg80211_color_change_settings *);
	int (*set_fils_aad)(struct wiphy *, struct net_device *, struct cfg80211_fils_aad *);
	int (*set_radar_background)(struct wiphy *, struct cfg80211_chan_def *);
	int (*add_link_station)(struct wiphy *, struct net_device *, struct link_station_parameters *);
	int (*mod_link_station)(struct wiphy *, struct net_device *, struct link_station_parameters *);
	int (*del_link_station)(struct wiphy *, struct net_device *, struct link_station_del_parameters *);
	int (*set_hw_timestamp)(struct wiphy *, struct net_device *, struct cfg80211_set_hw_timestamp *);
	int (*set_ttlm)(struct wiphy *, struct net_device *, struct cfg80211_ttlm_params *);
	u32 (*get_radio_mask)(struct wiphy *, struct net_device *);
	int (*assoc_ml_reconf)(struct wiphy *, struct net_device *, struct cfg80211_assoc_link *, u16);
	int (*set_epcs)(struct wiphy *, struct net_device *, bool);
};

struct cfg80211_per_bw_puncturing_values {
	u8 len;
	const u16 *valid_values;
};

struct cfg80211_pkt_pattern {
	const u8 *mask;
	const u8 *pattern;
	int pattern_len;
	int pkt_offset;
};

struct cfg80211_pmk_conf {
	const u8 *aa;
	u8 pmk_len;
	const u8 *pmk;
	const u8 *pmk_r0_name;
};

struct cfg80211_pmksa {
	const u8 *bssid;
	const u8 *pmkid;
	const u8 *pmk;
	size_t pmk_len;
	const u8 *ssid;
	size_t ssid_len;
	const u8 *cache_id;
	u32 pmk_lifetime;
	u8 pmk_reauth_threshold;
};

struct cfg80211_pmsr_capabilities {
	unsigned int max_peers;
	u8 report_ap_tsf: 1;
	u8 randomize_mac_addr: 1;
	struct {
		u32 preambles;
		u32 bandwidths;
		s8 max_bursts_exponent;
		u8 max_ftms_per_burst;
		u8 supported: 1;
		u8 asap: 1;
		u8 non_asap: 1;
		u8 request_lci: 1;
		u8 request_civicloc: 1;
		u8 trigger_based: 1;
		u8 non_trigger_based: 1;
	} ftm;
};

struct cfg80211_pmsr_ftm_request_peer {
	enum nl80211_preamble preamble;
	u16 burst_period;
	u8 requested: 1;
	u8 asap: 1;
	u8 request_lci: 1;
	u8 request_civicloc: 1;
	u8 trigger_based: 1;
	u8 non_trigger_based: 1;
	u8 lmr_feedback: 1;
	u8 num_bursts_exp;
	u8 burst_duration;
	u8 ftms_per_burst;
	u8 ftmr_retries;
	u8 bss_color;
};

struct rate_info {
	u16 flags;
	u16 legacy;
	u8 mcs;
	u8 nss;
	u8 bw;
	u8 he_gi;
	u8 he_dcm;
	u8 he_ru_alloc;
	u8 n_bonded_ch;
	u8 eht_gi;
	u8 eht_ru_alloc;
};

struct cfg80211_pmsr_ftm_result {
	const u8 *lci;
	const u8 *civicloc;
	unsigned int lci_len;
	unsigned int civicloc_len;
	enum nl80211_peer_measurement_ftm_failure_reasons failure_reason;
	u32 num_ftmr_attempts;
	u32 num_ftmr_successes;
	s16 burst_index;
	u8 busy_retry_time;
	u8 num_bursts_exp;
	u8 burst_duration;
	u8 ftms_per_burst;
	s32 rssi_avg;
	s32 rssi_spread;
	struct rate_info tx_rate;
	struct rate_info rx_rate;
	s64 rtt_avg;
	s64 rtt_variance;
	s64 rtt_spread;
	s64 dist_avg;
	s64 dist_variance;
	s64 dist_spread;
	u16 num_ftmr_attempts_valid: 1;
	u16 num_ftmr_successes_valid: 1;
	u16 rssi_avg_valid: 1;
	u16 rssi_spread_valid: 1;
	u16 tx_rate_valid: 1;
	u16 rx_rate_valid: 1;
	u16 rtt_avg_valid: 1;
	u16 rtt_variance_valid: 1;
	u16 rtt_spread_valid: 1;
	u16 dist_avg_valid: 1;
	u16 dist_variance_valid: 1;
	u16 dist_spread_valid: 1;
};

struct cfg80211_pmsr_request_peer {
	u8 addr[6];
	struct cfg80211_chan_def chandef;
	u8 report_ap_tsf: 1;
	struct cfg80211_pmsr_ftm_request_peer ftm;
};

struct cfg80211_pmsr_request {
	u64 cookie;
	void *drv_data;
	u32 n_peers;
	u32 nl_portid;
	u32 timeout;
	u8 mac_addr[6];
	u8 mac_addr_mask[6];
	struct list_head list;
	struct cfg80211_pmsr_request_peer peers[0];
};

struct cfg80211_pmsr_result {
	u64 host_time;
	u64 ap_tsf;
	enum nl80211_peer_measurement_status status;
	u8 addr[6];
	u8 final: 1;
	u8 ap_tsf_valid: 1;
	enum nl80211_peer_measurement_type type;
	union {
		struct cfg80211_pmsr_ftm_result ftm;
	};
};

struct cfg80211_qos_map {
	u8 num_des;
	struct cfg80211_dscp_exception dscp_exception[21];
	struct cfg80211_dscp_range up[8];
};

struct rfkill;

struct rfkill_ops {
	void (*poll)(struct rfkill *, void *);
	void (*query)(struct rfkill *, void *);
	int (*set_block)(void *, bool);
};

struct wiphy_work;

typedef void (*wiphy_work_func_t)(struct wiphy *, struct wiphy_work *);

struct wiphy_work {
	struct list_head entry;
	wiphy_work_func_t func;
};

struct ieee80211_txrx_stypes;

struct ieee80211_iface_combination;

struct wiphy_iftype_akm_suites;

struct wiphy_wowlan_support;

struct wiphy_iftype_ext_capab;

struct ieee80211_supported_band;

struct regulatory_request;

struct ieee80211_regdomain;

struct wiphy_coalesce_support;

struct wiphy_vendor_command;

struct nl80211_vendor_cmd_info;

struct cfg80211_sar_capa;

struct wiphy_radio;

struct wiphy {
	struct mutex mtx;
	u8 perm_addr[6];
	u8 addr_mask[6];
	struct mac_address *addresses;
	const struct ieee80211_txrx_stypes *mgmt_stypes;
	const struct ieee80211_iface_combination *iface_combinations;
	int n_iface_combinations;
	u16 software_iftypes;
	u16 n_addresses;
	u16 interface_modes;
	u16 max_acl_mac_addrs;
	u32 flags;
	u32 regulatory_flags;
	u32 features;
	u8 ext_features[9];
	u32 ap_sme_capa;
	enum cfg80211_signal_type signal_type;
	int bss_priv_size;
	u8 max_scan_ssids;
	u8 max_sched_scan_reqs;
	u8 max_sched_scan_ssids;
	u8 max_match_sets;
	u16 max_scan_ie_len;
	u16 max_sched_scan_ie_len;
	u32 max_sched_scan_plans;
	u32 max_sched_scan_plan_interval;
	u32 max_sched_scan_plan_iterations;
	int n_cipher_suites;
	const u32 *cipher_suites;
	int n_akm_suites;
	const u32 *akm_suites;
	const struct wiphy_iftype_akm_suites *iftype_akm_suites;
	unsigned int num_iftype_akm_suites;
	u8 retry_short;
	u8 retry_long;
	u32 frag_threshold;
	u32 rts_threshold;
	u8 coverage_class;
	char fw_version[32];
	u32 hw_version;
	const struct wiphy_wowlan_support *wowlan;
	struct cfg80211_wowlan *wowlan_config;
	u16 max_remain_on_channel_duration;
	u8 max_num_pmkids;
	u32 available_antennas_tx;
	u32 available_antennas_rx;
	u32 probe_resp_offload;
	const u8 *extended_capabilities;
	const u8 *extended_capabilities_mask;
	u8 extended_capabilities_len;
	const struct wiphy_iftype_ext_capab *iftype_ext_capab;
	unsigned int num_iftype_ext_capab;
	const void *privid;
	struct ieee80211_supported_band *bands[6];
	void (*reg_notifier)(struct wiphy *, struct regulatory_request *);
	const struct ieee80211_regdomain *regd;
	struct device dev;
	bool registered;
	struct dentry *debugfsdir;
	const struct ieee80211_ht_cap *ht_capa_mod_mask;
	const struct ieee80211_vht_cap *vht_capa_mod_mask;
	struct list_head wdev_list;
	possible_net_t _net;
	const struct wiphy_coalesce_support *coalesce;
	const struct wiphy_vendor_command *vendor_commands;
	const struct nl80211_vendor_cmd_info *vendor_events;
	int n_vendor_commands;
	int n_vendor_events;
	u16 max_ap_assoc_sta;
	u8 max_num_csa_counters;
	u32 bss_select_support;
	u8 nan_supported_bands;
	u32 txq_limit;
	u32 txq_memory_limit;
	u32 txq_quantum;
	long unsigned int tx_queue_len;
	u8 support_mbssid: 1;
	u8 support_only_he_mbssid: 1;
	const struct cfg80211_pmsr_capabilities *pmsr_capa;
	struct {
		u64 peer;
		u64 vif;
		u8 max_retry;
	} tid_config_support;
	u8 max_data_retry_count;
	const struct cfg80211_sar_capa *sar_capa;
	struct rfkill *rfkill;
	u8 mbssid_max_interfaces;
	u8 ema_max_profile_periodicity;
	u16 max_num_akm_suites;
	u16 hw_timestamp_max_peers;
	int n_radio;
	const struct wiphy_radio *radio;
	long: 64;
	char priv[0];
};

struct genl_info;

struct cfg80211_registered_device {
	const struct cfg80211_ops *ops;
	struct list_head list;
	struct rfkill_ops rfkill_ops;
	struct work_struct rfkill_block;
	char country_ie_alpha2[2];
	const struct ieee80211_regdomain *requested_regd;
	enum environment_cap env;
	int wiphy_idx;
	int devlist_generation;
	int wdev_id;
	int opencount;
	wait_queue_head_t dev_wait;
	struct list_head beacon_registrations;
	spinlock_t beacon_registrations_lock;
	int num_running_ifaces;
	int num_running_monitor_ifaces;
	u64 cookie_counter;
	spinlock_t bss_lock;
	struct list_head bss_list;
	struct rb_root bss_tree;
	u32 bss_generation;
	u32 bss_entries;
	struct cfg80211_scan_request *scan_req;
	struct cfg80211_scan_request *int_scan_req;
	struct sk_buff *scan_msg;
	struct list_head sched_scan_req_list;
	time64_t suspend_at;
	struct wiphy_work scan_done_wk;
	struct genl_info *cur_cmd_info;
	struct work_struct conn_work;
	struct work_struct event_work;
	struct delayed_work dfs_update_channels_wk;
	struct wireless_dev *background_radar_wdev;
	struct cfg80211_chan_def background_radar_chandef;
	struct delayed_work background_cac_done_wk;
	struct work_struct background_cac_abort_wk;
	u32 crit_proto_nlportid;
	struct cfg80211_coalesce *coalesce;
	struct work_struct destroy_work;
	struct wiphy_work sched_scan_stop_wk;
	struct work_struct sched_scan_res_wk;
	struct cfg80211_chan_def radar_chandef;
	struct work_struct propagate_radar_detect_wk;
	struct cfg80211_chan_def cac_done_chandef;
	struct work_struct propagate_cac_done_wk;
	struct work_struct mgmt_registrations_update_wk;
	spinlock_t mgmt_registrations_lock;
	struct work_struct wiphy_work;
	struct list_head wiphy_work_list;
	spinlock_t wiphy_work_lock;
	bool suspended;
	long: 64;
	long: 64;
	struct wiphy wiphy;
};

struct cfg80211_rnr_elems {
	u8 cnt;
	struct {
		const u8 *data;
		size_t len;
	} elem[0];
};

struct cfg80211_rx_assoc_resp_data {
	const u8 *buf;
	size_t len;
	const u8 *req_ies;
	size_t req_ies_len;
	int uapsd_queues;
	const u8 *ap_mld_addr;
	struct {
		u8 addr[6];
		struct cfg80211_bss *bss;
		u16 status;
	} links[15];
};

struct cfg80211_rx_info {
	int freq;
	int sig_dbm;
	bool have_link_id;
	u8 link_id;
	const u8 *buf;
	size_t len;
	u32 flags;
	u64 rx_tstamp;
	u64 ack_tstamp;
};

struct cfg80211_sar_freq_ranges;

struct cfg80211_sar_capa {
	enum nl80211_sar_type type;
	u32 num_freq_ranges;
	const struct cfg80211_sar_freq_ranges *freq_ranges;
};

struct cfg80211_sar_freq_ranges {
	u32 start_freq;
	u32 end_freq;
};

struct cfg80211_sar_sub_specs {
	s32 power;
	u32 freq_range_index;
};

struct cfg80211_sar_specs {
	enum nl80211_sar_type type;
	u32 num_sub_specs;
	struct cfg80211_sar_sub_specs sub_specs[0];
};

struct cfg80211_scan_6ghz_params {
	u32 short_ssid;
	u32 channel_idx;
	u8 bssid[6];
	bool unsolicited_probe;
	bool short_ssid_valid;
	bool psc_no_listen;
	s8 psd_20;
};

struct cfg80211_scan_info {
	u64 scan_start_tsf;
	u8 tsf_bssid[6];
	bool aborted;
};

struct cfg80211_scan_request {
	struct cfg80211_ssid *ssids;
	int n_ssids;
	u32 n_channels;
	const u8 *ie;
	size_t ie_len;
	u16 duration;
	bool duration_mandatory;
	u32 flags;
	u32 rates[6];
	struct wireless_dev *wdev;
	u8 mac_addr[6];
	u8 mac_addr_mask[6];
	u8 bssid[6];
	struct wiphy *wiphy;
	long unsigned int scan_start;
	struct cfg80211_scan_info info;
	bool notified;
	bool no_cck;
	bool scan_6ghz;
	u32 n_6ghz_params;
	struct cfg80211_scan_6ghz_params *scan_6ghz_params;
	s8 tsf_report_link_id;
	struct ieee80211_channel *channels[0];
};

struct cfg80211_sched_scan_plan {
	u32 interval;
	u32 iterations;
};

struct cfg80211_sched_scan_request {
	u64 reqid;
	struct cfg80211_ssid *ssids;
	int n_ssids;
	u32 n_channels;
	const u8 *ie;
	size_t ie_len;
	u32 flags;
	struct cfg80211_match_set *match_sets;
	int n_match_sets;
	s32 min_rssi_thold;
	u32 delay;
	struct cfg80211_sched_scan_plan *scan_plans;
	int n_scan_plans;
	u8 mac_addr[6];
	u8 mac_addr_mask[6];
	bool relative_rssi_set;
	s8 relative_rssi;
	struct cfg80211_bss_select_adjust rssi_adjust;
	struct wiphy *wiphy;
	struct net_device *dev;
	long unsigned int scan_start;
	bool report_results;
	struct callback_head callback_head;
	u32 owner_nlportid;
	bool nl_owner_dead;
	struct list_head list;
	struct ieee80211_channel *channels[0];
};

struct cfg80211_set_hw_timestamp {
	const u8 *macaddr;
	bool enable;
};

struct cfg80211_tid_cfg {
	bool config_override;
	u8 tids;
	u64 mask;
	enum nl80211_tid_config noack;
	u8 retry_long;
	u8 retry_short;
	enum nl80211_tid_config ampdu;
	enum nl80211_tid_config rtscts;
	enum nl80211_tid_config amsdu;
	enum nl80211_tx_rate_setting txrate_type;
	struct cfg80211_bitrate_mask txrate_mask;
};

struct cfg80211_tid_config {
	const u8 *peer;
	u32 n_tid_conf;
	struct cfg80211_tid_cfg tid_conf[0];
};

struct cfg80211_txq_stats {
	u32 filled;
	u32 backlog_bytes;
	u32 backlog_packets;
	u32 flows;
	u32 drops;
	u32 ecn_marks;
	u32 overlimit;
	u32 overmemory;
	u32 collisions;
	u32 tx_bytes;
	u32 tx_packets;
	u32 max_flows;
};

struct cfg80211_tid_stats {
	u32 filled;
	u64 rx_msdu;
	u64 tx_msdu;
	u64 tx_msdu_retries;
	u64 tx_msdu_failed;
	struct cfg80211_txq_stats txq_stats;
};

struct cfg80211_ttlm_params {
	u16 dlink[8];
	u16 ulink[8];
};

struct cfg80211_tx_status {
	u64 cookie;
	u64 tx_tstamp;
	u64 ack_tstamp;
	const u8 *buf;
	size_t len;
	bool ack;
};

struct cfg80211_update_ft_ies_params {
	u16 md;
	const u8 *ie;
	size_t ie_len;
};

struct cfg80211_update_owe_info {
	u8 peer[6];
	u16 status;
	const u8 *ie;
	size_t ie_len;
	int assoc_link_id;
	u8 peer_mld_addr[6];
};

struct cfg80211_wowlan_tcp;

struct cfg80211_wowlan {
	bool any;
	bool disconnect;
	bool magic_pkt;
	bool gtk_rekey_failure;
	bool eap_identity_req;
	bool four_way_handshake;
	bool rfkill_release;
	struct cfg80211_pkt_pattern *patterns;
	struct cfg80211_wowlan_tcp *tcp;
	int n_patterns;
	struct cfg80211_sched_scan_request *nd_config;
};

struct cfg80211_wowlan_nd_match;

struct cfg80211_wowlan_nd_info {
	int n_matches;
	struct cfg80211_wowlan_nd_match *matches[0];
};

struct cfg80211_wowlan_nd_match {
	struct cfg80211_ssid ssid;
	int n_channels;
	u32 channels[0];
};

struct nl80211_wowlan_tcp_data_seq {
	__u32 start;
	__u32 offset;
	__u32 len;
};

struct nl80211_wowlan_tcp_data_token {
	__u32 offset;
	__u32 len;
	__u8 token_stream[0];
};

struct socket;

struct cfg80211_wowlan_tcp {
	struct socket *sock;
	__be32 src;
	__be32 dst;
	u16 src_port;
	u16 dst_port;
	u8 dst_mac[6];
	int payload_len;
	const u8 *payload;
	struct nl80211_wowlan_tcp_data_seq payload_seq;
	u32 data_interval;
	u32 wake_len;
	const u8 *wake_data;
	const u8 *wake_mask;
	u32 tokens_size;
	struct nl80211_wowlan_tcp_data_token payload_tok;
};

struct cfg80211_wowlan_wakeup {
	bool disconnect;
	bool magic_pkt;
	bool gtk_rekey_failure;
	bool eap_identity_req;
	bool four_way_handshake;
	bool rfkill_release;
	bool packet_80211;
	bool tcp_match;
	bool tcp_connlost;
	bool tcp_nomoretokens;
	bool unprot_deauth_disassoc;
	s32 pattern_idx;
	u32 packet_present_len;
	u32 packet_len;
	const void *packet;
	struct cfg80211_wowlan_nd_info *net_detect;
};

struct cfs_bandwidth {};

struct load_weight {
	long unsigned int weight;
	u32 inv_weight;
};

struct sched_avg {
	u64 last_update_time;
	u64 load_sum;
	u64 runnable_sum;
	u32 util_sum;
	u32 period_contrib;
	long unsigned int load_avg;
	long unsigned int runnable_avg;
	long unsigned int util_avg;
	unsigned int util_est;
};

struct sched_entity;

struct task_group;

struct cfs_rq {
	struct load_weight load;
	unsigned int nr_queued;
	unsigned int h_nr_queued;
	unsigned int h_nr_runnable;
	unsigned int h_nr_idle;
	s64 avg_vruntime;
	u64 avg_load;
	u64 min_vruntime;
	struct rb_root_cached tasks_timeline;
	struct sched_entity *curr;
	struct sched_entity *next;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct sched_avg avg;
	struct {
		raw_spinlock_t lock;
		int nr;
		long unsigned int load_avg;
		long unsigned int util_avg;
		long unsigned int runnable_avg;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
	} removed;
	u64 last_update_tg_load_avg;
	long unsigned int tg_load_avg_contrib;
	long int propagate;
	long int prop_runnable_sum;
	long unsigned int h_load;
	u64 last_h_load_update;
	struct sched_entity *h_load_next;
	struct rq *rq;
	int on_list;
	struct list_head leaf_cfs_rq_list;
	struct task_group *tg;
	int idle;
	long: 64;
	long: 64;
	long: 64;
};

struct kernfs_ops;

struct kernfs_open_file;

struct cftype {
	char name[64];
	long unsigned int private;
	size_t max_write_len;
	unsigned int flags;
	unsigned int file_offset;
	struct cgroup_subsys *ss;
	struct list_head node;
	struct kernfs_ops *kf_ops;
	int (*open)(struct kernfs_open_file *);
	void (*release)(struct kernfs_open_file *);
	u64 (*read_u64)(struct cgroup_subsys_state *, struct cftype *);
	s64 (*read_s64)(struct cgroup_subsys_state *, struct cftype *);
	int (*seq_show)(struct seq_file *, void *);
	void * (*seq_start)(struct seq_file *, loff_t *);
	void * (*seq_next)(struct seq_file *, void *, loff_t *);
	void (*seq_stop)(struct seq_file *, void *);
	int (*write_u64)(struct cgroup_subsys_state *, struct cftype *, u64);
	int (*write_s64)(struct cgroup_subsys_state *, struct cftype *, s64);
	ssize_t (*write)(struct kernfs_open_file *, char *, size_t, loff_t);
	__poll_t (*poll)(struct kernfs_open_file *, struct poll_table_struct *);
	struct lock_class_key lockdep_key;
};

struct cgroup_file {
	struct kernfs_node *kn;
	long unsigned int notified_at;
	struct timer_list notify_timer;
};

struct task_cputime {
	u64 stime;
	u64 utime;
	long long unsigned int sum_exec_runtime;
};

struct cgroup_base_stat {
	struct task_cputime cputime;
	u64 ntime;
};

struct prev_cputime {
	u64 utime;
	u64 stime;
	raw_spinlock_t lock;
};

struct cgroup_bpf {};

struct cgroup_freezer_state {
	bool freeze;
	bool e_freeze;
	int nr_frozen_descendants;
	int nr_frozen_tasks;
};

struct cgroup_root;

struct cgroup_rstat_cpu;

struct psi_group;

struct cgroup {
	struct cgroup_subsys_state self;
	long unsigned int flags;
	int level;
	int max_depth;
	int nr_descendants;
	int nr_dying_descendants;
	int max_descendants;
	int nr_populated_csets;
	int nr_populated_domain_children;
	int nr_populated_threaded_children;
	int nr_threaded_children;
	unsigned int kill_seq;
	struct kernfs_node *kn;
	struct cgroup_file procs_file;
	struct cgroup_file events_file;
	struct cgroup_file psi_files[0];
	u16 subtree_control;
	u16 subtree_ss_mask;
	u16 old_subtree_control;
	u16 old_subtree_ss_mask;
	struct cgroup_subsys_state *subsys[14];
	int nr_dying_subsys[14];
	struct cgroup_root *root;
	struct list_head cset_links;
	struct list_head e_csets[14];
	struct cgroup *dom_cgrp;
	struct cgroup *old_dom_cgrp;
	struct cgroup_rstat_cpu *rstat_cpu;
	struct list_head rstat_css_list;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct cacheline_padding _pad_;
	struct cgroup *rstat_flush_next;
	struct cgroup_base_stat last_bstat;
	struct cgroup_base_stat bstat;
	struct prev_cputime prev_cputime;
	struct list_head pidlists;
	struct mutex pidlist_mutex;
	wait_queue_head_t offline_waitq;
	struct work_struct release_agent_work;
	struct psi_group *psi;
	struct cgroup_bpf bpf;
	struct cgroup_freezer_state freezer;
	struct bpf_local_storage *bpf_cgrp_storage;
	struct cgroup *ancestors[0];
	long: 64;
	long: 64;
	long: 64;
};

struct cgroup__safe_rcu {
	struct kernfs_node *kn;
};

struct cgroup_cls_state {
	struct cgroup_subsys_state css;
	u32 classid;
};

struct css_set;

struct css_task_iter {
	struct cgroup_subsys *ss;
	unsigned int flags;
	struct list_head *cset_pos;
	struct list_head *cset_head;
	struct list_head *tcset_pos;
	struct list_head *tcset_head;
	struct list_head *task_pos;
	struct list_head *cur_tasks_head;
	struct css_set *cur_cset;
	struct css_set *cur_dcset;
	struct task_struct *cur_task;
	struct list_head iters_node;
};

struct cgroup_of_peak {
	long unsigned int value;
	struct list_head list;
};

struct cgroup_namespace;

struct cgroup_pidlist;

struct cgroup_file_ctx {
	struct cgroup_namespace *ns;
	struct {
		void *trigger;
	} psi;
	struct {
		bool started;
		struct css_task_iter iter;
	} procs;
	struct {
		struct cgroup_pidlist *pidlist;
	} procs1;
	struct cgroup_of_peak peak;
};

struct kernfs_root;

struct kernfs_fs_context {
	struct kernfs_root *root;
	void *ns_tag;
	long unsigned int magic;
	bool new_sb_created;
};

struct cgroup_fs_context {
	struct kernfs_fs_context kfc;
	struct cgroup_root *root;
	struct cgroup_namespace *ns;
	unsigned int flags;
	bool cpuset_clone_children;
	bool none;
	bool all_ss;
	u16 subsys_mask;
	char *name;
	char *release_agent;
};

struct cgroup_iter_priv {
	struct cgroup_subsys_state *start_css;
	bool visited_all;
	bool terminate;
	int order;
};

struct cgroup_taskset {
	struct list_head src_csets;
	struct list_head dst_csets;
	int nr_tasks;
	int ssid;
	struct list_head *csets;
	struct css_set *cur_cset;
	struct task_struct *cur_task;
};

struct cgroup_mgctx {
	struct list_head preloaded_src_csets;
	struct list_head preloaded_dst_csets;
	struct cgroup_taskset tset;
	u16 ss_mask;
};

struct proc_ns_operations;

struct ns_common {
	struct dentry *stashed;
	const struct proc_ns_operations *ops;
	unsigned int inum;
	refcount_t count;
};

struct ucounts;

struct cgroup_namespace {
	struct ns_common ns;
	struct user_namespace *user_ns;
	struct ucounts *ucounts;
	struct css_set *root_cset;
};

struct cgroup_pidlist {
	struct {
		enum cgroup_filetype type;
		struct pid_namespace *ns;
	} key;
	pid_t *list;
	int length;
	struct list_head links;
	struct cgroup *owner;
	struct delayed_work destroy_dwork;
};

struct cgroup_root {
	struct kernfs_root *kf_root;
	unsigned int subsys_mask;
	int hierarchy_id;
	struct list_head root_list;
	struct callback_head rcu;
	long: 64;
	long: 64;
	struct cgroup cgrp;
	struct cgroup *cgrp_ancestor_storage;
	atomic_t nr_cgrps;
	unsigned int flags;
	char release_agent_path[4096];
	char name[64];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct cgroup_rstat_cpu {
	struct u64_stats_sync bsync;
	struct cgroup_base_stat bstat;
	struct cgroup_base_stat last_bstat;
	struct cgroup_base_stat subtree_bstat;
	struct cgroup_base_stat last_subtree_bstat;
	struct cgroup *updated_children;
	struct cgroup *updated_next;
};

struct idr {
	struct xarray idr_rt;
	unsigned int idr_base;
	unsigned int idr_next;
};

struct cgroup_subsys {
	struct cgroup_subsys_state * (*css_alloc)(struct cgroup_subsys_state *);
	int (*css_online)(struct cgroup_subsys_state *);
	void (*css_offline)(struct cgroup_subsys_state *);
	void (*css_released)(struct cgroup_subsys_state *);
	void (*css_free)(struct cgroup_subsys_state *);
	void (*css_reset)(struct cgroup_subsys_state *);
	void (*css_rstat_flush)(struct cgroup_subsys_state *, int);
	int (*css_extra_stat_show)(struct seq_file *, struct cgroup_subsys_state *);
	int (*css_local_stat_show)(struct seq_file *, struct cgroup_subsys_state *);
	int (*can_attach)(struct cgroup_taskset *);
	void (*cancel_attach)(struct cgroup_taskset *);
	void (*attach)(struct cgroup_taskset *);
	void (*post_attach)(void);
	int (*can_fork)(struct task_struct *, struct css_set *);
	void (*cancel_fork)(struct task_struct *, struct css_set *);
	void (*fork)(struct task_struct *);
	void (*exit)(struct task_struct *);
	void (*release)(struct task_struct *);
	void (*bind)(struct cgroup_subsys_state *);
	bool early_init: 1;
	bool implicit_on_dfl: 1;
	bool threaded: 1;
	int id;
	const char *name;
	const char *legacy_name;
	struct cgroup_root *root;
	struct idr css_idr;
	struct list_head cfts;
	struct cftype *dfl_cftypes;
	struct cftype *legacy_cftypes;
	unsigned int depends_on;
};

struct cgroupstats {
	__u64 nr_sleeping;
	__u64 nr_running;
	__u64 nr_stopped;
	__u64 nr_uninterruptible;
	__u64 nr_io_wait;
};

struct cgrp_cset_link {
	struct cgroup *cgrp;
	struct css_set *cset;
	struct list_head cset_link;
	struct list_head cgrp_link;
};

struct ch7017_priv {
	u8 dummy;
};

struct ch7xxx_did_struct {
	u8 did;
	char *name;
};

struct ch7xxx_id_struct {
	u8 vid;
	char *name;
};

struct ch7xxx_priv {
	bool quiet;
};

struct linked_page;

struct chain_allocator {
	struct linked_page *chain;
	unsigned int used_space;
	gfp_t gfp_mask;
	int safe_needed;
};

struct e820_entry;

struct change_member {
	struct e820_entry *entry;
	long long unsigned int addr;
};

struct channel_map_table {
	unsigned char map;
	int spk_mask;
};

struct ethnl_reply_data {
	struct net_device *dev;
};

struct ethtool_channels {
	__u32 cmd;
	__u32 max_rx;
	__u32 max_tx;
	__u32 max_other;
	__u32 max_combined;
	__u32 rx_count;
	__u32 tx_count;
	__u32 other_count;
	__u32 combined_count;
};

struct channels_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_channels channels;
};

struct char_device_struct {
	struct char_device_struct *next;
	unsigned int major;
	unsigned int baseminor;
	int minorct;
	char name[64];
	struct cdev *cdev;
};

struct qdisc_walker {
	int stop;
	int skip;
	int count;
	int (*fn)(struct Qdisc *, long unsigned int, struct qdisc_walker *);
};

struct check_loop_arg {
	struct qdisc_walker w;
	struct Qdisc *p;
	int depth;
};

struct check_mount {
	struct vfsmount *mnt;
	unsigned int mounted;
};

struct child_device_config {
	u16 handle;
	u16 device_type;
	union {
		u8 device_id[10];
		struct {
			u8 i2c_speed;
			u8 dp_onboard_redriver_preemph: 3;
			u8 dp_onboard_redriver_vswing: 3;
			u8 dp_onboard_redriver_present: 1;
			u8 reserved0: 1;
			u8 dp_ondock_redriver_preemph: 3;
			u8 dp_ondock_redriver_vswing: 3;
			u8 dp_ondock_redriver_present: 1;
			u8 reserved1: 1;
			u8 hdmi_level_shifter_value: 5;
			u8 hdmi_max_data_rate: 3;
			u16 dtd_buf_ptr;
			u8 edidless_efp: 1;
			u8 compression_enable: 1;
			u8 compression_method_cps: 1;
			u8 ganged_edp: 1;
			u8 lttpr_non_transparent: 1;
			u8 disable_compression_for_ext_disp: 1;
			u8 reserved2: 2;
			u8 compression_structure_index: 4;
			u8 reserved3: 4;
			u8 hdmi_max_frl_rate: 4;
			u8 hdmi_max_frl_rate_valid: 1;
			u8 reserved4: 3;
			u8 reserved5;
		};
	};
	u16 addin_offset;
	u8 dvo_port;
	u8 i2c_pin;
	u8 target_addr;
	u8 ddc_pin;
	u16 edid_ptr;
	u8 dvo_cfg;
	union {
		struct {
			u8 dvo2_port;
			u8 i2c2_pin;
			u8 target2_addr;
			u8 ddc2_pin;
		};
		struct {
			u8 efp_routed: 1;
			u8 lane_reversal: 1;
			u8 lspcon: 1;
			u8 iboost: 1;
			u8 hpd_invert: 1;
			u8 use_vbt_vswing: 1;
			u8 dp_max_lane_count: 2;
			u8 hdmi_support: 1;
			u8 dp_support: 1;
			u8 tmds_support: 1;
			u8 support_reserved: 5;
			u8 aux_channel;
			u8 dongle_detect;
		};
	};
	u8 pipe_cap: 2;
	u8 sdvo_stall: 1;
	u8 hpd_status: 2;
	u8 integrated_encoder: 1;
	u8 capabilities_reserved: 2;
	u8 dvo_wiring;
	union {
		u8 dvo2_wiring;
		u8 mipi_bridge_type;
	};
	u16 extended_type;
	u8 dvo_function;
	u8 dp_usb_type_c: 1;
	u8 tbt: 1;
	u8 flags2_reserved: 2;
	u8 dp_port_trace_length: 4;
	u8 dp_gpio_index;
	u16 dp_gpio_pin_num;
	u8 dp_iboost_level: 4;
	u8 hdmi_iboost_level: 4;
	u8 dp_max_link_rate: 3;
	u8 dp_max_link_rate_reserved: 5;
	u8 efp_index;
} __attribute__((packed));

struct iolatency_grp;

struct child_latency_info {
	spinlock_t lock;
	u64 last_scale_event;
	u64 scale_lat;
	u64 nr_samples;
	struct iolatency_grp *scale_grp;
	atomic_t scale_cookie;
};

struct chipset {
	u32 vendor;
	u32 device;
	u32 class;
	u32 class_mask;
	u32 flags;
	void (*f)(int, int, int);
};

struct cipher_context {
	char iv[20];
	char rec_seq[8];
};

struct cipso_v4_std_map_tbl;

struct cipso_v4_doi {
	u32 doi;
	u32 type;
	union {
		struct cipso_v4_std_map_tbl *std;
	} map;
	u8 tags[5];
	refcount_t refcount;
	struct list_head list;
	struct callback_head rcu;
};

struct cipso_v4_map_cache_bkt {
	spinlock_t lock;
	u32 size;
	struct list_head list;
};

struct cipso_v4_map_cache_entry {
	u32 hash;
	unsigned char *key;
	size_t key_len;
	struct netlbl_lsm_cache *lsm_data;
	u32 activity;
	struct list_head list;
};

struct cipso_v4_std_map_tbl {
	struct {
		u32 *cipso;
		u32 *local;
		u32 cipso_size;
		u32 local_size;
	} lvl;
	struct {
		u32 *cipso;
		u32 *local;
		u32 cipso_size;
		u32 local_size;
	} cat;
};

struct cis_cache_entry {
	struct list_head node;
	unsigned int addr;
	unsigned int len;
	unsigned int attr;
	unsigned char cache[0];
};

struct cistpl_device_t {
	u_char ndev;
	struct {
		u_char type;
		u_char wp;
		u_int speed;
		u_int size;
	} dev[4];
};

typedef struct cistpl_device_t cistpl_device_t;

struct cistpl_checksum_t {
	u_short addr;
	u_short len;
	u_char sum;
};

typedef struct cistpl_checksum_t cistpl_checksum_t;

struct cistpl_longlink_t {
	u_int addr;
};

typedef struct cistpl_longlink_t cistpl_longlink_t;

struct cistpl_longlink_mfc_t {
	u_char nfn;
	struct {
		u_char space;
		u_int addr;
	} fn[8];
};

typedef struct cistpl_longlink_mfc_t cistpl_longlink_mfc_t;

struct cistpl_vers_1_t {
	u_char major;
	u_char minor;
	u_char ns;
	u_char ofs[4];
	char str[254];
};

typedef struct cistpl_vers_1_t cistpl_vers_1_t;

struct cistpl_altstr_t {
	u_char ns;
	u_char ofs[4];
	char str[254];
};

typedef struct cistpl_altstr_t cistpl_altstr_t;

struct cistpl_jedec_t {
	u_char nid;
	struct {
		u_char mfr;
		u_char info;
	} id[4];
};

typedef struct cistpl_jedec_t cistpl_jedec_t;

struct cistpl_manfid_t {
	u_short manf;
	u_short card;
};

typedef struct cistpl_manfid_t cistpl_manfid_t;

struct cistpl_funcid_t {
	u_char func;
	u_char sysinit;
};

typedef struct cistpl_funcid_t cistpl_funcid_t;

struct cistpl_funce_t {
	u_char type;
	u_char data[0];
};

typedef struct cistpl_funce_t cistpl_funce_t;

struct cistpl_bar_t {
	u_char attr;
	u_int size;
};

typedef struct cistpl_bar_t cistpl_bar_t;

struct cistpl_config_t {
	u_char last_idx;
	u_int base;
	u_int rmask[4];
	u_char subtuples;
};

typedef struct cistpl_config_t cistpl_config_t;

struct cistpl_power_t {
	u_char present;
	u_char flags;
	u_int param[7];
};

typedef struct cistpl_power_t cistpl_power_t;

struct cistpl_timing_t {
	u_int wait;
	u_int waitscale;
	u_int ready;
	u_int rdyscale;
	u_int reserved;
	u_int rsvscale;
};

typedef struct cistpl_timing_t cistpl_timing_t;

struct cistpl_io_t {
	u_char flags;
	u_char nwin;
	struct {
		u_int base;
		u_int len;
	} win[16];
};

typedef struct cistpl_io_t cistpl_io_t;

struct cistpl_irq_t {
	u_int IRQInfo1;
	u_int IRQInfo2;
};

typedef struct cistpl_irq_t cistpl_irq_t;

struct cistpl_mem_t {
	u_char flags;
	u_char nwin;
	struct {
		u_int len;
		u_int card_addr;
		u_int host_addr;
	} win[8];
};

typedef struct cistpl_mem_t cistpl_mem_t;

struct cistpl_cftable_entry_t {
	u_char index;
	u_short flags;
	u_char interface;
	cistpl_power_t vcc;
	cistpl_power_t vpp1;
	cistpl_power_t vpp2;
	cistpl_timing_t timing;
	cistpl_io_t io;
	cistpl_irq_t irq;
	cistpl_mem_t mem;
	u_char subtuples;
};

typedef struct cistpl_cftable_entry_t cistpl_cftable_entry_t;

struct cistpl_cftable_entry_cb_t {
	u_char index;
	u_int flags;
	cistpl_power_t vcc;
	cistpl_power_t vpp1;
	cistpl_power_t vpp2;
	u_char io;
	cistpl_irq_t irq;
	u_char mem;
	u_char subtuples;
};

typedef struct cistpl_cftable_entry_cb_t cistpl_cftable_entry_cb_t;

struct cistpl_device_geo_t {
	u_char ngeo;
	struct {
		u_char buswidth;
		u_int erase_block;
		u_int read_block;
		u_int write_block;
		u_int partition;
		u_int interleave;
	} geo[4];
};

typedef struct cistpl_device_geo_t cistpl_device_geo_t;

struct cistpl_vers_2_t {
	u_char vers;
	u_char comply;
	u_short dindex;
	u_char vspec8;
	u_char vspec9;
	u_char nhdr;
	u_char vendor;
	u_char info;
	char str[244];
};

typedef struct cistpl_vers_2_t cistpl_vers_2_t;

struct cistpl_org_t {
	u_char data_org;
	char desc[30];
};

typedef struct cistpl_org_t cistpl_org_t;

struct cistpl_format_t {
	u_char type;
	u_char edc;
	u_int offset;
	u_int length;
};

typedef struct cistpl_format_t cistpl_format_t;

union cisparse_t {
	cistpl_device_t device;
	cistpl_checksum_t checksum;
	cistpl_longlink_t longlink;
	cistpl_longlink_mfc_t longlink_mfc;
	cistpl_vers_1_t version_1;
	cistpl_altstr_t altstr;
	cistpl_jedec_t jedec;
	cistpl_manfid_t manfid;
	cistpl_funcid_t funcid;
	cistpl_funce_t funce;
	cistpl_bar_t bar;
	cistpl_config_t config;
	cistpl_cftable_entry_t cftable_entry;
	cistpl_cftable_entry_cb_t cftable_entry_cb;
	cistpl_device_geo_t device_geo;
	cistpl_vers_2_t vers_2;
	cistpl_org_t org;
	cistpl_format_t format;
};

typedef union cisparse_t cisparse_t;

struct class_attribute {
	struct attribute attr;
	ssize_t (*show)(const struct class *, const struct class_attribute *, char *);
	ssize_t (*store)(const struct class *, const struct class_attribute *, const char *, size_t);
};

struct class_attribute_string {
	struct class_attribute attr;
	char *str;
};

struct class_compat {
	struct kobject *kobj;
};

struct hashtab_node;

struct hashtab {
	struct hashtab_node **htable;
	u32 size;
	u32 nel;
};

struct symtab {
	struct hashtab table;
	u32 nprim;
};

struct common_datum;

struct constraint_node;

struct class_datum {
	u32 value;
	char *comkey;
	struct common_datum *comdatum;
	struct symtab permissions;
	struct constraint_node *constraints;
	struct constraint_node *validatetrans;
	char default_user;
	char default_role;
	char default_type;
	char default_range;
};

struct klist_iter {
	struct klist *i_klist;
	struct klist_node *i_cur;
};

struct subsys_private;

struct class_dev_iter {
	struct klist_iter ki;
	const struct device_type *type;
	struct subsys_private *sp;
};

struct class_dir {
	struct kobject kobj;
	const struct class *class;
};

struct class_info {
	int class;
	char *class_name;
};

struct class_interface {
	struct list_head node;
	const struct class *class;
	int (*add_dev)(struct device *);
	void (*remove_dev)(struct device *);
};

struct clear_refs_private {
	enum clear_refs_types type;
};

struct dma_fence_ops;

struct dma_fence {
	spinlock_t *lock;
	const struct dma_fence_ops *ops;
	union {
		struct list_head cb_list;
		ktime_t timestamp;
		struct callback_head rcu;
	};
	u64 context;
	u64 seqno;
	long unsigned int flags;
	struct kref refcount;
	int error;
};

struct i915_sw_fence;

typedef int (*i915_sw_fence_notify_t)(struct i915_sw_fence *, enum i915_sw_fence_notify);

struct i915_sw_fence {
	wait_queue_head_t wait;
	i915_sw_fence_notify_t fn;
	atomic_t pending;
	int error;
};

struct i915_sw_dma_fence_cb {
	struct dma_fence_cb base;
	struct i915_sw_fence *fence;
};

struct dma_fence_work_ops;

struct dma_fence_work {
	struct dma_fence dma;
	spinlock_t lock;
	struct i915_sw_fence chain;
	struct i915_sw_dma_fence_cb cb;
	struct work_struct work;
	const struct dma_fence_work_ops *ops;
};

struct drm_i915_gem_object;

struct clflush {
	struct dma_fence_work base;
	struct drm_i915_gem_object *obj;
};

struct clk_bulk_data {
	const char *id;
	struct clk *clk;
};

struct clock_event_device {
	void (*event_handler)(struct clock_event_device *);
	int (*set_next_event)(long unsigned int, struct clock_event_device *);
	int (*set_next_ktime)(ktime_t, struct clock_event_device *);
	ktime_t next_event;
	u64 max_delta_ns;
	u64 min_delta_ns;
	u32 mult;
	u32 shift;
	enum clock_event_state state_use_accessors;
	unsigned int features;
	long unsigned int retries;
	int (*set_state_periodic)(struct clock_event_device *);
	int (*set_state_oneshot)(struct clock_event_device *);
	int (*set_state_oneshot_stopped)(struct clock_event_device *);
	int (*set_state_shutdown)(struct clock_event_device *);
	int (*tick_resume)(struct clock_event_device *);
	void (*broadcast)(const struct cpumask *);
	void (*suspend)(struct clock_event_device *);
	void (*resume)(struct clock_event_device *);
	long unsigned int min_delta_ticks;
	long unsigned int max_delta_ticks;
	const char *name;
	int rating;
	int irq;
	int bound_on;
	const struct cpumask *cpumask;
	struct list_head list;
	struct module *owner;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct clock_identity {
	u8 id[8];
};

struct clocksource_base;

struct clocksource {
	u64 (*read)(struct clocksource *);
	u64 mask;
	u32 mult;
	u32 shift;
	u64 max_idle_ns;
	u32 maxadj;
	u32 uncertainty_margin;
	u64 max_cycles;
	u64 max_raw_delta;
	const char *name;
	struct list_head list;
	u32 freq_khz;
	int rating;
	enum clocksource_ids id;
	enum vdso_clock_mode vdso_clock_mode;
	long unsigned int flags;
	struct clocksource_base *base;
	int (*enable)(struct clocksource *);
	void (*disable)(struct clocksource *);
	void (*suspend)(struct clocksource *);
	void (*resume)(struct clocksource *);
	void (*mark_unstable)(struct clocksource *);
	void (*tick_stable)(struct clocksource *);
	struct list_head wd_list;
	u64 cs_last;
	u64 wd_last;
	struct module *owner;
};

struct clocksource_base {
	enum clocksource_ids id;
	u32 freq_khz;
	u64 offset;
	u32 numerator;
	u32 denominator;
};

struct clone_args {
	__u64 flags;
	__u64 pidfd;
	__u64 child_tid;
	__u64 parent_tid;
	__u64 exit_signal;
	__u64 stack;
	__u64 stack_size;
	__u64 tls;
	__u64 set_tid;
	__u64 set_tid_size;
	__u64 cgroup;
};

struct dm_table;

struct dm_io;

struct clone_info {
	struct dm_table *map;
	struct bio *bio;
	struct dm_io *io;
	sector_t sector;
	unsigned int sector_count;
	bool is_abnormal_io: 1;
	bool submit_as_polled: 1;
};

struct tc_action;

struct tcf_exts_miss_cookie_node;

struct tcf_exts {
	__u32 type;
	int nr_actions;
	struct tc_action **actions;
	struct net *net;
	netns_tracker ns_tracker;
	struct tcf_exts_miss_cookie_node *miss_cookie_node;
	int action;
	int police;
};

struct tcf_ematch_tree_hdr {
	__u16 nmatches;
	__u16 progid;
};

struct tcf_ematch;

struct tcf_ematch_tree {
	struct tcf_ematch_tree_hdr hdr;
	struct tcf_ematch *matches;
};

struct tcf_proto;

struct cls_cgroup_head {
	u32 handle;
	struct tcf_exts exts;
	struct tcf_ematch_tree ematches;
	struct tcf_proto *tp;
	struct rcu_work rwork;
};

struct cmac_desc_ctx {
	unsigned int len;
	u8 odds[0];
};

struct cmac_tfm_ctx {
	struct crypto_cipher *child;
	__be64 consts[0];
};

struct drm_i915_cmd_descriptor;

struct cmd_node {
	const struct drm_i915_cmd_descriptor *desc;
	struct hlist_node node;
};

struct cmis_cdb_advert_rpl {
	u8 inst_supported;
	u8 read_write_len_ext;
	u8 resv1;
	u8 resv2;
};

struct cmis_cdb_fw_mng_features_rpl {
	u8 resv1;
	u8 resv2;
	u8 start_cmd_payload_size;
	u8 resv3;
	u8 read_write_len_ext;
	u8 write_mechanism;
	u8 resv4;
	u8 resv5;
	__be16 max_duration_start;
	__be16 resv6;
	__be16 max_duration_write;
	__be16 max_duration_complete;
	__be16 resv7;
};

struct cmis_cdb_module_features_rpl {
	u8 resv1[34];
	__be16 max_completion_time;
};

struct cmis_cdb_query_status_pl {
	u16 response_delay;
};

struct cmis_cdb_query_status_rpl {
	u8 length;
	u8 status;
};

struct cmis_cdb_run_fw_image_pl {
	u8 resv1;
	u8 image_to_run;
	u16 delay_to_reset;
};

struct cmis_cdb_start_fw_download_pl_h {
	__be32 image_size;
	__be32 resv1;
};

struct cmis_cdb_start_fw_download_pl {
	union {
		struct {
			__be32 image_size;
			__be32 resv1;
		};
		struct cmis_cdb_start_fw_download_pl_h head;
	};
	u8 vendor_data[112];
};

struct cmis_cdb_write_fw_block_epl_pl {
	u8 fw_block[2048];
};

struct cmis_cdb_write_fw_block_lpl_pl {
	__be32 block_address;
	u8 fw_block[116];
};

struct cmis_fw_update_fw_mng_features {
	u8 start_cmd_payload_size;
	u8 write_mechanism;
	u16 max_duration_start;
	u16 max_duration_write;
	u16 max_duration_complete;
};

struct cmis_password_entry_pl {
	__be32 password;
};

struct cmis_rev_rpl {
	u8 rev;
};

struct cmis_wait_for_cond_rpl {
	u8 state;
};

struct cmos_rtc;

struct rtc_time;

struct cmos_read_alarm_callback_param {
	struct cmos_rtc *cmos;
	struct rtc_time *time;
	unsigned char rtc_control;
};

struct rtc_time {
	int tm_sec;
	int tm_min;
	int tm_hour;
	int tm_mday;
	int tm_mon;
	int tm_year;
	int tm_wday;
	int tm_yday;
	int tm_isdst;
};

struct rtc_wkalrm {
	unsigned char enabled;
	unsigned char pending;
	struct rtc_time time;
};

struct rtc_device;

struct cmos_rtc {
	struct rtc_device *rtc;
	struct device *dev;
	int irq;
	struct resource *iomem;
	time64_t alarm_expires;
	void (*wake_on)(struct device *);
	void (*wake_off)(struct device *);
	u8 enabled_wake;
	u8 suspend_ctrl;
	u8 day_alrm;
	u8 mon_alrm;
	u8 century;
	struct rtc_wkalrm saved_wkalrm;
};

struct cmos_rtc_board_info {
	void (*wake_on)(struct device *);
	void (*wake_off)(struct device *);
	u32 flags;
	int address_space;
	u8 rtc_day_alarm;
	u8 rtc_mon_alarm;
	u8 rtc_century;
};

struct cmos_set_alarm_callback_param {
	struct cmos_rtc *cmos;
	unsigned char mon;
	unsigned char mday;
	unsigned char hrs;
	unsigned char min;
	unsigned char sec;
	struct rtc_wkalrm *t;
};

struct crypto_comp;

struct cmp_data {
	struct task_struct *thr;
	struct crypto_comp *cc;
	atomic_t ready;
	atomic_t stop;
	int ret;
	wait_queue_head_t go;
	wait_queue_head_t done;
	size_t unc_len;
	size_t cmp_len;
	unsigned char unc[131072];
	unsigned char cmp[143360];
};

struct cmsghdr {
	__kernel_size_t cmsg_len;
	int cmsg_level;
	int cmsg_type;
};

struct cn_callback_id {
	unsigned char name[32];
	struct cb_id id;
};

struct cn_queue_dev;

struct cn_msg;

struct netlink_skb_parms;

struct cn_callback_entry {
	struct list_head callback_entry;
	refcount_t refcnt;
	struct cn_queue_dev *pdev;
	struct cn_callback_id id;
	void (*callback)(struct cn_msg *, struct netlink_skb_parms *);
	u32 seq;
	u32 group;
};

struct cn_dev {
	struct cb_id id;
	u32 seq;
	u32 groups;
	struct sock *nls;
	struct cn_queue_dev *cbdev;
};

struct cn_msg {
	struct cb_id id;
	__u32 seq;
	__u32 ack;
	__u16 len;
	__u16 flags;
	__u8 data[0];
};

struct cn_queue_dev {
	atomic_t refcnt;
	unsigned char name[32];
	struct list_head queue_list;
	spinlock_t queue_lock;
	struct sock *nls;
};

struct ethtool_coalesce {
	__u32 cmd;
	__u32 rx_coalesce_usecs;
	__u32 rx_max_coalesced_frames;
	__u32 rx_coalesce_usecs_irq;
	__u32 rx_max_coalesced_frames_irq;
	__u32 tx_coalesce_usecs;
	__u32 tx_max_coalesced_frames;
	__u32 tx_coalesce_usecs_irq;
	__u32 tx_max_coalesced_frames_irq;
	__u32 stats_block_coalesce_usecs;
	__u32 use_adaptive_rx_coalesce;
	__u32 use_adaptive_tx_coalesce;
	__u32 pkt_rate_low;
	__u32 rx_coalesce_usecs_low;
	__u32 rx_max_coalesced_frames_low;
	__u32 tx_coalesce_usecs_low;
	__u32 tx_max_coalesced_frames_low;
	__u32 pkt_rate_high;
	__u32 rx_coalesce_usecs_high;
	__u32 rx_max_coalesced_frames_high;
	__u32 tx_coalesce_usecs_high;
	__u32 tx_max_coalesced_frames_high;
	__u32 rate_sample_interval;
};

struct kernel_ethtool_coalesce {
	u8 use_cqe_mode_tx;
	u8 use_cqe_mode_rx;
	u32 tx_aggr_max_bytes;
	u32 tx_aggr_max_frames;
	u32 tx_aggr_time_usecs;
};

struct coalesce_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_coalesce coalesce;
	struct kernel_ethtool_coalesce kernel_coalesce;
	u32 supported_params;
};

struct codel_params {
	codel_time_t target;
	codel_time_t ce_threshold;
	codel_time_t interval;
	u32 mtu;
	bool ecn;
	u8 ce_threshold_selector;
	u8 ce_threshold_mask;
};

struct codel_stats {
	u32 maxpacket;
	u32 drop_count;
	u32 drop_len;
	u32 ecn_mark;
	u32 ce_mark;
};

struct codel_vars {
	u32 count;
	u32 lastcount;
	bool dropping;
	u16 rec_inv_sqrt;
	codel_time_t first_above_time;
	codel_time_t drop_next;
	codel_time_t ldelay;
};

struct element;

struct colocated_ap_data {
	const struct element *ssid_elem;
	struct list_head ap_list;
	u32 s_ssid_tmp;
	int n_coloc;
};

struct color_conversion {
	u16 ry;
	u16 gy;
	u16 by;
	u16 ay;
	u16 ru;
	u16 gu;
	u16 bu;
	u16 au;
	u16 rv;
	u16 gv;
	u16 bv;
	u16 av;
};

struct comm_proc_event {
	__kernel_pid_t process_pid;
	__kernel_pid_t process_tgid;
	char comm[16];
};

struct commit_header {
	__be32 h_magic;
	__be32 h_blocktype;
	__be32 h_sequence;
	unsigned char h_chksum_type;
	unsigned char h_chksum_size;
	unsigned char h_padding[2];
	__be32 h_chksum[8];
	__be64 h_commit_sec;
	__be32 h_commit_nsec;
};

struct lsm_network_audit;

struct lsm_ioctlop_audit;

struct lsm_ibpkey_audit;

struct lsm_ibendport_audit;

struct selinux_audit_data;

struct common_audit_data {
	char type;
	union {
		struct path path;
		struct dentry *dentry;
		struct inode *inode;
		struct lsm_network_audit *net;
		int cap;
		int ipc_id;
		struct task_struct *tsk;
		struct {
			key_serial_t key;
			char *key_desc;
		} key_struct;
		char *kmod_name;
		struct lsm_ioctlop_audit *op;
		struct file *file;
		struct lsm_ibpkey_audit *ibpkey;
		struct lsm_ibendport_audit *ibendport;
		int reason;
		const char *anonclass;
		u16 nlmsg_type;
	} u;
	union {
		struct selinux_audit_data *selinux_audit_data;
	};
};

struct common_datum {
	u32 value;
	struct symtab permissions;
};

struct zone;

struct compact_control {
	struct list_head freepages[11];
	struct list_head migratepages;
	unsigned int nr_freepages;
	unsigned int nr_migratepages;
	long unsigned int free_pfn;
	long unsigned int migrate_pfn;
	long unsigned int fast_start_pfn;
	struct zone *zone;
	long unsigned int total_migrate_scanned;
	long unsigned int total_free_scanned;
	short unsigned int fast_search_fail;
	short int search_order;
	const gfp_t gfp_mask;
	int order;
	int migratetype;
	const unsigned int alloc_flags;
	const int highest_zoneidx;
	enum migrate_mode mode;
	bool ignore_skip_hint;
	bool no_set_skip_hint;
	bool ignore_block_suitable;
	bool direct_compaction;
	bool proactive_compaction;
	bool whole_zone;
	bool contended;
	bool finish_pageblock;
	bool alloc_contig;
};

struct compat_blk_user_trace_setup {
	char name[32];
	u16 act_mask;
	int: 0;
	u32 buf_size;
	u32 buf_nr;
	compat_u64 start_lba;
	compat_u64 end_lba;
	u32 pid;
} __attribute__((packed));

struct compat_blkpg_ioctl_arg {
	compat_int_t op;
	compat_int_t flags;
	compat_int_t datalen;
	compat_caddr_t data;
};

struct compat_cdrom_generic_command {
	unsigned char cmd[12];
	compat_caddr_t buffer;
	compat_uint_t buflen;
	compat_int_t stat;
	compat_caddr_t sense;
	unsigned char data_direction;
	unsigned char pad[3];
	compat_int_t quiet;
	compat_int_t timeout;
	compat_caddr_t unused;
};

struct compat_cdrom_read_audio {
	union cdrom_addr addr;
	u8 addr_format;
	compat_int_t nframes;
	compat_caddr_t buf;
};

struct compat_cmsghdr {
	compat_size_t cmsg_len;
	compat_int_t cmsg_level;
	compat_int_t cmsg_type;
};

struct compat_console_font_op {
	compat_uint_t op;
	compat_uint_t flags;
	compat_uint_t width;
	compat_uint_t height;
	compat_uint_t charcount;
	compat_caddr_t data;
};

struct compat_dirent {
	u32 d_ino;
	compat_off_t d_off;
	u16 d_reclen;
	char d_name[256];
};

struct compat_elf_prpsinfo {
	char pr_state;
	char pr_sname;
	char pr_zomb;
	char pr_nice;
	compat_ulong_t pr_flag;
	__compat_uid_t pr_uid;
	__compat_gid_t pr_gid;
	compat_pid_t pr_pid;
	compat_pid_t pr_ppid;
	compat_pid_t pr_pgrp;
	compat_pid_t pr_sid;
	char pr_fname[16];
	char pr_psargs[80];
};

struct compat_elf_siginfo {
	compat_int_t si_signo;
	compat_int_t si_code;
	compat_int_t si_errno;
};

struct old_timeval32 {
	old_time32_t tv_sec;
	s32 tv_usec;
};

struct compat_elf_prstatus_common {
	struct compat_elf_siginfo pr_info;
	short int pr_cursig;
	compat_ulong_t pr_sigpend;
	compat_ulong_t pr_sighold;
	compat_pid_t pr_pid;
	compat_pid_t pr_ppid;
	compat_pid_t pr_pgrp;
	compat_pid_t pr_sid;
	struct old_timeval32 pr_utime;
	struct old_timeval32 pr_stime;
	struct old_timeval32 pr_cutime;
	struct old_timeval32 pr_cstime;
};

struct user_regs_struct {
	long unsigned int r15;
	long unsigned int r14;
	long unsigned int r13;
	long unsigned int r12;
	long unsigned int bp;
	long unsigned int bx;
	long unsigned int r11;
	long unsigned int r10;
	long unsigned int r9;
	long unsigned int r8;
	long unsigned int ax;
	long unsigned int cx;
	long unsigned int dx;
	long unsigned int si;
	long unsigned int di;
	long unsigned int orig_ax;
	long unsigned int ip;
	long unsigned int cs;
	long unsigned int flags;
	long unsigned int sp;
	long unsigned int ss;
	long unsigned int fs_base;
	long unsigned int gs_base;
	long unsigned int ds;
	long unsigned int es;
	long unsigned int fs;
	long unsigned int gs;
};

typedef struct user_regs_struct compat_elf_gregset_t;

struct compat_elf_prstatus {
	struct compat_elf_prstatus_common common;
	compat_elf_gregset_t pr_reg;
	compat_int_t pr_fpvalid;
};

struct ethtool_tcpip4_spec {
	__be32 ip4src;
	__be32 ip4dst;
	__be16 psrc;
	__be16 pdst;
	__u8 tos;
};

struct ethtool_ah_espip4_spec {
	__be32 ip4src;
	__be32 ip4dst;
	__be32 spi;
	__u8 tos;
};

struct ethtool_usrip4_spec {
	__be32 ip4src;
	__be32 ip4dst;
	__be32 l4_4_bytes;
	__u8 tos;
	__u8 ip_ver;
	__u8 proto;
};

struct ethtool_tcpip6_spec {
	__be32 ip6src[4];
	__be32 ip6dst[4];
	__be16 psrc;
	__be16 pdst;
	__u8 tclass;
};

struct ethtool_ah_espip6_spec {
	__be32 ip6src[4];
	__be32 ip6dst[4];
	__be32 spi;
	__u8 tclass;
};

struct ethtool_usrip6_spec {
	__be32 ip6src[4];
	__be32 ip6dst[4];
	__be32 l4_4_bytes;
	__u8 tclass;
	__u8 l4_proto;
};

struct ethhdr {
	unsigned char h_dest[6];
	unsigned char h_source[6];
	__be16 h_proto;
};

union ethtool_flow_union {
	struct ethtool_tcpip4_spec tcp_ip4_spec;
	struct ethtool_tcpip4_spec udp_ip4_spec;
	struct ethtool_tcpip4_spec sctp_ip4_spec;
	struct ethtool_ah_espip4_spec ah_ip4_spec;
	struct ethtool_ah_espip4_spec esp_ip4_spec;
	struct ethtool_usrip4_spec usr_ip4_spec;
	struct ethtool_tcpip6_spec tcp_ip6_spec;
	struct ethtool_tcpip6_spec udp_ip6_spec;
	struct ethtool_tcpip6_spec sctp_ip6_spec;
	struct ethtool_ah_espip6_spec ah_ip6_spec;
	struct ethtool_ah_espip6_spec esp_ip6_spec;
	struct ethtool_usrip6_spec usr_ip6_spec;
	struct ethhdr ether_spec;
	__u8 hdata[52];
};

struct ethtool_flow_ext {
	__u8 padding[2];
	unsigned char h_dest[6];
	__be16 vlan_etype;
	__be16 vlan_tci;
	__be32 data[2];
};

struct compat_ethtool_rx_flow_spec {
	u32 flow_type;
	union ethtool_flow_union h_u;
	struct ethtool_flow_ext h_ext;
	union ethtool_flow_union m_u;
	struct ethtool_flow_ext m_ext;
	compat_u64 ring_cookie;
	u32 location;
} __attribute__((packed));

struct compat_ethtool_rxnfc {
	u32 cmd;
	u32 flow_type;
	compat_u64 data;
	struct compat_ethtool_rx_flow_spec fs;
	u32 rule_cnt;
	u32 rule_locs[0];
} __attribute__((packed));

struct compat_ext4_new_group_input {
	u32 group;
	compat_u64 block_bitmap;
	compat_u64 inode_bitmap;
	compat_u64 inode_table;
	u32 blocks_count;
	u16 reserved_blocks;
	u16 unused;
} __attribute__((packed));

struct compat_flock {
	short int l_type;
	short int l_whence;
	compat_off_t l_start;
	compat_off_t l_len;
	compat_pid_t l_pid;
};

struct compat_flock64 {
	short int l_type;
	short int l_whence;
	compat_loff_t l_start;
	compat_loff_t l_len;
	compat_pid_t l_pid;
} __attribute__((packed));

struct compat_fs_qfilestat {
	compat_u64 dqb_bhardlimit;
	compat_u64 qfs_nblks;
	compat_uint_t qfs_nextents;
} __attribute__((packed));

struct compat_fs_quota_stat {
	__s8 qs_version;
	__u16 qs_flags;
	__s8 qs_pad;
	long: 0;
	struct compat_fs_qfilestat qs_uquota;
	struct compat_fs_qfilestat qs_gquota;
	compat_uint_t qs_incoredqs;
	compat_int_t qs_btimelimit;
	compat_int_t qs_itimelimit;
	compat_int_t qs_rtbtimelimit;
	__u16 qs_bwarnlimit;
	__u16 qs_iwarnlimit;
};

struct dir_context;

typedef bool (*filldir_t)(struct dir_context *, const char *, int, loff_t, u64, unsigned int);

struct dir_context {
	filldir_t actor;
	loff_t pos;
};

struct compat_linux_dirent;

struct compat_getdents_callback {
	struct dir_context ctx;
	struct compat_linux_dirent *current_dir;
	int prev_reclen;
	int count;
	int error;
};

struct compat_group_filter {
	union {
		struct {
			__u32 gf_interface_aux;
			struct __kernel_sockaddr_storage gf_group_aux;
			__u32 gf_fmode_aux;
			__u32 gf_numsrc_aux;
			struct __kernel_sockaddr_storage gf_slist[1];
		} __attribute__((packed));
		struct {
			__u32 gf_interface;
			struct __kernel_sockaddr_storage gf_group;
			__u32 gf_fmode;
			__u32 gf_numsrc;
			struct __kernel_sockaddr_storage gf_slist_flex[0];
		} __attribute__((packed));
	};
};

struct compat_group_req {
	__u32 gr_interface;
	struct __kernel_sockaddr_storage gr_group;
} __attribute__((packed));

struct compat_group_source_req {
	__u32 gsr_interface;
	struct __kernel_sockaddr_storage gsr_group;
	struct __kernel_sockaddr_storage gsr_source;
} __attribute__((packed));

struct compat_hd_geometry {
	unsigned char heads;
	unsigned char sectors;
	short unsigned int cylinders;
	u32 start;
};

struct compat_hpet_info {
	compat_ulong_t hi_ireqfreq;
	compat_ulong_t hi_flags;
	short unsigned int hi_hpet;
	short unsigned int hi_timer;
};

struct compat_if_dqblk {
	compat_u64 dqb_bhardlimit;
	compat_u64 dqb_bsoftlimit;
	compat_u64 dqb_curspace;
	compat_u64 dqb_ihardlimit;
	compat_u64 dqb_isoftlimit;
	compat_u64 dqb_curinodes;
	compat_u64 dqb_btime;
	compat_u64 dqb_itime;
	compat_uint_t dqb_valid;
} __attribute__((packed));

struct compat_if_settings {
	unsigned int type;
	unsigned int size;
	compat_uptr_t ifs_ifsu;
};

struct compat_ifconf {
	compat_int_t ifc_len;
	compat_caddr_t ifcbuf;
};

struct compat_ifmap {
	compat_ulong_t mem_start;
	compat_ulong_t mem_end;
	short unsigned int base_addr;
	unsigned char irq;
	unsigned char dma;
	unsigned char port;
};

struct compat_ifreq {
	union {
		char ifrn_name[16];
	} ifr_ifrn;
	union {
		struct sockaddr ifru_addr;
		struct sockaddr ifru_dstaddr;
		struct sockaddr ifru_broadaddr;
		struct sockaddr ifru_netmask;
		struct sockaddr ifru_hwaddr;
		short int ifru_flags;
		compat_int_t ifru_ivalue;
		compat_int_t ifru_mtu;
		struct compat_ifmap ifru_map;
		char ifru_slave[16];
		char ifru_newname[16];
		compat_caddr_t ifru_data;
		struct compat_if_settings ifru_settings;
	} ifr_ifru;
};

struct compat_in6_rtmsg {
	struct in6_addr rtmsg_dst;
	struct in6_addr rtmsg_src;
	struct in6_addr rtmsg_gateway;
	u32 rtmsg_type;
	u16 rtmsg_dst_len;
	u16 rtmsg_src_len;
	u32 rtmsg_metric;
	u32 rtmsg_info;
	u32 rtmsg_flags;
	s32 rtmsg_ifindex;
};

struct compat_iovec {
	compat_uptr_t iov_base;
	compat_size_t iov_len;
};

struct compat_ipc64_perm {
	compat_key_t key;
	__compat_uid32_t uid;
	__compat_gid32_t gid;
	__compat_uid32_t cuid;
	__compat_gid32_t cgid;
	compat_mode_t mode;
	unsigned char __pad1[2];
	compat_ushort_t seq;
	compat_ushort_t __pad2;
	compat_ulong_t unused1;
	compat_ulong_t unused2;
};

struct compat_ipc_kludge {
	compat_uptr_t msgp;
	compat_long_t msgtyp;
};

struct compat_ipc_perm {
	key_t key;
	__compat_uid_t uid;
	__compat_gid_t gid;
	__compat_uid_t cuid;
	__compat_gid_t cgid;
	compat_mode_t mode;
	short unsigned int seq;
};

struct compat_kexec_segment {
	compat_uptr_t buf;
	compat_size_t bufsz;
	compat_ulong_t mem;
	compat_size_t memsz;
};

struct compat_linux_dirent {
	compat_ulong_t d_ino;
	compat_ulong_t d_off;
	short unsigned int d_reclen;
	char d_name[0];
};

struct compat_loop_info {
	compat_int_t lo_number;
	compat_dev_t lo_device;
	compat_ulong_t lo_inode;
	compat_dev_t lo_rdevice;
	compat_int_t lo_offset;
	compat_int_t lo_encrypt_type;
	compat_int_t lo_encrypt_key_size;
	compat_int_t lo_flags;
	char lo_name[64];
	unsigned char lo_encrypt_key[32];
	compat_ulong_t lo_init[2];
	char reserved[4];
};

struct compat_msghdr {
	compat_uptr_t msg_name;
	compat_int_t msg_namelen;
	compat_uptr_t msg_iov;
	compat_size_t msg_iovlen;
	compat_uptr_t msg_control;
	compat_size_t msg_controllen;
	compat_uint_t msg_flags;
};

struct compat_mmsghdr {
	struct compat_msghdr msg_hdr;
	compat_uint_t msg_len;
};

struct compat_mq_attr {
	compat_long_t mq_flags;
	compat_long_t mq_maxmsg;
	compat_long_t mq_msgsize;
	compat_long_t mq_curmsgs;
	compat_long_t __reserved[4];
};

struct compat_msgbuf {
	compat_long_t mtype;
	char mtext[0];
};

struct compat_msqid64_ds {
	struct compat_ipc64_perm msg_perm;
	compat_ulong_t msg_stime;
	compat_ulong_t msg_stime_high;
	compat_ulong_t msg_rtime;
	compat_ulong_t msg_rtime_high;
	compat_ulong_t msg_ctime;
	compat_ulong_t msg_ctime_high;
	compat_ulong_t msg_cbytes;
	compat_ulong_t msg_qnum;
	compat_ulong_t msg_qbytes;
	compat_pid_t msg_lspid;
	compat_pid_t msg_lrpid;
	compat_ulong_t __unused4;
	compat_ulong_t __unused5;
};

struct compat_msqid_ds {
	struct compat_ipc_perm msg_perm;
	compat_uptr_t msg_first;
	compat_uptr_t msg_last;
	old_time32_t msg_stime;
	old_time32_t msg_rtime;
	old_time32_t msg_ctime;
	compat_ulong_t msg_lcbytes;
	compat_ulong_t msg_lqbytes;
	short unsigned int msg_cbytes;
	short unsigned int msg_qnum;
	short unsigned int msg_qbytes;
	compat_ipc_pid_t msg_lspid;
	compat_ipc_pid_t msg_lrpid;
};

struct compat_nfs_string {
	compat_uint_t len;
	compat_uptr_t data;
};

struct compat_nfs4_mount_data_v1 {
	compat_int_t version;
	compat_int_t flags;
	compat_int_t rsize;
	compat_int_t wsize;
	compat_int_t timeo;
	compat_int_t retrans;
	compat_int_t acregmin;
	compat_int_t acregmax;
	compat_int_t acdirmin;
	compat_int_t acdirmax;
	struct compat_nfs_string client_addr;
	struct compat_nfs_string mnt_path;
	struct compat_nfs_string hostname;
	compat_uint_t host_addrlen;
	compat_uptr_t host_addr;
	compat_int_t proto;
	compat_int_t auth_flavourlen;
	compat_uptr_t auth_flavours;
};

struct compat_old_linux_dirent {
	compat_ulong_t d_ino;
	compat_ulong_t d_offset;
	short unsigned int d_namlen;
	char d_name[0];
};

struct compat_old_sigaction {
	compat_uptr_t sa_handler;
	compat_old_sigset_t sa_mask;
	compat_ulong_t sa_flags;
	compat_uptr_t sa_restorer;
};

struct compat_readdir_callback {
	struct dir_context ctx;
	struct compat_old_linux_dirent *dirent;
	int result;
};

struct compat_resume_swap_area {
	compat_loff_t offset;
	u32 dev;
} __attribute__((packed));

struct compat_rlimit {
	compat_ulong_t rlim_cur;
	compat_ulong_t rlim_max;
};

struct compat_robust_list {
	compat_uptr_t next;
};

struct compat_robust_list_head {
	struct compat_robust_list list;
	compat_long_t futex_offset;
	compat_uptr_t list_op_pending;
};

struct compat_rtentry {
	u32 rt_pad1;
	struct sockaddr rt_dst;
	struct sockaddr rt_gateway;
	struct sockaddr rt_genmask;
	short unsigned int rt_flags;
	short int rt_pad2;
	u32 rt_pad3;
	unsigned char rt_tos;
	unsigned char rt_class;
	short int rt_pad4;
	short int rt_metric;
	compat_uptr_t rt_dev;
	u32 rt_mtu;
	u32 rt_window;
	short unsigned int rt_irtt;
};

struct compat_rusage {
	struct old_timeval32 ru_utime;
	struct old_timeval32 ru_stime;
	compat_long_t ru_maxrss;
	compat_long_t ru_ixrss;
	compat_long_t ru_idrss;
	compat_long_t ru_isrss;
	compat_long_t ru_minflt;
	compat_long_t ru_majflt;
	compat_long_t ru_nswap;
	compat_long_t ru_inblock;
	compat_long_t ru_oublock;
	compat_long_t ru_msgsnd;
	compat_long_t ru_msgrcv;
	compat_long_t ru_nsignals;
	compat_long_t ru_nvcsw;
	compat_long_t ru_nivcsw;
};

struct compat_sel_arg_struct {
	compat_ulong_t n;
	compat_uptr_t inp;
	compat_uptr_t outp;
	compat_uptr_t exp;
	compat_uptr_t tvp;
};

struct compat_semid64_ds {
	struct compat_ipc64_perm sem_perm;
	compat_ulong_t sem_otime;
	compat_ulong_t sem_otime_high;
	compat_ulong_t sem_ctime;
	compat_ulong_t sem_ctime_high;
	compat_ulong_t sem_nsems;
	compat_ulong_t __unused3;
	compat_ulong_t __unused4;
};

struct compat_semid_ds {
	struct compat_ipc_perm sem_perm;
	old_time32_t sem_otime;
	old_time32_t sem_ctime;
	compat_uptr_t sem_base;
	compat_uptr_t sem_pending;
	compat_uptr_t sem_pending_last;
	compat_uptr_t undo;
	short unsigned int sem_nsems;
};

struct compat_sg_io_hdr {
	compat_int_t interface_id;
	compat_int_t dxfer_direction;
	unsigned char cmd_len;
	unsigned char mx_sb_len;
	short unsigned int iovec_count;
	compat_uint_t dxfer_len;
	compat_uint_t dxferp;
	compat_uptr_t cmdp;
	compat_uptr_t sbp;
	compat_uint_t timeout;
	compat_uint_t flags;
	compat_int_t pack_id;
	compat_uptr_t usr_ptr;
	unsigned char status;
	unsigned char masked_status;
	unsigned char msg_status;
	unsigned char sb_len_wr;
	short unsigned int host_status;
	short unsigned int driver_status;
	compat_int_t resid;
	compat_uint_t duration;
	compat_uint_t info;
};

struct compat_sg_req_info {
	char req_state;
	char orphan;
	char sg_io_owned;
	char problem;
	int pack_id;
	compat_uptr_t usr_ptr;
	unsigned int duration;
	int unused;
};

struct compat_shm_info {
	compat_int_t used_ids;
	compat_ulong_t shm_tot;
	compat_ulong_t shm_rss;
	compat_ulong_t shm_swp;
	compat_ulong_t swap_attempts;
	compat_ulong_t swap_successes;
};

struct compat_shmid64_ds {
	struct compat_ipc64_perm shm_perm;
	compat_size_t shm_segsz;
	compat_ulong_t shm_atime;
	compat_ulong_t shm_atime_high;
	compat_ulong_t shm_dtime;
	compat_ulong_t shm_dtime_high;
	compat_ulong_t shm_ctime;
	compat_ulong_t shm_ctime_high;
	compat_pid_t shm_cpid;
	compat_pid_t shm_lpid;
	compat_ulong_t shm_nattch;
	compat_ulong_t __unused4;
	compat_ulong_t __unused5;
};

struct compat_shmid_ds {
	struct compat_ipc_perm shm_perm;
	int shm_segsz;
	old_time32_t shm_atime;
	old_time32_t shm_dtime;
	old_time32_t shm_ctime;
	compat_ipc_pid_t shm_cpid;
	compat_ipc_pid_t shm_lpid;
	short unsigned int shm_nattch;
	short unsigned int shm_unused;
	compat_uptr_t shm_unused2;
	compat_uptr_t shm_unused3;
};

struct compat_shminfo64 {
	compat_ulong_t shmmax;
	compat_ulong_t shmmin;
	compat_ulong_t shmmni;
	compat_ulong_t shmseg;
	compat_ulong_t shmall;
	compat_ulong_t __unused1;
	compat_ulong_t __unused2;
	compat_ulong_t __unused3;
	compat_ulong_t __unused4;
};

struct compat_sigaction {
	compat_uptr_t sa_handler;
	compat_ulong_t sa_flags;
	compat_uptr_t sa_restorer;
	compat_sigset_t sa_mask;
};

struct compat_sigaltstack {
	compat_uptr_t ss_sp;
	int ss_flags;
	compat_size_t ss_size;
};

typedef struct compat_sigaltstack compat_stack_t;

union compat_sigval {
	compat_int_t sival_int;
	compat_uptr_t sival_ptr;
};

typedef union compat_sigval compat_sigval_t;

struct compat_sigevent {
	compat_sigval_t sigev_value;
	compat_int_t sigev_signo;
	compat_int_t sigev_notify;
	union {
		compat_int_t _pad[13];
		compat_int_t _tid;
		struct {
			compat_uptr_t _function;
			compat_uptr_t _attribute;
		} _sigev_thread;
	} _sigev_un;
};

struct compat_siginfo {
	int si_signo;
	int si_errno;
	int si_code;
	union {
		int _pad[29];
		struct {
			compat_pid_t _pid;
			__compat_uid32_t _uid;
		} _kill;
		struct {
			compat_timer_t _tid;
			int _overrun;
			compat_sigval_t _sigval;
		} _timer;
		struct {
			compat_pid_t _pid;
			__compat_uid32_t _uid;
			compat_sigval_t _sigval;
		} _rt;
		struct {
			compat_pid_t _pid;
			__compat_uid32_t _uid;
			int _status;
			compat_clock_t _utime;
			compat_clock_t _stime;
		} _sigchld;
		struct {
			compat_uptr_t _addr;
			union {
				int _trapno;
				short int _addr_lsb;
				struct {
					char _dummy_bnd[4];
					compat_uptr_t _lower;
					compat_uptr_t _upper;
				} _addr_bnd;
				struct {
					char _dummy_pkey[4];
					u32 _pkey;
				} _addr_pkey;
				struct {
					compat_ulong_t _data;
					u32 _type;
					u32 _flags;
				} _perf;
			};
		} _sigfault;
		struct {
			compat_long_t _band;
			int _fd;
		} _sigpoll;
		struct {
			compat_uptr_t _call_addr;
			int _syscall;
			unsigned int _arch;
		} _sigsys;
	} _sifields;
};

typedef struct compat_siginfo compat_siginfo_t;

struct compat_sigset_argpack {
	compat_uptr_t p;
	compat_size_t size;
};

struct in_addr {
	__be32 s_addr;
};

struct compat_sioc_sg_req {
	struct in_addr src;
	struct in_addr grp;
	compat_ulong_t pktcnt;
	compat_ulong_t bytecnt;
	compat_ulong_t wrong_if;
};

struct compat_sioc_vif_req {
	vifi_t vifi;
	compat_ulong_t icount;
	compat_ulong_t ocount;
	compat_ulong_t ibytes;
	compat_ulong_t obytes;
};

struct compat_snd_pcm_status64 {
	snd_pcm_state_t state;
	u8 rsvd[4];
	s64 trigger_tstamp_sec;
	s64 trigger_tstamp_nsec;
	s64 tstamp_sec;
	s64 tstamp_nsec;
	u32 appl_ptr;
	u32 hw_ptr;
	s32 delay;
	u32 avail;
	u32 avail_max;
	u32 overrange;
	snd_pcm_state_t suspended_state;
	u32 audio_tstamp_data;
	s64 audio_tstamp_sec;
	s64 audio_tstamp_nsec;
	s64 driver_tstamp_sec;
	s64 driver_tstamp_nsec;
	u32 audio_tstamp_accuracy;
	unsigned char reserved[20];
};

struct compat_sock_fprog {
	u16 len;
	compat_uptr_t filter;
};

struct compat_stat {
	u32 st_dev;
	compat_ino_t st_ino;
	compat_mode_t st_mode;
	compat_nlink_t st_nlink;
	__compat_uid_t st_uid;
	__compat_gid_t st_gid;
	u32 st_rdev;
	u32 st_size;
	u32 st_blksize;
	u32 st_blocks;
	u32 st_atime;
	u32 st_atime_nsec;
	u32 st_mtime;
	u32 st_mtime_nsec;
	u32 st_ctime;
	u32 st_ctime_nsec;
	u32 __unused4;
	u32 __unused5;
};

struct compat_statfs {
	int f_type;
	int f_bsize;
	int f_blocks;
	int f_bfree;
	int f_bavail;
	int f_files;
	int f_ffree;
	compat_fsid_t f_fsid;
	int f_namelen;
	int f_frsize;
	int f_flags;
	int f_spare[4];
};

struct compat_statfs64 {
	__u32 f_type;
	__u32 f_bsize;
	__u64 f_blocks;
	__u64 f_bfree;
	__u64 f_bavail;
	__u64 f_files;
	__u64 f_ffree;
	__kernel_fsid_t f_fsid;
	__u32 f_namelen;
	__u32 f_frsize;
	__u32 f_flags;
	__u32 f_spare[4];
} __attribute__((packed));

struct compat_sysinfo {
	s32 uptime;
	u32 loads[3];
	u32 totalram;
	u32 freeram;
	u32 sharedram;
	u32 bufferram;
	u32 totalswap;
	u32 freeswap;
	u16 procs;
	u16 pad;
	u32 totalhigh;
	u32 freehigh;
	u32 mem_unit;
	char _f[8];
};

struct compat_tms {
	compat_clock_t tms_utime;
	compat_clock_t tms_stime;
	compat_clock_t tms_cutime;
	compat_clock_t tms_cstime;
};

struct compat_unimapdesc {
	short unsigned int entry_ct;
	compat_caddr_t entries;
};

struct compat_ustat {
	compat_daddr_t f_tfree;
	compat_ino_t f_tinode;
	char f_fname[6];
	char f_fpack[6];
};

struct component_ops;

struct component {
	struct list_head node;
	struct aggregate_device *adev;
	bool bound;
	const struct component_ops *ops;
	int subcomponent;
	struct device *dev;
};

struct component_master_ops {
	int (*bind)(struct device *);
	void (*unbind)(struct device *);
};

struct component_match_array;

struct component_match {
	size_t alloc;
	size_t num;
	struct component_match_array *compare;
};

struct component_match_array {
	void *data;
	int (*compare)(struct device *, void *);
	int (*compare_typed)(struct device *, int, void *);
	void (*release)(struct device *, void *);
	struct component *component;
	bool duplicate;
};

struct component_ops {
	int (*bind)(struct device *, struct device *, void *);
	void (*unbind)(struct device *, struct device *, void *);
};

struct compound_hdr {
	int32_t status;
	uint32_t nops;
	__be32 *nops_p;
	uint32_t taglen;
	char *tag;
	uint32_t replen;
	u32 minorversion;
};

typedef int (*decompress_fn)(unsigned char *, long int, long int (*)(void *, long unsigned int), long int (*)(void *, long unsigned int), unsigned char *, long int *, void (*)(char *));

struct compress_format {
	unsigned char magic[2];
	const char *name;
	decompress_fn decompressor;
};

struct consw;

struct con_driver {
	const struct consw *con;
	const char *desc;
	struct device *dev;
	int node;
	int first;
	int last;
	int flag;
};

struct cond_av_list {
	struct avtab_node **nodes;
	u32 len;
};

struct cond_bool_datum {
	u32 value;
	int state;
};

struct cond_expr_node;

struct cond_expr {
	struct cond_expr_node *nodes;
	u32 len;
};

struct cond_expr_node {
	u32 expr_type;
	u32 boolean;
};

struct policydb;

struct cond_insertf_data {
	struct policydb *p;
	struct avtab_node **dst;
	struct cond_av_list *other;
};

struct cond_node {
	int cur_state;
	struct cond_expr expr;
	struct cond_av_list true_list;
	struct cond_av_list false_list;
};

struct dmi_system_id;

struct snd_soc_acpi_codecs;

struct config_entry {
	u32 flags;
	u16 device;
	u8 acpi_hid[16];
	const struct dmi_system_id *dmi_table;
	const struct snd_soc_acpi_codecs *codec_hid;
};

struct deflate_state;

typedef struct deflate_state deflate_state;

typedef block_state (*compress_func)(deflate_state *, int);

struct config_s {
	ush good_length;
	ush max_lazy;
	ush nice_length;
	ush max_chain;
	compress_func func;
};

typedef struct config_s config;

struct config_t {
	struct kref ref;
	unsigned int state;
	struct resource io[2];
	struct resource mem[4];
};

typedef struct config_t config_t;

struct connect_timeout_data {
	long unsigned int connect_timeout;
	long unsigned int reconnect_timeout;
};

struct conntrack_gc_work {
	struct delayed_work dwork;
	u32 next_bucket;
	u32 avg_timeout;
	u32 count;
	u32 start_time;
	bool exiting;
	bool early_drop;
};

struct console;

struct printk_buffers;

struct nbcon_context {
	struct console *console;
	unsigned int spinwait_max_us;
	enum nbcon_prio prio;
	unsigned int allow_unsafe_takeover: 1;
	unsigned int backlog: 1;
	struct printk_buffers *pbufs;
	u64 seq;
};

struct tty_driver;

struct nbcon_write_context;

struct console {
	char name[16];
	void (*write)(struct console *, const char *, unsigned int);
	int (*read)(struct console *, char *, unsigned int);
	struct tty_driver * (*device)(struct console *, int *);
	void (*unblank)(void);
	int (*setup)(struct console *, char *);
	int (*exit)(struct console *);
	int (*match)(struct console *, char *, int, char *);
	short int flags;
	short int index;
	int cflag;
	uint ispeed;
	uint ospeed;
	u64 seq;
	long unsigned int dropped;
	void *data;
	struct hlist_node node;
	void (*write_atomic)(struct console *, struct nbcon_write_context *);
	void (*write_thread)(struct console *, struct nbcon_write_context *);
	void (*device_lock)(struct console *, long unsigned int *);
	void (*device_unlock)(struct console *, long unsigned int);
	atomic_t nbcon_state;
	atomic_long_t nbcon_seq;
	struct nbcon_context nbcon_device_ctxt;
	atomic_long_t nbcon_prev_seq;
	struct printk_buffers *pbufs;
	struct task_struct *kthread;
	struct rcuwait rcuwait;
	struct irq_work irq_work;
};

struct winsize {
	short unsigned int ws_row;
	short unsigned int ws_col;
	short unsigned int ws_xpixel;
	short unsigned int ws_ypixel;
};

struct hvc_struct;

struct console___2 {
	struct list_head list;
	struct hvc_struct *hvc;
	struct winsize ws;
	u32 vtermno;
};

struct console_cmdline {
	char name[16];
	int index;
	char devname[32];
	bool user_specified;
	char *options;
};

struct console_flush_type {
	bool nbcon_atomic;
	bool nbcon_offload;
	bool legacy_direct;
	bool legacy_offload;
};

struct console_font {
	unsigned int width;
	unsigned int height;
	unsigned int charcount;
	unsigned char *data;
};

struct console_font_op {
	unsigned int op;
	unsigned int flags;
	unsigned int width;
	unsigned int height;
	unsigned int charcount;
	unsigned char *data;
};

struct constant_table {
	const char *name;
	int value;
};

struct ebitmap_node;

struct ebitmap {
	struct ebitmap_node *node;
	u32 highbit;
};

struct type_set;

struct constraint_expr {
	u32 expr_type;
	u32 attr;
	u32 op;
	struct ebitmap names;
	struct type_set *type_names;
	struct constraint_expr *next;
};

struct constraint_node {
	u32 permissions;
	struct constraint_expr *expr;
	struct constraint_node *next;
};

struct vc_data;

struct consw {
	struct module *owner;
	const char * (*con_startup)(void);
	void (*con_init)(struct vc_data *, bool);
	void (*con_deinit)(struct vc_data *);
	void (*con_clear)(struct vc_data *, unsigned int, unsigned int, unsigned int);
	void (*con_putc)(struct vc_data *, u16, unsigned int, unsigned int);
	void (*con_putcs)(struct vc_data *, const u16 *, unsigned int, unsigned int, unsigned int);
	void (*con_cursor)(struct vc_data *, bool);
	bool (*con_scroll)(struct vc_data *, unsigned int, unsigned int, enum con_scroll, unsigned int);
	bool (*con_switch)(struct vc_data *);
	bool (*con_blank)(struct vc_data *, enum vesa_blank_mode, bool);
	int (*con_font_set)(struct vc_data *, const struct console_font *, unsigned int, unsigned int);
	int (*con_font_get)(struct vc_data *, struct console_font *, unsigned int);
	int (*con_font_default)(struct vc_data *, struct console_font *, const char *);
	int (*con_resize)(struct vc_data *, unsigned int, unsigned int, bool);
	void (*con_set_palette)(struct vc_data *, const unsigned char *);
	void (*con_scrolldelta)(struct vc_data *, int);
	bool (*con_set_origin)(struct vc_data *);
	void (*con_save_screen)(struct vc_data *);
	u8 (*con_build_attr)(struct vc_data *, u8, enum vc_intensity, bool, bool, bool, bool);
	void (*con_invert_region)(struct vc_data *, u16 *, int);
	void (*con_debug_enter)(struct vc_data *);
	void (*con_debug_leave)(struct vc_data *);
};

struct microcode_amd;

struct cont_desc {
	struct microcode_amd *mc;
	u32 psize;
	u8 *data;
	size_t size;
};

struct container_dev {
	struct device dev;
	int (*offline)(struct container_dev *);
};

struct mls_level {
	u32 sens;
	struct ebitmap cat;
};

struct mls_range {
	struct mls_level level[2];
};

struct context___2 {
	u32 user;
	u32 role;
	u32 type;
	u32 len;
	struct mls_range range;
	char *str;
};

struct context_entry {
	u64 lo;
	u64 hi;
};

struct guc_update_context_policy_header {
	u32 action;
	u32 ctx_id;
};

struct guc_klv_generic_dw_t {
	u32 kl;
	u32 value;
};

struct guc_update_context_policy {
	struct guc_update_context_policy_header header;
	struct guc_klv_generic_dw_t klv[5];
};

struct context_policy {
	u32 count;
	struct guc_update_context_policy h2g;
};

struct context_tracking {
	atomic_t state;
	long int nesting;
	long int nmi_nesting;
};

struct contig_page_info {
	long unsigned int free_pages;
	long unsigned int free_blocks_total;
	long unsigned int free_blocks_suitable;
};

struct virtio_net_ctrl_hdr {
	__u8 class;
	__u8 cmd;
};

struct control_buf {
	struct virtio_net_ctrl_hdr hdr;
	virtio_net_ctrl_ack status;
};

struct convert_context_args {
	struct policydb *oldp;
	struct policydb *newp;
};

struct cooling_spec {
	long unsigned int upper;
	long unsigned int lower;
	unsigned int weight;
};

struct copy_subpage_arg {
	struct folio *dst;
	struct folio *src;
	struct vm_area_struct *vma;
};

struct core_name {
	char *corename;
	int used;
	int size;
};

struct core_thread {
	struct task_struct *task;
	struct core_thread *next;
};

struct core_state {
	atomic_t nr_threads;
	struct core_thread dumper;
	struct completion startup;
};

struct core_text {
	long unsigned int base;
	long unsigned int end;
	const char *name;
};

struct core_vma_metadata {
	long unsigned int start;
	long unsigned int end;
	long unsigned int flags;
	long unsigned int dump_size;
	long unsigned int pgoff;
	struct file *file;
};

struct kernel_siginfo;

typedef struct kernel_siginfo kernel_siginfo_t;

struct coredump_params {
	const kernel_siginfo_t *siginfo;
	struct file *file;
	long unsigned int limit;
	long unsigned int mm_flags;
	int cpu;
	loff_t written;
	loff_t pos;
	loff_t to_skip;
	int vma_count;
	size_t vma_data_size;
	struct core_vma_metadata *vma_meta;
};

struct coredump_proc_event {
	__kernel_pid_t process_pid;
	__kernel_pid_t process_tgid;
	__kernel_pid_t parent_pid;
	__kernel_pid_t parent_tgid;
};

struct pgprot {
	pgprotval_t pgprot;
};

typedef struct pgprot pgprot_t;

struct cpa_data {
	long unsigned int *vaddr;
	pgd_t *pgd;
	pgprot_t mask_set;
	pgprot_t mask_clr;
	long unsigned int numpages;
	long unsigned int curpage;
	long unsigned int pfn;
	unsigned int flags;
	unsigned int force_split: 1;
	unsigned int force_static_prot: 1;
	unsigned int force_flush_all: 1;
	struct page **pages;
};

struct cparams {
	u16 i;
	u16 t;
	u16 m;
	u16 c;
};

struct cpc_reg {
	u8 descriptor;
	u16 length;
	u8 space_id;
	u8 bit_width;
	u8 bit_offset;
	u8 access_width;
	u64 address;
} __attribute__((packed));

struct cpc_register_resource {
	acpi_object_type type;
	u64 *sys_mem_vaddr;
	union {
		struct cpc_reg reg;
		u64 int_value;
	} cpc_entry;
};

struct cpc_desc {
	int num_entries;
	int version;
	int cpu_id;
	int write_cmd_status;
	int write_cmd_id;
	raw_spinlock_t rmw_lock;
	struct cpc_register_resource cpc_regs[21];
	struct acpi_psd_package domain_info;
	struct kobject kobj;
};

struct cpio_data {
	void *data;
	size_t size;
	char name[18];
};

struct cppc_perf_caps {
	u32 guaranteed_perf;
	u32 highest_perf;
	u32 nominal_perf;
	u32 lowest_perf;
	u32 lowest_nonlinear_perf;
	u32 lowest_freq;
	u32 nominal_freq;
	u32 energy_perf;
	bool auto_sel;
};

struct cppc_perf_ctrls {
	u32 max_perf;
	u32 min_perf;
	u32 desired_perf;
	u32 energy_perf;
};

struct cppc_perf_fb_ctrs {
	u64 reference;
	u64 delivered;
	u64 reference_perf;
	u64 wraparound_time;
};

struct cppc_cpudata {
	struct list_head node;
	struct cppc_perf_caps perf_caps;
	struct cppc_perf_ctrls perf_ctrls;
	struct cppc_perf_fb_ctrs perf_fb_ctrs;
	unsigned int shared_type;
	cpumask_var_t shared_cpu_map;
};

struct pcc_mbox_chan;

struct cppc_pcc_data {
	struct pcc_mbox_chan *pcc_channel;
	void *pcc_comm_addr;
	bool pcc_channel_acquired;
	unsigned int deadline_us;
	unsigned int pcc_mpar;
	unsigned int pcc_mrtt;
	unsigned int pcc_nominal;
	bool pending_pcc_write_cmd;
	bool platform_owns_pcc;
	unsigned int pcc_write_cnt;
	struct rw_semaphore pcc_lock;
	wait_queue_head_t pcc_write_wait_q;
	ktime_t last_cmd_cmpl_time;
	ktime_t last_mpar_reset;
	int mpar_count;
	int refcount;
};

struct cpu {
	int node_id;
	int hotpluggable;
	struct device dev;
};

struct cpu_attr {
	struct device_attribute attr;
	const struct cpumask * const map;
};

struct cpu_cacheinfo {
	struct cacheinfo *info_list;
	unsigned int per_cpu_data_slice_size;
	unsigned int num_levels;
	unsigned int num_leaves;
	bool cpu_map_populated;
	bool early_ci_levels;
};

struct update_util_data {
	void (*func)(struct update_util_data *, u64, unsigned int);
};

struct policy_dbs_info;

struct cpu_dbs_info {
	u64 prev_cpu_idle;
	u64 prev_update_time;
	u64 prev_cpu_nice;
	unsigned int prev_load;
	struct update_util_data update_util;
	struct policy_dbs_info *policy_dbs;
};

struct cpuinfo_x86;

struct cpu_dev {
	const char *c_vendor;
	const char *c_ident[2];
	void (*c_early_init)(struct cpuinfo_x86 *);
	void (*c_bsp_init)(struct cpuinfo_x86 *);
	void (*c_init)(struct cpuinfo_x86 *);
	void (*c_identify)(struct cpuinfo_x86 *);
	void (*c_detect_tlb)(struct cpuinfo_x86 *);
	int c_x86_vendor;
};

struct cpu_down_work {
	unsigned int cpu;
	enum cpuhp_state target;
};

struct entry_stack {
	char stack[4096];
};

struct entry_stack_page {
	struct entry_stack stack;
};

struct x86_hw_tss {
	u32 reserved1;
	u64 sp0;
	u64 sp1;
	u64 sp2;
	u64 reserved2;
	u64 ist[7];
	u32 reserved3;
	u32 reserved4;
	u16 reserved5;
	u16 io_bitmap_base;
} __attribute__((packed));

struct x86_io_bitmap {
	u64 prev_sequence;
	unsigned int prev_max;
	long unsigned int bitmap[1025];
	long unsigned int mapall[1025];
};

struct tss_struct {
	struct x86_hw_tss x86_tss;
	struct x86_io_bitmap io_bitmap;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct debug_store_buffers {
	char bts_buffer[65536];
	char pebs_buffer[65536];
};

struct cpu_entry_area {
	char gdt[4096];
	struct entry_stack_page entry_stack_page;
	struct tss_struct tss;
	struct cea_exception_stacks estacks;
	struct debug_store cpu_debug_store;
	struct debug_store_buffers cpu_debug_buffers;
};

struct folio_batch {
	unsigned char nr;
	unsigned char i;
	bool percpu_pvec_drained;
	struct folio *folios[31];
};

struct cpu_fbatches {
	local_lock_t lock;
	struct folio_batch lru_add;
	struct folio_batch lru_deactivate_file;
	struct folio_batch lru_deactivate;
	struct folio_batch lru_lazyfree;
	struct folio_batch lru_activate;
	local_lock_t lock_irq;
	struct folio_batch lru_move_tail;
};

struct perf_branch_entry {
	__u64 from;
	__u64 to;
	__u64 mispred: 1;
	__u64 predicted: 1;
	__u64 in_tx: 1;
	__u64 abort: 1;
	__u64 cycles: 16;
	__u64 type: 4;
	__u64 spec: 2;
	__u64 new_type: 4;
	__u64 priv: 3;
	__u64 reserved: 31;
};

struct perf_branch_stack {
	__u64 nr;
	__u64 hw_idx;
	struct perf_branch_entry entries[0];
};

struct perf_guest_switch_msr {
	unsigned int msr;
	u64 host;
	u64 guest;
};

struct er_account;

struct intel_shared_regs;

struct intel_excl_cntrs;

struct cpu_hw_events {
	struct perf_event *events[64];
	long unsigned int active_mask[1];
	long unsigned int dirty[1];
	int enabled;
	int n_events;
	int n_added;
	int n_txn;
	int n_txn_pair;
	int n_txn_metric;
	int assign[64];
	u64 tags[64];
	struct perf_event *event_list[64];
	struct event_constraint *event_constraint[64];
	int n_excl;
	unsigned int txn_flags;
	int is_fake;
	struct debug_store *ds;
	void *ds_pebs_vaddr;
	void *ds_bts_vaddr;
	u64 pebs_enabled;
	int n_pebs;
	int n_large_pebs;
	int n_pebs_via_pt;
	int pebs_output;
	u64 pebs_data_cfg;
	u64 active_pebs_data_cfg;
	int pebs_record_size;
	u64 fixed_ctrl_val;
	u64 active_fixed_ctrl_val;
	int lbr_users;
	int lbr_pebs_users;
	struct perf_branch_stack lbr_stack;
	struct perf_branch_entry lbr_entries[32];
	u64 lbr_counters[32];
	union {
		struct er_account *lbr_sel;
		struct er_account *lbr_ctl;
	};
	u64 br_sel;
	void *last_task_ctx;
	int last_log_id;
	int lbr_select;
	void *lbr_xsave;
	u64 intel_ctrl_guest_mask;
	u64 intel_ctrl_host_mask;
	struct perf_guest_switch_msr guest_switch_msrs[64];
	u64 intel_cp_status;
	struct intel_shared_regs *shared_regs;
	struct event_constraint *constraint_list;
	struct intel_excl_cntrs *excl_cntrs;
	int excl_thread_id;
	u64 tfa_shadow;
	int n_metric;
	struct amd_nb *amd_nb;
	int brs_active;
	u64 perf_ctr_virt_mask;
	int n_pair;
	void *kfree_on_online[2];
	struct pmu *pmu;
};

struct cpu_itimer {
	u64 expires;
	u64 incr;
};

struct cpu_perf_ibs {
	struct perf_event *event;
	long unsigned int state[1];
};

struct cpu_rmap {
	struct kref refcount;
	u16 size;
	void **obj;
	struct {
		u16 index;
		u16 dist;
	} near[0];
};

struct cpu_signature {
	unsigned int sig;
	unsigned int pf;
	unsigned int rev;
};

struct cpu_stop_done {
	atomic_t nr_todo;
	int ret;
	struct completion completion;
};

typedef int (*cpu_stop_fn_t)(void *);

struct cpu_stop_work {
	struct list_head list;
	cpu_stop_fn_t fn;
	long unsigned int caller;
	void *arg;
	struct cpu_stop_done *done;
};

struct cpu_stopper {
	struct task_struct *thread;
	raw_spinlock_t lock;
	bool enabled;
	struct list_head works;
	struct cpu_stop_work stop_work;
	long unsigned int caller;
	cpu_stop_fn_t fn;
};

struct cpu_timer {
	struct timerqueue_node node;
	struct timerqueue_head *head;
	struct pid *pid;
	struct list_head elist;
	bool firing;
	bool nanosleep;
	struct task_struct *handling;
};

struct cpu_vfs_cap_data {
	__u32 magic_etc;
	kuid_t rootid;
	kernel_cap_t permitted;
	kernel_cap_t inheritable;
};

struct kernel_cpustat;

struct cpuacct {
	struct cgroup_subsys_state css;
	u64 *cpuusage;
	struct kernel_cpustat *cpustat;
};

struct pstate_data {
	int current_pstate;
	int min_pstate;
	int max_pstate;
	int max_pstate_physical;
	int perf_ctl_scaling;
	int scaling;
	int turbo_pstate;
	unsigned int min_freq;
	unsigned int max_freq;
	unsigned int turbo_freq;
};

struct vid_data {
	int min;
	int max;
	int turbo;
	int32_t ratio;
};

struct sample {
	int32_t core_avg_perf;
	int32_t busy_scaled;
	u64 aperf;
	u64 mperf;
	u64 tsc;
	u64 time;
};

struct cpudata {
	int cpu;
	unsigned int policy;
	struct update_util_data update_util;
	bool update_util_set;
	struct pstate_data pstate;
	struct vid_data vid;
	u64 last_update;
	u64 last_sample_time;
	u64 aperf_mperf_shift;
	u64 prev_aperf;
	u64 prev_mperf;
	u64 prev_tsc;
	struct sample sample;
	int32_t min_perf_ratio;
	int32_t max_perf_ratio;
	struct acpi_processor_performance acpi_perf_data;
	bool valid_pss_table;
	unsigned int iowait_boost;
	s16 epp_powersave;
	s16 epp_policy;
	s16 epp_default;
	s16 epp_cached;
	u64 hwp_req_cached;
	u64 hwp_cap_cached;
	u64 last_io_update;
	unsigned int capacity_perf;
	unsigned int sched_flags;
	u32 hwp_boost_min;
	bool suspended;
	struct delayed_work hwp_notify_work;
};

struct cpudl_item;

struct cpudl {
	raw_spinlock_t lock;
	int size;
	cpumask_var_t free_cpus;
	struct cpudl_item *elements;
};

struct cpudl_item {
	u64 dl;
	int cpu;
	int idx;
};

struct cpufreq_cpuinfo {
	unsigned int max_freq;
	unsigned int min_freq;
	unsigned int transition_latency;
};

struct cpufreq_policy;

struct cpufreq_policy_data;

struct freq_attr;

struct cpufreq_driver {
	char name[16];
	u16 flags;
	void *driver_data;
	int (*init)(struct cpufreq_policy *);
	int (*verify)(struct cpufreq_policy_data *);
	int (*setpolicy)(struct cpufreq_policy *);
	int (*target)(struct cpufreq_policy *, unsigned int, unsigned int);
	int (*target_index)(struct cpufreq_policy *, unsigned int);
	unsigned int (*fast_switch)(struct cpufreq_policy *, unsigned int);
	void (*adjust_perf)(unsigned int, long unsigned int, long unsigned int, long unsigned int);
	unsigned int (*get_intermediate)(struct cpufreq_policy *, unsigned int);
	int (*target_intermediate)(struct cpufreq_policy *, unsigned int);
	unsigned int (*get)(unsigned int);
	void (*update_limits)(unsigned int);
	int (*bios_limit)(int, unsigned int *);
	int (*online)(struct cpufreq_policy *);
	int (*offline)(struct cpufreq_policy *);
	void (*exit)(struct cpufreq_policy *);
	int (*suspend)(struct cpufreq_policy *);
	int (*resume)(struct cpufreq_policy *);
	void (*ready)(struct cpufreq_policy *);
	struct freq_attr **attr;
	bool boost_enabled;
	int (*set_boost)(struct cpufreq_policy *, int);
	void (*register_em)(struct cpufreq_policy *);
};

struct cpufreq_freqs {
	struct cpufreq_policy *policy;
	unsigned int old;
	unsigned int new;
	u8 flags;
};

struct cpufreq_frequency_table {
	unsigned int flags;
	unsigned int driver_data;
	unsigned int frequency;
};

struct cpufreq_governor {
	char name[16];
	int (*init)(struct cpufreq_policy *);
	void (*exit)(struct cpufreq_policy *);
	int (*start)(struct cpufreq_policy *);
	void (*stop)(struct cpufreq_policy *);
	void (*limits)(struct cpufreq_policy *);
	ssize_t (*show_setspeed)(struct cpufreq_policy *, char *);
	int (*store_setspeed)(struct cpufreq_policy *, unsigned int);
	struct list_head governor_list;
	struct module *owner;
	u8 flags;
};

struct plist_head {
	struct list_head node_list;
};

struct pm_qos_constraints {
	struct plist_head list;
	s32 target_value;
	s32 default_value;
	s32 no_constraint_value;
	enum pm_qos_type type;
	struct blocking_notifier_head *notifiers;
};

struct freq_constraints {
	struct pm_qos_constraints min_freq;
	struct blocking_notifier_head min_freq_notifiers;
	struct pm_qos_constraints max_freq;
	struct blocking_notifier_head max_freq_notifiers;
};

struct cpufreq_stats;

struct cpufreq_policy {
	cpumask_var_t cpus;
	cpumask_var_t related_cpus;
	cpumask_var_t real_cpus;
	unsigned int shared_type;
	unsigned int cpu;
	struct clk *clk;
	struct cpufreq_cpuinfo cpuinfo;
	unsigned int min;
	unsigned int max;
	unsigned int cur;
	unsigned int suspend_freq;
	unsigned int policy;
	unsigned int last_policy;
	struct cpufreq_governor *governor;
	void *governor_data;
	char last_governor[16];
	struct work_struct update;
	struct freq_constraints constraints;
	struct freq_qos_request *min_freq_req;
	struct freq_qos_request *max_freq_req;
	struct cpufreq_frequency_table *freq_table;
	enum cpufreq_table_sorting freq_table_sorted;
	struct list_head policy_list;
	struct kobject kobj;
	struct completion kobj_unregister;
	struct rw_semaphore rwsem;
	bool fast_switch_possible;
	bool fast_switch_enabled;
	bool strict_target;
	bool efficiencies_available;
	unsigned int transition_delay_us;
	bool dvfs_possible_from_any_cpu;
	bool boost_enabled;
	unsigned int cached_target_freq;
	unsigned int cached_resolved_idx;
	bool transition_ongoing;
	spinlock_t transition_lock;
	wait_queue_head_t transition_wait;
	struct task_struct *transition_task;
	struct cpufreq_stats *stats;
	void *driver_data;
	struct thermal_cooling_device *cdev;
	struct notifier_block nb_min;
	struct notifier_block nb_max;
};

struct cpufreq_policy_data {
	struct cpufreq_cpuinfo cpuinfo;
	struct cpufreq_frequency_table *freq_table;
	unsigned int cpu;
	unsigned int min;
	unsigned int max;
};

struct cpuhp_cpu_state {
	enum cpuhp_state state;
	enum cpuhp_state target;
	enum cpuhp_state fail;
	struct task_struct *thread;
	bool should_run;
	bool rollback;
	bool single;
	bool bringup;
	struct hlist_node *node;
	struct hlist_node *last;
	enum cpuhp_state cb_state;
	int result;
	atomic_t ap_sync_state;
	struct completion done_up;
	struct completion done_down;
};

struct cpuhp_step {
	const char *name;
	union {
		int (*single)(unsigned int);
		int (*multi)(unsigned int, struct hlist_node *);
	} startup;
	union {
		int (*single)(unsigned int);
		int (*multi)(unsigned int, struct hlist_node *);
	} teardown;
	struct hlist_head list;
	bool cant_stop;
	bool multi_instance;
};

union cpuid10_eax {
	struct {
		unsigned int version_id: 8;
		unsigned int num_counters: 8;
		unsigned int bit_width: 8;
		unsigned int mask_length: 8;
	} split;
	unsigned int full;
};

union cpuid10_ebx {
	struct {
		unsigned int no_unhalted_core_cycles: 1;
		unsigned int no_instructions_retired: 1;
		unsigned int no_unhalted_reference_cycles: 1;
		unsigned int no_llc_reference: 1;
		unsigned int no_llc_misses: 1;
		unsigned int no_branch_instruction_retired: 1;
		unsigned int no_branch_misses_retired: 1;
	} split;
	unsigned int full;
};

union cpuid10_edx {
	struct {
		unsigned int num_counters_fixed: 5;
		unsigned int bit_width_fixed: 8;
		unsigned int reserved1: 2;
		unsigned int anythread_deprecated: 1;
		unsigned int reserved2: 16;
	} split;
	unsigned int full;
};

union cpuid28_eax {
	struct {
		unsigned int lbr_depth_mask: 8;
		unsigned int reserved: 22;
		unsigned int lbr_deep_c_reset: 1;
		unsigned int lbr_lip: 1;
	} split;
	unsigned int full;
};

union cpuid28_ebx {
	struct {
		unsigned int lbr_cpl: 1;
		unsigned int lbr_filter: 1;
		unsigned int lbr_call_stack: 1;
	} split;
	unsigned int full;
};

union cpuid28_ecx {
	struct {
		unsigned int lbr_mispred: 1;
		unsigned int lbr_timed_lbr: 1;
		unsigned int lbr_br_type: 1;
		unsigned int reserved: 13;
		unsigned int lbr_counters: 4;
	} split;
	unsigned int full;
};

union cpuid35_eax {
	struct {
		unsigned int leaf0: 1;
		unsigned int cntr_subleaf: 1;
		unsigned int acr_subleaf: 1;
		unsigned int events_subleaf: 1;
		unsigned int reserved: 28;
	} split;
	unsigned int full;
};

union cpuid35_ebx {
	struct {
		unsigned int umask2: 1;
		unsigned int eq: 1;
		unsigned int reserved: 30;
	} split;
	unsigned int full;
};

union cpuid_0x80000022_ebx {
	struct {
		unsigned int num_core_pmc: 4;
		unsigned int lbr_v2_stack_sz: 6;
		unsigned int num_df_pmc: 6;
		unsigned int num_umc_pmc: 6;
	} split;
	unsigned int full;
};

union cpuid_1_eax {
	struct {
		__u32 stepping: 4;
		__u32 model: 4;
		__u32 family: 4;
		__u32 __reserved0: 4;
		__u32 ext_model: 4;
		__u32 ext_fam: 8;
		__u32 __reserved1: 4;
	};
	__u32 full;
};

struct cpuid_bit {
	u16 feature;
	u8 reg;
	u8 bit;
	u32 level;
	u32 sub_leaf;
};

struct cpuid_dep {
	unsigned int feature;
	unsigned int depends;
};

struct cpuid_dependent_feature {
	u32 feature;
	u32 level;
};

struct cpuid_regs {
	u32 eax;
	u32 ebx;
	u32 ecx;
	u32 edx;
};

struct cpuid_regs_done {
	struct cpuid_regs regs;
	struct completion done;
};

struct cpuidle_device;

struct cpuidle_attr {
	struct attribute attr;
	ssize_t (*show)(struct cpuidle_device *, char *);
	ssize_t (*store)(struct cpuidle_device *, const char *, size_t);
};

struct cpuidle_state_usage {
	long long unsigned int disable;
	long long unsigned int usage;
	u64 time_ns;
	long long unsigned int above;
	long long unsigned int below;
	long long unsigned int rejected;
	long long unsigned int s2idle_usage;
	long long unsigned int s2idle_time;
};

struct cpuidle_driver_kobj;

struct cpuidle_state_kobj;

struct cpuidle_device_kobj;

struct cpuidle_device {
	unsigned int registered: 1;
	unsigned int enabled: 1;
	unsigned int poll_time_limit: 1;
	unsigned int cpu;
	ktime_t next_hrtimer;
	int last_state_idx;
	u64 last_residency_ns;
	u64 poll_limit_ns;
	u64 forced_idle_latency_limit_ns;
	struct cpuidle_state_usage states_usage[10];
	struct cpuidle_state_kobj *kobjs[10];
	struct cpuidle_driver_kobj *kobj_driver;
	struct cpuidle_device_kobj *kobj_dev;
	struct list_head device_list;
};

struct cpuidle_device_kobj {
	struct cpuidle_device *dev;
	struct completion kobj_unregister;
	struct kobject kobj;
};

struct cpuidle_driver;

struct cpuidle_state {
	char name[16];
	char desc[32];
	s64 exit_latency_ns;
	s64 target_residency_ns;
	unsigned int flags;
	unsigned int exit_latency;
	int power_usage;
	unsigned int target_residency;
	int (*enter)(struct cpuidle_device *, struct cpuidle_driver *, int);
	void (*enter_dead)(struct cpuidle_device *, int);
	int (*enter_s2idle)(struct cpuidle_device *, struct cpuidle_driver *, int);
};

struct cpuidle_driver {
	const char *name;
	struct module *owner;
	unsigned int bctimer: 1;
	struct cpuidle_state states[10];
	int state_count;
	int safe_state_index;
	struct cpumask *cpumask;
	const char *governor;
};

struct cpuidle_governor {
	char name[16];
	struct list_head governor_list;
	unsigned int rating;
	int (*enable)(struct cpuidle_driver *, struct cpuidle_device *);
	void (*disable)(struct cpuidle_driver *, struct cpuidle_device *);
	int (*select)(struct cpuidle_driver *, struct cpuidle_device *, bool *);
	void (*reflect)(struct cpuidle_device *, int);
};

struct cpuidle_state_attr {
	struct attribute attr;
	ssize_t (*show)(struct cpuidle_state *, struct cpuidle_state_usage *, char *);
	ssize_t (*store)(struct cpuidle_state *, struct cpuidle_state_usage *, const char *, size_t);
};

struct cpuidle_state_kobj {
	struct cpuidle_state *state;
	struct cpuidle_state_usage *state_usage;
	struct completion kobj_unregister;
	struct kobject kobj;
	struct cpuidle_device *device;
};

struct cpuinfo_topology {
	u32 apicid;
	u32 initial_apicid;
	u32 pkg_id;
	u32 die_id;
	u32 cu_id;
	u32 core_id;
	u32 logical_pkg_id;
	u32 logical_die_id;
	u32 logical_core_id;
	u32 amd_node_id;
	u32 llc_id;
	u32 l2c_id;
	union {
		u32 cpu_type;
		struct {
			u32 intel_native_model_id: 24;
			u32 intel_type: 8;
		};
		struct {
			u32 amd_num_processors: 16;
			u32 amd_power_eff_ranking: 8;
			u32 amd_native_model_id: 4;
			u32 amd_type: 4;
		};
	};
};

struct cpuinfo_x86 {
	union {
		struct {
			__u8 x86_model;
			__u8 x86;
			__u8 x86_vendor;
			__u8 x86_reserved;
		};
		__u32 x86_vfm;
	};
	__u8 x86_stepping;
	int x86_tlbsize;
	__u32 vmx_capability[5];
	__u8 x86_virt_bits;
	__u8 x86_phys_bits;
	__u32 extended_cpuid_level;
	int cpuid_level;
	union {
		__u32 x86_capability[24];
		long unsigned int x86_capability_alignment;
	};
	char x86_vendor_id[16];
	char x86_model_id[64];
	struct cpuinfo_topology topo;
	unsigned int x86_cache_size;
	int x86_cache_alignment;
	int x86_cache_max_rmid;
	int x86_cache_occ_scale;
	int x86_cache_mbm_width_offset;
	int x86_power;
	long unsigned int loops_per_jiffy;
	u64 ppin;
	u16 x86_clflush_size;
	u16 booted_cores;
	u16 cpu_index;
	bool smt_active;
	u32 microcode;
	u8 x86_cache_bits;
	unsigned int initialized: 1;
};

struct cpumap {
	unsigned int available;
	unsigned int allocated;
	unsigned int managed;
	unsigned int managed_allocated;
	bool initialized;
	bool online;
	long unsigned int *managed_map;
	long unsigned int alloc_map[0];
};

union cpumask_rcuhead {
	cpumask_t cpumask;
	struct callback_head rcu;
};

struct cpupri_vec {
	atomic_t count;
	cpumask_var_t mask;
};

struct cpupri {
	struct cpupri_vec pri_to_cpu[101];
	int *cpu_to_pri;
};

struct fmeter {
	int cnt;
	int val;
	time64_t time;
	spinlock_t lock;
};

struct uf_node {
	struct uf_node *parent;
	unsigned int rank;
};

struct cpuset {
	struct cgroup_subsys_state css;
	long unsigned int flags;
	cpumask_var_t cpus_allowed;
	nodemask_t mems_allowed;
	cpumask_var_t effective_cpus;
	nodemask_t effective_mems;
	cpumask_var_t effective_xcpus;
	cpumask_var_t exclusive_cpus;
	nodemask_t old_mems_allowed;
	struct fmeter fmeter;
	int attach_in_progress;
	int relax_domain_level;
	int nr_subparts;
	int partition_root_state;
	int nr_deadline_tasks;
	int nr_migrate_dl_tasks;
	u64 sum_migrate_dl_bw;
	enum prs_errcode prs_err;
	struct cgroup_file partition_file;
	struct list_head remote_sibling;
	struct uf_node node;
};

struct cpuset_migrate_mm_work {
	struct work_struct work;
	struct mm_struct *mm;
	nodemask_t from;
	nodemask_t to;
};

struct range {
	u64 start;
	u64 end;
};

struct crash_mem {
	unsigned int max_nr_ranges;
	unsigned int nr_ranges;
	struct range ranges[0];
};

struct crc_data {
	struct task_struct *thr;
	atomic_t ready;
	atomic_t stop;
	unsigned int run_threads;
	wait_queue_head_t go;
	wait_queue_head_t done;
	u32 *crc32;
	size_t *unc_len[3];
	unsigned char *unc[3];
};

struct drm_i915_private;

struct intel_memory_region;

struct create_ext {
	struct drm_i915_private *i915;
	struct intel_memory_region *placements[7];
	unsigned int n_placements;
	unsigned int placement_mask;
	long unsigned int flags;
	unsigned int pat_index;
};

struct i915_gem_proto_context;

struct drm_i915_file_private;

struct create_ext___2 {
	struct i915_gem_proto_context *pc;
	struct drm_i915_file_private *fpriv;
};

struct group_info;

struct cred {
	atomic_long_t usage;
	kuid_t uid;
	kgid_t gid;
	kuid_t suid;
	kgid_t sgid;
	kuid_t euid;
	kgid_t egid;
	kuid_t fsuid;
	kgid_t fsgid;
	unsigned int securebits;
	kernel_cap_t cap_inheritable;
	kernel_cap_t cap_permitted;
	kernel_cap_t cap_effective;
	kernel_cap_t cap_bset;
	kernel_cap_t cap_ambient;
	unsigned char jit_keyring;
	struct key *session_keyring;
	struct key *process_keyring;
	struct key *thread_keyring;
	struct key *request_key_auth;
	void *security;
	struct user_struct *user;
	struct user_namespace *user_ns;
	struct ucounts *ucounts;
	struct group_info *group_info;
	union {
		int non_rcu;
		struct callback_head rcu;
	};
};

struct crng {
	u8 key[32];
	long unsigned int generation;
	local_lock_t lock;
};

struct crs_csi2 {
	struct list_head entry;
	acpi_handle handle;
	struct acpi_device_software_nodes *swnodes;
	struct list_head connections;
	u32 port_count;
};

struct crs_csi2_connection {
	struct list_head entry;
	struct acpi_resource_csi2_serialbus csi2_data;
	acpi_handle remote_handle;
	char remote_name[0];
};

struct crypto_tfm {
	refcount_t refcnt;
	u32 crt_flags;
	int node;
	void (*exit)(struct crypto_tfm *);
	struct crypto_alg *__crt_alg;
	void *__crt_ctx[0];
};

struct crypto_acomp {
	int (*compress)(struct acomp_req *);
	int (*decompress)(struct acomp_req *);
	void (*dst_free)(struct scatterlist *);
	unsigned int reqsize;
	struct crypto_tfm base;
};

struct crypto_aead {
	unsigned int authsize;
	unsigned int reqsize;
	struct crypto_tfm base;
};

struct crypto_aead_spawn {
	struct crypto_spawn base;
};

struct crypto_aes_ctx {
	u32 key_enc[60];
	u32 key_dec[60];
	u32 key_length;
};

struct crypto_ahash {
	bool using_shash;
	unsigned int statesize;
	unsigned int reqsize;
	struct crypto_tfm base;
};

struct crypto_akcipher {
	unsigned int reqsize;
	struct crypto_tfm base;
};

struct crypto_akcipher_spawn {
	struct crypto_spawn base;
};

struct crypto_wait {
	struct completion completion;
	int err;
};

struct crypto_akcipher_sync_data {
	struct crypto_akcipher *tfm;
	const void *src;
	void *dst;
	unsigned int slen;
	unsigned int dlen;
	struct akcipher_request *req;
	struct crypto_wait cwait;
	struct scatterlist sg;
	u8 *buf;
};

struct crypto_attr_alg {
	char name[128];
};

struct crypto_attr_type {
	u32 type;
	u32 mask;
};

struct crypto_skcipher;

struct crypto_authenc_ctx {
	struct crypto_ahash *auth;
	struct crypto_skcipher *enc;
	struct crypto_sync_skcipher *null;
};

struct crypto_authenc_esn_ctx {
	unsigned int reqoff;
	struct crypto_ahash *auth;
	struct crypto_skcipher *enc;
	struct crypto_sync_skcipher *null;
};

struct crypto_authenc_key_param {
	__be32 enckeylen;
};

struct crypto_authenc_keys {
	const u8 *authkey;
	const u8 *enckey;
	unsigned int authkeylen;
	unsigned int enckeylen;
};

struct crypto_ccm_ctx {
	struct crypto_ahash *mac;
	struct crypto_skcipher *ctr;
};

struct skcipher_request {
	unsigned int cryptlen;
	u8 *iv;
	struct scatterlist *src;
	struct scatterlist *dst;
	struct crypto_async_request base;
	void *__ctx[0];
};

struct crypto_ccm_req_priv_ctx {
	u8 odata[16];
	u8 idata[16];
	u8 auth_tag[16];
	u32 flags;
	struct scatterlist src[3];
	struct scatterlist dst[3];
	union {
		struct ahash_request ahreq;
		struct skcipher_request skreq;
	};
};

struct crypto_cipher {
	struct crypto_tfm base;
};

struct crypto_cipher_spawn {
	struct crypto_spawn base;
};

struct crypto_comp {
	struct crypto_tfm base;
};

struct crypto_gcm_ctx {
	struct crypto_skcipher *ctr;
	struct crypto_ahash *ghash;
};

struct crypto_gcm_ghash_ctx {
	unsigned int cryptlen;
	struct scatterlist *src;
	int (*complete)(struct aead_request *, u32);
};

struct crypto_gcm_req_priv_ctx {
	u8 iv[16];
	u8 auth_tag[16];
	u8 iauth_tag[16];
	struct scatterlist src[3];
	struct scatterlist dst[3];
	struct scatterlist sg;
	struct crypto_gcm_ghash_ctx ghash_ctx;
	union {
		struct ahash_request ahreq;
		struct skcipher_request skreq;
	} u;
};

struct crypto_hash_walk {
	char *data;
	unsigned int offset;
	unsigned int flags;
	struct page *pg;
	unsigned int entrylen;
	unsigned int total;
	struct scatterlist *sg;
};

struct crypto_kpp {
	unsigned int reqsize;
	struct crypto_tfm base;
};

struct crypto_kpp_spawn {
	struct crypto_spawn base;
};

struct crypto_larval {
	struct crypto_alg alg;
	struct crypto_alg *adult;
	struct completion completion;
	u32 mask;
	bool test_started;
};

struct crypto_lskcipher {
	struct crypto_tfm base;
};

struct crypto_lskcipher_spawn {
	struct crypto_spawn base;
};

struct crypto_queue {
	struct list_head list;
	struct list_head *backlog;
	unsigned int qlen;
	unsigned int max_qlen;
};

struct crypto_rfc3686_ctx {
	struct crypto_skcipher *child;
	u8 nonce[4];
};

struct crypto_rfc3686_req_ctx {
	u8 iv[16];
	struct skcipher_request subreq;
};

struct crypto_rfc4106_ctx {
	struct crypto_aead *child;
	u8 nonce[4];
};

struct crypto_rfc4106_req_ctx {
	struct scatterlist src[3];
	struct scatterlist dst[3];
	struct aead_request subreq;
};

struct crypto_rfc4309_ctx {
	struct crypto_aead *child;
	u8 nonce[3];
};

struct crypto_rfc4309_req_ctx {
	struct scatterlist src[3];
	struct scatterlist dst[3];
	struct aead_request subreq;
};

struct crypto_rfc4543_ctx {
	struct crypto_aead *child;
	struct crypto_sync_skcipher *null;
	u8 nonce[4];
};

struct crypto_rfc4543_instance_ctx {
	struct crypto_aead_spawn aead;
};

struct crypto_rfc4543_req_ctx {
	struct aead_request subreq;
};

struct crypto_rng {
	struct crypto_tfm base;
};

struct crypto_scomp {
	struct crypto_tfm base;
};

struct crypto_shash {
	unsigned int descsize;
	struct crypto_tfm base;
};

struct crypto_shash_spawn {
	struct crypto_spawn base;
};

struct crypto_sig {
	struct crypto_tfm base;
};

struct crypto_sig_spawn {
	struct crypto_spawn base;
};

struct crypto_skcipher {
	unsigned int reqsize;
	struct crypto_tfm base;
};

struct crypto_sync_skcipher {
	struct crypto_skcipher base;
};

struct rtattr;

struct crypto_template {
	struct list_head list;
	struct hlist_head instances;
	struct module *module;
	int (*create)(struct crypto_template *, struct rtattr **);
	char name[128];
};

struct crypto_test_param {
	char driver[128];
	char alg[128];
	u32 type;
};

struct crypto_type {
	unsigned int (*ctxsize)(struct crypto_alg *, u32, u32);
	unsigned int (*extsize)(struct crypto_alg *);
	int (*init_tfm)(struct crypto_tfm *);
	void (*show)(struct seq_file *, struct crypto_alg *);
	int (*report)(struct sk_buff *, struct crypto_alg *);
	void (*free)(struct crypto_instance *);
	unsigned int type;
	unsigned int maskclear;
	unsigned int maskset;
	unsigned int tfmsize;
};

struct rtattr {
	short unsigned int rta_len;
	short unsigned int rta_type;
};

struct cryptomgr_param {
	struct rtattr *tb[34];
	struct {
		struct rtattr attr;
		struct crypto_attr_type data;
	} type;
	struct {
		struct rtattr attr;
		struct crypto_attr_alg data;
	} attrs[32];
	char template[128];
	struct crypto_larval *larval;
	u32 otype;
	u32 omask;
};

struct csi2_resources_walk_data {
	acpi_handle handle;
	struct list_head connections;
};

struct csr {
	struct {
		u8 status;
		u8 stat_ack;
		u8 cmd_lo;
		u8 cmd_hi;
		u32 gen_ptr;
	} scb;
	u32 port;
	u16 flash_ctrl;
	u8 eeprom_ctrl_lo;
	u8 eeprom_ctrl_hi;
	u32 mdi_ctrl;
	u32 rx_dma_count;
};

struct css_set {
	struct cgroup_subsys_state *subsys[14];
	refcount_t refcount;
	struct css_set *dom_cset;
	struct cgroup *dfl_cgrp;
	int nr_tasks;
	struct list_head tasks;
	struct list_head mg_tasks;
	struct list_head dying_tasks;
	struct list_head task_iters;
	struct list_head e_cset_node[14];
	struct list_head threaded_csets;
	struct list_head threaded_csets_node;
	struct hlist_node hlist;
	struct list_head cgrp_links;
	struct list_head mg_src_preload_node;
	struct list_head mg_dst_preload_node;
	struct list_head mg_node;
	struct cgroup *mg_src_cgrp;
	struct cgroup *mg_dst_cgrp;
	struct css_set *mg_dst_cset;
	bool dead;
	struct callback_head callback_head;
};

struct css_set__safe_rcu {
	struct cgroup *dfl_cgrp;
};

struct cstate {
	int state;
	uint32_t rep0;
	uint32_t rep1;
	uint32_t rep2;
	uint32_t rep3;
};

struct cstate_entry {
	struct {
		unsigned int eax;
		unsigned int ecx;
	} states[8];
};

struct cstate_model {
	long unsigned int core_events;
	long unsigned int pkg_events;
	long unsigned int module_events;
	long unsigned int quirks;
};

struct csum_state {
	__wsum csum;
	size_t off;
};

struct ct_data_s {
	union {
		ush freq;
		ush code;
	} fc;
	union {
		ush dad;
		ush len;
	} dl;
};

typedef struct ct_data_s ct_data;

struct ct_incoming_msg {
	struct list_head link;
	u32 size;
	u32 msg[0];
};

struct ct_request {
	struct list_head link;
	u32 fence;
	u32 status;
	u32 response_len;
	u32 *response_buf;
};

struct ctl_table;

struct ctl_table_root;

struct ctl_table_set;

struct ctl_dir;

struct ctl_node;

struct ctl_table_header {
	union {
		struct {
			const struct ctl_table *ctl_table;
			int ctl_table_size;
			int used;
			int count;
			int nreg;
		};
		struct callback_head rcu;
	};
	struct completion *unregistering;
	const struct ctl_table *ctl_table_arg;
	struct ctl_table_root *root;
	struct ctl_table_set *set;
	struct ctl_dir *parent;
	struct ctl_node *node;
	struct hlist_head inodes;
	enum {
		SYSCTL_TABLE_TYPE_DEFAULT = 0,
		SYSCTL_TABLE_TYPE_PERMANENTLY_EMPTY = 1,
	} type;
};

struct ctl_dir {
	struct ctl_table_header header;
	struct rb_root root;
};

struct ctl_node {
	struct rb_node node;
	struct ctl_table_header *header;
};

typedef int proc_handler(const struct ctl_table *, int, void *, size_t *, loff_t *);

struct ctl_table_poll;

struct ctl_table {
	const char *procname;
	void *data;
	int maxlen;
	umode_t mode;
	proc_handler *proc_handler;
	struct ctl_table_poll *poll;
	void *extra1;
	void *extra2;
};

struct ctl_table_poll {
	atomic_t event;
	wait_queue_head_t wait;
};

struct ctl_table_set {
	int (*is_seen)(struct ctl_table_set *);
	struct ctl_dir dir;
};

struct ctl_table_root {
	struct ctl_table_set default_set;
	struct ctl_table_set * (*lookup)(struct ctl_table_root *);
	void (*set_ownership)(struct ctl_table_header *, kuid_t *, kgid_t *);
	int (*permissions)(struct ctl_table_header *, const struct ctl_table *);
};

union nf_inet_addr {
	__u32 all[4];
	__be32 ip;
	__be32 ip6[4];
	struct in_addr in;
	struct in6_addr in6;
};

union nf_conntrack_man_proto {
	__be16 all;
	struct {
		__be16 port;
	} tcp;
	struct {
		__be16 port;
	} udp;
	struct {
		__be16 id;
	} icmp;
	struct {
		__be16 port;
	} dccp;
	struct {
		__be16 port;
	} sctp;
	struct {
		__be16 key;
	} gre;
};

struct nf_conntrack_man {
	union nf_inet_addr u3;
	union nf_conntrack_man_proto u;
	u_int16_t l3num;
};

struct nf_conntrack_tuple {
	struct nf_conntrack_man src;
	struct {
		union nf_inet_addr u3;
		union {
			__be16 all;
			struct {
				__be16 port;
			} tcp;
			struct {
				__be16 port;
			} udp;
			struct {
				u_int8_t type;
				u_int8_t code;
			} icmp;
			struct {
				__be16 port;
			} dccp;
			struct {
				__be16 port;
			} sctp;
			struct {
				__be16 key;
			} gre;
		} u;
		u_int8_t protonum;
		struct {} __nfct_hash_offsetend;
		u_int8_t dir;
	} dst;
};

struct nf_conntrack_zone {
	u16 id;
	u8 flags;
	u8 dir;
};

struct ctnetlink_filter_u32 {
	u32 val;
	u32 mask;
};

struct ctnetlink_filter {
	u8 family;
	bool zone_filter;
	u_int32_t orig_flags;
	u_int32_t reply_flags;
	struct nf_conntrack_tuple orig;
	struct nf_conntrack_tuple reply;
	struct nf_conntrack_zone zone;
	struct ctnetlink_filter_u32 mark;
	struct ctnetlink_filter_u32 status;
};

struct nf_conn;

struct ctnetlink_list_dump_ctx {
	struct nf_conn *last;
	unsigned int cpu;
	bool done;
};

struct netlink_policy_dump_state;

struct genl_family;

struct genl_op_iter;

struct ctrl_dump_policy_ctx {
	struct netlink_policy_dump_state *state;
	const struct genl_family *rt;
	struct genl_op_iter *op_iter;
	u32 op;
	u16 fam_id;
	u8 dump_map: 1;
	u8 single_op: 1;
};

struct ctx_rq_wait {
	struct completion comp;
	atomic_t count;
};

struct ctx_switch_entry {
	struct trace_entry ent;
	unsigned int prev_pid;
	unsigned int next_pid;
	unsigned int next_cpu;
	unsigned char prev_prio;
	unsigned char prev_state;
	unsigned char next_prio;
	unsigned char next_state;
};

struct cvt_timing {
	u8 code[3];
};

struct cxsr_latency {
	bool is_desktop: 1;
	bool is_ddr3: 1;
	u16 fsb_freq;
	u16 mem_freq;
	u16 display_sr;
	u16 display_hpll_disable;
	u16 cursor_sr;
	u16 cursor_hpll_disable;
};

struct cyc2ns_data {
	u32 cyc2ns_mul;
	u32 cyc2ns_shift;
	u64 cyc2ns_offset;
};

struct cyc2ns {
	struct cyc2ns_data data[2];
	seqcount_latch_t seq;
};

struct cytp_contact {
	int x;
	int y;
	int z;
};

struct cytp_data {
	int fw_version;
	int pkt_size;
	int mode;
	int tp_min_pressure;
	int tp_max_pressure;
	int tp_width;
	int tp_high;
	int tp_max_abs_x;
	int tp_max_abs_y;
	int tp_res_x;
	int tp_res_y;
	int tp_metrics_supported;
};

struct cytp_report_data {
	int contact_cnt;
	struct cytp_contact contacts[2];
	unsigned int left: 1;
	unsigned int right: 1;
	unsigned int middle: 1;
	unsigned int tap: 1;
};

struct data_chunk {
	size_t size;
	size_t icg;
	size_t dst_icg;
	size_t src_icg;
};

struct dax_device;

struct dax_holder_operations {
	int (*notify_failure)(struct dax_device *, u64, u64, int);
};

struct dax_operations {
	long int (*direct_access)(struct dax_device *, long unsigned int, long int, enum dax_access_mode, void **, pfn_t *);
	int (*zero_page_range)(struct dax_device *, long unsigned int, size_t);
	size_t (*recovery_write)(struct dax_device *, long unsigned int, void *, size_t, struct iov_iter *);
};

struct xhci_dbc;

struct dbc_driver {
	int (*configure)(struct xhci_dbc *);
	void (*disconnect)(struct xhci_dbc *);
};

struct xhci_ring;

struct dbc_ep {
	struct xhci_dbc *dbc;
	struct list_head list_pending;
	struct xhci_ring *ring;
	unsigned int direction: 1;
	unsigned int halted: 1;
};

struct dbc_regs {
	__le32 capability;
	__le32 doorbell;
	__le32 ersts;
	__le32 __reserved_0;
	__le64 erstba;
	__le64 erdp;
	__le32 control;
	__le32 status;
	__le32 portsc;
	__le32 __reserved_1;
	__le64 dccp;
	__le32 devinfo1;
	__le32 devinfo2;
};

union xhci_trb;

struct dbc_request {
	void *buf;
	unsigned int length;
	dma_addr_t dma;
	void (*complete)(struct xhci_dbc *, struct dbc_request *);
	struct list_head list_pool;
	int status;
	unsigned int actual;
	struct xhci_dbc *dbc;
	struct list_head list_pending;
	dma_addr_t trb_dma;
	union xhci_trb *trb;
	unsigned int direction: 1;
};

struct dbc_str_descs {
	char string0[64];
	char manufacturer[64];
	char product[64];
	char serial[64];
};

struct gov_attr_set {
	struct kobject kobj;
	struct list_head policy_list;
	struct mutex update_lock;
	int usage_count;
};

struct dbs_governor;

struct dbs_data {
	struct gov_attr_set attr_set;
	struct dbs_governor *gov;
	void *tuners;
	unsigned int ignore_nice_load;
	unsigned int sampling_rate;
	unsigned int sampling_down_factor;
	unsigned int up_threshold;
	unsigned int io_is_busy;
};

struct sysfs_ops;

struct kobj_type {
	void (*release)(struct kobject *);
	const struct sysfs_ops *sysfs_ops;
	const struct attribute_group **default_groups;
	const struct kobj_ns_type_operations * (*child_ns_type)(const struct kobject *);
	const void * (*namespace)(const struct kobject *);
	void (*get_ownership)(const struct kobject *, kuid_t *, kgid_t *);
};

struct dbs_governor {
	struct cpufreq_governor gov;
	struct kobj_type kobj_type;
	struct dbs_data *gdbs_data;
	unsigned int (*gov_dbs_update)(struct cpufreq_policy *);
	struct policy_dbs_info * (*alloc)(void);
	void (*free)(struct policy_dbs_info *);
	int (*init)(struct dbs_data *);
	void (*exit)(struct dbs_data *);
	void (*start)(struct cpufreq_policy *);
};

struct dbuf_slice_conf_entry {
	u8 active_pipes;
	u8 dbuf_mask[4];
	bool join_mbus;
};

struct dccp_hdr {
	__be16 dccph_sport;
	__be16 dccph_dport;
	__u8 dccph_doff;
	__u8 dccph_cscov: 4;
	__u8 dccph_ccval: 4;
	__sum16 dccph_checksum;
	__u8 dccph_x: 1;
	__u8 dccph_type: 4;
	__u8 dccph_reserved: 3;
	__u8 dccph_seq2;
	__be16 dccph_seq;
};

struct io_stats_per_prio {
	uint32_t inserted;
	uint32_t merged;
	uint32_t dispatched;
	atomic_t completed;
};

struct dd_per_prio {
	struct list_head dispatch;
	struct rb_root sort_list[2];
	struct list_head fifo_list[2];
	sector_t latest_pos[2];
	struct io_stats_per_prio stats;
};

struct ddebug_class_map {
	struct list_head link;
	struct module *mod;
	const char *mod_name;
	const char **class_names;
	const int length;
	const int base;
	enum class_map_type map_type;
};

struct deadline_data {
	struct dd_per_prio per_prio[3];
	enum dd_data_dir last_dir;
	unsigned int batching;
	unsigned int starved;
	int fifo_expire[2];
	int fifo_batch;
	int writes_starved;
	int front_merges;
	u32 async_depth;
	int prio_aging_expire;
	spinlock_t lock;
};

struct ohci_hcd;

struct debug_buffer {
	ssize_t (*fill_func)(struct debug_buffer *);
	struct ohci_hcd *ohci;
	struct mutex mutex;
	size_t count;
	char *page;
};

struct debug_reply_data {
	struct ethnl_reply_data base;
	u32 msg_mask;
};

struct debugfs_blob_wrapper {
	void *data;
	long unsigned int size;
};

struct debugfs_cancellation {
	struct list_head list;
	void (*cancel)(struct dentry *, void *);
	void *cancel_data;
};

struct debugfs_devm_entry {
	int (*read)(struct seq_file *, void *);
	struct device *dev;
};

struct debugfs_fs_info {
	kuid_t uid;
	kgid_t gid;
	umode_t mode;
	unsigned int opts;
};

struct debugfs_short_fops;

struct debugfs_fsdata {
	const struct file_operations *real_fops;
	const struct debugfs_short_fops *short_fops;
	struct {
		refcount_t active_users;
		struct completion active_users_drained;
		struct mutex cancellations_mtx;
		struct list_head cancellations;
		unsigned int methods;
	};
};

typedef struct vfsmount * (*debugfs_automount_t)(struct dentry *, void *);

struct debugfs_inode_info {
	struct inode vfs_inode;
	union {
		const void *raw;
		const struct file_operations *real_fops;
		const struct debugfs_short_fops *short_fops;
		debugfs_automount_t automount;
	};
	const void *aux;
};

struct debugfs_reg32 {
	char *name;
	long unsigned int offset;
};

struct debugfs_regset32 {
	const struct debugfs_reg32 *regs;
	int nregs;
	void *base;
	struct device *dev;
};

struct debugfs_short_fops {
	ssize_t (*read)(struct file *, char *, size_t, loff_t *);
	ssize_t (*write)(struct file *, const char *, size_t, loff_t *);
	loff_t (*llseek)(struct file *, loff_t, int);
};

struct debugfs_u32_array {
	u32 *array;
	u32 n_elements;
};

struct dec_data {
	struct task_struct *thr;
	struct crypto_comp *cc;
	atomic_t ready;
	atomic_t stop;
	int ret;
	wait_queue_head_t go;
	wait_queue_head_t done;
	size_t unc_len;
	size_t cmp_len;
	unsigned char unc[131072];
	unsigned char cmp[143360];
};

struct decryptor_desc {
	u8 iv[16];
	struct skcipher_request *req;
	struct scatterlist frags[4];
	int fragno;
	int fraglen;
};

struct default_wait_cb {
	struct dma_fence_cb base;
	struct task_struct *task;
};

struct z_stream_s;

typedef struct z_stream_s z_stream;

typedef z_stream *z_streamp;

struct static_tree_desc_s;

typedef struct static_tree_desc_s static_tree_desc;

struct tree_desc_s {
	ct_data *dyn_tree;
	int max_code;
	static_tree_desc *stat_desc;
};

struct deflate_state {
	z_streamp strm;
	int status;
	Byte *pending_buf;
	ulg pending_buf_size;
	Byte *pending_out;
	int pending;
	int noheader;
	Byte data_type;
	Byte method;
	int last_flush;
	uInt w_size;
	uInt w_bits;
	uInt w_mask;
	Byte *window;
	ulg window_size;
	Pos *prev;
	Pos *head;
	uInt ins_h;
	uInt hash_size;
	uInt hash_bits;
	uInt hash_mask;
	uInt hash_shift;
	long int block_start;
	uInt match_length;
	IPos prev_match;
	int match_available;
	uInt strstart;
	uInt match_start;
	uInt lookahead;
	uInt prev_length;
	uInt max_chain_length;
	uInt max_lazy_match;
	int level;
	int strategy;
	uInt good_match;
	int nice_match;
	struct ct_data_s dyn_ltree[573];
	struct ct_data_s dyn_dtree[61];
	struct ct_data_s bl_tree[39];
	struct tree_desc_s l_desc;
	struct tree_desc_s d_desc;
	struct tree_desc_s bl_desc;
	ush bl_count[16];
	int heap[573];
	int heap_len;
	int heap_max;
	uch depth[573];
	uch *l_buf;
	uInt lit_bufsize;
	uInt last_lit;
	ush *d_buf;
	ulg opt_len;
	ulg static_len;
	ulg compressed_len;
	uInt matches;
	int last_eob_len;
	ush bi_buf;
	int bi_valid;
};

struct deflate_workspace {
	deflate_state deflate_memory;
	Byte *window_memory;
	Pos *prev_memory;
	Pos *head_memory;
	char *overlay_memory;
};

typedef struct deflate_workspace deflate_workspace;

struct delayed_call {
	void (*fn)(void *);
	void *arg;
};

struct delayed_uprobe {
	struct list_head list;
	struct uprobe *uprobe;
	struct mm_struct *mm;
};

struct demotion_nodes {
	nodemask_t preferred;
};

struct hlist_bl_node {
	struct hlist_bl_node *next;
	struct hlist_bl_node **pprev;
};

union shortname_store {
	unsigned char string[40];
	long unsigned int words[5];
};

struct lockref {
	union {
		__u64 lock_count;
		struct {
			spinlock_t lock;
			int count;
		};
	};
};

struct dentry_operations;

struct dentry {
	unsigned int d_flags;
	seqcount_spinlock_t d_seq;
	struct hlist_bl_node d_hash;
	struct dentry *d_parent;
	struct qstr d_name;
	struct inode *d_inode;
	union shortname_store d_shortname;
	const struct dentry_operations *d_op;
	struct super_block *d_sb;
	long unsigned int d_time;
	void *d_fsdata;
	struct lockref d_lockref;
	union {
		struct list_head d_lru;
		wait_queue_head_t *d_wait;
	};
	struct hlist_node d_sib;
	struct hlist_head d_children;
	union {
		struct hlist_node d_alias;
		struct hlist_bl_node d_in_lookup_hash;
		struct callback_head d_rcu;
	} d_u;
};

struct dentry__safe_trusted {
	struct inode *d_inode;
};

struct dentry_info_args {
	int parent_ino;
	int dname_len;
	int ino;
	int inode_len;
	char *dname;
};

struct dentry_operations {
	int (*d_revalidate)(struct inode *, const struct qstr *, struct dentry *, unsigned int);
	int (*d_weak_revalidate)(struct dentry *, unsigned int);
	int (*d_hash)(const struct dentry *, struct qstr *);
	int (*d_compare)(const struct dentry *, unsigned int, const char *, const struct qstr *);
	int (*d_delete)(const struct dentry *);
	int (*d_init)(struct dentry *);
	void (*d_release)(struct dentry *);
	void (*d_prune)(struct dentry *);
	void (*d_iput)(struct dentry *, struct inode *);
	char * (*d_dname)(struct dentry *, char *, int);
	struct vfsmount * (*d_automount)(struct path *);
	int (*d_manage)(const struct path *, bool);
	struct dentry * (*d_real)(struct dentry *, enum d_real_type);
	bool (*d_unalias_trylock)(const struct dentry *);
	void (*d_unalias_unlock)(const struct dentry *);
	long: 64;
};

struct dentry_stat_t {
	long int nr_dentry;
	long int nr_unused;
	long int age_limit;
	long int want_pages;
	long int nr_negative;
	long int dummy;
};

struct desc_ptr {
	short unsigned int size;
	long unsigned int address;
} __attribute__((packed));

struct desc_struct {
	u16 limit0;
	u16 base0;
	u16 base1: 8;
	u16 type: 4;
	u16 s: 1;
	u16 dpl: 2;
	u16 p: 1;
	u16 limit1: 4;
	u16 avl: 1;
	u16 l: 1;
	u16 d: 1;
	u16 g: 1;
	u16 base2: 8;
};

struct slab;

struct detached_freelist {
	struct slab *slab;
	void *tail;
	void *freelist;
	int cnt;
	struct kmem_cache *s;
};

struct detailed_data_monitor_range {
	u8 min_vfreq;
	u8 max_vfreq;
	u8 min_hfreq_khz;
	u8 max_hfreq_khz;
	u8 pixel_clock_mhz;
	u8 flags;
	union {
		struct {
			u8 reserved;
			u8 hfreq_start_khz;
			u8 c;
			__le16 m;
			u8 k;
			u8 j;
		} __attribute__((packed)) gtf2;
		struct {
			u8 version;
			u8 data1;
			u8 data2;
			u8 supported_aspects;
			u8 flags;
			u8 supported_scalings;
			u8 preferred_refresh;
		} cvt;
	} formula;
};

struct detailed_data_string {
	u8 str[13];
};

struct detailed_data_wpindex {
	u8 white_yx_lo;
	u8 white_x_hi;
	u8 white_y_hi;
	u8 gamma;
};

struct detailed_mode_closure {
	struct drm_connector *connector;
	const struct drm_edid *drm_edid;
	bool preferred;
	int modes;
};

struct std_timing {
	u8 hsize;
	u8 vfreq_aspect;
};

struct detailed_non_pixel {
	u8 pad1;
	u8 type;
	u8 pad2;
	union {
		struct detailed_data_string str;
		struct detailed_data_monitor_range range;
		struct detailed_data_wpindex color;
		struct std_timing timings[6];
		struct cvt_timing cvt[4];
	} data;
};

struct detailed_pixel_timing {
	u8 hactive_lo;
	u8 hblank_lo;
	u8 hactive_hblank_hi;
	u8 vactive_lo;
	u8 vblank_lo;
	u8 vactive_vblank_hi;
	u8 hsync_offset_lo;
	u8 hsync_pulse_width_lo;
	u8 vsync_offset_pulse_width_lo;
	u8 hsync_vsync_offset_pulse_width_hi;
	u8 width_mm_lo;
	u8 height_mm_lo;
	u8 width_height_mm_hi;
	u8 hborder;
	u8 vborder;
	u8 misc;
};

struct detailed_timing {
	__le16 pixel_clock;
	union {
		struct detailed_pixel_timing pixel_data;
		struct detailed_non_pixel other_data;
	} data;
};

struct detected_devices_node {
	struct list_head list;
	dev_t dev;
};

struct dev_cgroup {
	struct cgroup_subsys_state css;
	struct list_head exceptions;
	enum devcg_behavior behavior;
};

struct dev_exception_item {
	u32 major;
	u32 minor;
	short int type;
	short int access;
	struct list_head list;
	struct callback_head rcu;
};

struct dev_ext_attribute {
	struct device_attribute attr;
	void *var;
};

struct dev_ifalias {
	struct callback_head rcuhead;
	char ifalias[0];
};

struct iommu_fault_param;

struct iommu_fwspec;

struct dev_iommu {
	struct mutex lock;
	struct iommu_fault_param *fault_param;
	struct iommu_fwspec *fwspec;
	struct iommu_device *iommu_dev;
	void *priv;
	u32 max_pasids;
	u32 attach_deferred: 1;
	u32 pci_32bit_workaround: 1;
	u32 require_direct: 1;
	u32 shadow_on_flush: 1;
};

struct dev_kfree_skb_cb {
	enum skb_drop_reason reason;
};

struct vmem_altmap {
	long unsigned int base_pfn;
	const long unsigned int end_pfn;
	const long unsigned int reserve;
	long unsigned int free;
	long unsigned int align;
	long unsigned int alloc;
	bool inaccessible;
};

struct dev_pagemap_ops;

struct dev_pagemap {
	struct vmem_altmap altmap;
	struct percpu_ref ref;
	struct completion done;
	enum memory_type type;
	unsigned int flags;
	long unsigned int vmemmap_shift;
	const struct dev_pagemap_ops *ops;
	void *owner;
	int nr_range;
	union {
		struct range range;
		struct {
			struct {} __empty_ranges;
			struct range ranges[0];
		};
	};
};

struct vm_fault;

struct dev_pagemap_ops {
	void (*page_free)(struct page *);
	vm_fault_t (*migrate_to_ram)(struct vm_fault *);
	int (*memory_failure)(struct dev_pagemap *, long unsigned int, long unsigned int, int);
};

struct dev_pasid_info {
	struct list_head link_domain;
	struct device *dev;
	ioasid_t pasid;
};

struct dev_pm_ops {
	int (*prepare)(struct device *);
	void (*complete)(struct device *);
	int (*suspend)(struct device *);
	int (*resume)(struct device *);
	int (*freeze)(struct device *);
	int (*thaw)(struct device *);
	int (*poweroff)(struct device *);
	int (*restore)(struct device *);
	int (*suspend_late)(struct device *);
	int (*resume_early)(struct device *);
	int (*freeze_late)(struct device *);
	int (*thaw_early)(struct device *);
	int (*poweroff_late)(struct device *);
	int (*restore_early)(struct device *);
	int (*suspend_noirq)(struct device *);
	int (*resume_noirq)(struct device *);
	int (*freeze_noirq)(struct device *);
	int (*thaw_noirq)(struct device *);
	int (*poweroff_noirq)(struct device *);
	int (*restore_noirq)(struct device *);
	int (*runtime_suspend)(struct device *);
	int (*runtime_resume)(struct device *);
	int (*runtime_idle)(struct device *);
};

struct dev_pm_domain {
	struct dev_pm_ops ops;
	int (*start)(struct device *);
	void (*detach)(struct device *, bool);
	int (*activate)(struct device *);
	void (*sync)(struct device *);
	void (*dismiss)(struct device *);
	int (*set_performance_state)(struct device *, unsigned int);
};

struct dev_pm_domain_attach_data {
	const char * const *pd_names;
	const u32 num_pd_names;
	const u32 pd_flags;
};

struct device_link;

struct dev_pm_domain_list {
	struct device **pd_devs;
	struct device_link **pd_links;
	u32 *opp_tokens;
	u32 num_pds;
};

struct opp_table;

struct dev_pm_opp;

typedef int (*config_clks_t)(struct device *, struct opp_table *, struct dev_pm_opp *, void *, bool);

typedef int (*config_regulators_t)(struct device *, struct dev_pm_opp *, struct dev_pm_opp *, struct regulator **, unsigned int);

struct dev_pm_opp_config {
	const char * const *clk_names;
	config_clks_t config_clks;
	const char *prop_name;
	config_regulators_t config_regulators;
	const unsigned int *supported_hw;
	unsigned int supported_hw_count;
	const char * const *regulator_names;
	struct device *required_dev;
	unsigned int required_dev_index;
};

struct pm_qos_flags {
	struct list_head list;
	s32 effective_flags;
};

struct dev_pm_qos_request;

struct dev_pm_qos {
	struct pm_qos_constraints resume_latency;
	struct pm_qos_constraints latency_tolerance;
	struct freq_constraints freq;
	struct pm_qos_flags flags;
	struct dev_pm_qos_request *resume_latency_req;
	struct dev_pm_qos_request *latency_tolerance_req;
	struct dev_pm_qos_request *flags_req;
};

struct pm_qos_flags_request {
	struct list_head node;
	s32 flags;
};

struct dev_pm_qos_request {
	enum dev_pm_qos_req_type type;
	union {
		struct plist_node pnode;
		struct pm_qos_flags_request flr;
		struct freq_qos_request freq;
	} data;
	struct device *dev;
};

struct dev_printk_info {
	char subsystem[16];
	char device[48];
};

struct dev_table_entry {
	union {
		u64 data[4];
		u128 data128[2];
	};
};

struct dev_type {
	u16 idVendor;
	u16 idProduct;
	const short int *ff;
};

struct device_attach_data {
	struct device *dev;
	bool check_async;
	bool want_async;
	bool have_async;
};

union device_attr_group_devres {
	const struct attribute_group *group;
	const struct attribute_group **groups;
};

struct device_dma_parameters {
	unsigned int max_segment_size;
	unsigned int min_align_mask;
	long unsigned int segment_boundary_mask;
};

struct dmar_domain;

struct pasid_table;

struct device_domain_info {
	struct list_head link;
	u32 segment;
	u8 bus;
	u8 devfn;
	u16 pfsid;
	u8 pasid_supported: 3;
	u8 pasid_enabled: 1;
	u8 pri_supported: 1;
	u8 pri_enabled: 1;
	u8 ats_supported: 1;
	u8 ats_enabled: 1;
	u8 dtlb_extra_inval: 1;
	u8 ats_qdep;
	struct device *dev;
	struct intel_iommu *iommu;
	struct dmar_domain *domain;
	struct pasid_table *pasid_table;
	struct rb_node node;
};

struct device_link {
	struct device *supplier;
	struct list_head s_node;
	struct device *consumer;
	struct list_head c_node;
	struct device link_dev;
	enum device_link_state status;
	u32 flags;
	refcount_t rpm_active;
	struct kref kref;
	struct work_struct rm_work;
	bool supplier_preactivated;
};

struct property;

struct device_node {
	const char *name;
	phandle phandle;
	const char *full_name;
	struct fwnode_handle fwnode;
	struct property *properties;
	struct property *deadprops;
	struct device_node *parent;
	struct device_node *child;
	struct device_node *sibling;
	long unsigned int _flags;
	void *data;
};

struct device_physical_location {
	enum device_physical_location_panel panel;
	enum device_physical_location_vertical_position vertical_position;
	enum device_physical_location_horizontal_position horizontal_position;
	bool dock;
	bool lid;
};

struct klist_node {
	void *n_klist;
	struct list_head n_node;
	struct kref n_ref;
};

struct device_private {
	struct klist klist_children;
	struct klist_node knode_parent;
	struct klist_node knode_driver;
	struct klist_node knode_bus;
	struct klist_node knode_class;
	struct list_head deferred_probe;
	const struct device_driver *async_driver;
	char *deferred_probe_reason;
	struct device *device;
	u8 dead: 1;
};

struct device_type {
	const char *name;
	const struct attribute_group **groups;
	int (*uevent)(const struct device *, struct kobj_uevent_env *);
	char * (*devnode)(const struct device *, umode_t *, kuid_t *, kgid_t *);
	void (*release)(struct device *);
	const struct dev_pm_ops *pm;
};

struct devid_map {
	struct list_head list;
	u8 id;
	u32 devid;
	bool cmd_line;
};

struct devinet_sysctl_table {
	struct ctl_table_header *sysctl_header;
	struct ctl_table devinet_vars[33];
};

struct ratelimit_state {
	raw_spinlock_t lock;
	int interval;
	int burst;
	int printed;
	int missed;
	unsigned int flags;
	long unsigned int begin;
};

struct printk_buffers {
	char outbuf[2048];
	char scratchbuf[1024];
};

struct devkmsg_user {
	atomic64_t seq;
	struct ratelimit_state rs;
	struct mutex lock;
	struct printk_buffers pbufs;
};

struct devlink;

struct ib_device;

struct netdev_phys_item_id {
	unsigned char id[32];
	unsigned char id_len;
};

struct devlink_port_phys_attrs {
	u32 port_number;
	u32 split_subport_number;
};

struct devlink_port_pci_pf_attrs {
	u32 controller;
	u16 pf;
	u8 external: 1;
};

struct devlink_port_pci_vf_attrs {
	u32 controller;
	u16 pf;
	u16 vf;
	u8 external: 1;
};

struct devlink_port_pci_sf_attrs {
	u32 controller;
	u32 sf;
	u16 pf;
	u8 external: 1;
};

struct devlink_port_attrs {
	u8 split: 1;
	u8 splittable: 1;
	u32 lanes;
	enum devlink_port_flavour flavour;
	struct netdev_phys_item_id switch_id;
	union {
		struct devlink_port_phys_attrs phys;
		struct devlink_port_pci_pf_attrs pci_pf;
		struct devlink_port_pci_vf_attrs pci_vf;
		struct devlink_port_pci_sf_attrs pci_sf;
	};
};

struct devlink_linecard;

struct devlink_port_ops;

struct devlink_rate;

struct devlink_port {
	struct list_head list;
	struct list_head region_list;
	struct devlink *devlink;
	const struct devlink_port_ops *ops;
	unsigned int index;
	spinlock_t type_lock;
	enum devlink_port_type type;
	enum devlink_port_type desired_type;
	union {
		struct {
			struct net_device *netdev;
			int ifindex;
			char ifname[16];
		} type_eth;
		struct {
			struct ib_device *ibdev;
		} type_ib;
	};
	struct devlink_port_attrs attrs;
	u8 attrs_set: 1;
	u8 switch_port: 1;
	u8 registered: 1;
	u8 initialized: 1;
	struct delayed_work type_warn_dw;
	struct list_head reporter_list;
	struct devlink_rate *devlink_rate;
	struct devlink_linecard *linecard;
	u32 rel_index;
};

struct devlink_port_ops {
	int (*port_split)(struct devlink *, struct devlink_port *, unsigned int, struct netlink_ext_ack *);
	int (*port_unsplit)(struct devlink *, struct devlink_port *, struct netlink_ext_ack *);
	int (*port_type_set)(struct devlink_port *, enum devlink_port_type);
	int (*port_del)(struct devlink *, struct devlink_port *, struct netlink_ext_ack *);
	int (*port_fn_hw_addr_get)(struct devlink_port *, u8 *, int *, struct netlink_ext_ack *);
	int (*port_fn_hw_addr_set)(struct devlink_port *, const u8 *, int, struct netlink_ext_ack *);
	int (*port_fn_roce_get)(struct devlink_port *, bool *, struct netlink_ext_ack *);
	int (*port_fn_roce_set)(struct devlink_port *, bool, struct netlink_ext_ack *);
	int (*port_fn_migratable_get)(struct devlink_port *, bool *, struct netlink_ext_ack *);
	int (*port_fn_migratable_set)(struct devlink_port *, bool, struct netlink_ext_ack *);
	int (*port_fn_state_get)(struct devlink_port *, enum devlink_port_fn_state *, enum devlink_port_fn_opstate *, struct netlink_ext_ack *);
	int (*port_fn_state_set)(struct devlink_port *, enum devlink_port_fn_state, struct netlink_ext_ack *);
	int (*port_fn_ipsec_crypto_get)(struct devlink_port *, bool *, struct netlink_ext_ack *);
	int (*port_fn_ipsec_crypto_set)(struct devlink_port *, bool, struct netlink_ext_ack *);
	int (*port_fn_ipsec_packet_get)(struct devlink_port *, bool *, struct netlink_ext_ack *);
	int (*port_fn_ipsec_packet_set)(struct devlink_port *, bool, struct netlink_ext_ack *);
	int (*port_fn_max_io_eqs_get)(struct devlink_port *, u32 *, struct netlink_ext_ack *);
	int (*port_fn_max_io_eqs_set)(struct devlink_port *, u32, struct netlink_ext_ack *);
};

struct devlink_rate {
	struct list_head list;
	enum devlink_rate_type type;
	struct devlink *devlink;
	void *priv;
	u64 tx_share;
	u64 tx_max;
	struct devlink_rate *parent;
	union {
		struct devlink_port *devlink_port;
		struct {
			char *name;
			refcount_t refcnt;
		};
	};
	u32 tx_priority;
	u32 tx_weight;
};

typedef void (*dr_release_t)(struct device *, void *);

struct devres_node {
	struct list_head entry;
	dr_release_t release;
	const char *name;
	size_t size;
};

struct devres {
	struct devres_node node;
	u8 data[0];
};

struct devres_group {
	struct devres_node node[2];
	void *id;
	int color;
};

union dfixed {
	u32 full;
};

typedef union dfixed fixed20_12;

struct dg2_snps_phy_buf_trans {
	u8 vswing;
	u8 pre_cursor;
	u8 post_cursor;
};

struct dictionary {
	uint8_t *buf;
	size_t start;
	size_t pos;
	size_t full;
	size_t limit;
	size_t end;
	uint32_t size;
	uint32_t size_max;
	uint32_t allocated;
	enum xz_mode mode;
};

struct die_args {
	struct pt_regs *regs;
	const char *str;
	long int err;
	int trapnr;
	int signr;
};

struct dim_stats {
	int ppms;
	int bpms;
	int epms;
	int cpms;
	int cpe_ratio;
};

struct dim_sample {
	ktime_t time;
	u32 pkt_ctr;
	u32 byte_ctr;
	u16 event_ctr;
	u32 comp_ctr;
};

struct dim {
	u8 state;
	struct dim_stats prev_stats;
	struct dim_sample start_sample;
	struct dim_sample measuring_sample;
	struct work_struct work;
	void *priv;
	u8 profile_ix;
	u8 mode;
	u8 tune_state;
	u8 steps_right;
	u8 steps_left;
	u8 tired;
};

struct dim_cq_moder {
	u16 usec;
	u16 pkts;
	u16 comps;
	u8 cq_period_mode;
	struct callback_head rcu;
};

struct dim_irq_moder {
	u8 profile_flags;
	u8 coal_flags;
	u8 dim_rx_mode;
	u8 dim_tx_mode;
	struct dim_cq_moder *rx_profile;
	struct dim_cq_moder *tx_profile;
	void (*rx_dim_work)(struct work_struct *);
	void (*tx_dim_work)(struct work_struct *);
};

typedef int dio_iodone_t(struct kiocb *, loff_t, ssize_t, void *);

struct dio {
	int flags;
	blk_opf_t opf;
	struct gendisk *bio_disk;
	struct inode *inode;
	loff_t i_size;
	dio_iodone_t *end_io;
	bool is_pinned;
	void *private;
	spinlock_t bio_lock;
	int page_errors;
	int is_async;
	bool defer_completion;
	bool should_dirty;
	int io_error;
	long unsigned int refcount;
	struct bio *bio_list;
	struct task_struct *waiter;
	struct kiocb *iocb;
	ssize_t result;
	union {
		struct page *pages[64];
		struct work_struct complete_work;
	};
	long: 64;
};

typedef int get_block_t(struct inode *, sector_t, struct buffer_head *, int);

struct dio_submit {
	struct bio *bio;
	unsigned int blkbits;
	unsigned int blkfactor;
	unsigned int start_zero_done;
	int pages_in_io;
	sector_t block_in_file;
	unsigned int blocks_available;
	int reap_counter;
	sector_t final_block_in_request;
	int boundary;
	get_block_t *get_block;
	loff_t logical_offset_in_bio;
	sector_t final_block_in_bio;
	sector_t next_block_for_io;
	struct page *cur_page;
	unsigned int cur_page_offset;
	unsigned int cur_page_len;
	sector_t cur_page_block;
	loff_t cur_page_fs_offset;
	struct iov_iter *iter;
	unsigned int head;
	unsigned int tail;
	size_t from;
	size_t to;
};

struct dir_entry {
	struct list_head list;
	time64_t mtime;
	char name[0];
};

struct fname;

struct dir_private_info {
	struct rb_root root;
	struct rb_node *curr_node;
	struct fname *extra_fname;
	loff_t last_pos;
	__u32 curr_hash;
	__u32 curr_minor_hash;
	__u32 next_hash;
	u64 cookie;
	bool initialized;
};

struct dirty_throttle_control {
	struct bdi_writeback *wb;
	struct fprop_local_percpu *wb_completions;
	long unsigned int avail;
	long unsigned int dirty;
	long unsigned int thresh;
	long unsigned int bg_thresh;
	long unsigned int wb_dirty;
	long unsigned int wb_thresh;
	long unsigned int wb_bg_thresh;
	long unsigned int pos_ratio;
	bool freerun;
	bool dirty_exceeded;
};

struct disk_events {
	struct list_head node;
	struct gendisk *disk;
	spinlock_t lock;
	struct mutex block_mutex;
	int block;
	unsigned int pending;
	unsigned int clearing;
	long int poll_msecs;
	struct delayed_work dwork;
};

struct disk_stats {
	u64 nsecs[4];
	long unsigned int sectors[4];
	long unsigned int ios[4];
	long unsigned int merges[4];
	long unsigned int io_ticks;
	local_t in_flight[2];
};

struct dispatch_rq_data {
	struct blk_mq_hw_ctx *hctx;
	struct request *rq;
};

struct displayid_block {
	u8 tag;
	u8 rev;
	u8 num_bytes;
};

struct displayid_detailed_timings_1 {
	u8 pixel_clock[3];
	u8 flags;
	u8 hactive[2];
	u8 hblank[2];
	u8 hsync[2];
	u8 hsw[2];
	u8 vactive[2];
	u8 vblank[2];
	u8 vsync[2];
	u8 vsw[2];
};

struct displayid_detailed_timing_block {
	struct displayid_block base;
	struct displayid_detailed_timings_1 timings[0];
};

struct displayid_header {
	u8 rev;
	u8 bytes;
	u8 prod_id;
	u8 ext_count;
};

struct displayid_tiled_block {
	struct displayid_block base;
	u8 tile_cap;
	u8 topo[3];
	u8 tile_size[4];
	u8 tile_pixel_bezel[5];
	u8 topology_id[8];
};

struct displayid_vesa_vendor_specific_block {
	struct displayid_block base;
	u8 oui[3];
	u8 data_structure_type;
	u8 mso;
};

struct dl_bw {
	raw_spinlock_t lock;
	u64 bw;
	u64 total_bw;
};

struct dl_rq {
	struct rb_root_cached root;
	unsigned int dl_nr_running;
	struct {
		u64 curr;
		u64 next;
	} earliest_dl;
	bool overloaded;
	struct rb_root_cached pushable_dl_tasks_root;
	u64 running_bw;
	u64 this_bw;
	u64 extra_bw;
	u64 max_bw;
	u64 bw_ratio;
};

struct dm_arg {
	unsigned int min;
	unsigned int max;
	char *error;
};

struct dm_arg_set {
	unsigned int argc;
	char **argv;
};

struct dm_bio_details {
	struct block_device *bi_bdev;
	int __bi_remaining;
	long unsigned int bi_flags;
	struct bvec_iter bi_iter;
	bio_end_io_t *bi_end_io;
};

struct dm_blkdev_id {
	u8 *id;
	enum blk_unique_id type;
};

struct dm_dev {
	struct block_device *bdev;
	struct file *bdev_file;
	struct dax_device *dax_dev;
	blk_mode_t mode;
	char name[16];
};

struct dm_dev_internal {
	struct list_head list;
	refcount_t count;
	struct dm_dev *dm_dev;
};

struct dm_dirty_log_type;

struct dm_target;

struct dm_dirty_log {
	struct dm_dirty_log_type *type;
	int (*flush_callback_fn)(struct dm_target *);
	void *context;
};

struct dm_dirty_log_type {
	const char *name;
	struct module *module;
	struct list_head list;
	int (*ctr)(struct dm_dirty_log *, struct dm_target *, unsigned int, char **);
	void (*dtr)(struct dm_dirty_log *);
	int (*presuspend)(struct dm_dirty_log *);
	int (*postsuspend)(struct dm_dirty_log *);
	int (*resume)(struct dm_dirty_log *);
	uint32_t (*get_region_size)(struct dm_dirty_log *);
	int (*is_clean)(struct dm_dirty_log *, region_t);
	int (*in_sync)(struct dm_dirty_log *, region_t, int);
	int (*flush)(struct dm_dirty_log *);
	void (*mark_region)(struct dm_dirty_log *, region_t);
	void (*clear_region)(struct dm_dirty_log *, region_t);
	int (*get_resync_work)(struct dm_dirty_log *, region_t *);
	void (*set_region_sync)(struct dm_dirty_log *, region_t, int);
	region_t (*get_sync_count)(struct dm_dirty_log *);
	int (*status)(struct dm_dirty_log *, status_type_t, char *, unsigned int);
	int (*is_remote_recovering)(struct dm_dirty_log *, region_t);
};

struct dm_file {
	volatile unsigned int global_event_nr;
};

struct dm_stats_aux {
	bool merged;
	long long unsigned int duration_ns;
};

struct dm_target_io {
	short unsigned int magic;
	blk_short_t flags;
	unsigned int target_bio_nr;
	struct dm_io *io;
	struct dm_target *ti;
	unsigned int *len_ptr;
	sector_t old_sector;
	struct bio clone;
};

struct mapped_device;

struct dm_io {
	short unsigned int magic;
	blk_short_t flags;
	spinlock_t lock;
	long unsigned int start_time;
	void *data;
	struct dm_io *next;
	struct dm_stats_aux stats_aux;
	blk_status_t status;
	atomic_t io_count;
	struct mapped_device *md;
	struct bio *orig_bio;
	unsigned int sector_offset;
	unsigned int sectors;
	struct dm_target_io tio;
};

struct dm_io_client {
	mempool_t pool;
	struct bio_set bios;
};

struct page_list;

struct dm_io_memory {
	enum dm_io_mem_type type;
	unsigned int offset;
	union {
		struct page_list *pl;
		struct bio *bio;
		void *vma;
		void *addr;
	} ptr;
};

typedef void (*io_notify_fn)(long unsigned int, void *);

struct dm_io_notify {
	io_notify_fn fn;
	void *context;
};

struct dm_io_region {
	struct block_device *bdev;
	sector_t sector;
	sector_t count;
};

struct dm_io_request {
	blk_opf_t bi_opf;
	struct dm_io_memory mem;
	struct dm_io_notify notify;
	struct dm_io_client *client;
};

struct dm_ioctl {
	__u32 version[3];
	__u32 data_size;
	__u32 data_start;
	__u32 target_count;
	__s32 open_count;
	__u32 flags;
	__u32 event_nr;
	__u32 padding;
	__u64 dev;
	char name[128];
	char uuid[129];
	char data[7];
};

struct dm_kcopyd_throttle;

struct dm_kcopyd_client {
	struct page_list *pages;
	unsigned int nr_reserved_pages;
	unsigned int nr_free_pages;
	unsigned int sub_job_size;
	struct dm_io_client *io_client;
	wait_queue_head_t destroyq;
	mempool_t job_pool;
	struct workqueue_struct *kcopyd_wq;
	struct work_struct kcopyd_work;
	struct dm_kcopyd_throttle *throttle;
	atomic_t nr_jobs;
	spinlock_t job_lock;
	struct list_head callback_jobs;
	struct list_head complete_jobs;
	struct list_head io_jobs;
	struct list_head pages_jobs;
};

struct dm_kcopyd_throttle {
	unsigned int throttle;
	unsigned int num_io_jobs;
	unsigned int io_period;
	unsigned int total_period;
	unsigned int last_jiffies;
};

struct dm_kobject_holder {
	struct kobject kobj;
	struct completion completion;
};

struct dm_md_mempools {
	struct bio_set bs;
	struct bio_set io_bs;
};

struct dm_name_list {
	__u64 dev;
	__u32 next;
	char name[0];
};

struct pr_keys;

struct pr_held_reservation;

struct dm_pr {
	u64 old_key;
	u64 new_key;
	u32 flags;
	bool abort;
	bool fail_early;
	int ret;
	enum pr_type type;
	struct pr_keys *read_keys;
	struct pr_held_reservation *rsv;
};

struct mirror;

struct dm_raid1_bio_record {
	struct mirror *m;
	struct dm_bio_details details;
	region_t write_region;
};

struct dm_region_hash;

struct dm_region {
	struct dm_region_hash *rh;
	region_t key;
	int state;
	struct list_head hash_list;
	struct list_head list;
	atomic_t pending;
	struct bio_list delayed_bios;
};

struct semaphore {
	raw_spinlock_t lock;
	unsigned int count;
	struct list_head wait_list;
};

struct dm_region_hash {
	uint32_t region_size;
	unsigned int region_shift;
	struct dm_dirty_log *log;
	rwlock_t hash_lock;
	unsigned int mask;
	unsigned int nr_buckets;
	unsigned int prime;
	unsigned int shift;
	struct list_head *buckets;
	int flush_failure;
	unsigned int max_recovery;
	spinlock_t region_lock;
	atomic_t recovery_in_flight;
	struct list_head clean_regions;
	struct list_head quiesced_regions;
	struct list_head recovered_regions;
	struct list_head failed_recovered_regions;
	struct semaphore recovery_count;
	mempool_t region_pool;
	void *context;
	sector_t target_begin;
	void (*dispatch_bios)(void *, struct bio_list *);
	void (*wakeup_workers)(void *);
	void (*wakeup_all_recovery_waiters)(void *);
};

struct dm_rq_target_io;

struct dm_rq_clone_bio_info {
	struct bio *orig;
	struct dm_rq_target_io *tio;
	struct bio clone;
};

struct kthread_work;

typedef void (*kthread_work_func_t)(struct kthread_work *);

struct kthread_worker;

struct kthread_work {
	struct list_head node;
	kthread_work_func_t func;
	struct kthread_worker *worker;
	int canceling;
};

union map_info {
	void *ptr;
};

struct dm_rq_target_io {
	struct mapped_device *md;
	struct dm_target *ti;
	struct request *orig;
	struct request *clone;
	struct kthread_work work;
	blk_status_t error;
	union map_info info;
	struct dm_stats_aux stats_aux;
	long unsigned int duration_jiffies;
	unsigned int n_sectors;
	unsigned int completed;
};

struct dm_stat_percpu {
	long long unsigned int sectors[2];
	long long unsigned int ios[2];
	long long unsigned int merges[2];
	long long unsigned int ticks[2];
	long long unsigned int io_ticks[2];
	long long unsigned int io_ticks_total;
	long long unsigned int time_in_queue;
	long long unsigned int *histogram;
};

struct dm_stat_shared {
	atomic_t in_flight[2];
	long long unsigned int stamp;
	struct dm_stat_percpu tmp;
};

struct dm_stat {
	struct list_head list_entry;
	int id;
	unsigned int stat_flags;
	size_t n_entries;
	sector_t start;
	sector_t end;
	sector_t step;
	unsigned int n_histogram_entries;
	long long unsigned int *histogram_boundaries;
	const char *program_id;
	const char *aux_data;
	struct callback_head callback_head;
	size_t shared_alloc_size;
	size_t percpu_alloc_size;
	size_t histogram_alloc_size;
	struct dm_stat_percpu *stat_percpu[64];
	struct dm_stat_shared stat_shared[0];
};

struct dm_stats_last_position;

struct dm_stats {
	struct mutex mutex;
	struct list_head list;
	struct dm_stats_last_position *last;
	bool precise_timestamps;
};

struct dm_stats_last_position {
	sector_t last_sector;
	unsigned int last_rw;
};

struct dm_sysfs_attr {
	struct attribute attr;
	ssize_t (*show)(struct mapped_device *, char *);
	ssize_t (*store)(struct mapped_device *, const char *, size_t);
};

struct target_type;

struct dm_table {
	struct mapped_device *md;
	enum dm_queue_mode type;
	unsigned int depth;
	unsigned int counts[16];
	sector_t *index[16];
	unsigned int num_targets;
	unsigned int num_allocated;
	sector_t *highs;
	struct dm_target *targets;
	struct target_type *immutable_target_type;
	bool integrity_supported: 1;
	bool singleton: 1;
	bool flush_bypasses_map: 1;
	blk_mode_t mode;
	struct list_head devices;
	struct rw_semaphore devices_lock;
	void (*event_fn)(void *);
	void *event_context;
	struct dm_md_mempools *mempools;
};

struct dm_target {
	struct dm_table *table;
	struct target_type *type;
	sector_t begin;
	sector_t len;
	uint32_t max_io_len;
	unsigned int num_flush_bios;
	unsigned int num_discard_bios;
	unsigned int num_secure_erase_bios;
	unsigned int num_write_zeroes_bios;
	unsigned int per_io_data_size;
	void *private;
	char *error;
	bool flush_supported: 1;
	bool discards_supported: 1;
	bool zone_reset_all_supported: 1;
	bool max_discard_granularity: 1;
	bool limit_swap_bios: 1;
	bool emulate_zone_append: 1;
	bool accounts_remapped_io: 1;
	bool needs_bio_set_dev: 1;
	bool flush_bypasses_map: 1;
	bool mempool_needs_integrity: 1;
};

struct dm_target_deps {
	__u32 count;
	__u32 padding;
	__u64 dev[0];
};

struct dm_target_msg {
	__u64 sector;
	char message[0];
};

struct dm_target_spec {
	__u64 sector_start;
	__u64 length;
	__s32 status;
	__u32 next;
	char target_type[16];
};

struct dm_target_versions {
	__u32 next;
	__u32 version[3];
	char name[0];
};

typedef void (*dma_async_tx_callback)(void *);

struct dmaengine_result;

typedef void (*dma_async_tx_callback_result)(void *, const struct dmaengine_result *);

struct dmaengine_unmap_data;

struct dma_descriptor_metadata_ops;

struct dma_async_tx_descriptor {
	dma_cookie_t cookie;
	enum dma_ctrl_flags flags;
	dma_addr_t phys;
	struct dma_chan *chan;
	dma_cookie_t (*tx_submit)(struct dma_async_tx_descriptor *);
	int (*desc_free)(struct dma_async_tx_descriptor *);
	dma_async_tx_callback callback;
	dma_async_tx_callback_result callback_result;
	void *callback_param;
	struct dmaengine_unmap_data *unmap;
	enum dma_desc_metadata_mode desc_metadata_mode;
	struct dma_descriptor_metadata_ops *metadata_ops;
};

struct dma_block {
	struct dma_block *next_block;
	dma_addr_t dma;
};

struct iosys_map {
	union {
		void *vaddr_iomem;
		void *vaddr;
	};
	bool is_iomem;
};

struct dma_buf_poll_cb_t {
	struct dma_fence_cb cb;
	wait_queue_head_t *poll;
	__poll_t active;
};

struct dma_buf_ops;

struct dma_resv;

struct dma_buf {
	size_t size;
	struct file *file;
	struct list_head attachments;
	const struct dma_buf_ops *ops;
	unsigned int vmapping_counter;
	struct iosys_map vmap_ptr;
	const char *exp_name;
	const char *name;
	spinlock_t name_lock;
	struct module *owner;
	struct list_head list_node;
	void *priv;
	struct dma_resv *resv;
	wait_queue_head_t poll;
	struct dma_buf_poll_cb_t cb_in;
	struct dma_buf_poll_cb_t cb_out;
};

struct dma_buf_attachment;

struct dma_buf_attach_ops {
	bool allow_peer2peer;
	void (*move_notify)(struct dma_buf_attachment *);
};

struct sg_table;

struct dma_buf_attachment {
	struct dma_buf *dmabuf;
	struct device *dev;
	struct list_head node;
	struct sg_table *sgt;
	enum dma_data_direction dir;
	bool peer2peer;
	const struct dma_buf_attach_ops *importer_ops;
	void *importer_priv;
	void *priv;
};

struct dma_buf_export_info {
	const char *exp_name;
	struct module *owner;
	const struct dma_buf_ops *ops;
	size_t size;
	int flags;
	struct dma_resv *resv;
	void *priv;
};

struct dma_buf_export_sync_file {
	__u32 flags;
	__s32 fd;
};

struct dma_buf_import_sync_file {
	__u32 flags;
	__s32 fd;
};

struct dma_buf_ops {
	bool cache_sgt_mapping;
	int (*attach)(struct dma_buf *, struct dma_buf_attachment *);
	void (*detach)(struct dma_buf *, struct dma_buf_attachment *);
	int (*pin)(struct dma_buf_attachment *);
	void (*unpin)(struct dma_buf_attachment *);
	struct sg_table * (*map_dma_buf)(struct dma_buf_attachment *, enum dma_data_direction);
	void (*unmap_dma_buf)(struct dma_buf_attachment *, struct sg_table *, enum dma_data_direction);
	void (*release)(struct dma_buf *);
	int (*begin_cpu_access)(struct dma_buf *, enum dma_data_direction);
	int (*end_cpu_access)(struct dma_buf *, enum dma_data_direction);
	int (*mmap)(struct dma_buf *, struct vm_area_struct *);
	int (*vmap)(struct dma_buf *, struct iosys_map *);
	void (*vunmap)(struct dma_buf *, struct iosys_map *);
};

struct dma_buf_sync {
	__u64 flags;
};

struct dma_chan___2 {
	int lock;
	const char *device_id;
};

struct dma_device;

struct dma_chan_dev;

struct dma_chan_percpu;

struct dma_router;

struct dma_chan {
	struct dma_device *device;
	struct device *slave;
	dma_cookie_t cookie;
	dma_cookie_t completed_cookie;
	int chan_id;
	struct dma_chan_dev *dev;
	const char *name;
	char *dbg_client_name;
	struct list_head device_node;
	struct dma_chan_percpu *local;
	int client_count;
	int table_count;
	struct dma_router *router;
	void *route_data;
	void *private;
};

struct dma_chan_dev {
	struct dma_chan *chan;
	struct device device;
	int dev_id;
	bool chan_dma_dev;
};

struct dma_chan_percpu {
	long unsigned int memcpy_count;
	long unsigned int bytes_transferred;
};

struct dma_chan_tbl_ent {
	struct dma_chan *chan;
};

struct dma_descriptor_metadata_ops {
	int (*attach)(struct dma_async_tx_descriptor *, void *, size_t);
	void * (*get_ptr)(struct dma_async_tx_descriptor *, size_t *, size_t *);
	int (*set_len)(struct dma_async_tx_descriptor *, size_t);
};

struct dma_slave_map;

struct dma_filter {
	dma_filter_fn fn;
	int mapcnt;
	const struct dma_slave_map *map;
};

struct dma_vec;

struct dma_interleaved_template;

struct dma_slave_caps;

struct dma_slave_config;

struct dma_tx_state;

struct dma_device {
	struct kref ref;
	unsigned int chancnt;
	unsigned int privatecnt;
	struct list_head channels;
	struct list_head global_node;
	struct dma_filter filter;
	dma_cap_mask_t cap_mask;
	enum dma_desc_metadata_mode desc_metadata_modes;
	short unsigned int max_xor;
	short unsigned int max_pq;
	enum dmaengine_alignment copy_align;
	enum dmaengine_alignment xor_align;
	enum dmaengine_alignment pq_align;
	enum dmaengine_alignment fill_align;
	int dev_id;
	struct device *dev;
	struct module *owner;
	struct ida chan_ida;
	u32 src_addr_widths;
	u32 dst_addr_widths;
	u32 directions;
	u32 min_burst;
	u32 max_burst;
	u32 max_sg_burst;
	bool descriptor_reuse;
	enum dma_residue_granularity residue_granularity;
	int (*device_alloc_chan_resources)(struct dma_chan *);
	int (*device_router_config)(struct dma_chan *);
	void (*device_free_chan_resources)(struct dma_chan *);
	struct dma_async_tx_descriptor * (*device_prep_dma_memcpy)(struct dma_chan *, dma_addr_t, dma_addr_t, size_t, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_dma_xor)(struct dma_chan *, dma_addr_t, dma_addr_t *, unsigned int, size_t, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_dma_xor_val)(struct dma_chan *, dma_addr_t *, unsigned int, size_t, enum sum_check_flags *, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_dma_pq)(struct dma_chan *, dma_addr_t *, dma_addr_t *, unsigned int, const unsigned char *, size_t, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_dma_pq_val)(struct dma_chan *, dma_addr_t *, dma_addr_t *, unsigned int, const unsigned char *, size_t, enum sum_check_flags *, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_dma_memset)(struct dma_chan *, dma_addr_t, int, size_t, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_dma_memset_sg)(struct dma_chan *, struct scatterlist *, unsigned int, int, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_dma_interrupt)(struct dma_chan *, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_peripheral_dma_vec)(struct dma_chan *, const struct dma_vec *, size_t, enum dma_transfer_direction, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_slave_sg)(struct dma_chan *, struct scatterlist *, unsigned int, enum dma_transfer_direction, long unsigned int, void *);
	struct dma_async_tx_descriptor * (*device_prep_dma_cyclic)(struct dma_chan *, dma_addr_t, size_t, size_t, enum dma_transfer_direction, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_interleaved_dma)(struct dma_chan *, struct dma_interleaved_template *, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_dma_imm_data)(struct dma_chan *, dma_addr_t, u64, long unsigned int);
	void (*device_caps)(struct dma_chan *, struct dma_slave_caps *);
	int (*device_config)(struct dma_chan *, struct dma_slave_config *);
	int (*device_pause)(struct dma_chan *);
	int (*device_resume)(struct dma_chan *);
	int (*device_terminate_all)(struct dma_chan *);
	void (*device_synchronize)(struct dma_chan *);
	enum dma_status (*device_tx_status)(struct dma_chan *, dma_cookie_t, struct dma_tx_state *);
	void (*device_issue_pending)(struct dma_chan *);
	void (*device_release)(struct dma_device *);
	void (*dbg_summary_show)(struct seq_file *, struct dma_device *);
	struct dentry *dbg_dev_root;
};

struct dma_devres {
	size_t size;
	void *vaddr;
	dma_addr_t dma_handle;
	long unsigned int attrs;
};

struct dma_fence_array;

struct dma_fence_array_cb {
	struct dma_fence_cb cb;
	struct dma_fence_array *array;
};

struct dma_fence_array {
	struct dma_fence base;
	spinlock_t lock;
	unsigned int num_fences;
	atomic_t num_pending;
	struct dma_fence **fences;
	struct irq_work work;
	struct dma_fence_array_cb callbacks[0];
};

struct dma_fence_chain {
	struct dma_fence base;
	struct dma_fence *prev;
	u64 prev_seqno;
	struct dma_fence *fence;
	union {
		struct dma_fence_cb cb;
		struct irq_work work;
	};
	spinlock_t lock;
};

struct dma_fence_ops {
	bool use_64bit_seqno;
	const char * (*get_driver_name)(struct dma_fence *);
	const char * (*get_timeline_name)(struct dma_fence *);
	bool (*enable_signaling)(struct dma_fence *);
	bool (*signaled)(struct dma_fence *);
	long int (*wait)(struct dma_fence *, bool, long int);
	void (*release)(struct dma_fence *);
	void (*fence_value_str)(struct dma_fence *, char *, int);
	void (*timeline_value_str)(struct dma_fence *, char *, int);
	void (*set_deadline)(struct dma_fence *, ktime_t);
};

struct dma_fence_unwrap {
	struct dma_fence *chain;
	struct dma_fence *array;
	unsigned int index;
};

struct dma_fence_work_ops {
	const char *name;
	void (*work)(struct dma_fence_work *);
	void (*release)(struct dma_fence_work *);
};

struct dma_interleaved_template {
	dma_addr_t src_start;
	dma_addr_t dst_start;
	enum dma_transfer_direction dir;
	bool src_inc;
	bool dst_inc;
	bool src_sgl;
	bool dst_sgl;
	size_t numf;
	size_t frame_size;
	struct data_chunk sgl[0];
};

struct dma_map_ops {
	void * (*alloc)(struct device *, size_t, dma_addr_t *, gfp_t, long unsigned int);
	void (*free)(struct device *, size_t, void *, dma_addr_t, long unsigned int);
	struct page * (*alloc_pages_op)(struct device *, size_t, dma_addr_t *, enum dma_data_direction, gfp_t);
	void (*free_pages)(struct device *, size_t, struct page *, dma_addr_t, enum dma_data_direction);
	int (*mmap)(struct device *, struct vm_area_struct *, void *, dma_addr_t, size_t, long unsigned int);
	int (*get_sgtable)(struct device *, struct sg_table *, void *, dma_addr_t, size_t, long unsigned int);
	dma_addr_t (*map_page)(struct device *, struct page *, long unsigned int, size_t, enum dma_data_direction, long unsigned int);
	void (*unmap_page)(struct device *, dma_addr_t, size_t, enum dma_data_direction, long unsigned int);
	int (*map_sg)(struct device *, struct scatterlist *, int, enum dma_data_direction, long unsigned int);
	void (*unmap_sg)(struct device *, struct scatterlist *, int, enum dma_data_direction, long unsigned int);
	dma_addr_t (*map_resource)(struct device *, phys_addr_t, size_t, enum dma_data_direction, long unsigned int);
	void (*unmap_resource)(struct device *, dma_addr_t, size_t, enum dma_data_direction, long unsigned int);
	void (*sync_single_for_cpu)(struct device *, dma_addr_t, size_t, enum dma_data_direction);
	void (*sync_single_for_device)(struct device *, dma_addr_t, size_t, enum dma_data_direction);
	void (*sync_sg_for_cpu)(struct device *, struct scatterlist *, int, enum dma_data_direction);
	void (*sync_sg_for_device)(struct device *, struct scatterlist *, int, enum dma_data_direction);
	void (*cache_sync)(struct device *, void *, size_t, enum dma_data_direction);
	int (*dma_supported)(struct device *, u64);
	u64 (*get_required_mask)(struct device *);
	size_t (*max_mapping_size)(struct device *);
	size_t (*opt_mapping_size)(void);
	long unsigned int (*get_merge_boundary)(struct device *);
};

struct dma_page {
	struct list_head page_list;
	void *vaddr;
	dma_addr_t dma;
};

struct dma_pool {
	struct list_head page_list;
	spinlock_t lock;
	struct dma_block *next_block;
	size_t nr_blocks;
	size_t nr_active;
	size_t nr_pages;
	struct device *dev;
	unsigned int size;
	unsigned int allocation;
	unsigned int boundary;
	char name[32];
	struct list_head pools;
};

struct dma_pte {
	u64 val;
};

struct ww_acquire_ctx;

struct ww_mutex {
	struct mutex base;
	struct ww_acquire_ctx *ctx;
};

struct dma_resv_list;

struct dma_resv {
	struct ww_mutex lock;
	struct dma_resv_list *fences;
};

struct dma_resv_iter {
	struct dma_resv *obj;
	enum dma_resv_usage usage;
	struct dma_fence *fence;
	enum dma_resv_usage fence_usage;
	unsigned int index;
	struct dma_resv_list *fences;
	unsigned int num_fences;
	bool is_restarted;
};

struct dma_resv_list {
	struct callback_head rcu;
	u32 num_fences;
	u32 max_fences;
	struct dma_fence *table[0];
};

struct dma_router {
	struct device *dev;
	void (*route_free)(struct device *, void *);
};

struct sg_table {
	struct scatterlist *sgl;
	unsigned int nents;
	unsigned int orig_nents;
};

struct dma_sgt_handle {
	struct sg_table sgt;
	struct page **pages;
};

struct dma_slave_caps {
	u32 src_addr_widths;
	u32 dst_addr_widths;
	u32 directions;
	u32 min_burst;
	u32 max_burst;
	u32 max_sg_burst;
	bool cmd_pause;
	bool cmd_resume;
	bool cmd_terminate;
	enum dma_residue_granularity residue_granularity;
	bool descriptor_reuse;
};

struct dma_slave_config {
	enum dma_transfer_direction direction;
	phys_addr_t src_addr;
	phys_addr_t dst_addr;
	enum dma_slave_buswidth src_addr_width;
	enum dma_slave_buswidth dst_addr_width;
	u32 src_maxburst;
	u32 dst_maxburst;
	u32 src_port_window_size;
	u32 dst_port_window_size;
	bool device_fc;
	void *peripheral_config;
	size_t peripheral_size;
};

struct dma_slave_map {
	const char *devname;
	const char *slave;
	void *param;
};

struct dma_tx_state {
	dma_cookie_t last;
	dma_cookie_t used;
	u32 residue;
	u32 in_flight_bytes;
};

struct dma_vec {
	dma_addr_t addr;
	size_t len;
};

struct dmabuf_cmsg {
	__u64 frag_offset;
	__u32 frag_size;
	__u32 frag_token;
	__u32 dmabuf_id;
	__u32 flags;
};

struct net_iov;

struct net_devmem_dmabuf_binding;

struct dmabuf_genpool_chunk_owner {
	long unsigned int base_virtual;
	dma_addr_t base_dma_addr;
	struct net_iov *niovs;
	size_t num_niovs;
	struct net_devmem_dmabuf_binding *binding;
};

struct dmabuf_token {
	__u32 token_start;
	__u32 token_count;
};

struct dmaengine_desc_callback {
	dma_async_tx_callback callback;
	dma_async_tx_callback_result callback_result;
	void *callback_param;
};

struct dmaengine_result {
	enum dmaengine_tx_result result;
	u32 residue;
};

struct dmaengine_unmap_data {
	u8 map_cnt;
	u8 to_cnt;
	u8 from_cnt;
	u8 bidi_cnt;
	struct device *dev;
	struct kref kref;
	size_t len;
	dma_addr_t addr[0];
};

struct dmaengine_unmap_pool {
	struct kmem_cache *cache;
	const char *name;
	mempool_t *pool;
	size_t size;
};

struct dmar_dev_scope;

struct dmar_atsr_unit {
	struct list_head list;
	struct acpi_dmar_header *hdr;
	struct dmar_dev_scope *devices;
	int devices_cnt;
	u8 include_all: 1;
};

struct dmar_dev_scope {
	struct device *dev;
	u8 bus;
	u8 devfn;
};

struct iommu_hwpt_vtd_s1 {
	__u64 flags;
	__u64 pgtbl_addr;
	__u32 addr_width;
	__u32 __reserved;
};

struct mmu_notifier_ops;

struct mmu_notifier {
	struct hlist_node hlist;
	const struct mmu_notifier_ops *ops;
	struct mm_struct *mm;
	struct callback_head rcu;
	unsigned int users;
};

struct iommu_domain_geometry {
	dma_addr_t aperture_start;
	dma_addr_t aperture_end;
	bool force_aperture;
};

struct iommu_domain;

typedef int (*iommu_fault_handler_t)(struct iommu_domain *, struct device *, long unsigned int, int, void *);

struct iommu_domain_ops;

struct iommu_dirty_ops;

struct iommu_dma_cookie;

struct iopf_group;

struct iommu_domain {
	unsigned int type;
	const struct iommu_domain_ops *ops;
	const struct iommu_dirty_ops *dirty_ops;
	const struct iommu_ops *owner;
	long unsigned int pgsize_bitmap;
	struct iommu_domain_geometry geometry;
	struct iommu_dma_cookie *iova_cookie;
	int (*iopf_handler)(struct iopf_group *);
	void *fault_data;
	union {
		struct {
			iommu_fault_handler_t handler;
			void *handler_token;
		};
		struct {
			struct mm_struct *mm;
			int users;
			struct list_head next;
		};
	};
};

struct qi_batch;

struct dmar_domain {
	int nid;
	struct xarray iommu_array;
	u8 iommu_coherency: 1;
	u8 force_snooping: 1;
	u8 set_pte_snp: 1;
	u8 use_first_level: 1;
	u8 dirty_tracking: 1;
	u8 nested_parent: 1;
	u8 has_mappings: 1;
	spinlock_t lock;
	struct list_head devices;
	struct list_head dev_pasids;
	spinlock_t cache_lock;
	struct list_head cache_tags;
	struct qi_batch *qi_batch;
	int iommu_superpage;
	union {
		struct {
			struct dma_pte *pgd;
			int gaw;
			int agaw;
			u64 max_addr;
			spinlock_t s1_lock;
			struct list_head s1_domains;
		};
		struct {
			struct dmar_domain *s2_domain;
			struct iommu_hwpt_vtd_s1 s1_cfg;
			struct list_head s2_link;
		};
		struct {
			struct mmu_notifier notifier;
		};
	};
	struct iommu_domain domain;
};

struct dmar_drhd_unit {
	struct list_head list;
	struct acpi_dmar_header *hdr;
	u64 reg_base_addr;
	long unsigned int reg_size;
	struct dmar_dev_scope *devices;
	int devices_cnt;
	u16 segment;
	u8 ignored: 1;
	u8 include_all: 1;
	u8 gfx_dedicated: 1;
	struct intel_iommu *iommu;
};

struct dmar_pci_path {
	u8 bus;
	u8 device;
	u8 function;
};

struct dmar_pci_notify_info {
	struct pci_dev *dev;
	long unsigned int event;
	int bus;
	u16 seg;
	u16 level;
	struct dmar_pci_path path[0];
};

typedef int (*dmar_res_handler_t)(struct acpi_dmar_header *, void *);

struct dmar_res_callback {
	dmar_res_handler_t cb[6];
	void *arg[6];
	bool ignore_unhandled;
	bool print_entry;
};

struct dmar_rmrr_unit {
	struct list_head list;
	struct acpi_dmar_header *hdr;
	u64 base_address;
	u64 end_address;
	struct dmar_dev_scope *devices;
	int devices_cnt;
};

struct dmar_satc_unit {
	struct list_head list;
	struct acpi_dmar_header *hdr;
	struct dmar_dev_scope *devices;
	struct intel_iommu *iommu;
	int devices_cnt;
	u8 atc_required: 1;
};

struct dmc_fw_info {
	u32 mmio_count;
	i915_reg_t mmioaddr[20];
	u32 mmiodata[20];
	u32 dmc_offset;
	u32 start_mmioaddr;
	u32 dmc_fw_size;
	u32 *payload;
	bool present;
};

struct dmi_device {
	struct list_head list;
	int type;
	const char *name;
	void *device_data;
};

struct dmi_dev_onboard {
	struct dmi_device dev;
	int instance;
	int segment;
	int bus;
	int devfn;
};

struct dmi_device_attribute {
	struct device_attribute dev_attr;
	int field;
};

struct dmi_header {
	u8 type;
	u8 length;
	u16 handle;
};

struct dmi_memdev_info {
	const char *device;
	const char *bank;
	u64 size;
	u16 handle;
	u8 type;
};

struct dmi_onboard_device_info {
	const char *name;
	u8 type;
	short unsigned int i2c_addr;
	const char *i2c_type;
};

struct dmi_strmatch {
	unsigned char slot: 7;
	unsigned char exact_match: 1;
	char substr[79];
};

struct dmi_system_id {
	int (*callback)(const struct dmi_system_id *);
	const char *ident;
	struct dmi_strmatch matches[4];
	void *driver_data;
};

struct dnotify_struct;

struct dnotify_mark {
	struct fsnotify_mark fsn_mark;
	struct dnotify_struct *dn;
};

typedef void *fl_owner_t;

struct dnotify_struct {
	struct dnotify_struct *dn_next;
	__u32 dn_mask;
	int dn_fd;
	struct file *dn_filp;
	fl_owner_t dn_owner;
};

struct dns_payload_header {
	__u8 zero;
	__u8 content;
	__u8 version;
};

struct dns_server_list_v1_header {
	struct dns_payload_header hdr;
	__u8 source;
	__u8 status;
	__u8 nr_servers;
};

struct do_proc_dointvec_minmax_conv_param {
	int *min;
	int *max;
};

struct do_proc_douintvec_minmax_conv_param {
	unsigned int *min;
	unsigned int *max;
};

struct dock_dependent_device {
	struct list_head list;
	struct acpi_device *adev;
};

struct platform_device;

struct dock_station {
	acpi_handle handle;
	long unsigned int last_dock_time;
	u32 flags;
	struct list_head dependent_devices;
	struct list_head sibling;
	struct platform_device *dock_device;
};

struct dotl_iattr_map {
	int iattr_valid;
	int p9_iattr_valid;
};

struct dotl_openflag_map {
	int open_flag;
	int dotl_flag;
};

struct double_list {
	struct list_head *top;
	struct list_head *bottom;
};

struct drm_edp_backlight_info {
	u8 pwmgen_bit_count;
	u8 pwm_freq_pre_divider;
	u16 max;
	bool lsb_reg_used: 1;
	bool aux_enable: 1;
	bool aux_set: 1;
};

struct drm_dp_aux;

struct dp_aux_backlight {
	struct backlight_device *base;
	struct drm_dp_aux *aux;
	struct drm_edp_backlight_info info;
	bool enabled;
};

struct dp_sdp_header {
	u8 HB0;
	u8 HB1;
	u8 HB2;
	u8 HB3;
};

struct dp_sdp {
	struct dp_sdp_header sdp_header;
	u8 db[32];
};

struct dpages {
	void (*get_page)(struct dpages *, struct page **, long unsigned int *, unsigned int *);
	void (*next_page)(struct dpages *);
	union {
		unsigned int context_u;
		struct bvec_iter context_bi;
	};
	void *context_ptr;
	void *vma_invalidate_address;
	long unsigned int vma_invalidate_size;
};

struct dpcd_quirk {
	u8 oui[3];
	u8 device_id[6];
	bool is_branch;
	u32 quirks;
};

struct dpll {
	int n;
	int m1;
	int m2;
	int p1;
	int p2;
	int dot;
	int vco;
	int m;
	int p;
};

struct intel_shared_dpll_funcs;

struct dpll_info {
	const char *name;
	const struct intel_shared_dpll_funcs *funcs;
	enum intel_dpll_id id;
	enum intel_display_power_domain power_domain;
	bool always_on;
	bool is_alt_port_dpll;
};

struct dql {
	unsigned int num_queued;
	unsigned int adj_limit;
	unsigned int last_obj_cnt;
	short unsigned int stall_thrs;
	long unsigned int history_head;
	long unsigned int history[4];
	long: 64;
	unsigned int limit;
	unsigned int num_completed;
	unsigned int prev_ovlimit;
	unsigned int prev_num_queued;
	unsigned int prev_last_obj_cnt;
	unsigned int lowest_slack;
	long unsigned int slack_start_time;
	unsigned int max_limit;
	unsigned int min_limit;
	unsigned int slack_hold_time;
	short unsigned int stall_max;
	long unsigned int last_reap;
	long unsigned int stall_cnt;
};

struct dqstats {
	long unsigned int stat[8];
	struct percpu_counter counter[8];
};

struct kqid {
	union {
		kuid_t uid;
		kgid_t gid;
		kprojid_t projid;
	};
	enum quota_type type;
};

struct mem_dqblk {
	qsize_t dqb_bhardlimit;
	qsize_t dqb_bsoftlimit;
	qsize_t dqb_curspace;
	qsize_t dqb_rsvspace;
	qsize_t dqb_ihardlimit;
	qsize_t dqb_isoftlimit;
	qsize_t dqb_curinodes;
	time64_t dqb_btime;
	time64_t dqb_itime;
};

struct dquot {
	struct hlist_node dq_hash;
	struct list_head dq_inuse;
	struct list_head dq_free;
	struct list_head dq_dirty;
	struct mutex dq_lock;
	spinlock_t dq_dqb_lock;
	atomic_t dq_count;
	struct super_block *dq_sb;
	struct kqid dq_id;
	loff_t dq_off;
	long unsigned int dq_flags;
	struct mem_dqblk dq_dqb;
};

struct dquot_operations {
	int (*write_dquot)(struct dquot *);
	struct dquot * (*alloc_dquot)(struct super_block *, int);
	void (*destroy_dquot)(struct dquot *);
	int (*acquire_dquot)(struct dquot *);
	int (*release_dquot)(struct dquot *);
	int (*mark_dirty)(struct dquot *);
	int (*write_info)(struct super_block *, int);
	qsize_t * (*get_reserved_space)(struct inode *);
	int (*get_projid)(struct inode *, kprojid_t *);
	int (*get_inode_usage)(struct inode *, qsize_t *);
	int (*get_next_id)(struct super_block *, struct kqid *);
};

struct dquot_warn {
	struct super_block *w_sb;
	struct kqid w_dq_id;
	short int w_type;
};

struct dram_dimm_info {
	u16 size;
	u8 width;
	u8 ranks;
};

struct dram_channel_info {
	struct dram_dimm_info dimm_l;
	struct dram_dimm_info dimm_s;
	u8 ranks;
	bool is_16gb_dimm;
};

struct dram_info {
	bool wm_lv_0_adjust_needed;
	u8 num_channels;
	bool symmetric_memory;
	enum intel_dram_type type;
	u8 num_qgv_points;
	u8 num_psf_gv_points;
};

struct drbg_core {
	drbg_flag_t flags;
	__u8 statelen;
	__u8 blocklen_bytes;
	char cra_name[128];
	char backend_cra_name[128];
};

struct drbg_string {
	const unsigned char *buf;
	size_t len;
	struct list_head list;
};

struct drbg_state_ops;

struct drbg_state {
	struct mutex drbg_mutex;
	unsigned char *V;
	unsigned char *Vbuf;
	unsigned char *C;
	unsigned char *Cbuf;
	size_t reseed_ctr;
	size_t reseed_threshold;
	unsigned char *scratchpad;
	unsigned char *scratchpadbuf;
	void *priv_data;
	struct crypto_skcipher *ctr_handle;
	struct skcipher_request *ctr_req;
	__u8 *outscratchpadbuf;
	__u8 *outscratchpad;
	struct crypto_wait ctr_wait;
	struct scatterlist sg_in;
	struct scatterlist sg_out;
	enum drbg_seed_state seeded;
	long unsigned int last_seed_time;
	bool pr;
	bool fips_primed;
	unsigned char *prev;
	struct crypto_rng *jent;
	const struct drbg_state_ops *d_ops;
	const struct drbg_core *core;
	struct drbg_string test_data;
};

struct drbg_state_ops {
	int (*update)(struct drbg_state *, struct list_head *, int);
	int (*generate)(struct drbg_state *, unsigned char *, unsigned int, struct list_head *);
	int (*crypto_init)(struct drbg_state *);
	int (*crypto_fini)(struct drbg_state *);
};

struct driver_attribute {
	struct attribute attr;
	ssize_t (*show)(struct device_driver *, char *);
	ssize_t (*store)(struct device_driver *, const char *, size_t);
};

struct module_kobject;

struct driver_private {
	struct kobject kobj;
	struct klist klist_devices;
	struct klist_node knode_bus;
	struct module_kobject *mkobj;
	struct device_driver *driver;
};

struct drm_object_properties;

struct drm_mode_object {
	uint32_t id;
	uint32_t type;
	struct drm_object_properties *properties;
	struct kref refcount;
	void (*free_cb)(struct kref *);
};

struct drm_device;

struct drm_format_info;

struct drm_framebuffer_funcs;

struct drm_gem_object;

struct drm_framebuffer {
	struct drm_device *dev;
	struct list_head head;
	struct drm_mode_object base;
	char comm[16];
	const struct drm_format_info *format;
	const struct drm_framebuffer_funcs *funcs;
	unsigned int pitches[4];
	unsigned int offsets[4];
	uint64_t modifier;
	unsigned int width;
	unsigned int height;
	int flags;
	struct list_head filp_head;
	struct drm_gem_object *obj[4];
};

struct drm_afbc_framebuffer {
	struct drm_framebuffer base;
	u32 block_width;
	u32 block_height;
	u32 aligned_width;
	u32 aligned_height;
	u32 offset;
	u32 afbc_size;
};

struct drm_rect {
	int x1;
	int y1;
	int x2;
	int y2;
};

struct drm_atomic_helper_damage_iter {
	struct drm_rect plane_src;
	const struct drm_rect *clips;
	uint32_t num_clips;
	uint32_t curr_clip;
	bool full_update;
};

struct drm_modeset_acquire_ctx;

struct drm_atomic_state {
	struct kref ref;
	struct drm_device *dev;
	bool allow_modeset: 1;
	bool legacy_cursor_update: 1;
	bool async_update: 1;
	bool duplicated: 1;
	struct __drm_planes_state *planes;
	struct __drm_crtcs_state *crtcs;
	int num_connector;
	struct __drm_connnectors_state *connectors;
	int num_private_objs;
	struct __drm_private_objs_state *private_objs;
	struct drm_modeset_acquire_ctx *acquire_ctx;
	struct drm_crtc_commit *fake_commit;
	struct work_struct commit_work;
};

struct drm_audio_component_ops;

struct drm_audio_component_audio_ops;

struct drm_audio_component {
	struct device *dev;
	const struct drm_audio_component_ops *ops;
	const struct drm_audio_component_audio_ops *audio_ops;
	struct completion master_bind_complete;
};

struct drm_audio_component_audio_ops {
	void *audio_ptr;
	void (*pin_eld_notify)(void *, int, int);
	int (*pin2port)(void *, int);
	int (*master_bind)(struct device *, struct drm_audio_component *);
	void (*master_unbind)(struct device *, struct drm_audio_component *);
};

struct drm_audio_component_ops {
	struct module *owner;
	long unsigned int (*get_power)(struct device *);
	void (*put_power)(struct device *, long unsigned int);
	void (*codec_wake_override)(struct device *, bool);
	int (*get_cdclk_freq)(struct device *);
	int (*sync_audio_rate)(struct device *, int, int, int);
	int (*get_eld)(struct device *, int, int, bool *, unsigned char *, int);
};

struct drm_auth {
	drm_magic_t magic;
};

struct drm_modeset_lock {
	struct ww_mutex mutex;
	struct list_head head;
};

struct drm_private_state_funcs;

struct drm_private_obj {
	struct list_head head;
	struct drm_modeset_lock lock;
	struct drm_private_state *state;
	const struct drm_private_state_funcs *funcs;
};

struct drm_encoder;

struct drm_bridge_timings;

struct drm_bridge_funcs;

struct i2c_adapter;

struct drm_bridge {
	struct drm_private_obj base;
	struct drm_device *dev;
	struct drm_encoder *encoder;
	struct list_head chain_node;
	struct device_node *of_node;
	struct list_head list;
	const struct drm_bridge_timings *timings;
	const struct drm_bridge_funcs *funcs;
	void *driver_private;
	enum drm_bridge_ops ops;
	int type;
	bool interlace_allowed;
	bool ycbcr_420_allowed;
	bool pre_enable_prev_first;
	struct i2c_adapter *ddc;
	struct mutex hpd_mutex;
	void (*hpd_cb)(void *, enum drm_connector_status);
	void *hpd_data;
	const char *vendor;
	const char *product;
	unsigned int supported_formats;
	unsigned int max_bpc;
	struct device *hdmi_audio_dev;
	int hdmi_audio_max_i2s_playback_channels;
	unsigned int hdmi_audio_spdif_playback: 1;
	int hdmi_audio_dai_port;
};

struct hdmi_codec_daifmt;

struct hdmi_codec_params;

struct drm_display_info;

struct drm_display_mode;

struct drm_bridge_state;

struct drm_bridge_funcs {
	int (*attach)(struct drm_bridge *, enum drm_bridge_attach_flags);
	void (*detach)(struct drm_bridge *);
	enum drm_mode_status (*mode_valid)(struct drm_bridge *, const struct drm_display_info *, const struct drm_display_mode *);
	bool (*mode_fixup)(struct drm_bridge *, const struct drm_display_mode *, struct drm_display_mode *);
	void (*disable)(struct drm_bridge *);
	void (*post_disable)(struct drm_bridge *);
	void (*mode_set)(struct drm_bridge *, const struct drm_display_mode *, const struct drm_display_mode *);
	void (*pre_enable)(struct drm_bridge *);
	void (*enable)(struct drm_bridge *);
	void (*atomic_pre_enable)(struct drm_bridge *, struct drm_bridge_state *);
	void (*atomic_enable)(struct drm_bridge *, struct drm_bridge_state *);
	void (*atomic_disable)(struct drm_bridge *, struct drm_bridge_state *);
	void (*atomic_post_disable)(struct drm_bridge *, struct drm_bridge_state *);
	struct drm_bridge_state * (*atomic_duplicate_state)(struct drm_bridge *);
	void (*atomic_destroy_state)(struct drm_bridge *, struct drm_bridge_state *);
	u32 * (*atomic_get_output_bus_fmts)(struct drm_bridge *, struct drm_bridge_state *, struct drm_crtc_state *, struct drm_connector_state *, unsigned int *);
	u32 * (*atomic_get_input_bus_fmts)(struct drm_bridge *, struct drm_bridge_state *, struct drm_crtc_state *, struct drm_connector_state *, u32, unsigned int *);
	int (*atomic_check)(struct drm_bridge *, struct drm_bridge_state *, struct drm_crtc_state *, struct drm_connector_state *);
	struct drm_bridge_state * (*atomic_reset)(struct drm_bridge *);
	enum drm_connector_status (*detect)(struct drm_bridge *);
	int (*get_modes)(struct drm_bridge *, struct drm_connector *);
	const struct drm_edid * (*edid_read)(struct drm_bridge *, struct drm_connector *);
	void (*hpd_notify)(struct drm_bridge *, enum drm_connector_status);
	void (*hpd_enable)(struct drm_bridge *);
	void (*hpd_disable)(struct drm_bridge *);
	enum drm_mode_status (*hdmi_tmds_char_rate_valid)(const struct drm_bridge *, const struct drm_display_mode *, long long unsigned int);
	int (*hdmi_clear_infoframe)(struct drm_bridge *, enum hdmi_infoframe_type);
	int (*hdmi_write_infoframe)(struct drm_bridge *, enum hdmi_infoframe_type, const u8 *, size_t);
	int (*hdmi_audio_startup)(struct drm_connector *, struct drm_bridge *);
	int (*hdmi_audio_prepare)(struct drm_connector *, struct drm_bridge *, struct hdmi_codec_daifmt *, struct hdmi_codec_params *);
	void (*hdmi_audio_shutdown)(struct drm_connector *, struct drm_bridge *);
	int (*hdmi_audio_mute_stream)(struct drm_connector *, struct drm_bridge *, bool, int);
	void (*debugfs_init)(struct drm_bridge *, struct dentry *);
};

struct drm_private_state {
	struct drm_atomic_state *state;
	struct drm_private_obj *obj;
};

struct drm_bus_cfg {
	u32 format;
	u32 flags;
};

struct drm_bridge_state {
	struct drm_private_state base;
	struct drm_bridge *bridge;
	struct drm_bus_cfg input_bus_cfg;
	struct drm_bus_cfg output_bus_cfg;
};

struct drm_bridge_timings {
	u32 input_bus_flags;
	u32 setup_time_ps;
	u32 hold_time_ps;
	bool dual_link;
};

struct drm_buddy_block;

struct drm_buddy {
	struct list_head *free_list;
	struct drm_buddy_block **roots;
	unsigned int n_roots;
	unsigned int max_order;
	u64 chunk_size;
	u64 size;
	u64 avail;
	u64 clear_avail;
};

struct drm_buddy_block {
	u64 header;
	struct drm_buddy_block *left;
	struct drm_buddy_block *right;
	struct drm_buddy_block *parent;
	void *private;
	struct list_head link;
	struct list_head tmp_link;
};

struct drm_client {
	int idx;
	int auth;
	long unsigned int pid;
	long unsigned int uid;
	long unsigned int magic;
	long unsigned int iocs;
};

struct drm_client32 {
	int idx;
	int auth;
	u32 pid;
	u32 uid;
	u32 magic;
	u32 iocs;
};

typedef struct drm_client32 drm_client32_t;

struct drm_clip_rect {
	short unsigned int x1;
	short unsigned int y1;
	short unsigned int x2;
	short unsigned int y2;
};

struct drm_connector_tv_margins {
	unsigned int bottom;
	unsigned int left;
	unsigned int right;
	unsigned int top;
};

struct drm_cmdline_mode {
	char name[32];
	bool specified;
	bool refresh_specified;
	bool bpp_specified;
	unsigned int pixel_clock;
	int xres;
	int yres;
	int bpp;
	int refresh;
	bool rb;
	bool interlace;
	bool cvt;
	bool margins;
	enum drm_connector_force force;
	unsigned int rotation_reflection;
	enum drm_panel_orientation panel_orientation;
	struct drm_connector_tv_margins tv_margins;
	enum drm_connector_tv_mode tv_mode;
	bool tv_mode_specified;
};

struct drm_color_ctm {
	__u64 matrix[9];
};

struct drm_color_lut {
	__u16 red;
	__u16 green;
	__u16 blue;
	__u16 reserved;
};

struct drm_conn_prop_enum_list {
	int type;
	const char *name;
	struct ida ida;
};

struct drm_scrambling {
	bool supported;
	bool low_rates;
};

struct drm_scdc {
	bool supported;
	bool read_request;
	struct drm_scrambling scrambling;
};

struct drm_hdmi_dsc_cap {
	bool v_1p2;
	bool native_420;
	bool all_bpp;
	u8 bpc_supported;
	u8 max_slices;
	int clk_per_slice;
	u8 max_lanes;
	u8 max_frl_rate_per_lane;
	u8 total_chunk_kbytes;
};

struct drm_hdmi_info {
	struct drm_scdc scdc;
	long unsigned int y420_vdb_modes[4];
	long unsigned int y420_cmdb_modes[4];
	u8 y420_dc_modes;
	u8 max_frl_rate_per_lane;
	u8 max_lanes;
	struct drm_hdmi_dsc_cap dsc_cap;
};

struct drm_monitor_range_info {
	u16 min_vfreq;
	u16 max_vfreq;
};

struct drm_luminance_range_info {
	u32 min_luminance;
	u32 max_luminance;
};

struct drm_display_info {
	unsigned int width_mm;
	unsigned int height_mm;
	unsigned int bpc;
	enum subpixel_order subpixel_order;
	int panel_orientation;
	u32 color_formats;
	const u32 *bus_formats;
	unsigned int num_bus_formats;
	u32 bus_flags;
	int max_tmds_clock;
	bool dvi_dual;
	bool is_hdmi;
	bool has_audio;
	bool has_hdmi_infoframe;
	bool rgb_quant_range_selectable;
	u8 edid_hdmi_rgb444_dc_modes;
	u8 edid_hdmi_ycbcr444_dc_modes;
	u8 cea_rev;
	struct drm_hdmi_info hdmi;
	bool non_desktop;
	struct drm_monitor_range_info monitor_range;
	struct drm_luminance_range_info luminance_range;
	u8 mso_stream_count;
	u8 mso_pixel_overlap;
	u32 max_dsc_bpp;
	u8 *vics;
	int vics_len;
	u32 quirks;
	u16 source_physical_address;
};

struct drm_property;

struct drm_object_properties {
	int count;
	struct drm_property *properties[64];
	uint64_t values[64];
};

struct drm_privacy_screen;

struct hdr_static_metadata {
	__u8 eotf;
	__u8 metadata_type;
	__u16 max_cll;
	__u16 max_fall;
	__u16 min_cll;
};

struct hdr_sink_metadata {
	__u32 metadata_type;
	union {
		struct hdr_static_metadata hdmi_type1;
	};
};

struct hdmi_any_infoframe {
	enum hdmi_infoframe_type type;
	unsigned char version;
	unsigned char length;
};

struct hdmi_avi_infoframe {
	enum hdmi_infoframe_type type;
	unsigned char version;
	unsigned char length;
	bool itc;
	unsigned char pixel_repeat;
	enum hdmi_colorspace colorspace;
	enum hdmi_scan_mode scan_mode;
	enum hdmi_colorimetry colorimetry;
	enum hdmi_picture_aspect picture_aspect;
	enum hdmi_active_aspect active_aspect;
	enum hdmi_extended_colorimetry extended_colorimetry;
	enum hdmi_quantization_range quantization_range;
	enum hdmi_nups nups;
	unsigned char video_code;
	enum hdmi_ycc_quantization_range ycc_quantization_range;
	enum hdmi_content_type content_type;
	short unsigned int top_bar;
	short unsigned int bottom_bar;
	short unsigned int left_bar;
	short unsigned int right_bar;
};

struct hdmi_spd_infoframe {
	enum hdmi_infoframe_type type;
	unsigned char version;
	unsigned char length;
	char vendor[8];
	char product[16];
	enum hdmi_spd_sdi sdi;
};

struct hdmi_vendor_infoframe {
	enum hdmi_infoframe_type type;
	unsigned char version;
	unsigned char length;
	unsigned int oui;
	u8 vic;
	enum hdmi_3d_structure s3d_struct;
	unsigned int s3d_ext_data;
};

union hdmi_vendor_any_infoframe {
	struct {
		enum hdmi_infoframe_type type;
		unsigned char version;
		unsigned char length;
		unsigned int oui;
	} any;
	struct hdmi_vendor_infoframe hdmi;
};

struct hdmi_audio_infoframe {
	enum hdmi_infoframe_type type;
	unsigned char version;
	unsigned char length;
	unsigned char channels;
	enum hdmi_audio_coding_type coding_type;
	enum hdmi_audio_sample_size sample_size;
	enum hdmi_audio_sample_frequency sample_frequency;
	enum hdmi_audio_coding_type_ext coding_type_ext;
	unsigned char channel_allocation;
	unsigned char level_shift_value;
	bool downmix_inhibit;
};

struct hdmi_drm_infoframe {
	enum hdmi_infoframe_type type;
	unsigned char version;
	unsigned char length;
	enum hdmi_eotf eotf;
	enum hdmi_metadata_type metadata_type;
	struct {
		u16 x;
		u16 y;
	} display_primaries[3];
	struct {
		u16 x;
		u16 y;
	} white_point;
	u16 max_display_mastering_luminance;
	u16 min_display_mastering_luminance;
	u16 max_cll;
	u16 max_fall;
};

union hdmi_infoframe {
	struct hdmi_any_infoframe any;
	struct hdmi_avi_infoframe avi;
	struct hdmi_spd_infoframe spd;
	union hdmi_vendor_any_infoframe vendor;
	struct hdmi_audio_infoframe audio;
	struct hdmi_drm_infoframe drm;
};

struct drm_connector_hdmi_infoframe {
	union hdmi_infoframe data;
	bool set;
};

struct drm_connector_hdmi_funcs;

struct drm_connector_hdmi {
	unsigned char vendor[8];
	unsigned char product[16];
	long unsigned int supported_formats;
	const struct drm_connector_hdmi_funcs *funcs;
	struct {
		struct mutex lock;
		struct drm_connector_hdmi_infoframe audio;
	} infoframes;
};

struct drm_connector_hdmi_audio_funcs;

struct drm_connector_hdmi_audio {
	const struct drm_connector_hdmi_audio_funcs *funcs;
	struct platform_device *codec_pdev;
	struct mutex lock;
	void (*plugged_cb)(struct device *, bool);
	struct device *plugged_cb_dev;
	bool last_state;
	int dai_port;
};

struct drm_connector_funcs;

struct drm_property_blob;

struct drm_connector_helper_funcs;

struct drm_tile_group;

struct drm_connector {
	struct drm_device *dev;
	struct device *kdev;
	struct device_attribute *attr;
	struct fwnode_handle *fwnode;
	struct list_head head;
	struct list_head global_connector_list_entry;
	struct drm_mode_object base;
	char *name;
	struct mutex mutex;
	unsigned int index;
	int connector_type;
	int connector_type_id;
	bool interlace_allowed;
	bool doublescan_allowed;
	bool stereo_allowed;
	bool ycbcr_420_allowed;
	enum drm_connector_registration_state registration_state;
	struct list_head modes;
	enum drm_connector_status status;
	struct list_head probed_modes;
	struct drm_display_info display_info;
	const struct drm_connector_funcs *funcs;
	struct drm_property_blob *edid_blob_ptr;
	struct drm_object_properties properties;
	struct drm_property *scaling_mode_property;
	struct drm_property *vrr_capable_property;
	struct drm_property *colorspace_property;
	struct drm_property_blob *path_blob_ptr;
	unsigned int max_bpc;
	struct drm_property *max_bpc_property;
	struct drm_privacy_screen *privacy_screen;
	struct notifier_block privacy_screen_notifier;
	struct drm_property *privacy_screen_sw_state_property;
	struct drm_property *privacy_screen_hw_state_property;
	struct drm_property *broadcast_rgb_property;
	uint8_t polled;
	int dpms;
	const struct drm_connector_helper_funcs *helper_private;
	struct drm_cmdline_mode cmdline_mode;
	enum drm_connector_force force;
	const struct drm_edid *edid_override;
	struct mutex edid_override_mutex;
	u64 epoch_counter;
	u32 possible_encoders;
	struct drm_encoder *encoder;
	uint8_t eld[128];
	struct mutex eld_mutex;
	bool latency_present[2];
	int video_latency[2];
	int audio_latency[2];
	struct i2c_adapter *ddc;
	int null_edid_counter;
	unsigned int bad_edid_counter;
	bool edid_corrupt;
	u8 real_edid_checksum;
	struct dentry *debugfs_entry;
	struct drm_connector_state *state;
	struct drm_property_blob *tile_blob_ptr;
	bool has_tile;
	struct drm_tile_group *tile_group;
	bool tile_is_single_monitor;
	uint8_t num_h_tile;
	uint8_t num_v_tile;
	uint8_t tile_h_loc;
	uint8_t tile_v_loc;
	uint16_t tile_h_size;
	uint16_t tile_v_size;
	struct llist_node free_node;
	struct hdr_sink_metadata hdr_sink_metadata;
	struct drm_connector_hdmi hdmi;
	struct drm_connector_hdmi_audio hdmi_audio;
};

struct drm_printer;

struct drm_connector_funcs {
	int (*dpms)(struct drm_connector *, int);
	void (*reset)(struct drm_connector *);
	enum drm_connector_status (*detect)(struct drm_connector *, bool);
	void (*force)(struct drm_connector *);
	int (*fill_modes)(struct drm_connector *, uint32_t, uint32_t);
	int (*set_property)(struct drm_connector *, struct drm_property *, uint64_t);
	int (*late_register)(struct drm_connector *);
	void (*early_unregister)(struct drm_connector *);
	void (*destroy)(struct drm_connector *);
	struct drm_connector_state * (*atomic_duplicate_state)(struct drm_connector *);
	void (*atomic_destroy_state)(struct drm_connector *, struct drm_connector_state *);
	int (*atomic_set_property)(struct drm_connector *, struct drm_connector_state *, struct drm_property *, uint64_t);
	int (*atomic_get_property)(struct drm_connector *, const struct drm_connector_state *, struct drm_property *, uint64_t *);
	void (*atomic_print_state)(struct drm_printer *, const struct drm_connector_state *);
	void (*oob_hotplug_event)(struct drm_connector *, enum drm_connector_status);
	void (*debugfs_init)(struct drm_connector *, struct dentry *);
};

struct drm_connector_hdmi_audio_funcs {
	int (*startup)(struct drm_connector *);
	int (*prepare)(struct drm_connector *, struct hdmi_codec_daifmt *, struct hdmi_codec_params *);
	void (*shutdown)(struct drm_connector *);
	int (*mute_stream)(struct drm_connector *, bool, int);
};

struct drm_connector_hdmi_funcs {
	enum drm_mode_status (*tmds_char_rate_valid)(const struct drm_connector *, const struct drm_display_mode *, long long unsigned int);
	int (*clear_infoframe)(struct drm_connector *, enum hdmi_infoframe_type);
	int (*write_infoframe)(struct drm_connector *, enum hdmi_infoframe_type, const u8 *, size_t);
	const struct drm_edid * (*read_edid)(struct drm_connector *);
};

struct drm_connector_hdmi_state {
	enum drm_hdmi_broadcast_rgb broadcast_rgb;
	struct {
		struct drm_connector_hdmi_infoframe avi;
		struct drm_connector_hdmi_infoframe hdr_drm;
		struct drm_connector_hdmi_infoframe spd;
		struct drm_connector_hdmi_infoframe hdmi;
	} infoframes;
	bool is_limited_range;
	unsigned int output_bpc;
	enum hdmi_colorspace output_format;
	long long unsigned int tmds_char_rate;
};

struct drm_writeback_connector;

struct drm_writeback_job;

struct drm_connector_helper_funcs {
	int (*get_modes)(struct drm_connector *);
	int (*detect_ctx)(struct drm_connector *, struct drm_modeset_acquire_ctx *, bool);
	enum drm_mode_status (*mode_valid)(struct drm_connector *, struct drm_display_mode *);
	int (*mode_valid_ctx)(struct drm_connector *, struct drm_display_mode *, struct drm_modeset_acquire_ctx *, enum drm_mode_status *);
	struct drm_encoder * (*best_encoder)(struct drm_connector *);
	struct drm_encoder * (*atomic_best_encoder)(struct drm_connector *, struct drm_atomic_state *);
	int (*atomic_check)(struct drm_connector *, struct drm_atomic_state *);
	void (*atomic_commit)(struct drm_connector *, struct drm_atomic_state *);
	int (*prepare_writeback_job)(struct drm_writeback_connector *, struct drm_writeback_job *);
	void (*cleanup_writeback_job)(struct drm_writeback_connector *, struct drm_writeback_job *);
	void (*enable_hpd)(struct drm_connector *);
	void (*disable_hpd)(struct drm_connector *);
};

struct drm_connector_list_iter {
	struct drm_device *dev;
	struct drm_connector *conn;
};

struct drm_tv_connector_state {
	enum drm_mode_subconnector select_subconnector;
	enum drm_mode_subconnector subconnector;
	struct drm_connector_tv_margins margins;
	unsigned int legacy_mode;
	unsigned int mode;
	unsigned int brightness;
	unsigned int contrast;
	unsigned int flicker_reduction;
	unsigned int overscan;
	unsigned int saturation;
	unsigned int hue;
};

struct drm_connector_state {
	struct drm_connector *connector;
	struct drm_crtc *crtc;
	struct drm_encoder *best_encoder;
	enum drm_link_status link_status;
	struct drm_atomic_state *state;
	struct drm_crtc_commit *commit;
	struct drm_tv_connector_state tv;
	bool self_refresh_aware;
	enum hdmi_picture_aspect picture_aspect_ratio;
	unsigned int content_type;
	unsigned int hdcp_content_type;
	unsigned int scaling_mode;
	unsigned int content_protection;
	enum drm_colorspace colorspace;
	struct drm_writeback_job *writeback_job;
	u8 max_requested_bpc;
	u8 max_bpc;
	enum drm_privacy_screen_status privacy_screen_sw_state;
	struct drm_property_blob *hdr_output_metadata;
	struct drm_connector_hdmi_state hdmi;
};

struct drm_display_mode {
	int clock;
	u16 hdisplay;
	u16 hsync_start;
	u16 hsync_end;
	u16 htotal;
	u16 hskew;
	u16 vdisplay;
	u16 vsync_start;
	u16 vsync_end;
	u16 vtotal;
	u16 vscan;
	u32 flags;
	int crtc_clock;
	u16 crtc_hdisplay;
	u16 crtc_hblank_start;
	u16 crtc_hblank_end;
	u16 crtc_hsync_start;
	u16 crtc_hsync_end;
	u16 crtc_htotal;
	u16 crtc_hskew;
	u16 crtc_vdisplay;
	u16 crtc_vblank_start;
	u16 crtc_vblank_end;
	u16 crtc_vsync_start;
	u16 crtc_vsync_end;
	u16 crtc_vtotal;
	u16 width_mm;
	u16 height_mm;
	u8 type;
	bool expose_to_userspace;
	struct list_head head;
	char name[32];
	enum drm_mode_status status;
	enum hdmi_picture_aspect picture_aspect_ratio;
};

struct drm_crtc_crc_entry;

struct drm_crtc_crc {
	spinlock_t lock;
	const char *source;
	bool opened;
	bool overflow;
	struct drm_crtc_crc_entry *entries;
	int head;
	int tail;
	size_t values_cnt;
	wait_queue_head_t wq;
};

struct drm_crtc_funcs;

struct drm_crtc_helper_funcs;

struct drm_self_refresh_data;

struct drm_crtc {
	struct drm_device *dev;
	struct device_node *port;
	struct list_head head;
	char *name;
	struct drm_modeset_lock mutex;
	struct drm_mode_object base;
	struct drm_plane *primary;
	struct drm_plane *cursor;
	unsigned int index;
	int cursor_x;
	int cursor_y;
	bool enabled;
	struct drm_display_mode mode;
	struct drm_display_mode hwmode;
	int x;
	int y;
	const struct drm_crtc_funcs *funcs;
	uint32_t gamma_size;
	uint16_t *gamma_store;
	const struct drm_crtc_helper_funcs *helper_private;
	struct drm_object_properties properties;
	struct drm_property *scaling_filter_property;
	struct drm_crtc_state *state;
	struct list_head commit_list;
	spinlock_t commit_lock;
	struct dentry *debugfs_entry;
	struct drm_crtc_crc crc;
	unsigned int fence_context;
	spinlock_t fence_lock;
	long unsigned int fence_seqno;
	char timeline_name[32];
	struct drm_self_refresh_data *self_refresh_data;
};

struct drm_pending_vblank_event;

struct drm_crtc_commit {
	struct drm_crtc *crtc;
	struct kref ref;
	struct completion flip_done;
	struct completion hw_done;
	struct completion cleanup_done;
	struct list_head commit_entry;
	struct drm_pending_vblank_event *event;
	bool abort_completion;
};

struct drm_crtc_crc_entry {
	bool has_frame_counter;
	uint32_t frame;
	uint32_t crcs[10];
};

struct drm_file;

struct drm_mode_set;

struct drm_crtc_funcs {
	void (*reset)(struct drm_crtc *);
	int (*cursor_set)(struct drm_crtc *, struct drm_file *, uint32_t, uint32_t, uint32_t);
	int (*cursor_set2)(struct drm_crtc *, struct drm_file *, uint32_t, uint32_t, uint32_t, int32_t, int32_t);
	int (*cursor_move)(struct drm_crtc *, int, int);
	int (*gamma_set)(struct drm_crtc *, u16 *, u16 *, u16 *, uint32_t, struct drm_modeset_acquire_ctx *);
	void (*destroy)(struct drm_crtc *);
	int (*set_config)(struct drm_mode_set *, struct drm_modeset_acquire_ctx *);
	int (*page_flip)(struct drm_crtc *, struct drm_framebuffer *, struct drm_pending_vblank_event *, uint32_t, struct drm_modeset_acquire_ctx *);
	int (*page_flip_target)(struct drm_crtc *, struct drm_framebuffer *, struct drm_pending_vblank_event *, uint32_t, uint32_t, struct drm_modeset_acquire_ctx *);
	int (*set_property)(struct drm_crtc *, struct drm_property *, uint64_t);
	struct drm_crtc_state * (*atomic_duplicate_state)(struct drm_crtc *);
	void (*atomic_destroy_state)(struct drm_crtc *, struct drm_crtc_state *);
	int (*atomic_set_property)(struct drm_crtc *, struct drm_crtc_state *, struct drm_property *, uint64_t);
	int (*atomic_get_property)(struct drm_crtc *, const struct drm_crtc_state *, struct drm_property *, uint64_t *);
	int (*late_register)(struct drm_crtc *);
	void (*early_unregister)(struct drm_crtc *);
	int (*set_crc_source)(struct drm_crtc *, const char *);
	int (*verify_crc_source)(struct drm_crtc *, const char *, size_t *);
	const char * const * (*get_crc_sources)(struct drm_crtc *, size_t *);
	void (*atomic_print_state)(struct drm_printer *, const struct drm_crtc_state *);
	u32 (*get_vblank_counter)(struct drm_crtc *);
	int (*enable_vblank)(struct drm_crtc *);
	void (*disable_vblank)(struct drm_crtc *);
	bool (*get_vblank_timestamp)(struct drm_crtc *, int *, ktime_t *, bool);
};

struct drm_crtc_get_sequence {
	__u32 crtc_id;
	__u32 active;
	__u64 sequence;
	__s64 sequence_ns;
};

struct drm_crtc_helper_funcs {
	void (*dpms)(struct drm_crtc *, int);
	void (*prepare)(struct drm_crtc *);
	void (*commit)(struct drm_crtc *);
	enum drm_mode_status (*mode_valid)(struct drm_crtc *, const struct drm_display_mode *);
	bool (*mode_fixup)(struct drm_crtc *, const struct drm_display_mode *, struct drm_display_mode *);
	int (*mode_set)(struct drm_crtc *, struct drm_display_mode *, struct drm_display_mode *, int, int, struct drm_framebuffer *);
	void (*mode_set_nofb)(struct drm_crtc *);
	int (*mode_set_base)(struct drm_crtc *, int, int, struct drm_framebuffer *);
	int (*mode_set_base_atomic)(struct drm_crtc *, struct drm_framebuffer *, int, int, enum mode_set_atomic);
	void (*disable)(struct drm_crtc *);
	int (*atomic_check)(struct drm_crtc *, struct drm_atomic_state *);
	void (*atomic_begin)(struct drm_crtc *, struct drm_atomic_state *);
	void (*atomic_flush)(struct drm_crtc *, struct drm_atomic_state *);
	void (*atomic_enable)(struct drm_crtc *, struct drm_atomic_state *);
	void (*atomic_disable)(struct drm_crtc *, struct drm_atomic_state *);
	bool (*get_scanout_position)(struct drm_crtc *, bool, int *, int *, ktime_t *, ktime_t *, const struct drm_display_mode *);
};

struct drm_crtc_queue_sequence {
	__u32 crtc_id;
	__u32 flags;
	__u64 sequence;
	__u64 user_data;
};

struct drm_crtc_state {
	struct drm_crtc *crtc;
	bool enable;
	bool active;
	bool planes_changed: 1;
	bool mode_changed: 1;
	bool active_changed: 1;
	bool connectors_changed: 1;
	bool zpos_changed: 1;
	bool color_mgmt_changed: 1;
	bool no_vblank: 1;
	u32 plane_mask;
	u32 connector_mask;
	u32 encoder_mask;
	struct drm_display_mode adjusted_mode;
	struct drm_display_mode mode;
	struct drm_property_blob *mode_blob;
	struct drm_property_blob *degamma_lut;
	struct drm_property_blob *ctm;
	struct drm_property_blob *gamma_lut;
	u32 target_vblank;
	bool async_flip;
	bool vrr_enabled;
	bool self_refresh_active;
	enum drm_scaling_filter scaling_filter;
	struct drm_pending_vblank_event *event;
	struct drm_crtc_commit *commit;
	struct drm_atomic_state *state;
};

struct drm_debugfs_info {
	const char *name;
	int (*show)(struct seq_file *, void *);
	u32 driver_features;
	void *data;
};

struct drm_debugfs_entry {
	struct drm_device *dev;
	struct drm_debugfs_info file;
	struct list_head list;
};

struct drm_mode_config_funcs;

struct drm_mode_config_helper_funcs;

struct drm_mode_config {
	struct mutex mutex;
	struct drm_modeset_lock connection_mutex;
	struct drm_modeset_acquire_ctx *acquire_ctx;
	struct mutex idr_mutex;
	struct idr object_idr;
	struct idr tile_idr;
	struct mutex fb_lock;
	int num_fb;
	struct list_head fb_list;
	spinlock_t connector_list_lock;
	int num_connector;
	struct ida connector_ida;
	struct list_head connector_list;
	struct llist_head connector_free_list;
	struct work_struct connector_free_work;
	int num_encoder;
	struct list_head encoder_list;
	int num_total_plane;
	struct list_head plane_list;
	struct raw_spinlock panic_lock;
	int num_crtc;
	struct list_head crtc_list;
	struct list_head property_list;
	struct list_head privobj_list;
	int min_width;
	int min_height;
	int max_width;
	int max_height;
	const struct drm_mode_config_funcs *funcs;
	bool poll_enabled;
	bool poll_running;
	bool delayed_event;
	struct delayed_work output_poll_work;
	struct mutex blob_lock;
	struct list_head property_blob_list;
	struct drm_property *edid_property;
	struct drm_property *dpms_property;
	struct drm_property *path_property;
	struct drm_property *tile_property;
	struct drm_property *link_status_property;
	struct drm_property *plane_type_property;
	struct drm_property *prop_src_x;
	struct drm_property *prop_src_y;
	struct drm_property *prop_src_w;
	struct drm_property *prop_src_h;
	struct drm_property *prop_crtc_x;
	struct drm_property *prop_crtc_y;
	struct drm_property *prop_crtc_w;
	struct drm_property *prop_crtc_h;
	struct drm_property *prop_fb_id;
	struct drm_property *prop_in_fence_fd;
	struct drm_property *prop_out_fence_ptr;
	struct drm_property *prop_crtc_id;
	struct drm_property *prop_fb_damage_clips;
	struct drm_property *prop_active;
	struct drm_property *prop_mode_id;
	struct drm_property *prop_vrr_enabled;
	struct drm_property *dvi_i_subconnector_property;
	struct drm_property *dvi_i_select_subconnector_property;
	struct drm_property *dp_subconnector_property;
	struct drm_property *tv_subconnector_property;
	struct drm_property *tv_select_subconnector_property;
	struct drm_property *legacy_tv_mode_property;
	struct drm_property *tv_mode_property;
	struct drm_property *tv_left_margin_property;
	struct drm_property *tv_right_margin_property;
	struct drm_property *tv_top_margin_property;
	struct drm_property *tv_bottom_margin_property;
	struct drm_property *tv_brightness_property;
	struct drm_property *tv_contrast_property;
	struct drm_property *tv_flicker_reduction_property;
	struct drm_property *tv_overscan_property;
	struct drm_property *tv_saturation_property;
	struct drm_property *tv_hue_property;
	struct drm_property *scaling_mode_property;
	struct drm_property *aspect_ratio_property;
	struct drm_property *content_type_property;
	struct drm_property *degamma_lut_property;
	struct drm_property *degamma_lut_size_property;
	struct drm_property *ctm_property;
	struct drm_property *gamma_lut_property;
	struct drm_property *gamma_lut_size_property;
	struct drm_property *suggested_x_property;
	struct drm_property *suggested_y_property;
	struct drm_property *non_desktop_property;
	struct drm_property *panel_orientation_property;
	struct drm_property *writeback_fb_id_property;
	struct drm_property *writeback_pixel_formats_property;
	struct drm_property *writeback_out_fence_ptr_property;
	struct drm_property *hdr_output_metadata_property;
	struct drm_property *content_protection_property;
	struct drm_property *hdcp_content_type_property;
	uint32_t preferred_depth;
	uint32_t prefer_shadow;
	bool quirk_addfb_prefer_xbgr_30bpp;
	bool quirk_addfb_prefer_host_byte_order;
	bool async_page_flip;
	bool fb_modifiers_not_supported;
	bool normalize_zpos;
	struct drm_property *modifiers_property;
	struct drm_property *size_hints_property;
	uint32_t cursor_width;
	uint32_t cursor_height;
	struct drm_atomic_state *suspend_state;
	const struct drm_mode_config_helper_funcs *helper_private;
};

struct drm_vram_mm;

struct drm_fb_helper;

struct drm_driver;

struct drm_minor;

struct drm_master;

struct drm_vblank_crtc;

struct drm_vma_offset_manager;

struct drm_device {
	int if_version;
	struct kref ref;
	struct device *dev;
	struct {
		struct list_head resources;
		void *final_kfree;
		spinlock_t lock;
	} managed;
	const struct drm_driver *driver;
	void *dev_private;
	struct drm_minor *primary;
	struct drm_minor *render;
	struct drm_minor *accel;
	bool registered;
	struct drm_master *master;
	u32 driver_features;
	bool unplugged;
	struct inode *anon_inode;
	char *unique;
	struct mutex struct_mutex;
	struct mutex master_mutex;
	atomic_t open_count;
	struct mutex filelist_mutex;
	struct list_head filelist;
	struct list_head filelist_internal;
	struct mutex clientlist_mutex;
	struct list_head clientlist;
	bool vblank_disable_immediate;
	struct drm_vblank_crtc *vblank;
	spinlock_t vblank_time_lock;
	spinlock_t vbl_lock;
	u32 max_vblank_count;
	struct list_head vblank_event_list;
	spinlock_t event_lock;
	unsigned int num_crtcs;
	struct drm_mode_config mode_config;
	struct mutex object_name_lock;
	struct idr object_name_idr;
	struct drm_vma_offset_manager *vma_offset_manager;
	struct drm_vram_mm *vram_mm;
	enum switch_power_state switch_power_state;
	struct drm_fb_helper *fb_helper;
	struct dentry *debugfs_root;
};

struct drm_dmi_panel_orientation_data {
	int width;
	int height;
	const char * const *bios_dates;
	int orientation;
};

struct drm_dp_as_sdp {
	unsigned char sdp_type;
	unsigned char revision;
	unsigned char length;
	int vtotal;
	int target_rr;
	int duration_incr_ms;
	int duration_decr_ms;
	bool target_rr_divider;
	enum operation_mode mode;
};

struct rt_mutex_base {
	raw_spinlock_t wait_lock;
	struct rb_root_cached waiters;
	struct task_struct *owner;
};

struct rt_mutex {
	struct rt_mutex_base rtmutex;
};

struct i2c_algorithm;

struct i2c_lock_operations;

struct i2c_bus_recovery_info;

struct i2c_adapter_quirks;

struct i2c_adapter {
	struct module *owner;
	unsigned int class;
	const struct i2c_algorithm *algo;
	void *algo_data;
	const struct i2c_lock_operations *lock_ops;
	struct rt_mutex bus_lock;
	struct rt_mutex mux_lock;
	int timeout;
	int retries;
	struct device dev;
	long unsigned int locked_flags;
	int nr;
	char name[48];
	struct completion dev_released;
	struct mutex userspace_clients_lock;
	struct list_head userspace_clients;
	struct i2c_bus_recovery_info *bus_recovery_info;
	const struct i2c_adapter_quirks *quirks;
	struct irq_domain *host_notify_domain;
	struct regulator *bus_regulator;
	struct dentry *debugfs;
	long unsigned int addrs_in_instantiation[2];
};

struct drm_dp_aux_cec {
	struct mutex lock;
	struct cec_adapter *adap;
	struct drm_connector *connector;
	struct delayed_work unregister_work;
};

struct drm_dp_aux_msg;

struct drm_dp_aux {
	const char *name;
	struct i2c_adapter ddc;
	struct device *dev;
	struct drm_device *drm_dev;
	struct drm_crtc *crtc;
	struct mutex hw_mutex;
	struct work_struct crc_work;
	u8 crc_count;
	ssize_t (*transfer)(struct drm_dp_aux *, struct drm_dp_aux_msg *);
	int (*wait_hpd_asserted)(struct drm_dp_aux *, long unsigned int);
	unsigned int i2c_nack_count;
	unsigned int i2c_defer_count;
	struct drm_dp_aux_cec cec;
	bool is_remote;
	bool powered_down;
};

struct drm_dp_aux_msg {
	unsigned int address;
	u8 request;
	u8 reply;
	void *buffer;
	size_t size;
};

struct drm_dp_dpcd_ident {
	u8 oui[3];
	u8 device_id[6];
	u8 hw_rev;
	u8 sw_major_rev;
	u8 sw_minor_rev;
};

struct drm_dp_desc {
	struct drm_dp_dpcd_ident ident;
	u32 quirks;
};

struct drm_dp_mst_port;

struct drm_dp_mst_atomic_payload {
	struct drm_dp_mst_port *port;
	s8 vc_start_slot;
	u8 vcpi;
	int time_slots;
	int pbn;
	bool delete: 1;
	bool dsc_enabled: 1;
	enum drm_dp_mst_payload_allocation payload_allocation_status;
	struct list_head next;
};

struct drm_dp_mst_topology_mgr;

struct drm_dp_mst_branch {
	struct kref topology_kref;
	struct kref malloc_kref;
	struct list_head destroy_next;
	u8 rad[8];
	u8 lct;
	int num_ports;
	struct list_head ports;
	struct drm_dp_mst_port *port_parent;
	struct drm_dp_mst_topology_mgr *mgr;
	bool link_address_sent;
	guid_t guid;
};

struct drm_dp_mst_port {
	struct kref topology_kref;
	struct kref malloc_kref;
	u8 port_num;
	bool input;
	bool mcs;
	bool ddps;
	u8 pdt;
	bool ldps;
	u8 dpcd_rev;
	u8 num_sdp_streams;
	u8 num_sdp_stream_sinks;
	uint16_t full_pbn;
	struct list_head next;
	struct drm_dp_mst_branch *mstb;
	struct drm_dp_aux aux;
	struct drm_dp_aux *passthrough_aux;
	struct drm_dp_mst_branch *parent;
	struct drm_connector *connector;
	struct drm_dp_mst_topology_mgr *mgr;
	const struct drm_edid *cached_edid;
	bool fec_capable;
};

struct drm_dp_mst_topology_cbs {
	struct drm_connector * (*add_connector)(struct drm_dp_mst_topology_mgr *, struct drm_dp_mst_port *, const char *);
	void (*poll_hpd_irq)(struct drm_dp_mst_topology_mgr *);
};

struct drm_dp_sideband_msg_hdr {
	u8 lct;
	u8 lcr;
	u8 rad[8];
	bool broadcast;
	bool path_msg;
	u8 msg_len;
	bool somt;
	bool eomt;
	bool seqno;
};

struct drm_dp_sideband_msg_rx {
	u8 chunk[48];
	u8 msg[256];
	u8 curchunk_len;
	u8 curchunk_idx;
	u8 curchunk_hdrlen;
	u8 curlen;
	bool have_somt;
	bool have_eomt;
	struct drm_dp_sideband_msg_hdr initial_hdr;
};

struct drm_dp_mst_topology_mgr {
	struct drm_private_obj base;
	struct drm_device *dev;
	const struct drm_dp_mst_topology_cbs *cbs;
	int max_dpcd_transaction_bytes;
	struct drm_dp_aux *aux;
	int max_payloads;
	int conn_base_id;
	struct drm_dp_sideband_msg_rx up_req_recv;
	struct drm_dp_sideband_msg_rx down_rep_recv;
	struct mutex lock;
	struct mutex probe_lock;
	bool mst_state: 1;
	bool payload_id_table_cleared: 1;
	bool reset_rx_state: 1;
	u8 payload_count;
	u8 next_start_slot;
	struct drm_dp_mst_branch *mst_primary;
	u8 dpcd[15];
	u8 sink_count;
	const struct drm_private_state_funcs *funcs;
	struct mutex qlock;
	struct list_head tx_msg_downq;
	wait_queue_head_t tx_waitq;
	struct work_struct work;
	struct work_struct tx_work;
	struct list_head destroy_port_list;
	struct list_head destroy_branch_device_list;
	struct mutex delayed_destroy_lock;
	struct workqueue_struct *delayed_destroy_wq;
	struct work_struct delayed_destroy_work;
	struct list_head up_req_list;
	struct mutex up_req_lock;
	struct work_struct up_req_work;
};

struct drm_dp_mst_topology_state {
	struct drm_private_state base;
	struct drm_dp_mst_topology_mgr *mgr;
	u32 pending_crtc_mask;
	struct drm_crtc_commit **commit_deps;
	size_t num_commit_deps;
	u32 payload_mask;
	struct list_head payloads;
	u8 total_avail_slots;
	u8 start_slot;
	fixed20_12 pbn_div;
};

struct drm_dp_sideband_msg_req_body {
	u8 req_type;
	union ack_req u;
};

struct drm_dp_pending_up_req {
	struct drm_dp_sideband_msg_hdr hdr;
	struct drm_dp_sideband_msg_req_body msg;
	struct list_head next;
};

struct drm_dp_phy_test_params {
	int link_rate;
	u8 num_lanes;
	u8 phy_pattern;
	u8 hbr2_reset[2];
	u8 custom80[10];
	bool enhanced_frame_cap;
};

struct drm_dp_sideband_msg_reply_body {
	u8 reply_type;
	u8 req_type;
	union ack_replies u;
};

struct drm_dp_sideband_msg_tx {
	u8 msg[256];
	u8 chunk[48];
	u8 cur_offset;
	u8 cur_len;
	struct drm_dp_mst_branch *dst;
	struct list_head next;
	int seqno;
	int state;
	bool path_msg;
	struct drm_dp_sideband_msg_reply_body reply;
};

struct drm_dp_tunnel;

struct ref_tracker;

struct drm_dp_tunnel_ref {
	struct drm_dp_tunnel *tunnel;
	struct ref_tracker *tracker;
};

struct drm_dp_vsc_sdp {
	unsigned char sdp_type;
	unsigned char revision;
	unsigned char length;
	enum dp_pixelformat pixelformat;
	enum dp_colorimetry colorimetry;
	int bpc;
	enum dp_dynamic_range dynamic_range;
	enum dp_content_type content_type;
};

struct drm_fb_helper_surface_size;

struct drm_mode_create_dumb;

struct drm_ioctl_desc;

struct drm_driver {
	int (*load)(struct drm_device *, long unsigned int);
	int (*open)(struct drm_device *, struct drm_file *);
	void (*postclose)(struct drm_device *, struct drm_file *);
	void (*unload)(struct drm_device *);
	void (*release)(struct drm_device *);
	void (*master_set)(struct drm_device *, struct drm_file *, bool);
	void (*master_drop)(struct drm_device *, struct drm_file *);
	void (*debugfs_init)(struct drm_minor *);
	struct drm_gem_object * (*gem_create_object)(struct drm_device *, size_t);
	int (*prime_handle_to_fd)(struct drm_device *, struct drm_file *, uint32_t, uint32_t, int *);
	int (*prime_fd_to_handle)(struct drm_device *, struct drm_file *, int, uint32_t *);
	struct drm_gem_object * (*gem_prime_import)(struct drm_device *, struct dma_buf *);
	struct drm_gem_object * (*gem_prime_import_sg_table)(struct drm_device *, struct dma_buf_attachment *, struct sg_table *);
	int (*dumb_create)(struct drm_file *, struct drm_device *, struct drm_mode_create_dumb *);
	int (*dumb_map_offset)(struct drm_file *, struct drm_device *, uint32_t, uint64_t *);
	int (*fbdev_probe)(struct drm_fb_helper *, struct drm_fb_helper_surface_size *);
	void (*show_fdinfo)(struct drm_printer *, struct drm_file *);
	int major;
	int minor;
	int patchlevel;
	char *name;
	char *desc;
	u32 driver_features;
	const struct drm_ioctl_desc *ioctls;
	int num_ioctls;
	const struct file_operations *fops;
};

struct drm_dsc_rc_range_parameters {
	u8 range_min_qp;
	u8 range_max_qp;
	u8 range_bpg_offset;
};

struct drm_dsc_config {
	u8 line_buf_depth;
	u8 bits_per_component;
	bool convert_rgb;
	u8 slice_count;
	u16 slice_width;
	u16 slice_height;
	bool simple_422;
	u16 pic_width;
	u16 pic_height;
	u8 rc_tgt_offset_high;
	u8 rc_tgt_offset_low;
	u16 bits_per_pixel;
	u8 rc_edge_factor;
	u8 rc_quant_incr_limit1;
	u8 rc_quant_incr_limit0;
	u16 initial_xmit_delay;
	u16 initial_dec_delay;
	bool block_pred_enable;
	u8 first_line_bpg_offset;
	u16 initial_offset;
	u16 rc_buf_thresh[14];
	struct drm_dsc_rc_range_parameters rc_range_params[15];
	u16 rc_model_size;
	u8 flatness_min_qp;
	u8 flatness_max_qp;
	u8 initial_scale_value;
	u16 scale_decrement_interval;
	u16 scale_increment_interval;
	u16 nfl_bpg_offset;
	u16 slice_bpg_offset;
	u16 final_offset;
	bool vbr_enable;
	u8 mux_word_size;
	u16 slice_chunk_size;
	u16 rc_bits;
	u8 dsc_version_minor;
	u8 dsc_version_major;
	bool native_422;
	bool native_420;
	u8 second_line_bpg_offset;
	u16 nsl_bpg_offset;
	u16 second_line_offset_adj;
};

struct drm_dsc_picture_parameter_set {
	u8 dsc_version;
	u8 pps_identifier;
	u8 pps_reserved;
	u8 pps_3;
	u8 pps_4;
	u8 bits_per_pixel_low;
	__be16 pic_height;
	__be16 pic_width;
	__be16 slice_height;
	__be16 slice_width;
	__be16 chunk_size;
	u8 initial_xmit_delay_high;
	u8 initial_xmit_delay_low;
	__be16 initial_dec_delay;
	u8 pps20_reserved;
	u8 initial_scale_value;
	__be16 scale_increment_interval;
	u8 scale_decrement_interval_high;
	u8 scale_decrement_interval_low;
	u8 pps26_reserved;
	u8 first_line_bpg_offset;
	__be16 nfl_bpg_offset;
	__be16 slice_bpg_offset;
	__be16 initial_offset;
	__be16 final_offset;
	u8 flatness_min_qp;
	u8 flatness_max_qp;
	__be16 rc_model_size;
	u8 rc_edge_factor;
	u8 rc_quant_incr_limit0;
	u8 rc_quant_incr_limit1;
	u8 rc_tgt_offset;
	u8 rc_buf_thresh[14];
	__be16 rc_range_parameters[15];
	u8 native_422_420;
	u8 second_line_bpg_offset;
	__be16 nsl_bpg_offset;
	__be16 second_line_offset_adj;
	u32 pps_long_94_reserved;
	u32 pps_long_98_reserved;
	u32 pps_long_102_reserved;
	u32 pps_long_106_reserved;
	u32 pps_long_110_reserved;
	u32 pps_long_114_reserved;
	u32 pps_long_118_reserved;
	u32 pps_long_122_reserved;
	__be16 pps_short_126_reserved;
} __attribute__((packed));

struct drm_dsc_pps_infoframe {
	struct dp_sdp_header pps_header;
	struct drm_dsc_picture_parameter_set pps_payload;
};

struct edid;

struct drm_edid {
	size_t size;
	const struct edid *edid;
};

struct drm_edid_ident {
	u32 panel_id;
	const char *name;
};

struct drm_edid_match_closure {
	const struct drm_edid_ident *ident;
	bool matched;
};

struct drm_edid_product_id {
	__be16 manufacturer_name;
	__le16 product_code;
	__le32 serial_number;
	u8 week_of_manufacture;
	u8 year_of_manufacture;
} __attribute__((packed));

struct drm_encoder_funcs;

struct drm_encoder_helper_funcs;

struct drm_encoder {
	struct drm_device *dev;
	struct list_head head;
	struct drm_mode_object base;
	char *name;
	int encoder_type;
	unsigned int index;
	uint32_t possible_crtcs;
	uint32_t possible_clones;
	struct drm_crtc *crtc;
	struct list_head bridge_chain;
	const struct drm_encoder_funcs *funcs;
	const struct drm_encoder_helper_funcs *helper_private;
	struct dentry *debugfs_entry;
};

struct drm_encoder_funcs {
	void (*reset)(struct drm_encoder *);
	void (*destroy)(struct drm_encoder *);
	int (*late_register)(struct drm_encoder *);
	void (*early_unregister)(struct drm_encoder *);
	void (*debugfs_init)(struct drm_encoder *, struct dentry *);
};

struct drm_encoder_helper_funcs {
	void (*dpms)(struct drm_encoder *, int);
	enum drm_mode_status (*mode_valid)(struct drm_encoder *, const struct drm_display_mode *);
	bool (*mode_fixup)(struct drm_encoder *, const struct drm_display_mode *, struct drm_display_mode *);
	void (*prepare)(struct drm_encoder *);
	void (*commit)(struct drm_encoder *);
	void (*mode_set)(struct drm_encoder *, struct drm_display_mode *, struct drm_display_mode *);
	void (*atomic_mode_set)(struct drm_encoder *, struct drm_crtc_state *, struct drm_connector_state *);
	enum drm_connector_status (*detect)(struct drm_encoder *, struct drm_connector *);
	void (*atomic_disable)(struct drm_encoder *, struct drm_atomic_state *);
	void (*atomic_enable)(struct drm_encoder *, struct drm_atomic_state *);
	void (*disable)(struct drm_encoder *);
	void (*enable)(struct drm_encoder *);
	int (*atomic_check)(struct drm_encoder *, struct drm_crtc_state *, struct drm_connector_state *);
};

struct drm_encoder_slave_funcs;

struct drm_encoder_slave {
	struct drm_encoder base;
	const struct drm_encoder_slave_funcs *slave_funcs;
	void *slave_priv;
	void *bus_priv;
};

struct drm_encoder_slave_funcs {
	void (*set_config)(struct drm_encoder *, void *);
	void (*destroy)(struct drm_encoder *);
	void (*dpms)(struct drm_encoder *, int);
	void (*save)(struct drm_encoder *);
	void (*restore)(struct drm_encoder *);
	bool (*mode_fixup)(struct drm_encoder *, const struct drm_display_mode *, struct drm_display_mode *);
	int (*mode_valid)(struct drm_encoder *, struct drm_display_mode *);
	void (*mode_set)(struct drm_encoder *, struct drm_display_mode *, struct drm_display_mode *);
	enum drm_connector_status (*detect)(struct drm_encoder *, struct drm_connector *);
	int (*get_modes)(struct drm_encoder *, struct drm_connector *);
	int (*create_resources)(struct drm_encoder *, struct drm_connector *);
	int (*set_property)(struct drm_encoder *, struct drm_connector *, struct drm_property *, uint64_t);
};

struct drm_event {
	__u32 type;
	__u32 length;
};

struct drm_event_crtc_sequence {
	struct drm_event base;
	__u64 user_data;
	__s64 time_ns;
	__u64 sequence;
};

struct drm_event_vblank {
	struct drm_event base;
	__u64 user_data;
	__u32 tv_sec;
	__u32 tv_usec;
	__u32 sequence;
	__u32 crtc_id;
};

struct ww_acquire_ctx {
	struct task_struct *task;
	long unsigned int stamp;
	unsigned int acquired;
	short unsigned int wounded;
	short unsigned int is_wait_die;
};

struct drm_exec {
	u32 flags;
	struct ww_acquire_ctx ticket;
	unsigned int num_objects;
	unsigned int max_objects;
	struct drm_gem_object **objects;
	struct drm_gem_object *contended;
	struct drm_gem_object *prelocked;
};

struct drm_prime_file_private {
	struct mutex lock;
	struct rb_root dmabufs;
	struct rb_root handles;
};

struct drm_file {
	bool authenticated;
	bool stereo_allowed;
	bool universal_planes;
	bool atomic;
	bool aspect_ratio_allowed;
	bool writeback_connectors;
	bool was_master;
	bool is_master;
	bool supports_virtualized_cursor_plane;
	struct drm_master *master;
	spinlock_t master_lookup_lock;
	struct pid *pid;
	u64 client_id;
	drm_magic_t magic;
	struct list_head lhead;
	struct drm_minor *minor;
	struct idr object_idr;
	spinlock_t table_lock;
	struct idr syncobj_idr;
	spinlock_t syncobj_table_lock;
	struct file *filp;
	void *driver_priv;
	struct list_head fbs;
	struct mutex fbs_lock;
	struct list_head blobs;
	wait_queue_head_t event_wait;
	struct list_head pending_event_list;
	struct list_head event_list;
	int event_space;
	struct mutex event_read_lock;
	struct drm_prime_file_private prime;
	const char *client_name;
	struct mutex client_name_lock;
};

struct drm_flip_task {
	struct list_head node;
	void *data;
};

struct drm_flip_work;

typedef void (*drm_flip_func_t)(struct drm_flip_work *, void *);

struct drm_flip_work {
	const char *name;
	drm_flip_func_t func;
	struct work_struct worker;
	struct list_head queued;
	struct list_head commited;
	spinlock_t lock;
};

struct drm_format_conv_state {
	struct {
		void *mem;
		size_t size;
		bool preallocated;
	} tmp;
};

struct drm_format_info {
	u32 format;
	u8 depth;
	u8 num_planes;
	union {
		u8 cpp[4];
		u8 char_per_block[4];
	};
	u8 block_w[4];
	u8 block_h[4];
	u8 hsub;
	u8 vsub;
	bool has_alpha;
	bool is_yuv;
	bool is_color_indexed;
};

struct drm_format_modifier {
	__u64 formats;
	__u32 offset;
	__u32 pad;
	__u64 modifier;
};

struct drm_format_modifier_blob {
	__u32 version;
	__u32 flags;
	__u32 count_formats;
	__u32 formats_offset;
	__u32 count_modifiers;
	__u32 modifiers_offset;
};

struct drm_framebuffer_funcs {
	void (*destroy)(struct drm_framebuffer *);
	int (*create_handle)(struct drm_framebuffer *, struct drm_file *, unsigned int *);
	int (*dirty)(struct drm_framebuffer *, struct drm_file *, unsigned int, unsigned int, struct drm_clip_rect *, unsigned int);
};

struct drm_gem_close {
	__u32 handle;
	__u32 pad;
};

struct drm_gem_flink {
	__u32 handle;
	__u32 name;
};

struct drm_gem_lru {
	struct mutex *lock;
	long int count;
	struct list_head list;
};

struct drm_vma_offset_node {
	rwlock_t vm_lock;
	struct drm_mm_node vm_node;
	struct rb_root vm_files;
	void *driver_private;
};

struct drm_gem_object_funcs;

struct drm_gem_object {
	struct kref refcount;
	unsigned int handle_count;
	struct drm_device *dev;
	struct file *filp;
	struct drm_vma_offset_node vma_node;
	size_t size;
	int name;
	struct dma_buf *dma_buf;
	struct dma_buf_attachment *import_attach;
	struct dma_resv *resv;
	struct dma_resv _resv;
	struct {
		struct list_head list;
	} gpuva;
	const struct drm_gem_object_funcs *funcs;
	struct list_head lru_node;
	struct drm_gem_lru *lru;
};

struct drm_gem_object_funcs {
	void (*free)(struct drm_gem_object *);
	int (*open)(struct drm_gem_object *, struct drm_file *);
	void (*close)(struct drm_gem_object *, struct drm_file *);
	void (*print_info)(struct drm_printer *, unsigned int, const struct drm_gem_object *);
	struct dma_buf * (*export)(struct drm_gem_object *, int);
	int (*pin)(struct drm_gem_object *);
	void (*unpin)(struct drm_gem_object *);
	struct sg_table * (*get_sg_table)(struct drm_gem_object *);
	int (*vmap)(struct drm_gem_object *, struct iosys_map *);
	void (*vunmap)(struct drm_gem_object *, struct iosys_map *);
	int (*mmap)(struct drm_gem_object *, struct vm_area_struct *);
	int (*evict)(struct drm_gem_object *);
	enum drm_gem_object_status (*status)(struct drm_gem_object *);
	size_t (*rss)(struct drm_gem_object *);
	const struct vm_operations_struct *vm_ops;
};

struct drm_gem_open {
	__u32 name;
	__u32 handle;
	__u64 size;
};

struct drm_gem_shmem_object {
	struct drm_gem_object base;
	struct page **pages;
	unsigned int pages_use_count;
	int madv;
	struct list_head madv_list;
	struct sg_table *sgt;
	void *vaddr;
	unsigned int vmap_use_count;
	bool pages_mark_dirty_on_put: 1;
	bool pages_mark_accessed_on_put: 1;
	bool map_wc: 1;
};

struct drm_get_cap {
	__u64 capability;
	__u64 value;
};

struct drm_gpuvm;

struct drm_gpuvm_bo;

struct drm_gpuva {
	struct drm_gpuvm *vm;
	struct drm_gpuvm_bo *vm_bo;
	enum drm_gpuva_flags flags;
	struct {
		u64 addr;
		u64 range;
	} va;
	struct {
		u64 offset;
		struct drm_gem_object *obj;
		struct list_head entry;
	} gem;
	struct {
		struct rb_node node;
		struct list_head entry;
		u64 __subtree_last;
	} rb;
};

struct drm_gpuva_op_map {
	struct {
		u64 addr;
		u64 range;
	} va;
	struct {
		u64 offset;
		struct drm_gem_object *obj;
	} gem;
};

struct drm_gpuva_op_unmap;

struct drm_gpuva_op_remap {
	struct drm_gpuva_op_map *prev;
	struct drm_gpuva_op_map *next;
	struct drm_gpuva_op_unmap *unmap;
};

struct drm_gpuva_op_unmap {
	struct drm_gpuva *va;
	bool keep;
};

struct drm_gpuva_op_prefetch {
	struct drm_gpuva *va;
};

struct drm_gpuva_op {
	struct list_head entry;
	enum drm_gpuva_op_type op;
	union {
		struct drm_gpuva_op_map map;
		struct drm_gpuva_op_remap remap;
		struct drm_gpuva_op_unmap unmap;
		struct drm_gpuva_op_prefetch prefetch;
	};
};

struct drm_gpuvm_ops;

struct drm_gpuvm {
	const char *name;
	enum drm_gpuvm_flags flags;
	struct drm_device *drm;
	u64 mm_start;
	u64 mm_range;
	struct {
		struct rb_root_cached tree;
		struct list_head list;
	} rb;
	struct kref kref;
	struct drm_gpuva kernel_alloc_node;
	const struct drm_gpuvm_ops *ops;
	struct drm_gem_object *r_obj;
	struct {
		struct list_head list;
		struct list_head *local_list;
		spinlock_t lock;
	} extobj;
	struct {
		struct list_head list;
		struct list_head *local_list;
		spinlock_t lock;
	} evict;
};

struct drm_gpuvm_bo {
	struct drm_gpuvm *vm;
	struct drm_gem_object *obj;
	bool evicted;
	struct kref kref;
	struct {
		struct list_head gpuva;
		struct {
			struct list_head gem;
			struct list_head extobj;
			struct list_head evict;
		} entry;
	} list;
};

struct drm_gpuvm_ops {
	void (*vm_free)(struct drm_gpuvm *);
	struct drm_gpuva_op * (*op_alloc)(void);
	void (*op_free)(struct drm_gpuva_op *);
	struct drm_gpuvm_bo * (*vm_bo_alloc)(void);
	void (*vm_bo_free)(struct drm_gpuvm_bo *);
	int (*vm_bo_validate)(struct drm_gpuvm_bo *, struct drm_exec *);
	int (*sm_step_map)(struct drm_gpuva_op *, void *);
	int (*sm_step_remap)(struct drm_gpuva_op *, void *);
	int (*sm_step_unmap)(struct drm_gpuva_op *, void *);
};

struct i2c_client;

struct i2c_device_id;

struct i2c_board_info;

struct i2c_driver {
	unsigned int class;
	int (*probe)(struct i2c_client *);
	void (*remove)(struct i2c_client *);
	void (*shutdown)(struct i2c_client *);
	void (*alert)(struct i2c_client *, enum i2c_alert_protocol, unsigned int);
	int (*command)(struct i2c_client *, unsigned int, void *);
	struct device_driver driver;
	const struct i2c_device_id *id_table;
	int (*detect)(struct i2c_client *, struct i2c_board_info *);
	const short unsigned int *address_list;
	struct list_head clients;
	u32 flags;
};

struct drm_i2c_encoder_driver {
	struct i2c_driver i2c_driver;
	int (*encoder_init)(struct i2c_client *, struct drm_device *, struct drm_encoder_slave *);
};

struct drm_i915_clock_gating_funcs {
	void (*init_clock_gating)(struct drm_i915_private *);
};

struct drm_i915_cmd_descriptor {
	u32 flags;
	struct {
		u32 value;
		u32 mask;
	} cmd;
	union {
		u32 fixed;
		u32 mask;
	} length;
	struct {
		u32 offset;
		u32 mask;
		u32 step;
	} reg;
	struct {
		u32 offset;
		u32 mask;
		u32 expected;
		u32 condition_offset;
		u32 condition_mask;
	} bits[3];
};

struct drm_i915_cmd_table {
	const struct drm_i915_cmd_descriptor *table;
	int count;
};

struct i915_engine_class_instance {
	__u16 engine_class;
	__u16 engine_instance;
};

struct drm_i915_engine_info {
	struct i915_engine_class_instance engine;
	__u32 rsvd0;
	__u64 flags;
	__u64 capabilities;
	__u16 logical_instance;
	__u16 rsvd1[3];
	__u64 rsvd2[3];
};

struct drm_i915_error_state_buf {
	struct drm_i915_private *i915;
	struct scatterlist *sgl;
	struct scatterlist *cur;
	struct scatterlist *end;
	char *buf;
	size_t bytes;
	size_t size;
	loff_t iter;
	int err;
};

struct i915_drm_client;

struct drm_i915_file_private {
	struct drm_i915_private *i915;
	union {
		struct drm_file *file;
		struct callback_head rcu;
	};
	struct mutex proto_context_lock;
	struct xarray proto_context_xa;
	struct xarray context_xa;
	struct xarray vm_xa;
	unsigned int bsd_engine;
	atomic_t ban_score;
	long unsigned int hang_timestamp;
	struct i915_drm_client *client;
};

struct drm_i915_gem_busy {
	__u32 handle;
	__u32 busy;
};

struct drm_i915_gem_caching {
	__u32 handle;
	__u32 caching;
};

struct drm_i915_gem_context_create_ext {
	__u32 ctx_id;
	__u32 flags;
	__u64 extensions;
};

struct i915_user_extension {
	__u64 next_extension;
	__u32 name;
	__u32 flags;
	__u32 rsvd[4];
};

struct drm_i915_gem_context_param {
	__u32 ctx_id;
	__u32 size;
	__u64 param;
	__u64 value;
};

struct drm_i915_gem_context_create_ext_setparam {
	struct i915_user_extension base;
	struct drm_i915_gem_context_param param;
};

struct drm_i915_gem_context_destroy {
	__u32 ctx_id;
	__u32 pad;
};

struct drm_i915_gem_context_param_sseu {
	struct i915_engine_class_instance engine;
	__u32 flags;
	__u64 slice_mask;
	__u64 subslice_mask;
	__u16 min_eus_per_subslice;
	__u16 max_eus_per_subslice;
	__u32 rsvd;
};

struct drm_i915_gem_create {
	__u64 size;
	__u32 handle;
	__u32 pad;
};

struct drm_i915_gem_create_ext {
	__u64 size;
	__u32 handle;
	__u32 flags;
	__u64 extensions;
};

struct drm_i915_gem_create_ext_memory_regions {
	struct i915_user_extension base;
	__u32 pad;
	__u32 num_regions;
	__u64 regions;
};

struct drm_i915_gem_create_ext_protected_content {
	struct i915_user_extension base;
	__u32 flags;
};

struct drm_i915_gem_create_ext_set_pat {
	struct i915_user_extension base;
	__u32 pat_index;
	__u32 rsvd;
};

struct drm_i915_gem_exec_fence {
	__u32 handle;
	__u32 flags;
};

struct drm_i915_gem_exec_object2 {
	__u32 handle;
	__u32 relocation_count;
	__u64 relocs_ptr;
	__u64 alignment;
	__u64 offset;
	__u64 flags;
	union {
		__u64 rsvd1;
		__u64 pad_to_size;
	};
	__u64 rsvd2;
};

struct drm_i915_gem_execbuffer2 {
	__u64 buffers_ptr;
	__u32 buffer_count;
	__u32 batch_start_offset;
	__u32 batch_len;
	__u32 DR1;
	__u32 DR4;
	__u32 num_cliprects;
	__u64 cliprects_ptr;
	__u64 flags;
	__u64 rsvd1;
	__u64 rsvd2;
};

struct drm_i915_gem_execbuffer_ext_timeline_fences {
	struct i915_user_extension base;
	__u64 fence_count;
	__u64 handles_ptr;
	__u64 values_ptr;
};

struct drm_i915_gem_get_aperture {
	__u64 aper_size;
	__u64 aper_available_size;
};

struct drm_i915_gem_get_tiling {
	__u32 handle;
	__u32 tiling_mode;
	__u32 swizzle_mode;
	__u32 phys_swizzle_mode;
};

struct drm_i915_gem_madvise {
	__u32 handle;
	__u32 madv;
	__u32 retained;
};

struct drm_i915_gem_memory_class_instance {
	__u16 memory_class;
	__u16 memory_instance;
};

struct drm_i915_gem_mmap {
	__u32 handle;
	__u32 pad;
	__u64 offset;
	__u64 size;
	__u64 addr_ptr;
	__u64 flags;
};

struct drm_i915_gem_mmap_offset {
	__u32 handle;
	__u32 pad;
	__u64 offset;
	__u64 flags;
	__u64 extensions;
};

struct ttm_device;

struct ttm_resource;

struct ttm_tt;

struct ttm_lru_bulk_move;

struct ttm_buffer_object {
	struct drm_gem_object base;
	struct ttm_device *bdev;
	enum ttm_bo_type type;
	uint32_t page_alignment;
	void (*destroy)(struct ttm_buffer_object *);
	struct kref kref;
	struct ttm_resource *resource;
	struct ttm_tt *ttm;
	bool deleted;
	struct ttm_lru_bulk_move *bulk_move;
	unsigned int priority;
	unsigned int pin_count;
	struct work_struct delayed_delete;
	struct sg_table *sg;
};

struct i915_page_sizes {
	unsigned int phys;
	unsigned int sg;
};

struct i915_gem_object_page_iter {
	struct scatterlist *sg_pos;
	unsigned int sg_idx;
	struct xarray radix;
	struct mutex lock;
};

struct interval_tree_node {
	struct rb_node rb;
	long unsigned int start;
	long unsigned int last;
	long unsigned int __subtree_last;
};

struct mmu_interval_notifier_ops;

struct mmu_interval_notifier {
	struct interval_tree_node interval_tree;
	const struct mmu_interval_notifier_ops *ops;
	struct mm_struct *mm;
	struct hlist_node deferred_item;
	long unsigned int invalidate_seq;
};

struct i915_gem_userptr {
	uintptr_t ptr;
	long unsigned int notifier_seq;
	struct mmu_interval_notifier notifier;
	struct page **pvec;
	int page_ref;
};

struct drm_i915_gem_object_ops;

struct i915_address_space;

struct intel_frontbuffer;

struct i915_refct_sgt;

struct drm_i915_gem_object {
	union {
		struct drm_gem_object base;
		struct ttm_buffer_object __do_not_access;
	};
	const struct drm_i915_gem_object_ops *ops;
	struct {
		spinlock_t lock;
		struct list_head list;
		struct rb_root tree;
	} vma;
	struct list_head lut_list;
	spinlock_t lut_lock;
	struct list_head obj_link;
	struct i915_address_space *shares_resv_from;
	struct i915_drm_client *client;
	struct list_head client_link;
	union {
		struct callback_head rcu;
		struct llist_node freed;
	};
	unsigned int userfault_count;
	struct list_head userfault_link;
	struct {
		spinlock_t lock;
		struct rb_root offsets;
	} mmo;
	long unsigned int flags;
	unsigned int mem_flags;
	unsigned int pat_index: 6;
	unsigned int pat_set_by_user: 1;
	unsigned int cache_coherent: 2;
	unsigned int cache_dirty: 1;
	unsigned int is_dpt: 1;
	u16 read_domains;
	u16 write_domain;
	struct intel_frontbuffer *frontbuffer;
	unsigned int tiling_and_stride;
	struct {
		atomic_t pages_pin_count;
		atomic_t shrink_pin;
		bool ttm_shrinkable;
		bool unknown_state;
		struct intel_memory_region **placements;
		int n_placements;
		struct intel_memory_region *region;
		struct ttm_resource *res;
		struct list_head region_link;
		struct i915_refct_sgt *rsgt;
		struct sg_table *pages;
		void *mapping;
		struct i915_page_sizes page_sizes;
		struct i915_gem_object_page_iter get_page;
		struct i915_gem_object_page_iter get_dma_page;
		struct list_head link;
		unsigned int madv: 2;
		bool dirty: 1;
		u32 tlb[2];
	} mm;
	struct {
		struct i915_refct_sgt *cached_io_rsgt;
		struct i915_gem_object_page_iter get_io_page;
		struct drm_i915_gem_object *backup;
		bool created: 1;
	} ttm;
	u32 pxp_key_instance;
	long unsigned int *bit_17;
	union {
		struct i915_gem_userptr userptr;
		struct drm_mm_node *stolen;
		resource_size_t bo_offset;
		long unsigned int scratch;
		u64 encode;
		void *gvt_info;
	};
};

struct drm_i915_gem_pread;

struct drm_i915_gem_pwrite;

struct drm_i915_gem_object_ops {
	unsigned int flags;
	int (*get_pages)(struct drm_i915_gem_object *);
	void (*put_pages)(struct drm_i915_gem_object *, struct sg_table *);
	int (*truncate)(struct drm_i915_gem_object *);
	int (*shrink)(struct drm_i915_gem_object *, unsigned int);
	int (*pread)(struct drm_i915_gem_object *, const struct drm_i915_gem_pread *);
	int (*pwrite)(struct drm_i915_gem_object *, const struct drm_i915_gem_pwrite *);
	u64 (*mmap_offset)(struct drm_i915_gem_object *);
	void (*unmap_virtual)(struct drm_i915_gem_object *);
	int (*dmabuf_export)(struct drm_i915_gem_object *);
	void (*adjust_lru)(struct drm_i915_gem_object *);
	void (*delayed_free)(struct drm_i915_gem_object *);
	int (*migrate)(struct drm_i915_gem_object *, struct intel_memory_region *, unsigned int);
	void (*release)(struct drm_i915_gem_object *);
	const struct vm_operations_struct *mmap_ops;
	const char *name;
};

struct drm_i915_gem_pread {
	__u32 handle;
	__u32 pad;
	__u64 offset;
	__u64 size;
	__u64 data_ptr;
};

struct drm_i915_gem_pwrite {
	__u32 handle;
	__u32 pad;
	__u64 offset;
	__u64 size;
	__u64 data_ptr;
};

struct drm_i915_gem_relocation_entry {
	__u32 target_handle;
	__u32 delta;
	__u64 offset;
	__u64 presumed_offset;
	__u32 read_domains;
	__u32 write_domain;
};

struct drm_i915_gem_set_domain {
	__u32 handle;
	__u32 read_domains;
	__u32 write_domain;
};

struct drm_i915_gem_set_tiling {
	__u32 handle;
	__u32 tiling_mode;
	__u32 stride;
	__u32 swizzle_mode;
};

struct drm_i915_gem_sw_finish {
	__u32 handle;
};

struct drm_i915_gem_userptr {
	__u64 user_ptr;
	__u64 user_size;
	__u32 flags;
	__u32 handle;
};

struct drm_i915_gem_vm_control {
	__u64 extensions;
	__u32 flags;
	__u32 vm_id;
};

struct drm_i915_gem_wait {
	__u32 bo_handle;
	__u32 flags;
	__s64 timeout_ns;
};

struct drm_i915_get_pipe_from_crtc_id {
	__u32 crtc_id;
	__u32 pipe;
};

struct drm_i915_getparam {
	__s32 param;
	int *value;
};

typedef struct drm_i915_getparam drm_i915_getparam_t;

struct drm_i915_getparam32 {
	s32 param;
	u32 value;
};

struct drm_i915_memory_region_info {
	struct drm_i915_gem_memory_class_instance region;
	__u32 rsvd0;
	__u64 probed_size;
	__u64 unallocated_size;
	union {
		__u64 rsvd1[8];
		struct {
			__u64 probed_cpu_visible_size;
			__u64 unallocated_cpu_visible_size;
		};
	};
};

struct drm_i915_mocs_entry {
	u32 control_value;
	u16 l3cc_value;
	u16 used;
};

struct drm_i915_mocs_table {
	unsigned int size;
	unsigned int n_entries;
	const struct drm_i915_mocs_entry *table;
	u8 uc_index;
	u8 wb_index;
	u8 unused_entries_index;
};

struct drm_i915_perf_oa_config {
	char uuid[36];
	__u32 n_mux_regs;
	__u32 n_boolean_regs;
	__u32 n_flex_regs;
	__u64 mux_regs_ptr;
	__u64 boolean_regs_ptr;
	__u64 flex_regs_ptr;
};

struct drm_i915_perf_open_param {
	__u32 flags;
	__u32 num_properties;
	__u64 properties_ptr;
};

struct drm_i915_perf_record_header {
	__u32 type;
	__u16 pad;
	__u16 size;
};

struct intel_display_platforms {
	union {
		struct {
			long unsigned int g4x: 1;
			long unsigned int mobile: 1;
			long unsigned int dgfx: 1;
			long unsigned int i830: 1;
			long unsigned int i845g: 1;
			long unsigned int i85x: 1;
			long unsigned int i865g: 1;
			long unsigned int i915g: 1;
			long unsigned int i915gm: 1;
			long unsigned int i945g: 1;
			long unsigned int i945gm: 1;
			long unsigned int g33: 1;
			long unsigned int pineview: 1;
			long unsigned int i965g: 1;
			long unsigned int i965gm: 1;
			long unsigned int g45: 1;
			long unsigned int gm45: 1;
			long unsigned int ironlake: 1;
			long unsigned int sandybridge: 1;
			long unsigned int ivybridge: 1;
			long unsigned int valleyview: 1;
			long unsigned int haswell: 1;
			long unsigned int haswell_ult: 1;
			long unsigned int haswell_ulx: 1;
			long unsigned int broadwell: 1;
			long unsigned int broadwell_ult: 1;
			long unsigned int broadwell_ulx: 1;
			long unsigned int cherryview: 1;
			long unsigned int skylake: 1;
			long unsigned int skylake_ult: 1;
			long unsigned int skylake_ulx: 1;
			long unsigned int broxton: 1;
			long unsigned int kabylake: 1;
			long unsigned int kabylake_ult: 1;
			long unsigned int kabylake_ulx: 1;
			long unsigned int geminilake: 1;
			long unsigned int coffeelake: 1;
			long unsigned int coffeelake_ult: 1;
			long unsigned int coffeelake_ulx: 1;
			long unsigned int cometlake: 1;
			long unsigned int cometlake_ult: 1;
			long unsigned int cometlake_ulx: 1;
			long unsigned int icelake: 1;
			long unsigned int icelake_port_f: 1;
			long unsigned int jasperlake: 1;
			long unsigned int elkhartlake: 1;
			long unsigned int tigerlake: 1;
			long unsigned int tigerlake_uy: 1;
			long unsigned int rocketlake: 1;
			long unsigned int dg1: 1;
			long unsigned int alderlake_s: 1;
			long unsigned int alderlake_s_raptorlake_s: 1;
			long unsigned int alderlake_p: 1;
			long unsigned int alderlake_p_alderlake_n: 1;
			long unsigned int alderlake_p_raptorlake_p: 1;
			long unsigned int alderlake_p_raptorlake_u: 1;
			long unsigned int dg2: 1;
			long unsigned int dg2_g10: 1;
			long unsigned int dg2_g11: 1;
			long unsigned int dg2_g12: 1;
			long unsigned int meteorlake: 1;
			long unsigned int lunarlake: 1;
			long unsigned int battlemage: 1;
			long unsigned int pantherlake: 1;
		};
		long unsigned int bitmap[1];
	};
};

struct intel_global_state_funcs;

struct intel_global_obj {
	struct list_head head;
	struct intel_global_state *state;
	const struct intel_global_state_funcs *funcs;
};

struct intel_bw_info {
	unsigned int deratedbw[8];
	unsigned int psf_bw[3];
	unsigned int peakbw[8];
	u8 num_qgv_points;
	u8 num_psf_gv_points;
	u8 num_planes;
};

struct intel_cdclk_config {
	unsigned int cdclk;
	unsigned int vco;
	unsigned int ref;
	unsigned int bypass;
	u8 voltage_level;
	bool joined_mbus;
};

typedef struct ref_tracker *intel_wakeref_t;

struct intel_fbdev;

struct intel_display_ip_ver {
	u16 ver;
	u16 rel;
	u16 step;
};

struct intel_display_runtime_info {
	struct intel_display_ip_ver ip;
	int step;
	u32 rawclk_freq;
	u8 pipe_mask;
	u8 cpu_transcoder_mask;
	u16 port_mask;
	u8 num_sprites[4];
	u8 num_scalers[4];
	u8 fbc_mask;
	bool has_hdcp;
	bool has_dmc;
	bool has_dsc;
	bool edp_typec_support;
	bool has_dbuf_overlap_detection;
};

struct intel_power_domain_mask {
	long unsigned int bits[2];
};

struct i915_power_well;

struct i915_power_domains {
	bool initializing;
	bool display_core_suspended;
	int power_well_count;
	u32 dc_state;
	u32 target_dc_state;
	u32 allowed_dc_mask;
	intel_wakeref_t init_wakeref;
	intel_wakeref_t disable_wakeref;
	struct mutex lock;
	int domain_use_count[76];
	struct delayed_work async_put_work;
	intel_wakeref_t async_put_wakeref;
	struct intel_power_domain_mask async_put_domains[2];
	int async_put_next_delay;
	struct i915_power_well *power_wells;
};

struct drm_modeset_acquire_ctx {
	struct ww_acquire_ctx ww_ctx;
	struct drm_modeset_lock *contended;
	depot_stack_handle_t stack_depot;
	struct list_head locked;
	bool trylock_only;
	bool interruptible;
};

struct drm_dp_tunnel_mgr;

struct intel_encoder;

struct intel_audio_state {
	struct intel_encoder *encoder;
	u8 eld[128];
};

struct i915_audio_component;

struct intel_audio {
	struct i915_audio_component *component;
	bool component_registered;
	struct mutex mutex;
	int power_refcount;
	u32 freq_cntrl;
	struct intel_audio_state state[7];
	struct {
		struct platform_device *platdev;
		int irq;
	} lpe;
};

struct i9xx_dpll_hw_state {
	u32 dpll;
	u32 dpll_md;
	u32 fp0;
	u32 fp1;
};

struct hsw_dpll_hw_state {
	u32 wrpll;
	u32 spll;
};

struct skl_dpll_hw_state {
	u32 ctrl1;
	u32 cfgcr1;
	u32 cfgcr2;
};

struct icl_dpll_hw_state {
	u32 cfgcr0;
	u32 cfgcr1;
	u32 div0;
	u32 mg_refclkin_ctl;
	u32 mg_clktop2_coreclkctl1;
	u32 mg_clktop2_hsclkctl;
	u32 mg_pll_div0;
	u32 mg_pll_div1;
	u32 mg_pll_lf;
	u32 mg_pll_frac_lock;
	u32 mg_pll_ssc;
	u32 mg_pll_bias;
	u32 mg_pll_tdc_coldst_bias;
	u32 mg_pll_bias_mask;
	u32 mg_pll_tdc_coldst_bias_mask;
};

struct intel_mpllb_state {
	u32 clock;
	u32 ref_control;
	u32 mpllb_cp;
	u32 mpllb_div;
	u32 mpllb_div2;
	u32 mpllb_fracn1;
	u32 mpllb_fracn2;
	u32 mpllb_sscen;
	u32 mpllb_sscstep;
};

struct intel_c10pll_state {
	u32 clock;
	u8 tx;
	u8 cmn;
	u8 pll[20];
};

struct intel_c20pll_state {
	u32 clock;
	u16 tx[3];
	u16 cmn[4];
	union {
		u16 mplla[10];
		u16 mpllb[11];
	};
};

struct intel_cx0pll_state {
	union {
		struct intel_c10pll_state c10;
		struct intel_c20pll_state c20;
	};
	bool ssc_enabled;
	bool use_c10;
	bool tbt_mode;
};

struct intel_dpll_hw_state {
	union {
		struct i9xx_dpll_hw_state i9xx;
		struct hsw_dpll_hw_state hsw;
		struct skl_dpll_hw_state skl;
		struct bxt_dpll_hw_state bxt;
		struct icl_dpll_hw_state icl;
		struct intel_mpllb_state mpllb;
		struct intel_cx0pll_state cx0pll;
	};
};

struct intel_shared_dpll_state {
	u8 pipe_mask;
	struct intel_dpll_hw_state hw_state;
};

struct intel_shared_dpll {
	struct intel_shared_dpll_state state;
	u8 index;
	u8 active_mask;
	bool on;
	const struct dpll_info *info;
	intel_wakeref_t wakeref;
};

struct intel_dpll_mgr;

struct intel_dpll {
	struct mutex lock;
	int num_shared_dpll;
	struct intel_shared_dpll shared_dplls[9];
	const struct intel_dpll_mgr *mgr;
	struct {
		int nssc;
		int ssc;
	} ref_clks;
	u8 pch_ssc_use;
};

struct intel_frontbuffer_tracking {
	spinlock_t lock;
	unsigned int busy_bits;
	unsigned int flip_bits;
};

struct intel_hotplug {
	struct delayed_work hotplug_work;
	const u32 *hpd;
	const u32 *pch_hpd;
	struct {
		long unsigned int last_jiffies;
		int count;
		enum {
			HPD_ENABLED = 0,
			HPD_DISABLED = 1,
			HPD_MARK_DISABLED = 2,
		} state;
	} stats[15];
	u32 event_bits;
	u32 retry_bits;
	struct delayed_work reenable_work;
	u32 long_port_mask;
	u32 short_port_mask;
	struct work_struct dig_port_work;
	struct work_struct poll_init_work;
	bool poll_enabled;
	bool detection_work_enabled;
	unsigned int hpd_storm_threshold;
	u8 hpd_short_storm_enabled;
	long unsigned int oob_hotplug_last_state;
	struct workqueue_struct *dp_wq;
	bool ignore_long_hpd;
};

struct intel_display_params {
	char *dmc_firmware_path;
	char *vbt_firmware;
	int lvds_channel_mode;
	int panel_use_ssc;
	int vbt_sdvo_panel_type;
	int enable_dc;
	bool enable_dpt;
	bool enable_dsb;
	bool enable_sagv;
	int disable_power_well;
	bool enable_ips;
	int invert_brightness;
	int edp_vswing;
	int enable_dpcd_backlight;
	bool load_detect_test;
	bool force_reset_modeset_test;
	bool disable_display;
	bool verbose_state_checks;
	bool nuclear_pageflip;
	bool enable_dp_mst;
	int enable_fbc;
	int enable_psr;
	bool psr_safest_params;
	bool enable_psr2_sel_fetch;
	int enable_dmc_wl;
};

struct sdvo_device_mapping {
	u8 initialized;
	u8 dvo_port;
	u8 target_addr;
	u8 dvo_wiring;
	u8 i2c_pin;
	u8 ddc_pin;
};

struct intel_vbt_data {
	u16 version;
	unsigned int int_tv_support: 1;
	unsigned int int_crt_support: 1;
	unsigned int lvds_use_ssc: 1;
	unsigned int int_lvds_support: 1;
	unsigned int display_clock_mode: 1;
	unsigned int fdi_rx_polarity_inverted: 1;
	int lvds_ssc_freq;
	enum drm_panel_orientation orientation;
	bool override_afc_startup;
	u8 override_afc_startup_val;
	int crt_ddc_pin;
	struct list_head display_devices;
	struct list_head bdb_blocks;
	struct sdvo_device_mapping sdvo_mappings[2];
};

struct intel_dmc_wl {
	spinlock_t lock;
	bool enabled;
	bool taken;
	refcount_t refcount;
	u32 dc_state;
	struct delayed_work work;
};

struct ilk_wm_values {
	u32 wm_pipe[3];
	u32 wm_lp[3];
	u32 wm_lp_spr[3];
	bool enable_fbc_wm;
	enum intel_ddb_partitioning partitioning;
};

struct g4x_pipe_wm {
	u16 plane[8];
	u16 fbc;
};

struct g4x_sr_wm {
	u16 plane;
	u16 cursor;
	u16 fbc;
};

struct vlv_wm_ddl_values {
	u8 plane[8];
};

struct vlv_wm_values {
	struct g4x_pipe_wm pipe[3];
	struct g4x_sr_wm sr;
	struct vlv_wm_ddl_values ddl[3];
	u8 level;
	bool cxsr;
};

struct g4x_wm_values {
	struct g4x_pipe_wm pipe[2];
	struct g4x_sr_wm sr;
	struct g4x_sr_wm hpll;
	bool cxsr;
	bool hpll_en;
	bool fbc_en;
};

struct intel_wm {
	u16 pri_latency[5];
	u16 spr_latency[5];
	u16 cur_latency[5];
	u16 skl_latency[8];
	union {
		struct ilk_wm_values hw;
		struct vlv_wm_values vlv;
		struct g4x_wm_values g4x;
	};
	u8 num_levels;
	struct mutex wm_mutex;
	bool ipc_enabled;
};

struct intel_display_funcs;

struct intel_cdclk_funcs;

struct intel_dpll_funcs;

struct intel_hotplug_funcs;

struct intel_wm_funcs;

struct intel_fdi_funcs;

struct intel_color_funcs;

struct intel_audio_funcs;

struct intel_cdclk_vals;

struct intel_dmc;

struct intel_gmbus;

struct i915_hdcp_arbiter;

struct intel_hdcp_gsc_message;

struct intel_display_device_info;

struct intel_fbc;

struct intel_opregion;

struct intel_overlay;

struct intel_display {
	struct drm_device *drm;
	struct intel_display_platforms platform;
	struct {
		const struct intel_display_funcs *display;
		const struct intel_cdclk_funcs *cdclk;
		const struct intel_dpll_funcs *dpll;
		const struct intel_hotplug_funcs *hotplug;
		const struct intel_wm_funcs *wm;
		const struct intel_fdi_funcs *fdi;
		const struct intel_color_funcs *color;
		const struct intel_audio_funcs *audio;
	} funcs;
	struct {
		bool any_task_allowed;
		struct task_struct *allowed_task;
	} access;
	struct {
		struct mutex lock;
	} backlight;
	struct {
		struct intel_global_obj obj;
		struct intel_bw_info max[6];
	} bw;
	struct {
		struct intel_cdclk_config hw;
		const struct intel_cdclk_vals *table;
		struct intel_global_obj obj;
		unsigned int max_cdclk_freq;
		unsigned int max_dotclk_freq;
		unsigned int skl_preferred_vco_freq;
	} cdclk;
	struct {
		struct drm_property_blob *glk_linear_degamma_lut;
	} color;
	struct {
		u8 enabled_slices;
		struct intel_global_obj obj;
	} dbuf;
	struct {
		spinlock_t phy_lock;
	} dkl;
	struct {
		struct intel_dmc *dmc;
		intel_wakeref_t wakeref;
	} dmc;
	struct {
		u32 mmio_base;
	} dsi;
	struct {
		struct intel_fbdev *fbdev;
		struct work_struct suspend_work;
	} fbdev;
	struct {
		unsigned int pll_freq;
		u32 rx_config;
	} fdi;
	struct {
		struct list_head obj_list;
	} global;
	struct {
		u32 mmio_base;
		struct mutex mutex;
		struct intel_gmbus *bus[15];
		wait_queue_head_t wait_queue;
	} gmbus;
	struct {
		struct i915_hdcp_arbiter *arbiter;
		bool comp_added;
		struct intel_hdcp_gsc_message *hdcp_message;
		struct mutex hdcp_mutex;
	} hdcp;
	struct {
		u32 state;
	} hti;
	struct {
		const struct intel_display_device_info *__device_info;
		struct intel_display_runtime_info __runtime_info;
	} info;
	struct {
		bool false_color;
	} ips;
	struct {
		bool vlv_display_irqs_enabled;
		u8 vblank_enabled;
		int vblank_wa_num_pipes;
		struct work_struct vblank_dc_work;
		u32 de_irq_mask[4];
		u32 pipestat_irq_mask[4];
	} irq;
	struct {
		wait_queue_head_t waitqueue;
		struct mutex lock;
		struct intel_global_obj obj;
	} pmdemand;
	struct {
		struct i915_power_domains domains;
		u32 chv_phy_control;
		bool chv_phy_assert[2];
	} power;
	struct {
		u32 mmio_base;
		struct mutex mutex;
	} pps;
	struct {
		struct drm_property *broadcast_rgb;
		struct drm_property *force_audio;
	} properties;
	struct {
		long unsigned int mask;
	} quirks;
	struct {
		struct drm_atomic_state *modeset_state;
		struct drm_modeset_acquire_ctx reset_ctx;
		u32 saveDSPARB;
		u32 saveSWF0[16];
		u32 saveSWF1[16];
		u32 saveSWF3[3];
		u16 saveGCDGMBUS;
	} restore;
	struct {
		enum {
			I915_SAGV_UNKNOWN = 0,
			I915_SAGV_DISABLED = 1,
			I915_SAGV_ENABLED = 2,
			I915_SAGV_NOT_CONTROLLED = 3,
		} status;
		u32 block_time_us;
	} sagv;
	struct {
		u8 phy_failed_calibration;
	} snps;
	struct {
		u32 chv_dpll_md[4];
		u32 bxt_phy_grc;
	} state;
	struct {
		struct workqueue_struct *modeset;
		struct workqueue_struct *flip;
		struct workqueue_struct *cleanup;
	} wq;
	struct drm_dp_tunnel_mgr *dp_tunnel_mgr;
	struct intel_audio audio;
	struct intel_dpll dpll;
	struct intel_fbc *fbc[4];
	struct intel_frontbuffer_tracking fb_tracking;
	struct intel_hotplug hotplug;
	struct intel_opregion *opregion;
	struct intel_overlay *overlay;
	struct intel_display_params params;
	struct intel_vbt_data vbt;
	struct intel_dmc_wl wl;
	struct intel_wm wm;
};

struct i915_params {
	int modeset;
	int enable_guc;
	int guc_log_level;
	char *guc_firmware_path;
	char *huc_firmware_path;
	char *gsc_firmware_path;
	bool memtest;
	int mmio_debug;
	unsigned int reset;
	unsigned int inject_probe_failure;
	char *force_probe;
	unsigned int request_timeout_ms;
	unsigned int lmem_size;
	unsigned int lmem_bar_size;
	bool enable_hangcheck;
	bool error_capture;
	bool enable_gvt;
	bool enable_debug_only_api;
};

struct intel_ip_version {
	u8 ver;
	u8 rel;
	u8 step;
};

struct intel_step_info {
	u8 graphics_step;
	u8 media_step;
};

struct intel_runtime_info {
	struct {
		struct intel_ip_version ip;
	} graphics;
	struct {
		struct intel_ip_version ip;
	} media;
	u32 platform_mask[2];
	u16 device_id;
	struct intel_step_info step;
	unsigned int page_sizes;
	enum intel_ppgtt_type ppgtt_type;
	unsigned int ppgtt_size;
	bool has_pooled_eu;
};

struct intel_driver_caps {
	unsigned int scheduler;
	bool has_logical_contexts: 1;
};

struct i915_dsm {
	struct resource stolen;
	struct resource reserved;
	resource_size_t usable_size;
};

struct intel_uncore;

struct intel_uncore_funcs {
	enum forcewake_domains (*read_fw_domains)(struct intel_uncore *, i915_reg_t);
	enum forcewake_domains (*write_fw_domains)(struct intel_uncore *, i915_reg_t);
	u8 (*mmio_readb)(struct intel_uncore *, i915_reg_t, bool);
	u16 (*mmio_readw)(struct intel_uncore *, i915_reg_t, bool);
	u32 (*mmio_readl)(struct intel_uncore *, i915_reg_t, bool);
	u64 (*mmio_readq)(struct intel_uncore *, i915_reg_t, bool);
	void (*mmio_writeb)(struct intel_uncore *, i915_reg_t, u8, bool);
	void (*mmio_writew)(struct intel_uncore *, i915_reg_t, u16, bool);
	void (*mmio_writel)(struct intel_uncore *, i915_reg_t, u32, bool);
};

struct intel_gt;

struct intel_runtime_pm;

struct intel_forcewake_range;

struct i915_range;

struct intel_uncore_fw_get;

struct intel_uncore_forcewake_domain;

struct intel_uncore_mmio_debug;

struct intel_uncore {
	void *regs;
	struct drm_i915_private *i915;
	struct intel_gt *gt;
	struct intel_runtime_pm *rpm;
	spinlock_t lock;
	u32 gsi_offset;
	unsigned int flags;
	const struct intel_forcewake_range *fw_domains_table;
	unsigned int fw_domains_table_entries;
	const struct i915_range *shadowed_reg_table;
	unsigned int shadowed_reg_table_entries;
	struct notifier_block pmic_bus_access_nb;
	const struct intel_uncore_fw_get *fw_get_funcs;
	struct intel_uncore_funcs funcs;
	unsigned int fifo_count;
	enum forcewake_domains fw_domains;
	enum forcewake_domains fw_domains_active;
	enum forcewake_domains fw_domains_timer;
	enum forcewake_domains fw_domains_saved;
	struct intel_uncore_forcewake_domain *fw_domain[16];
	unsigned int user_forcewake_count;
	struct intel_uncore_mmio_debug *debug;
};

struct intel_uncore_mmio_debug {
	spinlock_t lock;
	int unclaimed_mmio_check;
	int saved_mmio_check;
	u32 suspend_count;
};

struct i915_virtual_gpu {
	struct mutex lock;
	bool active;
	u32 caps;
	u32 *initial_mmio;
	u8 *initial_cfg_space;
	struct list_head entry;
};

struct intel_gvt;

struct pm_qos_request {
	struct plist_node node;
	struct pm_qos_constraints *qos;
};

struct drm_mm {
	void (*color_adjust)(const struct drm_mm_node *, long unsigned int, u64 *, u64 *);
	struct list_head hole_stack;
	struct drm_mm_node head_node;
	struct rb_root_cached interval_tree;
	struct rb_root_cached holes_size;
	struct rb_root holes_addr;
	long unsigned int scan_active;
};

struct shrinker;

struct i915_gem_mm {
	struct intel_memory_region *stolen_region;
	struct drm_mm stolen;
	struct mutex stolen_lock;
	spinlock_t obj_lock;
	struct list_head purge_list;
	struct list_head shrink_list;
	struct llist_head free_list;
	struct work_struct free_work;
	atomic_t free_count;
	struct vfsmount *gemfs;
	struct intel_memory_region *regions[7];
	struct notifier_block oom_notifier;
	struct notifier_block vmap_notifier;
	struct shrinker *shrinker;
	u64 shrink_memory;
	u32 shrink_count;
};

struct intel_l3_parity {
	u32 *remap_info[2];
	struct work_struct error_work;
	int which_slice;
};

struct i915_gpu_coredump;

struct i915_gpu_error {
	spinlock_t lock;
	struct i915_gpu_coredump *first_error;
	atomic_t pending_fb_pin;
	atomic_t reset_count;
	atomic_t reset_engine_count[5];
};

struct intel_wakeref_auto {
	struct drm_i915_private *i915;
	struct timer_list timer;
	intel_wakeref_t wakeref;
	spinlock_t lock;
	refcount_t count;
};

struct intel_runtime_pm {
	atomic_t wakeref_count;
	struct device *kdev;
	bool available;
	bool no_wakeref_tracking;
	spinlock_t lmem_userfault_lock;
	struct list_head lmem_userfault_list;
	struct intel_wakeref_auto userfault_wakeref;
};

struct i915_perf;

struct i915_perf_stream;

struct i915_oa_ops {
	bool (*is_valid_b_counter_reg)(struct i915_perf *, u32);
	bool (*is_valid_mux_reg)(struct i915_perf *, u32);
	bool (*is_valid_flex_reg)(struct i915_perf *, u32);
	int (*enable_metric_set)(struct i915_perf_stream *, struct i915_active *);
	void (*disable_metric_set)(struct i915_perf_stream *);
	void (*oa_enable)(struct i915_perf_stream *);
	void (*oa_disable)(struct i915_perf_stream *);
	int (*read)(struct i915_perf_stream *, char *, size_t, size_t *);
	u32 (*oa_hw_tail_read)(struct i915_perf_stream *);
};

struct i915_oa_format;

struct i915_perf {
	struct drm_i915_private *i915;
	struct kobject *metrics_kobj;
	struct mutex metrics_lock;
	struct idr metrics_idr;
	struct ratelimit_state spurious_report_rs;
	struct ratelimit_state tail_pointer_race;
	u32 gen7_latched_oastatus1;
	u32 ctx_oactxctrl_offset;
	u32 ctx_flexeu0_offset;
	u32 gen8_valid_ctx_bit;
	struct i915_oa_ops ops;
	const struct i915_oa_format *oa_formats;
	long unsigned int format_mask[1];
	atomic64_t noa_programming_delay;
};

struct i915_gem_contexts {
	spinlock_t lock;
	struct list_head list;
};

struct i915_pmu_sample {
	u64 cur;
};

struct i915_pmu {
	struct {
		struct hlist_node node;
		unsigned int cpu;
	} cpuhp;
	struct pmu base;
	bool registered;
	const char *name;
	spinlock_t lock;
	unsigned int unparked;
	struct hrtimer timer;
	u32 enable;
	ktime_t timer_last;
	unsigned int enable_count[9];
	bool timer_enabled;
	struct i915_pmu_sample sample[8];
	ktime_t sleep_last[2];
	long unsigned int irq_count;
	struct attribute_group events_attr_group;
	void *i915_attr;
	void *pmu_attr;
};

struct dmem_cgroup_region;

struct ttm_resource_manager_func;

struct ttm_resource_manager {
	bool use_type;
	bool use_tt;
	struct ttm_device *bdev;
	uint64_t size;
	const struct ttm_resource_manager_func *func;
	spinlock_t move_lock;
	struct dma_fence *move;
	struct list_head lru[4];
	uint64_t usage;
	struct dmem_cgroup_region *cg;
};

struct ttm_pool;

struct ttm_pool_type {
	struct ttm_pool *pool;
	unsigned int order;
	enum ttm_caching caching;
	struct list_head shrinker_list;
	spinlock_t lock;
	struct list_head pages;
};

struct ttm_pool {
	struct device *dev;
	int nid;
	bool use_dma_alloc;
	bool use_dma32;
	struct {
		struct ttm_pool_type orders[11];
	} caching[3];
};

struct ttm_device_funcs;

struct ttm_device {
	struct list_head device_list;
	const struct ttm_device_funcs *funcs;
	struct ttm_resource_manager sysman;
	struct ttm_resource_manager *man_drv[8];
	struct drm_vma_offset_manager *vma_manager;
	struct ttm_pool pool;
	spinlock_t lru_lock;
	struct list_head unevictable;
	struct address_space *dev_mapping;
	struct workqueue_struct *wq;
};

struct intel_device_info;

struct vlv_s0ix_state;

struct i915_hwmon;

struct intel_pxp;

struct drm_i915_private {
	struct drm_device drm;
	struct intel_display display;
	bool do_release;
	struct i915_params params;
	const struct intel_device_info *__info;
	struct intel_runtime_info __runtime;
	struct intel_driver_caps caps;
	struct i915_dsm dsm;
	struct intel_uncore uncore;
	struct intel_uncore_mmio_debug mmio_debug;
	struct i915_virtual_gpu vgpu;
	struct intel_gvt *gvt;
	struct {
		struct pci_dev *pdev;
		struct resource mch_res;
		bool mchbar_need_disable;
	} gmch;
	union {
		struct llist_head uabi_engines_llist;
		struct list_head uabi_engines_list;
		struct rb_root uabi_engines;
	};
	unsigned int engine_uabi_class_count[5];
	spinlock_t irq_lock;
	bool irqs_enabled;
	struct mutex sbi_lock;
	struct {
		struct mutex lock;
		struct pm_qos_request qos;
	} vlv_iosf_sb;
	struct mutex sb_lock;
	u32 irq_mask;
	bool preserve_bios_swizzle;
	unsigned int fsb_freq;
	unsigned int mem_freq;
	unsigned int is_ddr3;
	unsigned int hpll_freq;
	unsigned int czclk_freq;
	struct workqueue_struct *wq;
	struct workqueue_struct *unordered_wq;
	const struct drm_i915_clock_gating_funcs *clock_gating_funcs;
	enum intel_pch pch_type;
	short unsigned int pch_id;
	long unsigned int gem_quirks;
	struct i915_gem_mm mm;
	struct intel_l3_parity l3_parity;
	u32 edram_size_mb;
	struct i915_gpu_error gpu_error;
	u32 suspend_count;
	struct vlv_s0ix_state *vlv_s0ix_state;
	struct dram_info dram_info;
	struct intel_runtime_pm runtime_pm;
	struct i915_perf perf;
	struct i915_hwmon *hwmon;
	struct intel_gt *gt[2];
	struct kobject *sysfs_gt;
	struct intel_gt *media_gt;
	struct {
		struct i915_gem_contexts contexts;
		struct file *mmap_singleton;
	} gem;
	struct intel_pxp *pxp;
	struct i915_pmu pmu;
	struct ttm_device bdev;
};

struct drm_i915_query {
	__u32 num_items;
	__u32 flags;
	__u64 items_ptr;
};

struct drm_i915_query_engine_info {
	__u32 num_engines;
	__u32 rsvd[3];
	struct drm_i915_engine_info engines[0];
};

struct drm_i915_query_guc_submission_version {
	__u32 branch;
	__u32 major;
	__u32 minor;
	__u32 patch;
};

struct drm_i915_query_item {
	__u64 query_id;
	__s32 length;
	__u32 flags;
	__u64 data_ptr;
};

struct drm_i915_query_memory_regions {
	__u32 num_regions;
	__u32 rsvd[3];
	struct drm_i915_memory_region_info regions[0];
};

struct drm_i915_query_perf_config {
	union {
		__u64 n_configs;
		__u64 config;
		char uuid[36];
	};
	__u32 flags;
	__u8 data[0];
};

struct drm_i915_query_topology_info {
	__u16 flags;
	__u16 max_slices;
	__u16 max_subslices;
	__u16 max_eus_per_subslice;
	__u16 subslice_offset;
	__u16 subslice_stride;
	__u16 eu_offset;
	__u16 eu_stride;
	__u8 data[0];
};

struct drm_i915_reg_descriptor {
	i915_reg_t addr;
	u32 mask;
	u32 value;
};

struct drm_i915_reg_read {
	__u64 offset;
	__u64 val;
};

struct drm_i915_reg_table {
	const struct drm_i915_reg_descriptor *regs;
	int num_regs;
};

struct drm_i915_reset_stats {
	__u32 ctx_id;
	__u32 flags;
	__u32 reset_count;
	__u32 batch_active;
	__u32 batch_pending;
	__u32 pad;
};

struct drm_info_list {
	const char *name;
	int (*show)(struct seq_file *, void *);
	u32 driver_features;
	void *data;
};

struct drm_info_node {
	struct drm_minor *minor;
	const struct drm_info_list *info_ent;
	struct list_head list;
	struct dentry *dent;
};

struct drm_intel_overlay_attrs {
	__u32 flags;
	__u32 color_key;
	__s32 brightness;
	__u32 contrast;
	__u32 saturation;
	__u32 gamma0;
	__u32 gamma1;
	__u32 gamma2;
	__u32 gamma3;
	__u32 gamma4;
	__u32 gamma5;
};

struct drm_intel_overlay_put_image {
	__u32 flags;
	__u32 bo_handle;
	__u16 stride_Y;
	__u16 stride_UV;
	__u32 offset_Y;
	__u32 offset_U;
	__u32 offset_V;
	__u16 src_width;
	__u16 src_height;
	__u16 src_scan_width;
	__u16 src_scan_height;
	__u32 crtc_id;
	__u16 dst_x;
	__u16 dst_y;
	__u16 dst_width;
	__u16 dst_height;
};

struct drm_intel_sprite_colorkey {
	__u32 plane_id;
	__u32 min_value;
	__u32 channel_mask;
	__u32 max_value;
	__u32 flags;
};

typedef int drm_ioctl_t(struct drm_device *, void *, struct drm_file *);

struct drm_ioctl_desc {
	unsigned int cmd;
	enum drm_ioctl_flags flags;
	drm_ioctl_t *func;
	const char *name;
};

struct drm_master {
	struct kref refcount;
	struct drm_device *dev;
	char *unique;
	int unique_len;
	struct idr magic_map;
	void *driver_priv;
	struct drm_master *lessor;
	int lessee_id;
	struct list_head lessee_list;
	struct list_head lessees;
	struct idr leases;
	struct idr lessee_idr;
};

struct drm_memory_stats {
	u64 shared;
	u64 private;
	u64 resident;
	u64 purgeable;
	u64 active;
};

struct drm_minor {
	int index;
	int type;
	struct device *kdev;
	struct drm_device *dev;
	struct dentry *debugfs_symlink;
	struct dentry *debugfs_root;
};

struct drm_mm_scan {
	struct drm_mm *mm;
	u64 size;
	u64 alignment;
	u64 remainder_mask;
	u64 range_start;
	u64 range_end;
	u64 hit_start;
	u64 hit_end;
	long unsigned int color;
	enum drm_mm_insert_mode mode;
};

struct drm_mode_atomic {
	__u32 flags;
	__u32 count_objs;
	__u64 objs_ptr;
	__u64 count_props_ptr;
	__u64 props_ptr;
	__u64 prop_values_ptr;
	__u64 reserved;
	__u64 user_data;
};

struct drm_mode_card_res {
	__u64 fb_id_ptr;
	__u64 crtc_id_ptr;
	__u64 connector_id_ptr;
	__u64 encoder_id_ptr;
	__u32 count_fbs;
	__u32 count_crtcs;
	__u32 count_connectors;
	__u32 count_encoders;
	__u32 min_width;
	__u32 max_width;
	__u32 min_height;
	__u32 max_height;
};

struct drm_mode_closefb {
	__u32 fb_id;
	__u32 pad;
};

struct drm_mode_fb_cmd2;

struct drm_mode_config_funcs {
	struct drm_framebuffer * (*fb_create)(struct drm_device *, struct drm_file *, const struct drm_mode_fb_cmd2 *);
	const struct drm_format_info * (*get_format_info)(const struct drm_mode_fb_cmd2 *);
	enum drm_mode_status (*mode_valid)(struct drm_device *, const struct drm_display_mode *);
	int (*atomic_check)(struct drm_device *, struct drm_atomic_state *);
	int (*atomic_commit)(struct drm_device *, struct drm_atomic_state *, bool);
	struct drm_atomic_state * (*atomic_state_alloc)(struct drm_device *);
	void (*atomic_state_clear)(struct drm_atomic_state *);
	void (*atomic_state_free)(struct drm_atomic_state *);
};

struct drm_mode_config_helper_funcs {
	void (*atomic_commit_tail)(struct drm_atomic_state *);
	int (*atomic_commit_setup)(struct drm_atomic_state *);
};

struct drm_mode_connector_set_property {
	__u64 value;
	__u32 prop_id;
	__u32 connector_id;
};

struct drm_mode_create_blob {
	__u64 data;
	__u32 length;
	__u32 blob_id;
};

struct drm_mode_create_dumb {
	__u32 height;
	__u32 width;
	__u32 bpp;
	__u32 flags;
	__u32 handle;
	__u32 pitch;
	__u64 size;
};

struct drm_mode_create_lease {
	__u64 object_ids;
	__u32 object_count;
	__u32 flags;
	__u32 lessee_id;
	__u32 fd;
};

struct drm_mode_modeinfo {
	__u32 clock;
	__u16 hdisplay;
	__u16 hsync_start;
	__u16 hsync_end;
	__u16 htotal;
	__u16 hskew;
	__u16 vdisplay;
	__u16 vsync_start;
	__u16 vsync_end;
	__u16 vtotal;
	__u16 vscan;
	__u32 vrefresh;
	__u32 flags;
	__u32 type;
	char name[32];
};

struct drm_mode_crtc {
	__u64 set_connectors_ptr;
	__u32 count_connectors;
	__u32 crtc_id;
	__u32 fb_id;
	__u32 x;
	__u32 y;
	__u32 gamma_size;
	__u32 mode_valid;
	struct drm_mode_modeinfo mode;
};

struct drm_mode_crtc_lut {
	__u32 crtc_id;
	__u32 gamma_size;
	__u64 red;
	__u64 green;
	__u64 blue;
};

struct drm_mode_crtc_page_flip_target {
	__u32 crtc_id;
	__u32 fb_id;
	__u32 flags;
	__u32 sequence;
	__u64 user_data;
};

struct drm_mode_cursor {
	__u32 flags;
	__u32 crtc_id;
	__s32 x;
	__s32 y;
	__u32 width;
	__u32 height;
	__u32 handle;
};

struct drm_mode_cursor2 {
	__u32 flags;
	__u32 crtc_id;
	__s32 x;
	__s32 y;
	__u32 width;
	__u32 height;
	__u32 handle;
	__s32 hot_x;
	__s32 hot_y;
};

struct drm_mode_destroy_blob {
	__u32 blob_id;
};

struct drm_mode_destroy_dumb {
	__u32 handle;
};

struct drm_mode_fb_cmd {
	__u32 fb_id;
	__u32 width;
	__u32 height;
	__u32 pitch;
	__u32 bpp;
	__u32 depth;
	__u32 handle;
};

struct drm_mode_fb_cmd2 {
	__u32 fb_id;
	__u32 width;
	__u32 height;
	__u32 pixel_format;
	__u32 flags;
	__u32 handles[4];
	__u32 pitches[4];
	__u32 offsets[4];
	__u64 modifier[4];
};

struct drm_mode_fb_cmd232 {
	u32 fb_id;
	u32 width;
	u32 height;
	u32 pixel_format;
	u32 flags;
	u32 handles[4];
	u32 pitches[4];
	u32 offsets[4];
	u64 modifier[4];
} __attribute__((packed));

struct drm_mode_fb_dirty_cmd {
	__u32 fb_id;
	__u32 flags;
	__u32 color;
	__u32 num_clips;
	__u64 clips_ptr;
};

struct drm_mode_get_blob {
	__u32 blob_id;
	__u32 length;
	__u64 data;
};

struct drm_mode_get_connector {
	__u64 encoders_ptr;
	__u64 modes_ptr;
	__u64 props_ptr;
	__u64 prop_values_ptr;
	__u32 count_modes;
	__u32 count_props;
	__u32 count_encoders;
	__u32 encoder_id;
	__u32 connector_id;
	__u32 connector_type;
	__u32 connector_type_id;
	__u32 connection;
	__u32 mm_width;
	__u32 mm_height;
	__u32 subpixel;
	__u32 pad;
};

struct drm_mode_get_encoder {
	__u32 encoder_id;
	__u32 encoder_type;
	__u32 crtc_id;
	__u32 possible_crtcs;
	__u32 possible_clones;
};

struct drm_mode_get_lease {
	__u32 count_objects;
	__u32 pad;
	__u64 objects_ptr;
};

struct drm_mode_get_plane {
	__u32 plane_id;
	__u32 crtc_id;
	__u32 fb_id;
	__u32 possible_crtcs;
	__u32 gamma_size;
	__u32 count_format_types;
	__u64 format_type_ptr;
};

struct drm_mode_get_plane_res {
	__u64 plane_id_ptr;
	__u32 count_planes;
};

struct drm_mode_get_property {
	__u64 values_ptr;
	__u64 enum_blob_ptr;
	__u32 prop_id;
	__u32 flags;
	char name[32];
	__u32 count_values;
	__u32 count_enum_blobs;
};

struct drm_mode_list_lessees {
	__u32 count_lessees;
	__u32 pad;
	__u64 lessees_ptr;
};

struct drm_mode_map_dumb {
	__u32 handle;
	__u32 pad;
	__u64 offset;
};

struct drm_mode_obj_get_properties {
	__u64 props_ptr;
	__u64 prop_values_ptr;
	__u32 count_props;
	__u32 obj_id;
	__u32 obj_type;
};

struct drm_mode_obj_set_property {
	__u64 value;
	__u32 prop_id;
	__u32 obj_id;
	__u32 obj_type;
};

struct drm_mode_property_enum {
	__u64 value;
	char name[32];
};

struct drm_mode_rect {
	__s32 x1;
	__s32 y1;
	__s32 x2;
	__s32 y2;
};

struct drm_mode_revoke_lease {
	__u32 lessee_id;
};

struct drm_mode_rmfb_work {
	struct work_struct work;
	struct list_head fbs;
};

struct drm_mode_set {
	struct drm_framebuffer *fb;
	struct drm_crtc *crtc;
	struct drm_display_mode *mode;
	uint32_t x;
	uint32_t y;
	struct drm_connector **connectors;
	size_t num_connectors;
};

struct drm_mode_set_plane {
	__u32 plane_id;
	__u32 crtc_id;
	__u32 fb_id;
	__u32 flags;
	__s32 crtc_x;
	__s32 crtc_y;
	__u32 crtc_w;
	__u32 crtc_h;
	__u32 src_x;
	__u32 src_y;
	__u32 src_h;
	__u32 src_w;
};

struct drm_named_mode {
	const char *name;
	unsigned int pixel_clock_khz;
	unsigned int xres;
	unsigned int yres;
	unsigned int flags;
	unsigned int tv_mode;
};

struct sync_file;

struct drm_out_fence_state {
	s32 *out_fence_ptr;
	struct sync_file *sync_file;
	int fd;
};

struct drm_panel_funcs;

struct drm_panel {
	struct device *dev;
	struct backlight_device *backlight;
	const struct drm_panel_funcs *funcs;
	int connector_type;
	struct list_head list;
	struct list_head followers;
	struct mutex follower_lock;
	bool prepare_prev_first;
	bool prepared;
	bool enabled;
};

struct drm_panel_follower_funcs;

struct drm_panel_follower {
	const struct drm_panel_follower_funcs *funcs;
	struct list_head list;
	struct drm_panel *panel;
};

struct drm_panel_follower_funcs {
	int (*panel_prepared)(struct drm_panel_follower *);
	int (*panel_unpreparing)(struct drm_panel_follower *);
};

struct display_timing;

struct drm_panel_funcs {
	int (*prepare)(struct drm_panel *);
	int (*enable)(struct drm_panel *);
	int (*disable)(struct drm_panel *);
	int (*unprepare)(struct drm_panel *);
	int (*get_modes)(struct drm_panel *, struct drm_connector *);
	enum drm_panel_orientation (*get_orientation)(struct drm_panel *);
	int (*get_timings)(struct drm_panel *, unsigned int, struct display_timing *);
	void (*debugfs_init)(struct drm_panel *, struct dentry *);
};

struct drm_pending_event {
	struct completion *completion;
	void (*completion_release)(struct completion *);
	struct drm_event *event;
	struct dma_fence *fence;
	struct drm_file *file_priv;
	struct list_head link;
	struct list_head pending_link;
};

struct drm_pending_vblank_event {
	struct drm_pending_event base;
	unsigned int pipe;
	u64 sequence;
	union {
		struct drm_event base;
		struct drm_event_vblank vbl;
		struct drm_event_crtc_sequence seq;
	} event;
};

struct kmsg_dump_detail;

struct kmsg_dumper {
	struct list_head list;
	void (*dump)(struct kmsg_dumper *, struct kmsg_dump_detail *);
	enum kmsg_dump_reason max_reason;
	bool registered;
};

struct drm_plane_funcs;

struct drm_plane_helper_funcs;

struct drm_plane {
	struct drm_device *dev;
	struct list_head head;
	char *name;
	struct drm_modeset_lock mutex;
	struct drm_mode_object base;
	uint32_t possible_crtcs;
	uint32_t *format_types;
	unsigned int format_count;
	bool format_default;
	uint64_t *modifiers;
	unsigned int modifier_count;
	struct drm_crtc *crtc;
	struct drm_framebuffer *fb;
	struct drm_framebuffer *old_fb;
	const struct drm_plane_funcs *funcs;
	struct drm_object_properties properties;
	enum drm_plane_type type;
	unsigned int index;
	const struct drm_plane_helper_funcs *helper_private;
	struct drm_plane_state *state;
	struct drm_property *alpha_property;
	struct drm_property *zpos_property;
	struct drm_property *rotation_property;
	struct drm_property *blend_mode_property;
	struct drm_property *color_encoding_property;
	struct drm_property *color_range_property;
	struct drm_property *scaling_filter_property;
	struct drm_property *hotspot_x_property;
	struct drm_property *hotspot_y_property;
	struct kmsg_dumper kmsg_panic;
};

struct drm_plane_funcs {
	int (*update_plane)(struct drm_plane *, struct drm_crtc *, struct drm_framebuffer *, int, int, unsigned int, unsigned int, uint32_t, uint32_t, uint32_t, uint32_t, struct drm_modeset_acquire_ctx *);
	int (*disable_plane)(struct drm_plane *, struct drm_modeset_acquire_ctx *);
	void (*destroy)(struct drm_plane *);
	void (*reset)(struct drm_plane *);
	int (*set_property)(struct drm_plane *, struct drm_property *, uint64_t);
	struct drm_plane_state * (*atomic_duplicate_state)(struct drm_plane *);
	void (*atomic_destroy_state)(struct drm_plane *, struct drm_plane_state *);
	int (*atomic_set_property)(struct drm_plane *, struct drm_plane_state *, struct drm_property *, uint64_t);
	int (*atomic_get_property)(struct drm_plane *, const struct drm_plane_state *, struct drm_property *, uint64_t *);
	int (*late_register)(struct drm_plane *);
	void (*early_unregister)(struct drm_plane *);
	void (*atomic_print_state)(struct drm_printer *, const struct drm_plane_state *);
	bool (*format_mod_supported)(struct drm_plane *, uint32_t, uint64_t);
};

struct drm_scanout_buffer;

struct drm_plane_helper_funcs {
	int (*prepare_fb)(struct drm_plane *, struct drm_plane_state *);
	void (*cleanup_fb)(struct drm_plane *, struct drm_plane_state *);
	int (*begin_fb_access)(struct drm_plane *, struct drm_plane_state *);
	void (*end_fb_access)(struct drm_plane *, struct drm_plane_state *);
	int (*atomic_check)(struct drm_plane *, struct drm_atomic_state *);
	void (*atomic_update)(struct drm_plane *, struct drm_atomic_state *);
	void (*atomic_enable)(struct drm_plane *, struct drm_atomic_state *);
	void (*atomic_disable)(struct drm_plane *, struct drm_atomic_state *);
	int (*atomic_async_check)(struct drm_plane *, struct drm_atomic_state *);
	void (*atomic_async_update)(struct drm_plane *, struct drm_atomic_state *);
	int (*get_scanout_buffer)(struct drm_plane *, struct drm_scanout_buffer *);
	void (*panic_flush)(struct drm_plane *);
};

struct drm_plane_size_hint {
	__u16 width;
	__u16 height;
};

struct drm_plane_state {
	struct drm_plane *plane;
	struct drm_crtc *crtc;
	struct drm_framebuffer *fb;
	struct dma_fence *fence;
	int32_t crtc_x;
	int32_t crtc_y;
	uint32_t crtc_w;
	uint32_t crtc_h;
	uint32_t src_x;
	uint32_t src_y;
	uint32_t src_h;
	uint32_t src_w;
	int32_t hotspot_x;
	int32_t hotspot_y;
	u16 alpha;
	uint16_t pixel_blend_mode;
	unsigned int rotation;
	unsigned int zpos;
	unsigned int normalized_zpos;
	enum drm_color_encoding color_encoding;
	enum drm_color_range color_range;
	struct drm_property_blob *fb_damage_clips;
	bool ignore_damage_clips;
	struct drm_rect src;
	struct drm_rect dst;
	bool visible;
	enum drm_scaling_filter scaling_filter;
	struct drm_crtc_commit *commit;
	struct drm_atomic_state *state;
	bool color_mgmt_changed: 1;
};

struct drm_prime_handle {
	__u32 handle;
	__u32 flags;
	__s32 fd;
};

struct drm_prime_member {
	struct dma_buf *dma_buf;
	uint32_t handle;
	struct rb_node dmabuf_rb;
	struct rb_node handle_rb;
};

struct drm_print_iterator {
	void *data;
	ssize_t start;
	ssize_t remain;
	ssize_t offset;
};

struct va_format;

struct drm_printer {
	void (*printfn)(struct drm_printer *, struct va_format *);
	void (*puts)(struct drm_printer *, const char *);
	void *arg;
	const void *origin;
	const char *prefix;
	struct {
		unsigned int series;
		unsigned int counter;
	} line;
	enum drm_debug_category category;
};

struct drm_private_state_funcs {
	struct drm_private_state * (*atomic_duplicate_state)(struct drm_private_obj *);
	void (*atomic_destroy_state)(struct drm_private_obj *, struct drm_private_state *);
	void (*atomic_print_state)(struct drm_printer *, const struct drm_private_state *);
};

struct drm_prop_enum_list {
	int type;
	const char *name;
};

struct drm_property {
	struct list_head head;
	struct drm_mode_object base;
	uint32_t flags;
	char name[32];
	uint32_t num_values;
	uint64_t *values;
	struct drm_device *dev;
	struct list_head enum_list;
};

struct drm_property_blob {
	struct drm_mode_object base;
	struct drm_device *dev;
	struct list_head head_global;
	struct list_head head_file;
	size_t length;
	void *data;
};

struct drm_property_enum {
	uint64_t value;
	struct list_head head;
	char name[32];
};

struct drm_scanout_buffer {
	const struct drm_format_info *format;
	struct iosys_map map[4];
	unsigned int width;
	unsigned int height;
	unsigned int pitch[4];
	void (*set_pixel)(struct drm_scanout_buffer *, unsigned int, unsigned int, u32);
};

struct ewma_psr_time {
	long unsigned int internal;
};

struct drm_self_refresh_data {
	struct drm_crtc *crtc;
	struct delayed_work entry_work;
	struct mutex avg_mutex;
	struct ewma_psr_time entry_avg_ms;
	struct ewma_psr_time exit_avg_ms;
};

struct drm_set_client_cap {
	__u64 capability;
	__u64 value;
};

struct drm_set_client_name {
	__u64 name_len;
	__u64 name;
};

struct drm_set_version {
	int drm_di_major;
	int drm_di_minor;
	int drm_dd_major;
	int drm_dd_minor;
};

struct drm_shadow_plane_state {
	struct drm_plane_state base;
	struct drm_format_conv_state fmtcnv_state;
	struct iosys_map map[4];
	struct iosys_map data[4];
};

struct drm_simple_display_pipe_funcs;

struct drm_simple_display_pipe {
	struct drm_crtc crtc;
	struct drm_plane plane;
	struct drm_encoder encoder;
	struct drm_connector *connector;
	const struct drm_simple_display_pipe_funcs *funcs;
};

struct drm_simple_display_pipe_funcs {
	enum drm_mode_status (*mode_valid)(struct drm_simple_display_pipe *, const struct drm_display_mode *);
	void (*enable)(struct drm_simple_display_pipe *, struct drm_crtc_state *, struct drm_plane_state *);
	void (*disable)(struct drm_simple_display_pipe *);
	int (*check)(struct drm_simple_display_pipe *, struct drm_plane_state *, struct drm_crtc_state *);
	void (*update)(struct drm_simple_display_pipe *, struct drm_plane_state *);
	int (*prepare_fb)(struct drm_simple_display_pipe *, struct drm_plane_state *);
	void (*cleanup_fb)(struct drm_simple_display_pipe *, struct drm_plane_state *);
	int (*begin_fb_access)(struct drm_simple_display_pipe *, struct drm_plane_state *);
	void (*end_fb_access)(struct drm_simple_display_pipe *, struct drm_plane_state *);
	int (*enable_vblank)(struct drm_simple_display_pipe *);
	void (*disable_vblank)(struct drm_simple_display_pipe *);
	void (*reset_crtc)(struct drm_simple_display_pipe *);
	struct drm_crtc_state * (*duplicate_crtc_state)(struct drm_simple_display_pipe *);
	void (*destroy_crtc_state)(struct drm_simple_display_pipe *, struct drm_crtc_state *);
	void (*reset_plane)(struct drm_simple_display_pipe *);
	struct drm_plane_state * (*duplicate_plane_state)(struct drm_simple_display_pipe *);
	void (*destroy_plane_state)(struct drm_simple_display_pipe *, struct drm_plane_state *);
};

struct drm_stats {
	long unsigned int count;
	struct {
		long unsigned int value;
		enum drm_stat_type type;
	} data[15];
};

struct drm_stats32 {
	u32 count;
	struct {
		u32 value;
		enum drm_stat_type type;
	} data[15];
};

typedef struct drm_stats32 drm_stats32_t;

struct drm_syncobj {
	struct kref refcount;
	struct dma_fence *fence;
	struct list_head cb_list;
	struct list_head ev_fd_list;
	spinlock_t lock;
	struct file *file;
};

struct drm_syncobj_array {
	__u64 handles;
	__u32 count_handles;
	__u32 pad;
};

struct drm_syncobj_create {
	__u32 handle;
	__u32 flags;
};

struct drm_syncobj_destroy {
	__u32 handle;
	__u32 pad;
};

struct drm_syncobj_eventfd {
	__u32 handle;
	__u32 flags;
	__u64 point;
	__s32 fd;
	__u32 pad;
};

struct drm_syncobj_handle {
	__u32 handle;
	__u32 flags;
	__s32 fd;
	__u32 pad;
};

struct drm_syncobj_timeline_array {
	__u64 handles;
	__u64 points;
	__u32 count_handles;
	__u32 flags;
};

struct drm_syncobj_timeline_wait {
	__u64 handles;
	__u64 points;
	__s64 timeout_nsec;
	__u32 count_handles;
	__u32 flags;
	__u32 first_signaled;
	__u32 pad;
	__u64 deadline_nsec;
};

struct drm_syncobj_transfer {
	__u32 src_handle;
	__u32 dst_handle;
	__u64 src_point;
	__u64 dst_point;
	__u32 flags;
	__u32 pad;
};

struct drm_syncobj_wait {
	__u64 handles;
	__s64 timeout_nsec;
	__u32 count_handles;
	__u32 flags;
	__u32 first_signaled;
	__u32 pad;
	__u64 deadline_nsec;
};

struct drm_tile_group {
	struct kref refcount;
	struct drm_device *dev;
	int id;
	u8 group_data[8];
};

struct drm_unique {
	__kernel_size_t unique_len;
	char *unique;
};

struct drm_unique32 {
	u32 unique_len;
	u32 unique;
};

typedef struct drm_unique32 drm_unique32_t;

struct drm_vblank_crtc_config {
	int offdelay_ms;
	bool disable_immediate;
};

struct drm_vblank_crtc {
	struct drm_device *dev;
	wait_queue_head_t queue;
	struct timer_list disable_timer;
	seqlock_t seqlock;
	atomic64_t count;
	ktime_t time;
	atomic_t refcount;
	u32 last;
	u32 max_vblank_count;
	unsigned int inmodeset;
	unsigned int pipe;
	int framedur_ns;
	int linedur_ns;
	struct drm_display_mode hwmode;
	struct drm_vblank_crtc_config config;
	bool enabled;
	struct kthread_worker *worker;
	struct list_head pending_work;
	wait_queue_head_t work_wait_queue;
};

struct drm_vblank_work {
	struct kthread_work base;
	struct drm_vblank_crtc *vblank;
	u64 count;
	int cancelling;
	struct list_head node;
};

struct drm_version {
	int version_major;
	int version_minor;
	int version_patchlevel;
	__kernel_size_t name_len;
	char *name;
	__kernel_size_t date_len;
	char *date;
	__kernel_size_t desc_len;
	char *desc;
};

struct drm_version_32 {
	int version_major;
	int version_minor;
	int version_patchlevel;
	u32 name_len;
	u32 name;
	u32 date_len;
	u32 date;
	u32 desc_len;
	u32 desc;
};

typedef struct drm_version_32 drm_version32_t;

struct drm_virtgpu_3d_box {
	__u32 x;
	__u32 y;
	__u32 z;
	__u32 w;
	__u32 h;
	__u32 d;
};

struct drm_virtgpu_3d_transfer_from_host {
	__u32 bo_handle;
	struct drm_virtgpu_3d_box box;
	__u32 level;
	__u32 offset;
	__u32 stride;
	__u32 layer_stride;
};

struct drm_virtgpu_3d_transfer_to_host {
	__u32 bo_handle;
	struct drm_virtgpu_3d_box box;
	__u32 level;
	__u32 offset;
	__u32 stride;
	__u32 layer_stride;
};

struct drm_virtgpu_3d_wait {
	__u32 handle;
	__u32 flags;
};

struct drm_virtgpu_context_init {
	__u32 num_params;
	__u32 pad;
	__u64 ctx_set_params;
};

struct drm_virtgpu_context_set_param {
	__u64 param;
	__u64 value;
};

struct drm_virtgpu_execbuffer {
	__u32 flags;
	__u32 size;
	__u64 command;
	__u64 bo_handles;
	__u32 num_bo_handles;
	__s32 fence_fd;
	__u32 ring_idx;
	__u32 syncobj_stride;
	__u32 num_in_syncobjs;
	__u32 num_out_syncobjs;
	__u64 in_syncobjs;
	__u64 out_syncobjs;
};

struct drm_virtgpu_execbuffer_syncobj {
	__u32 handle;
	__u32 flags;
	__u64 point;
};

struct drm_virtgpu_get_caps {
	__u32 cap_set_id;
	__u32 cap_set_ver;
	__u64 addr;
	__u32 size;
	__u32 pad;
};

struct drm_virtgpu_getparam {
	__u64 param;
	__u64 value;
};

struct drm_virtgpu_map {
	__u64 offset;
	__u32 handle;
	__u32 pad;
};

struct drm_virtgpu_resource_create {
	__u32 target;
	__u32 format;
	__u32 bind;
	__u32 width;
	__u32 height;
	__u32 depth;
	__u32 array_size;
	__u32 last_level;
	__u32 nr_samples;
	__u32 flags;
	__u32 bo_handle;
	__u32 res_handle;
	__u32 size;
	__u32 stride;
};

struct drm_virtgpu_resource_create_blob {
	__u32 blob_mem;
	__u32 blob_flags;
	__u32 bo_handle;
	__u32 res_handle;
	__u64 size;
	__u32 pad;
	__u32 cmd_size;
	__u64 cmd;
	__u64 blob_id;
};

struct drm_virtgpu_resource_info {
	__u32 bo_handle;
	__u32 res_handle;
	__u32 size;
	__u32 blob_mem;
};

struct drm_vma_offset_file {
	struct rb_node vm_rb;
	struct drm_file *vm_tag;
	long unsigned int vm_count;
};

struct drm_vma_offset_manager {
	rwlock_t vm_lock;
	struct drm_mm vm_addr_space_mm;
};

struct drm_wait_vblank_request {
	enum drm_vblank_seq_type type;
	unsigned int sequence;
	long unsigned int signal;
};

struct drm_wait_vblank_reply {
	enum drm_vblank_seq_type type;
	unsigned int sequence;
	long int tval_sec;
	long int tval_usec;
};

union drm_wait_vblank {
	struct drm_wait_vblank_request request;
	struct drm_wait_vblank_reply reply;
};

struct drm_wait_vblank_request32 {
	enum drm_vblank_seq_type type;
	unsigned int sequence;
	u32 signal;
};

struct drm_wait_vblank_reply32 {
	enum drm_vblank_seq_type type;
	unsigned int sequence;
	s32 tval_sec;
	s32 tval_usec;
};

union drm_wait_vblank32 {
	struct drm_wait_vblank_request32 request;
	struct drm_wait_vblank_reply32 reply;
};

typedef union drm_wait_vblank32 drm_wait_vblank32_t;

struct drm_writeback_connector {
	struct drm_connector base;
	struct drm_encoder encoder;
	struct drm_property_blob *pixel_formats_blob_ptr;
	spinlock_t job_lock;
	struct list_head job_queue;
	unsigned int fence_context;
	spinlock_t fence_lock;
	long unsigned int fence_seqno;
	char timeline_name[32];
};

struct drm_writeback_job {
	struct drm_writeback_connector *connector;
	bool prepared;
	struct work_struct cleanup_work;
	struct list_head list_entry;
	struct drm_framebuffer *fb;
	struct dma_fence *out_fence;
	void *priv;
};

typedef void (*drmres_release_t)(struct drm_device *, void *);

struct drmres_node {
	struct list_head entry;
	drmres_release_t release;
	const char *name;
	size_t size;
};

struct drmres {
	struct drmres_node node;
	u8 data[0];
};

struct drop_reason_list {
	const char * const *reasons;
	size_t n_reasons;
};

struct drv_cmd {
	struct acpi_pct_register *reg;
	u32 val;
	union {
		void (*write)(struct acpi_pct_register *, u32);
		u32 (*read)(struct acpi_pct_register *);
	} func;
};

struct pci_driver;

struct pci_device_id;

struct drv_dev_and_id {
	struct pci_driver *drv;
	struct pci_dev *dev;
	const struct pci_device_id *id;
};

struct dst_cache_pcpu;

struct dst_cache {
	struct dst_cache_pcpu *cache;
	long unsigned int reset_ts;
};

struct dst_entry;

struct dst_cache_pcpu {
	long unsigned int refresh_ts;
	struct dst_entry *dst;
	u32 cookie;
	union {
		struct in_addr in_saddr;
		struct in6_addr in6_saddr;
	};
};

struct dst_ops;

struct xfrm_state;

struct uncached_list;

struct lwtunnel_state;

struct dst_entry {
	struct net_device *dev;
	struct dst_ops *ops;
	long unsigned int _metrics;
	long unsigned int expires;
	struct xfrm_state *xfrm;
	int (*input)(struct sk_buff *);
	int (*output)(struct net *, struct sock *, struct sk_buff *);
	short unsigned int flags;
	short int obsolete;
	short unsigned int header_len;
	short unsigned int trailer_len;
	rcuref_t __rcuref;
	int __use;
	long unsigned int lastuse;
	struct callback_head callback_head;
	short int error;
	short int __pad;
	__u32 tclassid;
	netdevice_tracker dev_tracker;
	struct list_head rt_uncached;
	struct uncached_list *rt_uncached_list;
	struct lwtunnel_state *lwtstate;
};

struct dst_metrics {
	u32 metrics[17];
	refcount_t refcnt;
};

struct neighbour;

struct dst_ops {
	short unsigned int family;
	unsigned int gc_thresh;
	void (*gc)(struct dst_ops *);
	struct dst_entry * (*check)(struct dst_entry *, __u32);
	unsigned int (*default_advmss)(const struct dst_entry *);
	unsigned int (*mtu)(const struct dst_entry *);
	u32 * (*cow_metrics)(struct dst_entry *, long unsigned int);
	void (*destroy)(struct dst_entry *);
	void (*ifdown)(struct dst_entry *, struct net_device *);
	void (*negative_advice)(struct sock *, struct dst_entry *);
	void (*link_failure)(struct sk_buff *);
	void (*update_pmtu)(struct dst_entry *, struct sock *, struct sk_buff *, u32, bool);
	void (*redirect)(struct dst_entry *, struct sock *, struct sk_buff *);
	int (*local_out)(struct net *, struct sock *, struct sk_buff *);
	struct neighbour * (*neigh_lookup)(const struct dst_entry *, struct sk_buff *, const void *);
	void (*confirm_neigh)(const struct dst_entry *, const void *);
	struct kmem_cache *kmem_cachep;
	struct percpu_counter pcpuc_entries;
	long: 64;
	long: 64;
	long: 64;
};

struct uart_8250_port;

struct uart_8250_dma {
	int (*tx_dma)(struct uart_8250_port *);
	int (*rx_dma)(struct uart_8250_port *);
	void (*prepare_tx_dma)(struct uart_8250_port *);
	void (*prepare_rx_dma)(struct uart_8250_port *);
	dma_filter_fn fn;
	void *rx_param;
	void *tx_param;
	struct dma_slave_config rxconf;
	struct dma_slave_config txconf;
	struct dma_chan *rxchan;
	struct dma_chan *txchan;
	phys_addr_t rx_dma_addr;
	phys_addr_t tx_dma_addr;
	dma_addr_t rx_addr;
	dma_addr_t tx_addr;
	dma_cookie_t rx_cookie;
	dma_cookie_t tx_cookie;
	void *rx_buf;
	size_t rx_size;
	size_t tx_size;
	unsigned char tx_running;
	unsigned char tx_err;
	unsigned char rx_running;
};

struct dw8250_port_data {
	int line;
	struct uart_8250_dma dma;
	u32 cpr_value;
	u8 dlf_size;
	bool hw_rs485_support;
};

struct dw_lli {
	__le32 sar;
	__le32 dar;
	__le32 llp;
	__le32 ctllo;
	__le32 ctlhi;
	__le32 sstat;
	__le32 dstat;
};

struct dw_desc {
	struct dw_lli lli;
	struct list_head desc_node;
	struct list_head tx_list;
	struct dma_async_tx_descriptor txd;
	size_t len;
	size_t total_len;
	u32 residue;
};

struct tasklet_struct {
	struct tasklet_struct *next;
	long unsigned int state;
	atomic_t count;
	bool use_callback;
	union {
		void (*func)(long unsigned int);
		void (*callback)(struct tasklet_struct *);
	};
	long unsigned int data;
};

struct dw_dma_chan;

struct dw_dma_platform_data;

struct dw_dma {
	struct dma_device dma;
	char name[20];
	void *regs;
	struct dma_pool *desc_pool;
	struct tasklet_struct tasklet;
	struct dw_dma_chan *chan;
	u8 all_chan_mask;
	u8 in_use;
	void (*initialize_chan)(struct dw_dma_chan *);
	void (*suspend_chan)(struct dw_dma_chan *, bool);
	void (*resume_chan)(struct dw_dma_chan *, bool);
	u32 (*prepare_ctllo)(struct dw_dma_chan *);
	u32 (*bytes2block)(struct dw_dma_chan *, size_t, unsigned int, size_t *);
	size_t (*block2bytes)(struct dw_dma_chan *, u32, u32);
	void (*set_device_name)(struct dw_dma *, int);
	void (*disable)(struct dw_dma *);
	void (*enable)(struct dw_dma *);
	struct dw_dma_platform_data *pdata;
};

struct dw_dma_slave {
	struct device *dma_dev;
	u8 src_id;
	u8 dst_id;
	u8 m_master;
	u8 p_master;
	u8 channels;
	bool hs_polarity;
};

struct dw_dma_chan {
	struct dma_chan chan;
	void *ch_regs;
	u8 mask;
	u8 priority;
	enum dma_transfer_direction direction;
	struct list_head *tx_node_active;
	spinlock_t lock;
	long unsigned int flags;
	struct list_head active_list;
	struct list_head queue;
	unsigned int descs_allocated;
	unsigned int block_size;
	bool nollp;
	u32 max_burst;
	struct dw_dma_slave dws;
	struct dma_slave_config dma_sconfig;
};

struct dw_dma_chan_regs {
	u32 SAR;
	u32 __pad_SAR;
	u32 DAR;
	u32 __pad_DAR;
	u32 LLP;
	u32 __pad_LLP;
	u32 CTL_LO;
	u32 CTL_HI;
	u32 SSTAT;
	u32 __pad_SSTAT;
	u32 DSTAT;
	u32 __pad_DSTAT;
	u32 SSTATAR;
	u32 __pad_SSTATAR;
	u32 DSTATAR;
	u32 __pad_DSTATAR;
	u32 CFG_LO;
	u32 CFG_HI;
	u32 SGR;
	u32 __pad_SGR;
	u32 DSR;
	u32 __pad_DSR;
};

struct dw_dma_chip {
	struct device *dev;
	int id;
	int irq;
	void *regs;
	struct clk *clk;
	struct dw_dma *dw;
	const struct dw_dma_platform_data *pdata;
};

struct dw_dma_chip_pdata {
	const struct dw_dma_platform_data *pdata;
	int (*probe)(struct dw_dma_chip *);
	int (*remove)(struct dw_dma_chip *);
	struct dw_dma_chip *chip;
	u8 m_master;
	u8 p_master;
};

struct dw_dma_irq_regs {
	u32 XFER;
	u32 __pad_XFER;
	u32 BLOCK;
	u32 __pad_BLOCK;
	u32 SRC_TRAN;
	u32 __pad_SRC_TRAN;
	u32 DST_TRAN;
	u32 __pad_DST_TRAN;
	u32 ERROR;
	u32 __pad_ERROR;
};

struct dw_dma_platform_data {
	u32 nr_masters;
	u32 nr_channels;
	u32 chan_allocation_order;
	u32 chan_priority;
	u32 block_size;
	u32 data_width[4];
	u32 multi_block[8];
	u32 max_burst[8];
	u32 protctl;
	u32 quirks;
};

struct dw_dma_regs {
	struct dw_dma_chan_regs CHAN[8];
	struct dw_dma_irq_regs RAW;
	struct dw_dma_irq_regs STATUS;
	struct dw_dma_irq_regs MASK;
	struct dw_dma_irq_regs CLEAR;
	u32 STATUS_INT;
	u32 __pad_STATUS_INT;
	u32 REQ_SRC;
	u32 __pad_REQ_SRC;
	u32 REQ_DST;
	u32 __pad_REQ_DST;
	u32 SGL_REQ_SRC;
	u32 __pad_SGL_REQ_SRC;
	u32 SGL_REQ_DST;
	u32 __pad_SGL_REQ_DST;
	u32 LAST_SRC;
	u32 __pad_LAST_SRC;
	u32 LAST_DST;
	u32 __pad_LAST_DST;
	u32 CFG;
	u32 __pad_CFG;
	u32 CH_EN;
	u32 __pad_CH_EN;
	u32 ID;
	u32 __pad_ID;
	u32 TEST;
	u32 __pad_TEST;
	u32 CLASS_PRIORITY0;
	u32 __pad_CLASS_PRIORITY0;
	u32 CLASS_PRIORITY1;
	u32 __pad_CLASS_PRIORITY1;
	u32 __reserved;
	u32 DWC_PARAMS[8];
	u32 MULTI_BLK_TYPE;
	u32 MAX_BLK_SIZE;
	u32 DW_PARAMS;
	u32 COMP_TYPE;
	u32 COMP_VERSION;
	u32 FIFO_PARTITION0;
	u32 __pad_FIFO_PARTITION0;
	u32 FIFO_PARTITION1;
	u32 __pad_FIFO_PARTITION1;
	u32 SAI_ERR;
	u32 __pad_SAI_ERR;
	u32 GLOBAL_CFG;
	u32 __pad_GLOBAL_CFG;
};

struct dx_countlimit {
	__le16 limit;
	__le16 count;
};

struct dx_entry {
	__le32 hash;
	__le32 block;
};

struct dx_frame {
	struct buffer_head *bh;
	struct dx_entry *entries;
	struct dx_entry *at;
};

struct dx_hash_info {
	u32 hash;
	u32 minor_hash;
	int hash_version;
	u32 *seed;
};

struct dx_map_entry {
	u32 hash;
	u16 offs;
	u16 size;
};

struct fake_dirent {
	__le32 inode;
	__le16 rec_len;
	u8 name_len;
	u8 file_type;
};

struct dx_node {
	struct fake_dirent fake;
	struct dx_entry entries[0];
};

struct dx_root_info {
	__le32 reserved_zero;
	u8 hash_version;
	u8 info_length;
	u8 indirect_levels;
	u8 unused_flags;
};

struct dx_root {
	struct fake_dirent dot;
	char dot_name[4];
	struct fake_dirent dotdot;
	char dotdot_name[4];
	struct dx_root_info info;
	struct dx_entry entries[0];
};

struct dx_tail {
	u32 dt_reserved;
	__le32 dt_checksum;
};

struct dyn_event_operations;

struct dyn_event {
	struct list_head list;
	struct dyn_event_operations *ops;
};

struct dyn_event_operations {
	struct list_head list;
	int (*create)(const char *);
	int (*show)(struct seq_file *, struct dyn_event *);
	bool (*is_busy)(struct dyn_event *);
	int (*free)(struct dyn_event *);
	bool (*match)(const char *, const char *, int, const char **, struct dyn_event *);
};

struct dynevent_arg {
	const char *str;
	char separator;
};

struct dynevent_arg_pair {
	const char *lhs;
	const char *rhs;
	char operator;
	char separator;
};

struct seq_buf {
	char *buffer;
	size_t size;
	size_t len;
};

struct dynevent_cmd;

typedef int (*dynevent_create_fn_t)(struct dynevent_cmd *);

struct dynevent_cmd {
	struct seq_buf seq;
	const char *event_name;
	unsigned int n_fields;
	enum dynevent_type type;
	dynevent_create_fn_t run_command;
	void *private_data;
};

struct gro_list {
	struct list_head list;
	int count;
};

struct napi_config;

struct napi_struct {
	struct list_head poll_list;
	long unsigned int state;
	int weight;
	u32 defer_hard_irqs_count;
	long unsigned int gro_bitmask;
	int (*poll)(struct napi_struct *, int);
	int poll_owner;
	int list_owner;
	struct net_device *dev;
	struct gro_list gro_hash[8];
	struct sk_buff *skb;
	struct list_head rx_list;
	int rx_count;
	unsigned int napi_id;
	struct hrtimer timer;
	struct task_struct *thread;
	long unsigned int gro_flush_timeout;
	long unsigned int irq_suspend_timeout;
	u32 defer_hard_irqs;
	struct list_head dev_list;
	struct hlist_node napi_hash_node;
	int irq;
	int index;
	struct napi_config *config;
};

struct e1000_eeprom_info {
	e1000_eeprom_type type;
	u16 word_size;
	u16 opcode_bits;
	u16 address_bits;
	u16 delay_usec;
	u16 page_size;
};

struct e1000_host_mng_dhcp_cookie {
	u32 signature;
	u8 status;
	u8 reserved0;
	u16 vlan_id;
	u32 reserved1;
	u16 reserved2;
	u8 reserved3;
	u8 checksum;
};

struct e1000_shadow_ram;

struct e1000_hw {
	u8 *hw_addr;
	u8 *flash_address;
	void *ce4100_gbe_mdio_base_virt;
	e1000_mac_type mac_type;
	e1000_phy_type phy_type;
	u32 phy_init_script;
	e1000_media_type media_type;
	void *back;
	struct e1000_shadow_ram *eeprom_shadow_ram;
	u32 flash_bank_size;
	u32 flash_base_addr;
	e1000_fc_type fc;
	e1000_bus_speed bus_speed;
	e1000_bus_width bus_width;
	e1000_bus_type bus_type;
	struct e1000_eeprom_info eeprom;
	e1000_ms_type master_slave;
	e1000_ms_type original_master_slave;
	e1000_ffe_config ffe_config_state;
	u32 asf_firmware_present;
	u32 eeprom_semaphore_present;
	long unsigned int io_base;
	u32 phy_id;
	u32 phy_revision;
	u32 phy_addr;
	u32 original_fc;
	u32 txcw;
	u32 autoneg_failed;
	u32 max_frame_size;
	u32 min_frame_size;
	u32 mc_filter_type;
	u32 num_mc_addrs;
	u32 collision_delta;
	u32 tx_packet_delta;
	u32 ledctl_default;
	u32 ledctl_mode1;
	u32 ledctl_mode2;
	bool tx_pkt_filtering;
	struct e1000_host_mng_dhcp_cookie mng_cookie;
	u16 phy_spd_default;
	u16 autoneg_advertised;
	u16 pci_cmd_word;
	u16 fc_high_water;
	u16 fc_low_water;
	u16 fc_pause_time;
	u16 current_ifs_val;
	u16 ifs_min_val;
	u16 ifs_max_val;
	u16 ifs_step_size;
	u16 ifs_ratio;
	u16 device_id;
	u16 vendor_id;
	u16 subsystem_id;
	u16 subsystem_vendor_id;
	u8 revision_id;
	u8 autoneg;
	u8 mdix;
	u8 forced_speed_duplex;
	u8 wait_autoneg_complete;
	u8 dma_fairness;
	u8 mac_addr[6];
	u8 perm_mac_addr[6];
	bool disable_polarity_correction;
	bool speed_downgraded;
	e1000_smart_speed smart_speed;
	e1000_dsp_config dsp_config_state;
	bool get_link_status;
	bool serdes_has_link;
	bool tbi_compatibility_en;
	bool tbi_compatibility_on;
	bool laa_is_present;
	bool phy_reset_disable;
	bool initialize_hw_bits_disable;
	bool fc_send_xon;
	bool fc_strict_ieee;
	bool report_tx_early;
	bool adaptive_ifs;
	bool ifs_params_forced;
	bool in_ifs_mode;
	bool mng_reg_access_disabled;
	bool leave_av_bit_off;
	bool bad_tx_carr_stats_fd;
	bool has_smbus;
};

struct e1000_hw_stats {
	u64 crcerrs;
	u64 algnerrc;
	u64 symerrs;
	u64 rxerrc;
	u64 txerrc;
	u64 mpc;
	u64 scc;
	u64 ecol;
	u64 mcc;
	u64 latecol;
	u64 colc;
	u64 dc;
	u64 tncrs;
	u64 sec;
	u64 cexterr;
	u64 rlec;
	u64 xonrxc;
	u64 xontxc;
	u64 xoffrxc;
	u64 xofftxc;
	u64 fcruc;
	u64 prc64;
	u64 prc127;
	u64 prc255;
	u64 prc511;
	u64 prc1023;
	u64 prc1522;
	u64 gprc;
	u64 bprc;
	u64 mprc;
	u64 gptc;
	u64 gorcl;
	u64 gorch;
	u64 gotcl;
	u64 gotch;
	u64 rnbc;
	u64 ruc;
	u64 rfc;
	u64 roc;
	u64 rlerrc;
	u64 rjc;
	u64 mgprc;
	u64 mgpdc;
	u64 mgptc;
	u64 torl;
	u64 torh;
	u64 totl;
	u64 toth;
	u64 tpr;
	u64 tpt;
	u64 ptc64;
	u64 ptc127;
	u64 ptc255;
	u64 ptc511;
	u64 ptc1023;
	u64 ptc1522;
	u64 mptc;
	u64 bptc;
	u64 tsctc;
	u64 tsctfc;
	u64 iac;
	u64 icrxptc;
	u64 icrxatc;
	u64 ictxptc;
	u64 ictxatc;
	u64 ictxqec;
	u64 ictxqmtc;
	u64 icrxdmtc;
	u64 icrxoc;
};

struct e1000_phy_info {
	e1000_cable_length cable_length;
	e1000_10bt_ext_dist_enable extended_10bt_distance;
	e1000_rev_polarity cable_polarity;
	e1000_downshift downshift;
	e1000_polarity_reversal polarity_correction;
	e1000_auto_x_mode mdix_mode;
	e1000_1000t_rx_status local_rx;
	e1000_1000t_rx_status remote_rx;
};

struct e1000_phy_stats {
	u32 idle_errors;
	u32 receive_errors;
};

struct e1000_tx_buffer;

struct e1000_tx_ring {
	void *desc;
	dma_addr_t dma;
	unsigned int size;
	unsigned int count;
	unsigned int next_to_use;
	unsigned int next_to_clean;
	struct e1000_tx_buffer *buffer_info;
	u16 tdh;
	u16 tdt;
	bool last_tx_tso;
};

struct e1000_rx_buffer;

struct e1000_rx_ring {
	void *desc;
	dma_addr_t dma;
	unsigned int size;
	unsigned int count;
	unsigned int next_to_use;
	unsigned int next_to_clean;
	struct e1000_rx_buffer *buffer_info;
	struct sk_buff *rx_skb_top;
	int cpu;
	u16 rdh;
	u16 rdt;
};

struct e1000_adapter {
	long unsigned int active_vlans[64];
	u16 mng_vlan_id;
	u32 bd_number;
	u32 rx_buffer_len;
	u32 wol;
	u32 smartspeed;
	u32 en_mng_pt;
	u16 link_speed;
	u16 link_duplex;
	spinlock_t stats_lock;
	unsigned int total_tx_bytes;
	unsigned int total_tx_packets;
	unsigned int total_rx_bytes;
	unsigned int total_rx_packets;
	u32 itr;
	u32 itr_setting;
	u16 tx_itr;
	u16 rx_itr;
	u8 fc_autoneg;
	struct e1000_tx_ring *tx_ring;
	unsigned int restart_queue;
	u32 txd_cmd;
	u32 tx_int_delay;
	u32 tx_abs_int_delay;
	u32 gotcl;
	u64 gotcl_old;
	u64 tpt_old;
	u64 colc_old;
	u32 tx_timeout_count;
	u32 tx_fifo_head;
	u32 tx_head_addr;
	u32 tx_fifo_size;
	u8 tx_timeout_factor;
	atomic_t tx_fifo_stall;
	bool pcix_82544;
	bool detect_tx_hung;
	bool dump_buffers;
	bool (*clean_rx)(struct e1000_adapter *, struct e1000_rx_ring *, int *, int);
	void (*alloc_rx_buf)(struct e1000_adapter *, struct e1000_rx_ring *, int);
	struct e1000_rx_ring *rx_ring;
	struct napi_struct napi;
	int num_tx_queues;
	int num_rx_queues;
	u64 hw_csum_err;
	u64 hw_csum_good;
	u32 alloc_rx_buff_failed;
	u32 rx_int_delay;
	u32 rx_abs_int_delay;
	bool rx_csum;
	u32 gorcl;
	u64 gorcl_old;
	struct net_device *netdev;
	struct pci_dev *pdev;
	struct e1000_hw hw;
	struct e1000_hw_stats stats;
	struct e1000_phy_info phy_info;
	struct e1000_phy_stats phy_stats;
	u32 test_icr;
	struct e1000_tx_ring test_tx_ring;
	struct e1000_rx_ring test_rx_ring;
	int msg_enable;
	bool tso_force;
	bool smart_power_down;
	bool quad_port_a;
	long unsigned int flags;
	u32 eeprom_wol;
	int bars;
	int need_ioport;
	bool discarding;
	struct work_struct reset_task;
	struct delayed_work watchdog_task;
	struct delayed_work fifo_stall_task;
	struct delayed_work phy_info_task;
};

struct e1000_hw___2;

struct e1000_mac_operations {
	s32 (*id_led_init)(struct e1000_hw___2 *);
	s32 (*blink_led)(struct e1000_hw___2 *);
	bool (*check_mng_mode)(struct e1000_hw___2 *);
	s32 (*check_for_link)(struct e1000_hw___2 *);
	s32 (*cleanup_led)(struct e1000_hw___2 *);
	void (*clear_hw_cntrs)(struct e1000_hw___2 *);
	void (*clear_vfta)(struct e1000_hw___2 *);
	s32 (*get_bus_info)(struct e1000_hw___2 *);
	void (*set_lan_id)(struct e1000_hw___2 *);
	s32 (*get_link_up_info)(struct e1000_hw___2 *, u16 *, u16 *);
	s32 (*led_on)(struct e1000_hw___2 *);
	s32 (*led_off)(struct e1000_hw___2 *);
	void (*update_mc_addr_list)(struct e1000_hw___2 *, u8 *, u32);
	s32 (*reset_hw)(struct e1000_hw___2 *);
	s32 (*init_hw)(struct e1000_hw___2 *);
	s32 (*setup_link)(struct e1000_hw___2 *);
	s32 (*setup_physical_interface)(struct e1000_hw___2 *);
	s32 (*setup_led)(struct e1000_hw___2 *);
	void (*write_vfta)(struct e1000_hw___2 *, u32, u32);
	void (*config_collision_dist)(struct e1000_hw___2 *);
	int (*rar_set)(struct e1000_hw___2 *, u8 *, u32);
	s32 (*read_mac_addr)(struct e1000_hw___2 *);
	u32 (*rar_get_count)(struct e1000_hw___2 *);
};

struct e1000_mac_info {
	struct e1000_mac_operations ops;
	u8 addr[6];
	u8 perm_addr[6];
	enum e1000_mac_type type;
	u32 collision_delta;
	u32 ledctl_default;
	u32 ledctl_mode1;
	u32 ledctl_mode2;
	u32 mc_filter_type;
	u32 tx_packet_delta;
	u32 txcw;
	u16 current_ifs_val;
	u16 ifs_max_val;
	u16 ifs_min_val;
	u16 ifs_ratio;
	u16 ifs_step_size;
	u16 mta_reg_count;
	u32 mta_shadow[128];
	u16 rar_entry_count;
	u8 forced_speed_duplex;
	bool adaptive_ifs;
	bool has_fwsm;
	bool arc_subsystem_valid;
	bool autoneg;
	bool autoneg_failed;
	bool get_link_status;
	bool in_ifs_mode;
	bool serdes_has_link;
	bool tx_pkt_filtering;
	enum e1000_serdes_link_state serdes_link_state;
};

struct e1000_fc_info {
	u32 high_water;
	u32 low_water;
	u16 pause_time;
	u16 refresh_time;
	bool send_xon;
	bool strict_ieee;
	enum e1000_fc_mode current_mode;
	enum e1000_fc_mode requested_mode;
};

struct e1000_phy_operations {
	s32 (*acquire)(struct e1000_hw___2 *);
	s32 (*cfg_on_link_up)(struct e1000_hw___2 *);
	s32 (*check_polarity)(struct e1000_hw___2 *);
	s32 (*check_reset_block)(struct e1000_hw___2 *);
	s32 (*commit)(struct e1000_hw___2 *);
	s32 (*force_speed_duplex)(struct e1000_hw___2 *);
	s32 (*get_cfg_done)(struct e1000_hw___2 *);
	s32 (*get_cable_length)(struct e1000_hw___2 *);
	s32 (*get_info)(struct e1000_hw___2 *);
	s32 (*set_page)(struct e1000_hw___2 *, u16);
	s32 (*read_reg)(struct e1000_hw___2 *, u32, u16 *);
	s32 (*read_reg_locked)(struct e1000_hw___2 *, u32, u16 *);
	s32 (*read_reg_page)(struct e1000_hw___2 *, u32, u16 *);
	void (*release)(struct e1000_hw___2 *);
	s32 (*reset)(struct e1000_hw___2 *);
	s32 (*set_d0_lplu_state)(struct e1000_hw___2 *, bool);
	s32 (*set_d3_lplu_state)(struct e1000_hw___2 *, bool);
	s32 (*write_reg)(struct e1000_hw___2 *, u32, u16);
	s32 (*write_reg_locked)(struct e1000_hw___2 *, u32, u16);
	s32 (*write_reg_page)(struct e1000_hw___2 *, u32, u16);
	void (*power_up)(struct e1000_hw___2 *);
	void (*power_down)(struct e1000_hw___2 *);
};

struct e1000_phy_info___2 {
	struct e1000_phy_operations ops;
	enum e1000_phy_type type;
	enum e1000_1000t_rx_status local_rx;
	enum e1000_1000t_rx_status remote_rx;
	enum e1000_ms_type ms_type;
	enum e1000_ms_type original_ms_type;
	enum e1000_rev_polarity cable_polarity;
	enum e1000_smart_speed smart_speed;
	u32 addr;
	u32 id;
	u32 reset_delay_us;
	u32 revision;
	u32 retry_count;
	enum e1000_media_type media_type;
	u16 autoneg_advertised;
	u16 autoneg_mask;
	u16 cable_length;
	u16 max_cable_length;
	u16 min_cable_length;
	u8 mdix;
	bool disable_polarity_correction;
	bool is_mdix;
	bool polarity_correction;
	bool speed_downgraded;
	bool autoneg_wait_to_complete;
	bool retry_enabled;
};

struct e1000_nvm_operations {
	s32 (*acquire)(struct e1000_hw___2 *);
	s32 (*read)(struct e1000_hw___2 *, u16, u16, u16 *);
	void (*release)(struct e1000_hw___2 *);
	void (*reload)(struct e1000_hw___2 *);
	s32 (*update)(struct e1000_hw___2 *);
	s32 (*valid_led_default)(struct e1000_hw___2 *, u16 *);
	s32 (*validate)(struct e1000_hw___2 *);
	s32 (*write)(struct e1000_hw___2 *, u16, u16, u16 *);
};

struct e1000_nvm_info {
	struct e1000_nvm_operations ops;
	enum e1000_nvm_type type;
	enum e1000_nvm_override override;
	u32 flash_bank_size;
	u32 flash_base_addr;
	u16 word_size;
	u16 delay_usec;
	u16 address_bits;
	u16 opcode_bits;
	u16 page_size;
};

struct e1000_bus_info {
	enum e1000_bus_width width;
	u16 func;
};

struct e1000_dev_spec_82571 {
	bool laa_is_present;
	u32 smb_counter;
};

struct e1000_dev_spec_80003es2lan {
	bool mdic_wa_enable;
};

struct e1000_shadow_ram___2 {
	u16 value;
	bool modified;
};

struct e1000_dev_spec_ich8lan {
	bool kmrn_lock_loss_workaround_enabled;
	struct e1000_shadow_ram___2 shadow_ram[2048];
	bool nvm_k1_enabled;
	bool eee_disable;
	u16 eee_lp_ability;
	enum e1000_ulp_state ulp_state;
};

struct e1000_adapter___2;

struct e1000_hw___2 {
	struct e1000_adapter___2 *adapter;
	void *hw_addr;
	void *flash_address;
	struct e1000_mac_info mac;
	struct e1000_fc_info fc;
	struct e1000_phy_info___2 phy;
	struct e1000_nvm_info nvm;
	struct e1000_bus_info bus;
	struct e1000_host_mng_dhcp_cookie mng_cookie;
	union {
		struct e1000_dev_spec_82571 e82571;
		struct e1000_dev_spec_80003es2lan e80003es2lan;
		struct e1000_dev_spec_ich8lan ich8lan;
	} dev_spec;
};

struct e1000_hw_stats___2 {
	u64 crcerrs;
	u64 algnerrc;
	u64 symerrs;
	u64 rxerrc;
	u64 mpc;
	u64 scc;
	u64 ecol;
	u64 mcc;
	u64 latecol;
	u64 colc;
	u64 dc;
	u64 tncrs;
	u64 sec;
	u64 cexterr;
	u64 rlec;
	u64 xonrxc;
	u64 xontxc;
	u64 xoffrxc;
	u64 xofftxc;
	u64 fcruc;
	u64 prc64;
	u64 prc127;
	u64 prc255;
	u64 prc511;
	u64 prc1023;
	u64 prc1522;
	u64 gprc;
	u64 bprc;
	u64 mprc;
	u64 gptc;
	u64 gorc;
	u64 gotc;
	u64 rnbc;
	u64 ruc;
	u64 rfc;
	u64 roc;
	u64 rjc;
	u64 mgprc;
	u64 mgpdc;
	u64 mgptc;
	u64 tor;
	u64 tot;
	u64 tpr;
	u64 tpt;
	u64 ptc64;
	u64 ptc127;
	u64 ptc255;
	u64 ptc511;
	u64 ptc1023;
	u64 ptc1522;
	u64 mptc;
	u64 bptc;
	u64 tsctc;
	u64 tsctfc;
	u64 iac;
	u64 icrxptc;
	u64 icrxatc;
	u64 ictxptc;
	u64 ictxatc;
	u64 ictxqec;
	u64 ictxqmtc;
	u64 icrxdmtc;
	u64 icrxoc;
};

struct e1000_phy_regs {
	u16 bmcr;
	u16 bmsr;
	u16 advertise;
	u16 lpa;
	u16 expansion;
	u16 ctrl1000;
	u16 stat1000;
	u16 estatus;
};

struct e1000_buffer;

struct e1000_ring {
	struct e1000_adapter___2 *adapter;
	void *desc;
	dma_addr_t dma;
	unsigned int size;
	unsigned int count;
	u16 next_to_use;
	u16 next_to_clean;
	void *head;
	void *tail;
	struct e1000_buffer *buffer_info;
	char name[21];
	u32 ims_val;
	u32 itr_val;
	void *itr_register;
	int set_itr;
	struct sk_buff *rx_skb_top;
};

struct hwtstamp_config {
	int flags;
	int tx_type;
	int rx_filter;
};

struct ptp_pin_desc;

struct ptp_system_timestamp;

struct system_device_crosststamp;

struct ptp_clock_request;

struct ptp_clock_info {
	struct module *owner;
	char name[32];
	s32 max_adj;
	int n_alarm;
	int n_ext_ts;
	int n_per_out;
	int n_pins;
	int pps;
	struct ptp_pin_desc *pin_config;
	int (*adjfine)(struct ptp_clock_info *, long int);
	int (*adjphase)(struct ptp_clock_info *, s32);
	s32 (*getmaxphase)(struct ptp_clock_info *);
	int (*adjtime)(struct ptp_clock_info *, s64);
	int (*gettime64)(struct ptp_clock_info *, struct timespec64 *);
	int (*gettimex64)(struct ptp_clock_info *, struct timespec64 *, struct ptp_system_timestamp *);
	int (*getcrosststamp)(struct ptp_clock_info *, struct system_device_crosststamp *);
	int (*settime64)(struct ptp_clock_info *, const struct timespec64 *);
	int (*getcycles64)(struct ptp_clock_info *, struct timespec64 *);
	int (*getcyclesx64)(struct ptp_clock_info *, struct timespec64 *, struct ptp_system_timestamp *);
	int (*getcrosscycles)(struct ptp_clock_info *, struct system_device_crosststamp *);
	int (*enable)(struct ptp_clock_info *, struct ptp_clock_request *, int);
	int (*verify)(struct ptp_clock_info *, unsigned int, enum ptp_pin_function, unsigned int);
	long int (*do_aux_work)(struct ptp_clock_info *);
};

struct e1000_info;

struct msix_entry;

struct ptp_clock;

struct e1000_adapter___2 {
	struct timer_list watchdog_timer;
	struct timer_list phy_info_timer;
	struct timer_list blink_timer;
	struct work_struct reset_task;
	struct work_struct watchdog_task;
	const struct e1000_info *ei;
	long unsigned int active_vlans[64];
	u32 bd_number;
	u32 rx_buffer_len;
	u16 mng_vlan_id;
	u16 link_speed;
	u16 link_duplex;
	u16 eeprom_vers;
	long unsigned int state;
	u32 itr;
	u32 itr_setting;
	u16 tx_itr;
	u16 rx_itr;
	long: 64;
	long: 64;
	long: 64;
	struct e1000_ring *tx_ring;
	u32 tx_fifo_limit;
	struct napi_struct napi;
	unsigned int uncorr_errors;
	unsigned int corr_errors;
	unsigned int restart_queue;
	u32 txd_cmd;
	bool detect_tx_hung;
	bool tx_hang_recheck;
	u8 tx_timeout_factor;
	u32 tx_int_delay;
	u32 tx_abs_int_delay;
	unsigned int total_tx_bytes;
	unsigned int total_tx_packets;
	unsigned int total_rx_bytes;
	unsigned int total_rx_packets;
	u64 tpt_old;
	u64 colc_old;
	u32 gotc;
	u64 gotc_old;
	u32 tx_timeout_count;
	u32 tx_fifo_head;
	u32 tx_head_addr;
	u32 tx_fifo_size;
	u32 tx_dma_failed;
	u32 tx_hwtstamp_timeouts;
	u32 tx_hwtstamp_skipped;
	long: 64;
	long: 64;
	bool (*clean_rx)(struct e1000_ring *, int *, int);
	void (*alloc_rx_buf)(struct e1000_ring *, int, gfp_t);
	struct e1000_ring *rx_ring;
	u32 rx_int_delay;
	u32 rx_abs_int_delay;
	u64 hw_csum_err;
	u64 hw_csum_good;
	u64 rx_hdr_split;
	u32 gorc;
	u64 gorc_old;
	u32 alloc_rx_buff_failed;
	u32 rx_dma_failed;
	u32 rx_hwtstamp_cleared;
	unsigned int rx_ps_pages;
	u16 rx_ps_bsize0;
	u32 max_frame_size;
	u32 min_frame_size;
	struct net_device *netdev;
	struct pci_dev *pdev;
	struct e1000_hw___2 hw;
	spinlock_t stats64_lock;
	struct e1000_hw_stats___2 stats;
	struct e1000_phy_info___2 phy_info;
	struct e1000_phy_stats phy_stats;
	struct e1000_phy_regs phy_regs;
	struct e1000_ring test_tx_ring;
	struct e1000_ring test_rx_ring;
	u32 test_icr;
	u32 msg_enable;
	unsigned int num_vectors;
	struct msix_entry *msix_entries;
	int int_mode;
	u32 eiac_mask;
	u32 eeprom_wol;
	u32 wol;
	u32 pba;
	u32 max_hw_frame_size;
	bool fc_autoneg;
	unsigned int flags;
	unsigned int flags2;
	struct work_struct downshift_task;
	struct work_struct update_phy_task;
	struct work_struct print_hang_task;
	int phy_hang_count;
	u16 tx_ring_count;
	u16 rx_ring_count;
	struct hwtstamp_config hwtstamp_config;
	struct delayed_work systim_overflow_work;
	struct sk_buff *tx_hwtstamp_skb;
	long unsigned int tx_hwtstamp_start;
	struct work_struct tx_hwtstamp_work;
	spinlock_t systim_lock;
	struct cyclecounter cc;
	struct timecounter tc;
	struct ptp_clock *ptp_clock;
	struct ptp_clock_info ptp_clock_info;
	struct pm_qos_request pm_qos_req;
	long int ptp_delta;
	u16 eee_advert;
	long: 64;
	long: 64;
};

struct e1000_ps_page;

struct e1000_buffer {
	dma_addr_t dma;
	struct sk_buff *skb;
	union {
		struct {
			long unsigned int time_stamp;
			u16 length;
			u16 next_to_watch;
			unsigned int segs;
			unsigned int bytecount;
			u16 mapped_as_page;
		};
		struct {
			struct e1000_ps_page *ps_pages;
			struct page *page;
		};
	};
};

struct e1000_context_desc {
	union {
		__le32 ip_config;
		struct {
			u8 ipcss;
			u8 ipcso;
			__le16 ipcse;
		} ip_fields;
	} lower_setup;
	union {
		__le32 tcp_config;
		struct {
			u8 tucss;
			u8 tucso;
			__le16 tucse;
		} tcp_fields;
	} upper_setup;
	__le32 cmd_and_length;
	union {
		__le32 data;
		struct {
			u8 status;
			u8 hdr_len;
			__le16 mss;
		} fields;
	} tcp_seg_setup;
};

struct e1000_host_mng_command_header {
	u8 command_id;
	u8 checksum;
	u16 reserved1;
	u16 reserved2;
	u16 command_length;
};

struct e1000_info {
	enum e1000_mac_type mac;
	unsigned int flags;
	unsigned int flags2;
	u32 pba;
	u32 max_hw_frame_size;
	s32 (*get_variants)(struct e1000_adapter___2 *);
	const struct e1000_mac_operations *mac_ops;
	const struct e1000_phy_operations *phy_ops;
	const struct e1000_nvm_operations *nvm_ops;
};

struct e1000_opt_list {
	int i;
	char *str;
};

struct e1000_option {
	enum {
		enable_option = 0,
		range_option = 1,
		list_option = 2,
	} type;
	const char *name;
	const char *err;
	int def;
	union {
		struct {
			int min;
			int max;
		} r;
		struct {
			int nr;
			const struct e1000_opt_list *p;
		} l;
	} arg;
};

struct e1000_option___2 {
	enum {
		enable_option___2 = 0,
		range_option___2 = 1,
		list_option___2 = 2,
	} type;
	const char *name;
	const char *err;
	int def;
	union {
		struct {
			int min;
			int max;
		} r;
		struct {
			int nr;
			struct e1000_opt_list *p;
		} l;
	} arg;
};

struct e1000_ps_page {
	struct page *page;
	u64 dma;
};

struct e1000_reg_info {
	u32 ofs;
	char *name;
};

struct e1000_rx_buffer {
	union {
		struct page *page;
		u8 *data;
	} rxbuf;
	dma_addr_t dma;
};

struct e1000_rx_desc {
	__le64 buffer_addr;
	__le16 length;
	__le16 csum;
	u8 status;
	u8 errors;
	__le16 special;
};

union e1000_rx_desc_extended {
	struct {
		__le64 buffer_addr;
		__le64 reserved;
	} read;
	struct {
		struct {
			__le32 mrq;
			union {
				__le32 rss;
				struct {
					__le16 ip_id;
					__le16 csum;
				} csum_ip;
			} hi_dword;
		} lower;
		struct {
			__le32 status_error;
			__le16 length;
			__le16 vlan;
		} upper;
	} wb;
};

union e1000_rx_desc_packet_split {
	struct {
		__le64 buffer_addr[4];
	} read;
	struct {
		struct {
			__le32 mrq;
			union {
				__le32 rss;
				struct {
					__le16 ip_id;
					__le16 csum;
				} csum_ip;
			} hi_dword;
		} lower;
		struct {
			__le32 status_error;
			__le16 length0;
			__le16 vlan;
		} middle;
		struct {
			__le16 header_status;
			__le16 length[3];
		} upper;
		__le64 reserved;
	} wb;
};

struct e1000_shadow_ram {
	u16 eeprom_word;
	bool modified;
};

struct e1000_stats {
	char stat_string[32];
	int type;
	int sizeof_stat;
	int stat_offset;
};

struct e1000_tx_buffer {
	struct sk_buff *skb;
	dma_addr_t dma;
	long unsigned int time_stamp;
	u16 length;
	u16 next_to_watch;
	bool mapped_as_page;
	short unsigned int segs;
	unsigned int bytecount;
};

struct e1000_tx_desc {
	__le64 buffer_addr;
	union {
		__le32 data;
		struct {
			__le16 length;
			u8 cso;
			u8 cmd;
		} flags;
	} lower;
	union {
		__le32 data;
		struct {
			u8 status;
			u8 css;
			__le16 special;
		} fields;
	} upper;
};

struct e820_entry {
	u64 addr;
	u64 size;
	enum e820_type type;
} __attribute__((packed));

struct e820_table {
	__u32 nr_entries;
	struct e820_entry entries[320];
};

struct usb_device;

struct each_dev_arg {
	void *data;
	int (*fn)(struct usb_device *, void *);
};

struct early_load_data {
	u32 old_rev;
	u32 new_rev;
};

struct uart_icount {
	__u32 cts;
	__u32 dsr;
	__u32 rng;
	__u32 dcd;
	__u32 rx;
	__u32 tx;
	__u32 frame;
	__u32 overrun;
	__u32 parity;
	__u32 brk;
	__u32 buf_overrun;
};

struct serial_rs485 {
	__u32 flags;
	__u32 delay_rts_before_send;
	__u32 delay_rts_after_send;
	union {
		__u32 padding[5];
		struct {
			__u8 addr_recv;
			__u8 addr_dest;
			__u8 padding0[2];
			__u32 padding1[4];
		};
	};
};

struct gpio_desc;

struct serial_iso7816 {
	__u32 flags;
	__u32 tg;
	__u32 sc_fi;
	__u32 sc_di;
	__u32 clk;
	__u32 reserved[5];
};

struct ktermios;

struct uart_state;

struct uart_ops;

struct serial_port_device;

struct uart_port {
	spinlock_t lock;
	long unsigned int iobase;
	unsigned char *membase;
	unsigned int (*serial_in)(struct uart_port *, int);
	void (*serial_out)(struct uart_port *, int, int);
	void (*set_termios)(struct uart_port *, struct ktermios *, const struct ktermios *);
	void (*set_ldisc)(struct uart_port *, struct ktermios *);
	unsigned int (*get_mctrl)(struct uart_port *);
	void (*set_mctrl)(struct uart_port *, unsigned int);
	unsigned int (*get_divisor)(struct uart_port *, unsigned int, unsigned int *);
	void (*set_divisor)(struct uart_port *, unsigned int, unsigned int, unsigned int);
	int (*startup)(struct uart_port *);
	void (*shutdown)(struct uart_port *);
	void (*throttle)(struct uart_port *);
	void (*unthrottle)(struct uart_port *);
	int (*handle_irq)(struct uart_port *);
	void (*pm)(struct uart_port *, unsigned int, unsigned int);
	void (*handle_break)(struct uart_port *);
	int (*rs485_config)(struct uart_port *, struct ktermios *, struct serial_rs485 *);
	int (*iso7816_config)(struct uart_port *, struct serial_iso7816 *);
	unsigned int ctrl_id;
	unsigned int port_id;
	unsigned int irq;
	long unsigned int irqflags;
	unsigned int uartclk;
	unsigned int fifosize;
	unsigned char x_char;
	unsigned char regshift;
	unsigned char iotype;
	unsigned char quirks;
	unsigned int read_status_mask;
	unsigned int ignore_status_mask;
	struct uart_state *state;
	struct uart_icount icount;
	struct console *cons;
	upf_t flags;
	upstat_t status;
	bool hw_stopped;
	unsigned int mctrl;
	unsigned int frame_time;
	unsigned int type;
	const struct uart_ops *ops;
	unsigned int custom_divisor;
	unsigned int line;
	unsigned int minor;
	resource_size_t mapbase;
	resource_size_t mapsize;
	struct device *dev;
	struct serial_port_device *port_dev;
	long unsigned int sysrq;
	u8 sysrq_ch;
	unsigned char has_sysrq;
	unsigned char sysrq_seq;
	unsigned char hub6;
	unsigned char suspended;
	unsigned char console_reinit;
	const char *name;
	struct attribute_group *attr_group;
	const struct attribute_group **tty_groups;
	struct serial_rs485 rs485;
	struct serial_rs485 rs485_supported;
	struct gpio_desc *rs485_term_gpio;
	struct gpio_desc *rs485_rx_during_tx_gpio;
	struct serial_iso7816 iso7816;
	void *private_data;
};

struct earlycon_device {
	struct console *con;
	struct uart_port port;
	char options[32];
	unsigned int baud;
};

struct earlycon_id {
	char name[15];
	char name_term;
	char compatible[128];
	int (*setup)(struct earlycon_device *, const char *);
};

struct eb_fence {
	struct drm_syncobj *syncobj;
	struct dma_fence *dma_fence;
	u64 value;
	struct dma_fence_chain *chain_fence;
};

struct eb_vma {
	struct i915_vma *vma;
	unsigned int flags;
	struct drm_i915_gem_exec_object2 *exec;
	struct list_head bind_link;
	struct list_head reloc_link;
	struct hlist_node node;
	u32 handle;
};

struct ebitmap_node {
	struct ebitmap_node *next;
	long unsigned int maps[6];
	u32 startbit;
};

struct td;

struct ed {
	__hc32 hwINFO;
	__hc32 hwTailP;
	__hc32 hwHeadP;
	__hc32 hwNextED;
	dma_addr_t dma;
	struct td *dummy;
	struct ed *ed_next;
	struct ed *ed_prev;
	struct list_head td_list;
	struct list_head in_use_list;
	u8 state;
	u8 type;
	u8 branch;
	u16 interval;
	u16 load;
	u16 last_iso;
	u16 tick;
	unsigned int takeback_wdh_cnt;
	struct td *pending_td;
	long: 64;
};

struct est_timings {
	u8 t1;
	u8 t2;
	u8 mfg_rsvd;
};

struct edid {
	u8 header[8];
	union {
		struct drm_edid_product_id product_id;
		struct {
			u8 mfg_id[2];
			u8 prod_code[2];
			u32 serial;
			u8 mfg_week;
			u8 mfg_year;
		} __attribute__((packed));
	};
	u8 version;
	u8 revision;
	u8 input;
	u8 width_cm;
	u8 height_cm;
	u8 gamma;
	u8 features;
	u8 red_green_lo;
	u8 blue_white_lo;
	u8 red_x;
	u8 red_y;
	u8 green_x;
	u8 green_y;
	u8 blue_x;
	u8 blue_y;
	u8 white_x;
	u8 white_y;
	struct est_timings established_timings;
	struct std_timing standard_timings[8];
	struct detailed_timing detailed_timings[4];
	u8 extensions;
	u8 checksum;
};

struct edid_quirk {
	const struct drm_edid_ident ident;
	u32 quirks;
};

struct eee_config {
	u32 tx_lpi_timer;
	bool tx_lpi_enabled;
	bool eee_enabled;
};

struct ethtool_keee {
	long unsigned int supported[2];
	long unsigned int advertised[2];
	long unsigned int lp_advertised[2];
	u32 tx_lpi_timer;
	bool tx_lpi_enabled;
	bool eee_active;
	bool eee_enabled;
};

struct eee_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_keee eee;
};

struct eeepc_cpufv {
	int num;
	int cur;
};

struct hotplug_slot_ops;

struct pci_slot;

struct hotplug_slot {
	const struct hotplug_slot_ops *ops;
	struct list_head slot_list;
	struct pci_slot *pci_slot;
	struct module *owner;
	const char *mod_name;
};

struct eeepc_laptop {
	acpi_handle handle;
	u32 cm_supported;
	bool cpufv_disabled;
	bool hotplug_disabled;
	u16 event_count[128];
	struct platform_device *platform_device;
	struct acpi_device *device;
	struct backlight_device *backlight_device;
	struct input_dev *inputdev;
	struct rfkill *wlan_rfkill;
	struct rfkill *bluetooth_rfkill;
	struct rfkill *wwan3g_rfkill;
	struct rfkill *wimax_rfkill;
	struct hotplug_slot hotplug_slot;
	struct mutex hotplug_lock;
	struct led_classdev tpd_led;
	int tpd_led_wk;
	struct workqueue_struct *led_workqueue;
	struct work_struct tpd_led_work;
};

struct eeprom_93cx6 {
	void *data;
	void (*register_read)(struct eeprom_93cx6 *);
	void (*register_write)(struct eeprom_93cx6 *);
	int width;
	unsigned int quirks;
	char drive_data;
	char reg_data_in;
	char reg_data_out;
	char reg_data_clock;
	char reg_chip_select;
};

struct eeprom_reply_data {
	struct ethnl_reply_data base;
	u32 length;
	u8 *data;
};

struct ethnl_req_info {
	struct net_device *dev;
	netdevice_tracker dev_tracker;
	u32 flags;
	u32 phy_index;
};

struct eeprom_req_info {
	struct ethnl_req_info base;
	u32 offset;
	u32 length;
	u8 page;
	u8 bank;
	u8 i2c_address;
};

typedef efi_status_t efi_get_time_t(efi_time_t *, efi_time_cap_t *);

typedef efi_status_t efi_set_time_t(efi_time_t *);

typedef efi_status_t efi_get_wakeup_time_t(efi_bool_t *, efi_bool_t *, efi_time_t *);

typedef efi_status_t efi_set_wakeup_time_t(efi_bool_t, efi_time_t *);

typedef efi_status_t efi_get_variable_t(efi_char16_t *, efi_guid_t *, u32 *, long unsigned int *, void *);

typedef efi_status_t efi_get_next_variable_t(long unsigned int *, efi_char16_t *, efi_guid_t *);

typedef efi_status_t efi_set_variable_t(efi_char16_t *, efi_guid_t *, u32, long unsigned int, void *);

typedef efi_status_t efi_query_variable_info_t(u32, u64 *, u64 *, u64 *);

typedef efi_status_t efi_update_capsule_t(efi_capsule_header_t **, long unsigned int, long unsigned int);

typedef efi_status_t efi_query_capsule_caps_t(efi_capsule_header_t **, long unsigned int, u64 *, int *);

typedef efi_status_t efi_get_next_high_mono_count_t(u32 *);

typedef void efi_reset_system_t(int, efi_status_t, long unsigned int, efi_char16_t *);

struct efi_memory_map {
	phys_addr_t phys_map;
	void *map;
	void *map_end;
	int nr_map;
	long unsigned int desc_version;
	long unsigned int desc_size;
	long unsigned int flags;
};

struct efi {
	const efi_runtime_services_t *runtime;
	unsigned int runtime_version;
	unsigned int runtime_supported_mask;
	long unsigned int acpi;
	long unsigned int acpi20;
	long unsigned int smbios;
	long unsigned int smbios3;
	long unsigned int esrt;
	long unsigned int tpm_log;
	long unsigned int tpm_final_log;
	long unsigned int mokvar_table;
	long unsigned int coco_secret;
	long unsigned int unaccepted;
	efi_get_time_t *get_time;
	efi_set_time_t *set_time;
	efi_get_wakeup_time_t *get_wakeup_time;
	efi_set_wakeup_time_t *set_wakeup_time;
	efi_get_variable_t *get_variable;
	efi_get_next_variable_t *get_next_variable;
	efi_set_variable_t *set_variable;
	efi_set_variable_t *set_variable_nonblocking;
	efi_query_variable_info_t *query_variable_info;
	efi_query_variable_info_t *query_variable_info_nonblocking;
	efi_update_capsule_t *update_capsule;
	efi_query_capsule_caps_t *query_capsule_caps;
	efi_get_next_high_mono_count_t *get_next_high_mono_count;
	efi_reset_system_t *reset_system;
	struct efi_memory_map memmap;
	long unsigned int flags;
};

struct efi_mem_range {
	struct range range;
	u64 attribute;
};

struct efi_memory_map_data {
	phys_addr_t phys_map;
	long unsigned int size;
	long unsigned int desc_version;
	long unsigned int desc_size;
	long unsigned int flags;
};

union efi_rts_args {
	struct {
		efi_time_t *time;
		efi_time_cap_t *capabilities;
	} GET_TIME;
	struct {
		efi_time_t *time;
	} SET_TIME;
	struct {
		efi_bool_t *enabled;
		efi_bool_t *pending;
		efi_time_t *time;
	} GET_WAKEUP_TIME;
	struct {
		efi_bool_t enable;
		efi_time_t *time;
	} SET_WAKEUP_TIME;
	struct {
		efi_char16_t *name;
		efi_guid_t *vendor;
		u32 *attr;
		long unsigned int *data_size;
		void *data;
	} GET_VARIABLE;
	struct {
		long unsigned int *name_size;
		efi_char16_t *name;
		efi_guid_t *vendor;
	} GET_NEXT_VARIABLE;
	struct {
		efi_char16_t *name;
		efi_guid_t *vendor;
		u32 attr;
		long unsigned int data_size;
		void *data;
	} SET_VARIABLE;
	struct {
		u32 attr;
		u64 *storage_space;
		u64 *remaining_space;
		u64 *max_variable_size;
	} QUERY_VARIABLE_INFO;
	struct {
		u32 *high_count;
	} GET_NEXT_HIGH_MONO_COUNT;
	struct {
		efi_capsule_header_t **capsules;
		long unsigned int count;
		long unsigned int sg_list;
	} UPDATE_CAPSULE;
	struct {
		efi_capsule_header_t **capsules;
		long unsigned int count;
		u64 *max_size;
		int *reset_type;
	} QUERY_CAPSULE_CAPS;
	struct {
		efi_status_t (*acpi_prm_handler)(u64, void *);
		u64 param_buffer_addr;
		void *context;
	} ACPI_PRM_HANDLER;
};

struct efi_runtime_map_entry {
	efi_memory_desc_t md;
	struct kobject kobj;
};

struct efi_runtime_work {
	union efi_rts_args *args;
	efi_status_t status;
	struct work_struct work;
	enum efi_rts_ids efi_rts_id;
	struct completion efi_rts_comp;
	const void *caller;
};

struct efi_setup_data {
	u64 fw_vendor;
	u64 __unused;
	u64 tables;
	u64 smbios;
	u64 reserved[8];
};

struct efi_system_resource_entry_v1 {
	efi_guid_t fw_class;
	u32 fw_type;
	u32 fw_version;
	u32 lowest_supported_fw_version;
	u32 capsule_flags;
	u32 last_attempt_version;
	u32 last_attempt_status;
};

struct efi_system_resource_table {
	u32 fw_resource_count;
	u32 fw_resource_count_max;
	u64 fw_resource_version;
	u8 entries[0];
};

struct efi_tcg2_final_events_table {
	u64 version;
	u64 nr_events;
	u8 events[0];
};

struct efi_unaccepted_memory {
	u32 version;
	u32 unit_size;
	u64 phys_base;
	u64 size;
	long unsigned int bitmap[0];
};

typedef efi_status_t efi_query_variable_store_t(u32, long unsigned int, bool);

struct efivar_operations {
	efi_get_variable_t *get_variable;
	efi_get_next_variable_t *get_next_variable;
	efi_set_variable_t *set_variable;
	efi_set_variable_t *set_variable_nonblocking;
	efi_query_variable_store_t *query_variable_store;
	efi_query_variable_info_t *query_variable_info;
};

struct efivars {
	struct kset *kset;
	const struct efivar_operations *ops;
};

struct ehci_caps {
	u32 hc_capbase;
	u32 hcs_params;
	u32 hcc_params;
	u8 portroute[8];
};

struct ehci_dbg_port {
	u32 control;
	u32 pids;
	u32 data03;
	u32 data47;
	u32 address;
};

struct ehci_dev {
	u32 bus;
	u32 slot;
	u32 func;
};

struct usb_hcd;

struct ehci_driver_overrides {
	size_t extra_priv_size;
	int (*reset)(struct usb_hcd *);
	int (*port_power)(struct usb_hcd *, int, bool);
};

struct ehci_qh;

struct ehci_itd;

struct ehci_sitd;

struct ehci_fstn;

union ehci_shadow {
	struct ehci_qh *qh;
	struct ehci_itd *itd;
	struct ehci_sitd *sitd;
	struct ehci_fstn *fstn;
	__le32 *hw_next;
	void *ptr;
};

struct ehci_fstn {
	__le32 hw_next;
	__le32 hw_prev;
	dma_addr_t fstn_dma;
	union ehci_shadow fstn_next;
	long: 64;
};

struct ehci_regs;

struct ehci_hcd {
	enum ehci_hrtimer_event next_hrtimer_event;
	unsigned int enabled_hrtimer_events;
	ktime_t hr_timeouts[12];
	struct hrtimer hrtimer;
	int PSS_poll_count;
	int ASS_poll_count;
	int died_poll_count;
	struct ehci_caps *caps;
	struct ehci_regs *regs;
	struct ehci_dbg_port *debug;
	__u32 hcs_params;
	spinlock_t lock;
	enum ehci_rh_state rh_state;
	bool scanning: 1;
	bool need_rescan: 1;
	bool intr_unlinking: 1;
	bool iaa_in_progress: 1;
	bool async_unlinking: 1;
	bool shutdown: 1;
	struct ehci_qh *qh_scan_next;
	struct ehci_qh *async;
	struct ehci_qh *dummy;
	struct list_head async_unlink;
	struct list_head async_idle;
	unsigned int async_unlink_cycle;
	unsigned int async_count;
	__le32 old_current;
	__le32 old_token;
	unsigned int periodic_size;
	__le32 *periodic;
	dma_addr_t periodic_dma;
	struct list_head intr_qh_list;
	unsigned int i_thresh;
	union ehci_shadow *pshadow;
	struct list_head intr_unlink_wait;
	struct list_head intr_unlink;
	unsigned int intr_unlink_wait_cycle;
	unsigned int intr_unlink_cycle;
	unsigned int now_frame;
	unsigned int last_iso_frame;
	unsigned int intr_count;
	unsigned int isoc_count;
	unsigned int periodic_count;
	unsigned int uframe_periodic_max;
	struct list_head cached_itd_list;
	struct ehci_itd *last_itd_to_free;
	struct list_head cached_sitd_list;
	struct ehci_sitd *last_sitd_to_free;
	long unsigned int reset_done[15];
	long unsigned int bus_suspended;
	long unsigned int companion_ports;
	long unsigned int owned_ports;
	long unsigned int port_c_suspend;
	long unsigned int suspended_ports;
	long unsigned int resuming_ports;
	struct dma_pool *qh_pool;
	struct dma_pool *qtd_pool;
	struct dma_pool *itd_pool;
	struct dma_pool *sitd_pool;
	unsigned int random_frame;
	long unsigned int next_statechange;
	ktime_t last_periodic_enable;
	u32 command;
	unsigned int no_selective_suspend: 1;
	unsigned int has_fsl_port_bug: 1;
	unsigned int has_fsl_hs_errata: 1;
	unsigned int has_fsl_susp_errata: 1;
	unsigned int has_ci_pec_bug: 1;
	unsigned int big_endian_mmio: 1;
	unsigned int big_endian_desc: 1;
	unsigned int big_endian_capbase: 1;
	unsigned int has_amcc_usb23: 1;
	unsigned int need_io_watchdog: 1;
	unsigned int amd_pll_fix: 1;
	unsigned int use_dummy_qh: 1;
	unsigned int has_synopsys_hc_bug: 1;
	unsigned int frame_index_bug: 1;
	unsigned int need_oc_pp_cycle: 1;
	unsigned int imx28_write_fix: 1;
	unsigned int spurious_oc: 1;
	unsigned int is_aspeed: 1;
	unsigned int zx_wakeup_clear_needed: 1;
	__le32 *ohci_hcctrl_reg;
	unsigned int has_hostpc: 1;
	unsigned int has_tdi_phy_lpm: 1;
	unsigned int has_ppcd: 1;
	u8 sbrn;
	u8 bandwidth[64];
	u8 tt_budget[64];
	struct list_head tt_list;
	long unsigned int priv[0];
};

struct ehci_iso_packet {
	u64 bufp;
	__le32 transaction;
	u8 cross;
	u32 buf1;
};

struct ehci_iso_sched {
	struct list_head td_list;
	unsigned int span;
	unsigned int first_packet;
	struct ehci_iso_packet packet[0];
};

struct usb_host_endpoint;

struct ehci_per_sched {
	struct usb_device *udev;
	struct usb_host_endpoint *ep;
	struct list_head ps_list;
	u16 tt_usecs;
	u16 cs_mask;
	u16 period;
	u16 phase;
	u8 bw_phase;
	u8 phase_uf;
	u8 usecs;
	u8 c_usecs;
	u8 bw_uperiod;
	u8 bw_period;
};

struct ehci_qh_hw;

struct ehci_iso_stream {
	struct ehci_qh_hw *hw;
	u8 bEndpointAddress;
	u8 highspeed;
	struct list_head td_list;
	struct list_head free_list;
	struct ehci_per_sched ps;
	unsigned int next_uframe;
	__le32 splits;
	u16 uperiod;
	u16 maxp;
	unsigned int bandwidth;
	__le32 buf0;
	__le32 buf1;
	__le32 buf2;
	__le32 address;
};

struct ehci_itd {
	__le32 hw_next;
	__le32 hw_transaction[8];
	__le32 hw_bufp[7];
	__le32 hw_bufp_hi[7];
	dma_addr_t itd_dma;
	union ehci_shadow itd_next;
	struct urb *urb;
	struct ehci_iso_stream *stream;
	struct list_head itd_list;
	unsigned int frame;
	unsigned int pg;
	unsigned int index[8];
	long: 64;
};

struct ehci_qtd;

struct ehci_qh {
	struct ehci_qh_hw *hw;
	dma_addr_t qh_dma;
	union ehci_shadow qh_next;
	struct list_head qtd_list;
	struct list_head intr_node;
	struct ehci_qtd *dummy;
	struct list_head unlink_node;
	struct ehci_per_sched ps;
	unsigned int unlink_cycle;
	u8 qh_state;
	u8 xacterrs;
	u8 unlink_reason;
	u8 gap_uf;
	unsigned int is_out: 1;
	unsigned int clearing_tt: 1;
	unsigned int dequeue_during_giveback: 1;
	unsigned int should_be_inactive: 1;
};

struct ehci_qh_hw {
	__le32 hw_next;
	__le32 hw_info1;
	__le32 hw_info2;
	__le32 hw_current;
	__le32 hw_qtd_next;
	__le32 hw_alt_next;
	__le32 hw_token;
	__le32 hw_buf[5];
	__le32 hw_buf_hi[5];
	long: 64;
	long: 64;
	long: 64;
};

struct ehci_qtd {
	__le32 hw_next;
	__le32 hw_alt_next;
	__le32 hw_token;
	__le32 hw_buf[5];
	__le32 hw_buf_hi[5];
	dma_addr_t qtd_dma;
	struct list_head qtd_list;
	struct urb *urb;
	size_t length;
};

struct ehci_regs {
	u32 command;
	u32 status;
	u32 intr_enable;
	u32 frame_index;
	u32 segment;
	u32 frame_list;
	u32 async_next;
	u32 reserved1[2];
	u32 txfill_tuning;
	u32 reserved2[6];
	u32 configured_flag;
	union {
		u32 port_status[15];
		struct {
			u32 reserved3[9];
			u32 usbmode;
		};
	};
	union {
		struct {
			u32 reserved4;
			u32 hostpc[15];
		};
		u32 brcm_insnreg[4];
	};
	u32 reserved5[2];
	u32 usbmode_ex;
};

struct ehci_sitd {
	__le32 hw_next;
	__le32 hw_fullspeed_ep;
	__le32 hw_uframe;
	__le32 hw_results;
	__le32 hw_buf[2];
	__le32 hw_backpointer;
	__le32 hw_buf_hi[2];
	dma_addr_t sitd_dma;
	union ehci_shadow sitd_next;
	struct urb *urb;
	struct ehci_iso_stream *stream;
	struct list_head sitd_list;
	unsigned int frame;
	unsigned int index;
};

struct usb_tt;

struct ehci_tt {
	u16 bandwidth[8];
	struct list_head tt_list;
	struct list_head ps_list;
	struct usb_tt *usb_tt;
	int tt_port;
};

struct element {
	u8 id;
	u8 datalen;
	u8 data[0];
};

struct elevator_queue;

struct io_cq;

struct elevator_mq_ops {
	int (*init_sched)(struct request_queue *, struct elevator_type *);
	void (*exit_sched)(struct elevator_queue *);
	int (*init_hctx)(struct blk_mq_hw_ctx *, unsigned int);
	void (*exit_hctx)(struct blk_mq_hw_ctx *, unsigned int);
	void (*depth_updated)(struct blk_mq_hw_ctx *);
	bool (*allow_merge)(struct request_queue *, struct request *, struct bio *);
	bool (*bio_merge)(struct request_queue *, struct bio *, unsigned int);
	int (*request_merge)(struct request_queue *, struct request **, struct bio *);
	void (*request_merged)(struct request_queue *, struct request *, enum elv_merge);
	void (*requests_merged)(struct request_queue *, struct request *, struct request *);
	void (*limit_depth)(blk_opf_t, struct blk_mq_alloc_data *);
	void (*prepare_request)(struct request *);
	void (*finish_request)(struct request *);
	void (*insert_requests)(struct blk_mq_hw_ctx *, struct list_head *, blk_insert_t);
	struct request * (*dispatch_request)(struct blk_mq_hw_ctx *);
	bool (*has_work)(struct blk_mq_hw_ctx *);
	void (*completed_request)(struct request *, u64);
	void (*requeue_request)(struct request *);
	struct request * (*former_request)(struct request_queue *, struct request *);
	struct request * (*next_request)(struct request_queue *, struct request *);
	void (*init_icq)(struct io_cq *);
	void (*exit_icq)(struct io_cq *);
};

struct elevator_queue {
	struct elevator_type *type;
	void *elevator_data;
	struct kobject kobj;
	struct mutex sysfs_lock;
	long unsigned int flags;
	struct hlist_head hash[64];
};

struct elv_fs_entry;

struct elevator_type {
	struct kmem_cache *icq_cache;
	struct elevator_mq_ops ops;
	size_t icq_size;
	size_t icq_align;
	const struct elv_fs_entry *elevator_attrs;
	const char *elevator_name;
	const char *elevator_alias;
	struct module *elevator_owner;
	const struct blk_mq_debugfs_attr *queue_debugfs_attrs;
	const struct blk_mq_debugfs_attr *hctx_debugfs_attrs;
	char icq_cache_name[22];
	struct list_head list;
};

struct elf32_hdr {
	unsigned char e_ident[16];
	Elf32_Half e_type;
	Elf32_Half e_machine;
	Elf32_Word e_version;
	Elf32_Addr e_entry;
	Elf32_Off e_phoff;
	Elf32_Off e_shoff;
	Elf32_Word e_flags;
	Elf32_Half e_ehsize;
	Elf32_Half e_phentsize;
	Elf32_Half e_phnum;
	Elf32_Half e_shentsize;
	Elf32_Half e_shnum;
	Elf32_Half e_shstrndx;
};

typedef struct elf32_hdr Elf32_Ehdr;

struct elf32_note {
	Elf32_Word n_namesz;
	Elf32_Word n_descsz;
	Elf32_Word n_type;
};

typedef struct elf32_note Elf32_Nhdr;

struct elf32_phdr {
	Elf32_Word p_type;
	Elf32_Off p_offset;
	Elf32_Addr p_vaddr;
	Elf32_Addr p_paddr;
	Elf32_Word p_filesz;
	Elf32_Word p_memsz;
	Elf32_Word p_flags;
	Elf32_Word p_align;
};

typedef struct elf32_phdr Elf32_Phdr;

struct elf32_shdr {
	Elf32_Word sh_name;
	Elf32_Word sh_type;
	Elf32_Word sh_flags;
	Elf32_Addr sh_addr;
	Elf32_Off sh_offset;
	Elf32_Word sh_size;
	Elf32_Word sh_link;
	Elf32_Word sh_info;
	Elf32_Word sh_addralign;
	Elf32_Word sh_entsize;
};

struct elf64_hdr {
	unsigned char e_ident[16];
	Elf64_Half e_type;
	Elf64_Half e_machine;
	Elf64_Word e_version;
	Elf64_Addr e_entry;
	Elf64_Off e_phoff;
	Elf64_Off e_shoff;
	Elf64_Word e_flags;
	Elf64_Half e_ehsize;
	Elf64_Half e_phentsize;
	Elf64_Half e_phnum;
	Elf64_Half e_shentsize;
	Elf64_Half e_shnum;
	Elf64_Half e_shstrndx;
};

typedef struct elf64_hdr Elf64_Ehdr;

struct elf64_note {
	Elf64_Word n_namesz;
	Elf64_Word n_descsz;
	Elf64_Word n_type;
};

typedef struct elf64_note Elf64_Nhdr;

struct elf64_phdr {
	Elf64_Word p_type;
	Elf64_Word p_flags;
	Elf64_Off p_offset;
	Elf64_Addr p_vaddr;
	Elf64_Addr p_paddr;
	Elf64_Xword p_filesz;
	Elf64_Xword p_memsz;
	Elf64_Xword p_align;
};

typedef struct elf64_phdr Elf64_Phdr;

struct elf64_rela {
	Elf64_Addr r_offset;
	Elf64_Xword r_info;
	Elf64_Sxword r_addend;
};

typedef struct elf64_rela Elf64_Rela;

struct elf64_shdr {
	Elf64_Word sh_name;
	Elf64_Word sh_type;
	Elf64_Xword sh_flags;
	Elf64_Addr sh_addr;
	Elf64_Off sh_offset;
	Elf64_Xword sh_size;
	Elf64_Word sh_link;
	Elf64_Word sh_info;
	Elf64_Xword sh_addralign;
	Elf64_Xword sh_entsize;
};

typedef struct elf64_shdr Elf64_Shdr;

struct elf64_sym {
	Elf64_Word st_name;
	unsigned char st_info;
	unsigned char st_other;
	Elf64_Half st_shndx;
	Elf64_Addr st_value;
	Elf64_Xword st_size;
};

typedef struct elf64_sym Elf64_Sym;

struct memelfnote {
	const char *name;
	int type;
	unsigned int datasz;
	void *data;
};

struct elf_thread_core_info;

struct elf_note_info {
	struct elf_thread_core_info *thread;
	struct memelfnote psinfo;
	struct memelfnote signote;
	struct memelfnote auxv;
	struct memelfnote files;
	compat_siginfo_t csigdata;
	size_t size;
	int thread_notes;
};

struct siginfo {
	union {
		struct {
			int si_signo;
			int si_errno;
			int si_code;
			union __sifields _sifields;
		};
		int _si_pad[32];
	};
};

typedef struct siginfo siginfo_t;

struct elf_thread_core_info___2;

struct elf_note_info___2 {
	struct elf_thread_core_info___2 *thread;
	struct memelfnote psinfo;
	struct memelfnote signote;
	struct memelfnote auxv;
	struct memelfnote files;
	siginfo_t csigdata;
	size_t size;
	int thread_notes;
};

struct elf_prpsinfo {
	char pr_state;
	char pr_sname;
	char pr_zomb;
	char pr_nice;
	long unsigned int pr_flag;
	__kernel_uid_t pr_uid;
	__kernel_gid_t pr_gid;
	pid_t pr_pid;
	pid_t pr_ppid;
	pid_t pr_pgrp;
	pid_t pr_sid;
	char pr_fname[16];
	char pr_psargs[80];
};

struct elf_siginfo {
	int si_signo;
	int si_code;
	int si_errno;
};

struct elf_prstatus_common {
	struct elf_siginfo pr_info;
	short int pr_cursig;
	long unsigned int pr_sigpend;
	long unsigned int pr_sighold;
	pid_t pr_pid;
	pid_t pr_ppid;
	pid_t pr_pgrp;
	pid_t pr_sid;
	struct __kernel_old_timeval pr_utime;
	struct __kernel_old_timeval pr_stime;
	struct __kernel_old_timeval pr_cutime;
	struct __kernel_old_timeval pr_cstime;
};

struct elf_prstatus {
	struct elf_prstatus_common common;
	elf_gregset_t pr_reg;
	int pr_fpvalid;
};

struct elf_thread_core_info___2 {
	struct elf_thread_core_info___2 *next;
	struct task_struct *task;
	struct elf_prstatus prstatus;
	struct memelfnote notes[0];
};

struct elf_thread_core_info {
	struct elf_thread_core_info *next;
	struct task_struct *task;
	struct compat_elf_prstatus prstatus;
	struct memelfnote notes[0];
};

struct elv_fs_entry {
	struct attribute attr;
	ssize_t (*show)(struct elevator_queue *, char *);
	ssize_t (*store)(struct elevator_queue *, const char *, size_t);
};

struct em_perf_table;

struct em_perf_domain {
	struct em_perf_table *em_table;
	int nr_perf_states;
	int min_perf_state;
	int max_perf_state;
	long unsigned int flags;
	long unsigned int cpus[0];
};

struct em_perf_state {
	long unsigned int performance;
	long unsigned int frequency;
	long unsigned int power;
	long unsigned int cost;
	long unsigned int flags;
};

struct em_perf_table {
	struct callback_head rcu;
	struct kref kref;
	struct em_perf_state state[0];
};

struct trace_event_file;

struct enable_trigger_data {
	struct trace_event_file *file;
	bool enable;
	bool hist;
};

union encrypted_buff {
	u8 e_kpub_km[128];
	u8 e_kh_km_m[32];
	struct {
		u8 e_kh_km[16];
		u8 m[16];
	};
};

struct xdr_buf;

struct encryptor_desc {
	u8 iv[16];
	struct skcipher_request *req;
	int pos;
	struct xdr_buf *outbuf;
	struct page **pages;
	struct scatterlist infrags[4];
	struct scatterlist outfrags[4];
	int fragno;
	int fraglen;
};

struct energy_env {
	long unsigned int task_busy_time;
	long unsigned int pd_busy_time;
	long unsigned int cpu_cap;
	long unsigned int pd_cap;
};

struct engine_mmio_base {
	u32 graphics_ver: 8;
	u32 base: 24;
};

struct engine_info {
	u8 class;
	u8 instance;
	struct engine_mmio_base mmio_bases[3];
};

struct entropy_timer_state {
	long unsigned int entropy;
	struct timer_list timer;
	atomic_t samples;
	unsigned int samples_per_bit;
};

struct usb_endpoint_descriptor;

struct ep_device {
	struct usb_endpoint_descriptor *desc;
	struct usb_device *udev;
	struct device dev;
};

typedef struct poll_table_struct poll_table;

struct epitem;

struct ep_pqueue {
	poll_table pt;
	struct epitem *epi;
};

struct ephy_info {
	unsigned int offset;
	u16 mask;
	u16 bits;
};

struct epoll_filefd {
	struct file *file;
	int fd;
} __attribute__((packed));

struct epoll_event {
	__poll_t events;
	__u64 data;
} __attribute__((packed));

struct eppoll_entry;

struct eventpoll;

struct epitem {
	union {
		struct rb_node rbn;
		struct callback_head rcu;
	};
	struct list_head rdllink;
	struct epitem *next;
	struct epoll_filefd ffd;
	bool dying;
	struct eppoll_entry *pwqlist;
	struct eventpoll *ep;
	struct hlist_node fllink;
	struct wakeup_source *ws;
	struct epoll_event event;
};

struct epitems_head {
	struct hlist_head epitems;
	struct epitems_head *next;
};

struct epoll_params {
	__u32 busy_poll_usecs;
	__u16 busy_poll_budget;
	__u8 prefer_busy_poll;
	__u8 __pad;
};

struct eppoll_entry {
	struct eppoll_entry *next;
	struct epitem *base;
	wait_queue_entry_t wait;
	wait_queue_head_t *whead;
};

struct trace_eprobe;

struct eprobe_data {
	struct trace_event_file *file;
	struct trace_eprobe *ep;
};

struct eprobe_trace_entry_head {
	struct trace_entry ent;
};

struct equiv_cpu_entry {
	u32 installed_cpu;
	u32 fixed_errata_mask;
	u32 fixed_errata_compare;
	u16 equiv_cpu;
	u16 res;
};

struct equiv_cpu_table {
	unsigned int num_entries;
	struct equiv_cpu_entry *entry;
};

struct er_account {
	raw_spinlock_t lock;
	u64 config;
	u64 reg;
	atomic_t ref;
};

struct err_info {
	const char **errs;
	u8 type;
	u16 pos;
	u64 ts;
};

struct error_info {
	short unsigned int code12;
	short unsigned int size;
};

struct error_info2 {
	unsigned char code1;
	unsigned char code2_min;
	unsigned char code2_max;
	const char *str;
	const char *fmt;
};

struct errormap {
	char *name;
	int val;
	int namelen;
	struct hlist_node list;
};

struct erspan_md2 {
	__be32 timestamp;
	__be16 sgt;
	__u8 hwid_upper: 2;
	__u8 ft: 5;
	__u8 p: 1;
	__u8 o: 1;
	__u8 gra: 2;
	__u8 dir: 1;
	__u8 hwid: 4;
};

struct erspan_metadata {
	int version;
	union {
		__be32 index;
		struct erspan_md2 md2;
	} u;
};

struct ip_esp_hdr;

struct esp_info {
	struct ip_esp_hdr *esph;
	__be64 seqno;
	int tfclen;
	int tailen;
	int plen;
	int clen;
	int len;
	int nfrags;
	__u8 proto;
	bool inplace;
};

struct esp_output_extra {
	__be32 seqhi;
	u32 esphoff;
};

struct esp_skb_cb {
	struct xfrm_skb_cb xfrm;
	void *tmp;
};

struct esre_entry;

struct esre_attribute {
	struct attribute attr;
	ssize_t (*show)(struct esre_entry *, char *);
};

struct esre_entry {
	union {
		struct efi_system_resource_entry_v1 *esre1;
	} esre;
	struct kobject kobj;
	struct list_head list;
};

struct estack_pages {
	u32 offs;
	u16 size;
	u16 type;
};

struct ethnl_request_ops;

struct ethnl_dump_ctx {
	const struct ethnl_request_ops *ops;
	struct ethnl_req_info *req_info;
	struct ethnl_reply_data *reply_data;
	long unsigned int pos_ifindex;
};

struct ethnl_module_fw_flash_ntf_params {
	u32 portid;
	u32 seq;
	bool closed_sock;
};

struct phy_req_info;

struct ethnl_phy_dump_ctx {
	struct phy_req_info *phy_req_info;
	long unsigned int ifindex;
	long unsigned int phy_index;
};

struct ethnl_request_ops {
	u8 request_cmd;
	u8 reply_cmd;
	u16 hdr_attr;
	unsigned int req_info_size;
	unsigned int reply_data_size;
	bool allow_nodev_do;
	u8 set_ntf_cmd;
	int (*parse_request)(struct ethnl_req_info *, struct nlattr **, struct netlink_ext_ack *);
	int (*prepare_data)(const struct ethnl_req_info *, struct ethnl_reply_data *, const struct genl_info *);
	int (*reply_size)(const struct ethnl_req_info *, const struct ethnl_reply_data *);
	int (*fill_reply)(struct sk_buff *, const struct ethnl_req_info *, const struct ethnl_reply_data *);
	void (*cleanup_data)(struct ethnl_reply_data *);
	int (*set_validate)(struct ethnl_req_info *, struct genl_info *);
	int (*set)(struct ethnl_req_info *, struct genl_info *);
};

struct ethnl_sock_priv {
	struct net_device *dev;
	u32 portid;
	enum ethnl_sock_type type;
};

struct tsinfo_req_info;

struct tsinfo_reply_data;

struct ethnl_tsinfo_dump_ctx {
	struct tsinfo_req_info *req_info;
	struct tsinfo_reply_data *reply_data;
	long unsigned int pos_ifindex;
	bool netdev_dump_done;
	long unsigned int pos_phyindex;
	enum hwtstamp_provider_qualifier pos_phcqualifier;
};

struct ethnl_tunnel_info_dump_ctx {
	struct ethnl_req_info req_info;
	long unsigned int ifindex;
};

struct ethtool_c33_pse_ext_state_info {
	enum ethtool_c33_pse_ext_state c33_pse_ext_state;
	union {
		enum ethtool_c33_pse_ext_substate_error_condition error_condition;
		enum ethtool_c33_pse_ext_substate_mr_pse_enable mr_pse_enable;
		enum ethtool_c33_pse_ext_substate_option_detect_ted option_detect_ted;
		enum ethtool_c33_pse_ext_substate_option_vport_lim option_vport_lim;
		enum ethtool_c33_pse_ext_substate_ovld_detected ovld_detected;
		enum ethtool_c33_pse_ext_substate_power_not_available power_not_available;
		enum ethtool_c33_pse_ext_substate_short_detected short_detected;
		u32 __c33_pse_ext_substate;
	};
};

struct ethtool_c33_pse_pw_limit_range {
	u32 min;
	u32 max;
};

struct ethtool_cmd {
	__u32 cmd;
	__u32 supported;
	__u32 advertising;
	__u16 speed;
	__u8 duplex;
	__u8 port;
	__u8 phy_address;
	__u8 transceiver;
	__u8 autoneg;
	__u8 mdio_support;
	__u32 maxtxpkt;
	__u32 maxrxpkt;
	__u16 speed_hi;
	__u8 eth_tp_mdix;
	__u8 eth_tp_mdix_ctrl;
	__u32 lp_advertising;
	__u32 reserved[2];
};

struct ethtool_cmis_cdb {
	u8 cmis_rev;
	u8 read_write_len_ext;
	u16 max_completion_time;
};

struct ethtool_cmis_cdb_request {
	__be16 id;
	union {
		struct {
			__be16 epl_len;
			u8 lpl_len;
			u8 chk_code;
			u8 resv1;
			u8 resv2;
			u8 payload[120];
		};
		struct {
			__be16 epl_len;
			u8 lpl_len;
			u8 chk_code;
			u8 resv1;
			u8 resv2;
			u8 payload[120];
		} body;
	};
	u8 *epl;
};

struct ethtool_cmis_cdb_cmd_args {
	struct ethtool_cmis_cdb_request req;
	u16 max_duration;
	u8 read_write_len_ext;
	u8 msleep_pre_rpl;
	u8 rpl_exp_len;
	u8 flags;
	char *err_msg;
};

struct ethtool_cmis_cdb_rpl_hdr {
	u8 rpl_len;
	u8 rpl_chk_code;
};

struct ethtool_cmis_cdb_rpl {
	struct ethtool_cmis_cdb_rpl_hdr hdr;
	u8 payload[120];
};

struct ethtool_module_fw_flash_params {
	__be32 password;
	u8 password_valid: 1;
};

struct firmware;

struct ethtool_cmis_fw_update_params {
	struct net_device *dev;
	struct ethtool_module_fw_flash_params params;
	struct ethnl_module_fw_flash_ntf_params ntf_params;
	const struct firmware *fw;
};

struct ethtool_flash {
	__u32 cmd;
	__u32 region;
	char data[128];
};

struct ethtool_drvinfo {
	__u32 cmd;
	char driver[32];
	char version[32];
	char fw_version[32];
	char bus_info[32];
	char erom_version[32];
	char reserved2[12];
	__u32 n_priv_flags;
	__u32 n_stats;
	__u32 testinfo_len;
	__u32 eedump_len;
	__u32 regdump_len;
};

struct ethtool_devlink_compat {
	struct devlink *devlink;
	union {
		struct ethtool_flash efl;
		struct ethtool_drvinfo info;
	};
};

struct ethtool_dump {
	__u32 cmd;
	__u32 version;
	__u32 flag;
	__u32 len;
	__u8 data[0];
};

struct ethtool_eee {
	__u32 cmd;
	__u32 supported;
	__u32 advertised;
	__u32 lp_advertised;
	__u32 eee_active;
	__u32 eee_enabled;
	__u32 tx_lpi_enabled;
	__u32 tx_lpi_timer;
	__u32 reserved[2];
};

struct ethtool_eeprom {
	__u32 cmd;
	__u32 magic;
	__u32 offset;
	__u32 len;
	__u8 data[0];
};

struct ethtool_eth_ctrl_stats {
	enum ethtool_mac_stats_src src;
	union {
		struct {
			u64 MACControlFramesTransmitted;
			u64 MACControlFramesReceived;
			u64 UnsupportedOpcodesReceived;
		};
		struct {
			u64 MACControlFramesTransmitted;
			u64 MACControlFramesReceived;
			u64 UnsupportedOpcodesReceived;
		} stats;
	};
};

struct ethtool_eth_mac_stats {
	enum ethtool_mac_stats_src src;
	union {
		struct {
			u64 FramesTransmittedOK;
			u64 SingleCollisionFrames;
			u64 MultipleCollisionFrames;
			u64 FramesReceivedOK;
			u64 FrameCheckSequenceErrors;
			u64 AlignmentErrors;
			u64 OctetsTransmittedOK;
			u64 FramesWithDeferredXmissions;
			u64 LateCollisions;
			u64 FramesAbortedDueToXSColls;
			u64 FramesLostDueToIntMACXmitError;
			u64 CarrierSenseErrors;
			u64 OctetsReceivedOK;
			u64 FramesLostDueToIntMACRcvError;
			u64 MulticastFramesXmittedOK;
			u64 BroadcastFramesXmittedOK;
			u64 FramesWithExcessiveDeferral;
			u64 MulticastFramesReceivedOK;
			u64 BroadcastFramesReceivedOK;
			u64 InRangeLengthErrors;
			u64 OutOfRangeLengthField;
			u64 FrameTooLongErrors;
		};
		struct {
			u64 FramesTransmittedOK;
			u64 SingleCollisionFrames;
			u64 MultipleCollisionFrames;
			u64 FramesReceivedOK;
			u64 FrameCheckSequenceErrors;
			u64 AlignmentErrors;
			u64 OctetsTransmittedOK;
			u64 FramesWithDeferredXmissions;
			u64 LateCollisions;
			u64 FramesAbortedDueToXSColls;
			u64 FramesLostDueToIntMACXmitError;
			u64 CarrierSenseErrors;
			u64 OctetsReceivedOK;
			u64 FramesLostDueToIntMACRcvError;
			u64 MulticastFramesXmittedOK;
			u64 BroadcastFramesXmittedOK;
			u64 FramesWithExcessiveDeferral;
			u64 MulticastFramesReceivedOK;
			u64 BroadcastFramesReceivedOK;
			u64 InRangeLengthErrors;
			u64 OutOfRangeLengthField;
			u64 FrameTooLongErrors;
		} stats;
	};
};

struct ethtool_eth_phy_stats {
	enum ethtool_mac_stats_src src;
	union {
		struct {
			u64 SymbolErrorDuringCarrier;
		};
		struct {
			u64 SymbolErrorDuringCarrier;
		} stats;
	};
};

struct ethtool_fec_stat {
	u64 total;
	u64 lanes[8];
};

struct ethtool_fec_stats {
	struct ethtool_fec_stat corrected_blocks;
	struct ethtool_fec_stat uncorrectable_blocks;
	struct ethtool_fec_stat corrected_bits;
};

struct ethtool_fecparam {
	__u32 cmd;
	__u32 active_fec;
	__u32 fec;
	__u32 reserved;
};

struct ethtool_forced_speed_map {
	u32 speed;
	long unsigned int caps[2];
	const u32 *cap_arr;
	u32 arr_size;
};

struct ethtool_get_features_block {
	__u32 available;
	__u32 requested;
	__u32 active;
	__u32 never_changed;
};

struct ethtool_gfeatures {
	__u32 cmd;
	__u32 size;
	struct ethtool_get_features_block features[0];
};

struct ethtool_gstrings {
	__u32 cmd;
	__u32 string_set;
	__u32 len;
	__u8 data[0];
};

struct ethtool_link_ext_state_info {
	enum ethtool_link_ext_state link_ext_state;
	union {
		enum ethtool_link_ext_substate_autoneg autoneg;
		enum ethtool_link_ext_substate_link_training link_training;
		enum ethtool_link_ext_substate_link_logical_mismatch link_logical_mismatch;
		enum ethtool_link_ext_substate_bad_signal_integrity bad_signal_integrity;
		enum ethtool_link_ext_substate_cable_issue cable_issue;
		enum ethtool_link_ext_substate_module module;
		u32 __link_ext_substate;
	};
};

struct ethtool_link_ext_stats {
	u64 link_down_events;
};

struct ethtool_link_settings {
	__u32 cmd;
	__u32 speed;
	__u8 duplex;
	__u8 port;
	__u8 phy_address;
	__u8 autoneg;
	__u8 mdio_support;
	__u8 eth_tp_mdix;
	__u8 eth_tp_mdix_ctrl;
	__s8 link_mode_masks_nwords;
	__u8 transceiver;
	__u8 master_slave_cfg;
	__u8 master_slave_state;
	__u8 rate_matching;
	__u32 reserved[7];
};

struct ethtool_link_ksettings {
	struct ethtool_link_settings base;
	struct {
		long unsigned int supported[2];
		long unsigned int advertising[2];
		long unsigned int lp_advertising[2];
	} link_modes;
	u32 lanes;
};

struct ethtool_link_usettings {
	struct ethtool_link_settings base;
	struct {
		__u32 supported[4];
		__u32 advertising[4];
		__u32 lp_advertising[4];
	} link_modes;
};

struct ethtool_mm_cfg {
	u32 verify_time;
	bool verify_enabled;
	bool tx_enabled;
	bool pmac_enabled;
	u32 tx_min_frag_size;
};

struct ethtool_mm_state {
	u32 verify_time;
	u32 max_verify_time;
	enum ethtool_mm_verify_status verify_status;
	bool tx_enabled;
	bool tx_active;
	bool pmac_enabled;
	bool verify_enabled;
	u32 tx_min_frag_size;
	u32 rx_min_frag_size;
};

struct ethtool_mm_stats {
	u64 MACMergeFrameAssErrorCount;
	u64 MACMergeFrameSmdErrorCount;
	u64 MACMergeFrameAssOkCount;
	u64 MACMergeFragCountRx;
	u64 MACMergeFragCountTx;
	u64 MACMergeHoldCount;
};

struct ethtool_modinfo {
	__u32 cmd;
	__u32 type;
	__u32 eeprom_len;
	__u32 reserved[8];
};

struct ethtool_module_eeprom {
	u32 offset;
	u32 length;
	u8 page;
	u8 bank;
	u8 i2c_address;
	u8 *data;
};

struct ethtool_module_fw_flash {
	struct list_head list;
	netdevice_tracker dev_tracker;
	struct work_struct work;
	struct ethtool_cmis_fw_update_params fw_update;
};

struct ethtool_module_power_mode_params {
	enum ethtool_module_power_mode_policy policy;
	enum ethtool_module_power_mode mode;
};

struct ethtool_netdev_state {
	struct xarray rss_ctx;
	struct mutex rss_lock;
	unsigned int wol_enabled: 1;
	unsigned int module_fw_flash_in_progress: 1;
};

struct ethtool_regs;

struct ethtool_wolinfo;

struct ethtool_ringparam;

struct kernel_ethtool_ringparam;

struct ethtool_pause_stats;

struct ethtool_pauseparam;

struct ethtool_test;

struct ethtool_stats;

struct ethtool_rxnfc;

struct ethtool_rxfh_param;

struct ethtool_rxfh_context;

struct kernel_ethtool_ts_info;

struct ethtool_ts_stats;

struct ethtool_tunable;

struct ethtool_rmon_stats;

struct ethtool_rmon_hist_range;

struct ethtool_ops {
	u32 cap_link_lanes_supported: 1;
	u32 cap_rss_ctx_supported: 1;
	u32 cap_rss_sym_xor_supported: 1;
	u32 rxfh_per_ctx_key: 1;
	u32 cap_rss_rxnfc_adds: 1;
	u32 rxfh_indir_space;
	u16 rxfh_key_space;
	u16 rxfh_priv_size;
	u32 rxfh_max_num_contexts;
	u32 supported_coalesce_params;
	u32 supported_ring_params;
	u32 supported_hwtstamp_qualifiers;
	void (*get_drvinfo)(struct net_device *, struct ethtool_drvinfo *);
	int (*get_regs_len)(struct net_device *);
	void (*get_regs)(struct net_device *, struct ethtool_regs *, void *);
	void (*get_wol)(struct net_device *, struct ethtool_wolinfo *);
	int (*set_wol)(struct net_device *, struct ethtool_wolinfo *);
	u32 (*get_msglevel)(struct net_device *);
	void (*set_msglevel)(struct net_device *, u32);
	int (*nway_reset)(struct net_device *);
	u32 (*get_link)(struct net_device *);
	int (*get_link_ext_state)(struct net_device *, struct ethtool_link_ext_state_info *);
	void (*get_link_ext_stats)(struct net_device *, struct ethtool_link_ext_stats *);
	int (*get_eeprom_len)(struct net_device *);
	int (*get_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *);
	int (*set_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *);
	int (*get_coalesce)(struct net_device *, struct ethtool_coalesce *, struct kernel_ethtool_coalesce *, struct netlink_ext_ack *);
	int (*set_coalesce)(struct net_device *, struct ethtool_coalesce *, struct kernel_ethtool_coalesce *, struct netlink_ext_ack *);
	void (*get_ringparam)(struct net_device *, struct ethtool_ringparam *, struct kernel_ethtool_ringparam *, struct netlink_ext_ack *);
	int (*set_ringparam)(struct net_device *, struct ethtool_ringparam *, struct kernel_ethtool_ringparam *, struct netlink_ext_ack *);
	void (*get_pause_stats)(struct net_device *, struct ethtool_pause_stats *);
	void (*get_pauseparam)(struct net_device *, struct ethtool_pauseparam *);
	int (*set_pauseparam)(struct net_device *, struct ethtool_pauseparam *);
	void (*self_test)(struct net_device *, struct ethtool_test *, u64 *);
	void (*get_strings)(struct net_device *, u32, u8 *);
	int (*set_phys_id)(struct net_device *, enum ethtool_phys_id_state);
	void (*get_ethtool_stats)(struct net_device *, struct ethtool_stats *, u64 *);
	int (*begin)(struct net_device *);
	void (*complete)(struct net_device *);
	u32 (*get_priv_flags)(struct net_device *);
	int (*set_priv_flags)(struct net_device *, u32);
	int (*get_sset_count)(struct net_device *, int);
	int (*get_rxnfc)(struct net_device *, struct ethtool_rxnfc *, u32 *);
	int (*set_rxnfc)(struct net_device *, struct ethtool_rxnfc *);
	int (*flash_device)(struct net_device *, struct ethtool_flash *);
	int (*reset)(struct net_device *, u32 *);
	u32 (*get_rxfh_key_size)(struct net_device *);
	u32 (*get_rxfh_indir_size)(struct net_device *);
	int (*get_rxfh)(struct net_device *, struct ethtool_rxfh_param *);
	int (*set_rxfh)(struct net_device *, struct ethtool_rxfh_param *, struct netlink_ext_ack *);
	int (*create_rxfh_context)(struct net_device *, struct ethtool_rxfh_context *, const struct ethtool_rxfh_param *, struct netlink_ext_ack *);
	int (*modify_rxfh_context)(struct net_device *, struct ethtool_rxfh_context *, const struct ethtool_rxfh_param *, struct netlink_ext_ack *);
	int (*remove_rxfh_context)(struct net_device *, struct ethtool_rxfh_context *, u32, struct netlink_ext_ack *);
	void (*get_channels)(struct net_device *, struct ethtool_channels *);
	int (*set_channels)(struct net_device *, struct ethtool_channels *);
	int (*get_dump_flag)(struct net_device *, struct ethtool_dump *);
	int (*get_dump_data)(struct net_device *, struct ethtool_dump *, void *);
	int (*set_dump)(struct net_device *, struct ethtool_dump *);
	int (*get_ts_info)(struct net_device *, struct kernel_ethtool_ts_info *);
	void (*get_ts_stats)(struct net_device *, struct ethtool_ts_stats *);
	int (*get_module_info)(struct net_device *, struct ethtool_modinfo *);
	int (*get_module_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *);
	int (*get_eee)(struct net_device *, struct ethtool_keee *);
	int (*set_eee)(struct net_device *, struct ethtool_keee *);
	int (*get_tunable)(struct net_device *, const struct ethtool_tunable *, void *);
	int (*set_tunable)(struct net_device *, const struct ethtool_tunable *, const void *);
	int (*get_per_queue_coalesce)(struct net_device *, u32, struct ethtool_coalesce *);
	int (*set_per_queue_coalesce)(struct net_device *, u32, struct ethtool_coalesce *);
	int (*get_link_ksettings)(struct net_device *, struct ethtool_link_ksettings *);
	int (*set_link_ksettings)(struct net_device *, const struct ethtool_link_ksettings *);
	void (*get_fec_stats)(struct net_device *, struct ethtool_fec_stats *);
	int (*get_fecparam)(struct net_device *, struct ethtool_fecparam *);
	int (*set_fecparam)(struct net_device *, struct ethtool_fecparam *);
	void (*get_ethtool_phy_stats)(struct net_device *, struct ethtool_stats *, u64 *);
	int (*get_phy_tunable)(struct net_device *, const struct ethtool_tunable *, void *);
	int (*set_phy_tunable)(struct net_device *, const struct ethtool_tunable *, const void *);
	int (*get_module_eeprom_by_page)(struct net_device *, const struct ethtool_module_eeprom *, struct netlink_ext_ack *);
	int (*set_module_eeprom_by_page)(struct net_device *, const struct ethtool_module_eeprom *, struct netlink_ext_ack *);
	void (*get_eth_phy_stats)(struct net_device *, struct ethtool_eth_phy_stats *);
	void (*get_eth_mac_stats)(struct net_device *, struct ethtool_eth_mac_stats *);
	void (*get_eth_ctrl_stats)(struct net_device *, struct ethtool_eth_ctrl_stats *);
	void (*get_rmon_stats)(struct net_device *, struct ethtool_rmon_stats *, const struct ethtool_rmon_hist_range **);
	int (*get_module_power_mode)(struct net_device *, struct ethtool_module_power_mode_params *, struct netlink_ext_ack *);
	int (*set_module_power_mode)(struct net_device *, const struct ethtool_module_power_mode_params *, struct netlink_ext_ack *);
	int (*get_mm)(struct net_device *, struct ethtool_mm_state *);
	int (*set_mm)(struct net_device *, struct ethtool_mm_cfg *, struct netlink_ext_ack *);
	void (*get_mm_stats)(struct net_device *, struct ethtool_mm_stats *);
};

struct ethtool_pause_stats {
	enum ethtool_mac_stats_src src;
	union {
		struct {
			u64 tx_pause_frames;
			u64 rx_pause_frames;
		};
		struct {
			u64 tx_pause_frames;
			u64 rx_pause_frames;
		} stats;
	};
};

struct ethtool_pauseparam {
	__u32 cmd;
	__u32 autoneg;
	__u32 rx_pause;
	__u32 tx_pause;
};

struct ethtool_per_queue_op {
	__u32 cmd;
	__u32 sub_command;
	__u32 queue_mask[128];
	char data[0];
};

struct ethtool_perm_addr {
	__u32 cmd;
	__u32 size;
	__u8 data[0];
};

struct phy_device;

struct phy_plca_cfg;

struct phy_plca_status;

struct phy_tdr_config;

struct ethtool_phy_ops {
	int (*get_sset_count)(struct phy_device *);
	int (*get_strings)(struct phy_device *, u8 *);
	int (*get_stats)(struct phy_device *, struct ethtool_stats *, u64 *);
	int (*get_plca_cfg)(struct phy_device *, struct phy_plca_cfg *);
	int (*set_plca_cfg)(struct phy_device *, const struct phy_plca_cfg *, struct netlink_ext_ack *);
	int (*get_plca_status)(struct phy_device *, struct phy_plca_status *);
	int (*start_cable_test)(struct phy_device *, struct netlink_ext_ack *);
	int (*start_cable_test_tdr)(struct phy_device *, struct netlink_ext_ack *, const struct phy_tdr_config *);
};

struct ethtool_phy_stats {
	u64 rx_packets;
	u64 rx_bytes;
	u64 rx_errors;
	u64 tx_packets;
	u64 tx_bytes;
	u64 tx_errors;
};

struct ethtool_pse_control_status {
	enum ethtool_podl_pse_admin_state podl_admin_state;
	enum ethtool_podl_pse_pw_d_status podl_pw_status;
	enum ethtool_c33_pse_admin_state c33_admin_state;
	enum ethtool_c33_pse_pw_d_status c33_pw_status;
	u32 c33_pw_class;
	u32 c33_actual_pw;
	struct ethtool_c33_pse_ext_state_info c33_ext_state_info;
	u32 c33_avail_pw_limit;
	struct ethtool_c33_pse_pw_limit_range *c33_pw_limit_ranges;
	u32 c33_pw_limit_nb_ranges;
};

struct ethtool_regs {
	__u32 cmd;
	__u32 version;
	__u32 len;
	__u8 data[0];
};

struct ethtool_ringparam {
	__u32 cmd;
	__u32 rx_max_pending;
	__u32 rx_mini_max_pending;
	__u32 rx_jumbo_max_pending;
	__u32 tx_max_pending;
	__u32 rx_pending;
	__u32 rx_mini_pending;
	__u32 rx_jumbo_pending;
	__u32 tx_pending;
};

struct ethtool_rmon_hist_range {
	u16 low;
	u16 high;
};

struct ethtool_rmon_stats {
	enum ethtool_mac_stats_src src;
	union {
		struct {
			u64 undersize_pkts;
			u64 oversize_pkts;
			u64 fragments;
			u64 jabbers;
			u64 hist[10];
			u64 hist_tx[10];
		};
		struct {
			u64 undersize_pkts;
			u64 oversize_pkts;
			u64 fragments;
			u64 jabbers;
			u64 hist[10];
			u64 hist_tx[10];
		} stats;
	};
};

struct flow_dissector_key_basic {
	__be16 n_proto;
	u8 ip_proto;
	u8 padding;
};

struct flow_dissector_key_ipv4_addrs {
	__be32 src;
	__be32 dst;
};

struct flow_dissector_key_ipv6_addrs {
	struct in6_addr src;
	struct in6_addr dst;
};

struct flow_dissector_key_ports {
	union {
		__be32 ports;
		struct {
			__be16 src;
			__be16 dst;
		};
	};
};

struct flow_dissector_key_ip {
	__u8 tos;
	__u8 ttl;
};

struct flow_dissector_key_vlan {
	union {
		struct {
			u16 vlan_id: 12;
			u16 vlan_dei: 1;
			u16 vlan_priority: 3;
		};
		__be16 vlan_tci;
	};
	__be16 vlan_tpid;
	__be16 vlan_eth_type;
	u16 padding;
};

struct flow_dissector_key_eth_addrs {
	unsigned char dst[6];
	unsigned char src[6];
};

struct ethtool_rx_flow_key {
	struct flow_dissector_key_basic basic;
	union {
		struct flow_dissector_key_ipv4_addrs ipv4;
		struct flow_dissector_key_ipv6_addrs ipv6;
	};
	struct flow_dissector_key_ports tp;
	struct flow_dissector_key_ip ip;
	struct flow_dissector_key_vlan vlan;
	struct flow_dissector_key_eth_addrs eth_addrs;
};

struct flow_dissector {
	long long unsigned int used_keys;
	short unsigned int offset[33];
};

struct ethtool_rx_flow_match {
	struct flow_dissector dissector;
	struct ethtool_rx_flow_key key;
	struct ethtool_rx_flow_key mask;
};

struct flow_rule;

struct ethtool_rx_flow_rule {
	struct flow_rule *rule;
	long unsigned int priv[0];
};

struct ethtool_rx_flow_spec {
	__u32 flow_type;
	union ethtool_flow_union h_u;
	struct ethtool_flow_ext h_ext;
	union ethtool_flow_union m_u;
	struct ethtool_flow_ext m_ext;
	__u64 ring_cookie;
	__u32 location;
};

struct ethtool_rx_flow_spec_input {
	const struct ethtool_rx_flow_spec *fs;
	u32 rss_ctx;
};

struct ethtool_rxfh {
	__u32 cmd;
	__u32 rss_context;
	__u32 indir_size;
	__u32 key_size;
	__u8 hfunc;
	__u8 input_xfrm;
	__u8 rsvd8[2];
	__u32 rsvd32;
	__u32 rss_config[0];
};

struct ethtool_rxfh_context {
	u32 indir_size;
	u32 key_size;
	u16 priv_size;
	u8 hfunc;
	u8 input_xfrm;
	u8 indir_configured: 1;
	u8 key_configured: 1;
	u32 key_off;
	long: 0;
	u8 data[0];
};

struct ethtool_rxfh_param {
	u8 hfunc;
	u32 indir_size;
	u32 *indir;
	u32 key_size;
	u8 *key;
	u32 rss_context;
	u8 rss_delete;
	u8 input_xfrm;
};

struct ethtool_rxnfc {
	__u32 cmd;
	__u32 flow_type;
	__u64 data;
	struct ethtool_rx_flow_spec fs;
	union {
		__u32 rule_cnt;
		__u32 rss_context;
	};
	__u32 rule_locs[0];
};

struct ethtool_set_features_block {
	__u32 valid;
	__u32 requested;
};

struct ethtool_sfeatures {
	__u32 cmd;
	__u32 size;
	struct ethtool_set_features_block features[0];
};

struct ethtool_sset_info {
	__u32 cmd;
	__u32 reserved;
	__u64 sset_mask;
	__u32 data[0];
};

struct ethtool_stats {
	__u32 cmd;
	__u32 n_stats;
	__u64 data[0];
};

struct ethtool_test {
	__u32 cmd;
	__u32 flags;
	__u32 reserved;
	__u32 len;
	__u64 data[0];
};

struct ethtool_ts_info {
	__u32 cmd;
	__u32 so_timestamping;
	__s32 phc_index;
	__u32 tx_types;
	__u32 tx_reserved[3];
	__u32 rx_filters;
	__u32 rx_reserved[3];
};

struct ethtool_ts_stats {
	union {
		struct {
			u64 pkts;
			u64 onestep_pkts_unconfirmed;
			u64 lost;
			u64 err;
		};
		struct {
			u64 pkts;
			u64 onestep_pkts_unconfirmed;
			u64 lost;
			u64 err;
		} tx_stats;
	};
};

struct ethtool_tunable {
	__u32 cmd;
	__u32 id;
	__u32 type_id;
	__u32 len;
	void *data[0];
};

struct ethtool_value {
	__u32 cmd;
	__u32 data;
};

struct ethtool_wolinfo {
	__u32 cmd;
	__u32 supported;
	__u32 wolopts;
	__u8 sopass[6];
};

struct input_handler;

struct input_value;

struct input_handle {
	void *private;
	int open;
	const char *name;
	struct input_dev *dev;
	struct input_handler *handler;
	unsigned int (*handle_events)(struct input_handle *, struct input_value *, unsigned int);
	struct list_head d_node;
	struct list_head h_node;
};

struct evdev_client;

struct evdev {
	int open;
	struct input_handle handle;
	struct evdev_client *grab;
	struct list_head client_list;
	spinlock_t client_lock;
	struct mutex mutex;
	struct device dev;
	struct cdev cdev;
	bool exist;
};

struct input_event {
	__kernel_ulong_t __sec;
	__kernel_ulong_t __usec;
	__u16 type;
	__u16 code;
	__s32 value;
};

struct fasync_struct;

struct evdev_client {
	unsigned int head;
	unsigned int tail;
	unsigned int packet_head;
	spinlock_t buffer_lock;
	wait_queue_head_t wait;
	struct fasync_struct *fasync;
	struct evdev *evdev;
	struct list_head node;
	enum input_clock_type clk_type;
	bool revoked;
	long unsigned int *evmasks[32];
	unsigned int bufsize;
	struct input_event buffer[0];
};

struct event_trigger_data;

struct event_trigger_ops;

struct event_command {
	struct list_head list;
	char *name;
	enum event_trigger_type trigger_type;
	int flags;
	int (*parse)(struct event_command *, struct trace_event_file *, char *, char *, char *);
	int (*reg)(char *, struct event_trigger_data *, struct trace_event_file *);
	void (*unreg)(char *, struct event_trigger_data *, struct trace_event_file *);
	void (*unreg_all)(struct trace_event_file *);
	int (*set_filter)(char *, struct event_trigger_data *, struct trace_event_file *);
	struct event_trigger_ops * (*get_trigger_ops)(char *, char *);
};

struct event_counter {
	u32 count;
	u32 flags;
};

struct event_file_link {
	struct trace_event_file *file;
	struct list_head list;
};

struct prog_entry;

struct event_filter {
	struct prog_entry *prog;
	char *filter_string;
};

struct perf_cpu_context;

struct perf_event_context;

typedef void (*event_f)(struct perf_event *, struct perf_cpu_context *, struct perf_event_context *, void *);

struct event_function_struct {
	struct perf_event *event;
	event_f func;
	void *data;
};

struct event_header {
	__be16 data_len;
	__u8 notification_class: 3;
	__u8 reserved1: 4;
	__u8 nea: 1;
	__u8 supp_event_class;
};

struct event_mod_load {
	struct list_head list;
	char *module;
	char *match;
	char *system;
	char *event;
};

struct event_subsystem {
	struct list_head list;
	const char *name;
	struct event_filter *filter;
	int ref_count;
};

struct event_trigger_data {
	long unsigned int count;
	int ref;
	int flags;
	struct event_trigger_ops *ops;
	struct event_command *cmd_ops;
	struct event_filter *filter;
	char *filter_str;
	void *private_data;
	bool paused;
	bool paused_tmp;
	struct list_head list;
	char *name;
	struct list_head named_list;
	struct event_trigger_data *named_data;
};

struct ring_buffer_event;

struct event_trigger_ops {
	void (*trigger)(struct event_trigger_data *, struct trace_buffer *, void *, struct ring_buffer_event *);
	int (*init)(struct event_trigger_data *);
	void (*free)(struct event_trigger_data *);
	int (*print)(struct seq_file *, struct event_trigger_data *);
};

struct eventfd_ctx {
	struct kref kref;
	wait_queue_head_t wqh;
	__u64 count;
	unsigned int flags;
	int id;
};

struct eventfs_attr {
	int mode;
	kuid_t uid;
	kgid_t gid;
};

typedef int (*eventfs_callback)(const char *, umode_t *, void **, const struct file_operations **);

typedef void (*eventfs_release)(const char *, void *);

struct eventfs_entry {
	const char *name;
	eventfs_callback callback;
	eventfs_release release;
};

struct eventfs_inode {
	union {
		struct list_head list;
		struct callback_head rcu;
	};
	struct list_head children;
	const struct eventfs_entry *entries;
	const char *name;
	struct eventfs_attr *entry_attrs;
	void *data;
	struct eventfs_attr attr;
	struct kref kref;
	unsigned int is_freed: 1;
	unsigned int is_events: 1;
	unsigned int nr_entries: 30;
	unsigned int ino;
};

struct eventfs_root_inode {
	struct eventfs_inode ei;
	struct dentry *events_dir;
};

struct eventpoll {
	struct mutex mtx;
	wait_queue_head_t wq;
	wait_queue_head_t poll_wait;
	struct list_head rdllist;
	rwlock_t lock;
	struct rb_root_cached rbr;
	struct epitem *ovflist;
	struct wakeup_source *ws;
	struct user_struct *user;
	struct file *file;
	u64 gen;
	struct hlist_head refs;
	refcount_t refcount;
	unsigned int napi_id;
	u32 busy_poll_usecs;
	u16 busy_poll_budget;
	bool prefer_busy_poll;
};

struct ewma__engine_latency {
	long unsigned int internal;
};

struct ewma_avg_signal {
	long unsigned int internal;
};

struct ewma_beacon_signal {
	long unsigned int internal;
};

struct ewma_pkt_len {
	long unsigned int internal;
};

struct ewma_runtime {
	long unsigned int internal;
};

struct ewma_signal {
	long unsigned int internal;
};

struct exar8250_board;

struct exar8250 {
	unsigned int nr;
	unsigned int osc_freq;
	struct exar8250_board *board;
	struct eeprom_93cx6 eeprom;
	void *virt;
	int line[0];
};

struct exar8250_board {
	unsigned int num_ports;
	unsigned int reg_shift;
	int (*setup)(struct exar8250 *, struct pci_dev *, struct uart_8250_port *, int);
	void (*exit)(struct pci_dev *);
};

struct exar8250_platform {
	int (*rs485_config)(struct uart_port *, struct ktermios *, struct serial_rs485 *);
	const struct serial_rs485 *rs485_supported;
	int (*register_gpio)(struct pci_dev *, struct uart_8250_port *);
	void (*unregister_gpio)(struct uart_8250_port *);
};

struct exception_stacks {
	char DF_stack_guard[0];
	char DF_stack[8192];
	char NMI_stack_guard[0];
	char NMI_stack[8192];
	char DB_stack_guard[0];
	char DB_stack[8192];
	char MCE_stack_guard[0];
	char MCE_stack[8192];
	char VC_stack_guard[0];
	char VC_stack[0];
	char VC2_stack_guard[0];
	char VC2_stack[0];
	char IST_top_guard[0];
};

struct exception_table_entry {
	int insn;
	int fixup;
	int data;
};

struct exec_proc_event {
	__kernel_pid_t process_pid;
	__kernel_pid_t process_tgid;
};

struct i915_request;

struct execlists_capture {
	struct work_struct work;
	struct i915_request *rq;
	struct i915_gpu_coredump *error;
};

struct execmem_range {
	long unsigned int start;
	long unsigned int end;
	long unsigned int fallback_start;
	long unsigned int fallback_end;
	pgprot_t pgprot;
	unsigned int alignment;
	enum execmem_range_flags flags;
};

struct execmem_info {
	struct execmem_range ranges[5];
};

struct execute_cb {
	struct irq_work work;
	struct i915_sw_fence *fence;
};

struct execute_work {
	struct work_struct work;
};

struct exit_proc_event {
	__kernel_pid_t process_pid;
	__kernel_pid_t process_tgid;
	__u32 exit_code;
	__u32 exit_signal;
	__kernel_pid_t parent_pid;
	__kernel_pid_t parent_tgid;
};

struct fid;

struct iomap;

struct iattr;

struct handle_to_path_ctx;

struct export_operations {
	int (*encode_fh)(struct inode *, __u32 *, int *, struct inode *);
	struct dentry * (*fh_to_dentry)(struct super_block *, struct fid *, int, int);
	struct dentry * (*fh_to_parent)(struct super_block *, struct fid *, int, int);
	int (*get_name)(struct dentry *, char *, struct dentry *);
	struct dentry * (*get_parent)(struct dentry *);
	int (*commit_metadata)(struct inode *);
	int (*get_uuid)(struct super_block *, u8 *, u32 *, u64 *);
	int (*map_blocks)(struct inode *, loff_t, u64, struct iomap *, bool, u32 *);
	int (*commit_blocks)(struct inode *, struct iomap *, int, struct iattr *);
	int (*permission)(struct handle_to_path_ctx *, unsigned int);
	struct file * (*open)(struct path *, unsigned int);
	long unsigned int flags;
};

struct ext4_free_extent {
	ext4_lblk_t fe_logical;
	ext4_grpblk_t fe_start;
	ext4_group_t fe_group;
	ext4_grpblk_t fe_len;
};

struct ext4_prealloc_space;

struct ext4_locality_group;

struct ext4_allocation_context {
	struct inode *ac_inode;
	struct super_block *ac_sb;
	struct ext4_free_extent ac_o_ex;
	struct ext4_free_extent ac_g_ex;
	struct ext4_free_extent ac_b_ex;
	struct ext4_free_extent ac_f_ex;
	ext4_grpblk_t ac_orig_goal_len;
	__u32 ac_flags;
	__u32 ac_groups_linear_remaining;
	__u16 ac_groups_scanned;
	__u16 ac_found;
	__u16 ac_cX_found[5];
	__u16 ac_tail;
	__u16 ac_buddy;
	__u8 ac_status;
	__u8 ac_criteria;
	__u8 ac_2order;
	__u8 ac_op;
	struct folio *ac_bitmap_folio;
	struct folio *ac_buddy_folio;
	struct ext4_prealloc_space *ac_pa;
	struct ext4_locality_group *ac_lg;
};

struct ext4_allocation_request {
	struct inode *inode;
	unsigned int len;
	ext4_lblk_t logical;
	ext4_lblk_t lleft;
	ext4_lblk_t lright;
	ext4_fsblk_t goal;
	ext4_fsblk_t pleft;
	ext4_fsblk_t pright;
	unsigned int flags;
};

struct ext4_attr {
	struct attribute attr;
	short int attr_id;
	short int attr_ptr;
	short unsigned int attr_size;
	union {
		int offset;
		void *explicit_ptr;
	} u;
};

struct ext4_group_info;

struct ext4_buddy {
	struct folio *bd_buddy_folio;
	void *bd_buddy;
	struct folio *bd_bitmap_folio;
	void *bd_bitmap;
	struct ext4_group_info *bd_info;
	struct super_block *bd_sb;
	__u16 bd_blkbits;
	ext4_group_t bd_group;
};

struct ext4_dir_entry {
	__le32 inode;
	__le16 rec_len;
	__le16 name_len;
	char name[255];
};

struct ext4_dir_entry_2 {
	__le32 inode;
	__le16 rec_len;
	__u8 name_len;
	__u8 file_type;
	char name[255];
};

struct ext4_dir_entry_hash {
	__le32 hash;
	__le32 minor_hash;
};

struct ext4_dir_entry_tail {
	__le32 det_reserved_zero1;
	__le16 det_rec_len;
	__u8 det_reserved_zero2;
	__u8 det_reserved_ft;
	__le32 det_checksum;
};

struct ext4_err_translation {
	int code;
	int errno;
};

struct ext4_es_stats {
	long unsigned int es_stats_shrunk;
	struct percpu_counter es_stats_cache_hits;
	struct percpu_counter es_stats_cache_misses;
	u64 es_stats_scan_time;
	u64 es_stats_max_scan_time;
	struct percpu_counter es_stats_all_cnt;
	struct percpu_counter es_stats_shk_cnt;
};

struct extent_status;

struct ext4_es_tree {
	struct rb_root root;
	struct extent_status *cache_es;
};

struct ext4_extent;

struct ext4_extent_idx;

struct ext4_extent_header;

struct ext4_ext_path {
	ext4_fsblk_t p_block;
	__u16 p_depth;
	__u16 p_maxdepth;
	struct ext4_extent *p_ext;
	struct ext4_extent_idx *p_idx;
	struct ext4_extent_header *p_hdr;
	struct buffer_head *p_bh;
};

struct ext4_extent {
	__le32 ee_block;
	__le16 ee_len;
	__le16 ee_start_hi;
	__le32 ee_start_lo;
};

struct ext4_extent_header {
	__le16 eh_magic;
	__le16 eh_entries;
	__le16 eh_max;
	__le16 eh_depth;
	__le32 eh_generation;
};

struct ext4_extent_idx {
	__le32 ei_block;
	__le32 ei_leaf_lo;
	__le16 ei_leaf_hi;
	__u16 ei_unused;
};

struct ext4_extent_tail {
	__le32 et_checksum;
};

struct ext4_fc_add_range {
	__le32 fc_ino;
	__u8 fc_ex[12];
};

struct ext4_fc_alloc_region {
	ext4_lblk_t lblk;
	ext4_fsblk_t pblk;
	int ino;
	int len;
};

struct ext4_fc_del_range {
	__le32 fc_ino;
	__le32 fc_lblk;
	__le32 fc_len;
};

struct ext4_fc_dentry_info {
	__le32 fc_parent_ino;
	__le32 fc_ino;
	__u8 fc_dname[0];
};

struct name_snapshot {
	struct qstr name;
	union shortname_store inline_name;
};

struct ext4_fc_dentry_update {
	int fcd_op;
	int fcd_parent;
	int fcd_ino;
	struct name_snapshot fcd_name;
	struct list_head fcd_list;
	struct list_head fcd_dilist;
};

struct ext4_fc_head {
	__le32 fc_features;
	__le32 fc_tid;
};

struct ext4_fc_inode {
	__le32 fc_ino;
	__u8 fc_raw_inode[0];
};

struct ext4_fc_replay_state {
	int fc_replay_num_tags;
	int fc_replay_expected_off;
	int fc_current_pass;
	int fc_cur_tag;
	int fc_crc;
	struct ext4_fc_alloc_region *fc_regions;
	int fc_regions_size;
	int fc_regions_used;
	int fc_regions_valid;
	int *fc_modified_inodes;
	int fc_modified_inodes_used;
	int fc_modified_inodes_size;
};

struct ext4_fc_stats {
	unsigned int fc_ineligible_reason_count[10];
	long unsigned int fc_num_commits;
	long unsigned int fc_ineligible_commits;
	long unsigned int fc_failed_commits;
	long unsigned int fc_skipped_commits;
	long unsigned int fc_numblks;
	u64 s_fc_avg_commit_time;
};

struct ext4_fc_tail {
	__le32 fc_tid;
	__le32 fc_crc;
};

struct ext4_fc_tl {
	__le16 fc_tag;
	__le16 fc_len;
};

struct ext4_fc_tl_mem {
	u16 fc_tag;
	u16 fc_len;
};

struct fscrypt_str {
	unsigned char *name;
	u32 len;
};

struct ext4_filename {
	const struct qstr *usr_fname;
	struct fscrypt_str disk_name;
	struct dx_hash_info hinfo;
};

struct ext4_free_data {
	struct list_head efd_list;
	struct rb_node efd_node;
	ext4_group_t efd_group;
	ext4_grpblk_t efd_start_cluster;
	ext4_grpblk_t efd_count;
	tid_t efd_tid;
};

struct fscrypt_dummy_policy {};

struct ext4_fs_context {
	char *s_qf_names[3];
	struct fscrypt_dummy_policy dummy_enc_policy;
	int s_jquota_fmt;
	short unsigned int qname_spec;
	long unsigned int vals_s_flags;
	long unsigned int mask_s_flags;
	long unsigned int journal_devnum;
	long unsigned int s_commit_interval;
	long unsigned int s_stripe;
	unsigned int s_inode_readahead_blks;
	unsigned int s_want_extra_isize;
	unsigned int s_li_wait_mult;
	unsigned int s_max_dir_size_kb;
	unsigned int journal_ioprio;
	unsigned int vals_s_mount_opt;
	unsigned int mask_s_mount_opt;
	unsigned int vals_s_mount_opt2;
	unsigned int mask_s_mount_opt2;
	unsigned int opt_flags;
	unsigned int spec;
	u32 s_max_batch_time;
	u32 s_min_batch_time;
	kuid_t s_resuid;
	kgid_t s_resgid;
	ext4_fsblk_t s_sb_block;
};

struct ext4_fsmap {
	struct list_head fmr_list;
	dev_t fmr_device;
	uint32_t fmr_flags;
	uint64_t fmr_physical;
	uint64_t fmr_owner;
	uint64_t fmr_length;
};

struct ext4_fsmap_head {
	uint32_t fmh_iflags;
	uint32_t fmh_oflags;
	unsigned int fmh_count;
	unsigned int fmh_entries;
	struct ext4_fsmap fmh_keys[2];
};

struct ext4_getfsmap_info;

struct ext4_getfsmap_dev {
	int (*gfd_fn)(struct super_block *, struct ext4_fsmap *, struct ext4_getfsmap_info *);
	u32 gfd_dev;
};

typedef int (*ext4_fsmap_format_t)(struct ext4_fsmap *, void *);

struct ext4_getfsmap_info {
	struct ext4_fsmap_head *gfi_head;
	ext4_fsmap_format_t gfi_formatter;
	void *gfi_format_arg;
	ext4_fsblk_t gfi_next_fsblk;
	u32 gfi_dev;
	ext4_group_t gfi_agno;
	struct ext4_fsmap gfi_low;
	struct ext4_fsmap gfi_high;
	struct ext4_fsmap gfi_lastfree;
	struct list_head gfi_meta_list;
	bool gfi_last;
};

struct ext4_group_desc {
	__le32 bg_block_bitmap_lo;
	__le32 bg_inode_bitmap_lo;
	__le32 bg_inode_table_lo;
	__le16 bg_free_blocks_count_lo;
	__le16 bg_free_inodes_count_lo;
	__le16 bg_used_dirs_count_lo;
	__le16 bg_flags;
	__le32 bg_exclude_bitmap_lo;
	__le16 bg_block_bitmap_csum_lo;
	__le16 bg_inode_bitmap_csum_lo;
	__le16 bg_itable_unused_lo;
	__le16 bg_checksum;
	__le32 bg_block_bitmap_hi;
	__le32 bg_inode_bitmap_hi;
	__le32 bg_inode_table_hi;
	__le16 bg_free_blocks_count_hi;
	__le16 bg_free_inodes_count_hi;
	__le16 bg_used_dirs_count_hi;
	__le16 bg_itable_unused_hi;
	__le32 bg_exclude_bitmap_hi;
	__le16 bg_block_bitmap_csum_hi;
	__le16 bg_inode_bitmap_csum_hi;
	__u32 bg_reserved;
};

struct ext4_group_info {
	long unsigned int bb_state;
	struct rb_root bb_free_root;
	ext4_grpblk_t bb_first_free;
	ext4_grpblk_t bb_free;
	ext4_grpblk_t bb_fragments;
	int bb_avg_fragment_size_order;
	ext4_grpblk_t bb_largest_free_order;
	ext4_group_t bb_group;
	struct list_head bb_prealloc_list;
	struct rw_semaphore alloc_sem;
	struct list_head bb_avg_fragment_size_node;
	struct list_head bb_largest_free_order_node;
	ext4_grpblk_t bb_counters[0];
};

struct ext4_iloc {
	struct buffer_head *bh;
	long unsigned int offset;
	ext4_group_t block_group;
};

struct ext4_inode {
	__le16 i_mode;
	__le16 i_uid;
	__le32 i_size_lo;
	__le32 i_atime;
	__le32 i_ctime;
	__le32 i_mtime;
	__le32 i_dtime;
	__le16 i_gid;
	__le16 i_links_count;
	__le32 i_blocks_lo;
	__le32 i_flags;
	union {
		struct {
			__le32 l_i_version;
		} linux1;
		struct {
			__u32 h_i_translator;
		} hurd1;
		struct {
			__u32 m_i_reserved1;
		} masix1;
	} osd1;
	__le32 i_block[15];
	__le32 i_generation;
	__le32 i_file_acl_lo;
	__le32 i_size_high;
	__le32 i_obso_faddr;
	union {
		struct {
			__le16 l_i_blocks_high;
			__le16 l_i_file_acl_high;
			__le16 l_i_uid_high;
			__le16 l_i_gid_high;
			__le16 l_i_checksum_lo;
			__le16 l_i_reserved;
		} linux2;
		struct {
			__le16 h_i_reserved1;
			__u16 h_i_mode_high;
			__u16 h_i_uid_high;
			__u16 h_i_gid_high;
			__u32 h_i_author;
		} hurd2;
		struct {
			__le16 h_i_reserved1;
			__le16 m_i_file_acl_high;
			__u32 m_i_reserved2[2];
		} masix2;
	} osd2;
	__le16 i_extra_isize;
	__le16 i_checksum_hi;
	__le32 i_ctime_extra;
	__le32 i_mtime_extra;
	__le32 i_atime_extra;
	__le32 i_crtime;
	__le32 i_crtime_extra;
	__le32 i_version_hi;
	__le32 i_projid;
};

struct ext4_pending_tree {
	struct rb_root root;
};

struct jbd2_inode;

struct ext4_inode_info {
	__le32 i_data[15];
	__u32 i_dtime;
	ext4_fsblk_t i_file_acl;
	ext4_group_t i_block_group;
	ext4_lblk_t i_dir_start_lookup;
	long unsigned int i_flags;
	struct rw_semaphore xattr_sem;
	union {
		struct list_head i_orphan;
		unsigned int i_orphan_idx;
	};
	struct list_head i_fc_dilist;
	struct list_head i_fc_list;
	ext4_lblk_t i_fc_lblk_start;
	ext4_lblk_t i_fc_lblk_len;
	atomic_t i_fc_updates;
	atomic_t i_unwritten;
	wait_queue_head_t i_fc_wait;
	struct mutex i_fc_lock;
	loff_t i_disksize;
	struct rw_semaphore i_data_sem;
	struct inode vfs_inode;
	struct jbd2_inode *jinode;
	spinlock_t i_raw_lock;
	struct timespec64 i_crtime;
	atomic_t i_prealloc_active;
	unsigned int i_reserved_data_blocks;
	struct rb_root i_prealloc_node;
	rwlock_t i_prealloc_lock;
	struct ext4_es_tree i_es_tree;
	rwlock_t i_es_lock;
	struct list_head i_es_list;
	unsigned int i_es_all_nr;
	unsigned int i_es_shk_nr;
	ext4_lblk_t i_es_shrink_lblk;
	ext4_group_t i_last_alloc_group;
	struct ext4_pending_tree i_pending_tree;
	__u16 i_extra_isize;
	u16 i_inline_off;
	u16 i_inline_size;
	qsize_t i_reserved_quota;
	spinlock_t i_completed_io_lock;
	struct list_head i_rsv_conversion_list;
	struct work_struct i_rsv_conversion_work;
	spinlock_t i_block_reservation_lock;
	tid_t i_sync_tid;
	tid_t i_datasync_tid;
	struct dquot *i_dquot[3];
	__u32 i_csum_seed;
	kprojid_t i_projid;
};

struct jbd2_journal_handle;

typedef struct jbd2_journal_handle handle_t;

struct ext4_io_end {
	struct list_head list;
	handle_t *handle;
	struct inode *inode;
	struct bio *bio;
	unsigned int flag;
	refcount_t count;
	struct list_head list_vec;
};

typedef struct ext4_io_end ext4_io_end_t;

struct ext4_io_end_vec {
	struct list_head list;
	loff_t offset;
	ssize_t size;
};

struct ext4_io_submit {
	struct writeback_control *io_wbc;
	struct bio *io_bio;
	ext4_io_end_t *io_end;
	sector_t io_next_block;
};

struct ext4_journal_cb_entry {
	struct list_head jce_list;
	void (*jce_func)(struct super_block *, struct ext4_journal_cb_entry *, int);
};

struct jbd2_buffer_trigger_type {
	void (*t_frozen)(struct jbd2_buffer_trigger_type *, struct buffer_head *, void *, size_t);
	void (*t_abort)(struct jbd2_buffer_trigger_type *, struct buffer_head *);
};

struct ext4_journal_trigger {
	struct jbd2_buffer_trigger_type tr_triggers;
	struct super_block *sb;
};

struct ext4_lazy_init {
	long unsigned int li_state;
	struct list_head li_request_list;
	struct mutex li_list_mtx;
};

struct ext4_li_request {
	struct super_block *lr_super;
	enum ext4_li_mode lr_mode;
	ext4_group_t lr_first_not_zeroed;
	ext4_group_t lr_next_group;
	struct list_head lr_request;
	long unsigned int lr_next_sched;
	long unsigned int lr_timeout;
};

struct ext4_locality_group {
	struct mutex lg_mutex;
	struct list_head lg_prealloc_list[10];
	spinlock_t lg_prealloc_lock;
};

struct ext4_map_blocks {
	ext4_fsblk_t m_pblk;
	ext4_lblk_t m_lblk;
	unsigned int m_len;
	unsigned int m_flags;
};

struct ext4_mount_options {
	long unsigned int s_mount_opt;
	long unsigned int s_mount_opt2;
	kuid_t s_resuid;
	kgid_t s_resgid;
	long unsigned int s_commit_interval;
	u32 s_min_batch_time;
	u32 s_max_batch_time;
	int s_jquota_fmt;
	char *s_qf_names[3];
};

struct ext4_new_group_data;

struct ext4_new_flex_group_data {
	struct ext4_new_group_data *groups;
	__u16 *bg_flags;
	ext4_group_t resize_bg;
	ext4_group_t count;
};

struct ext4_new_group_data {
	__u32 group;
	__u64 block_bitmap;
	__u64 inode_bitmap;
	__u64 inode_table;
	__u32 blocks_count;
	__u16 reserved_blocks;
	__u16 mdata_blocks;
	__u32 free_clusters_count;
};

struct ext4_new_group_input {
	__u32 group;
	__u64 block_bitmap;
	__u64 inode_bitmap;
	__u64 inode_table;
	__u32 blocks_count;
	__u16 reserved_blocks;
	__u16 unused;
};

struct ext4_orphan_block {
	atomic_t ob_free_entries;
	struct buffer_head *ob_bh;
};

struct ext4_orphan_block_tail {
	__le32 ob_magic;
	__le32 ob_checksum;
};

struct ext4_orphan_info {
	int of_blocks;
	__u32 of_csum_seed;
	struct ext4_orphan_block *of_binfo;
};

struct ext4_prealloc_space {
	union {
		struct rb_node inode_node;
		struct list_head lg_list;
	} pa_node;
	struct list_head pa_group_list;
	union {
		struct list_head pa_tmp_list;
		struct callback_head pa_rcu;
	} u;
	spinlock_t pa_lock;
	atomic_t pa_count;
	unsigned int pa_deleted;
	ext4_fsblk_t pa_pstart;
	ext4_lblk_t pa_lstart;
	ext4_grpblk_t pa_len;
	ext4_grpblk_t pa_free;
	short unsigned int pa_type;
	union {
		rwlock_t *inode_lock;
		spinlock_t *lg_lock;
	} pa_node_lock;
	struct inode *pa_inode;
};

struct ext4_rcu_ptr {
	struct callback_head rcu;
	void *ptr;
};

struct ext4_renament {
	struct inode *dir;
	struct dentry *dentry;
	struct inode *inode;
	bool is_dir;
	int dir_nlink_delta;
	struct buffer_head *bh;
	struct ext4_dir_entry_2 *de;
	int inlined;
	struct buffer_head *dir_bh;
	struct ext4_dir_entry_2 *parent_de;
	int dir_inlined;
};

struct rcu_sync {
	int gp_state;
	int gp_count;
	wait_queue_head_t gp_wait;
	struct callback_head cb_head;
};

struct percpu_rw_semaphore {
	struct rcu_sync rss;
	unsigned int *read_count;
	struct rcuwait writer;
	wait_queue_head_t waiters;
	atomic_t block;
};

struct ext4_super_block;

struct journal_s;

struct ext4_system_blocks;

struct flex_groups;

struct mb_cache;

struct ext4_sb_info {
	long unsigned int s_desc_size;
	long unsigned int s_inodes_per_block;
	long unsigned int s_blocks_per_group;
	long unsigned int s_clusters_per_group;
	long unsigned int s_inodes_per_group;
	long unsigned int s_itb_per_group;
	long unsigned int s_gdb_count;
	long unsigned int s_desc_per_block;
	ext4_group_t s_groups_count;
	ext4_group_t s_blockfile_groups;
	long unsigned int s_overhead;
	unsigned int s_cluster_ratio;
	unsigned int s_cluster_bits;
	loff_t s_bitmap_maxbytes;
	struct buffer_head *s_sbh;
	struct ext4_super_block *s_es;
	struct buffer_head **s_group_desc;
	unsigned int s_mount_opt;
	unsigned int s_mount_opt2;
	long unsigned int s_mount_flags;
	unsigned int s_def_mount_opt;
	unsigned int s_def_mount_opt2;
	ext4_fsblk_t s_sb_block;
	atomic64_t s_resv_clusters;
	kuid_t s_resuid;
	kgid_t s_resgid;
	short unsigned int s_mount_state;
	short unsigned int s_pad;
	int s_addr_per_block_bits;
	int s_desc_per_block_bits;
	int s_inode_size;
	int s_first_ino;
	unsigned int s_inode_readahead_blks;
	unsigned int s_inode_goal;
	u32 s_hash_seed[4];
	int s_def_hash_version;
	int s_hash_unsigned;
	struct percpu_counter s_freeclusters_counter;
	struct percpu_counter s_freeinodes_counter;
	struct percpu_counter s_dirs_counter;
	struct percpu_counter s_dirtyclusters_counter;
	struct percpu_counter s_sra_exceeded_retry_limit;
	struct blockgroup_lock *s_blockgroup_lock;
	struct proc_dir_entry *s_proc;
	struct kobject s_kobj;
	struct completion s_kobj_unregister;
	struct super_block *s_sb;
	struct buffer_head *s_mmp_bh;
	struct journal_s *s_journal;
	long unsigned int s_ext4_flags;
	struct mutex s_orphan_lock;
	struct list_head s_orphan;
	struct ext4_orphan_info s_orphan_info;
	long unsigned int s_commit_interval;
	u32 s_max_batch_time;
	u32 s_min_batch_time;
	struct file *s_journal_bdev_file;
	char *s_qf_names[3];
	int s_jquota_fmt;
	unsigned int s_want_extra_isize;
	struct ext4_system_blocks *s_system_blks;
	struct ext4_group_info ***s_group_info;
	struct inode *s_buddy_cache;
	spinlock_t s_md_lock;
	short unsigned int *s_mb_offsets;
	unsigned int *s_mb_maxs;
	unsigned int s_group_info_size;
	unsigned int s_mb_free_pending;
	struct list_head s_freed_data_list[2];
	struct list_head s_discard_list;
	struct work_struct s_discard_work;
	atomic_t s_retry_alloc_pending;
	struct list_head *s_mb_avg_fragment_size;
	rwlock_t *s_mb_avg_fragment_size_locks;
	struct list_head *s_mb_largest_free_orders;
	rwlock_t *s_mb_largest_free_orders_locks;
	long unsigned int s_stripe;
	unsigned int s_mb_max_linear_groups;
	unsigned int s_mb_stream_request;
	unsigned int s_mb_max_to_scan;
	unsigned int s_mb_min_to_scan;
	unsigned int s_mb_stats;
	unsigned int s_mb_order2_reqs;
	unsigned int s_mb_group_prealloc;
	unsigned int s_max_dir_size_kb;
	long unsigned int s_mb_last_group;
	long unsigned int s_mb_last_start;
	unsigned int s_mb_prefetch;
	unsigned int s_mb_prefetch_limit;
	unsigned int s_mb_best_avail_max_trim_order;
	atomic_t s_bal_reqs;
	atomic_t s_bal_success;
	atomic_t s_bal_allocated;
	atomic_t s_bal_ex_scanned;
	atomic_t s_bal_cX_ex_scanned[5];
	atomic_t s_bal_groups_scanned;
	atomic_t s_bal_goals;
	atomic_t s_bal_len_goals;
	atomic_t s_bal_breaks;
	atomic_t s_bal_2orders;
	atomic_t s_bal_p2_aligned_bad_suggestions;
	atomic_t s_bal_goal_fast_bad_suggestions;
	atomic_t s_bal_best_avail_bad_suggestions;
	atomic64_t s_bal_cX_groups_considered[5];
	atomic64_t s_bal_cX_hits[5];
	atomic64_t s_bal_cX_failed[5];
	atomic_t s_mb_buddies_generated;
	atomic64_t s_mb_generation_time;
	atomic_t s_mb_lost_chunks;
	atomic_t s_mb_preallocated;
	atomic_t s_mb_discarded;
	atomic_t s_lock_busy;
	struct ext4_locality_group *s_locality_groups;
	long unsigned int s_sectors_written_start;
	u64 s_kbytes_written;
	unsigned int s_extent_max_zeroout_kb;
	unsigned int s_log_groups_per_flex;
	struct flex_groups **s_flex_groups;
	ext4_group_t s_flex_groups_allocated;
	struct workqueue_struct *rsv_conversion_wq;
	struct timer_list s_err_report;
	struct ext4_li_request *s_li_request;
	unsigned int s_li_wait_mult;
	struct task_struct *s_mmp_tsk;
	long unsigned int s_last_trim_minblks;
	__u32 s_csum_seed;
	struct shrinker *s_es_shrinker;
	struct list_head s_es_list;
	long int s_es_nr_inode;
	struct ext4_es_stats s_es_stats;
	struct mb_cache *s_ea_block_cache;
	struct mb_cache *s_ea_inode_cache;
	long: 64;
	long: 64;
	spinlock_t s_es_lock;
	struct ext4_journal_trigger s_journal_triggers[1];
	struct ratelimit_state s_err_ratelimit_state;
	struct ratelimit_state s_warning_ratelimit_state;
	struct ratelimit_state s_msg_ratelimit_state;
	atomic_t s_warning_count;
	atomic_t s_msg_count;
	struct fscrypt_dummy_policy s_dummy_enc_policy;
	struct percpu_rw_semaphore s_writepages_rwsem;
	struct dax_device *s_daxdev;
	u64 s_dax_part_off;
	errseq_t s_bdev_wb_err;
	spinlock_t s_bdev_wb_lock;
	spinlock_t s_error_lock;
	int s_add_error_count;
	int s_first_error_code;
	__u32 s_first_error_line;
	__u32 s_first_error_ino;
	__u64 s_first_error_block;
	const char *s_first_error_func;
	time64_t s_first_error_time;
	int s_last_error_code;
	__u32 s_last_error_line;
	__u32 s_last_error_ino;
	__u64 s_last_error_block;
	const char *s_last_error_func;
	time64_t s_last_error_time;
	struct work_struct s_sb_upd_work;
	unsigned int s_awu_min;
	unsigned int s_awu_max;
	atomic_t s_fc_subtid;
	struct list_head s_fc_q[2];
	struct list_head s_fc_dentry_q[2];
	unsigned int s_fc_bytes;
	spinlock_t s_fc_lock;
	struct buffer_head *s_fc_bh;
	struct ext4_fc_stats s_fc_stats;
	tid_t s_fc_ineligible_tid;
	struct ext4_fc_replay_state s_fc_replay_state;
	long: 64;
};

struct ext4_super_block {
	__le32 s_inodes_count;
	__le32 s_blocks_count_lo;
	__le32 s_r_blocks_count_lo;
	__le32 s_free_blocks_count_lo;
	__le32 s_free_inodes_count;
	__le32 s_first_data_block;
	__le32 s_log_block_size;
	__le32 s_log_cluster_size;
	__le32 s_blocks_per_group;
	__le32 s_clusters_per_group;
	__le32 s_inodes_per_group;
	__le32 s_mtime;
	__le32 s_wtime;
	__le16 s_mnt_count;
	__le16 s_max_mnt_count;
	__le16 s_magic;
	__le16 s_state;
	__le16 s_errors;
	__le16 s_minor_rev_level;
	__le32 s_lastcheck;
	__le32 s_checkinterval;
	__le32 s_creator_os;
	__le32 s_rev_level;
	__le16 s_def_resuid;
	__le16 s_def_resgid;
	__le32 s_first_ino;
	__le16 s_inode_size;
	__le16 s_block_group_nr;
	__le32 s_feature_compat;
	__le32 s_feature_incompat;
	__le32 s_feature_ro_compat;
	__u8 s_uuid[16];
	char s_volume_name[16];
	char s_last_mounted[64];
	__le32 s_algorithm_usage_bitmap;
	__u8 s_prealloc_blocks;
	__u8 s_prealloc_dir_blocks;
	__le16 s_reserved_gdt_blocks;
	__u8 s_journal_uuid[16];
	__le32 s_journal_inum;
	__le32 s_journal_dev;
	__le32 s_last_orphan;
	__le32 s_hash_seed[4];
	__u8 s_def_hash_version;
	__u8 s_jnl_backup_type;
	__le16 s_desc_size;
	__le32 s_default_mount_opts;
	__le32 s_first_meta_bg;
	__le32 s_mkfs_time;
	__le32 s_jnl_blocks[17];
	__le32 s_blocks_count_hi;
	__le32 s_r_blocks_count_hi;
	__le32 s_free_blocks_count_hi;
	__le16 s_min_extra_isize;
	__le16 s_want_extra_isize;
	__le32 s_flags;
	__le16 s_raid_stride;
	__le16 s_mmp_update_interval;
	__le64 s_mmp_block;
	__le32 s_raid_stripe_width;
	__u8 s_log_groups_per_flex;
	__u8 s_checksum_type;
	__u8 s_encryption_level;
	__u8 s_reserved_pad;
	__le64 s_kbytes_written;
	__le32 s_snapshot_inum;
	__le32 s_snapshot_id;
	__le64 s_snapshot_r_blocks_count;
	__le32 s_snapshot_list;
	__le32 s_error_count;
	__le32 s_first_error_time;
	__le32 s_first_error_ino;
	__le64 s_first_error_block;
	__u8 s_first_error_func[32];
	__le32 s_first_error_line;
	__le32 s_last_error_time;
	__le32 s_last_error_ino;
	__le32 s_last_error_line;
	__le64 s_last_error_block;
	__u8 s_last_error_func[32];
	__u8 s_mount_opts[64];
	__le32 s_usr_quota_inum;
	__le32 s_grp_quota_inum;
	__le32 s_overhead_clusters;
	__le32 s_backup_bgs[2];
	__u8 s_encrypt_algos[4];
	__u8 s_encrypt_pw_salt[16];
	__le32 s_lpf_ino;
	__le32 s_prj_quota_inum;
	__le32 s_checksum_seed;
	__u8 s_wtime_hi;
	__u8 s_mtime_hi;
	__u8 s_mkfs_time_hi;
	__u8 s_lastcheck_hi;
	__u8 s_first_error_time_hi;
	__u8 s_last_error_time_hi;
	__u8 s_first_error_errcode;
	__u8 s_last_error_errcode;
	__le16 s_encoding;
	__le16 s_encoding_flags;
	__le32 s_orphan_file_inum;
	__le32 s_reserved[94];
	__le32 s_checksum;
};

struct ext4_system_blocks {
	struct rb_root root;
	struct callback_head rcu;
};

struct ext4_system_zone {
	struct rb_node node;
	ext4_fsblk_t start_blk;
	unsigned int count;
	u32 ino;
};

struct ext4_xattr_entry;

struct ext4_xattr_search {
	struct ext4_xattr_entry *first;
	void *base;
	void *end;
	struct ext4_xattr_entry *here;
	int not_found;
};

struct ext4_xattr_block_find {
	struct ext4_xattr_search s;
	struct buffer_head *bh;
};

struct ext4_xattr_entry {
	__u8 e_name_len;
	__u8 e_name_index;
	__le16 e_value_offs;
	__le32 e_value_inum;
	__le32 e_value_size;
	__le32 e_hash;
	char e_name[0];
};

struct ext4_xattr_header {
	__le32 h_magic;
	__le32 h_refcount;
	__le32 h_blocks;
	__le32 h_hash;
	__le32 h_checksum;
	__u32 h_reserved[3];
};

struct ext4_xattr_ibody_find {
	struct ext4_xattr_search s;
	struct ext4_iloc iloc;
};

struct ext4_xattr_ibody_header {
	__le32 h_magic;
};

struct ext4_xattr_info {
	const char *name;
	const void *value;
	size_t value_len;
	int name_index;
	int in_inode;
};

struct ext4_xattr_inode_array {
	unsigned int count;
	struct inode *inodes[0];
};

struct ext_arg {
	size_t argsz;
	struct timespec64 ts;
	const sigset_t *sig;
	ktime_t min_time;
	bool ts_set;
};

struct msg_msg;

struct ext_wait_queue {
	struct task_struct *task;
	struct list_head list;
	struct msg_msg *msg;
	int state;
};

struct extended_signature {
	unsigned int sig;
	unsigned int pf;
	unsigned int cksum;
};

struct extended_sigtable {
	unsigned int count;
	unsigned int cksum;
	unsigned int reserved[3];
	struct extended_signature sigs[0];
};

struct extent_status {
	struct rb_node rb_node;
	ext4_lblk_t es_lblk;
	ext4_lblk_t es_len;
	ext4_fsblk_t es_pblk;
};

struct external_name {
	atomic_t count;
	struct callback_head head;
	unsigned char name[0];
};

struct extra_reg {
	unsigned int event;
	unsigned int msr;
	u64 config_mask;
	u64 valid_mask;
	int idx;
	bool extra_msr_access;
};

struct f815xxa_data {
	spinlock_t lock;
	int idx;
};

struct f_owner_ex {
	int type;
	__kernel_pid_t pid;
};

struct failover_ops;

struct failover {
	struct list_head list;
	struct net_device *failover_dev;
	netdevice_tracker dev_tracker;
	struct failover_ops *ops;
};

struct failover_ops {
	int (*slave_pre_register)(struct net_device *, struct net_device *);
	int (*slave_register)(struct net_device *, struct net_device *);
	int (*slave_pre_unregister)(struct net_device *, struct net_device *);
	int (*slave_unregister)(struct net_device *, struct net_device *);
	int (*slave_link_change)(struct net_device *, struct net_device *);
	int (*slave_name_change)(struct net_device *, struct net_device *);
	rx_handler_result_t (*slave_handle_frame)(struct sk_buff **);
};

struct fanotify_response_info_header {
	__u8 type;
	__u8 pad;
	__u16 len;
};

struct fanotify_response_info_audit_rule {
	struct fanotify_response_info_header hdr;
	__u32 rule_number;
	__u32 subj_trust;
	__u32 obj_trust;
};

struct fanout_args {
	__u16 id;
	__u16 type_flags;
	__u32 max_num_members;
};

struct fast_pool {
	long unsigned int pool[4];
	long unsigned int last;
	unsigned int count;
	struct timer_list mix;
};

struct request_sock;

struct tcp_fastopen_context;

struct fastopen_queue {
	struct request_sock *rskq_rst_head;
	struct request_sock *rskq_rst_tail;
	spinlock_t lock;
	int qlen;
	int max_qlen;
	struct tcp_fastopen_context *ctx;
};

struct fasync_struct {
	rwlock_t fa_lock;
	int magic;
	int fa_fd;
	struct fasync_struct *fa_next;
	struct file *fa_file;
	struct callback_head fa_rcu;
};

struct fat_bios_param_block {
	u16 fat_sector_size;
	u8 fat_sec_per_clus;
	u16 fat_reserved;
	u8 fat_fats;
	u16 fat_dir_entries;
	u16 fat_sectors;
	u16 fat_fat_length;
	u32 fat_total_sect;
	u8 fat16_state;
	u32 fat16_vol_id;
	u32 fat32_length;
	u32 fat32_root_cluster;
	u16 fat32_info_sector;
	u8 fat32_state;
	u32 fat32_vol_id;
};

struct fat_boot_fsinfo {
	__le32 signature1;
	__le32 reserved1[120];
	__le32 signature2;
	__le32 free_clusters;
	__le32 next_cluster;
	__le32 reserved2[4];
};

struct fat_boot_sector {
	__u8 ignored[3];
	__u8 system_id[8];
	__u8 sector_size[2];
	__u8 sec_per_clus;
	__le16 reserved;
	__u8 fats;
	__u8 dir_entries[2];
	__u8 sectors[2];
	__u8 media;
	__le16 fat_length;
	__le16 secs_track;
	__le16 heads;
	__le32 hidden;
	__le32 total_sect;
	union {
		struct {
			__u8 drive_number;
			__u8 state;
			__u8 signature;
			__u8 vol_id[4];
			__u8 vol_label[11];
			__u8 fs_type[8];
		} fat16;
		struct {
			__le32 length;
			__le16 flags;
			__u8 version[2];
			__le32 root_cluster;
			__le16 info_sector;
			__le16 backup_boot;
			__le16 reserved2[6];
			__u8 drive_number;
			__u8 state;
			__u8 signature;
			__u8 vol_id[4];
			__u8 vol_label[11];
			__u8 fs_type[8];
		} fat32;
	};
};

struct fat_cache {
	struct list_head cache_list;
	int nr_contig;
	int fcluster;
	int dcluster;
};

struct fat_cache_id {
	unsigned int id;
	int nr_contig;
	int fcluster;
	int dcluster;
};

struct fat_entry {
	int entry;
	union {
		u8 *ent12_p[2];
		__le16 *ent16_p;
		__le32 *ent32_p;
	} u;
	int nr_bhs;
	struct buffer_head *bhs[2];
	struct inode *fat_inode;
};

struct fat_fid {
	u32 i_gen;
	u32 i_pos_low;
	u16 i_pos_hi;
	u16 parent_i_pos_hi;
	u32 parent_i_pos_low;
	u32 parent_i_gen;
};

struct fat_floppy_defaults {
	unsigned int nr_sectors;
	unsigned int sec_per_clus;
	unsigned int dir_entries;
	unsigned int media;
	unsigned int fat_length;
};

struct fat_ioctl_filldir_callback {
	struct dir_context ctx;
	void *dirent;
	int result;
	const char *longname;
	int long_len;
	const char *shortname;
	int short_len;
};

struct fat_mount_options {
	kuid_t fs_uid;
	kgid_t fs_gid;
	short unsigned int fs_fmask;
	short unsigned int fs_dmask;
	short unsigned int codepage;
	int time_offset;
	char *iocharset;
	short unsigned int shortname;
	unsigned char name_check;
	unsigned char errors;
	unsigned char nfs;
	short unsigned int allow_utime;
	unsigned int quiet: 1;
	unsigned int showexec: 1;
	unsigned int sys_immutable: 1;
	unsigned int dotsOK: 1;
	unsigned int isvfat: 1;
	unsigned int utf8: 1;
	unsigned int unicode_xlate: 1;
	unsigned int numtail: 1;
	unsigned int flush: 1;
	unsigned int nocase: 1;
	unsigned int usefree: 1;
	unsigned int tz_set: 1;
	unsigned int rodir: 1;
	unsigned int discard: 1;
	unsigned int dos1xfloppy: 1;
	unsigned int debug: 1;
};

struct msdos_dir_entry;

struct fat_slot_info {
	loff_t i_pos;
	loff_t slot_off;
	int nr_slots;
	struct msdos_dir_entry *de;
	struct buffer_head *bh;
};

struct fatent_operations {
	void (*ent_blocknr)(struct super_block *, int, int *, sector_t *);
	void (*ent_set_ptr)(struct fat_entry *, int);
	int (*ent_bread)(struct super_block *, struct fat_entry *, int, sector_t);
	int (*ent_get)(struct fat_entry *);
	void (*ent_put)(struct fat_entry *, int);
	int (*ent_next)(struct fat_entry *);
};

struct fatent_ra {
	sector_t cur;
	sector_t limit;
	unsigned int ra_blocks;
	sector_t ra_advance;
	sector_t ra_next;
	sector_t ra_limit;
};

struct faux_device {
	struct device dev;
};

struct faux_device_ops {
	int (*probe)(struct faux_device *);
	void (*remove)(struct faux_device *);
};

struct faux_object {
	struct faux_device faux_dev;
	const struct faux_device_ops *faux_ops;
};

struct fb_plane_view_dims {
	unsigned int width;
	unsigned int height;
	unsigned int tile_width;
	unsigned int tile_height;
};

struct fc_log {
	refcount_t usage;
	u8 head;
	u8 tail;
	u8 need_free;
	struct module *owner;
	char *buffer[8];
};

struct fd {
	long unsigned int word;
};

typedef struct fd class_fd_pos_t;

typedef struct fd class_fd_raw_t;

typedef struct fd class_fd_t;

struct fd_data {
	fmode_t mode;
	unsigned int fd;
};

struct fd_range {
	unsigned int from;
	unsigned int to;
};

struct fdtable {
	unsigned int max_fds;
	struct file **fd;
	long unsigned int *close_on_exec;
	long unsigned int *open_fds;
	long unsigned int *full_fds_bits;
	struct callback_head rcu;
};

struct nv_ethtool_stats {
	u64 tx_bytes;
	u64 tx_zero_rexmt;
	u64 tx_one_rexmt;
	u64 tx_many_rexmt;
	u64 tx_late_collision;
	u64 tx_fifo_errors;
	u64 tx_carrier_errors;
	u64 tx_excess_deferral;
	u64 tx_retry_error;
	u64 rx_frame_error;
	u64 rx_extra_byte;
	u64 rx_late_collision;
	u64 rx_runt;
	u64 rx_frame_too_long;
	u64 rx_over_errors;
	u64 rx_crc_errors;
	u64 rx_frame_align_error;
	u64 rx_length_error;
	u64 rx_unicast;
	u64 rx_multicast;
	u64 rx_broadcast;
	u64 rx_packets;
	u64 rx_errors_total;
	u64 tx_errors_total;
	u64 tx_deferral;
	u64 tx_packets;
	u64 rx_bytes;
	u64 tx_pause;
	u64 rx_pause;
	u64 rx_drop_frame;
	u64 tx_unicast;
	u64 tx_multicast;
	u64 tx_broadcast;
};

struct ring_desc;

struct ring_desc_ex;

union ring_type {
	struct ring_desc *orig;
	struct ring_desc_ex *ex;
};

struct msix_entry {
	u32 vector;
	u16 entry;
};

struct nv_skb_map;

struct nv_txrx_stats;

struct fe_priv {
	spinlock_t lock;
	struct net_device *dev;
	struct napi_struct napi;
	spinlock_t hwstats_lock;
	struct nv_ethtool_stats estats;
	int in_shutdown;
	u32 linkspeed;
	int duplex;
	int autoneg;
	int fixed_mode;
	int phyaddr;
	int wolenabled;
	unsigned int phy_oui;
	unsigned int phy_model;
	unsigned int phy_rev;
	u16 gigabit;
	int intr_test;
	int recover_error;
	int quiet_count;
	dma_addr_t ring_addr;
	struct pci_dev *pci_dev;
	u32 orig_mac[2];
	u32 events;
	u32 irqmask;
	u32 desc_ver;
	u32 txrxctl_bits;
	u32 vlanctl_bits;
	u32 driver_data;
	u32 device_id;
	u32 register_size;
	u32 mac_in_use;
	int mgmt_version;
	int mgmt_sema;
	void *base;
	union ring_type get_rx;
	union ring_type put_rx;
	union ring_type last_rx;
	struct nv_skb_map *get_rx_ctx;
	struct nv_skb_map *put_rx_ctx;
	struct nv_skb_map *last_rx_ctx;
	struct nv_skb_map *rx_skb;
	union ring_type rx_ring;
	unsigned int rx_buf_sz;
	unsigned int pkt_limit;
	struct timer_list oom_kick;
	struct timer_list nic_poll;
	struct timer_list stats_poll;
	u32 nic_poll_irq;
	int rx_ring_size;
	struct u64_stats_sync swstats_rx_syncp;
	struct nv_txrx_stats *txrx_stats;
	int need_linktimer;
	long unsigned int link_timeout;
	union ring_type get_tx;
	union ring_type put_tx;
	union ring_type last_tx;
	struct nv_skb_map *get_tx_ctx;
	struct nv_skb_map *put_tx_ctx;
	struct nv_skb_map *last_tx_ctx;
	struct nv_skb_map *tx_skb;
	union ring_type tx_ring;
	u32 tx_flags;
	int tx_ring_size;
	int tx_limit;
	u32 tx_pkts_in_progress;
	struct nv_skb_map *tx_change_owner;
	struct nv_skb_map *tx_end_flip;
	int tx_stop;
	struct u64_stats_sync swstats_tx_syncp;
	u32 msi_flags;
	struct msix_entry msi_x_entry[8];
	u32 pause_flags;
	u32 saved_config_space[385];
	char name_rx[19];
	char name_tx[19];
	char name_other[22];
};

struct features_reply_data {
	struct ethnl_reply_data base;
	u32 hw[2];
	u32 wanted[2];
	u32 active[2];
	u32 nochange[2];
	u32 all[2];
};

struct fec_stat_grp {
	u64 stats[9];
	u8 cnt;
};

struct fec_reply_data {
	struct ethnl_reply_data base;
	long unsigned int fec_link_modes[2];
	u32 active_fec;
	u8 fec_auto;
	struct fec_stat_grp corr;
	struct fec_stat_grp uncorr;
	struct fec_stat_grp corr_bits;
};

struct fetch_insn {
	enum fetch_op op;
	union {
		unsigned int param;
		struct {
			unsigned int size;
			int offset;
		};
		struct {
			unsigned char basesize;
			unsigned char lshift;
			unsigned char rshift;
		};
		long unsigned int immediate;
		void *data;
	};
};

struct trace_seq;

typedef int (*print_type_func_t)(struct trace_seq *, void *, void *);

struct fetch_type {
	const char *name;
	size_t size;
	bool is_signed;
	bool is_string;
	print_type_func_t print;
	const char *fmt;
	const char *fmttype;
};

struct ff_condition_effect {
	__u16 right_saturation;
	__u16 left_saturation;
	__s16 right_coeff;
	__s16 left_coeff;
	__u16 deadband;
	__s16 center;
};

struct ff_envelope {
	__u16 attack_length;
	__u16 attack_level;
	__u16 fade_length;
	__u16 fade_level;
};

struct ff_constant_effect {
	__s16 level;
	struct ff_envelope envelope;
};

struct ff_effect;

struct ff_device {
	int (*upload)(struct input_dev *, struct ff_effect *, struct ff_effect *);
	int (*erase)(struct input_dev *, int);
	int (*playback)(struct input_dev *, int, int);
	void (*set_gain)(struct input_dev *, u16);
	void (*set_autocenter)(struct input_dev *, u16);
	void (*destroy)(struct ff_device *);
	void *private;
	long unsigned int ffbit[2];
	struct mutex mutex;
	int max_effects;
	struct ff_effect *effects;
	struct file *effect_owners[0];
};

struct ff_trigger {
	__u16 button;
	__u16 interval;
};

struct ff_replay {
	__u16 length;
	__u16 delay;
};

struct ff_ramp_effect {
	__s16 start_level;
	__s16 end_level;
	struct ff_envelope envelope;
};

struct ff_periodic_effect {
	__u16 waveform;
	__u16 period;
	__s16 magnitude;
	__s16 offset;
	__u16 phase;
	struct ff_envelope envelope;
	__u32 custom_len;
	__s16 *custom_data;
};

struct ff_rumble_effect {
	__u16 strong_magnitude;
	__u16 weak_magnitude;
};

struct ff_effect {
	__u16 type;
	__s16 id;
	__u16 direction;
	struct ff_trigger trigger;
	struct ff_replay replay;
	union {
		struct ff_constant_effect constant;
		struct ff_ramp_effect ramp;
		struct ff_periodic_effect periodic;
		struct ff_condition_effect condition[2];
		struct ff_rumble_effect rumble;
	} u;
};

struct ff_periodic_effect_compat {
	__u16 waveform;
	__u16 period;
	__s16 magnitude;
	__s16 offset;
	__u16 phase;
	struct ff_envelope envelope;
	__u32 custom_len;
	compat_uptr_t custom_data;
};

struct ff_effect_compat {
	__u16 type;
	__s16 id;
	__u16 direction;
	struct ff_trigger trigger;
	struct ff_replay replay;
	union {
		struct ff_constant_effect constant;
		struct ff_ramp_effect ramp;
		struct ff_periodic_effect_compat periodic;
		struct ff_condition_effect condition[2];
		struct ff_rumble_effect rumble;
	} u;
};

struct fib_kuid_range {
	kuid_t start;
	kuid_t end;
};

struct fib_rule_port_range {
	__u16 start;
	__u16 end;
};

struct fib_rule {
	struct list_head list;
	int iifindex;
	int oifindex;
	u32 mark;
	u32 mark_mask;
	u32 flags;
	u32 table;
	u8 action;
	u8 l3mdev;
	u8 proto;
	u8 ip_proto;
	u32 target;
	__be64 tun_id;
	struct fib_rule *ctarget;
	struct net *fr_net;
	refcount_t refcnt;
	u32 pref;
	int suppress_ifgroup;
	int suppress_prefixlen;
	char iifname[16];
	char oifname[16];
	struct fib_kuid_range uid_range;
	struct fib_rule_port_range sport_range;
	struct fib_rule_port_range dport_range;
	struct callback_head rcu;
};

struct fib4_rule {
	struct fib_rule common;
	u8 dst_len;
	u8 src_len;
	dscp_t dscp;
	u8 dscp_full: 1;
	__be32 src;
	__be32 srcmask;
	__be32 dst;
	__be32 dstmask;
};

struct fib6_node;

struct fib6_walker {
	struct list_head lh;
	struct fib6_node *root;
	struct fib6_node *node;
	struct fib6_info *leaf;
	enum fib6_walk_state state;
	unsigned int skip;
	unsigned int count;
	unsigned int skip_in_node;
	int (*func)(struct fib6_walker *);
	void *args;
};

struct fib6_cleaner {
	struct fib6_walker w;
	struct net *net;
	int (*func)(struct fib6_info *, void *);
	int sernum;
	void *arg;
	bool skip_notify;
};

struct nlmsghdr;

struct nl_info {
	struct nlmsghdr *nlh;
	struct net *nl_net;
	u32 portid;
	u8 skip_notify: 1;
	u8 skip_notify_kernel: 1;
};

struct fib6_config {
	u32 fc_table;
	u32 fc_metric;
	int fc_dst_len;
	int fc_src_len;
	int fc_ifindex;
	u32 fc_flags;
	u32 fc_protocol;
	u16 fc_type;
	u16 fc_delete_all_nh: 1;
	u16 fc_ignore_dev_down: 1;
	u16 __unused: 14;
	u32 fc_nh_id;
	struct in6_addr fc_dst;
	struct in6_addr fc_src;
	struct in6_addr fc_prefsrc;
	struct in6_addr fc_gateway;
	long unsigned int fc_expires;
	struct nlattr *fc_mx;
	int fc_mx_len;
	int fc_mp_len;
	struct nlattr *fc_mp;
	struct nl_info fc_nlinfo;
	struct nlattr *fc_encap;
	u16 fc_encap_type;
	bool fc_is_fdb;
};

struct fib6_dump_arg {
	struct net *net;
	struct notifier_block *nb;
	struct netlink_ext_ack *extack;
};

struct fib_notifier_info {
	int family;
	struct netlink_ext_ack *extack;
};

struct fib6_entry_notifier_info {
	struct fib_notifier_info info;
	struct fib6_info *rt;
	unsigned int nsiblings;
};

struct fib6_gc_args {
	int timeout;
	int more;
};

struct rt6key {
	struct in6_addr addr;
	int plen;
};

struct rtable;

struct fnhe_hash_bucket;

struct fib_nh_common {
	struct net_device *nhc_dev;
	netdevice_tracker nhc_dev_tracker;
	int nhc_oif;
	unsigned char nhc_scope;
	u8 nhc_family;
	u8 nhc_gw_family;
	unsigned char nhc_flags;
	struct lwtunnel_state *nhc_lwtstate;
	union {
		__be32 ipv4;
		struct in6_addr ipv6;
	} nhc_gw;
	int nhc_weight;
	atomic_t nhc_upper_bound;
	struct rtable **nhc_pcpu_rth_output;
	struct rtable *nhc_rth_input;
	struct fnhe_hash_bucket *nhc_exceptions;
};

struct rt6_info;

struct rt6_exception_bucket;

struct fib6_nh {
	struct fib_nh_common nh_common;
	struct rt6_info **rt6i_pcpu;
	struct rt6_exception_bucket *rt6i_exception_bucket;
};

struct fib6_table;

struct nexthop;

struct fib6_info {
	struct fib6_table *fib6_table;
	struct fib6_info *fib6_next;
	struct fib6_node *fib6_node;
	union {
		struct list_head fib6_siblings;
		struct list_head nh_list;
	};
	unsigned int fib6_nsiblings;
	refcount_t fib6_ref;
	long unsigned int expires;
	struct hlist_node gc_link;
	struct dst_metrics *fib6_metrics;
	struct rt6key fib6_dst;
	u32 fib6_flags;
	struct rt6key fib6_src;
	struct rt6key fib6_prefsrc;
	u32 fib6_metric;
	u8 fib6_protocol;
	u8 fib6_type;
	u8 offload;
	u8 trap;
	u8 offload_failed;
	u8 should_flush: 1;
	u8 dst_nocount: 1;
	u8 dst_nopolicy: 1;
	u8 fib6_destroying: 1;
	u8 unused: 4;
	struct callback_head rcu;
	struct nexthop *nh;
	struct fib6_nh fib6_nh[0];
};

struct fib6_nh_age_excptn_arg {
	struct fib6_gc_args *gc_args;
	long unsigned int now;
};

struct fib6_nh_del_cached_rt_arg {
	struct fib6_config *cfg;
	struct fib6_info *f6i;
};

struct fib6_nh_dm_arg {
	struct net *net;
	const struct in6_addr *saddr;
	int oif;
	int flags;
	struct fib6_nh *nh;
};

struct rt6_rtnl_dump_arg;

struct fib6_nh_exception_dump_walker {
	struct rt6_rtnl_dump_arg *dump;
	struct fib6_info *rt;
	unsigned int flags;
	unsigned int skip;
	unsigned int count;
};

struct fib6_nh_excptn_arg {
	struct rt6_info *rt;
	int plen;
};

struct fib6_nh_frl_arg {
	u32 flags;
	int oif;
	int strict;
	int *mpri;
	bool *do_rr;
	struct fib6_nh *nh;
};

struct fib6_nh_match_arg {
	const struct net_device *dev;
	const struct in6_addr *gw;
	struct fib6_nh *match;
};

struct fib6_nh_pcpu_arg {
	struct fib6_info *from;
	const struct fib6_table *table;
};

struct fib6_result;

struct flowi6;

struct fib6_nh_rd_arg {
	struct fib6_result *res;
	struct flowi6 *fl6;
	const struct in6_addr *gw;
	struct rt6_info **ret;
};

struct fib6_node {
	struct fib6_node *parent;
	struct fib6_node *left;
	struct fib6_node *right;
	struct fib6_info *leaf;
	__u16 fn_bit;
	__u16 fn_flags;
	int fn_sernum;
	struct fib6_info *rr_ptr;
	struct callback_head rcu;
};

struct fib6_result {
	struct fib6_nh *nh;
	struct fib6_info *f6i;
	u32 fib6_flags;
	u8 fib6_type;
	struct rt6_info *rt6;
};

struct inet_peer_base {
	struct rb_root rb_root;
	seqlock_t lock;
	int total;
};

struct fib6_table {
	struct hlist_node tb6_hlist;
	u32 tb6_id;
	spinlock_t tb6_lock;
	struct fib6_node tb6_root;
	struct inet_peer_base tb6_peers;
	unsigned int flags;
	unsigned int fib_seq;
	struct hlist_head tb6_gc_hlist;
};

struct fib_info;

struct fib_alias {
	struct hlist_node fa_list;
	struct fib_info *fa_info;
	dscp_t fa_dscp;
	u8 fa_type;
	u8 fa_state;
	u8 fa_slen;
	u32 tb_id;
	s16 fa_default;
	u8 offload;
	u8 trap;
	u8 offload_failed;
	struct callback_head rcu;
};

struct rtnexthop;

struct fib_config {
	u8 fc_dst_len;
	dscp_t fc_dscp;
	u8 fc_protocol;
	u8 fc_scope;
	u8 fc_type;
	u8 fc_gw_family;
	u32 fc_table;
	__be32 fc_dst;
	union {
		__be32 fc_gw4;
		struct in6_addr fc_gw6;
	};
	int fc_oif;
	u32 fc_flags;
	u32 fc_priority;
	__be32 fc_prefsrc;
	u32 fc_nh_id;
	struct nlattr *fc_mx;
	struct rtnexthop *fc_mp;
	int fc_mx_len;
	int fc_mp_len;
	u32 fc_flow;
	u32 fc_nlflags;
	struct nl_info fc_nlinfo;
	struct nlattr *fc_encap;
	u16 fc_encap_type;
};

struct fib_dump_filter {
	u32 table_id;
	bool filter_set;
	bool dump_routes;
	bool dump_exceptions;
	bool rtnl_held;
	unsigned char protocol;
	unsigned char rt_type;
	unsigned int flags;
	struct net_device *dev;
};

struct fib_entry_notifier_info {
	struct fib_notifier_info info;
	u32 dst;
	int dst_len;
	struct fib_info *fi;
	dscp_t dscp;
	u8 type;
	u32 tb_id;
};

struct fib_nh {
	struct fib_nh_common nh_common;
	struct hlist_node nh_hash;
	struct fib_info *nh_parent;
	__be32 nh_saddr;
	int nh_saddr_genid;
};

struct fib_info {
	struct hlist_node fib_hash;
	struct hlist_node fib_lhash;
	struct list_head nh_list;
	struct net *fib_net;
	refcount_t fib_treeref;
	refcount_t fib_clntref;
	unsigned int fib_flags;
	unsigned char fib_dead;
	unsigned char fib_protocol;
	unsigned char fib_scope;
	unsigned char fib_type;
	__be32 fib_prefsrc;
	u32 fib_tb_id;
	u32 fib_priority;
	struct dst_metrics *fib_metrics;
	int fib_nhs;
	bool fib_nh_is_v6;
	bool nh_updated;
	bool pfsrc_removed;
	struct nexthop *nh;
	struct callback_head rcu;
	struct fib_nh fib_nh[0];
};

struct fib_lookup_arg {
	void *lookup_ptr;
	const void *lookup_data;
	void *result;
	struct fib_rule *rule;
	u32 table;
	int flags;
};

struct fib_nh_exception {
	struct fib_nh_exception *fnhe_next;
	int fnhe_genid;
	__be32 fnhe_daddr;
	u32 fnhe_pmtu;
	bool fnhe_mtu_locked;
	__be32 fnhe_gw;
	long unsigned int fnhe_expires;
	struct rtable *fnhe_rth_input;
	struct rtable *fnhe_rth_output;
	long unsigned int fnhe_stamp;
	struct callback_head rcu;
};

struct fib_nh_notifier_info {
	struct fib_notifier_info info;
	struct fib_nh *fib_nh;
};

struct fib_notifier_net {
	struct list_head fib_notifier_ops;
	struct atomic_notifier_head fib_chain;
};

struct fib_notifier_ops {
	int family;
	struct list_head list;
	unsigned int (*fib_seq_read)(const struct net *);
	int (*fib_dump)(struct net *, struct notifier_block *, struct netlink_ext_ack *);
	struct module *owner;
	struct callback_head rcu;
};

struct fib_prop {
	int error;
	u8 scope;
};

struct fib_table;

struct fib_result {
	__be32 prefix;
	unsigned char prefixlen;
	unsigned char nh_sel;
	unsigned char type;
	unsigned char scope;
	u32 tclassid;
	dscp_t dscp;
	struct fib_nh_common *nhc;
	struct fib_info *fi;
	struct fib_table *table;
	struct hlist_head *fa_head;
};

struct fib_result_nl {
	__be32 fl_addr;
	u32 fl_mark;
	unsigned char fl_tos;
	unsigned char fl_scope;
	unsigned char tb_id_in;
	unsigned char tb_id;
	unsigned char prefixlen;
	unsigned char nh_sel;
	unsigned char type;
	unsigned char scope;
	int err;
};

struct key_vector;

struct fib_route_iter {
	struct seq_net_private p;
	struct fib_table *main_tb;
	struct key_vector *tnode;
	loff_t pos;
	t_key key;
};

struct fib_rt_info {
	struct fib_info *fi;
	u32 tb_id;
	__be32 dst;
	int dst_len;
	dscp_t dscp;
	u8 type;
	u8 offload: 1;
	u8 trap: 1;
	u8 offload_failed: 1;
	u8 unused: 5;
};

struct fib_rule_hdr {
	__u8 family;
	__u8 dst_len;
	__u8 src_len;
	__u8 tos;
	__u8 table;
	__u8 res1;
	__u8 res2;
	__u8 action;
	__u32 flags;
};

struct fib_rule_notifier_info {
	struct fib_notifier_info info;
	struct fib_rule *rule;
};

struct fib_rule_uid_range {
	__u32 start;
	__u32 end;
};

struct flowi;

struct fib_rules_ops {
	int family;
	struct list_head list;
	int rule_size;
	int addr_size;
	int unresolved_rules;
	int nr_goto_rules;
	unsigned int fib_rules_seq;
	int (*action)(struct fib_rule *, struct flowi *, int, struct fib_lookup_arg *);
	bool (*suppress)(struct fib_rule *, int, struct fib_lookup_arg *);
	int (*match)(struct fib_rule *, struct flowi *, int);
	int (*configure)(struct fib_rule *, struct sk_buff *, struct fib_rule_hdr *, struct nlattr **, struct netlink_ext_ack *);
	int (*delete)(struct fib_rule *);
	int (*compare)(struct fib_rule *, struct fib_rule_hdr *, struct nlattr **);
	int (*fill)(struct fib_rule *, struct sk_buff *, struct fib_rule_hdr *);
	size_t (*nlmsg_payload)(struct fib_rule *);
	void (*flush_cache)(struct fib_rules_ops *);
	int nlgroup;
	struct list_head rules_list;
	struct module *owner;
	struct net *fro_net;
	struct callback_head rcu;
};

struct fib_table {
	struct hlist_node tb_hlist;
	u32 tb_id;
	int tb_num_default;
	struct callback_head rcu;
	long unsigned int *tb_data;
	long unsigned int __data[0];
};

struct fib_trie_iter {
	struct seq_net_private p;
	struct fib_table *tb;
	struct key_vector *tnode;
	unsigned int index;
	unsigned int depth;
};

struct fid {
	union {
		struct {
			u32 ino;
			u32 gen;
			u32 parent_ino;
			u32 parent_gen;
		} i32;
		struct {
			u64 ino;
			u32 gen;
		} __attribute__((packed)) i64;
		struct {
			u32 block;
			u16 partref;
			u16 parent_partref;
			u32 generation;
			u32 parent_block;
			u32 parent_generation;
		} udf;
		struct {
			struct {} __empty_raw;
			__u32 raw[0];
		};
	};
};

struct fiemap_extent {
	__u64 fe_logical;
	__u64 fe_physical;
	__u64 fe_length;
	__u64 fe_reserved64[2];
	__u32 fe_flags;
	__u32 fe_reserved[3];
};

struct fiemap {
	__u64 fm_start;
	__u64 fm_length;
	__u32 fm_flags;
	__u32 fm_mapped_extents;
	__u32 fm_extent_count;
	__u32 fm_reserved;
	struct fiemap_extent fm_extents[0];
};

struct fiemap_extent_info {
	unsigned int fi_flags;
	unsigned int fi_extents_mapped;
	unsigned int fi_extents_max;
	struct fiemap_extent *fi_extents_start;
};

struct file__safe_trusted {
	struct inode *f_inode;
};

struct file_clone_range {
	__s64 src_fd;
	__u64 src_offset;
	__u64 src_length;
	__u64 dest_offset;
};

struct file_dedupe_range_info {
	__s64 dest_fd;
	__u64 dest_offset;
	__u64 bytes_deduped;
	__s32 status;
	__u32 reserved;
};

struct file_dedupe_range {
	__u64 src_offset;
	__u64 src_length;
	__u16 dest_count;
	__u16 reserved1;
	__u32 reserved2;
	struct file_dedupe_range_info info[0];
};

struct file_handle {
	__u32 handle_bytes;
	int handle_type;
	unsigned char f_handle[0];
};

struct file_lock_core {
	struct file_lock_core *flc_blocker;
	struct list_head flc_list;
	struct hlist_node flc_link;
	struct list_head flc_blocked_requests;
	struct list_head flc_blocked_member;
	fl_owner_t flc_owner;
	unsigned int flc_flags;
	unsigned char flc_type;
	pid_t flc_pid;
	int flc_link_cpu;
	wait_queue_head_t flc_wait;
	struct file *flc_file;
};

struct lease_manager_operations;

struct file_lease {
	struct file_lock_core c;
	struct fasync_struct *fl_fasync;
	long unsigned int fl_break_time;
	long unsigned int fl_downgrade_time;
	const struct lease_manager_operations *fl_lmops;
};

struct nlm_lockowner;

struct nfs_lock_info {
	u32 state;
	struct nlm_lockowner *owner;
	struct list_head list;
};

struct nfs4_lock_state;

struct nfs4_lock_info {
	struct nfs4_lock_state *owner;
};

struct file_lock_operations;

struct lock_manager_operations;

struct file_lock {
	struct file_lock_core c;
	loff_t fl_start;
	loff_t fl_end;
	const struct file_lock_operations *fl_ops;
	const struct lock_manager_operations *fl_lmops;
	union {
		struct nfs_lock_info nfs_fl;
		struct nfs4_lock_info nfs4_fl;
		struct {
			struct list_head link;
			int state;
			unsigned int debug_id;
		} afs;
		struct {
			struct inode *inode;
		} ceph;
	} fl_u;
};

struct file_lock_context {
	spinlock_t flc_lock;
	struct list_head flc_flock;
	struct list_head flc_posix;
	struct list_head flc_lease;
};

struct file_lock_list_struct {
	spinlock_t lock;
	struct hlist_head hlist;
};

struct file_lock_operations {
	void (*fl_copy_lock)(struct file_lock *, struct file_lock *);
	void (*fl_release_private)(struct file_lock *);
};

struct io_uring_cmd;

struct file_operations {
	struct module *owner;
	fop_flags_t fop_flags;
	loff_t (*llseek)(struct file *, loff_t, int);
	ssize_t (*read)(struct file *, char *, size_t, loff_t *);
	ssize_t (*write)(struct file *, const char *, size_t, loff_t *);
	ssize_t (*read_iter)(struct kiocb *, struct iov_iter *);
	ssize_t (*write_iter)(struct kiocb *, struct iov_iter *);
	int (*iopoll)(struct kiocb *, struct io_comp_batch *, unsigned int);
	int (*iterate_shared)(struct file *, struct dir_context *);
	__poll_t (*poll)(struct file *, struct poll_table_struct *);
	long int (*unlocked_ioctl)(struct file *, unsigned int, long unsigned int);
	long int (*compat_ioctl)(struct file *, unsigned int, long unsigned int);
	int (*mmap)(struct file *, struct vm_area_struct *);
	int (*open)(struct inode *, struct file *);
	int (*flush)(struct file *, fl_owner_t);
	int (*release)(struct inode *, struct file *);
	int (*fsync)(struct file *, loff_t, loff_t, int);
	int (*fasync)(int, struct file *, int);
	int (*lock)(struct file *, int, struct file_lock *);
	long unsigned int (*get_unmapped_area)(struct file *, long unsigned int, long unsigned int, long unsigned int, long unsigned int);
	int (*check_flags)(int);
	int (*flock)(struct file *, int, struct file_lock *);
	ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int);
	ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);
	void (*splice_eof)(struct file *);
	int (*setlease)(struct file *, int, struct file_lease **, void **);
	long int (*fallocate)(struct file *, int, loff_t, loff_t);
	void (*show_fdinfo)(struct seq_file *, struct file *);
	ssize_t (*copy_file_range)(struct file *, loff_t, struct file *, loff_t, size_t, unsigned int);
	loff_t (*remap_file_range)(struct file *, loff_t, struct file *, loff_t, loff_t, unsigned int);
	int (*fadvise)(struct file *, loff_t, loff_t, int);
	int (*uring_cmd)(struct io_uring_cmd *, unsigned int);
	int (*uring_cmd_iopoll)(struct io_uring_cmd *, struct io_comp_batch *, unsigned int);
};

struct file_range {
	const struct path *path;
	loff_t pos;
	size_t count;
};

struct page_counter;

struct file_region {
	struct list_head link;
	long int from;
	long int to;
	struct page_counter *reservation_counter;
	struct cgroup_subsys_state *css;
};

struct file_security_struct {
	u32 sid;
	u32 fown_sid;
	u32 isid;
	u32 pseqno;
};

struct fs_context;

struct fs_parameter_spec;

struct file_system_type {
	const char *name;
	int fs_flags;
	int (*init_fs_context)(struct fs_context *);
	const struct fs_parameter_spec *parameters;
	struct dentry * (*mount)(struct file_system_type *, int, const char *, void *);
	void (*kill_sb)(struct super_block *);
	struct module *owner;
	struct file_system_type *next;
	struct hlist_head fs_supers;
	struct lock_class_key s_lock_key;
	struct lock_class_key s_umount_key;
	struct lock_class_key s_vfs_rename_key;
	struct lock_class_key s_writers_key[3];
	struct lock_class_key i_lock_key;
	struct lock_class_key i_mutex_key;
	struct lock_class_key invalidate_lock_key;
	struct lock_class_key i_mutex_dir_key;
};

struct fileattr {
	u32 flags;
	u32 fsx_xflags;
	u32 fsx_extsize;
	u32 fsx_nextents;
	u32 fsx_projid;
	u32 fsx_cowextsize;
	bool flags_valid: 1;
	bool fsx_valid: 1;
};

struct filename {
	const char *name;
	const char *uptr;
	atomic_t refcnt;
	struct audit_names *aname;
	const char iname[0];
};

struct filename_trans_datum {
	struct ebitmap stypes;
	u32 otype;
	struct filename_trans_datum *next;
};

struct filename_trans_key {
	u32 ttype;
	u16 tclass;
	const char *name;
};

struct files_stat_struct {
	long unsigned int nr_files;
	long unsigned int nr_free_files;
	long unsigned int max_files;
};

struct files_struct {
	atomic_t count;
	bool resize_in_progress;
	wait_queue_head_t resize_wait;
	struct fdtable *fdt;
	struct fdtable fdtab;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	spinlock_t file_lock;
	unsigned int next_fd;
	long unsigned int close_on_exec_init[1];
	long unsigned int open_fds_init[1];
	long unsigned int full_fds_bits_init[1];
	struct file *fd_array[64];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct fils_discovery_data {
	struct callback_head callback_head;
	int len;
	u8 data[0];
};

struct filter_list {
	struct list_head list;
	struct event_filter *filter;
};

struct filter_parse_error {
	int lasterr;
	int lasterr_pos;
};

struct regex;

struct ftrace_event_field;

struct filter_pred {
	struct regex *regex;
	struct cpumask *mask;
	short unsigned int *ops;
	struct ftrace_event_field *field;
	u64 val;
	u64 val2;
	enum filter_pred_fn fn_num;
	int offset;
	int not;
	int op;
};

struct find_child_walk_data {
	struct acpi_device *adev;
	u64 address;
	int score;
	bool check_sta;
	bool check_children;
};

struct find_interface_arg {
	int minor;
	struct device_driver *drv;
};

struct kernel_symbol;

struct find_symbol_arg {
	const char *name;
	bool gplok;
	bool warn;
	struct module *owner;
	const u32 *crc;
	const struct kernel_symbol *sym;
	enum mod_license license;
};

struct firmware {
	size_t size;
	const u8 *data;
	void *priv;
};

struct firmware_cache {
	spinlock_t lock;
	struct list_head head;
	int state;
	spinlock_t name_lock;
	struct list_head fw_names;
	struct delayed_work work;
	struct notifier_block pm_notify;
};

struct firmware_map_entry {
	u64 start;
	u64 end;
	const char *type;
	struct list_head list;
	struct kobject kobj;
};

struct firmware_work {
	struct work_struct work;
	struct module *module;
	const char *name;
	struct device *device;
	void *context;
	void (*cont)(const struct firmware *, void *);
	u32 opt_flags;
};

struct mii_bus;

struct fixed_mdio_bus {
	struct mii_bus *mii_bus;
	struct list_head phys;
};

struct fixed_percpu_data {
	char gs_base[40];
	long unsigned int stack_canary;
};

struct fixed_phy_status {
	int link;
	int speed;
	int duplex;
	int pause;
	int asym_pause;
};

struct fixed_phy {
	int addr;
	struct phy_device *phydev;
	struct fixed_phy_status status;
	bool no_carrier;
	int (*link_update)(struct net_device *, struct fixed_phy_status *);
	struct list_head node;
	struct gpio_desc *link_gpiod;
};

struct fixed_range_block {
	int base_msr;
	int ranges;
};

struct flex {
	i915_reg_t reg;
	u32 offset;
	u32 value;
};

struct flex_groups {
	atomic64_t free_clusters;
	atomic_t free_inodes;
	atomic_t used_dirs;
};

struct flock {
	short int l_type;
	short int l_whence;
	__kernel_off_t l_start;
	__kernel_off_t l_len;
	__kernel_pid_t l_pid;
};

struct flock64 {
	short int l_type;
	short int l_whence;
	__kernel_loff_t l_start;
	__kernel_loff_t l_len;
	__kernel_pid_t l_pid;
};

typedef void (*action_destr)(void *);

struct nf_flowtable;

struct ip_tunnel_info;

struct psample_group;

struct flow_action_cookie;

struct flow_action_entry {
	enum flow_action_id id;
	u32 hw_index;
	long unsigned int cookie;
	u64 miss_cookie;
	enum flow_action_hw_stats hw_stats;
	action_destr destructor;
	void *destructor_priv;
	union {
		u32 chain_index;
		struct net_device *dev;
		struct {
			u16 vid;
			__be16 proto;
			u8 prio;
		} vlan;
		struct {
			unsigned char dst[6];
			unsigned char src[6];
		} vlan_push_eth;
		struct {
			enum flow_action_mangle_base htype;
			u32 offset;
			u32 mask;
			u32 val;
		} mangle;
		struct ip_tunnel_info *tunnel;
		u32 csum_flags;
		u32 mark;
		u16 ptype;
		u16 rx_queue;
		u32 priority;
		struct {
			u32 ctx;
			u32 index;
			u8 vf;
		} queue;
		struct {
			struct psample_group *psample_group;
			u32 rate;
			u32 trunc_size;
			bool truncate;
		} sample;
		struct {
			u32 burst;
			u64 rate_bytes_ps;
			u64 peakrate_bytes_ps;
			u32 avrate;
			u16 overhead;
			u64 burst_pkt;
			u64 rate_pkt_ps;
			u32 mtu;
			struct {
				enum flow_action_id act_id;
				u32 extval;
			} exceed;
			struct {
				enum flow_action_id act_id;
				u32 extval;
			} notexceed;
		} police;
		struct {
			int action;
			u16 zone;
			struct nf_flowtable *flow_table;
		} ct;
		struct {
			long unsigned int cookie;
			u32 mark;
			u32 labels[4];
			bool orig_dir;
		} ct_metadata;
		struct {
			u32 label;
			__be16 proto;
			u8 tc;
			u8 bos;
			u8 ttl;
		} mpls_push;
		struct {
			__be16 proto;
		} mpls_pop;
		struct {
			u32 label;
			u8 tc;
			u8 bos;
			u8 ttl;
		} mpls_mangle;
		struct {
			s32 prio;
			u64 basetime;
			u64 cycletime;
			u64 cycletimeext;
			u32 num_entries;
			struct action_gate_entry *entries;
		} gate;
		struct {
			u16 sid;
		} pppoe;
	};
	struct flow_action_cookie *user_cookie;
};

struct flow_action {
	unsigned int num_entries;
	struct flow_action_entry entries[0];
};

struct flow_action_cookie {
	u32 cookie_len;
	u8 cookie[0];
};

struct flow_block {
	struct list_head cb_list;
};

typedef int flow_setup_cb_t(enum tc_setup_type, void *, void *);

struct flow_block_cb;

struct flow_block_indr {
	struct list_head list;
	struct net_device *dev;
	struct Qdisc *sch;
	enum flow_block_binder_type binder_type;
	void *data;
	void *cb_priv;
	void (*cleanup)(struct flow_block_cb *);
};

struct flow_block_cb {
	struct list_head driver_list;
	struct list_head list;
	flow_setup_cb_t *cb;
	void *cb_ident;
	void *cb_priv;
	void (*release)(void *);
	struct flow_block_indr indr;
	unsigned int refcnt;
};

struct flow_block_offload {
	enum flow_block_command command;
	enum flow_block_binder_type binder_type;
	bool block_shared;
	bool unlocked_driver_cb;
	struct net *net;
	struct flow_block *block;
	struct list_head cb_list;
	struct list_head *driver_block_list;
	struct netlink_ext_ack *extack;
	struct Qdisc *sch;
	struct list_head *cb_list_head;
};

struct flow_dissector_key {
	enum flow_dissector_key_id key_id;
	size_t offset;
};

struct flow_dissector_key_tipc {
	__be32 key;
};

struct flow_dissector_key_addrs {
	union {
		struct flow_dissector_key_ipv4_addrs v4addrs;
		struct flow_dissector_key_ipv6_addrs v6addrs;
		struct flow_dissector_key_tipc tipckey;
	};
};

struct flow_dissector_key_arp {
	__u32 sip;
	__u32 tip;
	__u8 op;
	unsigned char sha[6];
	unsigned char tha[6];
};

struct flow_dissector_key_cfm {
	u8 mdl_ver;
	u8 opcode;
};

struct flow_dissector_key_control {
	u16 thoff;
	u16 addr_type;
	u32 flags;
};

struct flow_dissector_key_ct {
	u16 ct_state;
	u16 ct_zone;
	u32 ct_mark;
	u32 ct_labels[4];
};

struct flow_dissector_key_enc_opts {
	u8 data[255];
	u8 len;
	u32 dst_opt_type;
};

struct flow_dissector_key_hash {
	u32 hash;
};

struct flow_dissector_key_icmp {
	struct {
		u8 type;
		u8 code;
	};
	u16 id;
};

struct flow_dissector_key_ipsec {
	__be32 spi;
};

struct flow_dissector_key_keyid {
	__be32 keyid;
};

struct flow_dissector_key_l2tpv3 {
	__be32 session_id;
};

struct flow_dissector_key_meta {
	int ingress_ifindex;
	u16 ingress_iftype;
	u8 l2_miss;
};

struct flow_dissector_mpls_lse {
	u32 mpls_ttl: 8;
	u32 mpls_bos: 1;
	u32 mpls_tc: 3;
	u32 mpls_label: 20;
};

struct flow_dissector_key_mpls {
	struct flow_dissector_mpls_lse ls[7];
	u8 used_lses;
};

struct flow_dissector_key_num_of_vlans {
	u8 num_of_vlans;
};

struct flow_dissector_key_ports_range {
	union {
		struct flow_dissector_key_ports tp;
		struct {
			struct flow_dissector_key_ports tp_min;
			struct flow_dissector_key_ports tp_max;
		};
	};
};

struct flow_dissector_key_pppoe {
	__be16 session_id;
	__be16 ppp_proto;
	__be16 type;
};

struct flow_dissector_key_tags {
	u32 flow_label;
};

struct flow_dissector_key_tcp {
	__be16 flags;
};

struct flow_indir_dev_info {
	void *data;
	struct net_device *dev;
	struct Qdisc *sch;
	enum tc_setup_type type;
	void (*cleanup)(struct flow_block_cb *);
	struct list_head list;
	enum flow_block_command command;
	enum flow_block_binder_type binder_type;
	struct list_head *cb_list;
};

typedef int flow_indr_block_bind_cb_t(struct net_device *, struct Qdisc *, void *, enum tc_setup_type, void *, void *, void (*)(struct flow_block_cb *));

struct flow_indr_dev {
	struct list_head list;
	flow_indr_block_bind_cb_t *cb;
	void *cb_priv;
	refcount_t refcnt;
};

struct flow_keys {
	struct flow_dissector_key_control control;
	struct flow_dissector_key_basic basic;
	struct flow_dissector_key_tags tags;
	struct flow_dissector_key_vlan vlan;
	struct flow_dissector_key_vlan cvlan;
	struct flow_dissector_key_keyid keyid;
	struct flow_dissector_key_ports ports;
	struct flow_dissector_key_icmp icmp;
	struct flow_dissector_key_addrs addrs;
	long: 0;
};

struct flow_keys_basic {
	struct flow_dissector_key_control control;
	struct flow_dissector_key_basic basic;
};

struct flow_keys_digest {
	u8 data[16];
};

struct flow_match {
	struct flow_dissector *dissector;
	void *mask;
	void *key;
};

struct flow_match_arp {
	struct flow_dissector_key_arp *key;
	struct flow_dissector_key_arp *mask;
};

struct flow_match_basic {
	struct flow_dissector_key_basic *key;
	struct flow_dissector_key_basic *mask;
};

struct flow_match_control {
	struct flow_dissector_key_control *key;
	struct flow_dissector_key_control *mask;
};

struct flow_match_ct {
	struct flow_dissector_key_ct *key;
	struct flow_dissector_key_ct *mask;
};

struct flow_match_enc_keyid {
	struct flow_dissector_key_keyid *key;
	struct flow_dissector_key_keyid *mask;
};

struct flow_match_enc_opts {
	struct flow_dissector_key_enc_opts *key;
	struct flow_dissector_key_enc_opts *mask;
};

struct flow_match_eth_addrs {
	struct flow_dissector_key_eth_addrs *key;
	struct flow_dissector_key_eth_addrs *mask;
};

struct flow_match_icmp {
	struct flow_dissector_key_icmp *key;
	struct flow_dissector_key_icmp *mask;
};

struct flow_match_ip {
	struct flow_dissector_key_ip *key;
	struct flow_dissector_key_ip *mask;
};

struct flow_match_ipsec {
	struct flow_dissector_key_ipsec *key;
	struct flow_dissector_key_ipsec *mask;
};

struct flow_match_ipv4_addrs {
	struct flow_dissector_key_ipv4_addrs *key;
	struct flow_dissector_key_ipv4_addrs *mask;
};

struct flow_match_ipv6_addrs {
	struct flow_dissector_key_ipv6_addrs *key;
	struct flow_dissector_key_ipv6_addrs *mask;
};

struct flow_match_l2tpv3 {
	struct flow_dissector_key_l2tpv3 *key;
	struct flow_dissector_key_l2tpv3 *mask;
};

struct flow_match_meta {
	struct flow_dissector_key_meta *key;
	struct flow_dissector_key_meta *mask;
};

struct flow_match_mpls {
	struct flow_dissector_key_mpls *key;
	struct flow_dissector_key_mpls *mask;
};

struct flow_match_ports {
	struct flow_dissector_key_ports *key;
	struct flow_dissector_key_ports *mask;
};

struct flow_match_ports_range {
	struct flow_dissector_key_ports_range *key;
	struct flow_dissector_key_ports_range *mask;
};

struct flow_match_pppoe {
	struct flow_dissector_key_pppoe *key;
	struct flow_dissector_key_pppoe *mask;
};

struct flow_match_tcp {
	struct flow_dissector_key_tcp *key;
	struct flow_dissector_key_tcp *mask;
};

struct flow_match_vlan {
	struct flow_dissector_key_vlan *key;
	struct flow_dissector_key_vlan *mask;
};

struct flow_stats {
	u64 pkts;
	u64 bytes;
	u64 drops;
	u64 lastused;
	enum flow_action_hw_stats used_hw_stats;
	bool used_hw_stats_valid;
};

struct flow_offload_action {
	struct netlink_ext_ack *extack;
	enum offload_act_command command;
	enum flow_action_id id;
	u32 index;
	long unsigned int cookie;
	struct flow_stats stats;
	struct flow_action action;
};

struct flow_rule {
	struct flow_match match;
	struct flow_action action;
};

struct flowi_tunnel {
	__be64 tun_id;
};

struct flowi_common {
	int flowic_oif;
	int flowic_iif;
	int flowic_l3mdev;
	__u32 flowic_mark;
	__u8 flowic_tos;
	__u8 flowic_scope;
	__u8 flowic_proto;
	__u8 flowic_flags;
	__u32 flowic_secid;
	kuid_t flowic_uid;
	__u32 flowic_multipath_hash;
	struct flowi_tunnel flowic_tun_key;
};

union flowi_uli {
	struct {
		__be16 dport;
		__be16 sport;
	} ports;
	struct {
		__u8 type;
		__u8 code;
	} icmpt;
	__be32 gre_key;
	struct {
		__u8 type;
	} mht;
};

struct flowi4 {
	struct flowi_common __fl_common;
	__be32 saddr;
	__be32 daddr;
	union flowi_uli uli;
};

struct flowi6 {
	struct flowi_common __fl_common;
	struct in6_addr daddr;
	struct in6_addr saddr;
	__be32 flowlabel;
	union flowi_uli uli;
	__u32 mp_hash;
};

struct flowi {
	union {
		struct flowi_common __fl_common;
		struct flowi4 ip4;
		struct flowi6 ip6;
	} u;
};

struct flush_backlogs {
	cpumask_t flush_cpus;
	struct work_struct w[0];
};

struct flush_busy_ctx_data {
	struct blk_mq_hw_ctx *hctx;
	struct list_head *list;
};

struct kyber_hctx_data;

struct flush_kcq_data {
	struct kyber_hctx_data *khd;
	unsigned int sched_domain;
	struct list_head *list;
};

struct flush_tlb_info {
	struct mm_struct *mm;
	long unsigned int start;
	long unsigned int end;
	u64 new_tlb_gen;
	unsigned int initiating_cpu;
	u8 stride_shift;
	u8 freed_tables;
	u8 trim_cpumask;
};

struct fmt {
	const char *str;
	unsigned char state;
	unsigned char size;
};

struct fname {
	__u32 hash;
	__u32 minor_hash;
	struct rb_node rb_hash;
	struct fname *next;
	__u32 inode;
	__u8 name_len;
	__u8 file_type;
	char name[0];
};

struct fnhe_hash_bucket {
	struct fib_nh_exception *chain;
};

struct focaltech_finger_state {
	bool active;
	bool valid;
	unsigned int x;
	unsigned int y;
};

struct focaltech_hw_state {
	struct focaltech_finger_state fingers[5];
	unsigned int width;
	bool pressed;
};

struct focaltech_data {
	unsigned int x_max;
	unsigned int y_max;
	struct focaltech_hw_state state;
};

struct page_pool;

struct page {
	long unsigned int flags;
	union {
		struct {
			union {
				struct list_head lru;
				struct {
					void *__filler;
					unsigned int mlock_count;
				};
				struct list_head buddy_list;
				struct list_head pcp_list;
			};
			struct address_space *mapping;
			union {
				long unsigned int index;
				long unsigned int share;
			};
			long unsigned int private;
		};
		struct {
			long unsigned int pp_magic;
			struct page_pool *pp;
			long unsigned int _pp_mapping_pad;
			long unsigned int dma_addr;
			atomic_long_t pp_ref_count;
		};
		struct {
			long unsigned int compound_head;
		};
		struct {
			struct dev_pagemap *pgmap;
			void *zone_device_data;
		};
		struct callback_head callback_head;
	};
	union {
		unsigned int page_type;
		atomic_t _mapcount;
	};
	atomic_t _refcount;
	long: 64;
};

struct folio {
	union {
		struct {
			long unsigned int flags;
			union {
				struct list_head lru;
				struct {
					void *__filler;
					unsigned int mlock_count;
				};
			};
			struct address_space *mapping;
			long unsigned int index;
			union {
				void *private;
				swp_entry_t swap;
			};
			atomic_t _mapcount;
			atomic_t _refcount;
		};
		struct page page;
	};
	union {
		struct {
			long unsigned int _flags_1;
			long unsigned int _head_1;
			atomic_t _large_mapcount;
			atomic_t _entire_mapcount;
			atomic_t _nr_pages_mapped;
			atomic_t _pincount;
			unsigned int _folio_nr_pages;
		};
		struct page __page_1;
	};
	union {
		struct {
			long unsigned int _flags_2;
			long unsigned int _head_2;
			void *_hugetlb_subpool;
			void *_hugetlb_cgroup;
			void *_hugetlb_cgroup_rsvd;
			void *_hugetlb_hwpoison;
		};
		struct {
			long unsigned int _flags_2a;
			long unsigned int _head_2a;
			struct list_head _deferred_list;
		};
		struct page __page_2;
	};
};

struct folio_iter {
	struct folio *folio;
	size_t offset;
	size_t length;
	struct folio *_next;
	size_t _seg_count;
	int _i;
};

struct folio_queue {
	struct folio_batch vec;
	u8 orders[31];
	struct folio_queue *next;
	struct folio_queue *prev;
	long unsigned int marks;
	long unsigned int marks2;
	long unsigned int marks3;
	unsigned int rreq_id;
	unsigned int debug_id;
};

struct mem_cgroup;

struct folio_referenced_arg {
	int mapcount;
	int referenced;
	long unsigned int vm_flags;
	struct mem_cgroup *memcg;
};

struct folio_walk {
	struct page *page;
	enum folio_walk_level level;
	union {
		pte_t *ptep;
		pud_t *pudp;
		pmd_t *pmdp;
	};
	union {
		pte_t pte;
		pud_t pud;
		pmd_t pmd;
	};
	struct vm_area_struct *vma;
	spinlock_t *ptl;
};

struct follow_page_context {
	struct dev_pagemap *pgmap;
	unsigned int page_mask;
};

struct follow_pfnmap_args {
	struct vm_area_struct *vma;
	long unsigned int address;
	spinlock_t *lock;
	pte_t *ptep;
	long unsigned int pfn;
	pgprot_t pgprot;
	bool writable;
	bool special;
};

struct follower_init_arg {
	struct hda_codec *codec;
	int step;
};

struct font_data {
	unsigned int extra[4];
	const unsigned char data[0];
};

struct font_desc {
	int idx;
	const char *name;
	unsigned int width;
	unsigned int height;
	unsigned int charcount;
	const void *data;
	int pref;
};

struct inactive_task_frame {
	long unsigned int r15;
	long unsigned int r14;
	long unsigned int r13;
	long unsigned int r12;
	long unsigned int bx;
	long unsigned int bp;
	long unsigned int ret_addr;
};

struct fork_frame {
	struct inactive_task_frame frame;
	struct pt_regs regs;
};

struct fork_proc_event {
	__kernel_pid_t parent_pid;
	__kernel_pid_t parent_tgid;
	__kernel_pid_t child_pid;
	__kernel_pid_t child_tgid;
};

struct format_state___2 {
	unsigned char state;
	unsigned char size;
	unsigned char flags_or_double_size;
	unsigned char base;
};

struct fown_struct {
	struct file *file;
	rwlock_t lock;
	struct pid *pid;
	enum pid_type pid_type;
	kuid_t uid;
	kuid_t euid;
	int signum;
};

struct fregs_state {
	u32 cwd;
	u32 swd;
	u32 twd;
	u32 fip;
	u32 fcs;
	u32 foo;
	u32 fos;
	u32 st_space[20];
	u32 status;
};

struct fxregs_state {
	u16 cwd;
	u16 swd;
	u16 twd;
	u16 fop;
	union {
		struct {
			u64 rip;
			u64 rdp;
		};
		struct {
			u32 fip;
			u32 fcs;
			u32 foo;
			u32 fos;
		};
	};
	u32 mxcsr;
	u32 mxcsr_mask;
	u32 st_space[32];
	u32 xmm_space[64];
	u32 padding[12];
	union {
		u32 padding1[12];
		u32 sw_reserved[12];
	};
};

struct math_emu_info;

struct swregs_state {
	u32 cwd;
	u32 swd;
	u32 twd;
	u32 fip;
	u32 fcs;
	u32 foo;
	u32 fos;
	u32 st_space[20];
	u8 ftop;
	u8 changed;
	u8 lookahead;
	u8 no_update;
	u8 rm;
	u8 alimit;
	struct math_emu_info *info;
	u32 entry_eip;
};

struct xstate_header {
	u64 xfeatures;
	u64 xcomp_bv;
	u64 reserved[6];
};

struct xregs_state {
	struct fxregs_state i387;
	struct xstate_header header;
	u8 extended_state_area[0];
};

union fpregs_state {
	struct fregs_state fsave;
	struct fxregs_state fxsave;
	struct swregs_state soft;
	struct xregs_state xsave;
	u8 __padding[4096];
};

struct fprop_global {
	struct percpu_counter events;
	unsigned int period;
	seqcount_t sequence;
};

struct fpstate {
	unsigned int size;
	unsigned int user_size;
	u64 xfeatures;
	u64 user_xfeatures;
	u64 xfd;
	unsigned int is_valloc: 1;
	unsigned int is_guest: 1;
	unsigned int is_confidential: 1;
	unsigned int in_use: 1;
	long: 64;
	long: 64;
	long: 64;
	union fpregs_state regs;
};

struct fpu_state_perm {
	u64 __state_perm;
	unsigned int __state_size;
	unsigned int __user_state_size;
};

struct fpu {
	unsigned int last_cpu;
	long unsigned int avx512_timestamp;
	struct fpstate *fpstate;
	struct fpstate *__task_fpstate;
	struct fpu_state_perm perm;
	struct fpu_state_perm guest_perm;
	struct fpstate __fpstate;
};

struct fpu_guest {
	u64 xfeatures;
	u64 perm;
	u64 xfd_err;
	unsigned int uabi_size;
	struct fpstate *fpstate;
};

struct fpu_state_config {
	unsigned int max_size;
	unsigned int default_size;
	u64 max_features;
	u64 default_features;
	u64 legacy_features;
	u64 independent_features;
};

struct fq_flow;

struct fq {
	struct fq_flow *flows;
	long unsigned int *flows_bitmap;
	struct list_head tin_backlog;
	spinlock_t lock;
	u32 flows_cnt;
	u32 limit;
	u32 memory_limit;
	u32 memory_usage;
	u32 quantum;
	u32 backlog;
	u32 overlimit;
	u32 overmemory;
	u32 collisions;
};

struct fq_tin;

struct fq_flow {
	struct fq_tin *tin;
	struct list_head flowchain;
	struct sk_buff_head queue;
	u32 backlog;
	int deficit;
};

struct fq_tin {
	struct list_head new_flows;
	struct list_head old_flows;
	struct list_head tin_list;
	struct fq_flow default_flow;
	u32 backlog_bytes;
	u32 backlog_packets;
	u32 overlimit;
	u32 collisions;
	u32 flows;
	u32 tx_bytes;
	u32 tx_packets;
};

typedef u32 (*rht_hashfn_t)(const void *, u32, u32);

typedef u32 (*rht_obj_hashfn_t)(const void *, u32, u32);

struct rhashtable_compare_arg;

typedef int (*rht_obj_cmpfn_t)(struct rhashtable_compare_arg *, const void *);

struct rhashtable_params {
	u16 nelem_hint;
	u16 key_len;
	u16 key_offset;
	u16 head_offset;
	unsigned int max_size;
	u16 min_size;
	bool automatic_shrinking;
	rht_hashfn_t hashfn;
	rht_obj_hashfn_t obj_hashfn;
	rht_obj_cmpfn_t obj_cmpfn;
};

struct rhashtable {
	struct bucket_table *tbl;
	unsigned int key_len;
	unsigned int max_elems;
	struct rhashtable_params p;
	bool rhlist;
	struct work_struct run_work;
	struct mutex mutex;
	spinlock_t lock;
	atomic_t nelems;
};

struct inet_frags;

struct fqdir {
	long int high_thresh;
	long int low_thresh;
	int timeout;
	int max_dist;
	struct inet_frags *f;
	struct net *net;
	bool dead;
	long: 64;
	long: 64;
	struct rhashtable rhashtable;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	atomic_long_t mem;
	struct work_struct destroy_work;
	struct llist_node free_list;
	long: 64;
	long: 64;
};

struct frag_hdr {
	__u8 nexthdr;
	__u8 reserved;
	__be16 frag_off;
	__be32 identification;
};

struct frag_v4_compare_key {
	__be32 saddr;
	__be32 daddr;
	u32 user;
	u32 vif;
	__be16 id;
	u16 protocol;
};

struct frag_v6_compare_key {
	struct in6_addr saddr;
	struct in6_addr daddr;
	u32 user;
	__be32 id;
	u32 iif;
};

struct inet_frag_queue {
	struct rhash_head node;
	union {
		struct frag_v4_compare_key v4;
		struct frag_v6_compare_key v6;
	} key;
	struct timer_list timer;
	spinlock_t lock;
	refcount_t refcnt;
	struct rb_root rb_fragments;
	struct sk_buff *fragments_tail;
	struct sk_buff *last_run_head;
	ktime_t stamp;
	int len;
	int meat;
	u8 tstamp_type;
	__u8 flags;
	u16 max_size;
	struct fqdir *fqdir;
	struct callback_head rcu;
};

struct frag_queue {
	struct inet_frag_queue q;
	int iif;
	__u16 nhoffset;
	u8 ecn;
};

struct freader {
	void *buf;
	u32 buf_sz;
	int err;
	union {
		struct {
			struct file *file;
			struct folio *folio;
			void *addr;
			loff_t folio_off;
			bool may_fault;
		};
		struct {
			const char *data;
			u64 data_sz;
		};
	};
};

struct free_area {
	struct list_head free_list[4];
	long unsigned int nr_free;
};

struct freerunning_counters {
	unsigned int counter_base;
	unsigned int counter_offset;
	unsigned int box_offset;
	unsigned int num_counters;
	unsigned int bits;
	unsigned int *box_offsets;
};

struct freezer {
	struct cgroup_subsys_state css;
	unsigned int state;
};

struct freq_attr {
	struct attribute attr;
	ssize_t (*show)(struct cpufreq_policy *, char *);
	ssize_t (*store)(struct cpufreq_policy *, const char *, size_t);
};

struct freq_band_range {
	u64 start;
	u64 end;
};

struct muldiv {
	u32 multiplier;
	u32 divider;
};

struct freq_desc {
	bool use_msr_plat;
	struct muldiv muldiv[16];
	u32 freqs[16];
	u32 mask;
};

struct frontbuffer_fence_cb {
	struct dma_fence_cb base;
	struct intel_frontbuffer *front;
};

struct p_log {
	const char *prefix;
	struct fc_log *log;
};

struct fs_context_operations;

struct fs_context {
	const struct fs_context_operations *ops;
	struct mutex uapi_mutex;
	struct file_system_type *fs_type;
	void *fs_private;
	void *sget_key;
	struct dentry *root;
	struct user_namespace *user_ns;
	struct net *net_ns;
	const struct cred *cred;
	struct p_log log;
	const char *source;
	void *security;
	void *s_fs_info;
	unsigned int sb_flags;
	unsigned int sb_flags_mask;
	unsigned int s_iflags;
	enum fs_context_purpose purpose: 8;
	enum fs_context_phase phase: 8;
	bool need_free: 1;
	bool global: 1;
	bool oldapi: 1;
	bool exclusive: 1;
};

struct fs_parameter;

struct fs_context_operations {
	void (*free)(struct fs_context *);
	int (*dup)(struct fs_context *, struct fs_context *);
	int (*parse_param)(struct fs_context *, struct fs_parameter *);
	int (*parse_monolithic)(struct fs_context *, void *);
	int (*get_tree)(struct fs_context *);
	int (*reconfigure)(struct fs_context *);
};

struct fs_disk_quota {
	__s8 d_version;
	__s8 d_flags;
	__u16 d_fieldmask;
	__u32 d_id;
	__u64 d_blk_hardlimit;
	__u64 d_blk_softlimit;
	__u64 d_ino_hardlimit;
	__u64 d_ino_softlimit;
	__u64 d_bcount;
	__u64 d_icount;
	__s32 d_itimer;
	__s32 d_btimer;
	__u16 d_iwarns;
	__u16 d_bwarns;
	__s8 d_itimer_hi;
	__s8 d_btimer_hi;
	__s8 d_rtbtimer_hi;
	__s8 d_padding2;
	__u64 d_rtb_hardlimit;
	__u64 d_rtb_softlimit;
	__u64 d_rtbcount;
	__s32 d_rtbtimer;
	__u16 d_rtbwarns;
	__s16 d_padding3;
	char d_padding4[8];
};

struct fs_error_report {
	int error;
	struct inode *inode;
	struct super_block *sb;
};

struct fs_parameter {
	const char *key;
	enum fs_value_type type: 8;
	union {
		char *string;
		void *blob;
		struct filename *name;
		struct file *file;
	};
	size_t size;
	int dirfd;
};

struct fs_parse_result;

typedef int fs_param_type(struct p_log *, const struct fs_parameter_spec *, struct fs_parameter *, struct fs_parse_result *);

struct fs_parameter_spec {
	const char *name;
	fs_param_type *type;
	u8 opt;
	short unsigned int flags;
	const void *data;
};

struct fs_parse_result {
	bool negated;
	union {
		bool boolean;
		int int_32;
		unsigned int uint_32;
		u64 uint_64;
		kuid_t uid;
		kgid_t gid;
	};
};

struct fs_qfilestat {
	__u64 qfs_ino;
	__u64 qfs_nblks;
	__u32 qfs_nextents;
};

typedef struct fs_qfilestat fs_qfilestat_t;

struct fs_qfilestatv {
	__u64 qfs_ino;
	__u64 qfs_nblks;
	__u32 qfs_nextents;
	__u32 qfs_pad;
};

struct fs_quota_stat {
	__s8 qs_version;
	__u16 qs_flags;
	__s8 qs_pad;
	fs_qfilestat_t qs_uquota;
	fs_qfilestat_t qs_gquota;
	__u32 qs_incoredqs;
	__s32 qs_btimelimit;
	__s32 qs_itimelimit;
	__s32 qs_rtbtimelimit;
	__u16 qs_bwarnlimit;
	__u16 qs_iwarnlimit;
};

struct fs_quota_statv {
	__s8 qs_version;
	__u8 qs_pad1;
	__u16 qs_flags;
	__u32 qs_incoredqs;
	struct fs_qfilestatv qs_uquota;
	struct fs_qfilestatv qs_gquota;
	struct fs_qfilestatv qs_pquota;
	__s32 qs_btimelimit;
	__s32 qs_itimelimit;
	__s32 qs_rtbtimelimit;
	__u16 qs_bwarnlimit;
	__u16 qs_iwarnlimit;
	__u16 qs_rtbwarnlimit;
	__u16 qs_pad3;
	__u32 qs_pad4;
	__u64 qs_pad2[7];
};

struct fs_struct {
	int users;
	spinlock_t lock;
	seqcount_spinlock_t seq;
	int umask;
	int in_exec;
	struct path root;
	struct path pwd;
};

struct fs_sysfs_path {
	__u8 len;
	__u8 name[128];
};

struct fscache_cache_ops;

struct fscache_cache {
	const struct fscache_cache_ops *ops;
	struct list_head cache_link;
	void *cache_priv;
	refcount_t ref;
	atomic_t n_volumes;
	atomic_t n_accesses;
	atomic_t object_count;
	unsigned int debug_id;
	enum fscache_cache_state state;
	char *name;
};

struct fscache_volume;

struct fscache_cookie;

struct netfs_cache_resources;

struct fscache_cache_ops {
	const char *name;
	void (*acquire_volume)(struct fscache_volume *);
	void (*free_volume)(struct fscache_volume *);
	bool (*lookup_cookie)(struct fscache_cookie *);
	void (*withdraw_cookie)(struct fscache_cookie *);
	void (*resize_cookie)(struct netfs_cache_resources *, loff_t);
	bool (*invalidate_cookie)(struct fscache_cookie *);
	bool (*begin_operation)(struct netfs_cache_resources *, enum fscache_want_state);
	void (*prepare_to_write)(struct fscache_cookie *);
};

struct fscache_cookie {
	refcount_t ref;
	atomic_t n_active;
	atomic_t n_accesses;
	unsigned int debug_id;
	unsigned int inval_counter;
	spinlock_t lock;
	struct fscache_volume *volume;
	void *cache_priv;
	struct hlist_bl_node hash_link;
	struct list_head proc_link;
	struct list_head commit_link;
	struct work_struct work;
	loff_t object_size;
	long unsigned int unused_at;
	long unsigned int flags;
	enum fscache_cookie_state state;
	u8 advice;
	u8 key_len;
	u8 aux_len;
	u32 key_hash;
	union {
		void *key;
		u8 inline_key[16];
	};
	union {
		void *aux;
		u8 inline_aux[8];
	};
};

struct fscache_volume {
	refcount_t ref;
	atomic_t n_cookies;
	atomic_t n_accesses;
	unsigned int debug_id;
	unsigned int key_hash;
	u8 *key;
	struct list_head proc_link;
	struct hlist_bl_node hash_link;
	struct work_struct work;
	struct fscache_cache *cache;
	void *cache_priv;
	spinlock_t lock;
	long unsigned int flags;
	u8 coherency_len;
	u8 coherency[0];
};

struct fscrypt_name {
	const struct qstr *usr_fname;
	struct fscrypt_str disk_name;
	u32 hash;
	u32 minor_hash;
	struct fscrypt_str crypto_buf;
	bool is_nokey_name;
};

struct fsl_mc_obj_desc {
	char type[16];
	int id;
	u16 vendor;
	u16 ver_major;
	u16 ver_minor;
	u8 irq_count;
	u8 region_count;
	u32 state;
	char label[16];
	u16 flags;
};

struct fsl_mc_io;

struct fsl_mc_device_irq;

struct fsl_mc_resource;

struct fsl_mc_device {
	struct device dev;
	u64 dma_mask;
	u16 flags;
	u32 icid;
	u16 mc_handle;
	struct fsl_mc_io *mc_io;
	struct fsl_mc_obj_desc obj_desc;
	struct resource *regions;
	struct fsl_mc_device_irq **irqs;
	struct fsl_mc_resource *resource;
	struct device_link *consumer_link;
	const char *driver_override;
};

struct fsl_mc_resource_pool;

struct fsl_mc_resource {
	enum fsl_mc_pool_type type;
	s32 id;
	void *data;
	struct fsl_mc_resource_pool *parent_pool;
	struct list_head node;
};

struct fsl_mc_device_irq {
	unsigned int virq;
	struct fsl_mc_device *mc_dev;
	u8 dev_irq_index;
	struct fsl_mc_resource resource;
};

struct fsl_mc_io {
	struct device *dev;
	u16 flags;
	u32 portal_size;
	phys_addr_t portal_phys_addr;
	void *portal_virt_addr;
	struct fsl_mc_device *dpmcp_dev;
	union {
		struct mutex mutex;
		raw_spinlock_t spinlock;
	};
};

struct fsmap {
	__u32 fmr_device;
	__u32 fmr_flags;
	__u64 fmr_physical;
	__u64 fmr_owner;
	__u64 fmr_offset;
	__u64 fmr_length;
	__u64 fmr_reserved[3];
};

struct fsmap_head {
	__u32 fmh_iflags;
	__u32 fmh_oflags;
	__u32 fmh_count;
	__u32 fmh_entries;
	__u64 fmh_reserved[6];
	struct fsmap fmh_keys[2];
	struct fsmap fmh_recs[0];
};

struct fsnotify_event {
	struct list_head list;
};

struct inotify_group_private_data {
	spinlock_t idr_lock;
	struct idr idr;
	struct ucounts *ucounts;
};

struct fsnotify_ops;

struct fsnotify_group {
	const struct fsnotify_ops *ops;
	refcount_t refcnt;
	spinlock_t notification_lock;
	struct list_head notification_list;
	wait_queue_head_t notification_waitq;
	unsigned int q_len;
	unsigned int max_events;
	enum fsnotify_group_prio priority;
	bool shutdown;
	int flags;
	unsigned int owner_flags;
	struct mutex mark_mutex;
	atomic_t user_waits;
	struct list_head marks_list;
	struct fasync_struct *fsn_fa;
	struct fsnotify_event *overflow_event;
	struct mem_cgroup *memcg;
	union {
		void *private;
		struct inotify_group_private_data inotify_data;
	};
};

struct fsnotify_iter_info {
	struct fsnotify_mark *marks[5];
	struct fsnotify_group *current_group;
	unsigned int report_mask;
	int srcu_idx;
};

typedef struct fsnotify_mark_connector *fsnotify_connp_t;

struct fsnotify_mark_connector {
	spinlock_t lock;
	unsigned char type;
	unsigned char prio;
	short unsigned int flags;
	union {
		void *obj;
		struct fsnotify_mark_connector *destroy_next;
	};
	struct hlist_head list;
};

struct fsnotify_ops {
	int (*handle_event)(struct fsnotify_group *, u32, const void *, int, struct inode *, const struct qstr *, u32, struct fsnotify_iter_info *);
	int (*handle_inode_event)(struct fsnotify_mark *, u32, struct inode *, struct inode *, const struct qstr *, u32);
	void (*free_group_priv)(struct fsnotify_group *);
	void (*freeing_mark)(struct fsnotify_mark *, struct fsnotify_group *);
	void (*free_event)(struct fsnotify_group *, struct fsnotify_event *);
	void (*free_mark)(struct fsnotify_mark *);
};

struct fsnotify_sb_info {
	struct fsnotify_mark_connector *sb_marks;
	atomic_long_t watched_objects[3];
};

struct fstrim_range {
	__u64 start;
	__u64 len;
	__u64 minlen;
};

struct fsuuid {
	__u32 fsu_len;
	__u32 fsu_flags;
	__u8 fsu_uuid[0];
};

struct fsuuid2 {
	__u8 len;
	__u8 uuid[16];
};

struct fsxattr {
	__u32 fsx_xflags;
	__u32 fsx_extsize;
	__u32 fsx_nextents;
	__u32 fsx_projid;
	__u32 fsx_cowextsize;
	unsigned char fsx_pad[8];
};

struct ftp_search {
	const char *pattern;
	size_t plen;
	char skip;
	char term;
	enum nf_ct_ftp_type ftptype;
	int (*getnum)(const char *, size_t, struct nf_conntrack_man *, char, unsigned int *);
};

struct trace_seq {
	char buffer[8156];
	struct seq_buf seq;
	size_t readpos;
	int full;
};

struct tracer;

struct ring_buffer_iter;

struct trace_iterator {
	struct trace_array *tr;
	struct tracer *trace;
	struct array_buffer *array_buffer;
	void *private;
	int cpu_file;
	struct mutex mutex;
	struct ring_buffer_iter **buffer_iter;
	long unsigned int iter_flags;
	void *temp;
	unsigned int temp_size;
	char *fmt;
	unsigned int fmt_size;
	atomic_t wait_index;
	struct trace_seq tmp_seq;
	cpumask_var_t started;
	bool closed;
	bool snapshot;
	struct trace_seq seq;
	struct trace_entry *ent;
	long unsigned int lost_events;
	int leftover;
	int ent_size;
	int cpu;
	u64 ts;
	loff_t pos;
	long int idx;
};

struct ftrace_buffer_info {
	struct trace_iterator iter;
	void *spare;
	unsigned int spare_cpu;
	unsigned int spare_size;
	unsigned int read;
};

struct ftrace_entry {
	struct trace_entry ent;
	long unsigned int ip;
	long unsigned int parent_ip;
};

struct ftrace_event_field {
	struct list_head link;
	const char *name;
	const char *type;
	int filter_type;
	int offset;
	int size;
	unsigned int is_signed: 1;
	unsigned int needs_test: 1;
	int len;
};

struct ftrace_stack {
	long unsigned int calls[1024];
};

struct ftrace_stacks {
	struct ftrace_stack stacks[4];
};

struct func_repeats_entry {
	struct trace_entry ent;
	long unsigned int ip;
	long unsigned int parent_ip;
	u16 count;
	u16 top_delta_ts;
	u32 bottom_delta_ts;
};

struct futex_hash_bucket {
	atomic_t waiters;
	spinlock_t lock;
	struct plist_head chain;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

union futex_key {
	struct {
		u64 i_seq;
		long unsigned int pgoff;
		unsigned int offset;
	} shared;
	struct {
		union {
			struct mm_struct *mm;
			u64 __tmp;
		};
		long unsigned int address;
		unsigned int offset;
	} private;
	struct {
		u64 ptr;
		long unsigned int word;
		unsigned int offset;
	} both;
};

struct futex_pi_state {
	struct list_head list;
	struct rt_mutex_base pi_mutex;
	struct task_struct *owner;
	refcount_t refcount;
	union futex_key key;
};

struct wake_q_head;

struct futex_q;

typedef void futex_wake_fn(struct wake_q_head *, struct futex_q *);

struct rt_mutex_waiter;

struct futex_q {
	struct plist_node list;
	struct task_struct *task;
	spinlock_t *lock_ptr;
	futex_wake_fn *wake;
	void *wake_data;
	union futex_key key;
	struct futex_pi_state *pi_state;
	struct rt_mutex_waiter *rt_waiter;
	union futex_key *requeue_pi_key;
	u32 bitset;
	atomic_t requeue_state;
};

struct futex_waitv {
	__u64 val;
	__u64 uaddr;
	__u32 flags;
	__u32 __reserved;
};

struct futex_vector {
	struct futex_waitv w;
	struct futex_q q;
};

struct uc_fw_platform_requirement;

struct fw_blobs_by_type {
	const struct uc_fw_platform_requirement *blobs;
	u32 count;
};

struct fw_cache_entry {
	struct list_head list;
	const char *name;
};

struct fw_info {
	u32 magic;
	char version[32];
	__le32 fw_start;
	__le32 fw_len;
	u8 chksum;
} __attribute__((packed));

struct fw_name_devm {
	long unsigned int magic;
	const char *name;
};

struct fw_state {
	struct completion completion;
	enum fw_status status;
};

struct fw_priv {
	struct kref ref;
	struct list_head list;
	struct firmware_cache *fwc;
	struct fw_state fw_st;
	void *data;
	size_t size;
	size_t allocated_size;
	size_t offset;
	u32 opt_flags;
	const char *fw_name;
};

union fw_table_header {
	struct acpi_table_header acpi;
	struct acpi_table_cdat cdat;
};

struct fwdb_collection {
	u8 len;
	u8 n_rules;
	u8 dfs_region;
	int: 0;
};

struct fwdb_country {
	u8 alpha2[2];
	__be16 coll_ptr;
};

struct fwdb_header {
	__be32 magic;
	__be32 version;
	struct fwdb_country country[0];
};

struct fwdb_rule {
	u8 len;
	u8 flags;
	__be16 max_eirp;
	__be32 start;
	__be32 end;
	__be32 max_bw;
	__be16 cac_timeout;
	__be16 wmm_ptr;
};

struct fwdb_wmm_ac {
	u8 ecw;
	u8 aifsn;
	__be16 cot;
};

struct fwdb_wmm_rule {
	struct fwdb_wmm_ac client[4];
	struct fwdb_wmm_ac ap[4];
};

union fwnet_hwaddr {
	u8 u[16];
	struct {
		__be64 uniq_id;
		u8 max_rec;
		u8 sspd;
		u8 fifo[6];
	} uc;
};

struct fwnode_endpoint {
	unsigned int port;
	unsigned int id;
	const struct fwnode_handle *local_fwnode;
};

struct fwnode_link {
	struct fwnode_handle *supplier;
	struct list_head s_hook;
	struct fwnode_handle *consumer;
	struct list_head c_hook;
	u8 flags;
};

struct fwnode_reference_args;

struct fwnode_operations {
	struct fwnode_handle * (*get)(struct fwnode_handle *);
	void (*put)(struct fwnode_handle *);
	bool (*device_is_available)(const struct fwnode_handle *);
	const void * (*device_get_match_data)(const struct fwnode_handle *, const struct device *);
	bool (*device_dma_supported)(const struct fwnode_handle *);
	enum dev_dma_attr (*device_get_dma_attr)(const struct fwnode_handle *);
	bool (*property_present)(const struct fwnode_handle *, const char *);
	bool (*property_read_bool)(const struct fwnode_handle *, const char *);
	int (*property_read_int_array)(const struct fwnode_handle *, const char *, unsigned int, void *, size_t);
	int (*property_read_string_array)(const struct fwnode_handle *, const char *, const char **, size_t);
	const char * (*get_name)(const struct fwnode_handle *);
	const char * (*get_name_prefix)(const struct fwnode_handle *);
	struct fwnode_handle * (*get_parent)(const struct fwnode_handle *);
	struct fwnode_handle * (*get_next_child_node)(const struct fwnode_handle *, struct fwnode_handle *);
	struct fwnode_handle * (*get_named_child_node)(const struct fwnode_handle *, const char *);
	int (*get_reference_args)(const struct fwnode_handle *, const char *, const char *, unsigned int, unsigned int, struct fwnode_reference_args *);
	struct fwnode_handle * (*graph_get_next_endpoint)(const struct fwnode_handle *, struct fwnode_handle *);
	struct fwnode_handle * (*graph_get_remote_endpoint)(const struct fwnode_handle *);
	struct fwnode_handle * (*graph_get_port_parent)(struct fwnode_handle *);
	int (*graph_parse_endpoint)(const struct fwnode_handle *, struct fwnode_endpoint *);
	void * (*iomap)(struct fwnode_handle *, int);
	int (*irq_get)(const struct fwnode_handle *, unsigned int);
	int (*add_links)(struct fwnode_handle *);
};

struct fwnode_reference_args {
	struct fwnode_handle *fwnode;
	unsigned int nargs;
	u64 args[8];
};

struct g4x_wm_state {
	struct g4x_pipe_wm wm;
	struct g4x_sr_wm sr;
	struct g4x_sr_wm hpll;
	bool cxsr;
	bool hpll_en;
	bool fbc_en;
};

struct idt_bits {
	u16 ist: 3;
	u16 zero: 5;
	u16 type: 5;
	u16 dpl: 2;
	u16 p: 1;
};

struct gate_struct {
	u16 offset_low;
	u16 segment;
	struct idt_bits bits;
	u16 offset_middle;
	u32 offset_high;
	u32 reserved;
};

typedef struct gate_struct gate_desc;

struct gatt_mask {
	long unsigned int mask;
	u32 type;
};

struct gcm_instance_ctx {
	struct crypto_skcipher_spawn ctr;
	struct crypto_ahash_spawn ghash;
};

struct gcr3_tbl_info {
	u64 *gcr3_tbl;
	int glx;
	u32 pasid_cnt;
	u16 domid;
};

struct gcry_mpi;

typedef struct gcry_mpi *MPI;

struct gcry_mpi {
	int alloced;
	int nlimbs;
	int nbits;
	int sign;
	unsigned int flags;
	mpi_limb_t *d;
};

struct gdt_page {
	struct desc_struct gdt[16];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct i915_vm_pt_stash;

struct i915_vma_resource;

struct i915_vma_ops {
	void (*bind_vma)(struct i915_address_space *, struct i915_vm_pt_stash *, struct i915_vma_resource *, unsigned int, u32);
	void (*unbind_vma)(struct i915_address_space *, struct i915_vma_resource *);
};

struct i915_page_table;

struct i915_address_space {
	struct kref ref;
	struct work_struct release_work;
	struct drm_mm mm;
	struct {
		struct drm_i915_gem_object *obj;
		struct i915_vma *vma;
	} rsvd;
	struct intel_gt *gt;
	struct drm_i915_private *i915;
	struct drm_i915_file_private *fpriv;
	struct device *dma;
	u64 total;
	u64 reserved;
	u64 min_alignment[4];
	unsigned int bind_async_flags;
	struct mutex mutex;
	struct kref resv_ref;
	struct dma_resv _resv;
	struct drm_i915_gem_object *scratch[4];
	struct list_head bound_list;
	struct list_head unbound_list;
	bool is_ggtt: 1;
	bool is_dpt: 1;
	bool has_read_only: 1;
	bool skip_pte_rewrite: 1;
	u8 top;
	u8 pd_shift;
	u8 scratch_order;
	long unsigned int lmem_pt_obj_flags;
	struct rb_root_cached pending_unbind;
	struct drm_i915_gem_object * (*alloc_pt_dma)(struct i915_address_space *, int);
	struct drm_i915_gem_object * (*alloc_scratch_dma)(struct i915_address_space *, int);
	u64 (*pte_encode)(dma_addr_t, unsigned int, u32);
	void (*allocate_va_range)(struct i915_address_space *, struct i915_vm_pt_stash *, u64, u64);
	void (*clear_range)(struct i915_address_space *, u64, u64);
	void (*scratch_range)(struct i915_address_space *, u64, u64);
	void (*insert_page)(struct i915_address_space *, dma_addr_t, u64, unsigned int, u32);
	void (*insert_entries)(struct i915_address_space *, struct i915_vma_resource *, unsigned int, u32);
	void (*raw_insert_page)(struct i915_address_space *, dma_addr_t, u64, unsigned int, u32);
	void (*raw_insert_entries)(struct i915_address_space *, struct i915_vma_resource *, unsigned int, u32);
	void (*cleanup)(struct i915_address_space *);
	void (*foreach)(struct i915_address_space *, u64, u64, void (*)(struct i915_address_space *, struct i915_page_table *, void *), void *);
	struct i915_vma_ops vma_ops;
};

struct i915_page_directory;

struct i915_ppgtt {
	struct i915_address_space vm;
	struct i915_page_directory *pd;
};

struct gen6_ppgtt {
	struct i915_ppgtt base;
	struct mutex flush;
	struct i915_vma *vma;
	gen6_pte_t *pd_addr;
	u32 pp_dir;
	atomic_t pin_count;
	bool scan_for_unused_pt;
};

struct pcpu_gen_cookie;

struct gen_cookie {
	struct pcpu_gen_cookie *local;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	atomic64_t forward_last;
	atomic64_t reverse_last;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct gen_pool;

typedef long unsigned int (*genpool_algo_t)(long unsigned int *, long unsigned int, long unsigned int, unsigned int, void *, struct gen_pool *, long unsigned int);

struct gen_pool {
	spinlock_t lock;
	struct list_head chunks;
	int min_alloc_order;
	genpool_algo_t algo;
	void *data;
	const char *name;
};

struct gen_pool_chunk {
	struct list_head next_chunk;
	atomic_long_t avail;
	phys_addr_t phys_addr;
	void *owner;
	long unsigned int start_addr;
	long unsigned int end_addr;
	long unsigned int bits[0];
};

struct timer_rand_state;

struct gendisk {
	int major;
	int first_minor;
	int minors;
	char disk_name[32];
	short unsigned int events;
	short unsigned int event_flags;
	struct xarray part_tbl;
	struct block_device *part0;
	const struct block_device_operations *fops;
	struct request_queue *queue;
	void *private_data;
	struct bio_set bio_split;
	int flags;
	long unsigned int state;
	struct mutex open_mutex;
	unsigned int open_partitions;
	struct backing_dev_info *bdi;
	struct kobject queue_kobj;
	struct kobject *slave_dir;
	struct list_head slave_bdevs;
	struct timer_rand_state *random;
	atomic_t sync_io;
	struct disk_events *ev;
	struct cdrom_device_info *cdi;
	int node_id;
	struct badblocks *bb;
	struct lockdep_map lockdep_map;
	u64 diskseq;
	blk_mode_t open_mode;
	struct blk_independent_access_ranges *ia_ranges;
};

struct geneve_opt {
	__be16 opt_class;
	u8 type;
	u8 length: 5;
	u8 r3: 1;
	u8 r2: 1;
	u8 r1: 1;
	u8 opt_data[0];
};

struct ocontext;

struct genfs {
	char *fstype;
	struct ocontext *head;
	struct genfs *next;
};

struct netlink_callback;

struct nla_policy;

struct genl_split_ops {
	union {
		struct {
			int (*pre_doit)(const struct genl_split_ops *, struct sk_buff *, struct genl_info *);
			int (*doit)(struct sk_buff *, struct genl_info *);
			void (*post_doit)(const struct genl_split_ops *, struct sk_buff *, struct genl_info *);
		};
		struct {
			int (*start)(struct netlink_callback *);
			int (*dumpit)(struct sk_buff *, struct netlink_callback *);
			int (*done)(struct netlink_callback *);
		};
	};
	const struct nla_policy *policy;
	unsigned int maxattr;
	u8 cmd;
	u8 internal_flags;
	u8 flags;
	u8 validate;
};

struct genlmsghdr;

struct genl_info {
	u32 snd_seq;
	u32 snd_portid;
	const struct genl_family *family;
	const struct nlmsghdr *nlhdr;
	struct genlmsghdr *genlhdr;
	struct nlattr **attrs;
	possible_net_t _net;
	union {
		u8 ctx[48];
		void *user_ptr[2];
	};
	struct netlink_ext_ack *extack;
};

struct genl_dumpit_info {
	struct genl_split_ops op;
	struct genl_info info;
};

struct genl_ops;

struct genl_small_ops;

struct genl_multicast_group;

struct genl_family {
	unsigned int hdrsize;
	char name[16];
	unsigned int version;
	unsigned int maxattr;
	u8 netnsok: 1;
	u8 parallel_ops: 1;
	u8 n_ops;
	u8 n_small_ops;
	u8 n_split_ops;
	u8 n_mcgrps;
	u8 resv_start_op;
	const struct nla_policy *policy;
	int (*pre_doit)(const struct genl_split_ops *, struct sk_buff *, struct genl_info *);
	void (*post_doit)(const struct genl_split_ops *, struct sk_buff *, struct genl_info *);
	int (*bind)(int);
	void (*unbind)(int);
	const struct genl_ops *ops;
	const struct genl_small_ops *small_ops;
	const struct genl_split_ops *split_ops;
	const struct genl_multicast_group *mcgrps;
	struct module *module;
	size_t sock_priv_size;
	void (*sock_priv_init)(void *);
	void (*sock_priv_destroy)(void *);
	int id;
	unsigned int mcgrp_offset;
	struct xarray *sock_privs;
};

struct genl_multicast_group {
	char name[16];
	u8 flags;
};

struct genl_op_iter {
	const struct genl_family *family;
	struct genl_split_ops doit;
	struct genl_split_ops dumpit;
	int cmd_idx;
	int entry_idx;
	u32 cmd;
	u8 flags;
};

struct genl_ops {
	int (*doit)(struct sk_buff *, struct genl_info *);
	int (*start)(struct netlink_callback *);
	int (*dumpit)(struct sk_buff *, struct netlink_callback *);
	int (*done)(struct netlink_callback *);
	const struct nla_policy *policy;
	unsigned int maxattr;
	u8 cmd;
	u8 internal_flags;
	u8 flags;
	u8 validate;
};

struct genl_small_ops {
	int (*doit)(struct sk_buff *, struct genl_info *);
	int (*dumpit)(struct sk_buff *, struct netlink_callback *);
	u8 cmd;
	u8 internal_flags;
	u8 flags;
	u8 validate;
};

struct genl_start_context {
	const struct genl_family *family;
	struct nlmsghdr *nlh;
	struct netlink_ext_ack *extack;
	const struct genl_split_ops *ops;
	int hdrlen;
};

struct genlmsghdr {
	__u8 cmd;
	__u8 version;
	__u16 reserved;
};

struct genpool_data_align {
	int align;
};

struct genpool_data_fixed {
	long unsigned int offset;
};

struct genradix_iter {
	size_t offset;
	size_t pos;
};

struct genradix_node {
	union {
		struct genradix_node *children[64];
		u8 data[512];
	};
};

struct get_key_cookie {
	struct sk_buff *msg;
	int error;
	int idx;
};

struct getcpu_cache {
	long unsigned int blob[16];
};

struct getdents_callback {
	struct dir_context ctx;
	char *name;
	u64 ino;
	int found;
	int sequence;
};

struct linux_dirent;

struct getdents_callback___2 {
	struct dir_context ctx;
	struct linux_dirent *current_dir;
	int prev_reclen;
	int count;
	int error;
};

struct linux_dirent64;

struct getdents_callback64 {
	struct dir_context ctx;
	struct linux_dirent64 *current_dir;
	int prev_reclen;
	int count;
	int error;
};

struct getfsmap_info {
	struct super_block *gi_sb;
	struct fsmap_head *gi_data;
	unsigned int gi_idx;
	__u32 gi_last_flags;
};

struct input_keymap_entry {
	__u8 flags;
	__u8 len;
	__u16 index;
	__u32 keycode;
	__u8 scancode[32];
};

struct getset_keycode_data {
	struct input_keymap_entry ke;
	int error;
};

struct gf128mul_4k {
	be128 t[256];
};

struct gf128mul_64k {
	struct gf128mul_4k *t[16];
};

struct kvm_memory_slot;

struct gfn_to_hva_cache {
	u64 generation;
	gpa_t gpa;
	long unsigned int hva;
	long unsigned int len;
	struct kvm_memory_slot *memslot;
};

struct kvm;

struct gfn_to_pfn_cache {
	u64 generation;
	gpa_t gpa;
	long unsigned int uhva;
	struct kvm_memory_slot *memslot;
	struct kvm *kvm;
	struct list_head list;
	rwlock_t lock;
	struct mutex refresh_lock;
	void *khva;
	kvm_pfn_t pfn;
	bool active;
	bool valid;
};

struct ghash_ctx {
	struct gf128mul_4k *gf128;
};

struct ghash_desc_ctx {
	u8 buffer[16];
	u32 bytes;
};

struct ghcb_save_area {
	u8 reserved_0x0[203];
	u8 cpl;
	u8 reserved_0xcc[116];
	u64 xss;
	u8 reserved_0x148[24];
	u64 dr7;
	u8 reserved_0x168[16];
	u64 rip;
	u8 reserved_0x180[88];
	u64 rsp;
	u8 reserved_0x1e0[24];
	u64 rax;
	u8 reserved_0x200[264];
	u64 rcx;
	u64 rdx;
	u64 rbx;
	u8 reserved_0x320[8];
	u64 rbp;
	u64 rsi;
	u64 rdi;
	u64 r8;
	u64 r9;
	u64 r10;
	u64 r11;
	u64 r12;
	u64 r13;
	u64 r14;
	u64 r15;
	u8 reserved_0x380[16];
	u64 sw_exit_code;
	u64 sw_exit_info_1;
	u64 sw_exit_info_2;
	u64 sw_scratch;
	u8 reserved_0x3b0[56];
	u64 xcr0;
	u8 valid_bitmap[16];
	u64 x87_state_gpa;
};

struct ghcb {
	struct ghcb_save_area save;
	u8 reserved_save[1016];
	u8 shared_buffer[2032];
	u8 reserved_0xff0[10];
	u16 protocol_version;
	u32 ghcb_usage;
};

struct giveback_urb_bh {
	bool running;
	bool high_prio;
	spinlock_t lock;
	struct list_head head;
	struct work_struct bh;
	struct usb_host_endpoint *completing_ep;
};

struct global_params {
	bool no_turbo;
	bool turbo_disabled;
	int max_perf_pct;
	int min_perf_pct;
};

struct gmbus_pin {
	const char *name;
	enum gmbus_gpio gpio;
};

struct tc_stats {
	__u64 bytes;
	__u32 packets;
	__u32 drops;
	__u32 overlimits;
	__u32 bps;
	__u32 pps;
	__u32 qlen;
	__u32 backlog;
};

struct gnet_dump {
	spinlock_t *lock;
	struct sk_buff *skb;
	struct nlattr *tail;
	int compat_tc_stats;
	int compat_xstats;
	int padattr;
	void *xstats;
	int xstats_len;
	struct tc_stats tc_stats;
};

struct gnet_estimator {
	signed char interval;
	unsigned char ewma_log;
};

struct gnet_stats_basic {
	__u64 bytes;
	__u32 packets;
};

struct gnet_stats_rate_est {
	__u32 bps;
	__u32 pps;
};

struct gnet_stats_rate_est64 {
	__u64 bps;
	__u64 pps;
};

struct governor_attr {
	struct attribute attr;
	ssize_t (*show)(struct gov_attr_set *, char *);
	ssize_t (*store)(struct gov_attr_set *, const char *, size_t);
};

struct gpiod_lookup {
	const char *key;
	u16 chip_hwnum;
	const char *con_id;
	unsigned int idx;
	long unsigned int flags;
};

struct gpiod_lookup_table {
	struct list_head list;
	const char *dev_id;
	struct gpiod_lookup table[0];
};

struct gre_base_hdr {
	__be16 flags;
	__be16 protocol;
};

struct gre_full_hdr {
	struct gre_base_hdr fixed_header;
	__be16 csum;
	__be16 reserved1;
	__be32 key;
	__be32 seq;
};

struct gro_cell {
	struct sk_buff_head napi_skbs;
	struct napi_struct napi;
};

struct gro_cells {
	struct gro_cell *cells;
};

struct group_device {
	struct list_head list;
	struct device *dev;
	char *name;
};

struct group_filter {
	union {
		struct {
			__u32 gf_interface_aux;
			struct __kernel_sockaddr_storage gf_group_aux;
			__u32 gf_fmode_aux;
			__u32 gf_numsrc_aux;
			struct __kernel_sockaddr_storage gf_slist[1];
		};
		struct {
			__u32 gf_interface;
			struct __kernel_sockaddr_storage gf_group;
			__u32 gf_fmode;
			__u32 gf_numsrc;
			struct __kernel_sockaddr_storage gf_slist_flex[0];
		};
	};
};

struct group_for_pci_data {
	struct pci_dev *pdev;
	struct iommu_group *group;
};

struct group_info {
	refcount_t usage;
	int ngroups;
	kgid_t gid[0];
};

struct group_req {
	__u32 gr_interface;
	struct __kernel_sockaddr_storage gr_group;
};

struct group_source_req {
	__u32 gsr_interface;
	struct __kernel_sockaddr_storage gsr_group;
	struct __kernel_sockaddr_storage gsr_source;
};

struct gsb_buffer {
	u8 status;
	u8 len;
	union {
		u16 wdata;
		u8 bdata;
		struct {
			struct {} __empty_data;
			u8 data[0];
		};
	};
};

struct gsc_def {
	const char *name;
	long unsigned int bar;
	size_t bar_size;
	bool use_polling;
	bool slow_firmware;
	size_t lmem_size;
};

struct gsc_heci_pkt {
	u64 addr_in;
	u32 size_in;
	u64 addr_out;
	u32 size_out;
};

struct intel_gsc_mtl_header {
	u32 validity_marker;
	u8 heci_client_id;
	u8 reserved1;
	u16 header_version;
	u64 host_session_handle;
	u64 gsc_message_handle;
	u32 message_size;
	u32 flags;
	u32 status;
} __attribute__((packed));

struct intel_gsc_proxy_header {
	u32 hdr;
	u32 source;
	u32 destination;
	u32 status;
};

struct gsc_proxy_msg {
	struct intel_gsc_mtl_header header;
	struct intel_gsc_proxy_header proxy_header;
};

struct intel_context;

struct gsccs_session_resources {
	u64 host_session_handle;
	struct intel_context *ce;
	struct i915_vma *pkt_vma;
	void *pkt_vaddr;
	struct i915_vma *bb_vma;
	void *bb_vaddr;
};

struct rpc_clnt;

struct rpc_pipe_ops;

struct gss_alloc_pdo {
	struct rpc_clnt *clnt;
	const char *name;
	const struct rpc_pipe_ops *upcall_ops;
};

struct rpcsec_gss_oid {
	unsigned int len;
	u8 data[32];
};

struct gss_api_ops;

struct pf_desc;

struct gss_api_mech {
	struct list_head gm_list;
	struct module *gm_owner;
	struct rpcsec_gss_oid gm_oid;
	char *gm_name;
	const struct gss_api_ops *gm_ops;
	int gm_pf_num;
	struct pf_desc *gm_pfs;
	const char *gm_upcall_enctypes;
};

struct gss_ctx;

struct xdr_netobj;

struct gss_api_ops {
	int (*gss_import_sec_context)(const void *, size_t, struct gss_ctx *, time64_t *, gfp_t);
	u32 (*gss_get_mic)(struct gss_ctx *, struct xdr_buf *, struct xdr_netobj *);
	u32 (*gss_verify_mic)(struct gss_ctx *, struct xdr_buf *, struct xdr_netobj *);
	u32 (*gss_wrap)(struct gss_ctx *, int, struct xdr_buf *, struct page **);
	u32 (*gss_unwrap)(struct gss_ctx *, int, int, struct xdr_buf *);
	void (*gss_delete_sec_context)(void *);
};

struct rpc_authops;

struct rpc_cred_cache;

struct rpc_auth {
	unsigned int au_cslack;
	unsigned int au_rslack;
	unsigned int au_verfsize;
	unsigned int au_ralign;
	long unsigned int au_flags;
	const struct rpc_authops *au_ops;
	rpc_authflavor_t au_flavor;
	refcount_t au_count;
	struct rpc_cred_cache *au_credcache;
};

struct gss_pipe;

struct gss_auth {
	struct kref kref;
	struct hlist_node hash;
	struct rpc_auth rpc_auth;
	struct gss_api_mech *mech;
	enum rpc_gss_svc service;
	struct rpc_clnt *client;
	struct net *net;
	netns_tracker ns_tracker;
	struct gss_pipe *gss_pipe[2];
	const char *target_name;
};

struct xdr_netobj {
	unsigned int len;
	u8 *data;
};

struct gss_cl_ctx {
	refcount_t count;
	enum rpc_gss_proc gc_proc;
	u32 gc_seq;
	u32 gc_seq_xmit;
	spinlock_t gc_seq_lock;
	struct gss_ctx *gc_gss_ctx;
	struct xdr_netobj gc_wire_ctx;
	struct xdr_netobj gc_acceptor;
	u32 gc_win;
	long unsigned int gc_expiry;
	struct callback_head gc_rcu;
};

struct rpc_credops;

struct rpc_cred {
	struct hlist_node cr_hash;
	struct list_head cr_lru;
	struct callback_head cr_rcu;
	struct rpc_auth *cr_auth;
	const struct rpc_credops *cr_ops;
	long unsigned int cr_expire;
	long unsigned int cr_flags;
	refcount_t cr_count;
	const struct cred *cr_cred;
};

struct gss_upcall_msg;

struct gss_cred {
	struct rpc_cred gc_base;
	enum rpc_gss_svc gc_service;
	struct gss_cl_ctx *gc_ctx;
	struct gss_upcall_msg *gc_upcall;
	const char *gc_principal;
	long unsigned int gc_upcall_timestamp;
};

struct gss_ctx {
	struct gss_api_mech *mech_type;
	void *internal_ctx_id;
	unsigned int slack;
	unsigned int align;
};

struct gss_domain {
	struct auth_domain h;
	u32 pseudoflavor;
};

struct krb5_ctx;

struct gss_krb5_enctype {
	const u32 etype;
	const u32 ctype;
	const char *name;
	const char *encrypt_name;
	const char *aux_cipher;
	const char *cksum_name;
	const u16 signalg;
	const u16 sealalg;
	const u32 cksumlength;
	const u32 keyed_cksum;
	const u32 keybytes;
	const u32 keylength;
	const u32 Kc_length;
	const u32 Ke_length;
	const u32 Ki_length;
	int (*derive_key)(const struct gss_krb5_enctype *, const struct xdr_netobj *, struct xdr_netobj *, const struct xdr_netobj *, gfp_t);
	u32 (*encrypt)(struct krb5_ctx *, u32, struct xdr_buf *, struct page **);
	u32 (*decrypt)(struct krb5_ctx *, u32, u32, struct xdr_buf *, u32 *, u32 *);
	u32 (*get_mic)(struct krb5_ctx *, struct xdr_buf *, struct xdr_netobj *);
	u32 (*verify_mic)(struct krb5_ctx *, struct xdr_buf *, struct xdr_netobj *);
	u32 (*wrap)(struct krb5_ctx *, int, struct xdr_buf *, struct page **);
	u32 (*unwrap)(struct krb5_ctx *, int, int, struct xdr_buf *, unsigned int *, unsigned int *);
};

struct rpc_pipe_dir_object_ops;

struct rpc_pipe_dir_object {
	struct list_head pdo_head;
	const struct rpc_pipe_dir_object_ops *pdo_ops;
	void *pdo_data;
};

struct rpc_pipe;

struct gss_pipe {
	struct rpc_pipe_dir_object pdo;
	struct rpc_pipe *pipe;
	struct rpc_clnt *clnt;
	const char *name;
	struct kref kref;
};

struct rpc_gss_wire_cred {
	u32 gc_v;
	u32 gc_proc;
	u32 gc_seq;
	u32 gc_svc;
	struct xdr_netobj gc_ctx;
};

struct rsc;

struct gss_svc_data {
	struct rpc_gss_wire_cred clcred;
	u32 gsd_databody_offset;
	struct rsc *rsci;
	__be32 gsd_seq_num;
	u8 gsd_scratch[40];
};

struct gss_svc_seq_data {
	u32 sd_max;
	long unsigned int sd_win[2];
	spinlock_t sd_lock;
};

struct rpc_pipe_msg {
	struct list_head list;
	void *data;
	size_t len;
	size_t copied;
	int errno;
};

struct rpc_timer {
	struct list_head list;
	long unsigned int expires;
	struct delayed_work dwork;
};

struct rpc_wait_queue {
	spinlock_t lock;
	struct list_head tasks[4];
	unsigned char maxpriority;
	unsigned char priority;
	unsigned char nr;
	unsigned int qlen;
	struct rpc_timer timer_list;
	const char *name;
};

struct gss_upcall_msg {
	refcount_t count;
	kuid_t uid;
	const char *service_name;
	struct rpc_pipe_msg msg;
	struct list_head list;
	struct gss_auth *auth;
	struct rpc_pipe *pipe;
	struct rpc_wait_queue rpc_waitqueue;
	wait_queue_head_t waitqueue;
	struct gss_cl_ctx *ctx;
	char databuf[256];
};

struct gssp_in_token {
	struct page **pages;
	unsigned int page_base;
	unsigned int page_len;
};

struct svc_cred {
	kuid_t cr_uid;
	kgid_t cr_gid;
	struct group_info *cr_group_info;
	u32 cr_flavor;
	char *cr_raw_principal;
	char *cr_principal;
	char *cr_targ_princ;
	struct gss_api_mech *cr_gss_mech;
};

struct gssp_upcall_data {
	struct xdr_netobj in_handle;
	struct gssp_in_token in_token;
	struct xdr_netobj out_handle;
	struct xdr_netobj out_token;
	struct rpcsec_gss_oid mech_oid;
	struct svc_cred creds;
	int found_creds;
	int major_status;
	int minor_status;
};

typedef struct xdr_netobj utf8string;

typedef struct xdr_netobj gssx_buffer;

struct gssx_option;

struct gssx_option_array {
	u32 count;
	struct gssx_option *data;
};

struct gssx_call_ctx {
	utf8string locale;
	gssx_buffer server_ctx;
	struct gssx_option_array options;
};

struct gssx_ctx;

struct gssx_cred;

struct gssx_cb;

struct gssx_arg_accept_sec_context {
	struct gssx_call_ctx call_ctx;
	struct gssx_ctx *context_handle;
	struct gssx_cred *cred_handle;
	struct gssp_in_token input_token;
	struct gssx_cb *input_cb;
	u32 ret_deleg_cred;
	struct gssx_option_array options;
	struct page **pages;
	unsigned int npages;
};

struct gssx_cb {
	u64 initiator_addrtype;
	gssx_buffer initiator_address;
	u64 acceptor_addrtype;
	gssx_buffer acceptor_address;
	gssx_buffer application_data;
};

struct gssx_name {
	gssx_buffer display_name;
};

typedef struct gssx_name gssx_name;

struct gssx_cred_element;

struct gssx_cred_element_array {
	u32 count;
	struct gssx_cred_element *data;
};

struct gssx_cred {
	gssx_name desired_name;
	struct gssx_cred_element_array elements;
	gssx_buffer cred_handle_reference;
	u32 needs_release;
};

typedef struct xdr_netobj gssx_OID;

struct gssx_cred_element {
	gssx_name MN;
	gssx_OID mech;
	u32 cred_usage;
	u64 initiator_time_rec;
	u64 acceptor_time_rec;
	struct gssx_option_array options;
};

struct gssx_ctx {
	gssx_buffer exported_context_token;
	gssx_buffer state;
	u32 need_release;
	gssx_OID mech;
	gssx_name src_name;
	gssx_name targ_name;
	u64 lifetime;
	u64 ctx_flags;
	u32 locally_initiated;
	u32 open;
	struct gssx_option_array options;
};

struct gssx_name_attr {
	gssx_buffer attr;
	gssx_buffer value;
	struct gssx_option_array extensions;
};

struct gssx_name_attr_array {
	u32 count;
	struct gssx_name_attr *data;
};

struct gssx_option {
	gssx_buffer option;
	gssx_buffer value;
};

struct gssx_status {
	u64 major_status;
	gssx_OID mech;
	u64 minor_status;
	utf8string major_status_string;
	utf8string minor_status_string;
	gssx_buffer server_ctx;
	struct gssx_option_array options;
};

struct gssx_res_accept_sec_context {
	struct gssx_status status;
	struct gssx_ctx *context_handle;
	gssx_buffer *output_token;
	struct gssx_option_array options;
};

struct gt_defaults {
	u32 min_freq;
	u32 max_freq;
	u8 rps_up_threshold;
	u8 rps_down_threshold;
};

struct guc_ct_buffer_desc {
	u32 head;
	u32 tail;
	u32 status;
	u32 reserved[13];
};

struct guc_ctxt_registration_info {
	u32 flags;
	u32 context_idx;
	u32 engine_class;
	u32 engine_submit_mask;
	u32 wq_desc_lo;
	u32 wq_desc_hi;
	u32 wq_base_lo;
	u32 wq_base_hi;
	u32 wq_size;
	u32 hwlrca_lo;
	u32 hwlrca_hi;
};

struct guc_debug_capture_list_header {
	u32 info;
};

struct guc_debug_capture_list {
	struct guc_debug_capture_list_header header;
	struct guc_mmio_reg regs[0];
};

struct guc_sched_wq_desc {
	u32 head;
	u32 tail;
	u32 error_offset;
	u32 wq_status;
	u32 reserved[28];
};

struct guc_process_desc_v69 {
	u32 stage_id;
	u64 db_base_addr;
	u32 head;
	u32 tail;
	u32 error_offset;
	u64 wq_base_addr;
	u32 wq_size_bytes;
	u32 wq_status;
	u32 engine_presence;
	u32 priority;
	u32 reserved[36];
} __attribute__((packed));

union guc_descs {
	struct guc_sched_wq_desc wq_desc;
	struct guc_process_desc_v69 pdesc;
};

struct intel_ctb_coredump {
	u32 raw_head;
	u32 head;
	u32 raw_tail;
	u32 tail;
	u32 raw_status;
	u32 desc_offset;
	u32 cmds_offset;
	u32 size;
};

struct i915_vma_coredump;

struct guc_info {
	struct intel_ctb_coredump ctb[2];
	struct i915_vma_coredump *vma_ctb;
	struct i915_vma_coredump *vma_log;
	u32 timestamp;
	u16 last_fence;
	bool is_guc_capture;
};

struct guc_log_buffer_state {
	u32 marker[2];
	u32 read_ptr;
	u32 write_ptr;
	u32 size;
	u32 sampled_write_ptr;
	u32 wrap_offset;
	union {
		struct {
			u32 flush_to_file: 1;
			u32 buffer_full_cnt: 4;
			u32 reserved: 27;
		};
		u32 flags;
	};
	u32 version;
};

struct guc_log_section {
	u32 max;
	u32 flag;
	u32 default_val;
	const char *name;
};

struct guc_lrc_desc_v69 {
	u32 hw_context_desc;
	u32 slpm_perf_mode_hint;
	u32 slpm_freq_hint;
	u32 engine_submit_mask;
	u8 engine_class;
	u8 reserved0[3];
	u32 priority;
	u32 process_desc;
	u32 wq_addr;
	u32 wq_size;
	u32 context_flags;
	u32 execution_quantum;
	u32 preemption_timeout;
	u32 policy_flags;
	u32 reserved1[19];
};

struct guc_state_capture_group_header_t {
	u32 owner;
	u32 info;
};

struct guc_state_capture_header_t {
	u32 owner;
	u32 info;
	u32 lrca;
	u32 guc_id;
	u32 num_mmios;
};

struct guc_update_scheduling_policy_header {
	u32 action;
};

struct guc_update_scheduling_policy {
	struct guc_update_scheduling_policy_header header;
	u32 data[3];
};

union intel_engine_tlb_inv_reg {
	i915_reg_t reg;
	i915_mcr_reg_t mcr_reg;
};

struct intel_engine_tlb_inv {
	bool mcr;
	union intel_engine_tlb_inv_reg reg;
	u32 request;
	u32 done;
};

struct intel_sseu {
	u8 slice_mask;
	u8 subslice_mask;
	u8 min_eus_per_subslice;
	u8 max_eus_per_subslice;
};

struct intel_wakeref_ops;

struct intel_wakeref {
	atomic_t count;
	struct mutex mutex;
	intel_wakeref_t wakeref;
	struct drm_i915_private *i915;
	const struct intel_wakeref_ops *ops;
	struct delayed_work work;
};

struct intel_engine_pmu {
	u32 enable;
	unsigned int enable_count[3];
	struct i915_pmu_sample sample[3];
};

struct intel_hw_status_page {
	struct list_head timelines;
	struct i915_vma *vma;
	u32 *addr;
};

struct i915_wa_ctx_bb {
	u32 offset;
	u32 size;
};

struct i915_ctx_workarounds {
	struct i915_wa_ctx_bb indirect_ctx;
	struct i915_wa_ctx_bb per_ctx;
	struct i915_vma *vma;
};

struct i915_wa;

struct i915_wa_list {
	struct intel_gt *gt;
	const char *name;
	const char *engine_name;
	struct i915_wa *list;
	unsigned int count;
	unsigned int wa_count;
};

struct intel_engine_execlists {
	struct timer_list timer;
	struct timer_list preempt;
	const struct i915_request *preempt_target;
	u32 ccid;
	u32 yield;
	u32 error_interrupt;
	u32 reset_ccid;
	u32 *submit_reg;
	u32 *ctrl_reg;
	struct i915_request * const *active;
	struct i915_request *inflight[3];
	struct i915_request *pending[3];
	unsigned int port_mask;
	struct rb_root_cached virtual;
	u32 *csb_write;
	u64 *csb_status;
	u8 csb_size;
	u8 csb_head;
};

struct intel_engine_execlists_stats {
	unsigned int active;
	seqcount_t lock;
	ktime_t total;
	ktime_t start;
};

struct intel_engine_guc_stats {
	bool running;
	u32 prev_total;
	u64 total_gt_clks;
	u64 start_gt_clk;
	u64 total;
};

struct i915_sched_engine;

struct intel_ring;

struct intel_timeline;

struct intel_breadcrumbs;

struct intel_context_ops;

struct i915_perf_group;

struct intel_engine_cs {
	struct drm_i915_private *i915;
	struct intel_gt *gt;
	struct intel_uncore *uncore;
	char name[8];
	enum intel_engine_id id;
	enum intel_engine_id legacy_idx;
	unsigned int guc_id;
	intel_engine_mask_t mask;
	u32 reset_domain;
	intel_engine_mask_t logical_mask;
	u8 class;
	u8 instance;
	u16 uabi_class;
	u16 uabi_instance;
	u32 uabi_capabilities;
	u32 context_size;
	u32 mmio_base;
	struct intel_engine_tlb_inv tlb_inv;
	enum forcewake_domains fw_domain;
	unsigned int fw_active;
	long unsigned int context_tag;
	union {
		struct llist_node uabi_llist;
		struct list_head uabi_list;
		struct rb_node uabi_node;
	};
	struct intel_sseu sseu;
	struct i915_sched_engine *sched_engine;
	struct i915_request *request_pool;
	struct intel_context *hung_ce;
	struct llist_head barrier_tasks;
	struct intel_context *kernel_context;
	struct intel_context *bind_context;
	bool bind_context_ready;
	struct list_head pinned_contexts_list;
	intel_engine_mask_t saturated;
	struct {
		struct delayed_work work;
		struct i915_request *systole;
		long unsigned int blocked;
	} heartbeat;
	long unsigned int serial;
	long unsigned int wakeref_serial;
	intel_wakeref_t wakeref_track;
	struct intel_wakeref wakeref;
	struct file *default_state;
	struct {
		struct intel_ring *ring;
		struct intel_timeline *timeline;
	} legacy;
	struct ewma__engine_latency latency;
	struct intel_breadcrumbs *breadcrumbs;
	struct intel_engine_pmu pmu;
	struct intel_hw_status_page status_page;
	struct i915_ctx_workarounds wa_ctx;
	struct i915_wa_list ctx_wa_list;
	struct i915_wa_list wa_list;
	struct i915_wa_list whitelist;
	u32 irq_keep_mask;
	u32 irq_enable_mask;
	void (*irq_enable)(struct intel_engine_cs *);
	void (*irq_disable)(struct intel_engine_cs *);
	void (*irq_handler)(struct intel_engine_cs *, u16);
	void (*sanitize)(struct intel_engine_cs *);
	int (*resume)(struct intel_engine_cs *);
	struct {
		void (*prepare)(struct intel_engine_cs *);
		void (*rewind)(struct intel_engine_cs *, bool);
		void (*cancel)(struct intel_engine_cs *);
		void (*finish)(struct intel_engine_cs *);
	} reset;
	void (*park)(struct intel_engine_cs *);
	void (*unpark)(struct intel_engine_cs *);
	void (*bump_serial)(struct intel_engine_cs *);
	void (*set_default_submission)(struct intel_engine_cs *);
	const struct intel_context_ops *cops;
	int (*request_alloc)(struct i915_request *);
	int (*emit_flush)(struct i915_request *, u32);
	int (*emit_bb_start)(struct i915_request *, u64, u32, unsigned int);
	int (*emit_init_breadcrumb)(struct i915_request *);
	u32 * (*emit_fini_breadcrumb)(struct i915_request *, u32 *);
	unsigned int emit_fini_breadcrumb_dw;
	void (*submit_request)(struct i915_request *);
	void (*release)(struct intel_engine_cs *);
	void (*add_active_request)(struct i915_request *);
	void (*remove_active_request)(struct i915_request *);
	ktime_t (*busyness)(struct intel_engine_cs *, ktime_t *);
	struct intel_engine_execlists execlists;
	struct intel_timeline *retire;
	struct work_struct retire_work;
	struct atomic_notifier_head context_status_notifier;
	unsigned int flags;
	struct hlist_head cmd_hash[512];
	const struct drm_i915_reg_table *reg_tables;
	int reg_table_count;
	u32 (*get_cmd_length_mask)(u32);
	struct {
		union {
			struct intel_engine_execlists_stats execlists;
			struct intel_engine_guc_stats guc;
		};
		ktime_t rps;
	} stats;
	struct {
		long unsigned int heartbeat_interval_ms;
		long unsigned int max_busywait_duration_ns;
		long unsigned int preempt_timeout_ms;
		long unsigned int stop_timeout_ms;
		long unsigned int timeslice_duration_ms;
	} props;
	struct {
		long unsigned int heartbeat_interval_ms;
		long unsigned int max_busywait_duration_ns;
		long unsigned int preempt_timeout_ms;
		long unsigned int stop_timeout_ms;
		long unsigned int timeslice_duration_ms;
	} defaults;
	struct i915_perf_group *oa_group;
};

struct intel_context_stats {
	u64 active;
	struct {
		struct ewma_runtime avg;
		u64 total;
		u32 last;
	} runtime;
};

struct i915_gem_context;

struct intel_context {
	union {
		struct kref ref;
		struct callback_head rcu;
	};
	struct intel_engine_cs *engine;
	struct intel_engine_cs *inflight;
	struct i915_address_space *vm;
	struct i915_gem_context *gem_context;
	struct file *default_state;
	struct list_head signal_link;
	struct list_head signals;
	spinlock_t signal_lock;
	struct i915_vma *state;
	u32 ring_size;
	struct intel_ring *ring;
	struct intel_timeline *timeline;
	intel_wakeref_t wakeref;
	long unsigned int flags;
	struct {
		u64 timeout_us;
	} watchdog;
	u32 *lrc_reg_state;
	union {
		struct {
			u32 lrca;
			u32 ccid;
		};
		u64 desc;
	} lrc;
	u32 tag;
	struct intel_context_stats stats;
	unsigned int active_count;
	atomic_t pin_count;
	struct mutex pin_mutex;
	struct i915_active active;
	const struct intel_context_ops *ops;
	struct intel_sseu sseu;
	struct list_head pinned_contexts_link;
	u8 wa_bb_page;
	struct {
		spinlock_t lock;
		u32 sched_state;
		struct list_head fences;
		struct i915_sw_fence blocked;
		struct list_head requests;
		u8 prio;
		u32 prio_count[4];
		struct delayed_work sched_disable_delay_work;
	} guc_state;
	struct {
		u16 id;
		atomic_t ref;
		struct list_head link;
	} guc_id;
	struct list_head destroyed_link;
	struct {
		union {
			struct list_head child_list;
			struct list_head child_link;
		};
		struct intel_context *parent;
		struct i915_request *last_rq;
		u64 fence_context;
		u32 seqno;
		u8 number_children;
		u8 child_index;
		struct {
			u16 wqi_head;
			u16 wqi_tail;
			u32 *wq_head;
			u32 *wq_tail;
			u32 *wq_status;
			u8 parent_page;
		} guc;
	} parallel;
};

struct guc_virtual_engine {
	struct intel_engine_cs base;
	struct intel_context context;
};

struct guid_block {
	guid_t guid;
	union {
		char object_id[2];
		struct {
			unsigned char notify_id;
			unsigned char reserved;
		};
	};
	u8 instance_count;
	u8 flags;
};

union handle_parts {
	depot_stack_handle_t handle;
	struct {
		u32 pool_index_plus_1: 17;
		u32 offset: 10;
		u32 extra: 5;
	};
};

struct handle_to_path_ctx {
	struct path root;
	enum handle_to_path_flags flags;
	unsigned int fh_flags;
};

struct handshake_net {
	spinlock_t hn_lock;
	int hn_pending;
	int hn_pending_max;
	struct list_head hn_requests;
	long unsigned int hn_flags;
};

struct handshake_req;

struct handshake_proto {
	int hp_handler_class;
	size_t hp_privsize;
	long unsigned int hp_flags;
	int (*hp_accept)(struct handshake_req *, struct genl_info *, int);
	void (*hp_done)(struct handshake_req *, unsigned int, struct genl_info *);
	void (*hp_destroy)(struct handshake_req *);
};

struct handshake_req {
	struct list_head hr_list;
	struct rhash_head hr_rhash;
	long unsigned int hr_flags;
	const struct handshake_proto *hr_proto;
	struct sock *hr_sk;
	void (*hr_odestruct)(struct sock *);
	char hr_priv[0];
};

struct hash {
	int ino;
	int minor;
	int major;
	umode_t mode;
	struct hash *next;
	char name[4098];
};

struct hash_cell {
	struct rb_node name_node;
	struct rb_node uuid_node;
	bool name_set;
	bool uuid_set;
	char *name;
	char *uuid;
	struct mapped_device *md;
	struct dm_table *new_map;
};

struct hash_prefix {
	const char *name;
	const u8 *data;
	size_t size;
};

struct hashtab_key_params {
	u32 (*hash)(const void *);
	int (*cmp)(const void *, const void *);
};

struct hashtab_node {
	void *key;
	void *datum;
	struct hashtab_node *next;
};

struct mei_client_properties {
	uuid_le protocol_name;
	u8 protocol_version;
	u8 max_number_of_connections;
	u8 fixed_address;
	u8 single_recv_buf: 1;
	u8 vt_supported: 1;
	u8 reserved: 6;
	u32 max_msg_length;
};

struct hbm_add_client_request {
	u8 hbm_cmd;
	u8 me_addr;
	u8 reserved[2];
	struct mei_client_properties client_properties;
};

struct hbm_add_client_response {
	u8 hbm_cmd;
	u8 me_addr;
	u8 status;
	u8 reserved;
};

struct hbm_capability_request {
	u8 hbm_cmd;
	u8 capability_requested[3];
};

struct hbm_capability_response {
	u8 hbm_cmd;
	u8 capability_granted[3];
};

struct hbm_client_connect_request {
	u8 hbm_cmd;
	u8 me_addr;
	u8 host_addr;
	u8 reserved;
};

struct hbm_client_connect_response {
	u8 hbm_cmd;
	u8 me_addr;
	u8 host_addr;
	u8 status;
};

struct hbm_client_dma_map_request {
	u8 hbm_cmd;
	u8 client_buffer_id;
	u8 reserved[2];
	u32 address_lsb;
	u32 address_msb;
	u32 size;
};

struct hbm_client_dma_response {
	u8 hbm_cmd;
	u8 status;
};

struct hbm_client_dma_unmap_request {
	u8 hbm_cmd;
	u8 status;
	u8 client_buffer_id;
	u8 reserved;
};

struct hbm_dma_mem_dscr {
	u32 addr_hi;
	u32 addr_lo;
	u32 size;
};

struct hbm_dma_ring_ctrl {
	u32 hbuf_wr_idx;
	u32 reserved1;
	u32 hbuf_rd_idx;
	u32 reserved2;
	u32 dbuf_wr_idx;
	u32 reserved3;
	u32 dbuf_rd_idx;
	u32 reserved4;
};

struct hbm_dma_setup_request {
	u8 hbm_cmd;
	u8 reserved[3];
	struct hbm_dma_mem_dscr dma_dscr[3];
};

struct hbm_dma_setup_response {
	u8 hbm_cmd;
	u8 status;
	u8 reserved[2];
};

struct hbm_flow_control {
	u8 hbm_cmd;
	u8 me_addr;
	u8 host_addr;
	u8 reserved[5];
};

struct hbm_host_enum_request {
	u8 hbm_cmd;
	u8 flags;
	u8 reserved[2];
};

struct hbm_host_enum_response {
	u8 hbm_cmd;
	u8 reserved[3];
	u8 valid_addresses[32];
};

struct hbm_host_stop_request {
	u8 hbm_cmd;
	u8 reason;
	u8 reserved[2];
};

struct hbm_version {
	u8 minor_version;
	u8 major_version;
};

struct hbm_host_version_request {
	u8 hbm_cmd;
	u8 reserved;
	struct hbm_version host_version;
};

struct hbm_host_version_response {
	u8 hbm_cmd;
	u8 host_version_supported;
	struct hbm_version me_max_version;
};

struct hbm_notification_request {
	u8 hbm_cmd;
	u8 me_addr;
	u8 host_addr;
	u8 start;
};

struct hbm_notification_response {
	u8 hbm_cmd;
	u8 me_addr;
	u8 host_addr;
	u8 status;
	u8 start;
	u8 reserved[3];
};

struct hbm_power_gate {
	u8 hbm_cmd;
	u8 reserved[3];
};

struct hbm_props_request {
	u8 hbm_cmd;
	u8 me_addr;
	u8 reserved[2];
};

struct hbm_props_response {
	u8 hbm_cmd;
	u8 me_addr;
	u8 status;
	u8 reserved;
	struct mei_client_properties client_properties;
};

struct hc_driver {
	const char *description;
	const char *product_desc;
	size_t hcd_priv_size;
	irqreturn_t (*irq)(struct usb_hcd *);
	int flags;
	int (*reset)(struct usb_hcd *);
	int (*start)(struct usb_hcd *);
	int (*pci_suspend)(struct usb_hcd *, bool);
	int (*pci_resume)(struct usb_hcd *, pm_message_t);
	int (*pci_poweroff_late)(struct usb_hcd *, bool);
	void (*stop)(struct usb_hcd *);
	void (*shutdown)(struct usb_hcd *);
	int (*get_frame_number)(struct usb_hcd *);
	int (*urb_enqueue)(struct usb_hcd *, struct urb *, gfp_t);
	int (*urb_dequeue)(struct usb_hcd *, struct urb *, int);
	int (*map_urb_for_dma)(struct usb_hcd *, struct urb *, gfp_t);
	void (*unmap_urb_for_dma)(struct usb_hcd *, struct urb *);
	void (*endpoint_disable)(struct usb_hcd *, struct usb_host_endpoint *);
	void (*endpoint_reset)(struct usb_hcd *, struct usb_host_endpoint *);
	int (*hub_status_data)(struct usb_hcd *, char *);
	int (*hub_control)(struct usb_hcd *, u16, u16, u16, char *, u16);
	int (*bus_suspend)(struct usb_hcd *);
	int (*bus_resume)(struct usb_hcd *);
	int (*start_port_reset)(struct usb_hcd *, unsigned int);
	long unsigned int (*get_resuming_ports)(struct usb_hcd *);
	void (*relinquish_port)(struct usb_hcd *, int);
	int (*port_handed_over)(struct usb_hcd *, int);
	void (*clear_tt_buffer_complete)(struct usb_hcd *, struct usb_host_endpoint *);
	int (*alloc_dev)(struct usb_hcd *, struct usb_device *);
	void (*free_dev)(struct usb_hcd *, struct usb_device *);
	int (*alloc_streams)(struct usb_hcd *, struct usb_device *, struct usb_host_endpoint **, unsigned int, unsigned int, gfp_t);
	int (*free_streams)(struct usb_hcd *, struct usb_device *, struct usb_host_endpoint **, unsigned int, gfp_t);
	int (*add_endpoint)(struct usb_hcd *, struct usb_device *, struct usb_host_endpoint *);
	int (*drop_endpoint)(struct usb_hcd *, struct usb_device *, struct usb_host_endpoint *);
	int (*check_bandwidth)(struct usb_hcd *, struct usb_device *);
	void (*reset_bandwidth)(struct usb_hcd *, struct usb_device *);
	int (*address_device)(struct usb_hcd *, struct usb_device *, unsigned int);
	int (*enable_device)(struct usb_hcd *, struct usb_device *);
	int (*update_hub_device)(struct usb_hcd *, struct usb_device *, struct usb_tt *, gfp_t);
	int (*reset_device)(struct usb_hcd *, struct usb_device *);
	int (*update_device)(struct usb_hcd *, struct usb_device *);
	int (*set_usb2_hw_lpm)(struct usb_hcd *, struct usb_device *, int);
	int (*enable_usb3_lpm_timeout)(struct usb_hcd *, struct usb_device *, enum usb3_link_state);
	int (*disable_usb3_lpm_timeout)(struct usb_hcd *, struct usb_device *, enum usb3_link_state);
	int (*find_raw_port_number)(struct usb_hcd *, int);
	int (*port_power)(struct usb_hcd *, int, bool);
	int (*submit_single_step_set_feature)(struct usb_hcd *, struct urb *, int);
};

struct hd_geometry {
	unsigned char heads;
	unsigned char sectors;
	short unsigned int cylinders;
	long unsigned int start;
};

struct hda_amp_list {
	hda_nid_t nid;
	unsigned char dir;
	unsigned char idx;
};

struct hda_beep {
	struct input_dev *dev;
	struct hda_codec *codec;
	char phys[32];
	int tone;
	hda_nid_t nid;
	unsigned int registered: 1;
	unsigned int enabled: 1;
	unsigned int linear_tone: 1;
	unsigned int playing: 1;
	unsigned int keep_power_at_enable: 1;
	struct work_struct beep_work;
	void (*power_hook)(struct hda_beep *, bool);
};

struct snd_array {
	unsigned int used;
	unsigned int alloced;
	unsigned int elem_size;
	unsigned int alloc_align;
	void *list;
};

struct hdac_widget_tree;

struct regmap;

struct hdac_device {
	struct device dev;
	int type;
	struct hdac_bus *bus;
	unsigned int addr;
	struct list_head list;
	hda_nid_t afg;
	hda_nid_t mfg;
	unsigned int vendor_id;
	unsigned int subsystem_id;
	unsigned int revision_id;
	unsigned int afg_function_id;
	unsigned int mfg_function_id;
	unsigned int afg_unsol: 1;
	unsigned int mfg_unsol: 1;
	unsigned int power_caps;
	const char *vendor_name;
	const char *chip_name;
	int (*exec_verb)(struct hdac_device *, unsigned int, unsigned int, unsigned int *);
	unsigned int num_nodes;
	hda_nid_t start_nid;
	hda_nid_t end_nid;
	atomic_t in_pm;
	struct mutex widget_lock;
	struct hdac_widget_tree *widgets;
	struct regmap *regmap;
	struct mutex regmap_lock;
	struct snd_array vendor_verbs;
	bool lazy_cache: 1;
	bool caps_overwriting: 1;
	bool cache_coef: 1;
	unsigned int registered: 1;
};

struct hda_codec_ops {
	int (*build_controls)(struct hda_codec *);
	int (*build_pcms)(struct hda_codec *);
	int (*init)(struct hda_codec *);
	void (*free)(struct hda_codec *);
	void (*unsol_event)(struct hda_codec *, unsigned int);
	void (*set_power_state)(struct hda_codec *, hda_nid_t, unsigned int);
	int (*suspend)(struct hda_codec *);
	int (*resume)(struct hda_codec *);
	int (*check_power_status)(struct hda_codec *, hda_nid_t);
	void (*stream_pm)(struct hda_codec *, hda_nid_t, bool);
};

struct hda_device_id;

struct snd_hwdep;

struct snd_info_buffer;

struct hda_fixup;

struct hda_codec {
	struct hdac_device core;
	struct hda_bus *bus;
	struct snd_card *card;
	unsigned int addr;
	u32 probe_id;
	const struct hda_device_id *preset;
	const char *modelname;
	struct hda_codec_ops patch_ops;
	struct list_head pcm_list_head;
	refcount_t pcm_ref;
	wait_queue_head_t remove_sleep;
	void *spec;
	struct hda_beep *beep;
	unsigned int beep_mode;
	u32 *wcaps;
	struct snd_array mixers;
	struct snd_array nids;
	struct list_head conn_list;
	struct mutex spdif_mutex;
	struct mutex control_mutex;
	struct snd_array spdif_out;
	unsigned int spdif_in_enable;
	const hda_nid_t *follower_dig_outs;
	struct snd_array init_pins;
	struct snd_array driver_pins;
	struct snd_array cvt_setups;
	struct mutex user_mutex;
	struct snd_hwdep *hwdep;
	unsigned int configured: 1;
	unsigned int in_freeing: 1;
	unsigned int display_power_control: 1;
	unsigned int spdif_status_reset: 1;
	unsigned int pin_amp_workaround: 1;
	unsigned int single_adc_amp: 1;
	unsigned int no_sticky_stream: 1;
	unsigned int pins_shutup: 1;
	unsigned int no_trigger_sense: 1;
	unsigned int no_jack_detect: 1;
	unsigned int inv_eapd: 1;
	unsigned int inv_jack_detect: 1;
	unsigned int pcm_format_first: 1;
	unsigned int cached_write: 1;
	unsigned int dp_mst: 1;
	unsigned int dump_coef: 1;
	unsigned int power_save_node: 1;
	unsigned int auto_runtime_pm: 1;
	unsigned int force_pin_prefix: 1;
	unsigned int link_down_at_suspend: 1;
	unsigned int relaxed_resume: 1;
	unsigned int forced_resume: 1;
	unsigned int no_stream_clean_at_suspend: 1;
	unsigned int ctl_dev_id: 1;
	long unsigned int power_on_acct;
	long unsigned int power_off_acct;
	long unsigned int power_jiffies;
	unsigned int (*power_filter)(struct hda_codec *, hda_nid_t, unsigned int);
	void (*proc_widget_hook)(struct snd_info_buffer *, struct hda_codec *, hda_nid_t);
	struct snd_array jacktbl;
	long unsigned int jackpoll_interval;
	struct delayed_work jackpoll_work;
	int depop_delay;
	int fixup_id;
	const struct hda_fixup *fixup_list;
	const char *fixup_name;
	struct snd_array verbs;
};

struct hdac_driver {
	struct device_driver driver;
	int type;
	const struct hda_device_id *id_table;
	int (*match)(struct hdac_device *, struct hdac_driver *);
	void (*unsol_event)(struct hdac_device *, unsigned int);
	int (*probe)(struct hdac_device *);
	int (*remove)(struct hdac_device *);
	void (*shutdown)(struct hdac_device *);
};

struct hda_codec_driver {
	struct hdac_driver core;
	const struct hda_device_id *id;
};

struct hda_conn_list {
	struct list_head list;
	int len;
	hda_nid_t nid;
	hda_nid_t conns[0];
};

struct hda_controller_ops {
	int (*disable_msi_reset_irq)(struct azx *);
	int (*position_check)(struct azx *, struct azx_dev *);
	int (*link_power)(struct azx *, bool);
};

struct hda_cvt_setup {
	hda_nid_t nid;
	u8 stream_tag;
	u8 channel_id;
	u16 format_id;
	unsigned char active;
	unsigned char dirty;
};

struct hda_device_id {
	__u32 vendor_id;
	__u32 rev_id;
	__u8 api_version;
	const char *name;
	long unsigned int driver_data;
};

struct hda_pintbl;

struct hda_verb;

struct hda_fixup {
	int type;
	bool chained: 1;
	bool chained_before: 1;
	int chain_id;
	union {
		const struct hda_pintbl *pins;
		const struct hda_verb *verbs;
		void (*func)(struct hda_codec *, const struct hda_fixup *, int);
	} v;
};

struct hda_input_mux_item {
	char label[32];
	unsigned int index;
};

struct hda_input_mux {
	unsigned int num_items;
	struct hda_input_mux_item items[36];
};

struct hda_intel {
	struct azx chip;
	struct work_struct irq_pending_work;
	struct completion probe_wait;
	struct delayed_work probe_work;
	struct list_head list;
	unsigned int irq_pending_warned: 1;
	unsigned int probe_continued: 1;
	unsigned int runtime_pm_disabled: 1;
	unsigned int use_vga_switcheroo: 1;
	unsigned int vga_switcheroo_registered: 1;
	unsigned int init_failed: 1;
	unsigned int freed: 1;
	bool need_i915_power: 1;
	int probe_retry;
};

struct hda_jack_callback;

typedef void (*hda_jack_callback_fn)(struct hda_codec *, struct hda_jack_callback *);

struct hda_jack_tbl;

struct hda_jack_callback {
	hda_nid_t nid;
	int dev_id;
	hda_jack_callback_fn func;
	unsigned int private_data;
	unsigned int unsol_res;
	struct hda_jack_tbl *jack;
	struct hda_jack_callback *next;
};

struct hda_jack_keymap {
	enum snd_jack_types type;
	int key;
};

struct snd_jack;

struct hda_jack_tbl {
	hda_nid_t nid;
	int dev_id;
	unsigned char tag;
	struct hda_jack_callback *callback;
	unsigned int pin_sense;
	unsigned int jack_detect: 1;
	unsigned int jack_dirty: 1;
	unsigned int phantom_jack: 1;
	unsigned int block_report: 1;
	hda_nid_t gating_jack;
	hda_nid_t gated_jack;
	hda_nid_t key_report_jack;
	int type;
	int button_state;
	struct snd_jack *jack;
};

struct hda_loopback_check {
	const struct hda_amp_list *amplist;
	int power_on;
};

struct hda_model_fixup {
	const int id;
	const char *name;
};

struct hda_multi_out {
	int num_dacs;
	const hda_nid_t *dac_nids;
	hda_nid_t hp_nid;
	hda_nid_t hp_out_nid[5];
	hda_nid_t extra_out_nid[5];
	hda_nid_t dig_out_nid;
	const hda_nid_t *follower_dig_outs;
	int max_channels;
	int dig_out_used;
	int no_share_stream;
	int share_spdif;
	unsigned int analog_rates;
	unsigned int analog_maxbps;
	u64 analog_formats;
	unsigned int spdif_rates;
	unsigned int spdif_maxbps;
	u64 spdif_formats;
};

struct snd_kcontrol;

struct hda_nid_item {
	struct snd_kcontrol *kctl;
	unsigned int index;
	hda_nid_t nid;
	short unsigned int flags;
};

struct hda_pcm_stream;

struct hda_pcm_ops {
	int (*open)(struct hda_pcm_stream *, struct hda_codec *, struct snd_pcm_substream *);
	int (*close)(struct hda_pcm_stream *, struct hda_codec *, struct snd_pcm_substream *);
	int (*prepare)(struct hda_pcm_stream *, struct hda_codec *, unsigned int, unsigned int, struct snd_pcm_substream *);
	int (*cleanup)(struct hda_pcm_stream *, struct hda_codec *, struct snd_pcm_substream *);
	unsigned int (*get_delay)(struct hda_pcm_stream *, struct hda_codec *, struct snd_pcm_substream *);
};

struct snd_pcm_chmap_elem;

struct hda_pcm_stream {
	unsigned int substreams;
	unsigned int channels_min;
	unsigned int channels_max;
	hda_nid_t nid;
	u32 rates;
	u64 formats;
	u32 subformats;
	unsigned int maxbps;
	const struct snd_pcm_chmap_elem *chmap;
	struct hda_pcm_ops ops;
};

struct hda_pcm {
	char *name;
	struct hda_pcm_stream stream[2];
	unsigned int pcm_type;
	int device;
	struct snd_pcm *pcm;
	bool own_chmap;
	struct hda_codec *codec;
	struct list_head list;
	unsigned int disconnected: 1;
};

struct hda_pincfg {
	hda_nid_t nid;
	unsigned char ctrl;
	unsigned char target;
	unsigned int cfg;
};

struct hda_pintbl {
	hda_nid_t nid;
	u32 val;
};

struct hda_quirk {
	short unsigned int subvendor;
	short unsigned int subdevice;
	short unsigned int subdevice_mask;
	bool match_codec_ssid;
	int value;
};

struct hda_rate_tbl {
	unsigned int hz;
	unsigned int alsa_bits;
	unsigned int hda_fmt;
};

struct hda_spdif_out {
	hda_nid_t nid;
	unsigned int status;
	short unsigned int ctls;
};

struct hda_vendor_id {
	unsigned int id;
	const char *name;
};

struct hda_verb {
	hda_nid_t nid;
	u32 verb;
	u32 param;
};

struct hda_verb_ioctl {
	u32 verb;
	u32 res;
};

struct hda_vmaster_mute_hook {
	struct snd_kcontrol *sw_kctl;
	void (*hook)(void *, int);
	struct hda_codec *codec;
};

struct hdac_bus_ops {
	int (*command)(struct hdac_bus *, unsigned int);
	int (*get_response)(struct hdac_bus *, unsigned int, unsigned int *);
	void (*link_power)(struct hdac_device *, bool);
};

struct hdac_cea_channel_speaker_allocation {
	int ca_index;
	int speakers[8];
	int channels;
	int spk_mask;
};

struct hdac_chmap;

struct hdac_chmap_ops {
	int (*chmap_cea_alloc_validate_get_type)(struct hdac_chmap *, struct hdac_cea_channel_speaker_allocation *, int);
	void (*cea_alloc_to_tlv_chmap)(struct hdac_chmap *, struct hdac_cea_channel_speaker_allocation *, unsigned int *, int);
	int (*chmap_validate)(struct hdac_chmap *, int, int, unsigned char *);
	int (*get_spk_alloc)(struct hdac_device *, int);
	void (*get_chmap)(struct hdac_device *, int, unsigned char *);
	void (*set_chmap)(struct hdac_device *, int, unsigned char *, int);
	bool (*is_pcm_attached)(struct hdac_device *, int);
	int (*pin_get_slot_channel)(struct hdac_device *, hda_nid_t, int);
	int (*pin_set_slot_channel)(struct hdac_device *, hda_nid_t, int, int);
	void (*set_channel_count)(struct hdac_device *, hda_nid_t, int);
};

struct hdac_chmap {
	unsigned int channels_max;
	struct hdac_chmap_ops ops;
	struct hdac_device *hdac;
};

struct hdac_ext_bus_ops {
	int (*hdev_attach)(struct hdac_device *);
	int (*hdev_detach)(struct hdac_device *);
};

struct hdac_widget_tree {
	struct kobject *root;
	struct kobject *afg;
	struct kobject **nodes;
};

struct hdcp2_tx_caps {
	u8 version;
	u8 tx_cap_mask[2];
};

struct hdcp2_ake_init {
	u8 msg_id;
	u8 r_tx[8];
	struct hdcp2_tx_caps tx_caps;
};

struct hdcp2_ake_no_stored_km {
	u8 msg_id;
	u8 e_kpub_km[128];
};

struct hdcp2_cert_rx {
	u8 receiver_id[5];
	u8 kpub_rx[131];
	u8 reserved[2];
	u8 dcp_signature[384];
};

struct hdcp2_ake_send_cert {
	u8 msg_id;
	struct hdcp2_cert_rx cert_rx;
	u8 r_rx[8];
	u8 rx_caps[3];
};

struct hdcp2_ake_send_hprime {
	u8 msg_id;
	u8 h_prime[32];
};

struct hdcp2_ake_send_pairing_info {
	u8 msg_id;
	u8 e_kh_km[16];
};

struct hdcp2_dp_errata_stream_type {
	u8 msg_id;
	u8 stream_type;
};

struct hdcp2_dp_msg_data {
	u8 msg_id;
	u32 offset;
	bool msg_detectable;
	u32 timeout;
	u32 timeout2;
	u32 msg_read_timeout;
};

struct hdcp2_hdmi_msg_timeout {
	u8 msg_id;
	u16 timeout;
};

struct hdcp2_lc_init {
	u8 msg_id;
	u8 r_n[8];
};

struct hdcp2_lc_send_lprime {
	u8 msg_id;
	u8 l_prime[32];
};

struct hdcp2_rep_send_ack {
	u8 msg_id;
	u8 v[16];
};

struct hdcp2_rep_send_receiverid_list {
	u8 msg_id;
	u8 rx_info[2];
	u8 seq_num_v[3];
	u8 v_prime[16];
	u8 receiver_ids[155];
};

struct hdcp2_streamid_type {
	u8 stream_id;
	u8 stream_type;
};

struct hdcp2_rep_stream_manage {
	u8 msg_id;
	u8 seq_num_m[3];
	__be16 k;
	struct hdcp2_streamid_type streams[4];
};

struct hdcp2_rep_stream_ready {
	u8 msg_id;
	u8 m_prime[32];
};

struct hdcp2_ske_send_eks {
	u8 msg_id;
	u8 e_dkey_ks[16];
	u8 riv[8];
};

struct hdcp_cmd_header {
	u32 api_version;
	u32 command_id;
	enum fw_hdcp_status status;
	u32 buffer_len;
};

struct hdcp_port_data {
	enum hdcp_ddi hdcp_ddi;
	enum hdcp_transcoder hdcp_transcoder;
	u8 port_type;
	u8 protocol;
	u16 k;
	u32 seq_num_m;
	struct hdcp2_streamid_type *streams;
};

struct hdcp_port_id {
	u8 integrated_port_type;
	u8 physical_port;
	u8 attached_transcoder;
	u8 reserved;
};

struct hdcp_srm_header {
	u8 srm_id;
	u8 reserved;
	__be16 srm_version;
	u8 srm_gen_no;
} __attribute__((packed));

struct hdmi_aud_ncts {
	int sample_rate;
	int clock;
	int n;
	int cts;
};

struct hdr_metadata_infoframe {
	__u8 eotf;
	__u8 metadata_type;
	struct {
		__u16 x;
		__u16 y;
	} display_primaries[3];
	struct {
		__u16 x;
		__u16 y;
	} white_point;
	__u16 max_display_mastering_luminance;
	__u16 min_display_mastering_luminance;
	__u16 max_cll;
	__u16 max_fall;
};

struct hdr_output_metadata {
	__u32 metadata_type;
	union {
		struct hdr_metadata_infoframe hdmi_metadata_type1;
	};
};

struct hh_cache;

struct header_ops {
	int (*create)(struct sk_buff *, struct net_device *, short unsigned int, const void *, const void *, unsigned int);
	int (*parse)(const struct sk_buff *, unsigned char *);
	int (*cache)(const struct neighbour *, struct hh_cache *, __be16);
	void (*cache_update)(struct hh_cache *, const struct net_device *, const unsigned char *);
	bool (*validate)(const char *, unsigned int);
	__be16 (*parse_protocol)(const struct sk_buff *);
};

struct hh_cache {
	unsigned int hh_len;
	seqlock_t hh_lock;
	long unsigned int hh_data[12];
};

struct hib_bio_batch {
	atomic_t count;
	wait_queue_head_t wait;
	blk_status_t error;
	struct blk_plug plug;
};

struct hid_class_descriptor {
	__u8 bDescriptorType;
	__le16 wDescriptorLength;
} __attribute__((packed));

struct hid_collection {
	int parent_idx;
	unsigned int type;
	unsigned int usage;
	unsigned int level;
};

struct hid_control_fifo {
	unsigned char dir;
	struct hid_report *report;
	char *raw_report;
};

struct hid_debug_list {
	struct {
		union {
			struct __kfifo kfifo;
			char *type;
			const char *const_type;
			char (*rectype)[0];
			char *ptr;
			const char *ptr_const;
		};
		char buf[0];
	} hid_debug_fifo;
	struct fasync_struct *fasync;
	struct hid_device *hdev;
	struct list_head node;
	struct mutex read_mutex;
};

struct hid_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__le16 bcdHID;
	__u8 bCountryCode;
	__u8 bNumDescriptors;
	struct hid_class_descriptor desc[1];
} __attribute__((packed));

struct hid_report_enum {
	unsigned int numbered;
	struct list_head report_list;
	struct hid_report *report_id_hash[256];
};

struct hid_driver;

struct hid_ll_driver;

struct hid_field;

struct hid_usage;

struct hid_device {
	const __u8 *dev_rdesc;
	const __u8 *bpf_rdesc;
	const __u8 *rdesc;
	unsigned int dev_rsize;
	unsigned int bpf_rsize;
	unsigned int rsize;
	unsigned int collection_size;
	struct hid_collection *collection;
	unsigned int maxcollection;
	unsigned int maxapplication;
	__u16 bus;
	__u16 group;
	__u32 vendor;
	__u32 product;
	__u32 version;
	enum hid_type type;
	unsigned int country;
	struct hid_report_enum report_enum[3];
	struct work_struct led_work;
	struct semaphore driver_input_lock;
	struct device dev;
	struct hid_driver *driver;
	void *devres_group_id;
	const struct hid_ll_driver *ll_driver;
	struct mutex ll_open_lock;
	unsigned int ll_open_count;
	long unsigned int status;
	unsigned int claimed;
	unsigned int quirks;
	unsigned int initial_quirks;
	bool io_started;
	struct list_head inputs;
	void *hiddev;
	void *hidraw;
	char name[128];
	char phys[64];
	char uniq[64];
	void *driver_data;
	int (*ff_init)(struct hid_device *);
	int (*hiddev_connect)(struct hid_device *, unsigned int);
	void (*hiddev_disconnect)(struct hid_device *);
	void (*hiddev_hid_event)(struct hid_device *, struct hid_field *, struct hid_usage *, __s32);
	void (*hiddev_report_event)(struct hid_device *, struct hid_report *);
	short unsigned int debug;
	struct dentry *debug_dir;
	struct dentry *debug_rdesc;
	struct dentry *debug_events;
	struct list_head debug_list;
	spinlock_t debug_list_lock;
	wait_queue_head_t debug_wait;
	struct kref ref;
	unsigned int id;
};

struct hid_device_id {
	__u16 bus;
	__u16 group;
	__u32 vendor;
	__u32 product;
	kernel_ulong_t driver_data;
};

struct hid_report_id;

struct hid_usage_id;

struct hid_input;

struct hid_driver {
	char *name;
	const struct hid_device_id *id_table;
	struct list_head dyn_list;
	spinlock_t dyn_lock;
	bool (*match)(struct hid_device *, bool);
	int (*probe)(struct hid_device *, const struct hid_device_id *);
	void (*remove)(struct hid_device *);
	const struct hid_report_id *report_table;
	int (*raw_event)(struct hid_device *, struct hid_report *, u8 *, int);
	const struct hid_usage_id *usage_table;
	int (*event)(struct hid_device *, struct hid_field *, struct hid_usage *, __s32);
	void (*report)(struct hid_device *, struct hid_report *);
	const __u8 * (*report_fixup)(struct hid_device *, __u8 *, unsigned int *);
	int (*input_mapping)(struct hid_device *, struct hid_input *, struct hid_field *, struct hid_usage *, long unsigned int **, int *);
	int (*input_mapped)(struct hid_device *, struct hid_input *, struct hid_field *, struct hid_usage *, long unsigned int **, int *);
	int (*input_configured)(struct hid_device *, struct hid_input *);
	void (*feature_mapping)(struct hid_device *, struct hid_field *, struct hid_usage *);
	int (*suspend)(struct hid_device *, pm_message_t);
	int (*resume)(struct hid_device *);
	int (*reset_resume)(struct hid_device *);
	struct device_driver driver;
};

struct hid_dynid {
	struct list_head list;
	struct hid_device_id id;
};

struct hid_field {
	unsigned int physical;
	unsigned int logical;
	unsigned int application;
	struct hid_usage *usage;
	unsigned int maxusage;
	unsigned int flags;
	unsigned int report_offset;
	unsigned int report_size;
	unsigned int report_count;
	unsigned int report_type;
	__s32 *value;
	__s32 *new_value;
	__s32 *usages_priorities;
	__s32 logical_minimum;
	__s32 logical_maximum;
	__s32 physical_minimum;
	__s32 physical_maximum;
	__s32 unit_exponent;
	unsigned int unit;
	bool ignored;
	struct hid_report *report;
	unsigned int index;
	struct hid_input *hidinput;
	__u16 dpad;
	unsigned int slot_idx;
};

struct hid_field_entry {
	struct list_head list;
	struct hid_field *field;
	unsigned int index;
	__s32 priority;
};

struct hid_global {
	unsigned int usage_page;
	__s32 logical_minimum;
	__s32 logical_maximum;
	__s32 physical_minimum;
	__s32 physical_maximum;
	__s32 unit_exponent;
	unsigned int unit;
	unsigned int report_id;
	unsigned int report_size;
	unsigned int report_count;
};

struct hid_input {
	struct list_head list;
	struct hid_report *report;
	struct input_dev *input;
	const char *name;
	struct list_head reports;
	unsigned int application;
	bool registered;
};

struct hid_item {
	unsigned int format;
	__u8 size;
	__u8 type;
	__u8 tag;
	union {
		__u8 u8;
		__s8 s8;
		__u16 u16;
		__s16 s16;
		__u32 u32;
		__s32 s32;
		const __u8 *longdata;
	} data;
};

struct hid_ll_driver {
	int (*start)(struct hid_device *);
	void (*stop)(struct hid_device *);
	int (*open)(struct hid_device *);
	void (*close)(struct hid_device *);
	int (*power)(struct hid_device *, int);
	int (*parse)(struct hid_device *);
	void (*request)(struct hid_device *, struct hid_report *, int);
	int (*wait)(struct hid_device *);
	int (*raw_request)(struct hid_device *, unsigned char, __u8 *, size_t, unsigned char, int);
	int (*output_report)(struct hid_device *, __u8 *, size_t);
	int (*idle)(struct hid_device *, int, int, int);
	bool (*may_wakeup)(struct hid_device *);
	unsigned int max_buffer_size;
};

struct hid_local {
	unsigned int usage[12288];
	u8 usage_size[12288];
	unsigned int collection_index[12288];
	unsigned int usage_index;
	unsigned int usage_minimum;
	unsigned int delimiter_depth;
	unsigned int delimiter_branch;
};

struct hid_output_fifo {
	struct hid_report *report;
	char *raw_report;
};

struct hid_parser {
	struct hid_global global;
	struct hid_global global_stack[4];
	unsigned int global_stack_ptr;
	struct hid_local local;
	unsigned int *collection_stack;
	unsigned int collection_stack_ptr;
	unsigned int collection_stack_size;
	struct hid_device *device;
	unsigned int scan_flags;
};

struct hid_report {
	struct list_head list;
	struct list_head hidinput_list;
	struct list_head field_entry_list;
	unsigned int id;
	enum hid_report_type type;
	unsigned int application;
	struct hid_field *field[256];
	struct hid_field_entry *field_entries;
	unsigned int maxfield;
	unsigned int size;
	struct hid_device *device;
	bool tool_active;
	unsigned int tool;
};

struct hid_report_id {
	__u32 report_type;
};

struct hid_usage {
	unsigned int hid;
	unsigned int collection_index;
	unsigned int usage_index;
	__s8 resolution_multiplier;
	__s8 wheel_factor;
	__u16 code;
	__u8 type;
	__s16 hat_min;
	__s16 hat_max;
	__s16 hat_dir;
	__s16 wheel_accumulated;
};

struct hid_usage_entry {
	unsigned int page;
	unsigned int usage;
	const char *description;
};

struct hid_usage_id {
	__u32 usage_hid;
	__u32 usage_type;
	__u32 usage_code;
};

struct hiddev {
	int minor;
	int exist;
	int open;
	struct mutex existancelock;
	wait_queue_head_t wait;
	struct hid_device *hid;
	struct list_head list;
	spinlock_t list_lock;
	bool initialized;
};

struct hiddev_collection_info {
	__u32 index;
	__u32 type;
	__u32 usage;
	__u32 level;
};

struct hiddev_devinfo {
	__u32 bustype;
	__u32 busnum;
	__u32 devnum;
	__u32 ifnum;
	__s16 vendor;
	__s16 product;
	__s16 version;
	__u32 num_applications;
};

struct hiddev_event {
	unsigned int hid;
	int value;
};

struct hiddev_field_info {
	__u32 report_type;
	__u32 report_id;
	__u32 field_index;
	__u32 maxusage;
	__u32 flags;
	__u32 physical;
	__u32 logical;
	__u32 application;
	__s32 logical_minimum;
	__s32 logical_maximum;
	__s32 physical_minimum;
	__s32 physical_maximum;
	__u32 unit_exponent;
	__u32 unit;
};

struct hiddev_usage_ref {
	__u32 report_type;
	__u32 report_id;
	__u32 field_index;
	__u32 usage_index;
	__u32 usage_code;
	__s32 value;
};

struct hiddev_list {
	struct hiddev_usage_ref buffer[2048];
	int head;
	int tail;
	unsigned int flags;
	struct fasync_struct *fasync;
	struct hiddev *hiddev;
	struct list_head node;
	struct mutex thread_lock;
};

struct hiddev_report_info {
	__u32 report_type;
	__u32 report_id;
	__u32 num_fields;
};

struct hiddev_usage_ref_multi {
	struct hiddev_usage_ref uref;
	__u32 num_values;
	__s32 values[1024];
};

struct hidraw {
	unsigned int minor;
	int exist;
	int open;
	wait_queue_head_t wait;
	struct hid_device *hid;
	struct device *dev;
	spinlock_t list_lock;
	struct list_head list;
};

struct hidraw_devinfo {
	__u32 bustype;
	__s16 vendor;
	__s16 product;
};

struct hidraw_report {
	__u8 *value;
	int len;
};

struct hidraw_list {
	struct hidraw_report buffer[64];
	int head;
	int tail;
	struct fasync_struct *fasync;
	struct hidraw *hidraw;
	struct list_head node;
	struct mutex read_mutex;
	bool revoked;
};

struct hlist_bl_head {
	struct hlist_bl_node *first;
};

struct hlist_nulls_node {
	struct hlist_nulls_node *next;
	struct hlist_nulls_node **pprev;
};

struct hmac_ctx {
	struct crypto_shash *hash;
	u8 pads[0];
};

struct hop_jumbo_hdr {
	u8 nexthdr;
	u8 hdrlen;
	u8 tlv_type;
	u8 tlv_len;
	__be32 jumbo_payload_len;
};

struct hotplug_slot_ops {
	int (*enable_slot)(struct hotplug_slot *);
	int (*disable_slot)(struct hotplug_slot *);
	int (*set_attention_status)(struct hotplug_slot *, u8);
	int (*hardware_test)(struct hotplug_slot *, u32);
	int (*get_power_status)(struct hotplug_slot *, u8 *);
	int (*get_attention_status)(struct hotplug_slot *, u8 *);
	int (*get_latch_status)(struct hotplug_slot *, u8 *);
	int (*get_adapter_status)(struct hotplug_slot *, u8 *);
	int (*reset_slot)(struct hotplug_slot *, bool);
};

struct housekeeping {
	struct cpumask cpumasks[3];
	long unsigned int flags;
};

struct hpet_timer {
	u64 hpet_config;
	union {
		u64 _hpet_hc64;
		u32 _hpet_hc32;
		long unsigned int _hpet_compare;
	} _u1;
	u64 hpet_fsb[2];
};

struct hpet {
	u64 hpet_cap;
	u64 res0;
	u64 hpet_config;
	u64 res1;
	u64 hpet_isr;
	u64 res2[25];
	union {
		u64 _hpet_mc64;
		u32 _hpet_mc32;
		long unsigned int _hpet_mc;
	} _u0;
	u64 res3;
	struct hpet_timer hpet_timers[0];
};

struct hpet_channel;

struct hpet_base {
	unsigned int nr_channels;
	unsigned int nr_clockevents;
	unsigned int boot_cfg;
	struct hpet_channel *channels;
};

struct hpet_channel {
	struct clock_event_device evt;
	unsigned int num;
	unsigned int cpu;
	unsigned int irq;
	unsigned int in_use;
	enum hpet_mode mode;
	unsigned int boot_cfg;
	char name[10];
	long: 64;
	long: 64;
	long: 64;
};

struct hpet_data {
	long unsigned int hd_phys_address;
	void *hd_address;
	short unsigned int hd_nirqs;
	unsigned int hd_state;
	unsigned int hd_irq[32];
};

struct hpets;

struct hpet_dev {
	struct hpets *hd_hpets;
	struct hpet *hd_hpet;
	struct hpet_timer *hd_timer;
	long unsigned int hd_ireqfreq;
	long unsigned int hd_irqdata;
	wait_queue_head_t hd_waitqueue;
	struct fasync_struct *hd_async_queue;
	unsigned int hd_flags;
	unsigned int hd_irq;
	unsigned int hd_hdwirq;
	char hd_name[7];
};

struct hpet_info {
	long unsigned int hi_ireqfreq;
	long unsigned int hi_flags;
	short unsigned int hi_hpet;
	short unsigned int hi_timer;
};

union hpet_lock {
	struct {
		arch_spinlock_t lock;
		u32 value;
	};
	u64 lockval;
};

struct hpets {
	struct hpets *hp_next;
	struct hpet *hp_hpet;
	long unsigned int hp_hpet_phys;
	long long unsigned int hp_tick_freq;
	long unsigned int hp_delta;
	unsigned int hp_ntimer;
	unsigned int hp_which;
	struct hpet_dev hp_dev[0];
};

struct hprobe {
	enum hprobe_state state;
	int srcu_idx;
	struct uprobe *uprobe;
};

struct hpx_type0 {
	u32 revision;
	u8 cache_line_size;
	u8 latency_timer;
	u8 enable_serr;
	u8 enable_perr;
};

struct hpx_type1 {
	u32 revision;
	u8 max_mem_read;
	u8 avg_max_split;
	u16 tot_max_split;
};

struct hpx_type2 {
	u32 revision;
	u32 unc_err_mask_and;
	u32 unc_err_mask_or;
	u32 unc_err_sever_and;
	u32 unc_err_sever_or;
	u32 cor_err_mask_and;
	u32 cor_err_mask_or;
	u32 adv_err_cap_and;
	u32 adv_err_cap_or;
	u16 pci_exp_devctl_and;
	u16 pci_exp_devctl_or;
	u16 pci_exp_lnkctl_and;
	u16 pci_exp_lnkctl_or;
	u32 sec_unc_err_sever_and;
	u32 sec_unc_err_sever_or;
	u32 sec_unc_err_mask_and;
	u32 sec_unc_err_mask_or;
};

struct hpx_type3 {
	u16 device_type;
	u16 function_type;
	u16 config_space_location;
	u16 pci_exp_cap_id;
	u16 pci_exp_cap_ver;
	u16 pci_exp_vendor_id;
	u16 dvsec_id;
	u16 dvsec_rev;
	u16 match_offset;
	u32 match_mask_and;
	u32 match_value;
	u16 reg_offset;
	u32 reg_mask_and;
	u32 reg_mask_or;
};

struct seqcount_raw_spinlock {
	seqcount_t seqcount;
};

typedef struct seqcount_raw_spinlock seqcount_raw_spinlock_t;

struct hrtimer_cpu_base;

struct hrtimer_clock_base {
	struct hrtimer_cpu_base *cpu_base;
	unsigned int index;
	clockid_t clockid;
	seqcount_raw_spinlock_t seq;
	struct hrtimer *running;
	struct timerqueue_head active;
	ktime_t (*get_time)(void);
	ktime_t offset;
};

struct hrtimer_cpu_base {
	raw_spinlock_t lock;
	unsigned int cpu;
	unsigned int active_bases;
	unsigned int clock_was_set_seq;
	unsigned int hres_active: 1;
	unsigned int in_hrtirq: 1;
	unsigned int hang_detected: 1;
	unsigned int softirq_activated: 1;
	unsigned int online: 1;
	unsigned int nr_events;
	short unsigned int nr_retries;
	short unsigned int nr_hangs;
	unsigned int max_hang_time;
	ktime_t expires_next;
	struct hrtimer *next_timer;
	ktime_t softirq_expires_next;
	struct hrtimer *softirq_next_timer;
	struct hrtimer_clock_base clock_base[8];
	call_single_data_t csd;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct hrtimer_sleeper {
	struct hrtimer timer;
	struct task_struct *task;
};

struct hs_primary_descriptor {
	__u8 foo[8];
	__u8 type[1];
	__u8 id[5];
	__u8 version[1];
	__u8 unused1[1];
	char system_id[32];
	char volume_id[32];
	__u8 unused2[8];
	__u8 volume_space_size[8];
	__u8 unused3[32];
	__u8 volume_set_size[4];
	__u8 volume_sequence_number[4];
	__u8 logical_block_size[4];
	__u8 path_table_size[8];
	__u8 type_l_path_table[4];
	__u8 unused4[28];
	__u8 root_directory_record[34];
};

struct hs_volume_descriptor {
	__u8 foo[8];
	__u8 type[1];
	char id[5];
	__u8 version[1];
	__u8 data[2033];
};

struct hsr_tag {
	__be16 path_and_LSDU_size;
	__be16 sequence_nr;
	__be16 encap_proto;
};

struct hstate {
	struct mutex resize_lock;
	struct lock_class_key resize_key;
	int next_nid_to_alloc;
	int next_nid_to_free;
	unsigned int order;
	unsigned int demote_order;
	long unsigned int mask;
	long unsigned int max_huge_pages;
	long unsigned int nr_huge_pages;
	long unsigned int free_huge_pages;
	long unsigned int resv_huge_pages;
	long unsigned int surplus_huge_pages;
	long unsigned int nr_overcommit_huge_pages;
	struct list_head hugepage_activelist;
	struct list_head hugepage_freelists[64];
	unsigned int max_huge_pages_node[64];
	unsigned int nr_huge_pages_node[64];
	unsigned int free_huge_pages_node[64];
	unsigned int surplus_huge_pages_node[64];
	char name[32];
};

struct hsu_dma_chan;

struct hsu_dma {
	struct dma_device dma;
	struct hsu_dma_chan *chan;
	short unsigned int nr_channels;
};

struct virt_dma_desc;

struct virt_dma_chan {
	struct dma_chan chan;
	struct tasklet_struct task;
	void (*desc_free)(struct virt_dma_desc *);
	spinlock_t lock;
	struct list_head desc_allocated;
	struct list_head desc_submitted;
	struct list_head desc_issued;
	struct list_head desc_completed;
	struct list_head desc_terminated;
	struct virt_dma_desc *cyclic;
};

struct hsu_dma_desc;

struct hsu_dma_chan {
	struct virt_dma_chan vchan;
	void *reg;
	enum dma_transfer_direction direction;
	struct dma_slave_config config;
	struct hsu_dma_desc *desc;
};

struct hsu_dma_chip {
	struct device *dev;
	int irq;
	void *regs;
	unsigned int length;
	unsigned int offset;
	struct hsu_dma *hsu;
};

struct virt_dma_desc {
	struct dma_async_tx_descriptor tx;
	struct dmaengine_result tx_result;
	struct list_head node;
};

struct hsu_dma_sg;

struct hsu_dma_desc {
	struct virt_dma_desc vdesc;
	enum dma_transfer_direction direction;
	struct hsu_dma_sg *sg;
	unsigned int nents;
	size_t length;
	unsigned int active;
	enum dma_status status;
};

struct hsu_dma_sg {
	dma_addr_t addr;
	unsigned int len;
};

struct hsu_dma_slave {
	struct device *dma_dev;
	int chan_id;
};

struct hsw_ddi_buf_trans {
	u32 trans1;
	u32 trans2;
	u8 i_boost;
};

union hsw_tsx_tuning {
	struct {
		u32 cycles_last_block: 32;
		u32 hle_abort: 1;
		u32 rtm_abort: 1;
		u32 instruction_abort: 1;
		u32 non_instruction_abort: 1;
		u32 retry: 1;
		u32 data_conflict: 1;
		u32 capacity_writes: 1;
		u32 capacity_reads: 1;
	};
	u64 value;
};

struct hsw_wrpll_rnp {
	unsigned int p;
	unsigned int n2;
	unsigned int r2;
};

struct pcpu_freelist_node {
	struct pcpu_freelist_node *next;
};

struct htab_elem {
	union {
		struct hlist_nulls_node hash_node;
		struct {
			void *padding;
			union {
				struct pcpu_freelist_node fnode;
				struct htab_elem *batch_flink;
			};
		};
	};
	union {
		void *ptr_to_pptr;
		struct bpf_lru_node lru_node;
	};
	u32 hash;
	long: 0;
	char key[0];
};

struct huge_bootmem_page {
	struct list_head list;
	struct hstate *hstate;
};

struct hugepage_subpool {
	spinlock_t lock;
	long int count;
	long int max_hpages;
	long int used_hpages;
	struct hstate *hstate;
	long int min_hpages;
	long int rsv_hpages;
};

struct page_counter {
	atomic_long_t usage;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct cacheline_padding _pad1_;
	long unsigned int emin;
	atomic_long_t min_usage;
	atomic_long_t children_min_usage;
	long unsigned int elow;
	atomic_long_t low_usage;
	atomic_long_t children_low_usage;
	long unsigned int watermark;
	long unsigned int local_watermark;
	long unsigned int failcnt;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct cacheline_padding _pad2_;
	bool protection_support;
	long unsigned int min;
	long unsigned int low;
	long unsigned int high;
	long unsigned int max;
	struct page_counter *parent;
	long: 64;
	long: 64;
};

struct hugetlb_cgroup_per_node;

struct hugetlb_cgroup {
	struct cgroup_subsys_state css;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct page_counter hugepage[2];
	struct page_counter rsvd_hugepage[2];
	atomic_long_t events[2];
	atomic_long_t events_local[2];
	struct cgroup_file events_file[2];
	struct cgroup_file events_local_file[2];
	struct hugetlb_cgroup_per_node *nodeinfo[0];
};

struct hugetlb_cgroup_per_node {
	long unsigned int usage[2];
};

struct hugetlb_vma_lock {
	struct kref refs;
	struct rw_semaphore rw_sema;
	struct vm_area_struct *vma;
};

struct hugetlbfs_fs_context {
	struct hstate *hstate;
	long long unsigned int max_size_opt;
	long long unsigned int min_size_opt;
	long int max_hpages;
	long int nr_inodes;
	long int min_hpages;
	enum hugetlbfs_size_type max_val_type;
	enum hugetlbfs_size_type min_val_type;
	kuid_t uid;
	kgid_t gid;
	umode_t mode;
};

struct hugetlbfs_inode_info {
	struct inode vfs_inode;
	unsigned int seals;
};

struct hugetlbfs_sb_info {
	long int max_inodes;
	long int free_inodes;
	spinlock_t stat_lock;
	struct hstate *hstate;
	struct hugepage_subpool *spool;
	kuid_t uid;
	kgid_t gid;
	umode_t mode;
};

union hv_hypervisor_version_info {
	struct {
		u32 build_number;
		u32 minor_version: 16;
		u32 major_version: 16;
		u32 service_pack;
		u32 service_number: 24;
		u32 service_branch: 8;
	};
	struct {
		u32 eax;
		u32 ebx;
		u32 ecx;
		u32 edx;
	};
};

struct hv_ops {
	ssize_t (*get_chars)(uint32_t, u8 *, size_t);
	ssize_t (*put_chars)(uint32_t, const u8 *, size_t);
	int (*flush)(uint32_t, bool);
	int (*notifier_add)(struct hvc_struct *, int);
	void (*notifier_del)(struct hvc_struct *, int);
	void (*notifier_hangup)(struct hvc_struct *, int);
	int (*tiocmget)(struct hvc_struct *);
	int (*tiocmset)(struct hvc_struct *, unsigned int, unsigned int);
	void (*dtr_rts)(struct hvc_struct *, bool);
};

struct tty_buffer {
	union {
		struct tty_buffer *next;
		struct llist_node free;
	};
	unsigned int used;
	unsigned int size;
	unsigned int commit;
	unsigned int lookahead;
	unsigned int read;
	bool flags;
	long: 0;
	u8 data[0];
};

struct tty_bufhead {
	struct tty_buffer *head;
	struct work_struct work;
	struct mutex lock;
	atomic_t priority;
	struct tty_buffer sentinel;
	struct llist_head free;
	atomic_t mem_used;
	int mem_limit;
	struct tty_buffer *tail;
};

struct tty_struct;

struct tty_port_operations;

struct tty_port_client_operations;

struct tty_port {
	struct tty_bufhead buf;
	struct tty_struct *tty;
	struct tty_struct *itty;
	const struct tty_port_operations *ops;
	const struct tty_port_client_operations *client_ops;
	spinlock_t lock;
	int blocked_open;
	int count;
	wait_queue_head_t open_wait;
	wait_queue_head_t delta_msr_wait;
	long unsigned int flags;
	long unsigned int iflags;
	unsigned char console: 1;
	struct mutex mutex;
	struct mutex buf_mutex;
	u8 *xmit_buf;
	struct {
		union {
			struct __kfifo kfifo;
			u8 *type;
			const u8 *const_type;
			char (*rectype)[0];
			u8 *ptr;
			const u8 *ptr_const;
		};
		u8 buf[0];
	} xmit_fifo;
	unsigned int close_delay;
	unsigned int closing_wait;
	int drain_delay;
	struct kref kref;
	void *client_data;
};

struct hvc_struct {
	struct tty_port port;
	spinlock_t lock;
	int index;
	int do_wakeup;
	int outbuf_size;
	int n_outbuf;
	uint32_t vtermno;
	const struct hv_ops *ops;
	int irq_requested;
	int data;
	struct winsize ws;
	struct work_struct tty_resize;
	struct list_head next;
	long unsigned int flags;
	u8 outbuf[0];
};

struct hw_perf_event_extra {
	u64 config;
	unsigned int reg;
	int alloc;
	int idx;
};

struct rhlist_head {
	struct rhash_head rhead;
	struct rhlist_head *next;
};

struct hw_perf_event {
	union {
		struct {
			u64 config;
			u64 last_tag;
			long unsigned int config_base;
			long unsigned int event_base;
			int event_base_rdpmc;
			int idx;
			int last_cpu;
			int flags;
			struct hw_perf_event_extra extra_reg;
			struct hw_perf_event_extra branch_reg;
		};
		struct {
			u64 aux_config;
			unsigned int aux_paused;
		};
		struct {
			struct hrtimer hrtimer;
		};
		struct {
			struct list_head tp_list;
		};
		struct {
			u64 pwr_acc;
			u64 ptsc;
		};
		struct {
			struct arch_hw_breakpoint info;
			struct rhlist_head bp_list;
		};
		struct {
			u8 iommu_bank;
			u8 iommu_cntr;
			u16 padding;
			u64 conf;
			u64 conf1;
		};
	};
	struct task_struct *target;
	void *addr_filters;
	long unsigned int addr_filters_gen;
	int state;
	local64_t prev_count;
	u64 sample_period;
	union {
		struct {
			u64 last_period;
			local64_t period_left;
		};
		struct {
			u64 saved_metric;
			u64 saved_slots;
		};
	};
	u64 interrupts_seq;
	u64 interrupts;
	u64 freq_time_stamp;
	u64 freq_count_stamp;
};

struct hw_port_info {
	struct net_device *lower_dev;
	u32 port_id;
};

struct hwlat_entry {
	struct trace_entry ent;
	u64 duration;
	u64 outer_duration;
	u64 nmi_total_ts;
	struct timespec64 timestamp;
	unsigned int nmi_count;
	unsigned int seqnum;
	unsigned int count;
};

struct hwm_energy_info {
	u32 reg_val_prev;
	long int accum_energy;
};

struct hwm_fan_info {
	u32 reg_val_prev;
	u64 time_prev;
};

struct hwm_drvdata {
	struct i915_hwmon *hwmon;
	struct intel_uncore *uncore;
	struct device *hwmon_dev;
	struct hwm_energy_info ei;
	struct hwm_fan_info fi;
	char name[12];
	int gt_n;
	bool reset_in_progress;
	wait_queue_head_t waitq;
};

struct hwm_reg {
	i915_reg_t gt_perf_status;
	i915_reg_t pkg_temp;
	i915_reg_t pkg_power_sku_unit;
	i915_reg_t pkg_power_sku;
	i915_reg_t pkg_rapl_limit;
	i915_reg_t energy_status_all;
	i915_reg_t energy_status_tile;
	i915_reg_t fan_speed;
};

struct hwmon_channel_info {
	enum hwmon_sensor_types type;
	const u32 *config;
};

struct hwmon_ops;

struct hwmon_chip_info {
	const struct hwmon_ops *ops;
	const struct hwmon_channel_info * const *info;
};

struct hwmon_device {
	const char *name;
	const char *label;
	struct device dev;
	const struct hwmon_chip_info *chip;
	struct list_head tzdata;
	struct attribute_group group;
	const struct attribute_group **groups;
};

struct hwmon_device_attribute {
	struct device_attribute dev_attr;
	const struct hwmon_ops *ops;
	enum hwmon_sensor_types type;
	u32 attr;
	int index;
	char name[32];
};

struct hwmon_ops {
	umode_t visible;
	umode_t (*is_visible)(const void *, enum hwmon_sensor_types, u32, int);
	int (*read)(struct device *, enum hwmon_sensor_types, u32, int, long int *);
	int (*read_string)(struct device *, enum hwmon_sensor_types, u32, int, const char **);
	int (*write)(struct device *, enum hwmon_sensor_types, u32, int, long int);
};

struct hwmon_thermal_data {
	struct list_head node;
	struct device *dev;
	int index;
	struct thermal_zone_device *tzd;
};

struct hwmon_type_attr_list {
	const u32 *attrs;
	size_t n_attrs;
};

struct hwrng {
	const char *name;
	int (*init)(struct hwrng *);
	void (*cleanup)(struct hwrng *);
	int (*data_present)(struct hwrng *, int);
	int (*data_read)(struct hwrng *, u32 *);
	int (*read)(struct hwrng *, void *, size_t, bool);
	long unsigned int priv;
	short unsigned int quality;
	struct list_head list;
	struct kref ref;
	struct completion cleanup_done;
	struct completion dying;
};

struct hwtstamp_provider_desc {
	int index;
	enum hwtstamp_provider_qualifier qualifier;
};

struct hwtstamp_provider {
	struct callback_head callback_head;
	enum hwtstamp_source source;
	struct phy_device *phydev;
	struct hwtstamp_provider_desc desc;
};

struct x86_hyper_init {
	void (*init_platform)(void);
	void (*guest_late_init)(void);
	bool (*x2apic_available)(void);
	bool (*msi_ext_dest_id)(void);
	void (*init_mem_mapping)(void);
	void (*init_after_bootmem)(void);
};

struct x86_hyper_runtime {
	void (*pin_vcpu)(int);
	void (*sev_es_hcall_prepare)(struct ghcb *, struct pt_regs *);
	bool (*sev_es_hcall_finish)(struct ghcb *, struct pt_regs *);
	bool (*is_private_mmio)(u64);
};

struct hypervisor_x86 {
	const char *name;
	uint32_t (*detect)(void);
	enum x86_hypervisor_type type;
	struct x86_hyper_init init;
	struct x86_hyper_runtime runtime;
	bool ignore_nopv;
};

struct i2c_acpi_handler_data {
	struct acpi_connection_info info;
	struct i2c_adapter *adapter;
};

struct i2c_acpi_irq_context {
	int irq;
	bool wake_capable;
};

struct i2c_acpi_lookup {
	struct i2c_board_info *info;
	acpi_handle adapter_handle;
	acpi_handle device_handle;
	acpi_handle search_handle;
	int n;
	int index;
	u32 speed;
	u32 min_speed;
	u32 force_speed;
};

struct intel_dsi;

struct i2c_adapter_lookup {
	u16 target_addr;
	struct intel_dsi *intel_dsi;
	acpi_handle dev_handle;
};

struct i2c_adapter_quirks {
	u64 flags;
	int max_num_msgs;
	u16 max_write_len;
	u16 max_read_len;
	u16 max_comb_1st_msg_len;
	u16 max_comb_2nd_msg_len;
};

struct i2c_algo_bit_data {
	void *data;
	void (*setsda)(void *, int);
	void (*setscl)(void *, int);
	int (*getsda)(void *);
	int (*getscl)(void *);
	int (*pre_xfer)(struct i2c_adapter *);
	void (*post_xfer)(struct i2c_adapter *);
	int udelay;
	int timeout;
	bool can_do_atomic;
};

struct i2c_msg;

union i2c_smbus_data;

struct i2c_algorithm {
	union {
		int (*xfer)(struct i2c_adapter *, struct i2c_msg *, int);
		int (*master_xfer)(struct i2c_adapter *, struct i2c_msg *, int);
	};
	union {
		int (*xfer_atomic)(struct i2c_adapter *, struct i2c_msg *, int);
		int (*master_xfer_atomic)(struct i2c_adapter *, struct i2c_msg *, int);
	};
	int (*smbus_xfer)(struct i2c_adapter *, u16, short unsigned int, char, u8, int, union i2c_smbus_data *);
	int (*smbus_xfer_atomic)(struct i2c_adapter *, u16, short unsigned int, char, u8, int, union i2c_smbus_data *);
	u32 (*functionality)(struct i2c_adapter *);
};

struct i2c_board_info {
	char type[20];
	short unsigned int flags;
	short unsigned int addr;
	const char *dev_name;
	void *platform_data;
	struct device_node *of_node;
	struct fwnode_handle *fwnode;
	const struct software_node *swnode;
	const struct resource *resources;
	unsigned int num_resources;
	int irq;
};

struct pinctrl;

struct pinctrl_state;

struct i2c_bus_recovery_info {
	int (*recover_bus)(struct i2c_adapter *);
	int (*get_scl)(struct i2c_adapter *);
	void (*set_scl)(struct i2c_adapter *, int);
	int (*get_sda)(struct i2c_adapter *);
	void (*set_sda)(struct i2c_adapter *, int);
	int (*get_bus_free)(struct i2c_adapter *);
	void (*prepare_recovery)(struct i2c_adapter *);
	void (*unprepare_recovery)(struct i2c_adapter *);
	struct gpio_desc *scl_gpiod;
	struct gpio_desc *sda_gpiod;
	struct pinctrl *pinctrl;
	struct pinctrl_state *pins_default;
	struct pinctrl_state *pins_gpio;
};

struct i2c_client {
	short unsigned int flags;
	short unsigned int addr;
	char name[20];
	struct i2c_adapter *adapter;
	struct device dev;
	int init_irq;
	int irq;
	struct list_head detected;
	void *devres_group_id;
	struct dentry *debugfs;
};

struct i2c_cmd_arg {
	unsigned int cmd;
	void *arg;
};

struct i2c_device_id {
	char name[20];
	kernel_ulong_t driver_data;
};

struct i2c_device_identity {
	u16 manufacturer_id;
	u16 part_id;
	u8 die_revision;
};

struct i2c_devinfo {
	struct list_head list;
	int busnum;
	struct i2c_board_info board_info;
};

struct i2c_lock_operations {
	void (*lock_bus)(struct i2c_adapter *, unsigned int);
	int (*trylock_bus)(struct i2c_adapter *, unsigned int);
	void (*unlock_bus)(struct i2c_adapter *, unsigned int);
};

struct i2c_msg {
	__u16 addr;
	__u16 flags;
	__u16 len;
	__u8 *buf;
};

struct i2c_smbus_alert {
	struct work_struct alert;
	struct i2c_client *ara;
};

struct i2c_smbus_alert_setup {
	int irq;
};

union i2c_smbus_data {
	__u8 byte;
	__u16 word;
	__u8 block[34];
};

struct i2c_timings {
	u32 bus_freq_hz;
	u32 scl_rise_ns;
	u32 scl_fall_ns;
	u32 scl_int_delay_ns;
	u32 sda_fall_ns;
	u32 sda_hold_ns;
	u32 digital_filter_width_ns;
	u32 analog_filter_cutoff_freq_hz;
};

struct user_regs_struct32 {
	__u32 ebx;
	__u32 ecx;
	__u32 edx;
	__u32 esi;
	__u32 edi;
	__u32 ebp;
	__u32 eax;
	short unsigned int ds;
	short unsigned int __ds;
	short unsigned int es;
	short unsigned int __es;
	short unsigned int fs;
	short unsigned int __fs;
	short unsigned int gs;
	short unsigned int __gs;
	__u32 orig_eax;
	__u32 eip;
	short unsigned int cs;
	short unsigned int __cs;
	__u32 eflags;
	__u32 esp;
	short unsigned int ss;
	short unsigned int __ss;
};

struct i386_elf_prstatus {
	struct compat_elf_prstatus_common common;
	struct user_regs_struct32 pr_reg;
	compat_int_t pr_fpvalid;
};

struct i801_priv {
	struct i2c_adapter adapter;
	long unsigned int smba;
	unsigned char original_hstcfg;
	unsigned char original_hstcnt;
	unsigned char original_slvcmd;
	struct pci_dev *pci_dev;
	unsigned int features;
	struct completion done;
	u8 status;
	u8 cmd;
	bool is_read;
	int count;
	int len;
	u8 *data;
	struct platform_device *tco_pdev;
	bool acpi_reserved;
};

struct i8042_port {
	struct serio *serio;
	int irq;
	bool exists;
	bool driver_bound;
	signed char mux;
};

struct i915_audio_component {
	struct drm_audio_component base;
	int aud_sample_rate[9];
};

struct i915_capture_list {
	struct i915_vma_resource *vma_res;
	struct i915_capture_list *next;
};

struct i915_color_plane_view {
	u32 offset;
	unsigned int x;
	unsigned int y;
	unsigned int mapping_stride;
	unsigned int scanout_stride;
};

struct i915_context_engines_bond {
	struct i915_user_extension base;
	struct i915_engine_class_instance master;
	__u16 virtual_index;
	__u16 num_bonds;
	__u64 flags;
	__u64 mbz64[4];
	struct i915_engine_class_instance engines[0];
};

struct i915_context_engines_load_balance {
	struct i915_user_extension base;
	__u16 engine_index;
	__u16 num_siblings;
	__u32 flags;
	__u64 mbz64;
	struct i915_engine_class_instance engines[0];
};

struct i915_context_engines_parallel_submit {
	struct i915_user_extension base;
	__u16 engine_index;
	__u16 width;
	__u16 num_siblings;
	__u16 mbz16;
	__u64 flags;
	__u64 mbz64[3];
	struct i915_engine_class_instance engines[0];
};

struct i915_context_param_engines {
	__u64 extensions;
	struct i915_engine_class_instance engines[0];
};

struct i915_debugfs_files {
	const char *name;
	const struct file_operations *fops;
};

struct i915_sched_node;

struct i915_dependency {
	struct i915_sched_node *signaler;
	struct i915_sched_node *waiter;
	struct list_head signal_link;
	struct list_head wait_link;
	struct list_head dfs_link;
	long unsigned int flags;
};

struct i915_deps {
	struct dma_fence *single;
	struct dma_fence **fences;
	unsigned int num_deps;
	unsigned int fences_size;
	gfp_t gfp;
};

struct i915_dpt {
	struct i915_address_space vm;
	struct drm_i915_gem_object *obj;
	struct i915_vma *vma;
	void *iomem;
};

struct i915_drm_client {
	struct kref kref;
	spinlock_t ctx_lock;
	struct list_head ctx_list;
	spinlock_t objects_lock;
	struct list_head objects_list;
	atomic64_t past_runtime[5];
};

struct i915_gem_ww_ctx {
	struct ww_acquire_ctx ctx;
	struct list_head obj_list;
	struct drm_i915_gem_object *contended;
	bool intr;
};

struct reloc_cache {
	struct drm_mm_node node;
	long unsigned int vaddr;
	long unsigned int page;
	unsigned int graphics_ver;
	bool use_64bit_reloc: 1;
	bool has_llc: 1;
	bool has_fence: 1;
	bool needs_unfenced: 1;
};

struct intel_gt_buffer_pool_node;

struct i915_execbuffer {
	struct drm_i915_private *i915;
	struct drm_file *file;
	struct drm_i915_gem_execbuffer2 *args;
	struct drm_i915_gem_exec_object2 *exec;
	struct eb_vma *vma;
	struct intel_gt *gt;
	struct intel_context *context;
	struct i915_gem_context *gem_context;
	intel_wakeref_t wakeref;
	intel_wakeref_t wakeref_gt0;
	struct i915_request *requests[9];
	struct eb_vma *batches[9];
	struct i915_vma *trampoline;
	struct dma_fence *composite_fence;
	unsigned int buffer_count;
	unsigned int num_batches;
	struct list_head unbound;
	struct list_head relocs;
	struct i915_gem_ww_ctx ww;
	struct reloc_cache reloc_cache;
	u64 invalid_flags;
	u64 batch_len[9];
	u32 batch_start_offset;
	u32 batch_flags;
	struct intel_gt_buffer_pool_node *batch_pool;
	int lut_size;
	struct hlist_head *buckets;
	struct eb_fence *fences;
	long unsigned int num_fences;
	struct i915_capture_list *capture_lists[9];
};

struct i915_ext_attribute {
	struct device_attribute attr;
	long unsigned int val;
};

struct i915_ggtt;

struct i915_fence_reg {
	struct list_head link;
	struct i915_ggtt *ggtt;
	struct i915_vma *vma;
	atomic_t pin_count;
	struct i915_active active;
	int id;
	bool dirty;
	u32 start;
	u32 size;
	u32 tiling;
	u32 stride;
};

struct i915_gem_apply_to_region_ops;

struct i915_gem_apply_to_region {
	const struct i915_gem_apply_to_region_ops *ops;
	struct i915_gem_ww_ctx *ww;
	u32 interruptible: 1;
};

struct i915_gem_apply_to_region_ops {
	int (*process_obj)(struct i915_gem_apply_to_region *, struct drm_i915_gem_object *);
};

struct i915_sched_attr {
	int priority;
};

struct i915_gem_engines;

struct i915_gem_context {
	struct drm_i915_private *i915;
	struct drm_i915_file_private *file_priv;
	struct i915_gem_engines *engines;
	struct mutex engines_mutex;
	struct drm_syncobj *syncobj;
	struct i915_address_space *vm;
	struct pid *pid;
	struct list_head link;
	struct i915_drm_client *client;
	struct list_head client_link;
	struct kref ref;
	struct work_struct release_work;
	struct callback_head rcu;
	long unsigned int user_flags;
	long unsigned int flags;
	bool uses_protected_content;
	intel_wakeref_t pxp_wakeref;
	struct mutex mutex;
	struct i915_sched_attr sched;
	atomic_t guilty_count;
	atomic_t active_count;
	long unsigned int hang_timestamp[2];
	u8 remap_slice;
	struct xarray handles_vma;
	struct mutex lut_mutex;
	char name[24];
	struct {
		spinlock_t lock;
		struct list_head engines;
	} stale;
};

struct i915_gem_context_coredump {
	char comm[16];
	u64 total_runtime;
	u64 avg_runtime;
	pid_t pid;
	int active;
	int guilty;
	struct i915_sched_attr sched_attr;
	u32 hwsp_seqno;
};

struct i915_gem_context_param_context_image {
	struct i915_engine_class_instance engine;
	__u32 flags;
	__u32 size;
	__u32 mbz;
	__u64 image;
};

struct i915_gem_engines {
	union {
		struct list_head link;
		struct callback_head rcu;
	};
	struct i915_sw_fence fence;
	struct i915_gem_context *ctx;
	unsigned int num_engines;
	struct intel_context *engines[0];
};

struct i915_gem_engines_iter {
	unsigned int idx;
	const struct i915_gem_engines *engines;
};

struct i915_gem_proto_engine;

struct i915_gem_proto_context {
	struct drm_i915_file_private *fpriv;
	struct i915_address_space *vm;
	long unsigned int user_flags;
	struct i915_sched_attr sched;
	int num_user_engines;
	struct i915_gem_proto_engine *user_engines;
	struct intel_sseu legacy_rcs_sseu;
	bool single_timeline;
	bool uses_protected_content;
	intel_wakeref_t pxp_wakeref;
};

struct i915_gem_proto_engine {
	enum i915_gem_engine_type type;
	struct intel_engine_cs *engine;
	unsigned int num_siblings;
	unsigned int width;
	struct intel_engine_cs **siblings;
	struct intel_sseu sseu;
};

struct i915_gem_ttm_pm_apply {
	struct i915_gem_apply_to_region base;
	bool allow_gpu: 1;
	bool backup_pinned: 1;
};

struct io_mapping {
	resource_size_t base;
	long unsigned int size;
	pgprot_t prot;
	void *iomem;
};

struct i915_ggtt {
	struct i915_address_space vm;
	struct io_mapping iomap;
	struct resource gmadr;
	resource_size_t mappable_end;
	void *gsm;
	void (*invalidate)(struct i915_ggtt *);
	struct i915_ppgtt *alias;
	bool do_idle_maps;
	int mtrr;
	u32 bit_6_swizzle_x;
	u32 bit_6_swizzle_y;
	u32 pin_bias;
	unsigned int num_fences;
	struct i915_fence_reg *fence_regs;
	struct list_head fence_list;
	struct list_head userfault_list;
	struct mutex error_mutex;
	struct drm_mm_node error_capture;
	struct drm_mm_node uc_fw;
	struct list_head gt_list;
};

struct intel_gt_definition;

struct intel_device_info {
	enum intel_platform platform;
	unsigned int dma_mask_size;
	const struct intel_gt_definition *extra_gt_list;
	u8 gt;
	intel_engine_mask_t platform_engine_mask;
	u32 memory_regions;
	u8 is_mobile: 1;
	u8 require_force_probe: 1;
	u8 is_dgfx: 1;
	u8 has_64bit_reloc: 1;
	u8 has_64k_pages: 1;
	u8 gpu_reset_clobbers_display: 1;
	u8 has_reset_engine: 1;
	u8 has_3d_pipeline: 1;
	u8 has_flat_ccs: 1;
	u8 has_global_mocs: 1;
	u8 has_gmd_id: 1;
	u8 has_gt_uc: 1;
	u8 has_heci_pxp: 1;
	u8 has_heci_gscfi: 1;
	u8 has_guc_deprivilege: 1;
	u8 has_guc_tlb_invalidation: 1;
	u8 has_l3_ccs_read: 1;
	u8 has_l3_dpf: 1;
	u8 has_llc: 1;
	u8 has_logical_ring_contexts: 1;
	u8 has_logical_ring_elsq: 1;
	u8 has_media_ratio_mode: 1;
	u8 has_mslice_steering: 1;
	u8 has_oa_bpc_reporting: 1;
	u8 has_oa_slice_contrib_limits: 1;
	u8 has_oam: 1;
	u8 has_one_eu_per_fuse_bit: 1;
	u8 has_pxp: 1;
	u8 has_rc6: 1;
	u8 has_rc6p: 1;
	u8 has_rps: 1;
	u8 has_runtime_pm: 1;
	u8 has_snoop: 1;
	u8 has_coherent_ggtt: 1;
	u8 tuning_thread_rr_after_dep: 1;
	u8 unfenced_needs_alignment: 1;
	u8 hws_needs_physical: 1;
	const struct intel_runtime_info __runtime;
	u32 cachelevel_to_pat[4];
	u32 max_pat_index;
};

struct intel_gt_coredump;

struct intel_display_snapshot;

struct i915_gpu_coredump {
	struct kref ref;
	ktime_t time;
	ktime_t boottime;
	ktime_t uptime;
	long unsigned int capture;
	struct drm_i915_private *i915;
	struct intel_gt_coredump *gt;
	char error_msg[128];
	bool simulated;
	bool wakelock;
	bool suspended;
	int iommu;
	u32 reset_count;
	u32 suspend_count;
	struct intel_device_info device_info;
	struct intel_runtime_info runtime_info;
	struct intel_driver_caps driver_caps;
	struct i915_params params;
	struct scatterlist *sgl;
	struct scatterlist *fit;
	struct intel_display_snapshot *display_snapshot;
};

struct i915_gsc_proxy_component_ops;

struct i915_gsc_proxy_component {
	struct device *mei_dev;
	const struct i915_gsc_proxy_component_ops *ops;
};

struct i915_gsc_proxy_component_ops {
	struct module *owner;
	int (*send)(struct device *, const void *, size_t);
	int (*recv)(struct device *, void *, size_t);
};

struct intel_partial_info {
	u64 offset;
	unsigned int size;
} __attribute__((packed));

struct intel_remapped_plane_info {
	u32 offset: 31;
	u32 linear: 1;
	union {
		struct {
			u16 width;
			u16 height;
			u16 src_stride;
			u16 dst_stride;
		};
		u32 size;
	};
};

struct intel_rotation_info {
	struct intel_remapped_plane_info plane[2];
};

struct intel_remapped_info {
	struct intel_remapped_plane_info plane[4];
	u32 plane_alignment;
};

struct i915_gtt_view {
	enum i915_gtt_view_type type;
	union {
		struct intel_partial_info partial;
		struct intel_rotation_info rotated;
		struct intel_remapped_info remapped;
	};
};

struct i915_hdcp_ops;

struct i915_hdcp_arbiter {
	struct device *hdcp_dev;
	const struct i915_hdcp_ops *ops;
	struct mutex mutex;
};

struct i915_hdcp_ops {
	struct module *owner;
	int (*initiate_hdcp2_session)(struct device *, struct hdcp_port_data *, struct hdcp2_ake_init *);
	int (*verify_receiver_cert_prepare_km)(struct device *, struct hdcp_port_data *, struct hdcp2_ake_send_cert *, bool *, struct hdcp2_ake_no_stored_km *, size_t *);
	int (*verify_hprime)(struct device *, struct hdcp_port_data *, struct hdcp2_ake_send_hprime *);
	int (*store_pairing_info)(struct device *, struct hdcp_port_data *, struct hdcp2_ake_send_pairing_info *);
	int (*initiate_locality_check)(struct device *, struct hdcp_port_data *, struct hdcp2_lc_init *);
	int (*verify_lprime)(struct device *, struct hdcp_port_data *, struct hdcp2_lc_send_lprime *);
	int (*get_session_key)(struct device *, struct hdcp_port_data *, struct hdcp2_ske_send_eks *);
	int (*repeater_check_flow_prepare_ack)(struct device *, struct hdcp_port_data *, struct hdcp2_rep_send_receiverid_list *, struct hdcp2_rep_send_ack *);
	int (*verify_mprime)(struct device *, struct hdcp_port_data *, struct hdcp2_rep_stream_ready *);
	int (*enable_hdcp_authentication)(struct device *, struct hdcp_port_data *);
	int (*close_hdcp_session)(struct device *, struct hdcp_port_data *);
};

struct i915_hwmon {
	struct hwm_drvdata ddat;
	struct hwm_drvdata ddat_gt[2];
	struct mutex hwmon_lock;
	struct hwm_reg rg;
	int scl_shift_power;
	int scl_shift_energy;
	int scl_shift_time;
};

struct i915_irq_regs {
	i915_reg_t imr;
	i915_reg_t ier;
	i915_reg_t iir;
};

struct i915_lut_handle {
	struct list_head obj_link;
	struct i915_gem_context *ctx;
	u32 handle;
};

struct i915_mmap_offset {
	struct drm_vma_offset_node vma_node;
	struct drm_i915_gem_object *obj;
	enum i915_mmap_type mmap_type;
	struct rb_node offset;
};

struct kobj_attribute {
	struct attribute attr;
	ssize_t (*show)(struct kobject *, struct kobj_attribute *, char *);
	ssize_t (*store)(struct kobject *, struct kobj_attribute *, const char *, size_t);
};

struct i915_oa_reg;

struct i915_oa_config {
	struct i915_perf *perf;
	char uuid[37];
	int id;
	const struct i915_oa_reg *mux_regs;
	u32 mux_regs_len;
	const struct i915_oa_reg *b_counter_regs;
	u32 b_counter_regs_len;
	const struct i915_oa_reg *flex_regs;
	u32 flex_regs_len;
	struct attribute_group sysfs_metric;
	struct attribute *attrs[2];
	struct kobj_attribute sysfs_metric_id;
	struct kref ref;
	struct callback_head rcu;
};

struct i915_oa_config_bo {
	struct llist_node node;
	struct i915_oa_config *oa_config;
	struct i915_vma *vma;
};

struct i915_oa_format {
	u32 format;
	int size;
	int type;
	enum report_header header;
};

struct i915_oa_reg {
	i915_reg_t addr;
	u32 value;
};

struct i915_page_table {
	struct drm_i915_gem_object *base;
	union {
		atomic_t used;
		struct i915_page_table *stash;
	};
	bool is_compact;
};

struct i915_page_directory {
	struct i915_page_table pt;
	spinlock_t lock;
	void **entry;
};

struct i915_perf_regs {
	u32 base;
	i915_reg_t oa_head_ptr;
	i915_reg_t oa_tail_ptr;
	i915_reg_t oa_buffer;
	i915_reg_t oa_ctx_ctrl;
	i915_reg_t oa_ctrl;
	i915_reg_t oa_debug;
	i915_reg_t oa_status;
	u32 oa_ctrl_counter_format_shift;
};

struct i915_perf_group {
	struct i915_perf_stream *exclusive_stream;
	u32 num_engines;
	struct i915_perf_regs regs;
	enum oa_type type;
};

struct i915_perf_gt {
	struct mutex lock;
	struct intel_sseu sseu;
	u32 num_perf_groups;
	struct i915_perf_group *group;
};

struct i915_perf_stream_ops;

struct i915_perf_stream {
	struct i915_perf *perf;
	struct intel_uncore *uncore;
	struct intel_engine_cs *engine;
	struct mutex lock;
	u32 sample_flags;
	int sample_size;
	struct i915_gem_context *ctx;
	bool enabled;
	bool hold_preemption;
	const struct i915_perf_stream_ops *ops;
	struct i915_oa_config *oa_config;
	struct llist_head oa_config_bos;
	struct intel_context *pinned_ctx;
	u32 specific_ctx_id;
	u32 specific_ctx_id_mask;
	struct hrtimer poll_check_timer;
	wait_queue_head_t poll_wq;
	bool pollin;
	bool periodic;
	int period_exponent;
	struct {
		const struct i915_oa_format *format;
		struct i915_vma *vma;
		u8 *vaddr;
		u32 last_ctx_id;
		spinlock_t ptr_lock;
		u32 head;
		u32 tail;
	} oa_buffer;
	struct i915_vma *noa_wait;
	u64 poll_oa_period;
};

struct i915_perf_stream_ops {
	void (*enable)(struct i915_perf_stream *);
	void (*disable)(struct i915_perf_stream *);
	void (*poll_wait)(struct i915_perf_stream *, struct file *, poll_table *);
	int (*wait_unlocked)(struct i915_perf_stream *);
	int (*read)(struct i915_perf_stream *, char *, size_t, size_t *);
	void (*destroy)(struct i915_perf_stream *);
};

struct i915_power_domain_list {
	const enum intel_display_power_domain *list;
	u8 count;
};

struct i915_power_well_desc;

struct i915_power_well {
	const struct i915_power_well_desc *desc;
	struct intel_power_domain_mask domains;
	int count;
	bool hw_enabled;
	u8 instance_idx;
};

struct i915_power_well_ops;

struct i915_power_well_instance_list;

struct i915_power_well_desc {
	const struct i915_power_well_ops *ops;
	const struct i915_power_well_instance_list *instances;
	u16 irq_pipe_mask: 4;
	u16 always_on: 1;
	u16 fixed_enable_delay: 1;
	u16 has_vga: 1;
	u16 has_fuses: 1;
	u16 is_tc_tbt: 1;
	u16 enable_timeout;
};

struct i915_power_well_desc_list {
	const struct i915_power_well_desc *list;
	u8 count;
};

struct i915_power_well_instance {
	const char *name;
	const struct i915_power_domain_list *domain_list;
	enum i915_power_well_id id;
	union {
		struct {
			u8 idx;
		} vlv;
		struct {
			enum dpio_phy phy;
		} bxt;
		struct {
			u8 idx;
		} hsw;
		struct {
			u8 aux_ch;
		} xelpdp;
	};
};

struct i915_power_well_instance_list {
	const struct i915_power_well_instance *list;
	u8 count;
};

struct i915_power_well_regs;

struct i915_power_well_ops {
	const struct i915_power_well_regs *regs;
	void (*sync_hw)(struct intel_display *, struct i915_power_well *);
	void (*enable)(struct intel_display *, struct i915_power_well *);
	void (*disable)(struct intel_display *, struct i915_power_well *);
	bool (*is_enabled)(struct intel_display *, struct i915_power_well *);
};

struct i915_power_well_regs {
	i915_reg_t bios;
	i915_reg_t driver;
	i915_reg_t kvmr;
	i915_reg_t debug;
};

struct i915_priolist {
	struct list_head requests;
	struct rb_node node;
	int priority;
};

struct i915_pxp_component_ops;

struct i915_pxp_component {
	struct device *tee_dev;
	const struct i915_pxp_component_ops *ops;
	struct mutex mutex;
};

struct i915_pxp_component_ops {
	struct module *owner;
	int (*send)(struct device *, const void *, size_t, long unsigned int);
	int (*recv)(struct device *, void *, size_t, long unsigned int);
	ssize_t (*gsc_command)(struct device *, u8, u32, struct scatterlist *, size_t, struct scatterlist *);
};

struct i915_range {
	u32 start;
	u32 end;
};

struct i915_refct_sgt_ops;

struct i915_refct_sgt {
	struct kref kref;
	struct sg_table table;
	size_t size;
	const struct i915_refct_sgt_ops *ops;
};

struct i915_refct_sgt_ops {
	void (*release)(struct kref *);
};

struct i915_request_duration_cb {
	struct dma_fence_cb cb;
	ktime_t emitted;
};

struct i915_sched_node {
	struct list_head signalers_list;
	struct list_head waiters_list;
	struct list_head link;
	struct i915_sched_attr attr;
	unsigned int flags;
	intel_engine_mask_t semaphores;
};

struct i915_request_watchdog {
	struct llist_node link;
	struct hrtimer timer;
};

struct i915_request {
	struct dma_fence fence;
	spinlock_t lock;
	struct drm_i915_private *i915;
	struct intel_engine_cs *engine;
	struct intel_context *context;
	struct intel_ring *ring;
	struct intel_timeline *timeline;
	struct list_head signal_link;
	struct llist_node signal_node;
	long unsigned int rcustate;
	struct pin_cookie cookie;
	struct i915_sw_fence submit;
	union {
		wait_queue_entry_t submitq;
		struct i915_sw_dma_fence_cb dmaq;
		struct i915_request_duration_cb duration;
	};
	struct llist_head execute_cb;
	struct i915_sw_fence semaphore;
	struct irq_work submit_work;
	struct i915_sched_node sched;
	struct i915_dependency dep;
	intel_engine_mask_t execution_mask;
	const u32 *hwsp_seqno;
	u32 head;
	u32 infix;
	u32 postfix;
	u32 tail;
	u32 wa_tail;
	u32 reserved_space;
	struct i915_vma_resource *batch_res;
	struct i915_capture_list *capture_list;
	long unsigned int emitted_jiffies;
	struct list_head link;
	struct i915_request_watchdog watchdog;
	struct list_head guc_fence_link;
	u8 guc_prio;
	wait_queue_entry_t hucq;
};

struct i915_request_coredump {
	long unsigned int flags;
	pid_t pid;
	u32 context;
	u32 seqno;
	u32 head;
	u32 tail;
	struct i915_sched_attr sched_attr;
};

struct i915_sched_engine {
	struct kref ref;
	spinlock_t lock;
	struct list_head requests;
	struct list_head hold;
	struct tasklet_struct tasklet;
	struct i915_priolist default_priolist;
	int queue_priority_hint;
	struct rb_root_cached queue;
	bool no_priolist;
	void *private_data;
	void (*destroy)(struct kref *);
	bool (*disabled)(struct i915_sched_engine *);
	void (*kick_backend)(const struct i915_request *, int);
	void (*bump_inflight_request_prio)(struct i915_request *, int);
	void (*retire_inflight_request_prio)(struct i915_request *);
	void (*schedule)(struct i915_request *, const struct i915_sched_attr *);
};

struct i915_str_attribute {
	struct device_attribute attr;
	const char *str;
};

struct i915_sw_dma_fence_cb_timer {
	struct i915_sw_dma_fence_cb base;
	struct dma_fence *dma;
	struct timer_list timer;
	struct irq_work work;
	struct callback_head rcu;
};

struct i915_syncmap {
	u64 prefix;
	unsigned int height;
	unsigned int bitmap;
	struct i915_syncmap *parent;
	union {
		struct {
			struct {} __empty_seqno;
			u32 seqno[0];
		};
		struct {
			struct {} __empty_child;
			struct i915_syncmap *child[0];
		};
	};
};

struct i915_ttm_buddy_manager {
	struct ttm_resource_manager manager;
	struct drm_buddy mm;
	struct list_head reserved;
	struct mutex lock;
	long unsigned int visible_size;
	long unsigned int visible_avail;
	long unsigned int visible_reserved;
	u64 default_page_size;
};

struct ttm_bus_placement {
	void *addr;
	phys_addr_t offset;
	bool is_iomem;
	enum ttm_caching caching;
};

struct dmem_cgroup_pool_state;

struct ttm_lru_item {
	struct list_head link;
	enum ttm_lru_item_type type;
};

struct ttm_resource {
	long unsigned int start;
	size_t size;
	uint32_t mem_type;
	uint32_t placement;
	struct ttm_bus_placement bus;
	struct ttm_buffer_object *bo;
	struct dmem_cgroup_pool_state *css;
	struct ttm_lru_item lru;
};

struct i915_ttm_buddy_resource {
	struct ttm_resource base;
	struct list_head blocks;
	long unsigned int flags;
	long unsigned int used_visible_size;
	struct drm_buddy *mm;
};

struct ttm_kmap_iter_ops;

struct ttm_kmap_iter {
	const struct ttm_kmap_iter_ops *ops;
};

struct ttm_kmap_iter_tt {
	struct ttm_kmap_iter base;
	struct ttm_tt *tt;
	pgprot_t prot;
};

struct ttm_kmap_iter_iomap {
	struct ttm_kmap_iter base;
	struct io_mapping *iomap;
	struct sg_table *st;
	resource_size_t start;
	struct {
		struct scatterlist *sg;
		long unsigned int i;
		long unsigned int end;
		long unsigned int offs;
	} cache;
};

struct i915_ttm_memcpy_arg {
	union {
		struct ttm_kmap_iter_tt tt;
		struct ttm_kmap_iter_iomap io;
	} _dst_iter;
	union {
		struct ttm_kmap_iter_tt tt;
		struct ttm_kmap_iter_iomap io;
	} _src_iter;
	struct ttm_kmap_iter *dst_iter;
	struct ttm_kmap_iter *src_iter;
	long unsigned int num_pages;
	bool clear;
	struct i915_refct_sgt *src_rsgt;
	struct i915_refct_sgt *dst_rsgt;
};

struct i915_ttm_memcpy_work {
	struct dma_fence fence;
	struct work_struct work;
	spinlock_t lock;
	struct irq_work irq_work;
	struct dma_fence_cb cb;
	struct i915_ttm_memcpy_arg arg;
	struct drm_i915_private *i915;
	struct drm_i915_gem_object *obj;
	bool memcpy_allowed;
};

struct ttm_tt {
	struct page **pages;
	uint32_t page_flags;
	uint32_t num_pages;
	struct sg_table *sg;
	dma_addr_t *dma_address;
	struct file *swap_storage;
	enum ttm_caching caching;
};

struct i915_ttm_tt {
	struct ttm_tt ttm;
	struct device *dev;
	struct i915_refct_sgt cached_rsgt;
	bool is_shmem;
	struct file *filp;
};

struct i915_vm_pt_stash {
	struct i915_page_table *pt[2];
	int pt_sz;
};

struct i915_vma {
	struct drm_mm_node node;
	struct i915_address_space *vm;
	const struct i915_vma_ops *ops;
	struct drm_i915_gem_object *obj;
	struct sg_table *pages;
	void *iomap;
	void *private;
	struct i915_fence_reg *fence;
	u64 size;
	struct i915_page_sizes page_sizes;
	struct i915_mmap_offset *mmo;
	u32 guard;
	u32 fence_size;
	u32 fence_alignment;
	u32 display_alignment;
	atomic_t open_count;
	atomic_t flags;
	struct i915_active active;
	atomic_t pages_count;
	bool vm_ddestroy;
	struct i915_gtt_view gtt_view;
	struct list_head vm_link;
	struct list_head obj_link;
	struct rb_node obj_node;
	struct list_head evict_link;
	struct list_head closed_link;
	struct i915_vma_resource *resource;
};

struct i915_vma_bindinfo {
	struct sg_table *pages;
	struct i915_page_sizes page_sizes;
	struct i915_refct_sgt *pages_rsgt;
	bool readonly: 1;
	bool lmem: 1;
};

struct internal_state;

struct z_stream_s {
	const Byte *next_in;
	uLong avail_in;
	uLong total_in;
	Byte *next_out;
	uLong avail_out;
	uLong total_out;
	char *msg;
	struct internal_state *state;
	void *workspace;
	int data_type;
	uLong adler;
	uLong reserved;
};

struct i915_vma_compress {
	struct folio_batch pool;
	struct z_stream_s zstream;
	void *tmp;
};

struct i915_vma_coredump {
	struct i915_vma_coredump *next;
	char name[20];
	u64 gtt_offset;
	u64 gtt_size;
	u32 gtt_page_sizes;
	int unused;
	struct list_head page_list;
};

struct i915_vma_resource {
	struct dma_fence unbind_fence;
	spinlock_t lock;
	refcount_t hold_count;
	struct work_struct work;
	struct i915_sw_fence chain;
	struct rb_node rb;
	u64 __subtree_last;
	struct i915_address_space *vm;
	intel_wakeref_t wakeref;
	struct i915_vma_bindinfo bi;
	struct intel_memory_region *mr;
	const struct i915_vma_ops *ops;
	void *private;
	u64 start;
	u64 node_size;
	u64 vma_size;
	u32 guard;
	u32 page_sizes_gtt;
	u32 bound_flags;
	bool allocated: 1;
	bool immediate_unbind: 1;
	bool needs_wakeref: 1;
	bool skip_pte_rewrite: 1;
	u32 *tlb;
};

struct i915_vma_work {
	struct dma_fence_work base;
	struct i915_address_space *vm;
	struct i915_vm_pt_stash stash;
	struct i915_vma_resource *vma_res;
	struct drm_i915_gem_object *obj;
	struct i915_sw_dma_fence_cb cb;
	unsigned int pat_index;
	unsigned int flags;
};

struct i915_wa {
	union {
		i915_reg_t reg;
		i915_mcr_reg_t mcr_reg;
	};
	u32 clr;
	u32 set;
	u32 read;
	u32 masked_reg: 1;
	u32 is_mcr: 1;
};

struct ia_constants {
	unsigned int min_gpu_freq;
	unsigned int max_gpu_freq;
	unsigned int min_ring_freq;
	unsigned int max_ia_freq;
};

struct iapp_layer2_update {
	u8 da[6];
	u8 sa[6];
	__be16 len;
	u8 dsap;
	u8 ssap;
	u8 control;
	u8 xid_info[3];
};

struct iattr {
	unsigned int ia_valid;
	umode_t ia_mode;
	union {
		kuid_t ia_uid;
		vfsuid_t ia_vfsuid;
	};
	union {
		kgid_t ia_gid;
		vfsgid_t ia_vfsgid;
	};
	loff_t ia_size;
	struct timespec64 ia_atime;
	struct timespec64 ia_mtime;
	struct timespec64 ia_ctime;
	struct file *ia_file;
};

union ibs_fetch_ctl {
	__u64 val;
	struct {
		__u64 fetch_maxcnt: 16;
		__u64 fetch_cnt: 16;
		__u64 fetch_lat: 16;
		__u64 fetch_en: 1;
		__u64 fetch_val: 1;
		__u64 fetch_comp: 1;
		__u64 ic_miss: 1;
		__u64 phy_addr_valid: 1;
		__u64 l1tlb_pgsz: 2;
		__u64 l1tlb_miss: 1;
		__u64 l2tlb_miss: 1;
		__u64 rand_en: 1;
		__u64 fetch_l2_miss: 1;
		__u64 l3_miss_only: 1;
		__u64 fetch_oc_miss: 1;
		__u64 fetch_l3_miss: 1;
		__u64 reserved: 2;
	};
};

union ibs_op_ctl {
	__u64 val;
	struct {
		__u64 opmaxcnt: 16;
		__u64 l3_miss_only: 1;
		__u64 op_en: 1;
		__u64 op_val: 1;
		__u64 cnt_ctl: 1;
		__u64 opmaxcnt_ext: 7;
		__u64 reserved0: 5;
		__u64 opcurcnt: 27;
		__u64 reserved1: 5;
	};
};

union ibs_op_data {
	__u64 val;
	struct {
		__u64 comp_to_ret_ctr: 16;
		__u64 tag_to_ret_ctr: 16;
		__u64 reserved1: 2;
		__u64 op_return: 1;
		__u64 op_brn_taken: 1;
		__u64 op_brn_misp: 1;
		__u64 op_brn_ret: 1;
		__u64 op_rip_invalid: 1;
		__u64 op_brn_fuse: 1;
		__u64 op_microcode: 1;
		__u64 reserved2: 23;
	};
};

union ibs_op_data2 {
	__u64 val;
	struct {
		__u64 data_src_lo: 3;
		__u64 reserved0: 1;
		__u64 rmt_node: 1;
		__u64 cache_hit_st: 1;
		__u64 data_src_hi: 2;
		__u64 reserved1: 56;
	};
};

union ibs_op_data3 {
	__u64 val;
	struct {
		__u64 ld_op: 1;
		__u64 st_op: 1;
		__u64 dc_l1tlb_miss: 1;
		__u64 dc_l2tlb_miss: 1;
		__u64 dc_l1tlb_hit_2m: 1;
		__u64 dc_l1tlb_hit_1g: 1;
		__u64 dc_l2tlb_hit_2m: 1;
		__u64 dc_miss: 1;
		__u64 dc_mis_acc: 1;
		__u64 reserved: 4;
		__u64 dc_wc_mem_acc: 1;
		__u64 dc_uc_mem_acc: 1;
		__u64 dc_locked_op: 1;
		__u64 dc_miss_no_mab_alloc: 1;
		__u64 dc_lin_addr_valid: 1;
		__u64 dc_phy_addr_valid: 1;
		__u64 dc_l2_tlb_hit_1g: 1;
		__u64 l2_miss: 1;
		__u64 sw_pf: 1;
		__u64 op_mem_width: 4;
		__u64 op_dc_miss_open_mem_reqs: 6;
		__u64 dc_miss_lat: 16;
		__u64 tlb_refill_lat: 16;
	};
};

struct ibx_audio_regs {
	i915_reg_t hdmiw_hdmiedid;
	i915_reg_t aud_config;
	i915_reg_t aud_cntl_st;
	i915_reg_t aud_cntrl_st2;
};

struct ic_device {
	struct ic_device *next;
	struct net_device *dev;
	short unsigned int flags;
	short int able;
	__be32 xid;
};

struct ich8_pr {
	u32 base: 13;
	u32 reserved1: 2;
	u32 rpe: 1;
	u32 limit: 13;
	u32 reserved2: 2;
	u32 wpe: 1;
};

union ich8_flash_protected_range {
	struct ich8_pr range;
	u32 regval;
};

struct ich8_hsflctl {
	u16 flcgo: 1;
	u16 flcycle: 2;
	u16 reserved: 5;
	u16 fldbcount: 2;
	u16 flockdn: 6;
};

struct ich8_hsfsts {
	u16 flcdone: 1;
	u16 flcerr: 1;
	u16 dael: 1;
	u16 berasesz: 2;
	u16 flcinprog: 1;
	u16 reserved1: 2;
	u16 reserved2: 6;
	u16 fldesvalid: 1;
	u16 flockdn: 1;
};

union ich8_hws_flash_ctrl {
	struct ich8_hsflctl hsf_ctrl;
	u16 regval;
};

union ich8_hws_flash_status {
	struct ich8_hsfsts hsf_status;
	u16 regval;
};

struct ich_laptop {
	u16 device;
	u16 subvendor;
	u16 subdevice;
};

struct skl_wrpll_params {
	u32 dco_fraction;
	u32 dco_integer;
	u32 qdiv_ratio;
	u32 qdiv_mode;
	u32 kdiv;
	u32 pdiv;
	u32 central_freq;
};

struct icl_combo_pll_params {
	int clock;
	struct skl_wrpll_params wrpll;
};

struct icl_ddi_buf_trans {
	u8 dw2_swing_sel;
	u8 dw7_n_scalar;
	u8 dw4_cursor_coeff;
	u8 dw4_post_cursor_2;
	u8 dw4_post_cursor_1;
};

struct icl_mg_phy_ddi_buf_trans {
	u8 cri_txdeemph_override_11_6;
	u8 cri_txdeemph_override_5_0;
	u8 cri_txdeemph_override_17_12;
};

struct icl_port_dpll {
	struct intel_shared_dpll *pll;
	struct intel_dpll_hw_state hw_state;
};

struct icl_procmon {
	const char *name;
	u32 dw1;
	u32 dw9;
	u32 dw10;
};

struct iclkip_params {
	u32 iclk_virtual_root_freq;
	u32 iclk_pi_range;
	u32 divsel;
	u32 phaseinc;
	u32 auxdiv;
	u32 phasedir;
	u32 desired_divisor;
};

struct icmp6_err {
	int err;
	int fatal;
};

struct icmp6_filter {
	__u32 data[8];
};

struct icmpv6_echo {
	__be16 identifier;
	__be16 sequence;
};

struct icmpv6_nd_advt {
	__u32 reserved: 5;
	__u32 override: 1;
	__u32 solicited: 1;
	__u32 router: 1;
	__u32 reserved2: 24;
};

struct icmpv6_nd_ra {
	__u8 hop_limit;
	__u8 reserved: 3;
	__u8 router_pref: 2;
	__u8 home_agent: 1;
	__u8 other: 1;
	__u8 managed: 1;
	__be16 rt_lifetime;
};

struct icmp6hdr {
	__u8 icmp6_type;
	__u8 icmp6_code;
	__sum16 icmp6_cksum;
	union {
		__be32 un_data32[1];
		__be16 un_data16[2];
		__u8 un_data8[4];
		struct icmpv6_echo u_echo;
		struct icmpv6_nd_advt u_nd_advt;
		struct icmpv6_nd_ra u_nd_ra;
	} icmp6_dataun;
};

struct icmphdr {
	__u8 type;
	__u8 code;
	__sum16 checksum;
	union {
		struct {
			__be16 id;
			__be16 sequence;
		} echo;
		__be32 gateway;
		struct {
			__be16 __unused;
			__be16 mtu;
		} frag;
		__u8 reserved[4];
	} un;
};

struct ip_options_rcu {
	struct callback_head rcu;
	struct ip_options opt;
};

struct ip_options_data {
	struct ip_options_rcu opt;
	char data[40];
};

struct icmp_bxm {
	struct sk_buff *skb;
	int offset;
	int data_len;
	struct {
		struct icmphdr icmph;
		__be32 times[3];
	} data;
	int head_len;
	struct ip_options_data replyopts;
};

struct icmp_control {
	enum skb_drop_reason (*handler)(struct sk_buff *);
	short int error;
};

struct icmp_err {
	int errno;
	unsigned int fatal: 1;
};

struct icmp_ext_echo_ctype3_hdr {
	__be16 afi;
	__u8 addrlen;
	__u8 reserved;
};

struct icmp_extobj_hdr {
	__be16 length;
	__u8 class_num;
	__u8 class_type;
};

struct icmp_ext_echo_iio {
	struct icmp_extobj_hdr extobj_hdr;
	union {
		char name[16];
		__be32 ifindex;
		struct {
			struct icmp_ext_echo_ctype3_hdr ctype3_hdr;
			union {
				__be32 ipv4_addr;
				struct in6_addr ipv6_addr;
			} ip_addr;
		} addr;
	} ident;
};

struct icmp_ext_hdr {
	__u8 reserved1: 4;
	__u8 version: 4;
	__u8 reserved2;
	__sum16 checksum;
};

struct icmp_filter {
	__u32 data;
};

struct icmp_mib {
	long unsigned int mibs[30];
};

struct icmpmsg_mib {
	atomic_long_t mibs[512];
};

struct icmpv6_mib {
	long unsigned int mibs[7];
};

struct icmpv6_mib_device {
	atomic_long_t mibs[7];
};

struct icmpv6_msg {
	struct sk_buff *skb;
	int offset;
	uint8_t type;
};

struct icmpv6msg_mib {
	atomic_long_t mibs[512];
};

struct icmpv6msg_mib_device {
	atomic_long_t mibs[512];
};

struct id_proc_event {
	__kernel_pid_t process_pid;
	__kernel_pid_t process_tgid;
	union {
		__u32 ruid;
		__u32 rgid;
	} r;
	union {
		__u32 euid;
		__u32 egid;
	} e;
};

struct ida_bitmap {
	long unsigned int bitmap[16];
};

struct idempotent {
	const void *cookie;
	struct hlist_node entry;
	struct completion complete;
	int ret;
};

struct idle_timer {
	struct hrtimer timer;
	int done;
};

struct idmap_legacy_upcalldata;

struct idmap {
	struct rpc_pipe_dir_object idmap_pdo;
	struct rpc_pipe *idmap_pipe;
	struct idmap_legacy_upcalldata *idmap_upcall_data;
	struct mutex idmap_mutex;
	struct user_namespace *user_ns;
};

struct idmap_msg {
	__u8 im_type;
	__u8 im_conv;
	char im_name[128];
	__u32 im_id;
	__u8 im_status;
};

struct idmap_legacy_upcalldata {
	struct rpc_pipe_msg pipe_msg;
	struct idmap_msg idmap_msg;
	struct key *authkey;
	struct idmap *idmap;
};

struct idt_data {
	unsigned int vector;
	unsigned int segment;
	struct idt_bits bits;
	const void *addr;
};

struct ieee80211_addba_ext_ie {
	u8 data;
};

struct ieee80211_adv_ttlm_info {
	u16 switch_time;
	u32 duration;
	u16 map;
	bool active;
};

struct ieee80211_aid_response_ie {
	__le16 aid;
	u8 switch_count;
	__le16 response_int;
} __attribute__((packed));

struct ieee80211_sta;

struct ieee80211_ampdu_params {
	enum ieee80211_ampdu_mlme_action action;
	struct ieee80211_sta *sta;
	u16 tid;
	u16 ssn;
	u16 buf_size;
	bool amsdu;
	u16 timeout;
};

struct ieee80211_ba_event {
	struct ieee80211_sta *sta;
	u16 tid;
	u16 ssn;
};

struct ieee80211_eht_operation_info {
	u8 control;
	u8 ccfs0;
	u8 ccfs1;
	u8 optional[0];
};

struct ieee80211_bandwidth_indication {
	u8 params;
	struct ieee80211_eht_operation_info info;
};

struct ieee80211_bar {
	__le16 frame_control;
	__le16 duration;
	__u8 ra[6];
	__u8 ta[6];
	__le16 control;
	__le16 start_seq_num;
};

struct ieee80211_rate;

struct ieee80211_bss {
	u32 device_ts_beacon;
	u32 device_ts_presp;
	bool wmm_used;
	bool uapsd_supported;
	u8 supp_rates[32];
	size_t supp_rates_len;
	struct ieee80211_rate *beacon_rate;
	u32 vht_cap_info;
	bool has_erp_value;
	u8 erp_value;
	u8 corrupt_data;
	u8 valid_data;
};

struct ieee80211_chan_req {
	struct cfg80211_chan_def oper;
	struct cfg80211_chan_def ap;
};

struct ieee80211_mu_group_data {
	u8 membership[8];
	u8 position[16];
};

struct ieee80211_p2p_noa_desc {
	u8 count;
	__le32 duration;
	__le32 interval;
	__le32 start_time;
} __attribute__((packed));

struct ieee80211_p2p_noa_attr {
	u8 index;
	u8 oppps_ctwindow;
	struct ieee80211_p2p_noa_desc desc[4];
};

struct ieee80211_fils_discovery {
	u32 min_interval;
	u32 max_interval;
};

struct ieee80211_parsed_tpe_eirp {
	bool valid;
	s8 power[5];
	u8 count;
};

struct ieee80211_parsed_tpe_psd {
	bool valid;
	s8 power[16];
	u8 count;
	u8 n;
};

struct ieee80211_parsed_tpe {
	struct ieee80211_parsed_tpe_eirp max_local[2];
	struct ieee80211_parsed_tpe_eirp max_reg_client[2];
	struct ieee80211_parsed_tpe_psd psd_local[2];
	struct ieee80211_parsed_tpe_psd psd_reg_client[2];
};

struct ieee80211_vif;

struct ieee80211_ftm_responder_params;

struct ieee80211_chanctx_conf;

struct ieee80211_bss_conf {
	struct ieee80211_vif *vif;
	struct cfg80211_bss *bss;
	const u8 *bssid;
	unsigned int link_id;
	u8 addr[6];
	u8 htc_trig_based_pkt_ext;
	bool uora_exists;
	u8 uora_ocw_range;
	u16 frame_time_rts_th;
	bool he_support;
	bool twt_requester;
	bool twt_responder;
	bool twt_protected;
	bool twt_broadcast;
	bool use_cts_prot;
	bool use_short_preamble;
	bool use_short_slot;
	bool enable_beacon;
	u8 dtim_period;
	u16 beacon_int;
	u16 assoc_capability;
	u64 sync_tsf;
	u32 sync_device_ts;
	u8 sync_dtim_count;
	u32 basic_rates;
	struct ieee80211_rate *beacon_rate;
	int mcast_rate[6];
	u16 ht_operation_mode;
	s32 cqm_rssi_thold;
	u32 cqm_rssi_hyst;
	s32 cqm_rssi_low;
	s32 cqm_rssi_high;
	struct ieee80211_chan_req chanreq;
	struct ieee80211_mu_group_data mu_group;
	bool qos;
	bool hidden_ssid;
	int txpower;
	enum nl80211_tx_power_setting txpower_type;
	struct ieee80211_p2p_noa_attr p2p_noa_attr;
	bool allow_p2p_go_ps;
	u16 max_idle_period;
	bool protected_keep_alive;
	bool ftm_responder;
	struct ieee80211_ftm_responder_params *ftmr_params;
	bool nontransmitted;
	u8 transmitter_bssid[6];
	u8 bssid_index;
	u8 bssid_indicator;
	bool ema_ap;
	u8 profile_periodicity;
	struct {
		u32 params;
		u16 nss_set;
	} he_oper;
	struct ieee80211_he_obss_pd he_obss_pd;
	struct cfg80211_he_bss_color he_bss_color;
	struct ieee80211_fils_discovery fils_discovery;
	u32 unsol_bcast_probe_resp_interval;
	struct cfg80211_bitrate_mask beacon_tx_rate;
	enum ieee80211_ap_reg_power power_type;
	struct ieee80211_parsed_tpe tpe;
	u8 pwr_reduction;
	bool eht_support;
	bool csa_active;
	bool mu_mimo_owner;
	struct ieee80211_chanctx_conf *chanctx_conf;
	bool color_change_active;
	u8 color_change_color;
	bool ht_ldpc;
	bool vht_ldpc;
	bool he_ldpc;
	bool vht_su_beamformer;
	bool vht_su_beamformee;
	bool vht_mu_beamformer;
	bool vht_mu_beamformee;
	bool he_su_beamformer;
	bool he_su_beamformee;
	bool he_mu_beamformer;
	bool he_full_ul_mumimo;
	bool eht_su_beamformer;
	bool eht_su_beamformee;
	bool eht_mu_beamformer;
	bool eht_80mhz_full_bw_ul_mumimo;
	u8 bss_param_ch_cnt;
	u8 bss_param_ch_cnt_link_id;
};

struct ieee80211_bss_max_idle_period_ie {
	__le16 max_idle_period;
	u8 idle_options;
} __attribute__((packed));

struct ieee80211_bssid_index {
	u8 bssid_index;
	u8 dtim_period;
	u8 dtim_count;
};

struct ieee80211_ch_switch_timing {
	__le16 switch_time;
	__le16 switch_timeout;
};

struct ieee80211_chanctx_conf {
	struct cfg80211_chan_def def;
	struct cfg80211_chan_def min_def;
	struct cfg80211_chan_def ap;
	int radio_idx;
	u8 rx_chains_static;
	u8 rx_chains_dynamic;
	bool radar_enabled;
	long: 0;
	u8 drv_priv[0];
};

struct ieee80211_chanctx {
	struct list_head list;
	struct callback_head callback_head;
	struct list_head assigned_links;
	struct list_head reserved_links;
	enum ieee80211_chanctx_replace_state replace_state;
	struct ieee80211_chanctx *replace_ctx;
	enum ieee80211_chanctx_mode mode;
	bool driver_present;
	struct ieee80211_chan_req req;
	bool radar_detected;
	struct ieee80211_chanctx_conf conf;
};

struct ieee80211_channel {
	enum nl80211_band band;
	u32 center_freq;
	u16 freq_offset;
	u16 hw_value;
	u32 flags;
	int max_antenna_gain;
	int max_power;
	int max_reg_power;
	bool beacon_found;
	u32 orig_flags;
	int orig_mag;
	int orig_mpwr;
	enum nl80211_dfs_state dfs_state;
	long unsigned int dfs_state_entered;
	unsigned int dfs_cac_ms;
	s8 psd;
};

struct ieee80211_channel_sw_ie {
	u8 mode;
	u8 new_ch_num;
	u8 count;
};

struct ieee80211_channel_switch {
	u64 timestamp;
	u32 device_timestamp;
	bool block_tx;
	struct cfg80211_chan_def chandef;
	u8 count;
	u8 link_id;
	u32 delay;
};

struct ieee80211_color_change_settings {
	u16 counter_offset_beacon;
	u16 counter_offset_presp;
	u8 count;
};

struct ieee80211_conf {
	u32 flags;
	int power_level;
	int dynamic_ps_timeout;
	u16 listen_interval;
	u8 ps_dtim_period;
	u8 long_frame_max_tx_count;
	u8 short_frame_max_tx_count;
	struct cfg80211_chan_def chandef;
	bool radar_enabled;
	enum ieee80211_smps_mode smps_mode;
};

struct ieee80211_conn_settings {
	enum ieee80211_conn_mode mode;
	enum ieee80211_conn_bw_limit bw_limit;
};

struct ieee80211_country_ie_triplet {
	union {
		struct {
			u8 first_channel;
			u8 num_channels;
			s8 max_power;
		} chans;
		struct {
			u8 reg_extension_id;
			u8 reg_class;
			u8 coverage_class;
		} ext;
	};
};

struct ieee80211_csa_ie {
	struct ieee80211_chan_req chanreq;
	u8 mode;
	u8 count;
	u8 ttl;
	u16 pre_value;
	u16 reason_code;
	u32 max_switch_time;
};

struct ieee80211_csa_settings {
	const u16 *counter_offsets_beacon;
	const u16 *counter_offsets_presp;
	int n_counter_offsets_beacon;
	int n_counter_offsets_presp;
	u8 count;
};

struct ieee80211_cts {
	__le16 frame_control;
	__le16 duration;
	u8 ra[6];
};

struct ieee80211_eht_cap_elem_fixed {
	u8 mac_cap_info[2];
	u8 phy_cap_info[9];
};

struct ieee80211_eht_cap_elem {
	struct ieee80211_eht_cap_elem_fixed fixed;
	u8 optional[0];
};

struct ieee80211_eht_mcs_nss_supp_20mhz_only {
	union {
		struct {
			u8 rx_tx_mcs7_max_nss;
			u8 rx_tx_mcs9_max_nss;
			u8 rx_tx_mcs11_max_nss;
			u8 rx_tx_mcs13_max_nss;
		};
		u8 rx_tx_max_nss[4];
	};
};

struct ieee80211_eht_mcs_nss_supp_bw {
	union {
		struct {
			u8 rx_tx_mcs9_max_nss;
			u8 rx_tx_mcs11_max_nss;
			u8 rx_tx_mcs13_max_nss;
		};
		u8 rx_tx_max_nss[3];
	};
};

struct ieee80211_eht_mcs_nss_supp {
	union {
		struct ieee80211_eht_mcs_nss_supp_20mhz_only only_20mhz;
		struct {
			struct ieee80211_eht_mcs_nss_supp_bw _80;
			struct ieee80211_eht_mcs_nss_supp_bw _160;
			struct ieee80211_eht_mcs_nss_supp_bw _320;
		} bw;
	};
};

struct ieee80211_eht_operation {
	u8 params;
	struct ieee80211_eht_mcs_nss_supp_20mhz_only basic_mcs_nss;
	u8 optional[0];
};

struct ieee80211_tdls_lnkie;

struct ieee80211_tim_ie;

struct ieee80211_ht_operation;

struct ieee80211_vht_operation;

struct ieee80211_he_spr;

struct ieee80211_mu_edca_param_set;

struct ieee80211_he_6ghz_capa;

struct ieee80211_rann_ie;

struct ieee80211_ext_chansw_ie;

struct ieee80211_wide_bw_chansw_ie;

struct ieee80211_timeout_interval_ie;

struct ieee80211_sec_chan_offs_ie;

struct ieee80211_mesh_chansw_params_ie;

struct ieee80211_multiple_bssid_configuration;

struct ieee80211_s1g_oper_ie;

struct ieee80211_s1g_bcn_compat_ie;

struct ieee80211_ttlm_elem;

struct ieee802_11_elems {
	const u8 *ie_start;
	size_t total_len;
	u32 crc;
	const struct ieee80211_tdls_lnkie *lnk_id;
	const struct ieee80211_ch_switch_timing *ch_sw_timing;
	const u8 *ext_capab;
	const u8 *ssid;
	const u8 *supp_rates;
	const u8 *ds_params;
	const struct ieee80211_tim_ie *tim;
	const u8 *rsn;
	const u8 *rsnx;
	const u8 *erp_info;
	const u8 *ext_supp_rates;
	const u8 *wmm_info;
	const u8 *wmm_param;
	const struct ieee80211_ht_cap *ht_cap_elem;
	const struct ieee80211_ht_operation *ht_operation;
	const struct ieee80211_vht_cap *vht_cap_elem;
	const struct ieee80211_vht_operation *vht_operation;
	const struct ieee80211_meshconf_ie *mesh_config;
	const u8 *he_cap;
	const struct ieee80211_he_operation *he_operation;
	const struct ieee80211_he_spr *he_spr;
	const struct ieee80211_mu_edca_param_set *mu_edca_param_set;
	const struct ieee80211_he_6ghz_capa *he_6ghz_capa;
	const u8 *uora_element;
	const u8 *mesh_id;
	const u8 *peering;
	const __le16 *awake_window;
	const u8 *preq;
	const u8 *prep;
	const u8 *perr;
	const struct ieee80211_rann_ie *rann;
	const struct ieee80211_channel_sw_ie *ch_switch_ie;
	const struct ieee80211_ext_chansw_ie *ext_chansw_ie;
	const struct ieee80211_wide_bw_chansw_ie *wide_bw_chansw_ie;
	const u8 *max_channel_switch_time;
	const u8 *country_elem;
	const u8 *pwr_constr_elem;
	const u8 *cisco_dtpc_elem;
	const struct ieee80211_timeout_interval_ie *timeout_int;
	const u8 *opmode_notif;
	const struct ieee80211_sec_chan_offs_ie *sec_chan_offs;
	struct ieee80211_mesh_chansw_params_ie *mesh_chansw_params_ie;
	const struct ieee80211_bss_max_idle_period_ie *max_idle_period_ie;
	const struct ieee80211_multiple_bssid_configuration *mbssid_config_ie;
	const struct ieee80211_bssid_index *bssid_index;
	u8 max_bssid_indicator;
	u8 dtim_count;
	u8 dtim_period;
	const struct ieee80211_addba_ext_ie *addba_ext_ie;
	const struct ieee80211_s1g_cap *s1g_capab;
	const struct ieee80211_s1g_oper_ie *s1g_oper;
	const struct ieee80211_s1g_bcn_compat_ie *s1g_bcn_compat;
	const struct ieee80211_aid_response_ie *aid_resp;
	const struct ieee80211_eht_cap_elem *eht_cap;
	const struct ieee80211_eht_operation *eht_operation;
	const struct ieee80211_multi_link_elem *ml_basic;
	const struct ieee80211_multi_link_elem *ml_reconf;
	const struct ieee80211_multi_link_elem *ml_epcs;
	const struct ieee80211_bandwidth_indication *bandwidth_indication;
	const struct ieee80211_ttlm_elem *ttlm[2];
	struct ieee80211_parsed_tpe tpe;
	struct ieee80211_parsed_tpe csa_tpe;
	u8 ext_capab_len;
	u8 ssid_len;
	u8 supp_rates_len;
	u8 tim_len;
	u8 rsn_len;
	u8 rsnx_len;
	u8 ext_supp_rates_len;
	u8 wmm_info_len;
	u8 wmm_param_len;
	u8 he_cap_len;
	u8 mesh_id_len;
	u8 peering_len;
	u8 preq_len;
	u8 prep_len;
	u8 perr_len;
	u8 country_elem_len;
	u8 bssid_index_len;
	u8 eht_cap_len;
	size_t ml_basic_len;
	size_t ml_reconf_len;
	size_t ml_epcs_len;
	u8 ttlm_num;
	struct ieee80211_mle_per_sta_profile *prof;
	size_t sta_prof_len;
	u8 parse_error;
};

struct ieee80211_elems_parse {
	struct ieee802_11_elems elems;
	const struct element *ml_basic_elem;
	const struct element *ml_reconf_elem;
	const struct element *ml_epcs_elem;
	bool multi_link_inner;
	bool skip_vendor;
	size_t scratch_len;
	u8 *scratch_pos;
	u8 scratch[0];
};

struct ieee80211_elems_parse_params {
	enum ieee80211_conn_mode mode;
	const u8 *start;
	size_t len;
	bool action;
	u64 filter;
	u32 crc;
	struct cfg80211_bss *bss;
	int link_id;
	bool from_ap;
};

struct ieee80211_mutable_offsets {
	u16 tim_offset;
	u16 tim_length;
	u16 cntdwn_counter_offs[2];
	u16 mbssid_off;
};

struct ieee80211_ema_beacons {
	u8 cnt;
	struct {
		struct sk_buff *skb;
		struct ieee80211_mutable_offsets offs;
	} bcn[0];
};

struct ieee80211_rssi_event {
	enum ieee80211_rssi_event_data data;
};

struct ieee80211_mlme_event {
	enum ieee80211_mlme_event_data data;
	enum ieee80211_mlme_event_status status;
	u16 reason;
};

struct ieee80211_event {
	enum ieee80211_event_type type;
	union {
		struct ieee80211_rssi_event rssi;
		struct ieee80211_mlme_event mlme;
		struct ieee80211_ba_event ba;
	} u;
};

struct ieee80211_ext {
	__le16 frame_control;
	__le16 duration;
	union {
		struct {
			u8 sa[6];
			__le32 timestamp;
			u8 change_seq;
			u8 variable[0];
		} __attribute__((packed)) s1g_beacon;
		struct {
			u8 sa[6];
			__le32 timestamp;
			u8 change_seq;
			u8 next_tbtt[3];
			u8 variable[0];
		} __attribute__((packed)) s1g_short_beacon;
	} u;
};

struct ieee80211_ext_chansw_ie {
	u8 mode;
	u8 new_operating_class;
	u8 new_ch_num;
	u8 count;
};

struct ieee80211_fast_rx {
	struct net_device *dev;
	enum nl80211_iftype vif_type;
	u8 vif_addr[6];
	u8 rfc1042_hdr[6];
	__be16 control_port_protocol;
	__le16 expected_ds_bits;
	u8 icv_len;
	u8 key: 1;
	u8 internal_forward: 1;
	u8 uses_rss: 1;
	u8 da_offs;
	u8 sa_offs;
	struct callback_head callback_head;
};

struct ieee80211_key;

struct ieee80211_fast_tx {
	struct ieee80211_key *key;
	u8 hdr_len;
	u8 sa_offs;
	u8 da_offs;
	u8 pn_offs;
	u8 band;
	short: 0;
	u8 hdr[56];
	struct callback_head callback_head;
};

struct ieee80211_fragment_entry {
	struct sk_buff_head skb_list;
	long unsigned int first_frag_time;
	u16 seq;
	u16 extra_len;
	u16 last_frag;
	u8 rx_queue;
	u8 check_sequential_pn: 1;
	u8 is_protected: 1;
	u8 last_pn[6];
	unsigned int key_color;
};

struct ieee80211_fragment_cache {
	struct ieee80211_fragment_entry entries[4];
	unsigned int next;
};

struct ieee80211_freq_range {
	u32 start_freq_khz;
	u32 end_freq_khz;
	u32 max_bandwidth_khz;
};

struct ieee80211_ftm_responder_params {
	const u8 *lci;
	const u8 *civicloc;
	size_t lci_len;
	size_t civicloc_len;
};

struct ieee80211_hdr {
	__le16 frame_control;
	__le16 duration_id;
	union {
		struct {
			u8 addr1[6];
			u8 addr2[6];
			u8 addr3[6];
		};
		struct {
			u8 addr1[6];
			u8 addr2[6];
			u8 addr3[6];
		} addrs;
	};
	__le16 seq_ctrl;
	u8 addr4[6];
};

struct ieee80211_hdr_3addr {
	__le16 frame_control;
	__le16 duration_id;
	u8 addr1[6];
	u8 addr2[6];
	u8 addr3[6];
	__le16 seq_ctrl;
};

struct ieee80211_he_6ghz_capa {
	__le16 capa;
};

struct ieee80211_he_6ghz_oper {
	u8 primary;
	u8 control;
	u8 ccfs0;
	u8 ccfs1;
	u8 minrate;
};

struct ieee80211_he_cap_elem {
	u8 mac_cap_info[6];
	u8 phy_cap_info[11];
};

struct ieee80211_he_mcs_nss_supp {
	__le16 rx_mcs_80;
	__le16 tx_mcs_80;
	__le16 rx_mcs_160;
	__le16 tx_mcs_160;
	__le16 rx_mcs_80p80;
	__le16 tx_mcs_80p80;
};

struct ieee80211_he_mu_edca_param_ac_rec {
	u8 aifsn;
	u8 ecw_min_max;
	u8 mu_edca_timer;
};

struct ieee80211_he_operation {
	__le32 he_oper_params;
	__le16 he_mcs_nss_set;
	u8 optional[0];
} __attribute__((packed));

struct ieee80211_he_spr {
	u8 he_sr_control;
	u8 optional[0];
};

struct ieee80211_ht_operation {
	u8 primary_chan;
	u8 ht_param;
	__le16 operation_mode;
	__le16 stbc_param;
	u8 basic_set[16];
};

struct ieee80211_hw {
	struct ieee80211_conf conf;
	struct wiphy *wiphy;
	const char *rate_control_algorithm;
	void *priv;
	long unsigned int flags[1];
	unsigned int extra_tx_headroom;
	unsigned int extra_beacon_tailroom;
	int vif_data_size;
	int sta_data_size;
	int chanctx_data_size;
	int txq_data_size;
	u16 queues;
	u16 max_listen_interval;
	s8 max_signal;
	u8 max_rates;
	u8 max_report_rates;
	u8 max_rate_tries;
	u16 max_rx_aggregation_subframes;
	u16 max_tx_aggregation_subframes;
	u8 max_tx_fragments;
	u8 offchannel_tx_hw_queue;
	u8 radiotap_mcs_details;
	u16 radiotap_vht_details;
	struct {
		int units_pos;
		s16 accuracy;
	} radiotap_timestamp;
	netdev_features_t netdev_features;
	u8 uapsd_queues;
	u8 uapsd_max_sp_len;
	u8 max_nan_de_entries;
	u8 tx_sk_pacing_shift;
	u8 weight_multiplier;
	u32 max_mtu;
	const s8 *tx_power_levels;
	u8 max_txpwr_levels_idx;
};

struct ps_data {
	u8 tim[256];
	struct sk_buff_head bc_buf;
	atomic_t num_sta_ps;
	int dtim_count;
	bool dtim_bc_mc;
};

struct ieee80211_if_ap {
	struct list_head vlans;
	struct ps_data ps;
	atomic_t num_mcast_sta;
	bool multicast_to_unicast;
	bool active;
};

struct ieee80211_if_ibss {
	struct timer_list timer;
	struct wiphy_work csa_connection_drop_work;
	long unsigned int last_scan_completed;
	u32 basic_rates;
	bool fixed_bssid;
	bool fixed_channel;
	bool privacy;
	bool control_port;
	bool userspace_handles_dfs;
	short: 0;
	u8 bssid[6];
	u8 ssid[32];
	u8 ssid_len;
	u8 ie_len;
	u8 *ie;
	struct cfg80211_chan_def chandef;
	long unsigned int ibss_join_req;
	struct beacon_data *presp;
	struct ieee80211_ht_cap ht_capa;
	struct ieee80211_ht_cap ht_capa_mask;
	spinlock_t incomplete_lock;
	struct list_head incomplete_stations;
	enum {
		IEEE80211_IBSS_MLME_SEARCH = 0,
		IEEE80211_IBSS_MLME_JOINED = 1,
	} state;
};

struct wiphy_delayed_work {
	struct wiphy_work work;
	struct wiphy *wiphy;
	struct timer_list timer;
};

struct ieee80211_sta_tx_tspec {
	long unsigned int time_slice_start;
	u32 admitted_time;
	u8 tsid;
	s8 up;
	u32 consumed_tx_time;
	enum {
		TX_TSPEC_ACTION_NONE = 0,
		TX_TSPEC_ACTION_DOWNGRADE = 1,
		TX_TSPEC_ACTION_STOP_DOWNGRADE = 2,
	} action;
	bool downgraded;
};

struct ieee80211_mgd_auth_data;

struct ieee80211_mgd_assoc_data;

struct ieee80211_if_managed {
	struct timer_list timer;
	struct timer_list conn_mon_timer;
	struct timer_list bcn_mon_timer;
	struct wiphy_work monitor_work;
	struct wiphy_work beacon_connection_loss_work;
	struct wiphy_work csa_connection_drop_work;
	long unsigned int beacon_timeout;
	long unsigned int probe_timeout;
	int probe_send_count;
	bool nullfunc_failed;
	u8 connection_loss: 1;
	u8 driver_disconnect: 1;
	u8 reconnect: 1;
	u8 associated: 1;
	struct ieee80211_mgd_auth_data *auth_data;
	struct ieee80211_mgd_assoc_data *assoc_data;
	bool powersave;
	bool broken_ap;
	unsigned int flags;
	u16 mcast_seq_last;
	bool status_acked;
	bool status_received;
	__le16 status_fc;
	enum {
		IEEE80211_MFP_DISABLED = 0,
		IEEE80211_MFP_OPTIONAL = 1,
		IEEE80211_MFP_REQUIRED = 2,
	} mfp;
	unsigned int uapsd_queues;
	unsigned int uapsd_max_sp_len;
	u8 use_4addr;
	int rssi_min_thold;
	int rssi_max_thold;
	struct ieee80211_ht_cap ht_capa;
	struct ieee80211_ht_cap ht_capa_mask;
	struct ieee80211_vht_cap vht_capa;
	struct ieee80211_vht_cap vht_capa_mask;
	struct ieee80211_s1g_cap s1g_capa;
	struct ieee80211_s1g_cap s1g_capa_mask;
	u8 tdls_peer[6];
	struct wiphy_delayed_work tdls_peer_del_work;
	struct sk_buff *orig_teardown_skb;
	struct sk_buff *teardown_skb;
	spinlock_t teardown_lock;
	bool tdls_wider_bw_prohibited;
	struct ieee80211_sta_tx_tspec tx_tspec[4];
	struct wiphy_delayed_work tx_tspec_wk;
	u8 *assoc_req_ies;
	size_t assoc_req_ies_len;
	struct wiphy_delayed_work ml_reconf_work;
	u16 removed_links;
	struct wiphy_delayed_work ttlm_work;
	struct ieee80211_adv_ttlm_info ttlm_info;
	struct wiphy_work teardown_ttlm_work;
	u8 dialog_token_alloc;
	struct wiphy_delayed_work neg_ttlm_timeout_work;
	struct {
		struct ieee80211_mgd_assoc_data *add_links_data;
		struct wiphy_delayed_work wk;
		u16 removed_links;
		u16 added_links;
		u8 dialog_token;
	} reconf;
};

struct mesh_preq_queue {
	struct list_head list;
	u8 dst[6];
	u8 flags;
};

struct mesh_stats {
	__u32 fwded_mcast;
	__u32 fwded_unicast;
	__u32 fwded_frames;
	__u32 dropped_frames_ttl;
	__u32 dropped_frames_no_route;
};

struct mesh_config {
	u16 dot11MeshRetryTimeout;
	u16 dot11MeshConfirmTimeout;
	u16 dot11MeshHoldingTimeout;
	u16 dot11MeshMaxPeerLinks;
	u8 dot11MeshMaxRetries;
	u8 dot11MeshTTL;
	u8 element_ttl;
	bool auto_open_plinks;
	u32 dot11MeshNbrOffsetMaxNeighbor;
	u8 dot11MeshHWMPmaxPREQretries;
	u32 path_refresh_time;
	u16 min_discovery_timeout;
	u32 dot11MeshHWMPactivePathTimeout;
	u16 dot11MeshHWMPpreqMinInterval;
	u16 dot11MeshHWMPperrMinInterval;
	u16 dot11MeshHWMPnetDiameterTraversalTime;
	u8 dot11MeshHWMPRootMode;
	bool dot11MeshConnectedToMeshGate;
	bool dot11MeshConnectedToAuthServer;
	u16 dot11MeshHWMPRannInterval;
	bool dot11MeshGateAnnouncementProtocol;
	bool dot11MeshForwarding;
	s32 rssi_threshold;
	u16 ht_opmode;
	u32 dot11MeshHWMPactivePathToRootTimeout;
	u16 dot11MeshHWMProotInterval;
	u16 dot11MeshHWMPconfirmationInterval;
	enum nl80211_mesh_power_mode power_mode;
	u16 dot11MeshAwakeWindowDuration;
	u32 plink_timeout;
	bool dot11MeshNolearn;
};

struct mesh_table {
	struct hlist_head known_gates;
	spinlock_t gates_lock;
	struct rhashtable rhead;
	struct hlist_head walk_head;
	spinlock_t walk_lock;
	atomic_t entries;
};

struct mesh_tx_cache {
	struct rhashtable rht;
	struct hlist_head walk_head;
	spinlock_t walk_lock;
};

struct mesh_rmc;

struct ieee80211_mesh_sync_ops;

struct mesh_csa_settings;

struct ieee80211_if_mesh {
	struct timer_list housekeeping_timer;
	struct timer_list mesh_path_timer;
	struct timer_list mesh_path_root_timer;
	long unsigned int wrkq_flags;
	long unsigned int mbss_changed[1];
	bool userspace_handles_dfs;
	u8 mesh_id[32];
	size_t mesh_id_len;
	u8 mesh_pp_id;
	u8 mesh_pm_id;
	u8 mesh_cc_id;
	u8 mesh_sp_id;
	u8 mesh_auth_id;
	u32 sn;
	u32 preq_id;
	atomic_t mpaths;
	long unsigned int last_sn_update;
	long unsigned int next_perr;
	long unsigned int last_preq;
	struct mesh_rmc *rmc;
	spinlock_t mesh_preq_queue_lock;
	struct mesh_preq_queue preq_queue;
	int preq_queue_len;
	struct mesh_stats mshstats;
	struct mesh_config mshcfg;
	atomic_t estab_plinks;
	atomic_t mesh_seqnum;
	bool accepting_plinks;
	int num_gates;
	struct beacon_data *beacon;
	const u8 *ie;
	u8 ie_len;
	enum {
		IEEE80211_MESH_SEC_NONE = 0,
		IEEE80211_MESH_SEC_AUTHED = 1,
		IEEE80211_MESH_SEC_SECURED = 2,
	} security;
	bool user_mpm;
	const struct ieee80211_mesh_sync_ops *sync_ops;
	s64 sync_offset_clockdrift_max;
	spinlock_t sync_offset_lock;
	enum nl80211_mesh_power_mode nonpeer_pm;
	int ps_peers_light_sleep;
	int ps_peers_deep_sleep;
	struct ps_data ps;
	struct mesh_csa_settings *csa;
	enum {
		IEEE80211_MESH_CSA_ROLE_NONE = 0,
		IEEE80211_MESH_CSA_ROLE_INIT = 1,
		IEEE80211_MESH_CSA_ROLE_REPEATER = 2,
	} csa_role;
	u8 chsw_ttl;
	u16 pre_value;
	int meshconf_offset;
	struct mesh_table mesh_paths;
	struct mesh_table mpp_paths;
	int mesh_paths_generation;
	int mpp_paths_generation;
	struct mesh_tx_cache tx_cache;
};

struct ieee80211_if_mntr {
	u32 flags;
	u8 mu_follow_addr[6];
	struct list_head list;
};

struct ieee80211_if_nan {
	struct cfg80211_nan_conf conf;
	spinlock_t func_lock;
	struct idr function_inst_ids;
};

struct ieee80211_if_ocb {
	struct timer_list housekeeping_timer;
	long unsigned int wrkq_flags;
	spinlock_t incomplete_lock;
	struct list_head incomplete_stations;
	bool joined;
};

struct sta_info;

struct ieee80211_if_vlan {
	struct list_head list;
	struct sta_info *sta;
	atomic_t num_mcast_sta;
};

struct ieee80211_iface_limit;

struct ieee80211_iface_combination {
	const struct ieee80211_iface_limit *limits;
	u32 num_different_channels;
	u16 max_interfaces;
	u8 n_limits;
	bool beacon_int_infra_match;
	u8 radar_detect_widths;
	u8 radar_detect_regions;
	u32 beacon_int_min_gcd;
};

struct ieee80211_iface_limit {
	u16 max;
	u16 types;
};

struct tkip_ctx {
	u16 p1k[5];
	u32 p1k_iv32;
	enum ieee80211_internal_tkip_state state;
};

struct tkip_ctx_rx {
	struct tkip_ctx ctx;
	u32 iv32;
	u16 iv16;
};

struct ieee80211_key_conf {
	atomic64_t tx_pn;
	u32 cipher;
	u8 icv_len;
	u8 iv_len;
	u8 hw_key_idx;
	s8 keyidx;
	u16 flags;
	s8 link_id;
	u8 keylen;
	u8 key[0];
};

struct ieee80211_local;

struct ieee80211_sub_if_data;

struct ieee80211_key {
	struct ieee80211_local *local;
	struct ieee80211_sub_if_data *sdata;
	struct sta_info *sta;
	struct list_head list;
	unsigned int flags;
	union {
		struct {
			spinlock_t txlock;
			struct tkip_ctx tx;
			struct tkip_ctx_rx rx[16];
			u32 mic_failures;
		} tkip;
		struct {
			u8 rx_pn[102];
			struct crypto_aead *tfm;
			u32 replays;
		} ccmp;
		struct {
			u8 rx_pn[6];
			struct crypto_shash *tfm;
			u32 replays;
			u32 icverrors;
		} aes_cmac;
		struct {
			u8 rx_pn[6];
			struct crypto_aead *tfm;
			u32 replays;
			u32 icverrors;
		} aes_gmac;
		struct {
			u8 rx_pn[102];
			struct crypto_aead *tfm;
			u32 replays;
		} gcmp;
		struct {
			u8 rx_pn[272];
		} gen;
	} u;
	unsigned int color;
	struct ieee80211_key_conf conf;
};

struct ieee80211_key_seq {
	union {
		struct {
			u32 iv32;
			u16 iv16;
		} tkip;
		struct {
			u8 pn[6];
		} ccmp;
		struct {
			u8 pn[6];
		} aes_cmac;
		struct {
			u8 pn[6];
		} aes_gmac;
		struct {
			u8 pn[6];
		} gcmp;
		struct {
			u8 seq[16];
			u8 seq_len;
		} hw;
	};
};

struct ieee80211_link_data_managed {
	u8 bssid[6];
	u8 dtim_period;
	enum ieee80211_smps_mode req_smps;
	enum ieee80211_smps_mode driver_smps_mode;
	struct ieee80211_conn_settings conn;
	s16 p2p_noa_index;
	bool tdls_chan_switch_prohibited;
	bool have_beacon;
	bool tracking_signal_avg;
	bool disable_wmm_tracking;
	bool operating_11g_mode;
	struct {
		struct wiphy_delayed_work switch_work;
		struct cfg80211_chan_def ap_chandef;
		struct ieee80211_parsed_tpe tpe;
		long unsigned int time;
		bool waiting_bcn;
		bool ignored_same_chan;
		bool blocked_tx;
	} csa;
	struct wiphy_work request_smps_work;
	struct wiphy_work recalc_smps;
	bool beacon_crc_valid;
	u32 beacon_crc;
	struct ewma_beacon_signal ave_beacon_signal;
	int last_ave_beacon_signal;
	unsigned int count_beacon_signal;
	unsigned int beacon_loss_count;
	int last_cqm_event_signal;
	int wmm_last_param_set;
	int mu_edca_last_param_set;
};

struct probe_resp;

struct unsol_bcast_probe_resp_data;

struct ieee80211_link_data_ap {
	struct beacon_data *beacon;
	struct probe_resp *probe_resp;
	struct fils_discovery_data *fils_discovery;
	struct unsol_bcast_probe_resp_data *unsol_bcast_probe_resp;
	struct cfg80211_beacon_data *next_beacon;
};

struct ieee80211_tx_queue_params {
	u16 txop;
	u16 cw_min;
	u16 cw_max;
	u8 aifs;
	bool acm;
	bool uapsd;
	bool mu_edca;
	struct ieee80211_he_mu_edca_param_ac_rec mu_edca_param_rec;
};

struct ieee80211_link_data {
	struct ieee80211_sub_if_data *sdata;
	unsigned int link_id;
	struct list_head assigned_chanctx_list;
	struct list_head reserved_chanctx_list;
	struct ieee80211_key *gtk[8];
	struct ieee80211_key *default_multicast_key;
	struct ieee80211_key *default_mgmt_key;
	struct ieee80211_key *default_beacon_key;
	bool operating_11g_mode;
	struct {
		struct wiphy_work finalize_work;
		struct ieee80211_chan_req chanreq;
	} csa;
	struct wiphy_work color_change_finalize_work;
	struct wiphy_delayed_work color_collision_detect_work;
	u64 color_bitmap;
	struct ieee80211_chanctx *reserved_chanctx;
	struct ieee80211_chan_req reserved;
	bool reserved_radar_required;
	bool reserved_ready;
	u8 needed_rx_chains;
	enum ieee80211_smps_mode smps_mode;
	int user_power_level;
	int ap_power_level;
	bool radar_required;
	struct wiphy_delayed_work dfs_cac_timer_work;
	union {
		struct ieee80211_link_data_managed mgd;
		struct ieee80211_link_data_ap ap;
	} u;
	struct ieee80211_tx_queue_params tx_conf[4];
	struct ieee80211_bss_conf *conf;
};

struct ieee80211_sta_ht_cap {
	u16 cap;
	bool ht_supported;
	u8 ampdu_factor;
	u8 ampdu_density;
	struct ieee80211_mcs_info mcs;
	short: 0;
} __attribute__((packed));

struct ieee80211_sta_vht_cap {
	bool vht_supported;
	u32 cap;
	struct ieee80211_vht_mcs_info vht_mcs;
};

struct ieee80211_sta_he_cap {
	bool has_he;
	struct ieee80211_he_cap_elem he_cap_elem;
	struct ieee80211_he_mcs_nss_supp he_mcs_nss_supp;
	u8 ppe_thres[25];
} __attribute__((packed));

struct ieee80211_sta_eht_cap {
	bool has_eht;
	struct ieee80211_eht_cap_elem_fixed eht_cap_elem;
	struct ieee80211_eht_mcs_nss_supp eht_mcs_nss_supp;
	u8 eht_ppe_thres[32];
};

struct ieee80211_sta_aggregates {
	u16 max_amsdu_len;
	u16 max_rc_amsdu_len;
	u16 max_tid_amsdu_len[16];
};

struct ieee80211_sta_txpwr {
	s16 power;
	enum nl80211_tx_power_setting type;
};

struct ieee80211_link_sta {
	struct ieee80211_sta *sta;
	u8 addr[6];
	u8 link_id;
	long: 0;
	enum ieee80211_smps_mode smps_mode;
	u32 supp_rates[6];
	struct ieee80211_sta_ht_cap ht_cap;
	int: 0;
	struct ieee80211_sta_vht_cap vht_cap;
	struct ieee80211_sta_he_cap he_cap;
	struct ieee80211_he_6ghz_capa he_6ghz_capa;
	struct ieee80211_sta_eht_cap eht_cap;
	struct ieee80211_sta_aggregates agg;
	u8 rx_nss;
	long: 0;
	enum ieee80211_sta_rx_bandwidth bandwidth;
	struct ieee80211_sta_txpwr txpwr;
	long: 0;
} __attribute__((packed));

struct netdev_hw_addr_list {
	struct list_head list;
	int count;
	struct rb_root tree;
};

struct rhltable {
	struct rhashtable ht;
};

struct led_trigger {
	const char *name;
	int (*activate)(struct led_classdev *);
	void (*deactivate)(struct led_classdev *);
	enum led_brightness brightness;
	struct led_hw_trigger_type *trigger_type;
	spinlock_t leddev_list_lock;
	struct list_head led_cdevs;
	struct list_head next_trig;
	const struct attribute_group **groups;
};

struct ieee80211_ops;

struct rate_control_ref;

struct ieee80211_scan_request;

struct tpt_led_trigger;

struct ieee80211_local {
	struct ieee80211_hw hw;
	struct fq fq;
	struct codel_vars *cvars;
	struct codel_params cparams;
	spinlock_t active_txq_lock[4];
	struct list_head active_txqs[4];
	u16 schedule_round[4];
	spinlock_t handle_wake_tx_queue_lock;
	u16 airtime_flags;
	u32 aql_txq_limit_low[4];
	u32 aql_txq_limit_high[4];
	u32 aql_threshold;
	atomic_t aql_total_pending_airtime;
	atomic_t aql_ac_pending_airtime[4];
	const struct ieee80211_ops *ops;
	struct workqueue_struct *workqueue;
	long unsigned int queue_stop_reasons[16];
	int q_stop_reasons[176];
	spinlock_t queue_stop_reason_lock;
	int open_count;
	int monitors;
	int cooked_mntrs;
	int tx_mntrs;
	int fif_fcsfail;
	int fif_plcpfail;
	int fif_control;
	int fif_other_bss;
	int fif_pspoll;
	int fif_probe_req;
	bool probe_req_reg;
	bool rx_mcast_action_reg;
	unsigned int filter_flags;
	bool wiphy_ciphers_allocated;
	struct cfg80211_chan_def dflt_chandef;
	bool emulate_chanctx;
	spinlock_t filter_lock;
	struct wiphy_work reconfig_filter;
	struct netdev_hw_addr_list mc_list;
	bool tim_in_locked_section;
	bool suspended;
	bool suspending;
	bool resuming;
	bool quiescing;
	bool started;
	bool in_reconfig;
	bool reconfig_failure;
	bool wowlan;
	struct wiphy_work radar_detected_work;
	u8 rx_chains;
	u8 sband_allocated;
	int tx_headroom;
	struct tasklet_struct tasklet;
	struct sk_buff_head skb_queue;
	struct sk_buff_head skb_queue_unreliable;
	spinlock_t rx_path_lock;
	spinlock_t tim_lock;
	long unsigned int num_sta;
	struct list_head sta_list;
	struct rhltable sta_hash;
	struct rhltable link_sta_hash;
	struct timer_list sta_cleanup;
	int sta_generation;
	struct sk_buff_head pending[16];
	struct tasklet_struct tx_pending_tasklet;
	struct tasklet_struct wake_txqs_tasklet;
	atomic_t agg_queue_stop[16];
	atomic_t iff_allmultis;
	struct rate_control_ref *rate_ctrl;
	struct arc4_ctx wep_tx_ctx;
	struct arc4_ctx wep_rx_ctx;
	u32 wep_iv;
	struct list_head interfaces;
	struct list_head mon_list;
	struct mutex iflist_mtx;
	long unsigned int scanning;
	struct cfg80211_ssid scan_ssid;
	struct cfg80211_scan_request *int_scan_req;
	struct cfg80211_scan_request *scan_req;
	struct ieee80211_scan_request *hw_scan_req;
	struct cfg80211_chan_def scan_chandef;
	enum nl80211_band hw_scan_band;
	int scan_channel_idx;
	int scan_ies_len;
	int hw_scan_ies_bufsize;
	struct cfg80211_scan_info scan_info;
	struct wiphy_work sched_scan_stopped_work;
	struct ieee80211_sub_if_data *sched_scan_sdata;
	struct cfg80211_sched_scan_request *sched_scan_req;
	u8 scan_addr[6];
	long unsigned int leave_oper_channel_time;
	enum mac80211_scan_state next_scan_state;
	struct wiphy_delayed_work scan_work;
	struct ieee80211_sub_if_data *scan_sdata;
	struct ieee80211_channel *tmp_channel;
	struct list_head chanctx_list;
	struct led_trigger tx_led;
	struct led_trigger rx_led;
	struct led_trigger assoc_led;
	struct led_trigger radio_led;
	struct led_trigger tpt_led;
	atomic_t tx_led_active;
	atomic_t rx_led_active;
	atomic_t assoc_led_active;
	atomic_t radio_led_active;
	atomic_t tpt_led_active;
	struct tpt_led_trigger *tpt_led_trigger;
	int total_ps_buffered;
	bool pspolling;
	struct ieee80211_sub_if_data *ps_sdata;
	struct wiphy_work dynamic_ps_enable_work;
	struct wiphy_work dynamic_ps_disable_work;
	struct timer_list dynamic_ps_timer;
	struct notifier_block ifa_notifier;
	struct notifier_block ifa6_notifier;
	int dynamic_ps_forced_timeout;
	int user_power_level;
	struct work_struct restart_work;
	struct wiphy_delayed_work roc_work;
	struct list_head roc_list;
	struct wiphy_work hw_roc_start;
	struct wiphy_work hw_roc_done;
	long unsigned int hw_roc_start_time;
	u64 roc_cookie_counter;
	struct idr ack_status_frames;
	spinlock_t ack_status_lock;
	struct ieee80211_sub_if_data *p2p_sdata;
	struct ieee80211_sub_if_data *monitor_sdata;
	struct ieee80211_chan_req monitor_chanreq;
	u8 ext_capa[8];
	bool wbrf_supported;
};

struct ieee80211_low_level_stats {
	unsigned int dot11ACKFailureCount;
	unsigned int dot11RTSFailureCount;
	unsigned int dot11FCSErrorCount;
	unsigned int dot11RTSSuccessCount;
};

struct ieee80211_mesh_chansw_params_ie {
	u8 mesh_ttl;
	u8 mesh_flags;
	__le16 mesh_reason;
	__le16 mesh_pre_value;
};

struct ieee80211_mgmt;

struct ieee80211_rx_status;

struct ieee80211_mesh_sync_ops {
	void (*rx_bcn_presp)(struct ieee80211_sub_if_data *, u16, struct ieee80211_mgmt *, unsigned int, const struct ieee80211_meshconf_ie *, struct ieee80211_rx_status *);
	void (*adjust_tsf)(struct ieee80211_sub_if_data *, struct beacon_data *);
};

struct ieee80211_meshconf_ie {
	u8 meshconf_psel;
	u8 meshconf_pmetric;
	u8 meshconf_congest;
	u8 meshconf_synch;
	u8 meshconf_auth;
	u8 meshconf_form;
	u8 meshconf_cap;
};

struct ieee80211_mgd_assoc_data {
	struct {
		struct cfg80211_bss *bss;
		u8 addr[6];
		u8 ap_ht_param;
		struct ieee80211_vht_cap ap_vht_cap;
		long: 0;
		size_t elems_len;
		u8 *elems;
		struct ieee80211_conn_settings conn;
		u16 status;
		bool disabled;
		long: 0;
	} __attribute__((packed)) link[15];
	u8 ap_addr[6];
	const u8 *supp_rates;
	u8 supp_rates_len;
	long unsigned int userspace_selectors[2];
	long unsigned int timeout;
	int tries;
	u8 prev_ap_addr[6];
	u8 ssid[32];
	u8 ssid_len;
	bool wmm;
	bool uapsd;
	bool need_beacon;
	bool synced;
	bool timeout_started;
	bool comeback;
	bool s1g;
	bool spp_amsdu;
	unsigned int assoc_link_id;
	u8 fils_nonces[32];
	u8 fils_kek[64];
	size_t fils_kek_len;
	size_t ie_len;
	u8 *ie_pos;
	u8 ie[0];
};

struct ieee80211_mgd_auth_data {
	struct cfg80211_bss *bss;
	long unsigned int timeout;
	int tries;
	u16 algorithm;
	u16 expected_transaction;
	long unsigned int userspace_selectors[2];
	u8 key[13];
	u8 key_len;
	u8 key_idx;
	bool done;
	bool waiting;
	bool peer_confirmed;
	bool timeout_started;
	int link_id;
	u8 ap_addr[6];
	u16 sae_trans;
	u16 sae_status;
	size_t data_len;
	u8 data[0];
};

struct ieee80211_msrment_ie {
	u8 token;
	u8 mode;
	u8 type;
	u8 request[0];
};

struct ieee80211_tpc_report_ie {
	u8 tx_power;
	u8 link_margin;
};

struct ieee80211_mgmt {
	__le16 frame_control;
	__le16 duration;
	u8 da[6];
	u8 sa[6];
	u8 bssid[6];
	__le16 seq_ctrl;
	union {
		struct {
			__le16 auth_alg;
			__le16 auth_transaction;
			__le16 status_code;
			u8 variable[0];
		} auth;
		struct {
			__le16 reason_code;
		} deauth;
		struct {
			__le16 capab_info;
			__le16 listen_interval;
			u8 variable[0];
		} assoc_req;
		struct {
			__le16 capab_info;
			__le16 status_code;
			__le16 aid;
			u8 variable[0];
		} assoc_resp;
		struct {
			__le16 capab_info;
			__le16 status_code;
			__le16 aid;
			u8 variable[0];
		} reassoc_resp;
		struct {
			__le16 capab_info;
			__le16 status_code;
			u8 variable[0];
		} s1g_assoc_resp;
		struct {
			__le16 capab_info;
			__le16 status_code;
			u8 variable[0];
		} s1g_reassoc_resp;
		struct {
			__le16 capab_info;
			__le16 listen_interval;
			u8 current_ap[6];
			u8 variable[0];
		} reassoc_req;
		struct {
			__le16 reason_code;
		} disassoc;
		struct {
			__le64 timestamp;
			__le16 beacon_int;
			__le16 capab_info;
			u8 variable[0];
		} __attribute__((packed)) beacon;
		struct {
			struct {
				struct {} __empty_variable;
				u8 variable[0];
			};
		} probe_req;
		struct {
			__le64 timestamp;
			__le16 beacon_int;
			__le16 capab_info;
			u8 variable[0];
		} __attribute__((packed)) probe_resp;
		struct {
			u8 category;
			union {
				struct {
					u8 action_code;
					u8 dialog_token;
					u8 status_code;
					u8 variable[0];
				} wme_action;
				struct {
					u8 action_code;
					u8 variable[0];
				} chan_switch;
				struct {
					u8 action_code;
					struct ieee80211_ext_chansw_ie data;
					u8 variable[0];
				} ext_chan_switch;
				struct {
					u8 action_code;
					u8 dialog_token;
					u8 element_id;
					u8 length;
					struct ieee80211_msrment_ie msr_elem;
				} measurement;
				struct {
					u8 action_code;
					u8 dialog_token;
					__le16 capab;
					__le16 timeout;
					__le16 start_seq_num;
					u8 variable[0];
				} addba_req;
				struct {
					u8 action_code;
					u8 dialog_token;
					__le16 status;
					__le16 capab;
					__le16 timeout;
					u8 variable[0];
				} addba_resp;
				struct {
					u8 action_code;
					__le16 params;
					__le16 reason_code;
				} __attribute__((packed)) delba;
				struct {
					u8 action_code;
					u8 variable[0];
				} self_prot;
				struct {
					u8 action_code;
					u8 variable[0];
				} mesh_action;
				struct {
					u8 action;
					u8 trans_id[2];
				} sa_query;
				struct {
					u8 action;
					u8 smps_control;
				} ht_smps;
				struct {
					u8 action_code;
					u8 chanwidth;
				} ht_notify_cw;
				struct {
					u8 action_code;
					u8 dialog_token;
					__le16 capability;
					u8 variable[0];
				} tdls_discover_resp;
				struct {
					u8 action_code;
					u8 operating_mode;
				} vht_opmode_notif;
				struct {
					u8 action_code;
					u8 membership[8];
					u8 position[16];
				} vht_group_notif;
				struct {
					u8 action_code;
					u8 dialog_token;
					u8 tpc_elem_id;
					u8 tpc_elem_length;
					struct ieee80211_tpc_report_ie tpc;
				} tpc_report;
				struct {
					u8 action_code;
					u8 dialog_token;
					u8 follow_up;
					u8 tod[6];
					u8 toa[6];
					__le16 tod_error;
					__le16 toa_error;
					u8 variable[0];
				} __attribute__((packed)) ftm;
				struct {
					u8 action_code;
					u8 variable[0];
				} s1g;
				struct {
					u8 action_code;
					u8 dialog_token;
					u8 follow_up;
					u32 tod;
					u32 toa;
					u8 max_tod_error;
					u8 max_toa_error;
				} __attribute__((packed)) wnm_timing_msr;
				struct {
					u8 action_code;
					u8 dialog_token;
					u8 variable[0];
				} ttlm_req;
				struct {
					u8 action_code;
					u8 dialog_token;
					u8 status_code;
					u8 variable[0];
				} ttlm_res;
				struct {
					u8 action_code;
				} ttlm_tear_down;
				struct {
					u8 action_code;
					u8 dialog_token;
					u8 variable[0];
				} ml_reconf_req;
				struct {
					u8 action_code;
					u8 dialog_token;
					u8 count;
					u8 variable[0];
				} ml_reconf_resp;
			} u;
		} action;
		struct {
			struct {} __empty_body;
			u8 body[0];
		};
	} u;
};

struct ieee80211_mle_basic_common_info {
	u8 len;
	u8 mld_mac_addr[6];
	u8 variable[0];
};

struct ieee80211_mle_per_sta_profile {
	__le16 control;
	u8 sta_info_len;
	u8 variable[0];
} __attribute__((packed));

struct ieee80211_mmie {
	u8 element_id;
	u8 length;
	__le16 key_id;
	u8 sequence_number[6];
	u8 mic[8];
};

struct ieee80211_mmie_16 {
	u8 element_id;
	u8 length;
	__le16 key_id;
	u8 sequence_number[6];
	u8 mic[16];
};

struct ieee80211_mu_edca_param_set {
	u8 mu_qos_info;
	struct ieee80211_he_mu_edca_param_ac_rec ac_be;
	struct ieee80211_he_mu_edca_param_ac_rec ac_bk;
	struct ieee80211_he_mu_edca_param_ac_rec ac_vi;
	struct ieee80211_he_mu_edca_param_ac_rec ac_vo;
};

struct ieee80211_multi_link_elem {
	__le16 control;
	u8 variable[0];
};

struct ieee80211_multiple_bssid_configuration {
	u8 bssid_count;
	u8 profile_periodicity;
};

struct ieee80211_neg_ttlm {
	u16 downlink[8];
	u16 uplink[8];
	bool valid;
};

struct ieee80211_neighbor_ap_info {
	u8 tbtt_info_hdr;
	u8 tbtt_info_len;
	u8 op_class;
	u8 channel;
};

struct ieee80211_noa_data {
	u32 next_tsf;
	bool has_next_tsf;
	u8 absent;
	u8 count[4];
	struct {
		u32 start;
		u32 duration;
		u32 interval;
	} desc[4];
};

struct ieee80211_tx_control;

struct ieee80211_scan_ies;

struct ieee80211_prep_tx_info;

struct ieee80211_vif_chanctx_switch;

struct inet6_dev;

struct ieee80211_tdls_ch_sw_params;

struct ieee80211_txq;

struct ieee80211_twt_setup;

struct net_device_path_ctx;

struct net_device_path;

struct ieee80211_ops {
	void (*tx)(struct ieee80211_hw *, struct ieee80211_tx_control *, struct sk_buff *);
	int (*start)(struct ieee80211_hw *);
	void (*stop)(struct ieee80211_hw *, bool);
	int (*suspend)(struct ieee80211_hw *, struct cfg80211_wowlan *);
	int (*resume)(struct ieee80211_hw *);
	void (*set_wakeup)(struct ieee80211_hw *, bool);
	int (*add_interface)(struct ieee80211_hw *, struct ieee80211_vif *);
	int (*change_interface)(struct ieee80211_hw *, struct ieee80211_vif *, enum nl80211_iftype, bool);
	void (*remove_interface)(struct ieee80211_hw *, struct ieee80211_vif *);
	int (*config)(struct ieee80211_hw *, u32);
	void (*bss_info_changed)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_bss_conf *, u64);
	void (*vif_cfg_changed)(struct ieee80211_hw *, struct ieee80211_vif *, u64);
	void (*link_info_changed)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_bss_conf *, u64);
	int (*start_ap)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_bss_conf *);
	void (*stop_ap)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_bss_conf *);
	u64 (*prepare_multicast)(struct ieee80211_hw *, struct netdev_hw_addr_list *);
	void (*configure_filter)(struct ieee80211_hw *, unsigned int, unsigned int *, u64);
	void (*config_iface_filter)(struct ieee80211_hw *, struct ieee80211_vif *, unsigned int, unsigned int);
	int (*set_tim)(struct ieee80211_hw *, struct ieee80211_sta *, bool);
	int (*set_key)(struct ieee80211_hw *, enum set_key_cmd, struct ieee80211_vif *, struct ieee80211_sta *, struct ieee80211_key_conf *);
	void (*update_tkip_key)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_key_conf *, struct ieee80211_sta *, u32, u16 *);
	void (*set_rekey_data)(struct ieee80211_hw *, struct ieee80211_vif *, struct cfg80211_gtk_rekey_data *);
	void (*set_default_unicast_key)(struct ieee80211_hw *, struct ieee80211_vif *, int);
	int (*hw_scan)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_scan_request *);
	void (*cancel_hw_scan)(struct ieee80211_hw *, struct ieee80211_vif *);
	int (*sched_scan_start)(struct ieee80211_hw *, struct ieee80211_vif *, struct cfg80211_sched_scan_request *, struct ieee80211_scan_ies *);
	int (*sched_scan_stop)(struct ieee80211_hw *, struct ieee80211_vif *);
	void (*sw_scan_start)(struct ieee80211_hw *, struct ieee80211_vif *, const u8 *);
	void (*sw_scan_complete)(struct ieee80211_hw *, struct ieee80211_vif *);
	int (*get_stats)(struct ieee80211_hw *, struct ieee80211_low_level_stats *);
	void (*get_key_seq)(struct ieee80211_hw *, struct ieee80211_key_conf *, struct ieee80211_key_seq *);
	int (*set_frag_threshold)(struct ieee80211_hw *, u32);
	int (*set_rts_threshold)(struct ieee80211_hw *, u32);
	int (*sta_add)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_sta *);
	int (*sta_remove)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_sta *);
	void (*sta_notify)(struct ieee80211_hw *, struct ieee80211_vif *, enum sta_notify_cmd, struct ieee80211_sta *);
	int (*sta_set_txpwr)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_sta *);
	int (*sta_state)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_sta *, enum ieee80211_sta_state, enum ieee80211_sta_state);
	void (*sta_pre_rcu_remove)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_sta *);
	void (*link_sta_rc_update)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_link_sta *, u32);
	void (*sta_rate_tbl_update)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_sta *);
	void (*sta_statistics)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_sta *, struct station_info *);
	int (*conf_tx)(struct ieee80211_hw *, struct ieee80211_vif *, unsigned int, u16, const struct ieee80211_tx_queue_params *);
	u64 (*get_tsf)(struct ieee80211_hw *, struct ieee80211_vif *);
	void (*set_tsf)(struct ieee80211_hw *, struct ieee80211_vif *, u64);
	void (*offset_tsf)(struct ieee80211_hw *, struct ieee80211_vif *, s64);
	void (*reset_tsf)(struct ieee80211_hw *, struct ieee80211_vif *);
	int (*tx_last_beacon)(struct ieee80211_hw *);
	int (*ampdu_action)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_ampdu_params *);
	int (*get_survey)(struct ieee80211_hw *, int, struct survey_info *);
	void (*rfkill_poll)(struct ieee80211_hw *);
	void (*set_coverage_class)(struct ieee80211_hw *, s16);
	void (*flush)(struct ieee80211_hw *, struct ieee80211_vif *, u32, bool);
	void (*flush_sta)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_sta *);
	void (*channel_switch)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_channel_switch *);
	int (*set_antenna)(struct ieee80211_hw *, u32, u32);
	int (*get_antenna)(struct ieee80211_hw *, u32 *, u32 *);
	int (*remain_on_channel)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_channel *, int, enum ieee80211_roc_type);
	int (*cancel_remain_on_channel)(struct ieee80211_hw *, struct ieee80211_vif *);
	int (*set_ringparam)(struct ieee80211_hw *, u32, u32);
	void (*get_ringparam)(struct ieee80211_hw *, u32 *, u32 *, u32 *, u32 *);
	bool (*tx_frames_pending)(struct ieee80211_hw *);
	int (*set_bitrate_mask)(struct ieee80211_hw *, struct ieee80211_vif *, const struct cfg80211_bitrate_mask *);
	void (*event_callback)(struct ieee80211_hw *, struct ieee80211_vif *, const struct ieee80211_event *);
	void (*allow_buffered_frames)(struct ieee80211_hw *, struct ieee80211_sta *, u16, int, enum ieee80211_frame_release_type, bool);
	void (*release_buffered_frames)(struct ieee80211_hw *, struct ieee80211_sta *, u16, int, enum ieee80211_frame_release_type, bool);
	int (*get_et_sset_count)(struct ieee80211_hw *, struct ieee80211_vif *, int);
	void (*get_et_stats)(struct ieee80211_hw *, struct ieee80211_vif *, struct ethtool_stats *, u64 *);
	void (*get_et_strings)(struct ieee80211_hw *, struct ieee80211_vif *, u32, u8 *);
	void (*mgd_prepare_tx)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_prep_tx_info *);
	void (*mgd_complete_tx)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_prep_tx_info *);
	void (*mgd_protect_tdls_discover)(struct ieee80211_hw *, struct ieee80211_vif *, unsigned int);
	int (*add_chanctx)(struct ieee80211_hw *, struct ieee80211_chanctx_conf *);
	void (*remove_chanctx)(struct ieee80211_hw *, struct ieee80211_chanctx_conf *);
	void (*change_chanctx)(struct ieee80211_hw *, struct ieee80211_chanctx_conf *, u32);
	int (*assign_vif_chanctx)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_bss_conf *, struct ieee80211_chanctx_conf *);
	void (*unassign_vif_chanctx)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_bss_conf *, struct ieee80211_chanctx_conf *);
	int (*switch_vif_chanctx)(struct ieee80211_hw *, struct ieee80211_vif_chanctx_switch *, int, enum ieee80211_chanctx_switch_mode);
	void (*reconfig_complete)(struct ieee80211_hw *, enum ieee80211_reconfig_type);
	void (*ipv6_addr_change)(struct ieee80211_hw *, struct ieee80211_vif *, struct inet6_dev *);
	void (*channel_switch_beacon)(struct ieee80211_hw *, struct ieee80211_vif *, struct cfg80211_chan_def *);
	int (*pre_channel_switch)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_channel_switch *);
	int (*post_channel_switch)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_bss_conf *);
	void (*abort_channel_switch)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_bss_conf *);
	void (*channel_switch_rx_beacon)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_channel_switch *);
	int (*join_ibss)(struct ieee80211_hw *, struct ieee80211_vif *);
	void (*leave_ibss)(struct ieee80211_hw *, struct ieee80211_vif *);
	u32 (*get_expected_throughput)(struct ieee80211_hw *, struct ieee80211_sta *);
	int (*get_txpower)(struct ieee80211_hw *, struct ieee80211_vif *, unsigned int, int *);
	int (*tdls_channel_switch)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_sta *, u8, struct cfg80211_chan_def *, struct sk_buff *, u32);
	void (*tdls_cancel_channel_switch)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_sta *);
	void (*tdls_recv_channel_switch)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_tdls_ch_sw_params *);
	void (*wake_tx_queue)(struct ieee80211_hw *, struct ieee80211_txq *);
	void (*sync_rx_queues)(struct ieee80211_hw *);
	int (*start_nan)(struct ieee80211_hw *, struct ieee80211_vif *, struct cfg80211_nan_conf *);
	int (*stop_nan)(struct ieee80211_hw *, struct ieee80211_vif *);
	int (*nan_change_conf)(struct ieee80211_hw *, struct ieee80211_vif *, struct cfg80211_nan_conf *, u32);
	int (*add_nan_func)(struct ieee80211_hw *, struct ieee80211_vif *, const struct cfg80211_nan_func *);
	void (*del_nan_func)(struct ieee80211_hw *, struct ieee80211_vif *, u8);
	bool (*can_aggregate_in_amsdu)(struct ieee80211_hw *, struct sk_buff *, struct sk_buff *);
	int (*get_ftm_responder_stats)(struct ieee80211_hw *, struct ieee80211_vif *, struct cfg80211_ftm_responder_stats *);
	int (*start_pmsr)(struct ieee80211_hw *, struct ieee80211_vif *, struct cfg80211_pmsr_request *);
	void (*abort_pmsr)(struct ieee80211_hw *, struct ieee80211_vif *, struct cfg80211_pmsr_request *);
	int (*set_tid_config)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_sta *, struct cfg80211_tid_config *);
	int (*reset_tid_config)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_sta *, u8);
	void (*update_vif_offload)(struct ieee80211_hw *, struct ieee80211_vif *);
	void (*sta_set_4addr)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_sta *, bool);
	int (*set_sar_specs)(struct ieee80211_hw *, const struct cfg80211_sar_specs *);
	void (*sta_set_decap_offload)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_sta *, bool);
	void (*add_twt_setup)(struct ieee80211_hw *, struct ieee80211_sta *, struct ieee80211_twt_setup *);
	void (*twt_teardown_request)(struct ieee80211_hw *, struct ieee80211_sta *, u8);
	int (*set_radar_background)(struct ieee80211_hw *, struct cfg80211_chan_def *);
	int (*net_fill_forward_path)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_sta *, struct net_device_path_ctx *, struct net_device_path *);
	bool (*can_activate_links)(struct ieee80211_hw *, struct ieee80211_vif *, u16);
	int (*change_vif_links)(struct ieee80211_hw *, struct ieee80211_vif *, u16, u16, struct ieee80211_bss_conf **);
	int (*change_sta_links)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_sta *, u16, u16);
	int (*set_hw_timestamp)(struct ieee80211_hw *, struct ieee80211_vif *, struct cfg80211_set_hw_timestamp *);
	int (*net_setup_tc)(struct ieee80211_hw *, struct ieee80211_vif *, struct net_device *, enum tc_setup_type, void *);
	enum ieee80211_neg_ttlm_res (*can_neg_ttlm)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_neg_ttlm *);
	void (*prep_add_interface)(struct ieee80211_hw *, enum nl80211_iftype);
};

struct ieee80211_power_rule {
	u32 max_antenna_gain;
	u32 max_eirp;
};

struct ieee80211_prep_tx_info {
	u16 duration;
	u16 subtype;
	u8 success: 1;
	u8 was_assoc: 1;
	int link_id;
};

struct ieee80211_pspoll {
	__le16 frame_control;
	__le16 aid;
	u8 bssid[6];
	u8 ta[6];
};

struct ieee80211_qos_hdr {
	__le16 frame_control;
	__le16 duration_id;
	u8 addr1[6];
	u8 addr2[6];
	u8 addr3[6];
	__le16 seq_ctrl;
	__le16 qos_ctrl;
};

struct ieee80211_qos_hdr_4addr {
	__le16 frame_control;
	__le16 duration_id;
	u8 addr1[6];
	u8 addr2[6];
	u8 addr3[6];
	__le16 seq_ctrl;
	u8 addr4[6];
	__le16 qos_ctrl;
};

struct ieee80211_radiotap_he {
	__le16 data1;
	__le16 data2;
	__le16 data3;
	__le16 data4;
	__le16 data5;
	__le16 data6;
};

struct ieee80211_radiotap_he_mu {
	__le16 flags1;
	__le16 flags2;
	u8 ru_ch1[4];
	u8 ru_ch2[4];
};

struct ieee80211_radiotap_header_fixed {
	uint8_t it_version;
	uint8_t it_pad;
	__le16 it_len;
	__le32 it_present;
};

struct ieee80211_radiotap_header {
	union {
		struct {
			uint8_t it_version;
			uint8_t it_pad;
			__le16 it_len;
			__le32 it_present;
		};
		struct ieee80211_radiotap_header_fixed hdr;
	};
	__le32 it_optional[0];
};

struct ieee80211_radiotap_vendor_namespaces;

struct ieee80211_radiotap_namespace;

struct ieee80211_radiotap_iterator {
	struct ieee80211_radiotap_header *_rtheader;
	const struct ieee80211_radiotap_vendor_namespaces *_vns;
	const struct ieee80211_radiotap_namespace *current_namespace;
	unsigned char *_arg;
	unsigned char *_next_ns_data;
	__le32 *_next_bitmap;
	unsigned char *this_arg;
	int this_arg_index;
	int this_arg_size;
	int is_radiotap_ns;
	int _max_length;
	int _arg_index;
	uint32_t _bitmap_shifter;
	int _reset_on_ext;
};

struct ieee80211_radiotap_lsig {
	__le16 data1;
	__le16 data2;
};

struct radiotap_align_size;

struct ieee80211_radiotap_namespace {
	const struct radiotap_align_size *align_size;
	int n_bits;
	uint32_t oui;
	uint8_t subns;
};

struct ieee80211_radiotap_vendor_namespaces {
	const struct ieee80211_radiotap_namespace *ns;
	int n_ns;
};

struct ieee80211_rann_ie {
	u8 rann_flags;
	u8 rann_hopcount;
	u8 rann_ttl;
	u8 rann_addr[6];
	__le32 rann_seq;
	__le32 rann_interval;
	__le32 rann_metric;
} __attribute__((packed));

struct ieee80211_rate {
	u32 flags;
	u16 bitrate;
	u16 hw_value;
	u16 hw_value_short;
};

struct ieee80211_rate_status {
	struct rate_info rate_idx;
	u8 try_count;
	u8 tx_power_idx;
};

struct ieee80211_wmm_ac {
	u16 cw_min;
	u16 cw_max;
	u16 cot;
	u8 aifsn;
};

struct ieee80211_wmm_rule {
	struct ieee80211_wmm_ac client[4];
	struct ieee80211_wmm_ac ap[4];
};

struct ieee80211_reg_rule {
	struct ieee80211_freq_range freq_range;
	struct ieee80211_power_rule power_rule;
	struct ieee80211_wmm_rule wmm_rule;
	u32 flags;
	u32 dfs_cac_ms;
	bool has_wmm;
	s8 psd;
};

struct ieee80211_regdomain {
	struct callback_head callback_head;
	u32 n_reg_rules;
	char alpha2[3];
	enum nl80211_dfs_regions dfs_region;
	struct ieee80211_reg_rule reg_rules[0];
};

struct ieee80211_rnr_mld_params {
	u8 mld_id;
	__le16 params;
} __attribute__((packed));

struct ieee80211_roc_work {
	struct list_head list;
	struct ieee80211_sub_if_data *sdata;
	struct ieee80211_channel *chan;
	bool started;
	bool abort;
	bool hw_begun;
	bool notified;
	bool on_channel;
	long unsigned int start_time;
	u32 duration;
	u32 req_duration;
	struct sk_buff *frame;
	u64 cookie;
	u64 mgmt_tx_cookie;
	enum ieee80211_roc_type type;
};

struct ieee80211_rts {
	__le16 frame_control;
	__le16 duration;
	u8 ra[6];
	u8 ta[6];
};

struct link_sta_info;

struct ieee80211_rx_data {
	struct list_head *list;
	struct sk_buff *skb;
	struct ieee80211_local *local;
	struct ieee80211_sub_if_data *sdata;
	struct ieee80211_link_data *link;
	struct sta_info *sta;
	struct link_sta_info *link_sta;
	struct ieee80211_key *key;
	unsigned int flags;
	int seqno_idx;
	int security_idx;
	int link_id;
	union {
		struct {
			u32 iv32;
			u16 iv16;
		} tkip;
		struct {
			u8 pn[6];
		} ccm_gcm;
	};
};

struct ieee80211_rx_status {
	u64 mactime;
	union {
		u64 boottime_ns;
		ktime_t ack_tx_hwtstamp;
	};
	u32 device_timestamp;
	u32 ampdu_reference;
	u32 flag;
	u16 freq: 13;
	u16 freq_offset: 1;
	u8 enc_flags;
	u8 encoding: 3;
	u8 bw: 4;
	union {
		struct {
			u8 he_ru: 3;
			u8 he_gi: 2;
			u8 he_dcm: 1;
		};
		struct {
			u8 ru: 4;
			u8 gi: 2;
		} eht;
	};
	u8 rate_idx;
	u8 nss;
	u8 rx_flags;
	u8 band;
	u8 antenna;
	s8 signal;
	u8 chains;
	s8 chain_signal[4];
	u8 zero_length_psdu_type;
	u8 link_valid: 1;
	u8 link_id: 4;
};

struct ieee80211_s1g_bcn_compat_ie {
	__le16 compat_info;
	__le16 beacon_int;
	__le32 tsf_completion;
};

struct ieee80211_s1g_oper_ie {
	u8 ch_width;
	u8 oper_class;
	u8 primary_ch;
	u8 oper_ch;
	__le16 basic_mcs_nss;
};

struct ieee80211_sband_iftype_data {
	u16 types_mask;
	struct ieee80211_sta_he_cap he_cap;
	struct ieee80211_he_6ghz_capa he_6ghz_capa;
	struct ieee80211_sta_eht_cap eht_cap;
	struct {
		const u8 *data;
		unsigned int len;
	} vendor_elems;
} __attribute__((packed));

struct ieee80211_scan_ies {
	const u8 *ies[6];
	size_t len[6];
	const u8 *common_ies;
	size_t common_ie_len;
};

struct ieee80211_scan_request {
	struct ieee80211_scan_ies ies;
	struct cfg80211_scan_request req;
};

struct ieee80211_sec_chan_offs_ie {
	u8 sec_chan_offs;
};

struct ieee80211_sta_rates;

struct ieee80211_sta {
	u8 addr[6];
	u16 aid;
	u16 max_rx_aggregation_subframes;
	bool wme;
	u8 uapsd_queues;
	u8 max_sp;
	struct ieee80211_sta_rates *rates;
	bool tdls;
	bool tdls_initiator;
	bool mfp;
	bool mlo;
	bool spp_amsdu;
	u8 max_amsdu_subframes;
	struct ieee80211_sta_aggregates *cur;
	bool support_p2p_ps;
	struct ieee80211_txq *txq[17];
	u16 valid_links;
	long: 0;
	struct ieee80211_link_sta deflink;
	struct ieee80211_link_sta *link[15];
	u8 drv_priv[0];
};

struct ieee80211_sta_rates {
	struct callback_head callback_head;
	struct {
		s8 idx;
		u8 count;
		u8 count_cts;
		u8 count_rts;
		u16 flags;
	} rate[4];
};

struct ieee80211_sta_rx_stats {
	long unsigned int packets;
	long unsigned int last_rx;
	long unsigned int num_duplicates;
	long unsigned int fragments;
	long unsigned int dropped;
	int last_signal;
	u8 chains;
	s8 chain_signal_last[4];
	u32 last_rate;
	struct u64_stats_sync syncp;
	u64 bytes;
	u64 msdu[17];
};

struct ieee80211_sta_s1g_cap {
	bool s1g;
	u8 cap[10];
	u8 nss_mcs[5];
};

struct wireless_dev {
	struct wiphy *wiphy;
	enum nl80211_iftype iftype;
	struct list_head list;
	struct net_device *netdev;
	u32 identifier;
	struct list_head mgmt_registrations;
	u8 mgmt_registrations_need_update: 1;
	bool use_4addr;
	bool is_running;
	bool registered;
	bool registering;
	short: 0;
	u8 address[6];
	struct cfg80211_conn *conn;
	struct cfg80211_cached_keys *connect_keys;
	enum ieee80211_bss_type conn_bss_type;
	u32 conn_owner_nlportid;
	struct work_struct disconnect_wk;
	u8 disconnect_bssid[6];
	struct list_head event_list;
	spinlock_t event_lock;
	u8 connected: 1;
	bool ps;
	int ps_timeout;
	u32 ap_unexpected_nlportid;
	u32 owner_nlportid;
	bool nl_owner_dead;
	struct wiphy_work cqm_rssi_work;
	struct cfg80211_cqm_config *cqm_config;
	struct list_head pmsr_list;
	spinlock_t pmsr_lock;
	struct work_struct pmsr_free_wk;
	long unsigned int unprot_beacon_reported;
	union {
		struct {
			u8 connected_addr[6];
			u8 ssid[32];
			u8 ssid_len;
			long: 0;
		} client;
		struct {
			int beacon_interval;
			struct cfg80211_chan_def preset_chandef;
			struct cfg80211_chan_def chandef;
			u8 id[32];
			u8 id_len;
			u8 id_up_len;
		} mesh;
		struct {
			struct cfg80211_chan_def preset_chandef;
			u8 ssid[32];
			u8 ssid_len;
		} ap;
		struct {
			struct cfg80211_internal_bss *current_bss;
			struct cfg80211_chan_def chandef;
			int beacon_interval;
			u8 ssid[32];
			u8 ssid_len;
		} ibss;
		struct {
			struct cfg80211_chan_def chandef;
		} ocb;
	} u;
	struct {
		u8 addr[6];
		union {
			struct {
				unsigned int beacon_interval;
				struct cfg80211_chan_def chandef;
			} ap;
			struct {
				struct cfg80211_internal_bss *current_bss;
			} client;
		};
		bool cac_started;
		long unsigned int cac_start_time;
		unsigned int cac_time_ms;
	} links[15];
	u16 valid_links;
	u32 radio_mask;
};

struct ieee80211_vif_cfg {
	bool assoc;
	bool ibss_joined;
	bool ibss_creator;
	bool ps;
	u16 aid;
	u16 eml_cap;
	u16 eml_med_sync_delay;
	u16 mld_capa_op;
	__be32 arp_addr_list[4];
	int arp_addr_cnt;
	u8 ssid[32];
	size_t ssid_len;
	bool s1g;
	bool idle;
	u8 ap_addr[6];
};

struct ieee80211_vif {
	enum nl80211_iftype type;
	struct ieee80211_vif_cfg cfg;
	struct ieee80211_bss_conf bss_conf;
	struct ieee80211_bss_conf *link_conf[15];
	u16 valid_links;
	u16 active_links;
	u16 dormant_links;
	u16 suspended_links;
	struct ieee80211_neg_ttlm neg_ttlm;
	u8 addr[6];
	bool addr_valid;
	bool p2p;
	u8 cab_queue;
	u8 hw_queue[4];
	struct ieee80211_txq *txq;
	netdev_features_t netdev_features;
	u32 driver_flags;
	u32 offload_flags;
	bool probe_req_reg;
	bool rx_mcast_action_reg;
	struct ieee80211_vif *mbssid_tx_vif;
	u8 drv_priv[0];
};

struct mac80211_qos_map;

struct ieee80211_sub_if_data {
	struct list_head list;
	struct wireless_dev wdev;
	struct list_head key_list;
	int crypto_tx_tailroom_needed_cnt;
	int crypto_tx_tailroom_pending_dec;
	struct wiphy_delayed_work dec_tailroom_needed_wk;
	struct net_device *dev;
	struct ieee80211_local *local;
	unsigned int flags;
	long unsigned int state;
	char name[16];
	struct ieee80211_fragment_cache frags;
	u16 noack_map;
	u8 wmm_acm;
	struct ieee80211_key *keys[4];
	struct ieee80211_key *default_unicast_key;
	u16 sequence_number;
	u16 mld_mcast_seq;
	__be16 control_port_protocol;
	bool control_port_no_encrypt;
	bool control_port_no_preauth;
	bool control_port_over_nl80211;
	atomic_t num_tx_queued;
	struct mac80211_qos_map *qos_map;
	struct wiphy_work work;
	struct sk_buff_head skb_queue;
	struct sk_buff_head status_queue;
	struct ieee80211_if_ap *bss;
	u32 rc_rateidx_mask[6];
	bool rc_has_mcs_mask[6];
	u8 rc_rateidx_mcs_mask[60];
	bool rc_has_vht_mcs_mask[6];
	u16 rc_rateidx_vht_mcs_mask[48];
	u32 beacon_rateidx_mask[6];
	bool beacon_rate_set;
	union {
		struct ieee80211_if_ap ap;
		struct ieee80211_if_vlan vlan;
		struct ieee80211_if_managed mgd;
		struct ieee80211_if_ibss ibss;
		struct ieee80211_if_mesh mesh;
		struct ieee80211_if_ocb ocb;
		struct ieee80211_if_mntr mntr;
		struct ieee80211_if_nan nan;
	} u;
	struct ieee80211_link_data deflink;
	struct ieee80211_link_data *link[15];
	struct wiphy_work activate_links_work;
	u16 desired_active_links;
	u16 restart_active_links;
	struct ieee80211_vif vif;
};

struct ieee80211_supported_band {
	struct ieee80211_channel *channels;
	struct ieee80211_rate *bitrates;
	enum nl80211_band band;
	int n_channels;
	int n_bitrates;
	struct ieee80211_sta_ht_cap ht_cap;
	struct ieee80211_sta_vht_cap vht_cap;
	struct ieee80211_sta_s1g_cap s1g_cap;
	struct ieee80211_edmg edmg_cap;
	u16 n_iftype_data;
	const struct ieee80211_sband_iftype_data *iftype_data;
};

struct ieee80211_tbtt_info_7_8_9 {
	u8 tbtt_offset;
	u8 bssid[6];
	u8 bss_params;
	s8 psd_20;
};

struct ieee80211_tbtt_info_ge_11 {
	u8 tbtt_offset;
	u8 bssid[6];
	__le32 short_ssid;
	u8 bss_params;
	s8 psd_20;
	struct ieee80211_rnr_mld_params mld_params;
} __attribute__((packed));

struct ieee80211_tdls_ch_sw_params {
	struct ieee80211_sta *sta;
	struct cfg80211_chan_def *chandef;
	u8 action_code;
	u32 status;
	u32 timestamp;
	u16 switch_time;
	u16 switch_timeout;
	struct sk_buff *tmpl_skb;
	u32 ch_sw_tm_ie;
};

struct ieee80211_tdls_data {
	u8 da[6];
	u8 sa[6];
	__be16 ether_type;
	u8 payload_type;
	u8 category;
	u8 action_code;
	union {
		struct {
			u8 dialog_token;
			__le16 capability;
			u8 variable[0];
		} __attribute__((packed)) setup_req;
		struct {
			__le16 status_code;
			u8 dialog_token;
			__le16 capability;
			u8 variable[0];
		} __attribute__((packed)) setup_resp;
		struct {
			__le16 status_code;
			u8 dialog_token;
			u8 variable[0];
		} __attribute__((packed)) setup_cfm;
		struct {
			__le16 reason_code;
			u8 variable[0];
		} teardown;
		struct {
			u8 dialog_token;
			u8 variable[0];
		} discover_req;
		struct {
			u8 target_channel;
			u8 oper_class;
			u8 variable[0];
		} chan_switch_req;
		struct {
			__le16 status_code;
			u8 variable[0];
		} chan_switch_resp;
	} u;
};

struct ieee80211_tdls_lnkie {
	u8 ie_type;
	u8 ie_len;
	u8 bssid[6];
	u8 init_sta[6];
	u8 resp_sta[6];
};

struct ieee80211_tim_ie {
	u8 dtim_count;
	u8 dtim_period;
	u8 bitmap_ctrl;
	union {
		u8 required_octet;
		struct {
			struct {} __empty_virtual_map;
			u8 virtual_map[0];
		};
	};
};

struct ieee80211_timeout_interval_ie {
	u8 type;
	__le32 value;
} __attribute__((packed));

struct ieee80211_tpt_blink {
	int throughput;
	int blink_time;
};

struct ieee80211_ttlm_elem {
	u8 control;
	u8 optional[0];
};

struct ieee80211_twt_params {
	__le16 req_type;
	__le64 twt;
	u8 min_twt_dur;
	__le16 mantissa;
	u8 channel;
} __attribute__((packed));

struct ieee80211_twt_setup {
	u8 dialog_token;
	u8 element_id;
	u8 length;
	u8 control;
	u8 params[0];
};

struct ieee80211_tx_control {
	struct ieee80211_sta *sta;
};

struct ieee80211_tx_rate {
	s8 idx;
	u16 count: 5;
	u16 flags: 11;
} __attribute__((packed));

struct ieee80211_tx_data {
	struct sk_buff *skb;
	struct sk_buff_head skbs;
	struct ieee80211_local *local;
	struct ieee80211_sub_if_data *sdata;
	struct sta_info *sta;
	struct ieee80211_key *key;
	struct ieee80211_tx_rate rate;
	unsigned int flags;
};

struct ieee80211_tx_info {
	u32 flags;
	u32 band: 3;
	u32 status_data_idr: 1;
	u32 status_data: 13;
	u32 hw_queue: 4;
	u32 tx_time_est: 10;
	union {
		struct {
			union {
				struct {
					struct ieee80211_tx_rate rates[4];
					s8 rts_cts_rate_idx;
					u8 use_rts: 1;
					u8 use_cts_prot: 1;
					u8 short_preamble: 1;
					u8 skip_table: 1;
					u8 antennas: 2;
				};
				long unsigned int jiffies;
			};
			struct ieee80211_vif *vif;
			struct ieee80211_key_conf *hw_key;
			u32 flags;
			codel_time_t enqueue_time;
		} control;
		struct {
			u64 cookie;
		} ack;
		struct {
			struct ieee80211_tx_rate rates[4];
			s32 ack_signal;
			u8 ampdu_ack_len;
			u8 ampdu_len;
			u8 antenna;
			u8 pad;
			u16 tx_time;
			u8 flags;
			u8 pad2;
			void *status_driver_data[2];
		} status;
		struct {
			struct ieee80211_tx_rate driver_rates[4];
			u8 pad[4];
			void *rate_driver_data[3];
		};
		void *driver_data[5];
	};
};

struct ieee80211_tx_pwr_env {
	u8 info;
	u8 variable[0];
};

struct ieee80211_tx_rate_control {
	struct ieee80211_hw *hw;
	struct ieee80211_supported_band *sband;
	struct ieee80211_bss_conf *bss_conf;
	struct sk_buff *skb;
	struct ieee80211_tx_rate reported_rate;
	bool rts;
	bool short_preamble;
	u32 rate_idx_mask;
	u8 *rate_idx_mcs_mask;
	bool bss;
};

struct ieee80211_tx_status {
	struct ieee80211_sta *sta;
	struct ieee80211_tx_info *info;
	struct sk_buff *skb;
	struct ieee80211_rate_status *rates;
	ktime_t ack_hwtstamp;
	u8 n_rates;
	struct list_head *free_list;
};

struct ieee80211_txq {
	struct ieee80211_vif *vif;
	struct ieee80211_sta *sta;
	u8 tid;
	u8 ac;
	long: 0;
	u8 drv_priv[0];
};

struct ieee80211_txq_params {
	enum nl80211_ac ac;
	u16 txop;
	u16 cwmin;
	u16 cwmax;
	u8 aifs;
	int link_id;
};

struct ieee80211_txrx_stypes {
	u16 tx;
	u16 rx;
};

struct ieee80211_vht_operation {
	u8 chan_width;
	u8 center_freq_seg0_idx;
	u8 center_freq_seg1_idx;
	__le16 basic_mcs_set;
} __attribute__((packed));

struct ieee80211_vif_chanctx_switch {
	struct ieee80211_vif *vif;
	struct ieee80211_bss_conf *link_conf;
	struct ieee80211_chanctx_conf *old_ctx;
	struct ieee80211_chanctx_conf *new_ctx;
};

struct ieee80211_wide_bw_chansw_ie {
	u8 new_channel_width;
	u8 new_center_freq_seg0;
	u8 new_center_freq_seg1;
};

struct ieee80211_wmm_ac_param {
	u8 aci_aifsn;
	u8 cw;
	__le16 txop_limit;
};

struct ieee80211_wmm_param_ie {
	u8 element_id;
	u8 len;
	u8 oui[3];
	u8 oui_type;
	u8 oui_subtype;
	u8 version;
	u8 qos_info;
	u8 reserved;
	struct ieee80211_wmm_ac_param ac[4];
};

struct ieee80211s_hdr {
	u8 flags;
	u8 ttl;
	__le32 seqnum;
	u8 eaddr1[6];
	u8 eaddr2[6];
} __attribute__((packed));

struct if6_iter_state {
	struct seq_net_private p;
	int bucket;
	int offset;
};

struct if_dqblk {
	__u64 dqb_bhardlimit;
	__u64 dqb_bsoftlimit;
	__u64 dqb_curspace;
	__u64 dqb_ihardlimit;
	__u64 dqb_isoftlimit;
	__u64 dqb_curinodes;
	__u64 dqb_btime;
	__u64 dqb_itime;
	__u32 dqb_valid;
};

struct if_dqinfo {
	__u64 dqi_bgrace;
	__u64 dqi_igrace;
	__u32 dqi_flags;
	__u32 dqi_valid;
};

struct if_nextdqblk {
	__u64 dqb_bhardlimit;
	__u64 dqb_bsoftlimit;
	__u64 dqb_curspace;
	__u64 dqb_ihardlimit;
	__u64 dqb_isoftlimit;
	__u64 dqb_curinodes;
	__u64 dqb_btime;
	__u64 dqb_itime;
	__u32 dqb_valid;
	__u32 dqb_id;
};

struct if_settings {
	unsigned int type;
	unsigned int size;
	union {
		raw_hdlc_proto *raw_hdlc;
		cisco_proto *cisco;
		fr_proto *fr;
		fr_proto_pvc *fr_pvc;
		fr_proto_pvc_info *fr_pvc_info;
		x25_hdlc_proto *x25;
		sync_serial_settings *sync;
		te1_settings *te1;
	} ifs_ifsu;
};

struct if_stats_msg {
	__u8 family;
	__u8 pad1;
	__u16 pad2;
	__u32 ifindex;
	__u32 filter_mask;
};

struct ifa6_config {
	const struct in6_addr *pfx;
	unsigned int plen;
	u8 ifa_proto;
	const struct in6_addr *peer_pfx;
	u32 rt_priority;
	u32 ifa_flags;
	u32 preferred_lft;
	u32 valid_lft;
	u16 scope;
};

struct ifa_cacheinfo {
	__u32 ifa_prefered;
	__u32 ifa_valid;
	__u32 cstamp;
	__u32 tstamp;
};

struct ifacaddr6 {
	struct in6_addr aca_addr;
	struct fib6_info *aca_rt;
	struct ifacaddr6 *aca_next;
	struct hlist_node aca_addr_lst;
	int aca_users;
	refcount_t aca_refcnt;
	long unsigned int aca_cstamp;
	long unsigned int aca_tstamp;
	struct callback_head rcu;
};

struct iface_combination_params {
	int radio_idx;
	int num_different_channels;
	u8 radar_detect;
	int iftype_num[13];
	u32 new_beacon_int;
};

struct ifaddrlblmsg {
	__u8 ifal_family;
	__u8 __ifal_reserved;
	__u8 ifal_prefixlen;
	__u8 ifal_flags;
	__u32 ifal_index;
	__u32 ifal_seq;
};

struct ifaddrmsg {
	__u8 ifa_family;
	__u8 ifa_prefixlen;
	__u8 ifa_flags;
	__u8 ifa_scope;
	__u32 ifa_index;
};

struct ifbond {
	__s32 bond_mode;
	__s32 num_slaves;
	__s32 miimon;
};

typedef struct ifbond ifbond;

struct ifreq;

struct ifconf {
	int ifc_len;
	union {
		char *ifcu_buf;
		struct ifreq *ifcu_req;
	} ifc_ifcu;
};

struct ifinfomsg {
	unsigned char ifi_family;
	unsigned char __ifi_pad;
	short unsigned int ifi_type;
	int ifi_index;
	unsigned int ifi_flags;
	unsigned int ifi_change;
};

struct ifla_cacheinfo {
	__u32 max_reasm_len;
	__u32 tstamp;
	__u32 reachable_time;
	__u32 retrans_time;
};

struct ifla_vf_broadcast {
	__u8 broadcast[32];
};

struct ifla_vf_guid {
	__u32 vf;
	__u64 guid;
};

struct ifla_vf_info {
	__u32 vf;
	__u8 mac[32];
	__u32 vlan;
	__u32 qos;
	__u32 spoofchk;
	__u32 linkstate;
	__u32 min_tx_rate;
	__u32 max_tx_rate;
	__u32 rss_query_en;
	__u32 trusted;
	__be16 vlan_proto;
};

struct ifla_vf_link_state {
	__u32 vf;
	__u32 link_state;
};

struct ifla_vf_mac {
	__u32 vf;
	__u8 mac[32];
};

struct ifla_vf_rate {
	__u32 vf;
	__u32 min_tx_rate;
	__u32 max_tx_rate;
};

struct ifla_vf_rss_query_en {
	__u32 vf;
	__u32 setting;
};

struct ifla_vf_spoofchk {
	__u32 vf;
	__u32 setting;
};

struct ifla_vf_stats {
	__u64 rx_packets;
	__u64 tx_packets;
	__u64 rx_bytes;
	__u64 tx_bytes;
	__u64 broadcast;
	__u64 multicast;
	__u64 rx_dropped;
	__u64 tx_dropped;
};

struct ifla_vf_trust {
	__u32 vf;
	__u32 setting;
};

struct ifla_vf_tx_rate {
	__u32 vf;
	__u32 rate;
};

struct ifla_vf_vlan {
	__u32 vf;
	__u32 vlan;
	__u32 qos;
};

struct ifla_vf_vlan_info {
	__u32 vf;
	__u32 vlan;
	__u32 qos;
	__be16 vlan_proto;
};

struct ifmap {
	long unsigned int mem_start;
	long unsigned int mem_end;
	short unsigned int base_addr;
	unsigned char irq;
	unsigned char dma;
	unsigned char port;
};

struct ip6_sf_list;

struct ifmcaddr6 {
	struct in6_addr mca_addr;
	struct inet6_dev *idev;
	struct ifmcaddr6 *next;
	struct ip6_sf_list *mca_sources;
	struct ip6_sf_list *mca_tomb;
	unsigned int mca_sfmode;
	unsigned char mca_crcount;
	long unsigned int mca_sfcount[2];
	struct delayed_work mca_work;
	unsigned int mca_flags;
	int mca_users;
	refcount_t mca_refcnt;
	long unsigned int mca_cstamp;
	long unsigned int mca_tstamp;
	struct callback_head rcu;
};

struct ifreq {
	union {
		char ifrn_name[16];
	} ifr_ifrn;
	union {
		struct sockaddr ifru_addr;
		struct sockaddr ifru_dstaddr;
		struct sockaddr ifru_broadaddr;
		struct sockaddr ifru_netmask;
		struct sockaddr ifru_hwaddr;
		short int ifru_flags;
		int ifru_ivalue;
		int ifru_mtu;
		struct ifmap ifru_map;
		char ifru_slave[16];
		char ifru_newname[16];
		void *ifru_data;
		struct if_settings ifru_settings;
	} ifr_ifru;
};

struct ifslave {
	__s32 slave_id;
	char slave_name[16];
	__s8 link;
	__s8 state;
	__u32 link_failure_count;
};

typedef struct ifslave ifslave;

struct igmp6_mc_iter_state {
	struct seq_net_private p;
	struct net_device *dev;
	struct inet6_dev *idev;
};

struct igmp6_mcf_iter_state {
	struct seq_net_private p;
	struct net_device *dev;
	struct inet6_dev *idev;
	struct ifmcaddr6 *im;
};

struct in_device;

struct igmp_mc_iter_state {
	struct seq_net_private p;
	struct net_device *dev;
	struct in_device *in_dev;
};

struct ip_mc_list;

struct igmp_mcf_iter_state {
	struct seq_net_private p;
	struct net_device *dev;
	struct in_device *idev;
	struct ip_mc_list *im;
};

struct igmphdr {
	__u8 type;
	__u8 code;
	__sum16 csum;
	__be32 group;
};

struct igmpmsg {
	__u32 unused1;
	__u32 unused2;
	unsigned char im_msgtype;
	unsigned char im_mbz;
	unsigned char im_vif;
	unsigned char im_vif_hi;
	struct in_addr im_src;
	struct in_addr im_dst;
};

struct igmpv3_grec {
	__u8 grec_type;
	__u8 grec_auxwords;
	__be16 grec_nsrcs;
	__be32 grec_mca;
	__be32 grec_src[0];
};

struct igmpv3_query {
	__u8 type;
	__u8 code;
	__sum16 csum;
	__be32 group;
	__u8 qrv: 3;
	__u8 suppress: 1;
	__u8 resv: 4;
	__u8 qqic;
	__be16 nsrcs;
	__be32 srcs[0];
};

struct igmpv3_report {
	__u8 type;
	__u8 resv1;
	__sum16 csum;
	__be16 resv2;
	__be16 ngrec;
	struct igmpv3_grec grec[0];
};

struct ignore_entry {
	u16 vid;
	u16 pid;
	u16 bcdmin;
	u16 bcdmax;
};

struct ilk_wm_maximums {
	u16 pri;
	u16 spr;
	u16 cur;
	u16 fbc;
};

struct imc_uncore_pci_dev {
	__u32 pci_id;
	struct pci_driver *driver;
};

struct in6_flowlabel_req {
	struct in6_addr flr_dst;
	__be32 flr_label;
	__u8 flr_action;
	__u8 flr_share;
	__u16 flr_flags;
	__u16 flr_expires;
	__u16 flr_linger;
	__u32 __flr_pad;
};

struct in6_ifreq {
	struct in6_addr ifr6_addr;
	__u32 ifr6_prefixlen;
	int ifr6_ifindex;
};

struct in6_pktinfo {
	struct in6_addr ipi6_addr;
	int ipi6_ifindex;
};

struct in6_rtmsg {
	struct in6_addr rtmsg_dst;
	struct in6_addr rtmsg_src;
	struct in6_addr rtmsg_gateway;
	__u32 rtmsg_type;
	__u16 rtmsg_dst_len;
	__u16 rtmsg_src_len;
	__u32 rtmsg_metric;
	long unsigned int rtmsg_info;
	__u32 rtmsg_flags;
	int rtmsg_ifindex;
};

struct in6_validator_info {
	struct in6_addr i6vi_addr;
	struct inet6_dev *i6vi_dev;
	struct netlink_ext_ack *extack;
};

struct ipv4_devconf {
	void *sysctl;
	int data[33];
	long unsigned int state[1];
};

struct in_ifaddr;

struct neigh_parms;

struct in_device {
	struct net_device *dev;
	netdevice_tracker dev_tracker;
	refcount_t refcnt;
	int dead;
	struct in_ifaddr *ifa_list;
	struct ip_mc_list *mc_list;
	struct ip_mc_list **mc_hash;
	int mc_count;
	spinlock_t mc_tomb_lock;
	struct ip_mc_list *mc_tomb;
	long unsigned int mr_v1_seen;
	long unsigned int mr_v2_seen;
	long unsigned int mr_maxdelay;
	long unsigned int mr_qi;
	long unsigned int mr_qri;
	unsigned char mr_qrv;
	unsigned char mr_gq_running;
	u32 mr_ifc_count;
	struct timer_list mr_gq_timer;
	struct timer_list mr_ifc_timer;
	struct neigh_parms *arp_parms;
	struct ipv4_devconf cnf;
	struct callback_head callback_head;
};

struct in_ifaddr {
	struct hlist_node addr_lst;
	struct in_ifaddr *ifa_next;
	struct in_device *ifa_dev;
	struct callback_head callback_head;
	__be32 ifa_local;
	__be32 ifa_address;
	__be32 ifa_mask;
	__u32 ifa_rt_priority;
	__be32 ifa_broadcast;
	unsigned char ifa_scope;
	unsigned char ifa_prefixlen;
	unsigned char ifa_proto;
	__u32 ifa_flags;
	char ifa_label[16];
	__u32 ifa_valid_lft;
	__u32 ifa_preferred_lft;
	long unsigned int ifa_cstamp;
	long unsigned int ifa_tstamp;
};

struct in_pktinfo {
	int ipi_ifindex;
	struct in_addr ipi_spec_dst;
	struct in_addr ipi_addr;
};

struct in_validator_info {
	__be32 ivi_addr;
	struct in_device *ivi_dev;
	struct netlink_ext_ack *extack;
};

struct ipv6_txoptions;

struct inet6_cork {
	struct ipv6_txoptions *opt;
	u8 hop_limit;
	u8 tclass;
};

struct ipv6_stable_secret {
	bool initialized;
	struct in6_addr secret;
};

struct ipv6_devconf {
	__u8 __cacheline_group_begin__ipv6_devconf_read_txrx[0];
	__s32 disable_ipv6;
	__s32 hop_limit;
	__s32 mtu6;
	__s32 forwarding;
	__s32 disable_policy;
	__s32 proxy_ndp;
	__u8 __cacheline_group_end__ipv6_devconf_read_txrx[0];
	__s32 accept_ra;
	__s32 accept_redirects;
	__s32 autoconf;
	__s32 dad_transmits;
	__s32 rtr_solicits;
	__s32 rtr_solicit_interval;
	__s32 rtr_solicit_max_interval;
	__s32 rtr_solicit_delay;
	__s32 force_mld_version;
	__s32 mldv1_unsolicited_report_interval;
	__s32 mldv2_unsolicited_report_interval;
	__s32 use_tempaddr;
	__s32 temp_valid_lft;
	__s32 temp_prefered_lft;
	__s32 regen_min_advance;
	__s32 regen_max_retry;
	__s32 max_desync_factor;
	__s32 max_addresses;
	__s32 accept_ra_defrtr;
	__u32 ra_defrtr_metric;
	__s32 accept_ra_min_hop_limit;
	__s32 accept_ra_min_lft;
	__s32 accept_ra_pinfo;
	__s32 ignore_routes_with_linkdown;
	__s32 accept_source_route;
	__s32 accept_ra_from_local;
	__s32 drop_unicast_in_l2_multicast;
	__s32 accept_dad;
	__s32 force_tllao;
	__s32 ndisc_notify;
	__s32 suppress_frag_ndisc;
	__s32 accept_ra_mtu;
	__s32 drop_unsolicited_na;
	__s32 accept_untracked_na;
	struct ipv6_stable_secret stable_secret;
	__s32 use_oif_addrs_only;
	__s32 keep_addr_on_down;
	__s32 seg6_enabled;
	__u32 enhanced_dad;
	__u32 addr_gen_mode;
	__s32 ndisc_tclass;
	__s32 rpl_seg_enabled;
	__u32 ioam6_id;
	__u32 ioam6_id_wide;
	__u8 ioam6_enabled;
	__u8 ndisc_evict_nocarrier;
	__u8 ra_honor_pio_life;
	__u8 ra_honor_pio_pflag;
	struct ctl_table_header *sysctl_header;
};

struct ipstats_mib;

struct ipv6_devstat {
	struct proc_dir_entry *proc_dir_entry;
	struct ipstats_mib *ipv6;
	struct icmpv6_mib_device *icmpv6dev;
	struct icmpv6msg_mib_device *icmpv6msgdev;
};

struct inet6_dev {
	struct net_device *dev;
	netdevice_tracker dev_tracker;
	struct list_head addr_list;
	struct ifmcaddr6 *mc_list;
	struct ifmcaddr6 *mc_tomb;
	unsigned char mc_qrv;
	unsigned char mc_gq_running;
	unsigned char mc_ifc_count;
	unsigned char mc_dad_count;
	long unsigned int mc_v1_seen;
	long unsigned int mc_qi;
	long unsigned int mc_qri;
	long unsigned int mc_maxdelay;
	struct delayed_work mc_gq_work;
	struct delayed_work mc_ifc_work;
	struct delayed_work mc_dad_work;
	struct delayed_work mc_query_work;
	struct delayed_work mc_report_work;
	struct sk_buff_head mc_query_queue;
	struct sk_buff_head mc_report_queue;
	spinlock_t mc_query_lock;
	spinlock_t mc_report_lock;
	struct mutex mc_lock;
	struct ifacaddr6 *ac_list;
	rwlock_t lock;
	refcount_t refcnt;
	__u32 if_flags;
	int dead;
	u32 desync_factor;
	struct list_head tempaddr_list;
	struct in6_addr token;
	struct neigh_parms *nd_parms;
	struct ipv6_devconf cnf;
	struct ipv6_devstat stats;
	struct timer_list rs_timer;
	__s32 rs_interval;
	__u8 rs_probes;
	long unsigned int tstamp;
	struct callback_head rcu;
	unsigned int ra_mtu;
};

struct inet6_fill_args {
	u32 portid;
	u32 seq;
	int event;
	unsigned int flags;
	int netnsid;
	int ifindex;
	enum addr_type_t type;
	bool force_rt_scope_universe;
};

struct inet6_ifaddr {
	struct in6_addr addr;
	__u32 prefix_len;
	__u32 rt_priority;
	__u32 valid_lft;
	__u32 prefered_lft;
	refcount_t refcnt;
	spinlock_t lock;
	int state;
	__u32 flags;
	__u8 dad_probes;
	__u8 stable_privacy_retry;
	__u16 scope;
	__u64 dad_nonce;
	long unsigned int cstamp;
	long unsigned int tstamp;
	struct delayed_work dad_work;
	struct inet6_dev *idev;
	struct fib6_info *rt;
	struct hlist_node addr_lst;
	struct list_head if_list;
	struct list_head if_list_aux;
	struct list_head tmp_list;
	struct inet6_ifaddr *ifpub;
	int regen_count;
	bool tokenized;
	u8 ifa_proto;
	struct callback_head rcu;
	struct in6_addr peer_addr;
};

struct inet6_protocol {
	int (*handler)(struct sk_buff *);
	int (*err_handler)(struct sk_buff *, struct inet6_skb_parm *, u8, u8, int, __be32);
	unsigned int flags;
	u32 secret;
};

union inet_addr {
	__u32 all[4];
	__be32 ip;
	__be32 ip6[4];
	struct in_addr in;
	struct in6_addr in6;
};

struct inet_bind2_bucket {
	possible_net_t ib_net;
	int l3mdev;
	short unsigned int port;
	short unsigned int addr_type;
	struct in6_addr v6_rcv_saddr;
	struct hlist_node node;
	struct hlist_node bhash_node;
	struct hlist_head owners;
};

struct inet_bind_bucket {
	possible_net_t ib_net;
	int l3mdev;
	short unsigned int port;
	signed char fastreuse;
	signed char fastreuseport;
	kuid_t fastuid;
	struct in6_addr fast_v6_rcv_saddr;
	__be32 fast_rcv_saddr;
	short unsigned int fast_sk_family;
	bool fast_ipv6_only;
	struct hlist_node node;
	struct hlist_head bhash2;
};

struct inet_bind_hashbucket {
	spinlock_t lock;
	struct hlist_head chain;
};

struct proto;

struct inet_timewait_death_row;

struct sock_common {
	union {
		__addrpair skc_addrpair;
		struct {
			__be32 skc_daddr;
			__be32 skc_rcv_saddr;
		};
	};
	union {
		unsigned int skc_hash;
		__u16 skc_u16hashes[2];
	};
	union {
		__portpair skc_portpair;
		struct {
			__be16 skc_dport;
			__u16 skc_num;
		};
	};
	short unsigned int skc_family;
	volatile unsigned char skc_state;
	unsigned char skc_reuse: 4;
	unsigned char skc_reuseport: 1;
	unsigned char skc_ipv6only: 1;
	unsigned char skc_net_refcnt: 1;
	int skc_bound_dev_if;
	union {
		struct hlist_node skc_bind_node;
		struct hlist_node skc_portaddr_node;
	};
	struct proto *skc_prot;
	possible_net_t skc_net;
	struct in6_addr skc_v6_daddr;
	struct in6_addr skc_v6_rcv_saddr;
	atomic64_t skc_cookie;
	union {
		long unsigned int skc_flags;
		struct sock *skc_listener;
		struct inet_timewait_death_row *skc_tw_dr;
	};
	int skc_dontcopy_begin[0];
	union {
		struct hlist_node skc_node;
		struct hlist_nulls_node skc_nulls_node;
	};
	short unsigned int skc_tx_queue_mapping;
	short unsigned int skc_rx_queue_mapping;
	union {
		int skc_incoming_cpu;
		u32 skc_rcv_wnd;
		u32 skc_tw_rcv_nxt;
	};
	refcount_t skc_refcnt;
	int skc_dontcopy_end[0];
	union {
		u32 skc_rxhash;
		u32 skc_window_clamp;
		u32 skc_tw_snd_nxt;
	};
};

struct page_frag {
	struct page *page;
	__u32 offset;
	__u32 size;
};

struct sock_cgroup_data {
	struct cgroup *cgroup;
	u32 classid;
	u16 prioidx;
};

struct sk_filter;

struct socket_wq;

struct xfrm_policy;

struct sock_reuseport;

struct sock {
	struct sock_common __sk_common;
	__u8 __cacheline_group_begin__sock_write_rx[0];
	atomic_t sk_drops;
	__s32 sk_peek_off;
	struct sk_buff_head sk_error_queue;
	struct sk_buff_head sk_receive_queue;
	struct {
		atomic_t rmem_alloc;
		int len;
		struct sk_buff *head;
		struct sk_buff *tail;
	} sk_backlog;
	__u8 __cacheline_group_end__sock_write_rx[0];
	__u8 __cacheline_group_begin__sock_read_rx[0];
	struct dst_entry *sk_rx_dst;
	int sk_rx_dst_ifindex;
	u32 sk_rx_dst_cookie;
	unsigned int sk_ll_usec;
	unsigned int sk_napi_id;
	u16 sk_busy_poll_budget;
	u8 sk_prefer_busy_poll;
	u8 sk_userlocks;
	int sk_rcvbuf;
	struct sk_filter *sk_filter;
	union {
		struct socket_wq *sk_wq;
		struct socket_wq *sk_wq_raw;
	};
	void (*sk_data_ready)(struct sock *);
	long int sk_rcvtimeo;
	int sk_rcvlowat;
	__u8 __cacheline_group_end__sock_read_rx[0];
	__u8 __cacheline_group_begin__sock_read_rxtx[0];
	int sk_err;
	struct socket *sk_socket;
	struct mem_cgroup *sk_memcg;
	struct xfrm_policy *sk_policy[2];
	__u8 __cacheline_group_end__sock_read_rxtx[0];
	__u8 __cacheline_group_begin__sock_write_rxtx[0];
	socket_lock_t sk_lock;
	u32 sk_reserved_mem;
	int sk_forward_alloc;
	u32 sk_tsflags;
	__u8 __cacheline_group_end__sock_write_rxtx[0];
	__u8 __cacheline_group_begin__sock_write_tx[0];
	int sk_write_pending;
	atomic_t sk_omem_alloc;
	int sk_sndbuf;
	int sk_wmem_queued;
	refcount_t sk_wmem_alloc;
	long unsigned int sk_tsq_flags;
	union {
		struct sk_buff *sk_send_head;
		struct rb_root tcp_rtx_queue;
	};
	struct sk_buff_head sk_write_queue;
	u32 sk_dst_pending_confirm;
	u32 sk_pacing_status;
	struct page_frag sk_frag;
	struct timer_list sk_timer;
	long unsigned int sk_pacing_rate;
	atomic_t sk_zckey;
	atomic_t sk_tskey;
	__u8 __cacheline_group_end__sock_write_tx[0];
	__u8 __cacheline_group_begin__sock_read_tx[0];
	long unsigned int sk_max_pacing_rate;
	long int sk_sndtimeo;
	u32 sk_priority;
	u32 sk_mark;
	struct dst_entry *sk_dst_cache;
	netdev_features_t sk_route_caps;
	u16 sk_gso_type;
	u16 sk_gso_max_segs;
	unsigned int sk_gso_max_size;
	gfp_t sk_allocation;
	u32 sk_txhash;
	u8 sk_pacing_shift;
	bool sk_use_task_frag;
	__u8 __cacheline_group_end__sock_read_tx[0];
	u8 sk_gso_disabled: 1;
	u8 sk_kern_sock: 1;
	u8 sk_no_check_tx: 1;
	u8 sk_no_check_rx: 1;
	u8 sk_shutdown;
	u16 sk_type;
	u16 sk_protocol;
	long unsigned int sk_lingertime;
	struct proto *sk_prot_creator;
	rwlock_t sk_callback_lock;
	int sk_err_soft;
	u32 sk_ack_backlog;
	u32 sk_max_ack_backlog;
	kuid_t sk_uid;
	spinlock_t sk_peer_lock;
	int sk_bind_phc;
	struct pid *sk_peer_pid;
	const struct cred *sk_peer_cred;
	ktime_t sk_stamp;
	int sk_disconnects;
	u8 sk_txrehash;
	u8 sk_clockid;
	u8 sk_txtime_deadline_mode: 1;
	u8 sk_txtime_report_errors: 1;
	u8 sk_txtime_unused: 6;
	void *sk_user_data;
	void *sk_security;
	struct sock_cgroup_data sk_cgrp_data;
	void (*sk_state_change)(struct sock *);
	void (*sk_write_space)(struct sock *);
	void (*sk_error_report)(struct sock *);
	int (*sk_backlog_rcv)(struct sock *, struct sk_buff *);
	void (*sk_destruct)(struct sock *);
	struct sock_reuseport *sk_reuseport_cb;
	struct bpf_local_storage *sk_bpf_storage;
	struct callback_head sk_rcu;
	netns_tracker ns_tracker;
	struct xarray sk_user_frags;
};

struct inet_cork {
	unsigned int flags;
	__be32 addr;
	struct ip_options *opt;
	unsigned int fragsize;
	int length;
	struct dst_entry *dst;
	u8 tx_flags;
	__u8 ttl;
	__s16 tos;
	u32 priority;
	__u16 gso_size;
	u32 ts_opt_id;
	u64 transmit_time;
	u32 mark;
};

struct inet_cork_full {
	struct inet_cork base;
	struct flowi fl;
};

struct ipv6_pinfo;

struct ip_mc_socklist;

struct inet_sock {
	struct sock sk;
	struct ipv6_pinfo *pinet6;
	long unsigned int inet_flags;
	__be32 inet_saddr;
	__s16 uc_ttl;
	__be16 inet_sport;
	struct ip_options_rcu *inet_opt;
	atomic_t inet_id;
	__u8 tos;
	__u8 min_ttl;
	__u8 mc_ttl;
	__u8 pmtudisc;
	__u8 rcv_tos;
	__u8 convert_csum;
	int uc_index;
	int mc_index;
	__be32 mc_addr;
	u32 local_port_range;
	struct ip_mc_socklist *mc_list;
	struct inet_cork_full cork;
};

struct request_sock_queue {
	spinlock_t rskq_lock;
	u8 rskq_defer_accept;
	u32 synflood_warned;
	atomic_t qlen;
	atomic_t young;
	struct request_sock *rskq_accept_head;
	struct request_sock *rskq_accept_tail;
	struct fastopen_queue fastopenq;
};

struct tcp_congestion_ops;

struct inet_connection_sock_af_ops;

struct tcp_ulp_ops;

struct inet_connection_sock {
	struct inet_sock icsk_inet;
	struct request_sock_queue icsk_accept_queue;
	struct inet_bind_bucket *icsk_bind_hash;
	struct inet_bind2_bucket *icsk_bind2_hash;
	long unsigned int icsk_timeout;
	struct timer_list icsk_retransmit_timer;
	struct timer_list icsk_delack_timer;
	__u32 icsk_rto;
	__u32 icsk_rto_min;
	__u32 icsk_delack_max;
	__u32 icsk_pmtu_cookie;
	const struct tcp_congestion_ops *icsk_ca_ops;
	const struct inet_connection_sock_af_ops *icsk_af_ops;
	const struct tcp_ulp_ops *icsk_ulp_ops;
	void *icsk_ulp_data;
	void (*icsk_clean_acked)(struct sock *, u32);
	unsigned int (*icsk_sync_mss)(struct sock *, u32);
	__u8 icsk_ca_state: 5;
	__u8 icsk_ca_initialized: 1;
	__u8 icsk_ca_setsockopt: 1;
	__u8 icsk_ca_dst_locked: 1;
	__u8 icsk_retransmits;
	__u8 icsk_pending;
	__u8 icsk_backoff;
	__u8 icsk_syn_retries;
	__u8 icsk_probes_out;
	__u16 icsk_ext_hdr_len;
	struct {
		__u8 pending;
		__u8 quick;
		__u8 pingpong;
		__u8 retry;
		__u32 ato: 8;
		__u32 lrcv_flowlabel: 20;
		__u32 unused: 4;
		long unsigned int timeout;
		__u32 lrcvtime;
		__u16 last_seg_size;
		__u16 rcv_mss;
	} icsk_ack;
	struct {
		int search_high;
		int search_low;
		u32 probe_size: 31;
		u32 enabled: 1;
		u32 probe_timestamp;
	} icsk_mtup;
	u32 icsk_probes_tstamp;
	u32 icsk_user_timeout;
	u64 icsk_ca_priv[13];
};

struct inet_connection_sock_af_ops {
	int (*queue_xmit)(struct sock *, struct sk_buff *, struct flowi *);
	void (*send_check)(struct sock *, struct sk_buff *);
	int (*rebuild_header)(struct sock *);
	void (*sk_rx_dst_set)(struct sock *, const struct sk_buff *);
	int (*conn_request)(struct sock *, struct sk_buff *);
	struct sock * (*syn_recv_sock)(const struct sock *, struct sk_buff *, struct request_sock *, struct dst_entry *, struct request_sock *, bool *);
	u16 net_header_len;
	u16 sockaddr_len;
	int (*setsockopt)(struct sock *, int, int, sockptr_t, unsigned int);
	int (*getsockopt)(struct sock *, int, int, char *, int *);
	void (*addr2sockaddr)(struct sock *, struct sockaddr *);
	void (*mtu_reduced)(struct sock *);
};

struct inet_ehash_bucket {
	struct hlist_nulls_head chain;
};

struct inet_fill_args {
	u32 portid;
	u32 seq;
	int event;
	unsigned int flags;
	int netnsid;
	int ifindex;
};

struct inet_frags {
	unsigned int qsize;
	void (*constructor)(struct inet_frag_queue *, const void *);
	void (*destructor)(struct inet_frag_queue *);
	void (*frag_expire)(struct timer_list *);
	struct kmem_cache *frags_cachep;
	const char *frags_cache_name;
	struct rhashtable_params rhash_params;
	refcount_t refcnt;
	struct completion completion;
};

struct inet_listen_hashbucket;

struct inet_hashinfo {
	struct inet_ehash_bucket *ehash;
	spinlock_t *ehash_locks;
	unsigned int ehash_mask;
	unsigned int ehash_locks_mask;
	struct kmem_cache *bind_bucket_cachep;
	struct inet_bind_hashbucket *bhash;
	struct kmem_cache *bind2_bucket_cachep;
	struct inet_bind_hashbucket *bhash2;
	unsigned int bhash_size;
	unsigned int lhash2_mask;
	struct inet_listen_hashbucket *lhash2;
	bool pernet;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct inet_listen_hashbucket {
	spinlock_t lock;
	struct hlist_nulls_head nulls_head;
};

struct ipv4_addr_key {
	__be32 addr;
	int vif;
};

struct inetpeer_addr {
	union {
		struct ipv4_addr_key a4;
		struct in6_addr a6;
		u32 key[4];
	};
	__u16 family;
};

struct inet_peer {
	struct rb_node rb_node;
	struct inetpeer_addr daddr;
	u32 metrics[17];
	u32 rate_tokens;
	u32 n_redirects;
	long unsigned int rate_last;
	union {
		struct {
			atomic_t rid;
		};
		struct callback_head rcu;
	};
	__u32 dtime;
	refcount_t refcnt;
};

struct proto_ops;

struct inet_protosw {
	struct list_head list;
	short unsigned int type;
	short unsigned int protocol;
	struct proto *prot;
	const struct proto_ops *ops;
	unsigned char flags;
};

struct request_sock_ops;

struct saved_syn;

struct request_sock {
	struct sock_common __req_common;
	struct request_sock *dl_next;
	u16 mss;
	u8 num_retrans;
	u8 syncookie: 1;
	u8 num_timeout: 7;
	u32 ts_recent;
	struct timer_list rsk_timer;
	const struct request_sock_ops *rsk_ops;
	struct sock *sk;
	struct saved_syn *saved_syn;
	u32 secid;
	u32 peer_secid;
	u32 timeout;
};

struct inet_request_sock {
	struct request_sock req;
	u16 snd_wscale: 4;
	u16 rcv_wscale: 4;
	u16 tstamp_ok: 1;
	u16 sack_ok: 1;
	u16 wscale_ok: 1;
	u16 ecn_ok: 1;
	u16 acked: 1;
	u16 no_srccheck: 1;
	u16 smc_ok: 1;
	u32 ir_mark;
	union {
		struct ip_options_rcu *ireq_opt;
		struct {
			struct ipv6_txoptions *ipv6_opt;
			struct sk_buff *pktopts;
		};
	};
};

struct inet_timewait_death_row {
	refcount_t tw_refcount;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct inet_hashinfo *hashinfo;
	int sysctl_max_tw_buckets;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct inet_timewait_sock {
	struct sock_common __tw_common;
	__u32 tw_mark;
	unsigned char tw_substate;
	unsigned char tw_rcv_wscale;
	__be16 tw_sport;
	unsigned int tw_transparent: 1;
	unsigned int tw_flowlabel: 20;
	unsigned int tw_usec_ts: 1;
	unsigned int tw_pad: 2;
	unsigned int tw_tos: 8;
	u32 tw_txhash;
	u32 tw_priority;
	u32 tw_entry_stamp;
	struct timer_list tw_timer;
	struct inet_bind_bucket *tw_tb;
	struct inet_bind2_bucket *tw_tb2;
};

struct inflate_state {
	inflate_mode mode;
	int last;
	int wrap;
	int havedict;
	int flags;
	unsigned int dmax;
	long unsigned int check;
	long unsigned int total;
	unsigned int wbits;
	unsigned int wsize;
	unsigned int whave;
	unsigned int write;
	unsigned char *window;
	long unsigned int hold;
	unsigned int bits;
	unsigned int length;
	unsigned int offset;
	unsigned int extra;
	const code *lencode;
	const code *distcode;
	unsigned int lenbits;
	unsigned int distbits;
	unsigned int ncode;
	unsigned int nlen;
	unsigned int ndist;
	unsigned int have;
	code *next;
	short unsigned int lens[320];
	short unsigned int work[288];
	code codes[2048];
};

struct inflate_workspace {
	struct inflate_state inflate_state;
	unsigned char working_window[32768];
};

struct inform_bss_update_data {
	struct ieee80211_rx_status *rx_status;
	bool beacon;
};

struct x86_mapping_info;

struct init_pgtable_data {
	struct x86_mapping_info *info;
	pgd_t *level4p;
};

struct mnt_idmap;

struct kstat;

struct offset_ctx;

struct inode_operations {
	struct dentry * (*lookup)(struct inode *, struct dentry *, unsigned int);
	const char * (*get_link)(struct dentry *, struct inode *, struct delayed_call *);
	int (*permission)(struct mnt_idmap *, struct inode *, int);
	struct posix_acl * (*get_inode_acl)(struct inode *, int, bool);
	int (*readlink)(struct dentry *, char *, int);
	int (*create)(struct mnt_idmap *, struct inode *, struct dentry *, umode_t, bool);
	int (*link)(struct dentry *, struct inode *, struct dentry *);
	int (*unlink)(struct inode *, struct dentry *);
	int (*symlink)(struct mnt_idmap *, struct inode *, struct dentry *, const char *);
	int (*mkdir)(struct mnt_idmap *, struct inode *, struct dentry *, umode_t);
	int (*rmdir)(struct inode *, struct dentry *);
	int (*mknod)(struct mnt_idmap *, struct inode *, struct dentry *, umode_t, dev_t);
	int (*rename)(struct mnt_idmap *, struct inode *, struct dentry *, struct inode *, struct dentry *, unsigned int);
	int (*setattr)(struct mnt_idmap *, struct dentry *, struct iattr *);
	int (*getattr)(struct mnt_idmap *, const struct path *, struct kstat *, u32, unsigned int);
	ssize_t (*listxattr)(struct dentry *, char *, size_t);
	int (*fiemap)(struct inode *, struct fiemap_extent_info *, u64, u64);
	int (*update_time)(struct inode *, int);
	int (*atomic_open)(struct inode *, struct dentry *, struct file *, unsigned int, umode_t);
	int (*tmpfile)(struct mnt_idmap *, struct inode *, struct file *, umode_t);
	struct posix_acl * (*get_acl)(struct mnt_idmap *, struct dentry *, int);
	int (*set_acl)(struct mnt_idmap *, struct dentry *, struct posix_acl *, int);
	int (*fileattr_set)(struct mnt_idmap *, struct dentry *, struct fileattr *);
	int (*fileattr_get)(struct dentry *, struct fileattr *);
	struct offset_ctx * (*get_offset_ctx)(struct inode *);
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct inode_security_struct {
	struct inode *inode;
	struct list_head list;
	u32 task_sid;
	u32 sid;
	u16 sclass;
	unsigned char initialized;
	spinlock_t lock;
};

struct inodes_stat_t {
	long int nr_inodes;
	long int nr_unused;
	long int dummy[5];
};

struct inotify_event {
	__s32 wd;
	__u32 mask;
	__u32 cookie;
	__u32 len;
	char name[0];
};

struct inotify_event_info {
	struct fsnotify_event fse;
	u32 mask;
	int wd;
	u32 sync_cookie;
	int name_len;
	char name[0];
};

struct inotify_inode_mark {
	struct fsnotify_mark fsn_mark;
	int wd;
};

struct input_absinfo {
	__s32 value;
	__s32 minimum;
	__s32 maximum;
	__s32 fuzz;
	__s32 flat;
	__s32 resolution;
};

struct input_id {
	__u16 bustype;
	__u16 vendor;
	__u16 product;
	__u16 version;
};

struct input_dev_poller;

struct input_mt;

struct input_dev {
	const char *name;
	const char *phys;
	const char *uniq;
	struct input_id id;
	long unsigned int propbit[1];
	long unsigned int evbit[1];
	long unsigned int keybit[12];
	long unsigned int relbit[1];
	long unsigned int absbit[1];
	long unsigned int mscbit[1];
	long unsigned int ledbit[1];
	long unsigned int sndbit[1];
	long unsigned int ffbit[2];
	long unsigned int swbit[1];
	unsigned int hint_events_per_packet;
	unsigned int keycodemax;
	unsigned int keycodesize;
	void *keycode;
	int (*setkeycode)(struct input_dev *, const struct input_keymap_entry *, unsigned int *);
	int (*getkeycode)(struct input_dev *, struct input_keymap_entry *);
	struct ff_device *ff;
	struct input_dev_poller *poller;
	unsigned int repeat_key;
	struct timer_list timer;
	int rep[2];
	struct input_mt *mt;
	struct input_absinfo *absinfo;
	long unsigned int key[12];
	long unsigned int led[1];
	long unsigned int snd[1];
	long unsigned int sw[1];
	int (*open)(struct input_dev *);
	void (*close)(struct input_dev *);
	int (*flush)(struct input_dev *, struct file *);
	int (*event)(struct input_dev *, unsigned int, unsigned int, int);
	struct input_handle *grab;
	spinlock_t event_lock;
	struct mutex mutex;
	unsigned int users;
	bool going_away;
	struct device dev;
	struct list_head h_list;
	struct list_head node;
	unsigned int num_vals;
	unsigned int max_vals;
	struct input_value *vals;
	bool devres_managed;
	ktime_t timestamp[3];
	bool inhibited;
};

struct input_dev_poller {
	void (*poll)(struct input_dev *);
	unsigned int poll_interval;
	unsigned int poll_interval_max;
	unsigned int poll_interval_min;
	struct input_dev *input;
	struct delayed_work work;
};

struct input_device_id {
	kernel_ulong_t flags;
	__u16 bustype;
	__u16 vendor;
	__u16 product;
	__u16 version;
	kernel_ulong_t evbit[1];
	kernel_ulong_t keybit[12];
	kernel_ulong_t relbit[1];
	kernel_ulong_t absbit[1];
	kernel_ulong_t mscbit[1];
	kernel_ulong_t ledbit[1];
	kernel_ulong_t sndbit[1];
	kernel_ulong_t ffbit[2];
	kernel_ulong_t swbit[1];
	kernel_ulong_t propbit[1];
	kernel_ulong_t driver_info;
};

struct input_devres {
	struct input_dev *input;
};

struct input_event_compat {
	compat_ulong_t sec;
	compat_ulong_t usec;
	__u16 type;
	__u16 code;
	__s32 value;
};

struct input_handler {
	void *private;
	void (*event)(struct input_handle *, unsigned int, unsigned int, int);
	unsigned int (*events)(struct input_handle *, struct input_value *, unsigned int);
	bool (*filter)(struct input_handle *, unsigned int, unsigned int, int);
	bool (*match)(struct input_handler *, struct input_dev *);
	int (*connect)(struct input_handler *, struct input_dev *, const struct input_device_id *);
	void (*disconnect)(struct input_handle *);
	void (*start)(struct input_handle *);
	bool passive_observer;
	bool legacy_minors;
	int minor;
	const char *name;
	const struct input_device_id *id_table;
	struct list_head h_list;
	struct list_head node;
};

struct input_led {
	struct led_classdev cdev;
	struct input_handle *handle;
	unsigned int code;
};

struct input_leds {
	struct input_handle handle;
	unsigned int num_leds;
	struct input_led leds[0];
};

struct input_mask {
	__u32 type;
	__u32 codes_size;
	__u64 codes_ptr;
};

struct input_mt_slot {
	int abs[14];
	unsigned int frame;
	unsigned int key;
};

struct input_mt {
	int trkid;
	int num_slots;
	int slot;
	unsigned int flags;
	unsigned int frame;
	int *red;
	struct input_mt_slot slots[0];
};

struct input_res {
	u16 w;
	u16 h;
};

struct input_seq_state {
	short unsigned int pos;
	bool mutex_acquired;
	int input_devices_state;
};

struct input_value {
	__u16 type;
	__u16 code;
	__s32 value;
};

struct insert_entries {
	struct i915_address_space *vm;
	struct i915_vma_resource *vma_res;
	unsigned int pat_index;
	u32 flags;
};

struct insert_page {
	struct i915_address_space *vm;
	dma_addr_t addr;
	u64 offset;
	unsigned int pat_index;
};

struct insert_pte_data {
	u64 offset;
};

struct insn_field {
	union {
		insn_value_t value;
		insn_byte_t bytes[4];
	};
	unsigned char got;
	unsigned char nbytes;
};

struct insn {
	struct insn_field prefixes;
	struct insn_field rex_prefix;
	struct insn_field vex_prefix;
	struct insn_field opcode;
	struct insn_field modrm;
	struct insn_field sib;
	struct insn_field displacement;
	union {
		struct insn_field immediate;
		struct insn_field moffset1;
		struct insn_field immediate1;
	};
	union {
		struct insn_field moffset2;
		struct insn_field immediate2;
	};
	int emulate_prefix_size;
	insn_attr_t attr;
	unsigned char opnd_bytes;
	unsigned char addr_bytes;
	unsigned char length;
	unsigned char x86_64;
	const insn_byte_t *kaddr;
	const insn_byte_t *end_kaddr;
	const insn_byte_t *next_byte;
};

union intcapxt {
	u64 capxt;
	struct {
		u64 reserved_0: 2;
		u64 dest_mode_logical: 1;
		u64 reserved_1: 5;
		u64 destid_0_23: 24;
		u64 vector: 8;
		u64 reserved_2: 16;
		u64 destid_24_31: 8;
	};
};

struct intel_agp_driver_description {
	unsigned int chip_id;
	char *name;
	const struct agp_bridge_driver *driver;
};

struct intel_dp_tunnel_inherited_state;

struct intel_atomic_state {
	struct drm_atomic_state base;
	intel_wakeref_t wakeref;
	struct __intel_global_objs_state *global_objs;
	int num_global_objs;
	bool internal;
	bool dpll_set;
	bool modeset;
	struct intel_shared_dpll_state shared_dpll[9];
	struct intel_dp_tunnel_inherited_state *inherited_dp_tunnels;
	bool skip_intermediate_wm;
	bool rps_interactive;
	struct work_struct cleanup_work;
};

struct intel_crtc_state;

struct intel_audio_funcs {
	void (*audio_codec_enable)(struct intel_encoder *, const struct intel_crtc_state *, const struct drm_connector_state *);
	void (*audio_codec_disable)(struct intel_encoder *, const struct intel_crtc_state *, const struct drm_connector_state *);
	void (*audio_codec_get_config)(struct intel_encoder *, struct intel_crtc_state *);
};

struct intel_bios_encoder_data {
	struct intel_display *display;
	struct child_device_config child;
	struct dsc_compression_parameters_entry *dsc;
	struct list_head node;
};

struct intel_breadcrumbs {
	struct kref ref;
	atomic_t active;
	spinlock_t signalers_lock;
	struct list_head signalers;
	struct llist_head signaled_requests;
	atomic_t signaler_active;
	spinlock_t irq_lock;
	struct irq_work irq_work;
	unsigned int irq_enabled;
	intel_wakeref_t irq_armed;
	intel_engine_mask_t engine_mask;
	struct intel_engine_cs *irq_engine;
	bool (*irq_enable)(struct intel_breadcrumbs *);
	void (*irq_disable)(struct intel_breadcrumbs *);
};

struct intel_global_commit;

struct intel_global_state {
	struct intel_global_obj *obj;
	struct intel_atomic_state *state;
	struct intel_global_commit *commit;
	struct kref ref;
	bool changed;
	bool serialized;
};

struct intel_dbuf_bw {
	unsigned int max_bw[4];
	u8 active_planes[4];
};

struct intel_bw_state {
	struct intel_global_state base;
	struct intel_dbuf_bw dbuf_bw[4];
	u8 pipe_sagv_reject;
	u8 active_pipes;
	u16 qgv_point_peakbw;
	u16 qgv_points_mask;
	bool force_check_qgv;
	int min_cdclk[4];
	unsigned int data_rate[4];
	u8 num_active_planes[4];
};

struct intel_cdclk_funcs {
	void (*get_cdclk)(struct intel_display *, struct intel_cdclk_config *);
	void (*set_cdclk)(struct intel_display *, const struct intel_cdclk_config *, enum pipe);
	int (*modeset_calc_cdclk)(struct intel_atomic_state *);
	u8 (*calc_voltage_level)(int);
};

struct intel_cdclk_state {
	struct intel_global_state base;
	struct intel_cdclk_config logical;
	struct intel_cdclk_config actual;
	int bw_min_cdclk;
	int min_cdclk[4];
	u8 min_voltage_level[4];
	enum pipe pipe;
	int force_min_cdclk;
	u8 active_pipes;
	bool disable_pipes;
};

struct intel_cdclk_vals {
	u32 cdclk;
	u16 refclk;
	u16 waveform;
	u8 ratio;
};

struct intel_crtc;

struct intel_dsb;

struct intel_color_funcs {
	int (*color_check)(struct intel_atomic_state *, struct intel_crtc *);
	void (*color_commit_noarm)(struct intel_dsb *, const struct intel_crtc_state *);
	void (*color_commit_arm)(struct intel_dsb *, const struct intel_crtc_state *);
	void (*color_post_update)(const struct intel_crtc_state *);
	void (*load_luts)(const struct intel_crtc_state *);
	void (*read_luts)(struct intel_crtc_state *);
	bool (*lut_equal)(const struct intel_crtc_state *, const struct drm_property_blob *, const struct drm_property_blob *, bool);
	void (*read_csc)(struct intel_crtc_state *);
	void (*get_config)(struct intel_crtc_state *);
};

struct pwm_state {
	u64 period;
	u64 duty_cycle;
	enum pwm_polarity polarity;
	bool enabled;
	bool usage_power;
};

struct intel_pps_delays {
	u16 power_up;
	u16 backlight_on;
	u16 backlight_off;
	u16 power_down;
	u16 power_cycle;
};

struct intel_vbt_panel_data {
	struct drm_display_mode *lfp_vbt_mode;
	struct drm_display_mode *sdvo_lvds_vbt_mode;
	int panel_type;
	unsigned int lvds_dither: 1;
	unsigned int bios_lvds_val;
	bool vrr;
	u8 seamless_drrs_min_refresh_rate;
	enum drrs_type drrs_type;
	struct {
		int max_link_rate;
		int rate;
		int lanes;
		int preemphasis;
		int vswing;
		int bpp;
		struct intel_pps_delays pps;
		u8 drrs_msa_timing_delay;
		bool low_vswing;
		bool hobl;
		bool dsc_disable;
	} edp;
	struct {
		bool enable;
		bool full_link;
		bool require_aux_wakeup;
		int idle_frames;
		int tp1_wakeup_time_us;
		int tp2_tp3_wakeup_time_us;
		int psr2_tp2_tp3_wakeup_time_us;
	} psr;
	struct {
		u16 pwm_freq_hz;
		u16 brightness_precision_bits;
		u16 hdr_dpcd_refresh_timeout;
		bool present;
		bool active_low_pwm;
		u8 min_brightness;
		s8 controller;
		enum intel_backlight_type type;
	} backlight;
	struct {
		u16 panel_id;
		struct mipi_config *config;
		struct mipi_pps_data *pps;
		u16 bl_ports;
		u16 cabc_ports;
		u8 seq_version;
		u32 size;
		u8 *data;
		const u8 *sequence[12];
		u8 *deassert_seq;
		enum drm_panel_orientation orientation;
	} dsi;
};

struct pwm_device;

struct intel_panel_bl_funcs;

struct intel_connector;

struct intel_panel {
	const struct drm_edid *fixed_edid;
	struct list_head fixed_modes;
	struct {
		bool present;
		u32 level;
		u32 min;
		u32 max;
		bool enabled;
		bool combination_mode;
		bool active_low_pwm;
		bool alternate_pwm_increment;
		u32 pwm_level_min;
		u32 pwm_level_max;
		bool pwm_enabled;
		bool util_pin_active_low;
		u8 controller;
		struct pwm_device *pwm;
		struct pwm_state pwm_state;
		union {
			struct {
				struct drm_edp_backlight_info info;
			} vesa;
			struct {
				bool sdr_uses_aux;
				bool supports_2084_decode;
				bool supports_2020_gamut;
				bool supports_segmented_backlight;
				bool supports_sdp_colorimetry;
				bool supports_tone_mapping;
			} intel_cap;
		} edp;
		struct backlight_device *device;
		const struct intel_panel_bl_funcs *funcs;
		const struct intel_panel_bl_funcs *pwm_funcs;
		void (*power)(struct intel_connector *, bool);
	} backlight;
	struct intel_vbt_panel_data vbt;
};

struct intel_hdcp_shim;

struct intel_hdcp {
	const struct intel_hdcp_shim *shim;
	struct mutex mutex;
	u64 value;
	struct delayed_work check_work;
	struct work_struct prop_work;
	bool hdcp_encrypted;
	bool hdcp2_supported;
	bool hdcp2_encrypted;
	u8 content_type;
	bool is_paired;
	bool is_repeater;
	u32 seq_num_v;
	u32 seq_num_m;
	wait_queue_head_t cp_irq_queue;
	atomic_t cp_irq_count;
	int cp_irq_count_cached;
	enum transcoder cpu_transcoder;
	enum transcoder stream_transcoder;
};

struct intel_dp;

struct intel_connector {
	struct drm_connector base;
	struct intel_encoder *encoder;
	u32 acpi_device_id;
	bool (*get_hw_state)(struct intel_connector *);
	void (*sync_state)(struct intel_connector *, const struct intel_crtc_state *);
	struct intel_panel panel;
	const struct drm_edid *detect_edid;
	int hotplug_retries;
	u8 polled;
	struct drm_dp_mst_port *port;
	struct intel_dp *mst_port;
	int force_joined_pipes;
	struct {
		struct drm_dp_aux *dsc_decompression_aux;
		u8 dsc_dpcd[16];
		u8 fec_capability;
		u8 dsc_hblank_expansion_quirk: 1;
		u8 dsc_decompression_enabled: 1;
	} dp;
	struct work_struct modeset_retry_work;
	struct intel_hdcp hdcp;
};

struct intel_context_ops {
	long unsigned int flags;
	int (*alloc)(struct intel_context *);
	void (*revoke)(struct intel_context *, struct i915_request *, unsigned int);
	void (*close)(struct intel_context *);
	int (*pre_pin)(struct intel_context *, struct i915_gem_ww_ctx *, void **);
	int (*pin)(struct intel_context *, void *);
	void (*unpin)(struct intel_context *);
	void (*post_unpin)(struct intel_context *);
	void (*cancel_request)(struct intel_context *, struct i915_request *);
	void (*enter)(struct intel_context *);
	void (*exit)(struct intel_context *);
	void (*sched_disable)(struct intel_context *);
	void (*update_stats)(struct intel_context *);
	void (*reset)(struct intel_context *);
	void (*destroy)(struct kref *);
	struct intel_context * (*create_virtual)(struct intel_engine_cs **, unsigned int, long unsigned int);
	struct intel_context * (*create_parallel)(struct intel_engine_cs **, unsigned int, unsigned int);
	struct intel_engine_cs * (*get_sibling)(struct intel_engine_cs *, unsigned int);
};

struct intel_ddi_buf_trans;

struct intel_encoder {
	struct drm_encoder base;
	enum intel_output_type type;
	enum port port;
	u16 cloneable;
	u8 pipe_mask;
	struct delayed_work link_check_work;
	void (*link_check)(struct intel_encoder *);
	enum intel_hotplug_state (*hotplug)(struct intel_encoder *, struct intel_connector *);
	enum intel_output_type (*compute_output_type)(struct intel_encoder *, struct intel_crtc_state *, struct drm_connector_state *);
	int (*compute_config)(struct intel_encoder *, struct intel_crtc_state *, struct drm_connector_state *);
	int (*compute_config_late)(struct intel_encoder *, struct intel_crtc_state *, struct drm_connector_state *);
	void (*pre_pll_enable)(struct intel_atomic_state *, struct intel_encoder *, const struct intel_crtc_state *, const struct drm_connector_state *);
	void (*pre_enable)(struct intel_atomic_state *, struct intel_encoder *, const struct intel_crtc_state *, const struct drm_connector_state *);
	void (*enable)(struct intel_atomic_state *, struct intel_encoder *, const struct intel_crtc_state *, const struct drm_connector_state *);
	void (*disable)(struct intel_atomic_state *, struct intel_encoder *, const struct intel_crtc_state *, const struct drm_connector_state *);
	void (*post_disable)(struct intel_atomic_state *, struct intel_encoder *, const struct intel_crtc_state *, const struct drm_connector_state *);
	void (*post_pll_disable)(struct intel_atomic_state *, struct intel_encoder *, const struct intel_crtc_state *, const struct drm_connector_state *);
	void (*update_pipe)(struct intel_atomic_state *, struct intel_encoder *, const struct intel_crtc_state *, const struct drm_connector_state *);
	void (*audio_enable)(struct intel_encoder *, const struct intel_crtc_state *, const struct drm_connector_state *);
	void (*audio_disable)(struct intel_encoder *, const struct intel_crtc_state *, const struct drm_connector_state *);
	bool (*get_hw_state)(struct intel_encoder *, enum pipe *);
	void (*get_config)(struct intel_encoder *, struct intel_crtc_state *);
	void (*sync_state)(struct intel_encoder *, const struct intel_crtc_state *);
	bool (*initial_fastset_check)(struct intel_encoder *, struct intel_crtc_state *);
	void (*get_power_domains)(struct intel_encoder *, struct intel_crtc_state *);
	void (*suspend)(struct intel_encoder *);
	void (*suspend_complete)(struct intel_encoder *);
	void (*shutdown)(struct intel_encoder *);
	void (*shutdown_complete)(struct intel_encoder *);
	void (*enable_clock)(struct intel_encoder *, const struct intel_crtc_state *);
	void (*disable_clock)(struct intel_encoder *);
	bool (*is_clock_enabled)(struct intel_encoder *);
	enum icl_port_dpll_id (*port_pll_type)(struct intel_encoder *, const struct intel_crtc_state *);
	const struct intel_ddi_buf_trans * (*get_buf_trans)(struct intel_encoder *, const struct intel_crtc_state *, int *);
	void (*set_signal_levels)(struct intel_encoder *, const struct intel_crtc_state *);
	enum hpd_pin hpd_pin;
	enum intel_display_power_domain power_domain;
	const struct intel_bios_encoder_data *devdata;
};

struct intel_crt {
	struct intel_encoder base;
	bool force_hotplug_required;
	i915_reg_t adpa_reg;
};

struct intel_display_power_domain_set {
	struct intel_power_domain_mask mask;
};

struct intel_wm_level {
	bool enable;
	u32 pri_val;
	u32 spr_val;
	u32 cur_val;
	u32 fbc_val;
};

struct intel_pipe_wm {
	struct intel_wm_level wm[5];
	bool fbc_wm_enabled;
	bool pipe_enabled;
	bool sprites_enabled;
	bool sprites_scaled;
};

struct vlv_wm_state {
	struct g4x_pipe_wm wm[3];
	struct g4x_sr_wm sr[3];
	u8 num_levels;
	bool cxsr;
};

struct intel_link_m_n {
	u32 tu;
	u32 data_m;
	u32 data_n;
	u32 link_m;
	u32 link_n;
};

struct intel_pipe_crc {
	spinlock_t lock;
	int skipped;
	enum intel_pipe_crc_source source;
};

struct intel_crtc {
	struct drm_crtc base;
	enum pipe pipe;
	bool active;
	u8 plane_ids_mask;
	u8 mode_flags;
	u16 vmax_vblank_start;
	struct intel_display_power_domain_set enabled_power_domains;
	struct intel_display_power_domain_set hw_readout_power_domains;
	struct intel_overlay *overlay;
	struct intel_crtc_state *config;
	struct drm_pending_vblank_event *flip_done_event;
	struct drm_pending_vblank_event *dsb_event;
	bool cpu_fifo_underrun_disabled;
	bool pch_fifo_underrun_disabled;
	struct {
		union {
			struct intel_pipe_wm ilk;
			struct vlv_wm_state vlv;
			struct g4x_wm_state g4x;
		} active;
	} wm;
	struct {
		struct mutex mutex;
		struct delayed_work work;
		enum drrs_refresh_rate refresh_rate;
		unsigned int frontbuffer_bits;
		unsigned int busy_frontbuffer_bits;
		enum transcoder cpu_transcoder;
		struct intel_link_m_n m_n;
		struct intel_link_m_n m2_n2;
	} drrs;
	int scanline_offset;
	struct {
		unsigned int start_vbl_count;
		ktime_t start_vbl_time;
		int min_vbl;
		int max_vbl;
		int scanline_start;
	} debug;
	int num_scalers;
	struct pm_qos_request vblank_pm_qos;
	struct intel_pipe_crc pipe_crc;
	bool block_dc_for_vblank;
};

struct intel_scaler {
	u32 mode;
	bool in_use;
};

struct intel_crtc_scaler_state {
	struct intel_scaler scalers[2];
	unsigned int scaler_users;
	int scaler_id;
};

struct intel_csc_matrix {
	u16 coeff[9];
	u16 preoff[3];
	u16 postoff[3];
};

struct skl_wm_level {
	u16 min_ddb_alloc;
	u16 blocks;
	u8 lines;
	bool enable;
	bool ignore_lines;
	bool auto_min_alloc_wm_enable;
	bool can_sagv;
};

struct skl_plane_wm {
	struct skl_wm_level wm[8];
	struct skl_wm_level uv_wm[8];
	struct skl_wm_level trans_wm;
	struct {
		struct skl_wm_level wm0;
		struct skl_wm_level trans_wm;
	} sagv;
	bool is_planar;
};

struct skl_pipe_wm {
	struct skl_plane_wm planes[8];
	bool use_sagv_wm;
};

struct skl_ddb_entry {
	u16 start;
	u16 end;
};

struct vlv_fifo_state {
	u16 plane[8];
};

struct intel_crtc_wm_state {
	union {
		struct {
			struct intel_pipe_wm intermediate;
			struct intel_pipe_wm optimal;
		} ilk;
		struct {
			struct skl_pipe_wm raw;
			struct skl_pipe_wm optimal;
			struct skl_ddb_entry ddb;
			struct skl_ddb_entry plane_ddb[8];
			struct skl_ddb_entry plane_ddb_y[8];
			u16 plane_min_ddb[8];
			u16 plane_interim_ddb[8];
		} skl;
		struct {
			struct g4x_pipe_wm raw[3];
			struct vlv_wm_state intermediate;
			struct vlv_wm_state optimal;
			struct vlv_fifo_state fifo_state;
		} vlv;
		struct {
			struct g4x_pipe_wm raw[3];
			struct g4x_wm_state intermediate;
			struct g4x_wm_state optimal;
		} g4x;
	};
	bool need_postvbl_update;
};

struct intel_crtc_state {
	struct drm_crtc_state uapi;
	struct {
		bool active;
		bool enable;
		struct drm_property_blob *degamma_lut;
		struct drm_property_blob *gamma_lut;
		struct drm_property_blob *ctm;
		struct drm_display_mode mode;
		struct drm_display_mode pipe_mode;
		struct drm_display_mode adjusted_mode;
		enum drm_scaling_filter scaling_filter;
	} hw;
	struct drm_property_blob *pre_csc_lut;
	struct drm_property_blob *post_csc_lut;
	struct intel_csc_matrix csc;
	struct intel_csc_matrix output_csc;
	long unsigned int quirks;
	unsigned int fb_bits;
	bool update_pipe;
	bool update_m_n;
	bool update_lrr;
	bool disable_cxsr;
	bool update_wm_pre;
	bool update_wm_post;
	bool fifo_changed;
	bool preload_luts;
	bool inherited;
	bool do_async_flip;
	struct drm_rect pipe_src;
	unsigned int pixel_rate;
	bool has_pch_encoder;
	bool has_infoframe;
	enum transcoder cpu_transcoder;
	bool limited_color_range;
	unsigned int output_types;
	bool has_hdmi_sink;
	bool has_audio;
	bool dither;
	bool dither_force_disable;
	bool clock_set;
	bool sdvo_tv_clock;
	bool bw_constrained;
	struct dpll dpll;
	struct intel_shared_dpll *shared_dpll;
	struct intel_dpll_hw_state dpll_hw_state;
	struct icl_port_dpll icl_port_dplls[2];
	struct {
		u32 ctrl;
		u32 div;
	} dsi_pll;
	int max_link_bpp_x16;
	int pipe_bpp;
	struct intel_link_m_n dp_m_n;
	struct intel_link_m_n dp_m2_n2;
	bool has_drrs;
	bool has_psr;
	bool has_sel_update;
	bool enable_psr2_sel_fetch;
	bool enable_psr2_su_region_et;
	bool req_psr2_sdp_prior_scanline;
	bool has_panel_replay;
	bool wm_level_disabled;
	u32 dc3co_exitline;
	u16 su_y_granularity;
	int port_clock;
	unsigned int pixel_multiplier;
	u8 mode_flags;
	u8 lane_count;
	u8 lane_lat_optim_mask;
	u8 min_voltage_level;
	struct {
		u32 control;
		u32 pgm_ratios;
		u32 lvds_border_bits;
	} gmch_pfit;
	struct {
		struct drm_rect dst;
		bool enabled;
		bool force_thru;
	} pch_pfit;
	int fdi_lanes;
	struct intel_link_m_n fdi_m_n;
	bool ips_enabled;
	bool crc_enabled;
	bool double_wide;
	struct intel_crtc_scaler_state scaler_state;
	enum pipe hsw_workaround_pipe;
	struct intel_crtc_wm_state wm;
	int min_cdclk[8];
	u32 data_rate[8];
	u32 data_rate_y[8];
	u64 rel_data_rate[8];
	u64 rel_data_rate_y[8];
	u32 gamma_mode;
	union {
		u32 csc_mode;
		u32 cgm_mode;
	};
	u8 enabled_planes;
	u8 active_planes;
	u8 scaled_planes;
	u8 nv12_planes;
	u8 c8_planes;
	u8 update_planes;
	u8 async_flip_planes;
	u8 framestart_delay;
	u8 msa_timing_delay;
	struct {
		u32 enable;
		u32 gcp;
		union hdmi_infoframe avi;
		union hdmi_infoframe spd;
		union hdmi_infoframe hdmi;
		union hdmi_infoframe drm;
		struct drm_dp_vsc_sdp vsc;
		struct drm_dp_as_sdp as_sdp;
	} infoframes;
	u8 eld[128];
	bool hdmi_scrambling;
	bool hdmi_high_tmds_clock_ratio;
	enum intel_output_format output_format;
	enum intel_output_format sink_format;
	bool gamma_enable;
	bool csc_enable;
	bool wgc_enable;
	u8 joiner_pipes;
	struct {
		bool compression_enable;
		int num_streams;
		u16 compressed_bpp_x16;
		u8 slice_count;
		struct drm_dsc_config config;
	} dsc;
	struct drm_dp_tunnel_ref dp_tunnel_ref;
	u16 linetime;
	u16 ips_linetime;
	bool enhanced_framing;
	bool fec_enable;
	bool sdp_split_enable;
	enum transcoder master_transcoder;
	u8 sync_mode_slaves_mask;
	enum transcoder mst_master_transcoder;
	struct intel_dsb *dsb_color_vblank;
	struct intel_dsb *dsb_commit;
	bool use_dsb;
	u32 psr2_man_track_ctl;
	u32 pipe_srcsz_early_tpt;
	struct drm_rect psr2_su_area;
	struct {
		bool enable;
		bool in_range;
		u8 pipeline_full;
		u16 flipline;
		u16 vmin;
		u16 vmax;
		u16 guardband;
		u32 vsync_end;
		u32 vsync_start;
	} vrr;
	struct {
		bool enable;
		u64 cmrr_n;
		u64 cmrr_m;
	} cmrr;
	struct {
		bool enable;
		u8 link_count;
		u8 pixel_overlap;
	} splitter;
	struct drm_vblank_work vblank_work;
	bool has_lobf;
};

struct intel_css_header {
	u32 module_type;
	u32 header_len;
	u32 header_ver;
	u32 module_id;
	u32 module_vendor;
	u32 date;
	u32 size;
	u32 key_size;
	u32 modulus_size;
	u32 exponent_size;
	u32 reserved1[12];
	u32 version;
	u32 reserved2[8];
	u32 kernel_header_info;
};

struct intel_dbuf_state {
	struct intel_global_state base;
	struct skl_ddb_entry ddb[4];
	unsigned int weight[4];
	u8 slices[4];
	u8 enabled_slices;
	u8 active_pipes;
	u8 mdclk_cdclk_ratio;
	bool joined_mbus;
};

union intel_ddi_buf_trans_entry;

struct intel_ddi_buf_trans {
	const union intel_ddi_buf_trans_entry *entries;
	u8 num_entries;
	u8 hdmi_default_entry;
};

struct tgl_dkl_phy_ddi_buf_trans {
	u8 vswing;
	u8 preshoot;
	u8 de_emphasis;
};

union intel_ddi_buf_trans_entry {
	struct hsw_ddi_buf_trans hsw;
	struct bxt_ddi_buf_trans bxt;
	struct icl_ddi_buf_trans icl;
	struct icl_mg_phy_ddi_buf_trans mg;
	struct tgl_dkl_phy_ddi_buf_trans dkl;
	struct dg2_snps_phy_buf_trans snps;
};

struct intel_ddi_port_domains {
	enum port port_start;
	enum port port_end;
	enum aux_ch aux_ch_start;
	enum aux_ch aux_ch_end;
	enum intel_display_power_domain ddi_lanes;
	enum intel_display_power_domain ddi_io;
	enum intel_display_power_domain aux_io;
	enum intel_display_power_domain aux_legacy_usbc;
	enum intel_display_power_domain aux_tbt;
};

struct intel_digital_connector_state {
	struct drm_connector_state base;
	enum hdmi_force_audio force_audio;
	int broadcast_rgb;
};

struct intel_dp_link_config {
	u8 link_rate_idx: 6;
	u8 lane_count_exp: 2;
};

struct intel_pps {
	int panel_power_up_delay;
	int panel_power_down_delay;
	int panel_power_cycle_delay;
	int backlight_on_delay;
	int backlight_off_delay;
	struct delayed_work panel_vdd_work;
	bool want_panel_vdd;
	bool initializing;
	long unsigned int last_power_on;
	long unsigned int last_backlight_off;
	ktime_t panel_power_off_time;
	intel_wakeref_t vdd_wakeref;
	union {
		enum pipe vlv_pps_pipe;
		int pps_idx;
	};
	enum pipe vlv_active_pipe;
	bool bxt_pps_reset;
	struct intel_pps_delays pps_delays;
	struct intel_pps_delays bios_pps_delays;
};

struct intel_dp_compliance_data {
	long unsigned int edid;
	u8 video_pattern;
	u16 hdisplay;
	u16 vdisplay;
	u8 bpc;
	struct drm_dp_phy_test_params phytest;
};

struct intel_dp_compliance {
	long unsigned int test_type;
	struct intel_dp_compliance_data test_data;
	bool test_active;
	int test_link_rate;
	u8 test_lane_count;
};

struct intel_dp_pcon_frl {
	bool is_trained;
	int trained_rate_gbps;
};

struct intel_psr {
	struct mutex lock;
	u32 debug;
	bool sink_support;
	bool source_support;
	bool enabled;
	bool paused;
	enum pipe pipe;
	enum transcoder transcoder;
	bool active;
	struct work_struct work;
	unsigned int busy_frontbuffer_bits;
	bool sink_psr2_support;
	bool link_standby;
	bool sel_update_enabled;
	bool psr2_sel_fetch_enabled;
	bool psr2_sel_fetch_cff_enabled;
	bool su_region_et_enabled;
	bool req_psr2_sdp_prior_scanline;
	u8 sink_sync_latency;
	ktime_t last_entry_attempt;
	ktime_t last_exit;
	bool sink_not_reliable;
	bool irq_aux_error;
	u16 su_w_granularity;
	u16 su_y_granularity;
	bool source_panel_replay_support;
	bool sink_panel_replay_support;
	bool sink_panel_replay_su_support;
	bool panel_replay_enabled;
	u32 dc3co_exitline;
	u32 dc3co_exit_delay;
	struct delayed_work dc3co_work;
	u8 entry_setup_frames;
	bool link_ok;
};

struct intel_dp_mst_encoder;

struct intel_dp {
	i915_reg_t output_reg;
	u32 DP;
	int link_rate;
	u8 lane_count;
	u8 sink_count;
	bool link_trained;
	bool needs_modeset_retry;
	bool use_max_params;
	u8 dpcd[15];
	u8 psr_dpcd[2];
	u8 pr_dpcd;
	u8 downstream_ports[16];
	u8 edp_dpcd[3];
	u8 lttpr_common_caps[8];
	u8 lttpr_phy_caps[24];
	u8 pcon_dsc_dpcd[13];
	int num_source_rates;
	const int *source_rates;
	int num_sink_rates;
	int sink_rates[8];
	bool use_rate_select;
	int max_sink_lane_count;
	int num_common_rates;
	int common_rates[8];
	struct {
		int num_configs;
		struct intel_dp_link_config configs[24];
		int max_lane_count;
		int max_rate;
		int mst_probed_lane_count;
		int mst_probed_rate;
		int force_lane_count;
		int force_rate;
		bool retrain_disabled;
		int seq_train_failures;
		int force_train_failure;
		bool force_retrain;
	} link;
	bool reset_link_params;
	int mso_link_count;
	int mso_pixel_overlap;
	struct drm_dp_desc desc;
	struct drm_dp_aux aux;
	u32 aux_busy_last_status;
	u8 train_set[4];
	struct intel_pps pps;
	bool is_mst;
	int active_mst_links;
	enum drm_dp_mst_mode mst_detect;
	struct intel_connector *attached_connector;
	bool as_sdp_supported;
	struct drm_dp_tunnel *tunnel;
	bool tunnel_suspended: 1;
	struct intel_dp_mst_encoder *mst_encoders[4];
	struct drm_dp_mst_topology_mgr mst_mgr;
	u32 (*get_aux_clock_divider)(struct intel_dp *, int);
	u32 (*get_aux_send_ctl)(struct intel_dp *, int, u32);
	i915_reg_t (*aux_ch_ctl_reg)(struct intel_dp *);
	i915_reg_t (*aux_ch_data_reg)(struct intel_dp *, int);
	void (*prepare_link_retrain)(struct intel_dp *, const struct intel_crtc_state *);
	void (*set_link_train)(struct intel_dp *, const struct intel_crtc_state *, u8);
	void (*set_idle_link_train)(struct intel_dp *, const struct intel_crtc_state *);
	u8 (*preemph_max)(struct intel_dp *);
	u8 (*voltage_max)(struct intel_dp *, const struct intel_crtc_state *);
	struct intel_dp_compliance compliance;
	struct {
		int min_tmds_clock;
		int max_tmds_clock;
		int max_dotclock;
		int pcon_max_frl_bw;
		u8 max_bpc;
		bool ycbcr_444_to_420;
		bool ycbcr420_passthrough;
		bool rgb_to_ycbcr;
	} dfp;
	struct pm_qos_request pm_qos;
	bool force_dsc_en;
	int force_dsc_output_format;
	bool force_dsc_fractional_bpp_en;
	int force_dsc_bpc;
	bool hobl_failed;
	bool hobl_active;
	struct intel_dp_pcon_frl frl;
	struct intel_psr psr;
	long unsigned int last_oui_write;
	bool oui_valid;
	bool colorimetry_support;
	struct {
		u8 io_wake_lines;
		u8 fast_wake_lines;
		u8 check_entry_lines;
		u8 aux_less_wake_lines;
		u8 silence_period_sym_clocks;
		u8 lfps_half_cycle_num_of_syms;
	} alpm_parameters;
	u8 alpm_dpcd;
	struct {
		long unsigned int mask;
	} quirks;
};

struct cec_notifier;

struct intel_hdmi {
	i915_reg_t hdmi_reg;
	struct {
		enum drm_dp_dual_mode_type type;
		int max_tmds_clock;
	} dp_dual_mode;
	struct intel_connector *attached_connector;
	struct cec_notifier *cec_notifier;
};

struct intel_lspcon {
	bool active;
	bool hdr_supported;
	enum drm_lspcon_mode mode;
	enum lspcon_vendor vendor;
};

struct intel_tc_port;

struct intel_digital_port {
	struct intel_encoder base;
	struct intel_dp dp;
	struct intel_hdmi hdmi;
	struct intel_lspcon lspcon;
	enum irqreturn (*hpd_pulse)(struct intel_digital_port *, bool);
	bool lane_reversal;
	bool ddi_a_4_lanes;
	bool release_cl2_override;
	u8 max_lanes;
	enum aux_ch aux_ch;
	enum intel_display_power_domain ddi_io_power_domain;
	intel_wakeref_t ddi_io_wakeref;
	intel_wakeref_t aux_wakeref;
	struct intel_tc_port *tc;
	struct mutex hdcp_mutex;
	unsigned int num_hdcp_streams;
	bool hdcp_auth_status;
	struct hdcp_port_data hdcp_port_data;
	bool hdcp_mst_type1_capable;
	void (*write_infoframe)(struct intel_encoder *, const struct intel_crtc_state *, unsigned int, const void *, ssize_t);
	void (*read_infoframe)(struct intel_encoder *, const struct intel_crtc_state *, unsigned int, void *, ssize_t);
	void (*set_infoframes)(struct intel_encoder *, bool, const struct intel_crtc_state *, const struct drm_connector_state *);
	u32 (*infoframes_enabled)(struct intel_encoder *, const struct intel_crtc_state *);
	bool (*connected)(struct intel_encoder *);
	void (*lock)(struct intel_digital_port *);
	void (*unlock)(struct intel_digital_port *);
};

struct intel_display_device_info {
	const struct intel_display_runtime_info __runtime_defaults;
	u8 abox_mask;
	struct {
		u16 size;
		u8 slice_mask;
	} dbuf;
	u8 cursor_needs_physical: 1;
	u8 has_cdclk_crawl: 1;
	u8 has_cdclk_squash: 1;
	u8 has_ddi: 1;
	u8 has_dp_mst: 1;
	u8 has_dsb: 1;
	u8 has_fpga_dbg: 1;
	u8 has_gmch: 1;
	u8 has_hotplug: 1;
	u8 has_hti: 1;
	u8 has_ipc: 1;
	u8 has_overlay: 1;
	u8 has_psr: 1;
	u8 has_psr_hw_tracking: 1;
	u8 overlay_needs_physical: 1;
	u8 supports_tv: 1;
	u32 mmio_offset;
	u32 pipe_offsets[7];
	u32 trans_offsets[7];
	u32 cursor_offsets[4];
	struct {
		u32 degamma_lut_size;
		u32 gamma_lut_size;
		u32 degamma_lut_tests;
		u32 gamma_lut_tests;
	} color;
};

struct intel_initial_plane_config;

struct intel_display_funcs {
	bool (*get_pipe_config)(struct intel_crtc *, struct intel_crtc_state *);
	void (*get_initial_plane_config)(struct intel_crtc *, struct intel_initial_plane_config *);
	bool (*fixup_initial_plane_config)(struct intel_crtc *, const struct intel_initial_plane_config *);
	void (*crtc_enable)(struct intel_atomic_state *, struct intel_crtc *);
	void (*crtc_disable)(struct intel_atomic_state *, struct intel_crtc *);
	void (*commit_modeset_enables)(struct intel_atomic_state *);
};

struct intel_overlay_snapshot;

struct intel_dmc_snapshot;

struct intel_display_snapshot {
	struct intel_display *display;
	struct intel_display_device_info info;
	struct intel_display_runtime_info runtime_info;
	struct intel_display_params params;
	struct intel_overlay_snapshot *overlay;
	struct intel_dmc_snapshot *dmc;
};

struct intel_dkl_phy_reg {
	u32 reg: 24;
	u32 bank_idx: 4;
};

struct intel_dmc {
	struct intel_display *display;
	struct work_struct work;
	const char *fw_path;
	u32 max_fw_size;
	u32 version;
	struct dmc_fw_info dmc_info[5];
};

struct intel_dmc_header_base {
	u32 signature;
	u8 header_len;
	u8 header_ver;
	u16 dmcc_ver;
	u32 project;
	u32 fw_size;
	u32 fw_version;
};

struct intel_dmc_header_v1 {
	struct intel_dmc_header_base base;
	u32 mmio_count;
	u32 mmioaddr[8];
	u32 mmiodata[8];
	char dfile[32];
	u32 reserved1[2];
};

struct intel_dmc_header_v3 {
	struct intel_dmc_header_base base;
	u32 start_mmioaddr;
	u32 reserved[9];
	char dfile[32];
	u32 mmio_count;
	u32 mmioaddr[20];
	u32 mmiodata[20];
};

struct intel_dmc_snapshot {
	bool initialized;
	bool loaded;
	u32 version;
};

struct intel_dmc_wl_range {
	u32 start;
	u32 end;
};

struct intel_dmi_quirk {
	void (*hook)(struct intel_display *);
	const struct dmi_system_id (*dmi_id_list)[0];
};

struct intel_dp_mst_encoder {
	struct intel_encoder base;
	enum pipe pipe;
	struct intel_digital_port *primary;
	struct intel_connector *connector;
};

struct intel_dpcd_quirk {
	int device;
	int subsystem_vendor;
	int subsystem_device;
	u8 sink_oui[3];
	u8 sink_device_id[6];
	void (*hook)(struct intel_dp *);
};

struct intel_dpll_funcs {
	int (*crtc_compute_clock)(struct intel_atomic_state *, struct intel_crtc *);
	int (*crtc_get_shared_dpll)(struct intel_atomic_state *, struct intel_crtc *);
};

struct intel_dpll_mgr {
	const struct dpll_info *dpll_info;
	int (*compute_dplls)(struct intel_atomic_state *, struct intel_crtc *, struct intel_encoder *);
	int (*get_dplls)(struct intel_atomic_state *, struct intel_crtc *, struct intel_encoder *);
	void (*put_dplls)(struct intel_atomic_state *, struct intel_crtc *);
	void (*update_active_dpll)(struct intel_atomic_state *, struct intel_crtc *, struct intel_encoder *);
	void (*update_ref_clks)(struct drm_i915_private *);
	void (*dump_hw_state)(struct drm_printer *, const struct intel_dpll_hw_state *);
	bool (*compare_hw_state)(const struct intel_dpll_hw_state *, const struct intel_dpll_hw_state *);
};

struct intel_dsb_buffer {
	u32 *cmd_buf;
	struct i915_vma *vma;
	size_t buf_size;
};

struct intel_dsb {
	enum intel_dsb_id id;
	struct intel_dsb_buffer dsb_buf;
	struct intel_crtc *crtc;
	unsigned int size;
	unsigned int free_pos;
	u32 ins[2];
	unsigned int ins_start_offset;
	u32 chicken;
	int hw_dewake_scanline;
};

struct intel_dsi_host;

struct intel_dsi {
	struct intel_encoder base;
	struct intel_dsi_host *dsi_hosts[9];
	intel_wakeref_t io_wakeref[9];
	struct gpio_desc *gpio_panel;
	struct gpio_desc *gpio_backlight;
	struct intel_connector *attached_connector;
	union {
		u16 ports;
		u16 phys;
	};
	int channel;
	u16 operation_mode;
	unsigned int lane_count;
	int i2c_bus_num;
	enum mipi_dsi_pixel_format pixel_format;
	int video_mode;
	u8 eotp_pkt;
	u8 clock_stop;
	u8 escape_clk_div;
	u8 dual_link;
	bool bgr_enabled;
	u8 pixel_overlap;
	u32 bw_timer;
	u32 dphy_reg;
	u32 dphy_data_lane_reg;
	u32 video_frmt_cfg_bits;
	u16 lp_byte_clk;
	u16 hs_tx_timeout;
	u16 lp_rx_timeout;
	u16 turn_arnd_val;
	u16 rst_timer_val;
	u16 hs_to_lp_count;
	u16 clk_lp_to_hs_count;
	u16 clk_hs_to_lp_count;
	u16 init_count;
	u32 pclk;
	u16 burst_mode_ratio;
	u16 backlight_off_delay;
	u16 backlight_on_delay;
	u16 panel_on_delay;
	u16 panel_off_delay;
	u16 panel_pwr_cycle_delay;
	ktime_t panel_power_off_time;
};

struct mipi_dsi_host_ops;

struct mipi_dsi_host {
	struct device *dev;
	const struct mipi_dsi_host_ops *ops;
	struct list_head list;
};

struct mipi_dsi_device;

struct intel_dsi_host {
	struct mipi_dsi_host base;
	struct intel_dsi *intel_dsi;
	enum port port;
	struct mipi_dsi_device *device;
};

struct intel_dvo_dev_ops;

struct intel_dvo_device {
	const char *name;
	int type;
	enum port port;
	u32 gpio;
	int target_addr;
	const struct intel_dvo_dev_ops *dev_ops;
	void *dev_priv;
	struct i2c_adapter *i2c_bus;
};

struct intel_dvo {
	struct intel_encoder base;
	struct intel_dvo_device dev;
	struct intel_connector *attached_connector;
};

struct intel_dvo_dev_ops {
	bool (*init)(struct intel_dvo_device *, struct i2c_adapter *);
	void (*dpms)(struct intel_dvo_device *, bool);
	enum drm_mode_status (*mode_valid)(struct intel_dvo_device *, struct drm_display_mode *);
	void (*mode_set)(struct intel_dvo_device *, const struct drm_display_mode *, const struct drm_display_mode *);
	enum drm_connector_status (*detect)(struct intel_dvo_device *);
	bool (*get_hw_state)(struct intel_dvo_device *);
	void (*destroy)(struct intel_dvo_device *);
	void (*dump_regs)(struct intel_dvo_device *);
};

struct intel_early_ops {
	resource_size_t (*stolen_size)(int, int, int);
	resource_size_t (*stolen_base)(int, int, int, resource_size_t);
};

struct intel_engine_capture_vma {
	struct intel_engine_capture_vma *next;
	struct i915_vma_resource *vma_res;
	char name[16];
	bool lockdep_cookie;
};

struct intel_instdone {
	u32 instdone;
	u32 slice_common;
	u32 slice_common_extra[2];
	u32 sampler[128];
	u32 row[128];
	u32 geom_svg[128];
};

struct intel_guc_state_capture;

struct intel_engine_coredump {
	const struct intel_engine_cs *engine;
	bool hung;
	bool simulated;
	u32 reset_count;
	u32 rq_head;
	u32 rq_post;
	u32 rq_tail;
	u32 ccid;
	u32 start;
	u32 tail;
	u32 head;
	u32 ctl;
	u32 mode;
	u32 hws;
	u32 ipeir;
	u32 ipehr;
	u32 esr;
	u32 bbstate;
	u32 instpm;
	u32 instps;
	u64 bbaddr;
	u64 acthd;
	u32 fault_reg;
	u64 faddr;
	u32 rc_psmi;
	u32 nopid;
	u32 excc;
	u32 cmd_cctl;
	u32 cscmdop;
	u32 ctx_sr_ctl;
	u32 dma_faddr_hi;
	u32 dma_faddr_lo;
	struct intel_instdone instdone;
	struct intel_guc_state_capture *guc_capture;
	struct __guc_capture_parsed_output *guc_capture_node;
	struct i915_gem_context_coredump context;
	struct i915_vma_coredump *vma;
	struct i915_request_coredump execlist[2];
	unsigned int num_ports;
	struct {
		u32 gfx_mode;
		union {
			u64 pdp[4];
			u32 pp_dir_base;
		};
	} vm_info;
	struct intel_engine_coredump *next;
};

struct intel_excl_states {
	enum intel_excl_state_type state[64];
	bool sched_started;
};

struct intel_excl_cntrs {
	raw_spinlock_t lock;
	struct intel_excl_states states[2];
	union {
		u16 has_exclusive[2];
		u32 exclusive_present;
	};
	int refcnt;
	unsigned int core_id;
};

struct intel_fb_view {
	struct i915_gtt_view gtt;
	struct i915_color_plane_view color_plane[4];
};

struct intel_plane;

struct intel_fbc_state {
	struct intel_plane *plane;
	unsigned int cfb_stride;
	unsigned int cfb_size;
	unsigned int fence_y_offset;
	u16 override_cfb_stride;
	u16 interval;
	s8 fence_id;
};

struct intel_fbc_funcs;

struct intel_fbc {
	struct intel_display *display;
	const struct intel_fbc_funcs *funcs;
	struct mutex lock;
	unsigned int busy_bits;
	struct drm_mm_node compressed_fb;
	struct drm_mm_node compressed_llb;
	enum intel_fbc_id id;
	u8 limit;
	bool false_color;
	bool active;
	bool activated;
	bool flip_pending;
	bool underrun_detected;
	struct work_struct underrun_work;
	struct intel_fbc_state state;
	const char *no_fbc_reason;
};

struct intel_fbc_funcs {
	void (*activate)(struct intel_fbc *);
	void (*deactivate)(struct intel_fbc *);
	bool (*is_active)(struct intel_fbc *);
	bool (*is_compressing)(struct intel_fbc *);
	void (*nuke)(struct intel_fbc *);
	void (*program_cfb)(struct intel_fbc *);
	void (*set_false_color)(struct intel_fbc *, bool);
};

struct intel_fdi_funcs {
	void (*fdi_link_train)(struct intel_crtc *, const struct intel_crtc_state *);
};

struct intel_forcewake_range {
	u32 start;
	u32 end;
	enum forcewake_domains domains;
};

struct intel_framebuffer {
	struct drm_framebuffer base;
	struct intel_frontbuffer *frontbuffer;
	struct intel_fb_view normal_view;
	union {
		struct intel_fb_view rotated_view;
		struct intel_fb_view remapped_view;
	};
	struct i915_address_space *dpt_vm;
	unsigned int min_alignment;
};

struct intel_frontbuffer {
	struct kref ref;
	atomic_t bits;
	struct i915_active write;
	struct drm_gem_object *obj;
	struct callback_head rcu;
	struct work_struct flush_work;
};

struct intel_fw_info {
	u8 reserved1;
	u8 dmc_id;
	char stepping;
	char substepping;
	u32 offset;
	u32 reserved2;
};

struct intel_global_commit {
	struct kref ref;
	struct completion done;
};

struct intel_global_state_funcs {
	struct intel_global_state * (*atomic_duplicate_state)(struct intel_global_obj *);
	void (*atomic_destroy_state)(struct intel_global_obj *, struct intel_global_state *);
};

struct intel_gmbus {
	struct i2c_adapter adapter;
	u32 force_bit;
	u32 reg0;
	i915_reg_t gpio_reg;
	struct i2c_algo_bit_data bit_algo;
	struct intel_display *display;
};

struct mei_aux_device;

struct intel_gsc_intf {
	struct mei_aux_device *adev;
	struct drm_i915_gem_object *gem_obj;
	int irq;
	unsigned int id;
};

struct intel_gsc {
	struct intel_gsc_intf intf[2];
};

struct intel_gsc_bpdt_entry {
	u32 type;
	u32 sub_partition_offset;
	u32 sub_partition_size;
};

struct intel_gsc_version {
	u16 major;
	u16 minor;
	u16 hotfix;
	u16 build;
};

struct intel_gsc_bpdt_header {
	u32 signature;
	u16 descriptor_count;
	u8 version;
	u8 configuration;
	u32 crc32;
	u32 build_version;
	struct intel_gsc_version tool_version;
};

struct intel_gsc_cpd_entry {
	u8 name[12];
	u32 offset;
	u32 length;
	u8 reserved[4];
};

struct intel_gsc_cpd_header_v2 {
	u32 header_marker;
	u32 num_of_entries;
	u8 header_version;
	u8 entry_version;
	u8 header_length;
	u8 flags;
	u32 partition_name;
	u32 crc32;
};

struct intel_gsc_heci_non_priv_pkt {
	u64 addr_in;
	u32 size_in;
	u64 addr_out;
	u32 size_out;
	struct i915_vma *heci_pkt_vma;
	struct i915_vma *bb_vma;
};

struct intel_gsc_partition {
	u32 offset;
	u32 size;
};

struct intel_gsc_layout_pointers {
	u8 rom_bypass_vector[16];
	u16 size;
	u8 flags;
	u8 reserved;
	u32 crc32;
	struct intel_gsc_partition datap;
	struct intel_gsc_partition boot1;
	struct intel_gsc_partition boot2;
	struct intel_gsc_partition boot3;
	struct intel_gsc_partition boot4;
	struct intel_gsc_partition boot5;
	struct intel_gsc_partition temp_pages;
};

struct intel_gsc_manifest_header {
	u32 header_type;
	u32 header_length;
	u32 header_version;
	u32 flags;
	u32 vendor;
	u32 date;
	u32 size;
	u32 header_id;
	u32 internal_data;
	struct intel_gsc_version fw_version;
	u32 security_version;
	struct intel_gsc_version meu_kit_version;
	u32 meu_manifest_version;
	u8 general_data[4];
	u8 reserved3[56];
	u32 modulus_size;
	u32 exponent_size;
};

struct intel_gsc_mkhi_header {
	u8 group_id;
	u8 command;
	u8 reserved;
	u8 result;
};

struct intel_uc_fw_ver {
	u32 major;
	u32 minor;
	u32 patch;
	u32 build;
};

struct intel_uc_fw_file {
	const char *path;
	struct intel_uc_fw_ver ver;
};

struct intel_uc_fw {
	enum intel_uc_fw_type type;
	union {
		const enum intel_uc_fw_status status;
		enum intel_uc_fw_status __status;
	};
	struct intel_uc_fw_file file_wanted;
	struct intel_uc_fw_file file_selected;
	bool user_overridden;
	size_t size;
	struct drm_i915_gem_object *obj;
	bool needs_ggtt_mapping;
	struct i915_vma_resource vma_res;
	struct i915_vma *rsa_data;
	u32 rsa_size;
	u32 ucode_size;
	u32 private_data_size;
	u32 dma_start_offset;
	bool has_gsc_headers;
};

struct intel_gsc_uc {
	struct intel_uc_fw fw;
	struct intel_uc_fw_ver release;
	u32 security_version;
	struct i915_vma *local;
	void *local_vaddr;
	struct intel_context *ce;
	struct workqueue_struct *wq;
	struct work_struct work;
	u32 gsc_work_actions;
	struct {
		struct i915_gsc_proxy_component *component;
		bool component_added;
		struct i915_vma *vma;
		void *to_gsc;
		void *to_csme;
		struct mutex mutex;
	} proxy;
};

struct intel_guc_log {
	u32 level;
	struct {
		s32 bytes;
		s32 units;
		s32 count;
		u32 flag;
	} sizes[3];
	bool sizes_initialised;
	struct i915_vma *vma;
	void *buf_addr;
	struct {
		bool buf_in_use;
		bool started;
		struct work_struct flush_work;
		struct rchan *channel;
		struct mutex lock;
		u32 full_count;
	} relay;
	struct {
		u32 sampled_overflow;
		u32 overflow;
		u32 flush;
	} stats[3];
};

struct intel_guc_ct_buffer {
	spinlock_t lock;
	struct guc_ct_buffer_desc *desc;
	u32 *cmds;
	u32 size;
	u32 resv_space;
	u32 tail;
	u32 head;
	atomic_t space;
	bool broken;
};

struct intel_guc_ct {
	struct i915_vma *vma;
	bool enabled;
	struct {
		struct intel_guc_ct_buffer send;
		struct intel_guc_ct_buffer recv;
	} ctbs;
	struct tasklet_struct receive_tasklet;
	wait_queue_head_t wq;
	struct {
		u16 last_fence;
		spinlock_t lock;
		struct list_head pending;
		struct list_head incoming;
		struct work_struct worker;
	} requests;
	ktime_t stall_time;
};

struct slpc_shared_data;

struct intel_guc_slpc {
	struct i915_vma *vma;
	struct slpc_shared_data *vaddr;
	bool supported;
	bool selected;
	bool min_is_rpmax;
	u32 min_freq;
	u32 rp0_freq;
	u32 rp1_freq;
	u32 boost_freq;
	u32 min_freq_softlimit;
	u32 max_freq_softlimit;
	bool ignore_eff_freq;
	u32 media_ratio_mode;
	struct mutex lock;
	struct work_struct boost_work;
	atomic_t num_waiters;
	u32 num_boosts;
};

struct intel_guc {
	struct intel_uc_fw fw;
	struct intel_guc_log log;
	struct intel_guc_ct ct;
	struct intel_guc_slpc slpc;
	struct intel_guc_state_capture *capture;
	struct dentry *dbgfs_node;
	struct i915_sched_engine *sched_engine;
	struct i915_request *stalled_request;
	enum {
		STALL_NONE = 0,
		STALL_REGISTER_CONTEXT = 1,
		STALL_MOVE_LRC_TAIL = 2,
		STALL_ADD_REQUEST = 3,
	} submission_stall_reason;
	spinlock_t irq_lock;
	unsigned int msg_enabled_mask;
	atomic_t outstanding_submission_g2h;
	struct xarray tlb_lookup;
	u32 serial_slot;
	u32 next_seqno;
	struct {
		bool enabled;
		void (*reset)(struct intel_guc *);
		void (*enable)(struct intel_guc *);
		void (*disable)(struct intel_guc *);
	} interrupts;
	struct {
		spinlock_t lock;
		struct ida guc_ids;
		int num_guc_ids;
		long unsigned int *guc_ids_bitmap;
		struct list_head guc_id_list;
		unsigned int guc_ids_in_use;
		struct list_head destroyed_contexts;
		struct work_struct destroyed_worker;
		struct work_struct reset_fail_worker;
		intel_engine_mask_t reset_fail_mask;
		unsigned int sched_disable_delay_ms;
		unsigned int sched_disable_gucid_threshold;
	} submission_state;
	bool submission_supported;
	bool submission_selected;
	bool submission_initialized;
	struct intel_uc_fw_ver submission_version;
	bool rc_supported;
	bool rc_selected;
	struct i915_vma *ads_vma;
	struct iosys_map ads_map;
	u32 ads_regset_size;
	u32 ads_regset_count[27];
	struct guc_mmio_reg *ads_regset;
	u32 ads_golden_ctxt_size;
	u32 ads_waklv_size;
	u32 ads_capture_size;
	struct i915_vma *lrc_desc_pool_v69;
	void *lrc_desc_pool_vaddr_v69;
	struct xarray context_lookup;
	u32 params[14];
	struct {
		u32 base;
		unsigned int count;
		enum forcewake_domains fw_domains;
	} send_regs;
	i915_reg_t notify_reg;
	u32 mmio_msg;
	struct mutex send_mutex;
	struct {
		spinlock_t lock;
		u64 gt_stamp;
		long unsigned int ping_delay;
		struct delayed_work work;
		u32 shift;
		long unsigned int last_stat_jiffies;
	} timestamp;
	struct work_struct dead_guc_worker;
	long unsigned int last_dead_guc_jiffies;
};

struct intel_huc {
	struct intel_uc_fw fw;
	struct {
		i915_reg_t reg;
		u32 mask;
		u32 value;
	} status[2];
	struct {
		struct i915_sw_fence fence;
		struct hrtimer timer;
		struct notifier_block nb;
		enum intel_huc_delayed_load_status status;
	} delayed_load;
	struct i915_vma *heci_pkt;
	bool loaded_via_gsc;
};

struct intel_uc_ops;

struct intel_uc {
	const struct intel_uc_ops *ops;
	struct intel_gsc_uc gsc;
	struct intel_guc guc;
	struct intel_huc huc;
	struct drm_i915_gem_object *load_err_log;
	bool reset_in_progress;
	bool fw_table_invalid;
};

struct intel_wopcm {
	u32 size;
	struct {
		u32 base;
		u32 size;
	} guc;
};

struct seqcount_mutex {
	seqcount_t seqcount;
};

typedef struct seqcount_mutex seqcount_mutex_t;

struct intel_gt_timelines {
	spinlock_t lock;
	struct list_head active_list;
};

struct intel_gt_requests {
	struct delayed_work retire_work;
};

struct srcu_data;

struct srcu_usage;

struct srcu_struct {
	unsigned int srcu_idx;
	struct srcu_data *sda;
	struct lockdep_map dep_map;
	struct srcu_usage *srcu_sup;
};

struct intel_reset {
	long unsigned int flags;
	struct mutex mutex;
	wait_queue_head_t queue;
	struct srcu_struct backoff_srcu;
};

struct intel_llc {};

struct intel_rc6 {
	i915_reg_t res_reg[4];
	u64 prev_hw_residency[4];
	u64 cur_residency[4];
	u32 ctl_enable;
	u32 bios_rc_state;
	struct drm_i915_gem_object *pctx;
	bool supported: 1;
	bool enabled: 1;
	bool manual: 1;
	bool wakeref: 1;
	bool bios_state_captured: 1;
};

struct intel_rps_ei {
	ktime_t ktime;
	u32 render_c0;
	u32 media_c0;
};

struct intel_ips {
	u64 last_count1;
	long unsigned int last_time1;
	long unsigned int chipset_power;
	u64 last_count2;
	u64 last_time2;
	long unsigned int gfx_power;
	u8 corr;
	int c;
	int m;
};

struct intel_rps {
	struct mutex lock;
	struct timer_list timer;
	struct work_struct work;
	long unsigned int flags;
	ktime_t pm_timestamp;
	u32 pm_interval;
	u32 pm_iir;
	u32 pm_intrmsk_mbz;
	u32 pm_events;
	u8 cur_freq;
	u8 last_freq;
	u8 min_freq_softlimit;
	u8 max_freq_softlimit;
	u8 max_freq;
	u8 min_freq;
	u8 boost_freq;
	u8 idle_freq;
	u8 efficient_freq;
	u8 rp1_freq;
	u8 rp0_freq;
	u16 gpll_ref_freq;
	int last_adj;
	struct {
		struct mutex mutex;
		enum {
			LOW_POWER = 0,
			BETWEEN = 1,
			HIGH_POWER = 2,
		} mode;
		unsigned int interactive;
		u8 up_threshold;
		u8 down_threshold;
	} power;
	atomic_t num_waiters;
	unsigned int boosts;
	struct intel_rps_ei ei;
	struct intel_ips ips;
};

struct intel_gt_buffer_pool {
	spinlock_t lock;
	struct list_head cache_list[4];
	struct delayed_work work;
};

struct intel_migrate {
	struct intel_context *context;
};

struct sseu_dev_info {
	u8 slice_mask;
	intel_sseu_ss_mask_t subslice_mask;
	intel_sseu_ss_mask_t geometry_subslice_mask;
	intel_sseu_ss_mask_t compute_subslice_mask;
	union {
		u16 hsw[24];
		u16 xehp[64];
	} eu_mask;
	u16 eu_total;
	u8 eu_per_subslice;
	u8 min_eu_in_pool;
	u8 subslice_7eu[3];
	u8 has_slice_pg: 1;
	u8 has_subslice_pg: 1;
	u8 has_eu_pg: 1;
	u8 has_xehp_dss: 1;
	u8 max_slices;
	u8 max_subslices;
	u8 max_eus_per_subslice;
};

struct intel_hwconfig {
	u32 size;
	void *ptr;
};

struct intel_gt_info {
	unsigned int id;
	intel_engine_mask_t engine_mask;
	u32 l3bank_mask;
	u8 num_engines;
	u8 sfc_mask;
	u8 vdbox_sfc_access;
	struct sseu_dev_info sseu;
	long unsigned int mslice_mask;
	struct intel_hwconfig hwconfig;
};

struct intel_mmio_range;

struct intel_gt {
	struct drm_i915_private *i915;
	const char *name;
	enum intel_gt_type type;
	struct intel_uncore *uncore;
	struct i915_ggtt *ggtt;
	struct intel_uc uc;
	struct intel_gsc gsc;
	struct intel_wopcm wopcm;
	struct {
		struct mutex invalidate_lock;
		seqcount_mutex_t seqno;
	} tlb;
	struct i915_wa_list wa_list;
	struct intel_gt_timelines timelines;
	struct intel_gt_requests requests;
	struct {
		struct llist_head list;
		struct work_struct work;
	} watchdog;
	struct intel_wakeref wakeref;
	atomic_t user_wakeref;
	struct list_head closed_vma;
	spinlock_t closed_lock;
	ktime_t last_init_time;
	struct intel_reset reset;
	intel_wakeref_t awake;
	u32 clock_frequency;
	u32 clock_period_ns;
	struct intel_llc llc;
	struct intel_rc6 rc6;
	struct intel_rps rps;
	spinlock_t *irq_lock;
	u32 gt_imr;
	u32 pm_ier;
	u32 pm_imr;
	u32 pm_guc_events;
	struct {
		bool active;
		seqcount_mutex_t lock;
		ktime_t total;
		ktime_t start;
	} stats;
	struct intel_engine_cs *engine[27];
	struct intel_engine_cs *engine_class[54];
	enum intel_submission_method submission_method;
	struct {
		intel_engine_mask_t cslices;
	} ccs;
	struct i915_address_space *vm;
	struct intel_gt_buffer_pool buffer_pool;
	struct i915_vma *scratch;
	struct intel_migrate migrate;
	const struct intel_mmio_range *steering_table[7];
	struct {
		u8 groupid;
		u8 instanceid;
	} default_steering;
	spinlock_t mcr_lock;
	phys_addr_t phys_addr;
	struct intel_gt_info info;
	struct {
		u8 uc_index;
		u8 wb_index;
	} mocs;
	struct kobject sysfs_gt;
	struct gt_defaults defaults;
	struct kobject *sysfs_defaults;
	struct work_struct wedge;
	struct i915_perf_gt perf;
	struct list_head ggtt_link;
};

struct intel_gt_bool_throttle_attr {
	struct attribute attr;
	ssize_t (*show)(struct kobject *, struct kobj_attribute *, char *);
	i915_reg_t (*reg32)(struct intel_gt *);
	u32 mask;
};

struct intel_gt_buffer_pool_node {
	struct i915_active active;
	struct drm_i915_gem_object *obj;
	struct list_head link;
	union {
		struct intel_gt_buffer_pool *pool;
		struct intel_gt_buffer_pool_node *free;
		struct callback_head rcu;
	};
	long unsigned int age;
	enum i915_map_type type;
	u32 pinned;
};

struct intel_uc_coredump;

struct intel_gt_coredump {
	const struct intel_gt *_gt;
	bool awake;
	bool simulated;
	struct intel_gt_info info;
	u32 eir;
	u32 pgtbl_er;
	u32 ier;
	u32 gtier[6];
	u32 ngtier;
	u32 forcewake;
	u32 error;
	u32 err_int;
	u32 fault_data0;
	u32 fault_data1;
	u32 done_reg;
	u32 gac_eco;
	u32 gam_ecochk;
	u32 gab_ctl;
	u32 gfx_mode;
	u32 gtt_cache;
	u32 aux_err;
	u32 gam_done;
	u32 clock_frequency;
	u32 clock_period_ns;
	u32 derrmr;
	u32 sfc_done[4];
	u32 nfence;
	u64 fence[32];
	struct intel_engine_coredump *engine;
	struct intel_uc_coredump *uc;
	struct intel_gt_coredump *next;
};

struct intel_gt_debugfs_file {
	const char *name;
	const struct file_operations *fops;
	bool (*eval)(void *);
};

struct intel_gt_definition {
	enum intel_gt_type type;
	char *name;
	u32 mapping_base;
	u32 gsi_offset;
	intel_engine_mask_t engine_mask;
};

struct intel_gtt_driver {
	unsigned int gen: 8;
	unsigned int is_g33: 1;
	unsigned int is_pineview: 1;
	unsigned int is_ironlake: 1;
	unsigned int has_pgtbl_enable: 1;
	unsigned int dma_mask_size: 8;
	int (*setup)(void);
	void (*cleanup)(void);
	void (*write_entry)(dma_addr_t, unsigned int, unsigned int);
	bool (*check_flags)(unsigned int);
	void (*chipset_flush)(void);
};

struct intel_gtt_driver_description {
	unsigned int gmch_chip_id;
	char *name;
	const struct intel_gtt_driver *gtt_driver;
};

struct intel_guc_state_capture {
	const struct __guc_mmio_reg_descr_group *reglists;
	struct __guc_mmio_reg_descr_group *extlists;
	struct __guc_capture_ads_cache ads_cache[96];
	void *ads_null_cache;
	struct list_head cachelist;
	int max_mmio_per_node;
	struct list_head outlist;
};

struct intel_guc_tlb_wait {
	struct wait_queue_head wq;
	bool busy;
};

struct intel_hdcp_gsc_message {
	struct i915_vma *vma;
	void *hdcp_cmd_in;
	void *hdcp_cmd_out;
};

struct intel_hdcp_shim {
	int (*write_an_aksv)(struct intel_digital_port *, u8 *);
	int (*read_bksv)(struct intel_digital_port *, u8 *);
	int (*read_bstatus)(struct intel_digital_port *, u8 *);
	int (*repeater_present)(struct intel_digital_port *, bool *);
	int (*read_ri_prime)(struct intel_digital_port *, u8 *);
	int (*read_ksv_ready)(struct intel_digital_port *, bool *);
	int (*read_ksv_fifo)(struct intel_digital_port *, int, u8 *);
	int (*read_v_prime_part)(struct intel_digital_port *, int, u32 *);
	int (*toggle_signalling)(struct intel_digital_port *, enum transcoder, bool);
	int (*stream_encryption)(struct intel_connector *, bool);
	bool (*check_link)(struct intel_digital_port *, struct intel_connector *);
	int (*hdcp_get_capability)(struct intel_digital_port *, bool *);
	enum hdcp_wired_protocol protocol;
	int (*hdcp_2_2_get_capability)(struct intel_connector *, bool *);
	int (*write_2_2_msg)(struct intel_connector *, void *, size_t);
	int (*read_2_2_msg)(struct intel_connector *, u8, void *, size_t);
	int (*config_stream_type)(struct intel_connector *, bool, u8);
	int (*stream_2_2_encryption)(struct intel_connector *, bool);
	int (*check_2_2_link)(struct intel_digital_port *, struct intel_connector *);
	int (*get_remote_hdcp_capability)(struct intel_connector *, bool *, bool *);
};

struct intel_hdmi_lpe_audio_port_pdata {
	u8 eld[128];
	int port;
	int pipe;
	int ls_clock;
	bool dp_output;
};

struct intel_hdmi_lpe_audio_pdata {
	struct intel_hdmi_lpe_audio_port_pdata port[3];
	int num_ports;
	int num_pipes;
	void (*notify_audio_lpe)(struct platform_device *, int);
	spinlock_t lpe_audio_slock;
};

struct intel_hotplug_funcs {
	void (*hpd_irq_setup)(struct drm_i915_private *);
	void (*hpd_enable_detection)(struct intel_encoder *);
};

struct intel_initial_plane_config {
	struct intel_framebuffer *fb;
	struct intel_memory_region *mem;
	resource_size_t phys_base;
	struct i915_vma *vma;
	unsigned int tiling;
	int size;
	u32 base;
	u8 rotation;
};

struct iommu_flush {
	void (*flush_context)(struct intel_iommu *, u16, u16, u8, u64);
	void (*flush_iotlb)(struct intel_iommu *, u16, u64, unsigned int, u64);
};

struct root_entry;

struct page_req_dsc;

struct q_inval;

struct iommu_pmu;

struct intel_iommu {
	void *reg;
	u64 reg_phys;
	u64 reg_size;
	u64 cap;
	u64 ecap;
	u64 vccap;
	u64 ecmdcap[4];
	u32 gcmd;
	raw_spinlock_t register_lock;
	int seq_id;
	int agaw;
	int msagaw;
	unsigned int irq;
	unsigned int pr_irq;
	unsigned int perf_irq;
	u16 segment;
	unsigned char name[16];
	long unsigned int *domain_ids;
	long unsigned int *copied_tables;
	spinlock_t lock;
	struct root_entry *root_entry;
	struct iommu_flush flush;
	struct page_req_dsc *prq;
	unsigned char prq_name[16];
	long unsigned int prq_seq_number;
	struct completion prq_complete;
	struct iopf_queue *iopf_queue;
	unsigned char iopfq_name[16];
	struct mutex iopf_lock;
	struct q_inval *qi;
	u32 iommu_state[4];
	struct rb_root device_rbtree;
	spinlock_t device_rbtree_lock;
	struct iommu_device iommu;
	int node;
	u32 flags;
	struct dmar_drhd_unit *drhd;
	void *perf_statistic;
	struct iommu_pmu *pmu;
};

struct intel_limit {
	struct {
		int min;
		int max;
	} dot;
	struct {
		int min;
		int max;
	} vco;
	struct {
		int min;
		int max;
	} n;
	struct {
		int min;
		int max;
	} m;
	struct {
		int min;
		int max;
	} m1;
	struct {
		int min;
		int max;
	} m2;
	struct {
		int min;
		int max;
	} p;
	struct {
		int min;
		int max;
	} p1;
	struct {
		int dot_limit;
		int p2_slow;
		int p2_fast;
	} p2;
};

struct intel_link_bw_limits {
	u8 force_fec_pipes;
	u8 bpp_limit_reached_pipes;
	int max_bpp_x16[4];
};

struct intel_lvds_pps {
	struct intel_pps_delays delays;
	int divider;
	int port;
	bool powerdown_on_reset;
};

struct intel_lvds_encoder {
	struct intel_encoder base;
	bool is_dual_link;
	i915_reg_t reg;
	u32 a3_power;
	struct intel_lvds_pps init_pps;
	u32 init_lvds_val;
	struct intel_connector *attached_connector;
};

struct intel_memory_region_ops;

struct intel_memory_region {
	struct drm_i915_private *i915;
	const struct intel_memory_region_ops *ops;
	struct io_mapping iomap;
	struct resource region;
	struct resource io;
	resource_size_t min_page_size;
	resource_size_t total;
	u16 type;
	u16 instance;
	enum intel_region_id id;
	char name[16];
	char uabi_name[16];
	bool private;
	struct {
		struct mutex lock;
		struct list_head list;
	} objects;
	bool is_range_manager;
	void *region_private;
};

struct intel_memory_region_ops {
	int (*init)(struct intel_memory_region *);
	int (*release)(struct intel_memory_region *);
	int (*init_object)(struct intel_memory_region *, struct drm_i915_gem_object *, resource_size_t, resource_size_t, resource_size_t, unsigned int);
};

struct intel_mmio_range {
	u32 start;
	u32 end;
};

struct intel_modifier_desc {
	u64 modifier;
	struct {
		u8 from;
		u8 until;
	} display_ver;
	const struct drm_format_info *formats;
	int format_count;
	u8 plane_caps;
	struct {
		u8 cc_planes: 3;
		u8 packed_aux_planes: 4;
		char: 1;
		u8 planar_aux_planes: 4;
	} ccs;
};

struct opregion_header;

struct opregion_acpi;

struct opregion_swsci;

struct opregion_asle;

struct opregion_asle_ext;

struct intel_opregion {
	struct intel_display *display;
	struct opregion_header *header;
	struct opregion_acpi *acpi;
	struct opregion_swsci *swsci;
	u32 swsci_gbda_sub_functions;
	u32 swsci_sbcb_sub_functions;
	struct opregion_asle *asle;
	struct opregion_asle_ext *asle_ext;
	void *rvda;
	const void *vbt;
	u32 vbt_size;
	struct work_struct asle_work;
	struct notifier_block acpi_notifier;
};

struct overlay_registers;

struct intel_overlay {
	struct intel_display *display;
	struct intel_context *context;
	struct intel_crtc *crtc;
	struct i915_vma *vma;
	struct i915_vma *old_vma;
	struct intel_frontbuffer *frontbuffer;
	bool active;
	bool pfit_active;
	u32 pfit_vscale_ratio;
	u32 color_key: 24;
	u32 color_key_enabled: 1;
	u32 brightness;
	u32 contrast;
	u32 saturation;
	u32 old_xscale;
	u32 old_yscale;
	struct drm_i915_gem_object *reg_bo;
	struct overlay_registers *regs;
	u32 flip_addr;
	struct i915_active last_flip;
	void (*flip_complete)(struct intel_overlay *);
};

struct overlay_registers {
	u32 OBUF_0Y;
	u32 OBUF_1Y;
	u32 OBUF_0U;
	u32 OBUF_0V;
	u32 OBUF_1U;
	u32 OBUF_1V;
	u32 OSTRIDE;
	u32 YRGB_VPH;
	u32 UV_VPH;
	u32 HORZ_PH;
	u32 INIT_PHS;
	u32 DWINPOS;
	u32 DWINSZ;
	u32 SWIDTH;
	u32 SWIDTHSW;
	u32 SHEIGHT;
	u32 YRGBSCALE;
	u32 UVSCALE;
	u32 OCLRC0;
	u32 OCLRC1;
	u32 DCLRKV;
	u32 DCLRKM;
	u32 SCLRKVH;
	u32 SCLRKVL;
	u32 SCLRKEN;
	u32 OCONFIG;
	u32 OCMD;
	u32 RESERVED1;
	u32 OSTART_0Y;
	u32 OSTART_1Y;
	u32 OSTART_0U;
	u32 OSTART_0V;
	u32 OSTART_1U;
	u32 OSTART_1V;
	u32 OTILEOFF_0Y;
	u32 OTILEOFF_1Y;
	u32 OTILEOFF_0U;
	u32 OTILEOFF_0V;
	u32 OTILEOFF_1U;
	u32 OTILEOFF_1V;
	u32 FASTHSCALE;
	u32 UVSCALEV;
	u32 RESERVEDC[86];
	u16 Y_VCOEFS[51];
	u16 RESERVEDD[77];
	u16 Y_HCOEFS[85];
	u16 RESERVEDE[171];
	u16 UV_VCOEFS[51];
	u16 RESERVEDF[77];
	u16 UV_HCOEFS[51];
	u16 RESERVEDG[77];
};

struct intel_overlay_snapshot {
	struct overlay_registers regs;
	long unsigned int base;
	u32 dovsta;
	u32 isr;
};

struct intel_package_header {
	u8 header_len;
	u8 header_ver;
	u8 reserved[10];
	u32 num_entries;
};

struct intel_panel_bl_funcs {
	int (*setup)(struct intel_connector *, enum pipe);
	u32 (*get)(struct intel_connector *, enum pipe);
	void (*set)(const struct drm_connector_state *, u32);
	void (*disable)(const struct drm_connector_state *, u32);
	void (*enable)(const struct intel_crtc_state *, const struct drm_connector_state *, u32);
	u32 (*hz_to_pwm)(struct intel_connector *, u32);
};

struct intel_plane_state;

struct intel_plane {
	struct drm_plane base;
	enum i9xx_plane_id i9xx_plane;
	enum plane_id id;
	enum pipe pipe;
	bool need_async_flip_toggle_wa;
	u32 frontbuffer_bit;
	struct {
		u32 base;
		u32 cntl;
		u32 size;
	} cursor;
	struct intel_fbc *fbc;
	int (*min_width)(const struct drm_framebuffer *, int, unsigned int);
	int (*max_width)(const struct drm_framebuffer *, int, unsigned int);
	int (*max_height)(const struct drm_framebuffer *, int, unsigned int);
	unsigned int (*min_alignment)(struct intel_plane *, const struct drm_framebuffer *, int);
	unsigned int (*max_stride)(struct intel_plane *, u32, u64, unsigned int);
	void (*update_noarm)(struct intel_dsb *, struct intel_plane *, const struct intel_crtc_state *, const struct intel_plane_state *);
	void (*update_arm)(struct intel_dsb *, struct intel_plane *, const struct intel_crtc_state *, const struct intel_plane_state *);
	void (*disable_arm)(struct intel_dsb *, struct intel_plane *, const struct intel_crtc_state *);
	bool (*get_hw_state)(struct intel_plane *, enum pipe *);
	int (*check_plane)(struct intel_crtc_state *, struct intel_plane_state *);
	int (*min_cdclk)(const struct intel_crtc_state *, const struct intel_plane_state *);
	void (*async_flip)(struct intel_dsb *, struct intel_plane *, const struct intel_crtc_state *, const struct intel_plane_state *, bool);
	void (*enable_flip_done)(struct intel_plane *);
	void (*disable_flip_done)(struct intel_plane *);
};

struct intel_plane_state {
	struct drm_plane_state uapi;
	struct {
		struct drm_crtc *crtc;
		struct drm_framebuffer *fb;
		u16 alpha;
		u16 pixel_blend_mode;
		unsigned int rotation;
		enum drm_color_encoding color_encoding;
		enum drm_color_range color_range;
		enum drm_scaling_filter scaling_filter;
	} hw;
	struct i915_vma *ggtt_vma;
	struct i915_vma *dpt_vma;
	long unsigned int flags;
	struct intel_fb_view view;
	u32 phys_dma_addr;
	struct drm_vblank_work unpin_work;
	bool decrypt;
	bool force_black;
	u32 ctl;
	u32 color_ctl;
	u32 cus_ctl;
	int scaler_id;
	struct intel_plane *planar_linked_plane;
	u32 planar_slave;
	struct drm_intel_sprite_colorkey ckey;
	struct drm_rect psr2_sel_fetch_area;
	u64 ccval;
	const char *no_fbc_reason;
};

struct pmdemand_params {
	u16 qclk_gv_bw;
	u8 voltage_index;
	u8 qclk_gv_index;
	u8 active_pipes;
	u8 active_dbufs;
	u8 active_phys;
	u8 plls;
	u16 cdclk_freq_mhz;
	u16 ddiclk_max;
	u8 scalers;
};

struct intel_pmdemand_state {
	struct intel_global_state base;
	int ddi_clocks[4];
	u16 active_combo_phys_mask;
	struct pmdemand_params params;
};

struct intel_psf_gv_point {
	u8 clk;
};

struct intel_pxp {
	struct intel_gt *ctrl_gt;
	bool platform_cfg_is_bad;
	u32 kcr_base;
	struct gsccs_session_resources gsccs_res;
	struct i915_pxp_component *pxp_component;
	struct device_link *dev_link;
	bool pxp_component_added;
	struct intel_context *ce;
	struct mutex arb_mutex;
	bool arb_is_valid;
	u32 key_instance;
	struct mutex tee_mutex;
	struct {
		struct drm_i915_gem_object *obj;
		void *vaddr;
	} stream_cmd;
	bool hw_state_invalidated;
	bool irq_enabled;
	struct completion termination;
	struct work_struct session_work;
	u32 session_events;
};

struct intel_qgv_point {
	u16 dclk;
	u16 t_rp;
	u16 t_rdpre;
	u16 t_rc;
	u16 t_ras;
	u16 t_rcd;
};

struct intel_qgv_info {
	struct intel_qgv_point points[8];
	struct intel_psf_gv_point psf_points[3];
	u8 num_points;
	u8 num_psf_points;
	u8 t_bl;
	u8 max_numchannels;
	u8 channel_width;
	u8 deinterleave;
};

struct intel_quirk {
	int device;
	int subsystem_vendor;
	int subsystem_device;
	void (*hook)(struct intel_display *);
};

struct intel_renderstate_rodata;

struct intel_renderstate {
	struct i915_gem_ww_ctx ww;
	const struct intel_renderstate_rodata *rodata;
	struct i915_vma *vma;
	u32 batch_offset;
	u32 batch_size;
	u32 aux_offset;
	u32 aux_size;
};

struct intel_renderstate_rodata {
	const u32 *reloc;
	const u32 *batch;
	const u32 batch_items;
};

struct intel_ring {
	struct kref ref;
	struct i915_vma *vma;
	void *vaddr;
	atomic_t pin_count;
	u32 head;
	u32 tail;
	u32 emit;
	u32 space;
	u32 size;
	u32 wrap;
	u32 effective_size;
};

struct intel_rom {
	struct pci_dev *pdev;
	void *oprom;
	struct intel_uncore *uncore;
	loff_t offset;
	size_t size;
	u32 (*read32)(struct intel_rom *, loff_t);
	u16 (*read16)(struct intel_rom *, loff_t);
	void (*read_block)(struct intel_rom *, void *, loff_t, size_t);
	void (*free)(struct intel_rom *);
};

struct intel_rps_freq_caps {
	u8 rp0_freq;
	u8 rp1_freq;
	u8 min_freq;
};

struct intel_sa_info {
	u16 displayrtids;
	u8 deburst;
	u8 deprogbwlimit;
	u8 derating;
};

struct intel_sdvo;

struct intel_sdvo_ddc {
	struct i2c_adapter ddc;
	struct intel_sdvo *sdvo;
	u8 ddc_bus;
};

struct intel_sdvo_caps {
	u8 vendor_id;
	u8 device_id;
	u8 device_rev_id;
	u8 sdvo_version_major;
	u8 sdvo_version_minor;
	unsigned int sdvo_num_inputs: 2;
	unsigned int smooth_scaling: 1;
	unsigned int sharp_scaling: 1;
	unsigned int up_scaling: 1;
	unsigned int down_scaling: 1;
	unsigned int stall_support: 1;
	unsigned int pad: 1;
	u16 output_flags;
};

struct intel_sdvo {
	struct intel_encoder base;
	struct i2c_adapter *i2c;
	u8 target_addr;
	struct intel_sdvo_ddc ddc[3];
	i915_reg_t sdvo_reg;
	struct intel_sdvo_caps caps;
	u8 colorimetry_cap;
	int pixel_clock_min;
	int pixel_clock_max;
	u16 hotplug_active;
	u8 dtd_sdvo_flags;
};

struct intel_sdvo_connector {
	struct intel_connector base;
	u16 output_flag;
	u8 tv_format_supported[19];
	int format_supported_num;
	struct drm_property *tv_format;
	struct drm_property *left;
	struct drm_property *right;
	struct drm_property *top;
	struct drm_property *bottom;
	struct drm_property *hpos;
	struct drm_property *vpos;
	struct drm_property *contrast;
	struct drm_property *saturation;
	struct drm_property *hue;
	struct drm_property *sharpness;
	struct drm_property *flicker_filter;
	struct drm_property *flicker_filter_adaptive;
	struct drm_property *flicker_filter_2d;
	struct drm_property *tv_chroma_filter;
	struct drm_property *tv_luma_filter;
	struct drm_property *dot_crawl;
	struct drm_property *brightness;
	u32 max_hscan;
	u32 max_vscan;
	bool is_hdmi;
};

struct intel_sdvo_connector_state {
	struct intel_digital_connector_state base;
	struct {
		unsigned int overscan_h;
		unsigned int overscan_v;
		unsigned int hpos;
		unsigned int vpos;
		unsigned int sharpness;
		unsigned int flicker_filter;
		unsigned int flicker_filter_2d;
		unsigned int flicker_filter_adaptive;
		unsigned int chroma_filter;
		unsigned int luma_filter;
		unsigned int dot_crawl;
	} tv;
};

struct intel_sdvo_dtd {
	struct {
		u16 clock;
		u8 h_active;
		u8 h_blank;
		u8 h_high;
		u8 v_active;
		u8 v_blank;
		u8 v_high;
	} part1;
	struct {
		u8 h_sync_off;
		u8 h_sync_width;
		u8 v_sync_off_width;
		u8 sync_off_width_high;
		u8 dtd_flags;
		u8 sdvo_flags;
		u8 v_sync_off_high;
		u8 reserved;
	} part2;
};

struct intel_sdvo_encode {
	u8 dvi_rev;
	u8 hdmi_rev;
};

struct intel_sdvo_enhancements_reply {
	unsigned int flicker_filter: 1;
	unsigned int flicker_filter_adaptive: 1;
	unsigned int flicker_filter_2d: 1;
	unsigned int saturation: 1;
	unsigned int hue: 1;
	unsigned int brightness: 1;
	unsigned int contrast: 1;
	unsigned int overscan_h: 1;
	unsigned int overscan_v: 1;
	unsigned int hpos: 1;
	unsigned int vpos: 1;
	unsigned int sharpness: 1;
	unsigned int dot_crawl: 1;
	unsigned int dither: 1;
	unsigned int tv_chroma_filter: 1;
	unsigned int tv_luma_filter: 1;
} __attribute__((packed));

struct intel_sdvo_get_trained_inputs_response {
	unsigned int input0_trained: 1;
	unsigned int input1_trained: 1;
	unsigned int pad: 6;
} __attribute__((packed));

struct intel_sdvo_in_out_map {
	u16 in0;
	u16 in1;
};

struct intel_sdvo_pixel_clock_range {
	u16 min;
	u16 max;
};

struct intel_sdvo_preferred_input_timing_args {
	u16 clock;
	u16 width;
	u16 height;
	u8 interlace: 1;
	u8 scaled: 1;
	u8 pad: 6;
} __attribute__((packed));

struct intel_sdvo_sdtv_resolution_request {
	unsigned int ntsc_m: 1;
	unsigned int ntsc_j: 1;
	unsigned int ntsc_443: 1;
	unsigned int pal_b: 1;
	unsigned int pal_d: 1;
	unsigned int pal_g: 1;
	unsigned int pal_h: 1;
	unsigned int pal_i: 1;
	unsigned int pal_m: 1;
	unsigned int pal_n: 1;
	unsigned int pal_nc: 1;
	unsigned int pal_60: 1;
	unsigned int secam_b: 1;
	unsigned int secam_d: 1;
	unsigned int secam_g: 1;
	unsigned int secam_k: 1;
	unsigned int secam_k1: 1;
	unsigned int secam_l: 1;
	unsigned int secam_60: 1;
	unsigned int pad: 5;
} __attribute__((packed));

struct intel_sdvo_set_target_input_args {
	unsigned int target_1: 1;
	unsigned int pad: 7;
} __attribute__((packed));

struct intel_sdvo_tv_format {
	unsigned int ntsc_m: 1;
	unsigned int ntsc_j: 1;
	unsigned int ntsc_443: 1;
	unsigned int pal_b: 1;
	unsigned int pal_d: 1;
	unsigned int pal_g: 1;
	unsigned int pal_h: 1;
	unsigned int pal_i: 1;
	unsigned int pal_m: 1;
	unsigned int pal_n: 1;
	unsigned int pal_nc: 1;
	unsigned int pal_60: 1;
	unsigned int secam_b: 1;
	unsigned int secam_d: 1;
	unsigned int secam_g: 1;
	unsigned int secam_k: 1;
	unsigned int secam_k1: 1;
	unsigned int secam_l: 1;
	unsigned int secam_60: 1;
	unsigned int hdtv_std_smpte_240m_1080i_59: 1;
	unsigned int hdtv_std_smpte_240m_1080i_60: 1;
	unsigned int hdtv_std_smpte_260m_1080i_59: 1;
	unsigned int hdtv_std_smpte_260m_1080i_60: 1;
	unsigned int hdtv_std_smpte_274m_1080i_50: 1;
	unsigned int hdtv_std_smpte_274m_1080i_59: 1;
	unsigned int hdtv_std_smpte_274m_1080i_60: 1;
	unsigned int hdtv_std_smpte_274m_1080p_23: 1;
	unsigned int hdtv_std_smpte_274m_1080p_24: 1;
	unsigned int hdtv_std_smpte_274m_1080p_25: 1;
	unsigned int hdtv_std_smpte_274m_1080p_29: 1;
	unsigned int hdtv_std_smpte_274m_1080p_30: 1;
	unsigned int hdtv_std_smpte_274m_1080p_50: 1;
	unsigned int hdtv_std_smpte_274m_1080p_59: 1;
	unsigned int hdtv_std_smpte_274m_1080p_60: 1;
	unsigned int hdtv_std_smpte_295m_1080i_50: 1;
	unsigned int hdtv_std_smpte_295m_1080p_50: 1;
	unsigned int hdtv_std_smpte_296m_720p_59: 1;
	unsigned int hdtv_std_smpte_296m_720p_60: 1;
	unsigned int hdtv_std_smpte_296m_720p_50: 1;
	unsigned int hdtv_std_smpte_293m_480p_59: 1;
	unsigned int hdtv_std_smpte_170m_480i_59: 1;
	unsigned int hdtv_std_iturbt601_576i_50: 1;
	unsigned int hdtv_std_iturbt601_576p_50: 1;
	unsigned int hdtv_std_eia_7702a_480i_60: 1;
	unsigned int hdtv_std_eia_7702a_480p_60: 1;
	unsigned int pad: 3;
} __attribute__((packed));

struct intel_shared_dpll_funcs {
	void (*enable)(struct drm_i915_private *, struct intel_shared_dpll *, const struct intel_dpll_hw_state *);
	void (*disable)(struct drm_i915_private *, struct intel_shared_dpll *);
	bool (*get_hw_state)(struct drm_i915_private *, struct intel_shared_dpll *, struct intel_dpll_hw_state *);
	int (*get_freq)(struct drm_i915_private *, const struct intel_shared_dpll *, const struct intel_dpll_hw_state *);
};

struct intel_shared_regs {
	struct er_account regs[7];
	int refcnt;
	unsigned int core_id;
};

struct intel_tc_phy_ops {
	enum intel_display_power_domain (*cold_off_domain)(struct intel_tc_port *);
	u32 (*hpd_live_status)(struct intel_tc_port *);
	bool (*is_ready)(struct intel_tc_port *);
	bool (*is_owned)(struct intel_tc_port *);
	void (*get_hw_state)(struct intel_tc_port *);
	bool (*connect)(struct intel_tc_port *, int);
	void (*disconnect)(struct intel_tc_port *);
	void (*init)(struct intel_tc_port *);
};

struct intel_tc_port {
	struct intel_digital_port *dig_port;
	const struct intel_tc_phy_ops *phy_ops;
	struct mutex lock;
	intel_wakeref_t lock_wakeref;
	struct delayed_work disconnect_phy_work;
	struct delayed_work link_reset_work;
	int link_refcount;
	bool legacy_port: 1;
	const char *port_name;
	enum tc_port_mode mode;
	enum tc_port_mode init_mode;
	enum phy_fia phy_fia;
	u8 phy_fia_idx;
};

struct intel_timeline {
	u64 fence_context;
	u32 seqno;
	struct mutex mutex;
	atomic_t pin_count;
	atomic_t active_count;
	void *hwsp_map;
	const u32 *hwsp_seqno;
	struct i915_vma *hwsp_ggtt;
	u32 hwsp_offset;
	bool has_initial_breadcrumb;
	struct list_head requests;
	struct i915_active_fence last_request;
	struct i915_active active;
	struct intel_timeline *retire;
	struct i915_syncmap *sync;
	struct list_head link;
	struct intel_gt *gt;
	struct list_head engine_link;
	struct kref kref;
	struct callback_head rcu;
};

struct intel_tv {
	struct intel_encoder base;
	int type;
};

struct intel_tv_connector_state {
	struct drm_connector_state base;
	struct {
		u16 top;
		u16 bottom;
	} margins;
	bool bypass_vfilter;
};

struct intel_uc_coredump {
	struct intel_uc_fw guc_fw;
	struct intel_uc_fw huc_fw;
	struct guc_info guc;
};

struct intel_uc_ops {
	int (*sanitize)(struct intel_uc *);
	void (*init_fw)(struct intel_uc *);
	void (*fini_fw)(struct intel_uc *);
	int (*init)(struct intel_uc *);
	void (*fini)(struct intel_uc *);
	int (*init_hw)(struct intel_uc *);
	void (*fini_hw)(struct intel_uc *);
	void (*resume_mappings)(struct intel_uc *);
};

struct intel_uncore_extra_reg {
	raw_spinlock_t lock;
	u64 config;
	u64 config1;
	u64 config2;
	atomic_t ref;
};

struct intel_uncore_pmu;

struct intel_uncore_box {
	int dieid;
	int n_active;
	int n_events;
	int cpu;
	long unsigned int flags;
	atomic_t refcnt;
	struct perf_event *events[10];
	struct perf_event *event_list[10];
	struct event_constraint *event_constraint[10];
	long unsigned int active_mask[1];
	u64 tags[10];
	struct pci_dev *pci_dev;
	struct intel_uncore_pmu *pmu;
	u64 hrtimer_duration;
	struct hrtimer hrtimer;
	struct list_head list;
	struct list_head active_list;
	void *io_addr;
	struct intel_uncore_extra_reg shared_regs[0];
};

struct intel_uncore_discovery_type {
	struct rb_node node;
	enum uncore_access_type access_type;
	struct rb_root units;
	u16 type;
	u8 num_counters;
	u8 counter_width;
	u8 ctl_offset;
	u8 ctr_offset;
	u16 num_units;
};

struct intel_uncore_discovery_unit {
	struct rb_node node;
	unsigned int pmu_idx;
	unsigned int id;
	unsigned int die;
	u64 addr;
};

struct intel_uncore_forcewake_domain {
	struct intel_uncore *uncore;
	enum forcewake_domain_id id;
	enum forcewake_domains mask;
	unsigned int wake_count;
	bool active;
	struct hrtimer timer;
	u32 *reg_set;
	u32 *reg_ack;
};

struct intel_uncore_fw_get {
	void (*force_wake_get)(struct intel_uncore *, enum forcewake_domains);
};

struct intel_uncore_init_fun {
	void (*cpu_init)(void);
	int (*pci_init)(void);
	void (*mmio_init)(void);
	bool use_discovery;
	int *uncore_units_ignore;
};

struct intel_uncore_ops {
	void (*init_box)(struct intel_uncore_box *);
	void (*exit_box)(struct intel_uncore_box *);
	void (*disable_box)(struct intel_uncore_box *);
	void (*enable_box)(struct intel_uncore_box *);
	void (*disable_event)(struct intel_uncore_box *, struct perf_event *);
	void (*enable_event)(struct intel_uncore_box *, struct perf_event *);
	u64 (*read_counter)(struct intel_uncore_box *, struct perf_event *);
	int (*hw_config)(struct intel_uncore_box *, struct perf_event *);
	struct event_constraint * (*get_constraint)(struct intel_uncore_box *, struct perf_event *);
	void (*put_constraint)(struct intel_uncore_box *, struct perf_event *);
};

struct intel_uncore_type;

struct intel_uncore_pmu {
	struct pmu pmu;
	char name[32];
	int pmu_idx;
	bool registered;
	atomic_t activeboxes;
	cpumask_t cpu_mask;
	struct intel_uncore_type *type;
	struct intel_uncore_box **boxes;
};

struct uncore_iio_topology;

struct uncore_upi_topology;

struct intel_uncore_topology {
	int pmu_idx;
	union {
		void *untyped;
		struct uncore_iio_topology *iio;
		struct uncore_upi_topology *upi;
	};
};

struct uncore_event_desc;

struct intel_uncore_type {
	const char *name;
	int num_counters;
	int num_boxes;
	int perf_ctr_bits;
	int fixed_ctr_bits;
	int num_freerunning_types;
	int type_id;
	unsigned int perf_ctr;
	unsigned int event_ctl;
	unsigned int event_mask;
	unsigned int event_mask_ext;
	unsigned int fixed_ctr;
	unsigned int fixed_ctl;
	unsigned int box_ctl;
	union {
		unsigned int msr_offset;
		unsigned int mmio_offset;
	};
	unsigned int mmio_map_size;
	unsigned int num_shared_regs: 8;
	unsigned int single_fixed: 1;
	unsigned int pair_ctr_ctl: 1;
	union {
		u64 *msr_offsets;
		u64 *pci_offsets;
		u64 *mmio_offsets;
	};
	struct event_constraint unconstrainted;
	struct event_constraint *constraints;
	struct intel_uncore_pmu *pmus;
	struct intel_uncore_ops *ops;
	struct uncore_event_desc *event_descs;
	struct freerunning_counters *freerunning;
	const struct attribute_group *attr_groups[4];
	const struct attribute_group **attr_update;
	struct pmu *pmu;
	struct rb_root *boxes;
	struct intel_uncore_topology **topology;
	int (*get_topology)(struct intel_uncore_type *);
	void (*set_mapping)(struct intel_uncore_type *);
	void (*cleanup_mapping)(struct intel_uncore_type *);
	void (*cleanup_extra_boxes)(struct intel_uncore_type *);
};

struct intel_vblank_evade_ctx {
	struct intel_crtc *crtc;
	int min;
	int max;
	int vblank_start;
	bool need_vlv_dsi_wa;
};

struct intel_wakeref_lockclass {
	struct lock_class_key mutex;
	struct lock_class_key work;
};

struct intel_wakeref_ops {
	int (*get)(struct intel_wakeref *);
	int (*put)(struct intel_wakeref *);
};

struct intel_watermark_params {
	u16 fifo_size;
	u16 max_wm;
	u8 default_wm;
	u8 guard_size;
	u8 cacheline_size;
};

struct intel_wedge_me {
	struct delayed_work work;
	struct intel_gt *gt;
	const char *name;
};

struct intel_wm_config {
	unsigned int num_pipes_active;
	bool sprites_enabled;
	bool sprites_scaled;
};

struct intel_wm_funcs {
	void (*update_wm)(struct drm_i915_private *);
	int (*compute_watermarks)(struct intel_atomic_state *, struct intel_crtc *);
	void (*initial_watermarks)(struct intel_atomic_state *, struct intel_crtc *);
	void (*atomic_update_watermarks)(struct intel_atomic_state *, struct intel_crtc *);
	void (*optimize_watermarks)(struct intel_atomic_state *, struct intel_crtc *);
	int (*compute_global_watermarks)(struct intel_atomic_state *);
	void (*get_hw_state)(struct drm_i915_private *);
};

union intel_x86_pebs_dse {
	u64 val;
	struct {
		unsigned int ld_dse: 4;
		unsigned int ld_stlb_miss: 1;
		unsigned int ld_locked: 1;
		unsigned int ld_data_blk: 1;
		unsigned int ld_addr_blk: 1;
		unsigned int ld_reserved: 24;
	};
	struct {
		unsigned int st_l1d_hit: 1;
		unsigned int st_reserved1: 3;
		unsigned int st_stlb_miss: 1;
		unsigned int st_locked: 1;
		unsigned int st_reserved2: 26;
	};
	struct {
		unsigned int st_lat_dse: 4;
		unsigned int st_lat_stlb_miss: 1;
		unsigned int st_lat_locked: 1;
		unsigned int ld_reserved3: 26;
	};
	struct {
		unsigned int mtl_dse: 5;
		unsigned int mtl_locked: 1;
		unsigned int mtl_stlb_miss: 1;
		unsigned int mtl_fwd_blk: 1;
		unsigned int ld_reserved4: 24;
	};
	struct {
		unsigned int lnc_dse: 8;
		unsigned int ld_reserved5: 2;
		unsigned int lnc_stlb_miss: 1;
		unsigned int lnc_locked: 1;
		unsigned int lnc_data_blk: 1;
		unsigned int lnc_addr_blk: 1;
		unsigned int ld_reserved6: 18;
	};
};

struct internal_container {
	struct klist_node node;
	struct attribute_container *cont;
	struct device classdev;
};

struct internal_state {
	int dummy;
};

struct interval {
	uint32_t first;
	uint32_t last;
};

struct io {
	long unsigned int error_bits;
	atomic_t count;
	struct dm_io_client *client;
	io_notify_fn callback;
	void *context;
	void *vma_invalidate_address;
	long unsigned int vma_invalidate_size;
	long: 64;
};

struct io_accept {
	struct file *file;
	struct sockaddr *addr;
	int *addr_len;
	int flags;
	int iou_flags;
	u32 file_slot;
	long unsigned int nofile;
};

struct io_alloc_cache {
	void **entries;
	unsigned int nr_cached;
	unsigned int max_cached;
	unsigned int elem_size;
	unsigned int init_clear;
};

struct io_apic {
	unsigned int index;
	unsigned int unused[3];
	unsigned int data;
	unsigned int unused2[11];
	unsigned int eoi;
};

struct ubuf_info;

struct msghdr {
	void *msg_name;
	int msg_namelen;
	int msg_inq;
	struct iov_iter msg_iter;
	union {
		void *msg_control;
		void *msg_control_user;
	};
	bool msg_control_is_user: 1;
	bool msg_get_inq: 1;
	unsigned int msg_flags;
	__kernel_size_t msg_controllen;
	struct kiocb *msg_iocb;
	struct ubuf_info *msg_ubuf;
	int (*sg_from_iter)(struct sk_buff *, struct iov_iter *, size_t);
};

struct io_async_msghdr {
	struct iovec *free_iov;
	int free_iov_nr;
	union {
		struct {
			int namelen;
			struct iovec fast_iov;
			__kernel_size_t controllen;
			__kernel_size_t payloadlen;
			struct sockaddr *uaddr;
			struct msghdr msg;
			struct __kernel_sockaddr_storage addr;
		};
		struct {
			int namelen;
			struct iovec fast_iov;
			__kernel_size_t controllen;
			__kernel_size_t payloadlen;
			struct sockaddr *uaddr;
			struct msghdr msg;
			struct __kernel_sockaddr_storage addr;
		} clear;
	};
};

struct iov_iter_state {
	size_t iov_offset;
	size_t count;
	long unsigned int nr_segs;
};

struct wait_page_queue {
	struct folio *folio;
	int bit_nr;
	wait_queue_entry_t wait;
};

struct uio_meta {
	uio_meta_flags_t flags;
	u16 app_tag;
	u64 seed;
	struct iov_iter iter;
};

struct io_meta_state {
	u32 seed;
	struct iov_iter_state iter_meta;
};

struct io_async_rw {
	size_t bytes_done;
	struct iovec *free_iovec;
	union {
		struct {
			struct iov_iter iter;
			struct iov_iter_state iter_state;
			struct iovec fast_iov;
			int free_iov_nr;
			union {
				struct wait_page_queue wpq;
				struct {
					struct uio_meta meta;
					struct io_meta_state meta_state;
				};
			};
		};
		struct {
			struct iov_iter iter;
			struct iov_iter_state iter_state;
			struct iovec fast_iov;
			int free_iov_nr;
			union {
				struct wait_page_queue wpq;
				struct {
					struct uio_meta meta;
					struct io_meta_state meta_state;
				};
			};
		} clear;
	};
};

struct io_bind {
	struct file *file;
	int addr_len;
};

struct io_bitmap {
	u64 sequence;
	refcount_t refcnt;
	unsigned int max;
	long unsigned int bitmap[1024];
};

struct io_buffer {
	struct list_head list;
	__u64 addr;
	__u32 len;
	__u16 bid;
	__u16 bgid;
};

struct io_mapped_region {
	struct page **pages;
	void *ptr;
	unsigned int nr_pages;
	unsigned int flags;
};

struct io_uring_buf_ring;

struct io_buffer_list {
	union {
		struct list_head buf_list;
		struct io_uring_buf_ring *buf_ring;
	};
	__u16 bgid;
	__u16 buf_nr_pages;
	__u16 nr_entries;
	__u16 head;
	__u16 mask;
	__u16 flags;
	struct io_mapped_region region;
};

struct io_cancel {
	struct file *file;
	u64 addr;
	u32 flags;
	s32 fd;
	u8 opcode;
};

struct io_ring_ctx;

struct io_cancel_data {
	struct io_ring_ctx *ctx;
	union {
		u64 data;
		struct file *file;
	};
	u8 opcode;
	u32 flags;
	int seq;
};

struct io_wq_work;

typedef bool work_cancel_fn(struct io_wq_work *, void *);

struct io_cb_cancel_data {
	work_cancel_fn *fn;
	void *data;
	int nr_running;
	int nr_pending;
	bool cancel_all;
};

struct io_close {
	struct file *file;
	int fd;
	u32 file_slot;
};

struct io_cmd_data {
	struct file *file;
	__u8 data[56];
};

struct io_kiocb;

struct io_cold_def {
	const char *name;
	void (*cleanup)(struct io_kiocb *);
	void (*fail)(struct io_kiocb *);
};

struct io_comp_batch {
	struct rq_list req_list;
	bool need_ts;
	void (*complete)(struct io_comp_batch *);
};

struct io_connect {
	struct file *file;
	struct sockaddr *addr;
	int addr_len;
	bool in_progress;
	bool seen_econnaborted;
};

struct io_context {
	atomic_long_t refcount;
	atomic_t active_ref;
	short unsigned int ioprio;
};

struct io_cq {
	struct request_queue *q;
	struct io_context *ioc;
	union {
		struct list_head q_node;
		struct kmem_cache *__rcu_icq_cache;
	};
	union {
		struct hlist_node ioc_node;
		struct callback_head __rcu_head;
	};
	unsigned int flags;
};

struct io_cqe {
	__u64 user_data;
	__s32 res;
	union {
		__u32 flags;
		int fd;
	};
};

struct io_cqring_offsets {
	__u32 head;
	__u32 tail;
	__u32 ring_mask;
	__u32 ring_entries;
	__u32 overflow;
	__u32 cqes;
	__u32 flags;
	__u32 resv1;
	__u64 user_addr;
};

struct io_defer_entry {
	struct list_head list;
	struct io_kiocb *req;
	u32 seq;
};

struct io_epoll {
	struct file *file;
	int epfd;
	int op;
	int fd;
	struct epoll_event event;
};

struct io_err_c {
	struct dm_dev *dev;
	sector_t start;
};

struct io_ev_fd {
	struct eventfd_ctx *cq_ev_fd;
	unsigned int eventfd_async;
	unsigned int last_cq_tail;
	refcount_t refs;
	atomic_t ops;
	struct callback_head rcu;
};

struct io_fadvise {
	struct file *file;
	u64 offset;
	u64 len;
	u32 advice;
};

struct io_rsrc_node;

struct io_rsrc_data {
	unsigned int nr;
	struct io_rsrc_node **nodes;
};

struct io_file_table {
	struct io_rsrc_data data;
	long unsigned int *bitmap;
	unsigned int alloc_hint;
};

struct io_fixed_install {
	struct file *file;
	unsigned int o_flags;
};

struct io_ftrunc {
	struct file *file;
	loff_t len;
};

struct io_futex {
	struct file *file;
	union {
		u32 *uaddr;
		struct futex_waitv *uwaitv;
	};
	long unsigned int futex_val;
	long unsigned int futex_mask;
	long unsigned int futexv_owned;
	u32 futex_flags;
	unsigned int futex_nr;
	bool futexv_unqueued;
};

struct io_futex_data {
	struct futex_q q;
	struct io_kiocb *req;
};

struct io_hash_bucket {
	struct hlist_head list;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct io_hash_table {
	struct io_hash_bucket *hbs;
	unsigned int hash_bits;
};

struct io_imu_folio_data {
	unsigned int nr_pages_head;
	unsigned int nr_pages_mid;
	unsigned int folio_shift;
	unsigned int nr_folios;
};

struct io_uring_sqe;

struct io_issue_def {
	unsigned int needs_file: 1;
	unsigned int plug: 1;
	unsigned int hash_reg_file: 1;
	unsigned int unbound_nonreg_file: 1;
	unsigned int pollin: 1;
	unsigned int pollout: 1;
	unsigned int poll_exclusive: 1;
	unsigned int buffer_select: 1;
	unsigned int audit_skip: 1;
	unsigned int ioprio: 1;
	unsigned int iopoll: 1;
	unsigned int iopoll_queue: 1;
	unsigned int vectored: 1;
	short unsigned int async_size;
	int (*issue)(struct io_kiocb *, unsigned int);
	int (*prep)(struct io_kiocb *, const struct io_uring_sqe *);
};

struct io_wq_work_node {
	struct io_wq_work_node *next;
};

struct io_tw_state;

typedef void (*io_req_tw_func_t)(struct io_kiocb *, struct io_tw_state *);

struct io_task_work {
	struct llist_node node;
	io_req_tw_func_t func;
};

struct io_wq_work {
	struct io_wq_work_node list;
	atomic_t flags;
	int cancel_seq;
};

struct io_uring_task;

struct io_kiocb {
	union {
		struct file *file;
		struct io_cmd_data cmd;
	};
	u8 opcode;
	u8 iopoll_completed;
	u16 buf_index;
	unsigned int nr_tw;
	io_req_flags_t flags;
	struct io_cqe cqe;
	struct io_ring_ctx *ctx;
	struct io_uring_task *tctx;
	union {
		struct io_buffer *kbuf;
		struct io_buffer_list *buf_list;
		struct io_rsrc_node *buf_node;
	};
	union {
		struct io_wq_work_node comp_list;
		__poll_t apoll_events;
	};
	struct io_rsrc_node *file_node;
	atomic_t refs;
	bool cancel_seq_set;
	struct io_task_work io_task_work;
	union {
		struct hlist_node hash_node;
		u64 iopoll_start;
	};
	struct async_poll *apoll;
	void *async_data;
	atomic_t poll_refs;
	struct io_kiocb *link;
	const struct cred *creds;
	struct io_wq_work work;
	struct {
		u64 extra1;
		u64 extra2;
	} big_cqe;
};

struct io_link {
	struct file *file;
	int old_dfd;
	int new_dfd;
	struct filename *oldpath;
	struct filename *newpath;
	int flags;
};

struct io_listen {
	struct file *file;
	int backlog;
};

struct io_madvise {
	struct file *file;
	u64 addr;
	u64 len;
	u32 advice;
};

struct io_mapped_ubuf {
	u64 ubuf;
	unsigned int len;
	unsigned int nr_bvecs;
	unsigned int folio_shift;
	refcount_t refs;
	long unsigned int acct_pages;
	struct bio_vec bvec[0];
};

struct io_mkdir {
	struct file *file;
	int dfd;
	umode_t mode;
	struct filename *filename;
};

struct io_msg {
	struct file *file;
	struct file *src_file;
	struct callback_head tw;
	u64 user_data;
	u32 len;
	u32 cmd;
	u32 src_fd;
	union {
		u32 dst_fd;
		u32 cqe_flags;
	};
	u32 flags;
};

struct io_napi_entry {
	unsigned int napi_id;
	struct list_head list;
	long unsigned int timeout;
	struct hlist_node node;
	struct callback_head rcu;
};

struct io_nop {
	struct file *file;
	int result;
	int fd;
	int buffer;
	unsigned int flags;
};

struct ubuf_info_ops;

struct ubuf_info {
	const struct ubuf_info_ops *ops;
	refcount_t refcnt;
	u8 flags;
};

struct io_notif_data {
	struct file *file;
	struct ubuf_info uarg;
	struct io_notif_data *next;
	struct io_notif_data *head;
	unsigned int account_pages;
	bool zc_report;
	bool zc_used;
	bool zc_copied;
};

struct io_open {
	struct file *file;
	int dfd;
	u32 file_slot;
	struct filename *filename;
	struct open_how how;
	long unsigned int nofile;
};

struct io_uring_cqe {
	__u64 user_data;
	__s32 res;
	__u32 flags;
	__u64 big_cqe[0];
};

struct io_overflow_cqe {
	struct list_head list;
	struct io_uring_cqe cqe;
};

struct io_pgtable_init_fns {
	struct io_pgtable * (*alloc)(struct io_pgtable_cfg *, void *);
	void (*free)(struct io_pgtable *);
	u32 caps;
};

struct io_poll_table {
	struct poll_table_struct pt;
	struct io_kiocb *req;
	int nr_entries;
	int error;
	bool owning;
	__poll_t result_mask;
};

struct io_poll_update {
	struct file *file;
	u64 old_user_data;
	u64 new_user_data;
	__poll_t events;
	bool update_events;
	bool update_user_data;
};

struct io_provide_buf {
	struct file *file;
	__u64 addr;
	__u32 len;
	__u32 bgid;
	__u32 nbufs;
	__u16 bid;
};

struct io_uring_recvmsg_out {
	__u32 namelen;
	__u32 controllen;
	__u32 payloadlen;
	__u32 flags;
};

struct io_recvmsg_multishot_hdr {
	struct io_uring_recvmsg_out msg;
	struct __kernel_sockaddr_storage addr;
};

struct io_rename {
	struct file *file;
	int old_dfd;
	int new_dfd;
	struct filename *oldpath;
	struct filename *newpath;
	int flags;
};

struct io_restriction {
	long unsigned int register_op[1];
	long unsigned int sqe_op[1];
	u8 sqe_flags_allowed;
	u8 sqe_flags_required;
	bool registered;
};

struct io_wq_work_list {
	struct io_wq_work_node *first;
	struct io_wq_work_node *last;
};

struct io_submit_link {
	struct io_kiocb *head;
	struct io_kiocb *last;
};

struct io_submit_state {
	struct io_wq_work_node free_list;
	struct io_wq_work_list compl_reqs;
	struct io_submit_link link;
	bool plug_started;
	bool need_plug;
	bool cq_flush;
	short unsigned int submit_nr;
	struct blk_plug plug;
};

struct io_rings;

struct io_sq_data;

struct io_wq_hash;

struct io_ring_ctx {
	struct {
		unsigned int flags;
		unsigned int drain_next: 1;
		unsigned int restricted: 1;
		unsigned int off_timeout_used: 1;
		unsigned int drain_active: 1;
		unsigned int has_evfd: 1;
		unsigned int task_complete: 1;
		unsigned int lockless_cq: 1;
		unsigned int syscall_iopoll: 1;
		unsigned int poll_activated: 1;
		unsigned int drain_disabled: 1;
		unsigned int compat: 1;
		unsigned int iowq_limits_set: 1;
		struct task_struct *submitter_task;
		struct io_rings *rings;
		struct percpu_ref refs;
		clockid_t clockid;
		enum tk_offsets clock_offset;
		enum task_work_notify_mode notify_method;
		unsigned int sq_thread_idle;
		long: 64;
	};
	struct {
		struct mutex uring_lock;
		u32 *sq_array;
		struct io_uring_sqe *sq_sqes;
		unsigned int cached_sq_head;
		unsigned int sq_entries;
		atomic_t cancel_seq;
		bool poll_multi_queue;
		struct io_wq_work_list iopoll_list;
		struct io_file_table file_table;
		struct io_rsrc_data buf_table;
		struct io_submit_state submit_state;
		struct xarray io_bl_xa;
		struct io_hash_table cancel_table;
		struct io_alloc_cache apoll_cache;
		struct io_alloc_cache netmsg_cache;
		struct io_alloc_cache rw_cache;
		struct io_alloc_cache uring_cache;
		struct hlist_head cancelable_uring_cmd;
		u64 hybrid_poll_time;
	};
	struct {
		struct io_uring_cqe *cqe_cached;
		struct io_uring_cqe *cqe_sentinel;
		unsigned int cached_cq_tail;
		unsigned int cq_entries;
		struct io_ev_fd *io_ev_fd;
		unsigned int cq_extra;
		void *cq_wait_arg;
		size_t cq_wait_size;
		long: 64;
	};
	struct {
		struct llist_head work_llist;
		struct llist_head retry_llist;
		long unsigned int check_cq;
		atomic_t cq_wait_nr;
		atomic_t cq_timeouts;
		struct wait_queue_head cq_wait;
		long: 64;
	};
	struct {
		raw_spinlock_t timeout_lock;
		struct list_head timeout_list;
		struct list_head ltimeout_list;
		unsigned int cq_last_tm_flush;
		long: 64;
		long: 64;
	};
	spinlock_t completion_lock;
	struct list_head io_buffers_comp;
	struct list_head cq_overflow_list;
	struct hlist_head waitid_list;
	struct hlist_head futex_list;
	struct io_alloc_cache futex_cache;
	const struct cred *sq_creds;
	struct io_sq_data *sq_data;
	struct wait_queue_head sqo_sq_wait;
	struct list_head sqd_list;
	unsigned int file_alloc_start;
	unsigned int file_alloc_end;
	struct list_head io_buffers_cache;
	struct wait_queue_head poll_wq;
	struct io_restriction restrictions;
	u32 pers_next;
	struct xarray personalities;
	struct io_wq_hash *hash_map;
	struct user_struct *user;
	struct mm_struct *mm_account;
	struct llist_head fallback_llist;
	struct delayed_work fallback_work;
	struct work_struct exit_work;
	struct list_head tctx_list;
	struct completion ref_comp;
	u32 iowq_limits[2];
	struct callback_head poll_wq_task_work;
	struct list_head defer_list;
	struct io_alloc_cache msg_cache;
	spinlock_t msg_lock;
	struct list_head napi_list;
	spinlock_t napi_lock;
	ktime_t napi_busy_poll_dt;
	bool napi_prefer_busy_poll;
	u8 napi_track_mode;
	struct hlist_head napi_ht[16];
	unsigned int evfd_last_cq_tail;
	struct mutex mmap_lock;
	struct io_mapped_region sq_region;
	struct io_mapped_region ring_region;
	struct io_mapped_region param_region;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct io_ring_ctx_rings {
	struct io_rings *rings;
	struct io_uring_sqe *sq_sqes;
	struct io_mapped_region sq_region;
	struct io_mapped_region ring_region;
};

struct io_uring {
	u32 head;
	u32 tail;
};

struct io_rings {
	struct io_uring sq;
	struct io_uring cq;
	u32 sq_ring_mask;
	u32 cq_ring_mask;
	u32 sq_ring_entries;
	u32 cq_ring_entries;
	u32 sq_dropped;
	atomic_t sq_flags;
	u32 cq_flags;
	u32 cq_overflow;
	long: 64;
	long: 64;
	struct io_uring_cqe cqes[0];
};

struct io_rsrc_node {
	unsigned char type;
	int refs;
	u64 tag;
	union {
		long unsigned int file_ptr;
		struct io_mapped_ubuf *buf;
	};
};

struct io_rsrc_update {
	struct file *file;
	u64 arg;
	u32 nr_args;
	u32 offset;
};

struct io_rw {
	struct kiocb kiocb;
	u64 addr;
	u32 len;
	rwf_t flags;
};

struct io_shutdown {
	struct file *file;
	int how;
};

struct io_socket {
	struct file *file;
	int domain;
	int type;
	int protocol;
	int flags;
	u32 file_slot;
	long unsigned int nofile;
};

struct io_splice {
	struct file *file_out;
	loff_t off_out;
	loff_t off_in;
	u64 len;
	int splice_fd_in;
	unsigned int flags;
	struct io_rsrc_node *rsrc_node;
};

struct io_sq_data {
	refcount_t refs;
	atomic_t park_pending;
	struct mutex lock;
	struct list_head ctx_list;
	struct task_struct *thread;
	struct wait_queue_head wait;
	unsigned int sq_thread_idle;
	int sq_cpu;
	pid_t task_pid;
	pid_t task_tgid;
	u64 work_time;
	long unsigned int state;
	struct completion exited;
};

struct io_sqring_offsets {
	__u32 head;
	__u32 tail;
	__u32 ring_mask;
	__u32 ring_entries;
	__u32 flags;
	__u32 dropped;
	__u32 array;
	__u32 resv1;
	__u64 user_addr;
};

struct user_msghdr;

struct io_sr_msg {
	struct file *file;
	union {
		struct compat_msghdr *umsg_compat;
		struct user_msghdr *umsg;
		void *buf;
	};
	int len;
	unsigned int done_io;
	unsigned int msg_flags;
	unsigned int nr_multishot_loops;
	u16 flags;
	u16 buf_group;
	u16 buf_index;
	void *msg_control;
	struct io_kiocb *notif;
};

struct statx;

struct io_statx {
	struct file *file;
	int dfd;
	unsigned int mask;
	unsigned int flags;
	struct filename *filename;
	struct statx *buffer;
};

struct io_sync {
	struct file *file;
	loff_t len;
	loff_t off;
	int flags;
	int mode;
};

struct io_task_cancel {
	struct io_uring_task *tctx;
	bool all;
};

struct io_tctx_exit {
	struct callback_head task_work;
	struct completion completion;
	struct io_ring_ctx *ctx;
};

struct io_tctx_node {
	struct list_head ctx_node;
	struct task_struct *task;
	struct io_ring_ctx *ctx;
};

struct io_timeout {
	struct file *file;
	u32 off;
	u32 target_seq;
	u32 repeats;
	struct list_head list;
	struct io_kiocb *head;
	struct io_kiocb *prev;
};

struct io_timeout_data {
	struct io_kiocb *req;
	struct hrtimer timer;
	struct timespec64 ts;
	enum hrtimer_mode mode;
	u32 flags;
};

struct io_timeout_rem {
	struct file *file;
	u64 addr;
	struct timespec64 ts;
	u32 flags;
	bool ltimeout;
};

struct io_tlb_area {
	long unsigned int used;
	unsigned int index;
	spinlock_t lock;
};

struct io_tlb_slot;

struct io_tlb_pool {
	phys_addr_t start;
	phys_addr_t end;
	void *vaddr;
	long unsigned int nslabs;
	bool late_alloc;
	unsigned int nareas;
	unsigned int area_nslabs;
	struct io_tlb_area *areas;
	struct io_tlb_slot *slots;
};

struct io_tlb_mem {
	struct io_tlb_pool defpool;
	long unsigned int nslabs;
	struct dentry *debugfs;
	bool force_bounce;
	bool for_alloc;
	atomic_long_t total_used;
	atomic_long_t used_hiwater;
	atomic_long_t transient_nslabs;
};

struct io_tlb_slot {
	phys_addr_t orig_addr;
	size_t alloc_size;
	short unsigned int list;
	short unsigned int pad_slots;
};

struct io_tw_state {};

struct io_unlink {
	struct file *file;
	int dfd;
	int flags;
	struct filename *filename;
};

struct io_uring_attr_pi {
	__u16 flags;
	__u16 app_tag;
	__u32 len;
	__u64 addr;
	__u64 seed;
	__u64 rsvd;
};

struct io_uring_buf {
	__u64 addr;
	__u32 len;
	__u16 bid;
	__u16 resv;
};

struct io_uring_buf_reg {
	__u64 ring_addr;
	__u32 ring_entries;
	__u16 bgid;
	__u16 flags;
	__u64 resv[3];
};

struct io_uring_buf_ring {
	union {
		struct {
			__u64 resv1;
			__u32 resv2;
			__u16 resv3;
			__u16 tail;
		};
		struct {
			struct {} __empty_bufs;
			struct io_uring_buf bufs[0];
		};
	};
};

struct io_uring_buf_status {
	__u32 buf_group;
	__u32 head;
	__u32 resv[8];
};

struct io_uring_clock_register {
	__u32 clockid;
	__u32 __resv[3];
};

struct io_uring_clone_buffers {
	__u32 src_fd;
	__u32 flags;
	__u32 src_off;
	__u32 dst_off;
	__u32 nr;
	__u32 pad[3];
};

struct io_uring_cmd {
	struct file *file;
	const struct io_uring_sqe *sqe;
	void (*task_work_cb)(struct io_uring_cmd *, unsigned int);
	u32 cmd_op;
	u32 flags;
	u8 pdu[32];
};

struct io_uring_sqe {
	__u8 opcode;
	__u8 flags;
	__u16 ioprio;
	__s32 fd;
	union {
		__u64 off;
		__u64 addr2;
		struct {
			__u32 cmd_op;
			__u32 __pad1;
		};
	};
	union {
		__u64 addr;
		__u64 splice_off_in;
		struct {
			__u32 level;
			__u32 optname;
		};
	};
	__u32 len;
	union {
		__kernel_rwf_t rw_flags;
		__u32 fsync_flags;
		__u16 poll_events;
		__u32 poll32_events;
		__u32 sync_range_flags;
		__u32 msg_flags;
		__u32 timeout_flags;
		__u32 accept_flags;
		__u32 cancel_flags;
		__u32 open_flags;
		__u32 statx_flags;
		__u32 fadvise_advice;
		__u32 splice_flags;
		__u32 rename_flags;
		__u32 unlink_flags;
		__u32 hardlink_flags;
		__u32 xattr_flags;
		__u32 msg_ring_flags;
		__u32 uring_cmd_flags;
		__u32 waitid_flags;
		__u32 futex_flags;
		__u32 install_fd_flags;
		__u32 nop_flags;
	};
	__u64 user_data;
	union {
		__u16 buf_index;
		__u16 buf_group;
	};
	__u16 personality;
	union {
		__s32 splice_fd_in;
		__u32 file_index;
		__u32 optlen;
		struct {
			__u16 addr_len;
			__u16 __pad3[1];
		};
	};
	union {
		struct {
			__u64 addr3;
			__u64 __pad2[1];
		};
		struct {
			__u64 attr_ptr;
			__u64 attr_type_mask;
		};
		__u64 optval;
		__u8 cmd[0];
	};
};

struct io_uring_cmd_data {
	void *op_data;
	struct io_uring_sqe sqes[2];
};

struct io_uring_file_index_range {
	__u32 off;
	__u32 len;
	__u64 resv;
};

struct io_uring_getevents_arg {
	__u64 sigmask;
	__u32 sigmask_sz;
	__u32 min_wait_usec;
	__u64 ts;
};

struct io_uring_mem_region_reg {
	__u64 region_uptr;
	__u64 flags;
	__u64 __resv[2];
};

struct io_uring_napi {
	__u32 busy_poll_to;
	__u8 prefer_busy_poll;
	__u8 opcode;
	__u8 pad[2];
	__u32 op_param;
	__u32 resv;
};

struct io_uring_params {
	__u32 sq_entries;
	__u32 cq_entries;
	__u32 flags;
	__u32 sq_thread_cpu;
	__u32 sq_thread_idle;
	__u32 features;
	__u32 wq_fd;
	__u32 resv[3];
	struct io_sqring_offsets sq_off;
	struct io_cqring_offsets cq_off;
};

struct io_uring_probe_op {
	__u8 op;
	__u8 resv;
	__u16 flags;
	__u32 resv2;
};

struct io_uring_probe {
	__u8 last_op;
	__u8 ops_len;
	__u16 resv;
	__u32 resv2[3];
	struct io_uring_probe_op ops[0];
};

struct io_uring_reg_wait {
	struct __kernel_timespec ts;
	__u32 min_wait_usec;
	__u32 flags;
	__u64 sigmask;
	__u32 sigmask_sz;
	__u32 pad[3];
	__u64 pad2[2];
};

struct io_uring_region_desc {
	__u64 user_addr;
	__u64 size;
	__u32 flags;
	__u32 id;
	__u64 mmap_offset;
	__u64 __resv[4];
};

struct io_uring_restriction {
	__u16 opcode;
	union {
		__u8 register_op;
		__u8 sqe_op;
		__u8 sqe_flags;
	};
	__u8 resv;
	__u32 resv2[3];
};

struct io_uring_rsrc_register {
	__u32 nr;
	__u32 flags;
	__u64 resv2;
	__u64 data;
	__u64 tags;
};

struct io_uring_rsrc_update {
	__u32 offset;
	__u32 resv;
	__u64 data;
};

struct io_uring_rsrc_update2 {
	__u32 offset;
	__u32 resv;
	__u64 data;
	__u64 tags;
	__u32 nr;
	__u32 resv2;
};

struct io_uring_sync_cancel_reg {
	__u64 addr;
	__s32 fd;
	__u32 flags;
	struct __kernel_timespec timeout;
	__u8 opcode;
	__u8 pad[7];
	__u64 pad2[3];
};

struct io_wq;

struct io_uring_task {
	int cached_refs;
	const struct io_ring_ctx *last;
	struct task_struct *task;
	struct io_wq *io_wq;
	struct file *registered_rings[16];
	struct xarray xa;
	struct wait_queue_head wait;
	atomic_t in_cancel;
	atomic_t inflight_tracked;
	struct percpu_counter inflight;
	long: 64;
	struct {
		struct llist_head task_list;
		struct callback_head task_work;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
	};
};

struct io_wait_queue {
	struct wait_queue_entry wq;
	struct io_ring_ctx *ctx;
	unsigned int cq_tail;
	unsigned int cq_min_tail;
	unsigned int nr_timeouts;
	int hit_timeout;
	ktime_t min_timeout;
	ktime_t timeout;
	struct hrtimer t;
	ktime_t napi_busy_poll_dt;
	bool napi_prefer_busy_poll;
};

struct waitid_info {
	pid_t pid;
	uid_t uid;
	int status;
	int cause;
};

struct io_waitid {
	struct file *file;
	int which;
	pid_t upid;
	int options;
	atomic_t refs;
	struct wait_queue_head *head;
	struct siginfo *infop;
	struct waitid_info info;
};

struct rusage;

struct wait_opts {
	enum pid_type wo_type;
	int wo_flags;
	struct pid *wo_pid;
	struct waitid_info *wo_info;
	int wo_stat;
	struct rusage *wo_rusage;
	wait_queue_entry_t child_wait;
	int notask_error;
};

struct io_waitid_async {
	struct io_kiocb *req;
	struct wait_opts wo;
};

struct io_window_t {
	u_int InUse;
	u_int Config;
	struct resource *res;
};

typedef struct io_window_t io_window_t;

struct io_worker {
	refcount_t ref;
	int create_index;
	long unsigned int flags;
	struct hlist_nulls_node nulls_node;
	struct list_head all_list;
	struct task_struct *task;
	struct io_wq *wq;
	struct io_wq_work *cur_work;
	raw_spinlock_t lock;
	struct completion ref_done;
	long unsigned int create_state;
	struct callback_head create_work;
	int init_retries;
	union {
		struct callback_head rcu;
		struct delayed_work work;
	};
};

typedef struct io_wq_work *free_work_fn(struct io_wq_work *);

typedef void io_wq_work_fn(struct io_wq_work *);

struct io_wq_acct {
	unsigned int nr_workers;
	unsigned int max_workers;
	int index;
	atomic_t nr_running;
	raw_spinlock_t lock;
	struct io_wq_work_list work_list;
	long unsigned int flags;
};

struct io_wq {
	long unsigned int state;
	free_work_fn *free_work;
	io_wq_work_fn *do_work;
	struct io_wq_hash *hash;
	atomic_t worker_refs;
	struct completion worker_done;
	struct hlist_node cpuhp_node;
	struct task_struct *task;
	struct io_wq_acct acct[2];
	raw_spinlock_t lock;
	struct hlist_nulls_head free_list;
	struct list_head all_list;
	struct wait_queue_entry wait;
	struct io_wq_work *hash_tail[64];
	cpumask_var_t cpu_mask;
};

struct io_wq_data {
	struct io_wq_hash *hash;
	struct task_struct *task;
	io_wq_work_fn *do_work;
	free_work_fn *free_work;
};

struct io_wq_hash {
	refcount_t refs;
	long unsigned int map;
	struct wait_queue_head wait;
};

struct xattr_name;

struct kernel_xattr_ctx {
	union {
		const void *cvalue;
		void *value;
	};
	void *kvalue;
	size_t size;
	struct xattr_name *kname;
	unsigned int flags;
};

struct io_xattr {
	struct file *file;
	struct kernel_xattr_ctx ctx;
	struct filename *filename;
};

struct ioam6_hdr {
	__u8 opt_type;
	__u8 opt_len;
	char: 8;
	__u8 type;
};

struct ioam6_schema;

struct ioam6_namespace {
	struct rhash_head head;
	struct callback_head rcu;
	struct ioam6_schema *schema;
	__be16 id;
	__be32 data;
	__be64 data_wide;
};

struct ioam6_pernet_data {
	struct mutex lock;
	struct rhashtable namespaces;
	struct rhashtable schemas;
};

struct ioam6_schema {
	struct rhash_head head;
	struct callback_head rcu;
	struct ioam6_namespace *ns;
	u32 id;
	int len;
	__be32 hdr;
	u8 data[0];
};

struct ioam6_trace_hdr {
	__be16 namespace_id;
	char: 2;
	__u8 overflow: 1;
	__u8 nodelen: 5;
	__u8 remlen: 7;
	union {
		__be32 type_be32;
		struct {
			__u32 bit7: 1;
			__u32 bit6: 1;
			__u32 bit5: 1;
			__u32 bit4: 1;
			__u32 bit3: 1;
			__u32 bit2: 1;
			__u32 bit1: 1;
			__u32 bit0: 1;
			__u32 bit15: 1;
			__u32 bit14: 1;
			__u32 bit13: 1;
			__u32 bit12: 1;
			__u32 bit11: 1;
			__u32 bit10: 1;
			__u32 bit9: 1;
			__u32 bit8: 1;
			__u32 bit23: 1;
			__u32 bit22: 1;
			__u32 bit21: 1;
			__u32 bit20: 1;
			__u32 bit19: 1;
			__u32 bit18: 1;
			__u32 bit17: 1;
			__u32 bit16: 1;
		} type;
	};
	__u8 data[0];
};

struct mpc_ioapic {
	unsigned char type;
	unsigned char apicid;
	unsigned char apicver;
	unsigned char flags;
	unsigned int apicaddr;
};

struct mp_ioapic_gsi {
	u32 gsi_base;
	u32 gsi_end;
};

struct irq_domain_ops;

struct ioapic_domain_cfg {
	enum ioapic_domain_type type;
	const struct irq_domain_ops *ops;
	struct device_node *dev;
};

struct ioapic {
	int nr_registers;
	struct IO_APIC_route_entry *saved_registers;
	struct mpc_ioapic mp_config;
	struct mp_ioapic_gsi gsi_config;
	struct ioapic_domain_cfg irqdomain_cfg;
	struct irq_domain *irqdomain;
	struct resource *iomem_res;
};

struct ioapic_alloc_info {
	int pin;
	int node;
	u32 is_level: 1;
	u32 active_low: 1;
	u32 valid: 1;
};

struct ioc_params {
	u32 qos[6];
	u64 i_lcoefs[6];
	u64 lcoefs[6];
	u32 too_fast_vrate_pct;
	u32 too_slow_vrate_pct;
};

struct ioc_margins {
	s64 min;
	s64 low;
	s64 target;
};

struct ioc_pcpu_stat;

struct ioc {
	struct rq_qos rqos;
	bool enabled;
	struct ioc_params params;
	struct ioc_margins margins;
	u32 period_us;
	u32 timer_slack_ns;
	u64 vrate_min;
	u64 vrate_max;
	spinlock_t lock;
	struct timer_list timer;
	struct list_head active_iocgs;
	struct ioc_pcpu_stat *pcpu_stat;
	enum ioc_running running;
	atomic64_t vtime_rate;
	u64 vtime_base_rate;
	s64 vtime_err;
	seqcount_spinlock_t period_seqcount;
	u64 period_at;
	u64 period_at_vtime;
	atomic64_t cur_period;
	int busy_level;
	bool weights_updated;
	atomic_t hweight_gen;
	u64 dfgv_period_at;
	u64 dfgv_period_rem;
	u64 dfgv_usage_us_sum;
	u64 autop_too_fast_at;
	u64 autop_too_slow_at;
	int autop_idx;
	bool user_qos_params: 1;
	bool user_cost_model: 1;
};

struct ioc_cgrp {
	struct blkcg_policy_data cpd;
	unsigned int dfl_weight;
};

struct iocg_stat {
	u64 usage_us;
	u64 wait_us;
	u64 indebt_us;
	u64 indelay_us;
};

struct iocg_pcpu_stat;

struct ioc_gq {
	struct blkg_policy_data pd;
	struct ioc *ioc;
	u32 cfg_weight;
	u32 weight;
	u32 active;
	u32 inuse;
	u32 last_inuse;
	s64 saved_margin;
	sector_t cursor;
	atomic64_t vtime;
	atomic64_t done_vtime;
	u64 abs_vdebt;
	u64 delay;
	u64 delay_at;
	atomic64_t active_period;
	struct list_head active_list;
	u64 child_active_sum;
	u64 child_inuse_sum;
	u64 child_adjusted_sum;
	int hweight_gen;
	u32 hweight_active;
	u32 hweight_inuse;
	u32 hweight_donating;
	u32 hweight_after_donation;
	struct list_head walk_list;
	struct list_head surplus_list;
	struct wait_queue_head waitq;
	struct hrtimer waitq_timer;
	u64 activated_at;
	struct iocg_pcpu_stat *pcpu_stat;
	struct iocg_stat stat;
	struct iocg_stat last_stat;
	u64 last_stat_abs_vusage;
	u64 usage_delta_us;
	u64 wait_since;
	u64 indebt_since;
	u64 indelay_since;
	int level;
	struct ioc_gq *ancestors[0];
};

struct ioc_missed {
	local_t nr_met;
	local_t nr_missed;
	u32 last_met;
	u32 last_missed;
};

struct ioc_now {
	u64 now_ns;
	u64 now;
	u64 vnow;
};

struct ioc_pcpu_stat {
	struct ioc_missed missed[2];
	local64_t rq_wait_ns;
	u64 last_rq_wait_ns;
};

struct iocb {
	__u64 aio_data;
	__u32 aio_key;
	__kernel_rwf_t aio_rw_flags;
	__u16 aio_lio_opcode;
	__s16 aio_reqprio;
	__u32 aio_fildes;
	__u64 aio_buf;
	__u64 aio_nbytes;
	__s64 aio_offset;
	__u64 aio_reserved2;
	__u32 aio_flags;
	__u32 aio_resfd;
};

struct iocg_pcpu_stat {
	local64_t abs_vusage;
};

struct iocg_wait {
	struct wait_queue_entry wait;
	struct bio *bio;
	u64 abs_cost;
	bool committed;
};

struct iocg_wake_ctx {
	struct ioc_gq *iocg;
	u32 hw_inuse;
	s64 vbudget;
};

struct snd_seq_client;

struct ioctl_handler {
	unsigned int cmd;
	int (*func)(struct snd_seq_client *, void *);
};

struct percentile_stats {
	u64 total;
	u64 missed;
};

struct latency_stat {
	union {
		struct percentile_stats ps;
		struct blk_rq_stat rqs;
	};
};

struct rq_wait {
	wait_queue_head_t wait;
	atomic_t inflight;
};

struct iolatency_grp {
	struct blkg_policy_data pd;
	struct latency_stat *stats;
	struct latency_stat cur_stat;
	struct blk_iolatency *blkiolat;
	unsigned int max_depth;
	struct rq_wait rq_wait;
	atomic64_t window_start;
	atomic_t scale_cookie;
	u64 min_lat_nsec;
	u64 cur_win_nsec;
	u64 lat_avg;
	u64 nr_samples;
	bool ssd;
	struct child_latency_info child_lat;
};

struct iomap_folio_ops;

struct iomap {
	u64 addr;
	loff_t offset;
	u64 length;
	u16 type;
	u16 flags;
	struct block_device *bdev;
	struct dax_device *dax_dev;
	void *inline_data;
	void *private;
	const struct iomap_folio_ops *folio_ops;
	u64 validity_cookie;
};

struct iomap_dio_ops;

struct iomap_dio {
	struct kiocb *iocb;
	const struct iomap_dio_ops *dops;
	loff_t i_size;
	loff_t size;
	atomic_t ref;
	unsigned int flags;
	int error;
	size_t done_before;
	bool wait_for_completion;
	union {
		struct {
			struct iov_iter *iter;
			struct task_struct *waiter;
		} submit;
		struct {
			struct work_struct work;
		} aio;
	};
};

struct iomap_iter;

struct iomap_dio_ops {
	int (*end_io)(struct kiocb *, ssize_t, int, unsigned int);
	void (*submit_io)(const struct iomap_iter *, struct bio *, loff_t);
	struct bio_set *bio_set;
};

struct iomap_folio_ops {
	struct folio * (*get_folio)(struct iomap_iter *, loff_t, unsigned int);
	void (*put_folio)(struct inode *, loff_t, unsigned int, struct folio *);
	bool (*iomap_valid)(struct inode *, const struct iomap *);
};

struct iomap_folio_state {
	spinlock_t state_lock;
	unsigned int read_bytes_pending;
	atomic_t write_bytes_pending;
	long unsigned int state[0];
};

struct iomap_ioend {
	struct list_head io_list;
	u16 io_type;
	u16 io_flags;
	struct inode *io_inode;
	size_t io_size;
	loff_t io_offset;
	sector_t io_sector;
	struct bio io_bio;
};

struct iomap_iter {
	struct inode *inode;
	loff_t pos;
	u64 len;
	s64 processed;
	unsigned int flags;
	struct iomap iomap;
	struct iomap srcmap;
	void *private;
};

struct iomap_ops {
	int (*iomap_begin)(struct inode *, loff_t, loff_t, unsigned int, struct iomap *, struct iomap *);
	int (*iomap_end)(struct inode *, loff_t, loff_t, ssize_t, unsigned int, struct iomap *);
};

struct iomap_readpage_ctx {
	struct folio *cur_folio;
	bool cur_folio_in_bio;
	struct bio *bio;
	struct readahead_control *rac;
};

struct iomap_swapfile_info {
	struct iomap iomap;
	struct swap_info_struct *sis;
	uint64_t lowest_ppage;
	uint64_t highest_ppage;
	long unsigned int nr_pages;
	int nr_extents;
	struct file *file;
};

struct iomap_writepage_ctx;

struct iomap_writeback_ops {
	int (*map_blocks)(struct iomap_writepage_ctx *, struct inode *, loff_t, unsigned int);
	int (*prepare_ioend)(struct iomap_ioend *, int);
	void (*discard_folio)(struct folio *, loff_t);
};

struct iomap_writepage_ctx {
	struct iomap iomap;
	struct iomap_ioend *ioend;
	const struct iomap_writeback_ops *ops;
	u32 nr_folios;
};

struct iommu_attach_handle {
	struct iommu_domain *domain;
};

struct iommu_cmd {
	u32 data[4];
};

struct protection_domain;

struct iommu_dev_data {
	struct mutex mutex;
	spinlock_t dte_lock;
	struct list_head list;
	struct llist_node dev_data_list;
	struct protection_domain *domain;
	struct gcr3_tbl_info gcr3_info;
	struct device *dev;
	u16 devid;
	u32 max_pasids;
	u32 flags;
	int ats_qdep;
	u8 ats_enabled: 1;
	u8 pri_enabled: 1;
	u8 pasid_enabled: 1;
	u8 pri_tlp: 1;
	u8 ppr: 1;
	bool use_vapic;
	bool defer_attach;
	struct ratelimit_state rs;
};

struct iova_bitmap;

struct iommu_dirty_bitmap {
	struct iova_bitmap *bitmap;
	struct iommu_iotlb_gather *gather;
};

struct iommu_dirty_ops {
	int (*set_dirty_tracking)(struct iommu_domain *, bool);
	int (*read_and_clear_dirty)(struct iommu_domain *, long unsigned int, size_t, long unsigned int, struct iommu_dirty_bitmap *);
};

struct iova {
	struct rb_node node;
	long unsigned int pfn_hi;
	long unsigned int pfn_lo;
};

struct iova_rcache;

struct iova_domain {
	spinlock_t iova_rbtree_lock;
	struct rb_root rbroot;
	struct rb_node *cached_node;
	struct rb_node *cached32_node;
	long unsigned int granule;
	long unsigned int start_pfn;
	long unsigned int dma_32bit_pfn;
	long unsigned int max32_alloc_size;
	struct iova anchor;
	struct iova_rcache *rcaches;
	struct hlist_node cpuhp_dead;
};

struct iommu_dma_options {
	enum iommu_dma_queue_type qt;
	size_t fq_size;
	unsigned int fq_timeout;
};

struct iova_fq;

struct iommu_dma_cookie {
	enum iommu_dma_cookie_type type;
	union {
		struct {
			struct iova_domain iovad;
			union {
				struct iova_fq *single_fq;
				struct iova_fq *percpu_fq;
			};
			atomic64_t fq_flush_start_cnt;
			atomic64_t fq_flush_finish_cnt;
			struct timer_list fq_timer;
			atomic_t fq_timer_on;
		};
		dma_addr_t msi_iova;
	};
	struct list_head msi_page_list;
	struct iommu_domain *fq_domain;
	struct iommu_dma_options options;
	struct mutex mutex;
};

struct iommu_dma_msi_page {
	struct list_head list;
	dma_addr_t iova;
	phys_addr_t phys;
};

struct iommu_domain_info {
	struct intel_iommu *iommu;
	unsigned int refcnt;
	u16 did;
};

struct iommu_user_data_array;

struct iommu_domain_ops {
	int (*attach_dev)(struct iommu_domain *, struct device *);
	int (*set_dev_pasid)(struct iommu_domain *, struct device *, ioasid_t, struct iommu_domain *);
	int (*map_pages)(struct iommu_domain *, long unsigned int, phys_addr_t, size_t, size_t, int, gfp_t, size_t *);
	size_t (*unmap_pages)(struct iommu_domain *, long unsigned int, size_t, size_t, struct iommu_iotlb_gather *);
	void (*flush_iotlb_all)(struct iommu_domain *);
	int (*iotlb_sync_map)(struct iommu_domain *, long unsigned int, size_t);
	void (*iotlb_sync)(struct iommu_domain *, struct iommu_iotlb_gather *);
	int (*cache_invalidate_user)(struct iommu_domain *, struct iommu_user_data_array *);
	phys_addr_t (*iova_to_phys)(struct iommu_domain *, dma_addr_t);
	bool (*enforce_cache_coherency)(struct iommu_domain *);
	int (*set_pgtable_quirks)(struct iommu_domain *, long unsigned int);
	void (*free)(struct iommu_domain *);
};

struct iommu_fault_page_request {
	u32 flags;
	u32 pasid;
	u32 grpid;
	u32 perm;
	u64 addr;
	u64 private_data[2];
};

struct iommu_fault {
	u32 type;
	struct iommu_fault_page_request prm;
};

struct iommu_fault_param {
	struct mutex lock;
	refcount_t users;
	struct callback_head rcu;
	struct device *dev;
	struct iopf_queue *queue;
	struct list_head queue_list;
	struct list_head partial;
	struct list_head faults;
};

struct iommu_flush_ops {
	void (*tlb_flush_all)(void *);
	void (*tlb_flush_walk)(long unsigned int, size_t, size_t, void *);
	void (*tlb_add_page)(struct iommu_iotlb_gather *, long unsigned int, size_t, void *);
};

struct iommu_fwspec {
	struct fwnode_handle *iommu_fwnode;
	u32 flags;
	unsigned int num_ids;
	u32 ids[0];
};

struct iommu_group {
	struct kobject kobj;
	struct kobject *devices_kobj;
	struct list_head devices;
	struct xarray pasid_array;
	struct mutex mutex;
	void *iommu_data;
	void (*iommu_data_release)(void *);
	char *name;
	int id;
	struct iommu_domain *default_domain;
	struct iommu_domain *blocking_domain;
	struct iommu_domain *domain;
	struct list_head entry;
	unsigned int owner_cnt;
	void *owner;
};

struct iommu_group_attribute {
	struct attribute attr;
	ssize_t (*show)(struct iommu_group *, char *);
	ssize_t (*store)(struct iommu_group *, const char *, size_t);
};

struct iommu_hw_info_vtd {
	__u32 flags;
	__u32 __reserved;
	__u64 cap_reg;
	__u64 ecap_reg;
};

struct iommu_hwpt_vtd_s1_invalidate {
	__u64 addr;
	__u64 npages;
	__u32 flags;
	__u32 __reserved;
};

struct iommu_iotlb_gather {
	long unsigned int start;
	long unsigned int end;
	size_t pgsize;
	struct list_head freelist;
	bool queued;
};

struct iommu_mm_data {
	u32 pasid;
	struct list_head sva_domains;
};

struct iommufd_viommu;

struct iommufd_ctx;

struct iommu_user_data;

struct of_phandle_args;

struct iopf_fault;

struct iommu_page_response;

struct iommu_ops {
	bool (*capable)(struct device *, enum iommu_cap);
	void * (*hw_info)(struct device *, u32 *, u32 *);
	struct iommu_domain * (*domain_alloc)(unsigned int);
	struct iommu_domain * (*domain_alloc_paging_flags)(struct device *, u32, const struct iommu_user_data *);
	struct iommu_domain * (*domain_alloc_paging)(struct device *);
	struct iommu_domain * (*domain_alloc_sva)(struct device *, struct mm_struct *);
	struct iommu_domain * (*domain_alloc_nested)(struct device *, struct iommu_domain *, u32, const struct iommu_user_data *);
	struct iommu_device * (*probe_device)(struct device *);
	void (*release_device)(struct device *);
	void (*probe_finalize)(struct device *);
	struct iommu_group * (*device_group)(struct device *);
	void (*get_resv_regions)(struct device *, struct list_head *);
	int (*of_xlate)(struct device *, const struct of_phandle_args *);
	bool (*is_attach_deferred)(struct device *);
	int (*dev_enable_feat)(struct device *, enum iommu_dev_features);
	int (*dev_disable_feat)(struct device *, enum iommu_dev_features);
	void (*page_response)(struct device *, struct iopf_fault *, struct iommu_page_response *);
	int (*def_domain_type)(struct device *);
	struct iommufd_viommu * (*viommu_alloc)(struct device *, struct iommu_domain *, struct iommufd_ctx *, unsigned int);
	const struct iommu_domain_ops *default_domain_ops;
	long unsigned int pgsize_bitmap;
	struct module *owner;
	struct iommu_domain *identity_domain;
	struct iommu_domain *blocked_domain;
	struct iommu_domain *release_domain;
	struct iommu_domain *default_domain;
	u8 user_pasid_table: 1;
};

struct iommu_page_response {
	u32 pasid;
	u32 grpid;
	u32 code;
};

struct iommu_pmu {
	struct intel_iommu *iommu;
	u32 num_cntr;
	u32 num_eg;
	u32 cntr_width;
	u32 cntr_stride;
	u32 filter;
	void *base;
	void *cfg_reg;
	void *cntr_reg;
	void *overflow;
	u64 *evcap;
	u32 **cntr_evcap;
	struct pmu pmu;
	long unsigned int used_mask[1];
	struct perf_event *event_list[64];
	unsigned char irq_name[16];
};

struct iommu_resv_region {
	struct list_head list;
	phys_addr_t start;
	size_t length;
	int prot;
	enum iommu_resv_type type;
	void (*free)(struct device *, struct iommu_resv_region *);
};

struct iommu_sva {
	struct iommu_attach_handle handle;
	struct device *dev;
	refcount_t users;
};

struct iommu_user_data {
	unsigned int type;
	void *uptr;
	size_t len;
};

struct iommu_user_data_array {
	unsigned int type;
	void *uptr;
	size_t entry_len;
	u32 entry_num;
};

struct iopf_fault {
	struct iommu_fault fault;
	struct list_head list;
};

struct iopf_group {
	struct iopf_fault last_fault;
	struct list_head faults;
	size_t fault_count;
	struct list_head pending_node;
	struct work_struct work;
	struct iommu_attach_handle *attach_handle;
	struct iommu_fault_param *fault_param;
	struct list_head node;
	u32 cookie;
};

struct iopf_queue {
	struct workqueue_struct *wq;
	struct list_head devices;
	struct mutex lock;
};

struct ioprio_blkcg {
	struct blkcg_policy_data cpd;
	enum prio_policy prio_policy;
};

struct ioremap_desc {
	unsigned int flags;
};

struct iova_magazine;

struct iova_cpu_rcache {
	spinlock_t lock;
	struct iova_magazine *loaded;
	struct iova_magazine *prev;
};

struct iova_fq_entry {
	long unsigned int iova_pfn;
	long unsigned int pages;
	struct list_head freelist;
	u64 counter;
};

struct iova_fq {
	spinlock_t lock;
	unsigned int head;
	unsigned int tail;
	unsigned int mod_mask;
	struct iova_fq_entry entries[0];
};

struct iova_magazine {
	union {
		long unsigned int size;
		struct iova_magazine *next;
	};
	long unsigned int pfns[127];
};

struct iova_rcache {
	spinlock_t lock;
	unsigned int depot_size;
	struct iova_magazine *depot;
	struct iova_cpu_rcache *cpu_rcaches;
	struct iova_domain *iovad;
	struct delayed_work work;
};

struct ip6_flowlabel {
	struct ip6_flowlabel *next;
	__be32 label;
	atomic_t users;
	struct in6_addr dst;
	struct ipv6_txoptions *opt;
	long unsigned int linger;
	struct callback_head rcu;
	u8 share;
	union {
		struct pid *pid;
		kuid_t uid;
	} owner;
	long unsigned int lastuse;
	long unsigned int expires;
	struct net *fl_net;
};

struct ip6_frag_state {
	u8 *prevhdr;
	unsigned int hlen;
	unsigned int mtu;
	unsigned int left;
	int offset;
	int ptr;
	int hroom;
	int troom;
	__be32 frag_id;
	u8 nexthdr;
};

struct ipv6hdr;

struct ip6_fraglist_iter {
	struct ipv6hdr *tmp_hdr;
	struct sk_buff *frag;
	int offset;
	unsigned int hlen;
	__be32 frag_id;
	u8 nexthdr;
};

struct sockaddr_in6 {
	short unsigned int sin6_family;
	__be16 sin6_port;
	__be32 sin6_flowinfo;
	struct in6_addr sin6_addr;
	__u32 sin6_scope_id;
};

struct ip6_mtuinfo {
	struct sockaddr_in6 ip6m_addr;
	__u32 ip6m_mtu;
};

struct ip6_ra_chain {
	struct ip6_ra_chain *next;
	struct sock *sk;
	int sel;
	void (*destructor)(struct sock *);
};

struct ip6_rt_info {
	struct in6_addr daddr;
	struct in6_addr saddr;
	u_int32_t mark;
};

struct ip6_sf_list {
	struct ip6_sf_list *sf_next;
	struct in6_addr sf_addr;
	long unsigned int sf_count[2];
	unsigned char sf_gsresp;
	unsigned char sf_oldin;
	unsigned char sf_crcount;
	struct callback_head rcu;
};

struct ip6_sf_socklist {
	unsigned int sl_max;
	unsigned int sl_count;
	struct callback_head rcu;
	struct in6_addr sl_addr[0];
};

struct ip_tunnel_encap {
	u16 type;
	u16 flags;
	__be16 sport;
	__be16 dport;
};

struct ip6_tnl {
	struct ip6_tnl *next;
	struct net_device *dev;
	netdevice_tracker dev_tracker;
	struct net *net;
	struct __ip6_tnl_parm parms;
	struct flowi fl;
	struct dst_cache dst_cache;
	struct gro_cells gro_cells;
	int err_count;
	long unsigned int err_time;
	__u32 i_seqno;
	atomic_t o_seqno;
	int hlen;
	int tun_hlen;
	int encap_hlen;
	struct ip_tunnel_encap encap;
	int mlink;
};

struct ip6_tnl_encap_ops {
	size_t (*encap_hlen)(struct ip_tunnel_encap *);
	int (*build_header)(struct sk_buff *, struct ip_tunnel_encap *, u8 *, struct flowi6 *);
	int (*err_handler)(struct sk_buff *, struct inet6_skb_parm *, u8, u8, int, __be32);
};

struct ip6addrlbl_entry {
	struct in6_addr prefix;
	int prefixlen;
	int ifindex;
	int addrtype;
	u32 label;
	struct hlist_node list;
	struct callback_head rcu;
};

struct ip6addrlbl_init_table {
	const struct in6_addr *prefix;
	int prefixlen;
	u32 label;
};

struct ip6fl_iter_state {
	struct seq_net_private p;
	struct pid_namespace *pid_ns;
	int bucket;
};

struct ip6rd_flowi {
	struct flowi6 fl6;
	struct in6_addr gateway;
};

struct ip6t_ip6 {
	struct in6_addr src;
	struct in6_addr dst;
	struct in6_addr smsk;
	struct in6_addr dmsk;
	char iniface[16];
	char outiface[16];
	unsigned char iniface_mask[16];
	unsigned char outiface_mask[16];
	__u16 proto;
	__u8 tos;
	__u8 flags;
	__u8 invflags;
};

struct xt_counters {
	__u64 pcnt;
	__u64 bcnt;
};

struct ip6t_entry {
	struct ip6t_ip6 ipv6;
	unsigned int nfcache;
	__u16 target_offset;
	__u16 next_offset;
	unsigned int comefrom;
	struct xt_counters counters;
	unsigned char elems[0];
};

struct xt_target;

struct xt_entry_target {
	union {
		struct {
			__u16 target_size;
			char name[29];
			__u8 revision;
		} user;
		struct {
			__u16 target_size;
			struct xt_target *target;
		} kernel;
		__u16 target_size;
	} u;
	unsigned char data[0];
};

struct xt_error_target {
	struct xt_entry_target target;
	char errorname[30];
};

struct ip6t_error {
	struct ip6t_entry entry;
	struct xt_error_target target;
};

struct ip6t_get_entries {
	char name[32];
	unsigned int size;
	struct ip6t_entry entrytable[0];
};

struct ip6t_getinfo {
	char name[32];
	unsigned int valid_hooks;
	unsigned int hook_entry[5];
	unsigned int underflow[5];
	unsigned int num_entries;
	unsigned int size;
};

struct ip6t_icmp {
	__u8 type;
	__u8 code[2];
	__u8 invflags;
};

struct ip6t_ipv6header_info {
	__u8 matchflags;
	__u8 invflags;
	__u8 modeflag;
};

struct ip6t_reject_info {
	__u32 with;
};

struct ip6t_replace {
	char name[32];
	unsigned int valid_hooks;
	unsigned int num_entries;
	unsigned int size;
	unsigned int hook_entry[5];
	unsigned int underflow[5];
	unsigned int num_counters;
	struct xt_counters *counters;
	struct ip6t_entry entries[0];
};

struct xt_standard_target {
	struct xt_entry_target target;
	int verdict;
};

struct ip6t_standard {
	struct ip6t_entry entry;
	struct xt_standard_target target;
};

struct ip_auth_hdr {
	__u8 nexthdr;
	__u8 hdrlen;
	__be16 reserved;
	__be32 spi;
	__be32 seq_no;
	__u8 auth_data[0];
};

struct ip_beet_phdr {
	__u8 nexthdr;
	__u8 hdrlen;
	__u8 padlen;
	__u8 reserved;
};

struct ip_conntrack_stat {
	unsigned int found;
	unsigned int invalid;
	unsigned int insert;
	unsigned int insert_failed;
	unsigned int clash_resolve;
	unsigned int drop;
	unsigned int early_drop;
	unsigned int error;
	unsigned int expect_new;
	unsigned int expect_create;
	unsigned int expect_delete;
	unsigned int search_restart;
	unsigned int chaintoolong;
};

struct ip_ct_sctp {
	enum sctp_conntrack state;
	__be32 vtag[2];
	u8 init[2];
	u8 last_dir;
	u8 flags;
};

struct ip_ct_tcp_state {
	u_int32_t td_end;
	u_int32_t td_maxend;
	u_int32_t td_maxwin;
	u_int32_t td_maxack;
	u_int8_t td_scale;
	u_int8_t flags;
};

struct ip_ct_tcp {
	struct ip_ct_tcp_state seen[2];
	u_int8_t state;
	u_int8_t last_dir;
	u_int8_t retrans;
	u_int8_t last_index;
	u_int32_t last_seq;
	u_int32_t last_ack;
	u_int32_t last_end;
	u_int16_t last_win;
	u_int8_t last_wscale;
	u_int8_t last_flags;
};

struct ip_esp_hdr {
	__be32 spi;
	__be32 seq_no;
	__u8 enc_data[0];
};

struct ip_frag_state {
	bool DF;
	unsigned int hlen;
	unsigned int ll_rs;
	unsigned int mtu;
	unsigned int left;
	int offset;
	int ptr;
	__be16 not_last_frag;
};

struct ip_fraglist_iter {
	struct sk_buff *frag;
	struct iphdr *iph;
	int offset;
	unsigned int hlen;
};

struct unix_domain;

struct ip_map {
	struct cache_head h;
	char m_class[8];
	struct in6_addr m_addr;
	struct unix_domain *m_client;
	struct callback_head m_rcu;
};

struct ip_sf_list;

struct ip_mc_list {
	struct in_device *interface;
	__be32 multiaddr;
	unsigned int sfmode;
	struct ip_sf_list *sources;
	struct ip_sf_list *tomb;
	long unsigned int sfcount[2];
	union {
		struct ip_mc_list *next;
		struct ip_mc_list *next_rcu;
	};
	struct ip_mc_list *next_hash;
	struct timer_list timer;
	int users;
	refcount_t refcnt;
	spinlock_t lock;
	char tm_running;
	char reporter;
	char unsolicit_count;
	char loaded;
	unsigned char gsquery;
	unsigned char crcount;
	long unsigned int mca_cstamp;
	long unsigned int mca_tstamp;
	struct callback_head rcu;
};

struct ip_mreqn {
	struct in_addr imr_multiaddr;
	struct in_addr imr_address;
	int imr_ifindex;
};

struct ip_sf_socklist;

struct ip_mc_socklist {
	struct ip_mc_socklist *next_rcu;
	struct ip_mreqn multi;
	unsigned int sfmode;
	struct ip_sf_socklist *sflist;
	struct callback_head rcu;
};

struct ip_mreq_source {
	__be32 imr_multiaddr;
	__be32 imr_interface;
	__be32 imr_sourceaddr;
};

struct ip_msfilter {
	__be32 imsf_multiaddr;
	__be32 imsf_interface;
	__u32 imsf_fmode;
	__u32 imsf_numsrc;
	union {
		__be32 imsf_slist[1];
		struct {
			struct {} __empty_imsf_slist_flex;
			__be32 imsf_slist_flex[0];
		};
	};
};

struct ip_ra_chain {
	struct ip_ra_chain *next;
	struct sock *sk;
	union {
		void (*destructor)(struct sock *);
		struct sock *saved_sk;
	};
	struct callback_head rcu;
};

struct kvec {
	void *iov_base;
	size_t iov_len;
};

struct ip_reply_arg {
	struct kvec iov[1];
	int flags;
	__wsum csum;
	int csumoffset;
	int bound_dev_if;
	u8 tos;
	kuid_t uid;
};

struct ip_rt_info {
	__be32 daddr;
	__be32 saddr;
	u_int8_t tos;
	u_int32_t mark;
};

struct ip_sf_list {
	struct ip_sf_list *sf_next;
	long unsigned int sf_count[2];
	__be32 sf_inaddr;
	unsigned char sf_gsresp;
	unsigned char sf_oldin;
	unsigned char sf_crcount;
};

struct ip_sf_socklist {
	unsigned int sl_max;
	unsigned int sl_count;
	struct callback_head rcu;
	__be32 sl_addr[0];
};

struct ip_tunnel_parm_kern {
	char name[16];
	long unsigned int i_flags[1];
	long unsigned int o_flags[1];
	__be32 i_key;
	__be32 o_key;
	int link;
	struct iphdr iph;
};

struct ip_tunnel_prl_entry;

struct ip_tunnel {
	struct ip_tunnel *next;
	struct hlist_node hash_node;
	struct net_device *dev;
	netdevice_tracker dev_tracker;
	struct net *net;
	long unsigned int err_time;
	int err_count;
	u32 i_seqno;
	atomic_t o_seqno;
	int tun_hlen;
	u32 index;
	u8 erspan_ver;
	u8 dir;
	u16 hwid;
	struct dst_cache dst_cache;
	struct ip_tunnel_parm_kern parms;
	int mlink;
	int encap_hlen;
	int hlen;
	struct ip_tunnel_encap encap;
	struct ip_tunnel_prl_entry *prl;
	unsigned int prl_count;
	unsigned int ip_tnl_net_id;
	struct gro_cells gro_cells;
	__u32 fwmark;
	bool collect_md;
	bool ignore_df;
};

struct ip_tunnel_encap_ops {
	size_t (*encap_hlen)(struct ip_tunnel_encap *);
	int (*build_header)(struct sk_buff *, struct ip_tunnel_encap *, u8 *, struct flowi4 *);
	int (*err_handler)(struct sk_buff *, u32);
};

struct ip_tunnel_key {
	__be64 tun_id;
	union {
		struct {
			__be32 src;
			__be32 dst;
		} ipv4;
		struct {
			struct in6_addr src;
			struct in6_addr dst;
		} ipv6;
	} u;
	long unsigned int tun_flags[1];
	__be32 label;
	u32 nhid;
	u8 tos;
	u8 ttl;
	__be16 tp_src;
	__be16 tp_dst;
	__u8 flow_flags;
};

struct ip_tunnel_info {
	struct ip_tunnel_key key;
	struct ip_tunnel_encap encap;
	struct dst_cache dst_cache;
	u8 options_len;
	u8 mode;
};

struct rtnl_link_ops;

struct ip_tunnel_net {
	struct net_device *fb_tunnel_dev;
	struct rtnl_link_ops *rtnl_link_ops;
	struct hlist_head tunnels[128];
	struct ip_tunnel *collect_md_tun;
	int type;
};

struct ip_tunnel_parm {
	char name[16];
	int link;
	__be16 i_flags;
	__be16 o_flags;
	__be32 i_key;
	__be32 o_key;
	struct iphdr iph;
};

struct ip_tunnel_prl {
	__be32 addr;
	__u16 flags;
	__u16 __reserved;
	__u32 datalen;
	__u32 __reserved2;
};

struct ip_tunnel_prl_entry {
	struct ip_tunnel_prl_entry *next;
	__be32 addr;
	u16 flags;
	struct callback_head callback_head;
};

struct ipc64_perm {
	__kernel_key_t key;
	__kernel_uid32_t uid;
	__kernel_gid32_t gid;
	__kernel_uid32_t cuid;
	__kernel_gid32_t cgid;
	__kernel_mode_t mode;
	unsigned char __pad1[0];
	short unsigned int seq;
	short unsigned int __pad2;
	__kernel_ulong_t __unused1;
	__kernel_ulong_t __unused2;
};

struct ipc_ids {
	int in_use;
	short unsigned int seq;
	struct rw_semaphore rwsem;
	struct idr ipcs_idr;
	int max_idx;
	int last_idx;
	struct rhashtable key_ht;
};

struct ipc_namespace {
	struct ipc_ids ids[3];
	int sem_ctls[4];
	int used_sems;
	unsigned int msg_ctlmax;
	unsigned int msg_ctlmnb;
	unsigned int msg_ctlmni;
	struct percpu_counter percpu_msg_bytes;
	struct percpu_counter percpu_msg_hdrs;
	size_t shm_ctlmax;
	size_t shm_ctlall;
	long unsigned int shm_tot;
	int shm_ctlmni;
	int shm_rmid_forced;
	struct notifier_block ipcns_nb;
	struct vfsmount *mq_mnt;
	unsigned int mq_queues_count;
	unsigned int mq_queues_max;
	unsigned int mq_msg_max;
	unsigned int mq_msgsize_max;
	unsigned int mq_msg_default;
	unsigned int mq_msgsize_default;
	struct ctl_table_set mq_set;
	struct ctl_table_header *mq_sysctls;
	struct ctl_table_set ipc_set;
	struct ctl_table_header *ipc_sysctls;
	struct user_namespace *user_ns;
	struct ucounts *ucounts;
	struct llist_node mnt_llist;
	struct ns_common ns;
};

struct ipc_params;

struct kern_ipc_perm;

struct ipc_ops {
	int (*getnew)(struct ipc_namespace *, struct ipc_params *);
	int (*associate)(struct kern_ipc_perm *, int);
	int (*more_checks)(struct kern_ipc_perm *, struct ipc_params *);
};

struct ipc_params {
	key_t key;
	int flg;
	union {
		size_t size;
		int nsems;
	} u;
};

struct ipc_perm {
	__kernel_key_t key;
	__kernel_uid_t uid;
	__kernel_gid_t gid;
	__kernel_uid_t cuid;
	__kernel_gid_t cgid;
	__kernel_mode_t mode;
	short unsigned int seq;
};

struct ipc_proc_iface {
	const char *path;
	const char *header;
	int ids;
	int (*show)(struct seq_file *, void *);
};

struct ipc_proc_iter {
	struct ipc_namespace *ns;
	struct pid_namespace *pid_ns;
	struct ipc_proc_iface *iface;
};

struct ipc_security_struct {
	u16 sclass;
	u32 sid;
};

struct sockcm_cookie {
	u64 transmit_time;
	u32 mark;
	u32 tsflags;
	u32 ts_opt_id;
	u32 priority;
};

struct ipcm6_cookie {
	struct sockcm_cookie sockc;
	__s16 hlimit;
	__s16 tclass;
	__u16 gso_size;
	__s8 dontfrag;
	struct ipv6_txoptions *opt;
};

struct ipcm_cookie {
	struct sockcm_cookie sockc;
	__be32 addr;
	int oif;
	struct ip_options_rcu *opt;
	__u8 protocol;
	__u8 ttl;
	__s16 tos;
	__u16 gso_size;
};

struct ipfrag_skb_cb {
	union {
		struct inet_skb_parm h4;
		struct inet6_skb_parm h6;
	};
	struct sk_buff *next_frag;
	int frag_run_len;
	int ip_defrag_offset;
};

struct ipq {
	struct inet_frag_queue q;
	u8 ecn;
	u16 max_df_size;
	int iif;
	unsigned int rid;
	struct inet_peer *peer;
};

struct ipstats_mib {
	u64 mibs[38];
	struct u64_stats_sync syncp;
};

struct ipt_ip {
	struct in_addr src;
	struct in_addr dst;
	struct in_addr smsk;
	struct in_addr dmsk;
	char iniface[16];
	char outiface[16];
	unsigned char iniface_mask[16];
	unsigned char outiface_mask[16];
	__u16 proto;
	__u8 flags;
	__u8 invflags;
};

struct ipt_entry {
	struct ipt_ip ip;
	unsigned int nfcache;
	__u16 target_offset;
	__u16 next_offset;
	unsigned int comefrom;
	struct xt_counters counters;
	unsigned char elems[0];
};

struct ipt_error {
	struct ipt_entry entry;
	struct xt_error_target target;
};

struct ipt_get_entries {
	char name[32];
	unsigned int size;
	struct ipt_entry entrytable[0];
};

struct ipt_getinfo {
	char name[32];
	unsigned int valid_hooks;
	unsigned int hook_entry[5];
	unsigned int underflow[5];
	unsigned int num_entries;
	unsigned int size;
};

struct ipt_icmp {
	__u8 type;
	__u8 code[2];
	__u8 invflags;
};

struct ipt_reject_info {
	enum ipt_reject_with with;
};

struct ipt_replace {
	char name[32];
	unsigned int valid_hooks;
	unsigned int num_entries;
	unsigned int size;
	unsigned int hook_entry[5];
	unsigned int underflow[5];
	unsigned int num_counters;
	struct xt_counters *counters;
	struct ipt_entry entries[0];
};

struct ipt_standard {
	struct ipt_entry entry;
	struct xt_standard_target target;
};

struct ipv6_ac_socklist {
	struct in6_addr acl_addr;
	int acl_ifindex;
	struct ipv6_ac_socklist *acl_next;
};

struct udp_table;

struct ipv6_bpf_stub {
	int (*inet6_bind)(struct sock *, struct sockaddr *, int, u32);
	struct sock * (*udp6_lib_lookup)(const struct net *, const struct in6_addr *, __be16, const struct in6_addr *, __be16, int, int, struct udp_table *, struct sk_buff *);
	int (*ipv6_setsockopt)(struct sock *, int, int, sockptr_t, unsigned int);
	int (*ipv6_getsockopt)(struct sock *, int, int, sockptr_t, sockptr_t);
	int (*ipv6_dev_get_saddr)(struct net *, const struct net_device *, const struct in6_addr *, unsigned int, struct in6_addr *);
};

struct ipv6_fl_socklist {
	struct ipv6_fl_socklist *next;
	struct ip6_flowlabel *fl;
	struct callback_head rcu;
};

struct ipv6_mc_socklist {
	struct in6_addr addr;
	int ifindex;
	unsigned int sfmode;
	struct ipv6_mc_socklist *next;
	struct ip6_sf_socklist *sflist;
	struct callback_head rcu;
};

struct ipv6_mreq {
	struct in6_addr ipv6mr_multiaddr;
	int ipv6mr_ifindex;
};

struct ipv6_opt_hdr {
	__u8 nexthdr;
	__u8 hdrlen;
};

struct ipv6_params {
	__s32 disable_ipv6;
	__s32 autoconf;
};

struct ipv6_pinfo {
	struct in6_addr saddr;
	struct in6_pktinfo sticky_pktinfo;
	const struct in6_addr *daddr_cache;
	__be32 flow_label;
	__u32 frag_size;
	s16 hop_limit;
	u8 mcast_hops;
	int ucast_oif;
	int mcast_oif;
	union {
		struct {
			__u16 srcrt: 1;
			__u16 osrcrt: 1;
			__u16 rxinfo: 1;
			__u16 rxoinfo: 1;
			__u16 rxhlim: 1;
			__u16 rxohlim: 1;
			__u16 hopopts: 1;
			__u16 ohopopts: 1;
			__u16 dstopts: 1;
			__u16 odstopts: 1;
			__u16 rxflow: 1;
			__u16 rxtclass: 1;
			__u16 rxpmtu: 1;
			__u16 rxorigdstaddr: 1;
			__u16 recvfragsize: 1;
		} bits;
		__u16 all;
	} rxopt;
	__u8 srcprefs;
	__u8 pmtudisc;
	__u8 min_hopcount;
	__u8 tclass;
	__be32 rcv_flowinfo;
	__u32 dst_cookie;
	struct ipv6_mc_socklist *ipv6_mc_list;
	struct ipv6_ac_socklist *ipv6_ac_list;
	struct ipv6_fl_socklist *ipv6_fl_list;
	struct ipv6_txoptions *opt;
	struct sk_buff *pktoptions;
	struct sk_buff *rxpmtu;
	struct inet6_cork cork;
};

struct ipv6_route_iter {
	struct seq_net_private p;
	struct fib6_walker w;
	loff_t skip;
	struct fib6_table *tbl;
	int sernum;
};

struct ipv6_rpl_sr_hdr {
	__u8 nexthdr;
	__u8 hdrlen;
	__u8 type;
	__u8 segments_left;
	__u32 cmpre: 4;
	__u32 cmpri: 4;
	__u32 reserved: 4;
	__u32 pad: 4;
	__u32 reserved1: 16;
	union {
		struct {
			struct {} __empty_addr;
			struct in6_addr addr[0];
		};
		struct {
			struct {} __empty_data;
			__u8 data[0];
		};
	} segments;
};

struct ipv6_rt_hdr {
	__u8 nexthdr;
	__u8 hdrlen;
	__u8 type;
	__u8 segments_left;
};

struct ipv6_saddr_dst {
	const struct in6_addr *addr;
	int ifindex;
	int scope;
	int label;
	unsigned int prefs;
};

struct ipv6_saddr_score {
	int rule;
	int addr_type;
	struct inet6_ifaddr *ifa;
	long unsigned int scorebits[1];
	int scopedist;
	int matchlen;
};

struct ipv6_sr_hdr {
	__u8 nexthdr;
	__u8 hdrlen;
	__u8 type;
	__u8 segments_left;
	__u8 first_segment;
	__u8 flags;
	__u16 tag;
	struct in6_addr segments[0];
};

struct neigh_table;

struct ipv6_stub {
	int (*ipv6_sock_mc_join)(struct sock *, int, const struct in6_addr *);
	int (*ipv6_sock_mc_drop)(struct sock *, int, const struct in6_addr *);
	struct dst_entry * (*ipv6_dst_lookup_flow)(struct net *, const struct sock *, struct flowi6 *, const struct in6_addr *);
	int (*ipv6_route_input)(struct sk_buff *);
	struct fib6_table * (*fib6_get_table)(struct net *, u32);
	int (*fib6_lookup)(struct net *, int, struct flowi6 *, struct fib6_result *, int);
	int (*fib6_table_lookup)(struct net *, struct fib6_table *, int, struct flowi6 *, struct fib6_result *, int);
	void (*fib6_select_path)(const struct net *, struct fib6_result *, struct flowi6 *, int, bool, const struct sk_buff *, int);
	u32 (*ip6_mtu_from_fib6)(const struct fib6_result *, const struct in6_addr *, const struct in6_addr *);
	int (*fib6_nh_init)(struct net *, struct fib6_nh *, struct fib6_config *, gfp_t, struct netlink_ext_ack *);
	void (*fib6_nh_release)(struct fib6_nh *);
	void (*fib6_nh_release_dsts)(struct fib6_nh *);
	void (*fib6_update_sernum)(struct net *, struct fib6_info *);
	int (*ip6_del_rt)(struct net *, struct fib6_info *, bool);
	void (*fib6_rt_update)(struct net *, struct fib6_info *, struct nl_info *);
	void (*udpv6_encap_enable)(void);
	void (*ndisc_send_na)(struct net_device *, const struct in6_addr *, const struct in6_addr *, bool, bool, bool, bool);
	void (*xfrm6_local_rxpmtu)(struct sk_buff *, u32);
	int (*xfrm6_udp_encap_rcv)(struct sock *, struct sk_buff *);
	struct sk_buff * (*xfrm6_gro_udp_encap_rcv)(struct sock *, struct list_head *, struct sk_buff *);
	int (*xfrm6_rcv_encap)(struct sk_buff *, int, __be32, int);
	struct neigh_table *nd_tbl;
	int (*ipv6_fragment)(struct net *, struct sock *, struct sk_buff *, int (*)(struct net *, struct sock *, struct sk_buff *));
	struct net_device * (*ipv6_dev_find)(struct net *, const struct in6_addr *, struct net_device *);
	int (*ip6_xmit)(const struct sock *, struct sk_buff *, struct flowi6 *, __u32, struct ipv6_txoptions *, int, u32);
};

struct ipv6_txoptions {
	refcount_t refcnt;
	int tot_len;
	__u16 opt_flen;
	__u16 opt_nflen;
	struct ipv6_opt_hdr *hopopt;
	struct ipv6_opt_hdr *dst0opt;
	struct ipv6_rt_hdr *srcrt;
	struct ipv6_opt_hdr *dst1opt;
	struct callback_head rcu;
};

struct ipv6hdr {
	__u8 priority: 4;
	__u8 version: 4;
	__u8 flow_lbl[3];
	__be16 payload_len;
	__u8 nexthdr;
	__u8 hop_limit;
	union {
		struct {
			struct in6_addr saddr;
			struct in6_addr daddr;
		};
		struct {
			struct in6_addr saddr;
			struct in6_addr daddr;
		} addrs;
	};
};

struct irq_affinity {
	unsigned int pre_vectors;
	unsigned int post_vectors;
	unsigned int nr_sets;
	unsigned int set_size[4];
	void (*calc_sets)(struct irq_affinity *, unsigned int);
	void *priv;
};

struct irq_affinity_desc {
	struct cpumask mask;
	unsigned int is_managed: 1;
};

struct irq_affinity_devres {
	unsigned int count;
	unsigned int irq[0];
};

struct irq_affinity_notify {
	unsigned int irq;
	struct kref kref;
	struct work_struct work;
	void (*notify)(struct irq_affinity_notify *, const cpumask_t *);
	void (*release)(struct kref *);
};

struct uv_alloc_info {
	int limit;
	int blade;
	long unsigned int offset;
	char *name;
};

struct msi_desc;

struct irq_alloc_info {
	enum irq_alloc_type type;
	u32 flags;
	u32 devid;
	irq_hw_number_t hwirq;
	const struct cpumask *mask;
	struct msi_desc *desc;
	void *data;
	union {
		struct ioapic_alloc_info ioapic;
		struct uv_alloc_info uv;
	};
};

typedef struct irq_alloc_info msi_alloc_info_t;

struct irq_data;

struct msi_msg;

struct irq_chip {
	const char *name;
	unsigned int (*irq_startup)(struct irq_data *);
	void (*irq_shutdown)(struct irq_data *);
	void (*irq_enable)(struct irq_data *);
	void (*irq_disable)(struct irq_data *);
	void (*irq_ack)(struct irq_data *);
	void (*irq_mask)(struct irq_data *);
	void (*irq_mask_ack)(struct irq_data *);
	void (*irq_unmask)(struct irq_data *);
	void (*irq_eoi)(struct irq_data *);
	int (*irq_set_affinity)(struct irq_data *, const struct cpumask *, bool);
	int (*irq_retrigger)(struct irq_data *);
	int (*irq_set_type)(struct irq_data *, unsigned int);
	int (*irq_set_wake)(struct irq_data *, unsigned int);
	void (*irq_bus_lock)(struct irq_data *);
	void (*irq_bus_sync_unlock)(struct irq_data *);
	void (*irq_suspend)(struct irq_data *);
	void (*irq_resume)(struct irq_data *);
	void (*irq_pm_shutdown)(struct irq_data *);
	void (*irq_calc_mask)(struct irq_data *);
	void (*irq_print_chip)(struct irq_data *, struct seq_file *);
	int (*irq_request_resources)(struct irq_data *);
	void (*irq_release_resources)(struct irq_data *);
	void (*irq_compose_msi_msg)(struct irq_data *, struct msi_msg *);
	void (*irq_write_msi_msg)(struct irq_data *, struct msi_msg *);
	int (*irq_get_irqchip_state)(struct irq_data *, enum irqchip_irq_state, bool *);
	int (*irq_set_irqchip_state)(struct irq_data *, enum irqchip_irq_state, bool);
	int (*irq_set_vcpu_affinity)(struct irq_data *, void *);
	void (*ipi_send_single)(struct irq_data *, unsigned int);
	void (*ipi_send_mask)(struct irq_data *, const struct cpumask *);
	int (*irq_nmi_setup)(struct irq_data *);
	void (*irq_nmi_teardown)(struct irq_data *);
	long unsigned int flags;
};

struct irq_chip_regs {
	long unsigned int enable;
	long unsigned int disable;
	long unsigned int mask;
	long unsigned int ack;
	long unsigned int eoi;
	long unsigned int type;
};

struct irq_desc;

typedef void (*irq_flow_handler_t)(struct irq_desc *);

struct irq_chip_type {
	struct irq_chip chip;
	struct irq_chip_regs regs;
	irq_flow_handler_t handler;
	u32 type;
	u32 mask_cache_priv;
	u32 *mask_cache;
};

struct irq_chip_generic {
	raw_spinlock_t lock;
	void *reg_base;
	u32 (*reg_readl)(void *);
	void (*reg_writel)(u32, void *);
	void (*suspend)(struct irq_chip_generic *);
	void (*resume)(struct irq_chip_generic *);
	unsigned int irq_base;
	unsigned int irq_cnt;
	u32 mask_cache;
	u32 wake_enabled;
	u32 wake_active;
	unsigned int num_ct;
	void *private;
	long unsigned int installed;
	long unsigned int unused;
	struct irq_domain *domain;
	struct list_head list;
	struct irq_chip_type chip_types[0];
};

struct irq_common_data {
	unsigned int state_use_accessors;
	unsigned int node;
	void *handler_data;
	struct msi_desc *msi_desc;
	cpumask_var_t affinity;
	cpumask_var_t effective_affinity;
};

struct irq_data {
	u32 mask;
	unsigned int irq;
	irq_hw_number_t hwirq;
	struct irq_common_data *common;
	struct irq_chip *chip;
	struct irq_domain *domain;
	struct irq_data *parent_data;
	void *chip_data;
};

struct irqstat;

struct irqaction;

struct irq_desc {
	struct irq_common_data irq_common_data;
	struct irq_data irq_data;
	struct irqstat *kstat_irqs;
	irq_flow_handler_t handle_irq;
	struct irqaction *action;
	unsigned int status_use_accessors;
	unsigned int core_internal_state__do_not_mess_with_it;
	unsigned int depth;
	unsigned int wake_depth;
	unsigned int tot_count;
	unsigned int irq_count;
	long unsigned int last_unhandled;
	unsigned int irqs_unhandled;
	atomic_t threads_handled;
	int threads_handled_last;
	raw_spinlock_t lock;
	struct cpumask *percpu_enabled;
	const struct cpumask *percpu_affinity;
	const struct cpumask *affinity_hint;
	struct irq_affinity_notify *affinity_notify;
	cpumask_var_t pending_mask;
	long unsigned int threads_oneshot;
	atomic_t threads_active;
	wait_queue_head_t wait_for_threads;
	unsigned int nr_actions;
	unsigned int no_suspend_depth;
	unsigned int cond_suspend_depth;
	unsigned int force_resume_depth;
	struct proc_dir_entry *dir;
	struct callback_head rcu;
	struct kobject kobj;
	struct mutex request_mutex;
	int parent_irq;
	struct module *owner;
	const char *name;
	struct hlist_node resend_node;
	long: 64;
	long: 64;
	long: 64;
};

typedef struct irq_desc *vector_irq_t[256];

struct irq_desc_devres {
	unsigned int from;
	unsigned int cnt;
};

struct irq_devres {
	unsigned int irq;
	void *dev_id;
};

struct irq_domain_chip_generic;

struct msi_parent_ops;

struct irq_domain {
	struct list_head link;
	const char *name;
	const struct irq_domain_ops *ops;
	void *host_data;
	unsigned int flags;
	unsigned int mapcount;
	struct mutex mutex;
	struct irq_domain *root;
	struct fwnode_handle *fwnode;
	enum irq_domain_bus_token bus_token;
	struct irq_domain_chip_generic *gc;
	struct device *dev;
	struct device *pm_dev;
	struct irq_domain *parent;
	const struct msi_parent_ops *msi_parent_ops;
	void (*exit)(struct irq_domain *);
	irq_hw_number_t hwirq_max;
	unsigned int revmap_size;
	struct xarray revmap_tree;
	struct irq_data *revmap[0];
};

struct irq_domain_chip_generic {
	unsigned int irqs_per_chip;
	unsigned int num_chips;
	unsigned int irq_flags_to_clear;
	unsigned int irq_flags_to_set;
	enum irq_gc_flags gc_flags;
	void (*exit)(struct irq_chip_generic *);
	struct irq_chip_generic *gc[0];
};

struct irq_domain_chip_generic_info {
	const char *name;
	irq_flow_handler_t handler;
	unsigned int irqs_per_chip;
	unsigned int num_ct;
	unsigned int irq_flags_to_clear;
	unsigned int irq_flags_to_set;
	enum irq_gc_flags gc_flags;
	int (*init)(struct irq_chip_generic *);
	void (*exit)(struct irq_chip_generic *);
};

struct irq_domain_info {
	struct fwnode_handle *fwnode;
	unsigned int domain_flags;
	unsigned int size;
	irq_hw_number_t hwirq_max;
	int direct_max;
	unsigned int hwirq_base;
	unsigned int virq_base;
	enum irq_domain_bus_token bus_token;
	const char *name_suffix;
	const struct irq_domain_ops *ops;
	void *host_data;
	struct irq_domain *parent;
	struct irq_domain_chip_generic_info *dgc_info;
	int (*init)(struct irq_domain *);
	void (*exit)(struct irq_domain *);
};

struct irq_fwspec;

struct irq_domain_ops {
	int (*match)(struct irq_domain *, struct device_node *, enum irq_domain_bus_token);
	int (*select)(struct irq_domain *, struct irq_fwspec *, enum irq_domain_bus_token);
	int (*map)(struct irq_domain *, unsigned int, irq_hw_number_t);
	void (*unmap)(struct irq_domain *, unsigned int);
	int (*xlate)(struct irq_domain *, struct device_node *, const u32 *, unsigned int, long unsigned int *, unsigned int *);
	int (*alloc)(struct irq_domain *, unsigned int, unsigned int, void *);
	void (*free)(struct irq_domain *, unsigned int, unsigned int);
	int (*activate)(struct irq_domain *, struct irq_data *, bool);
	void (*deactivate)(struct irq_domain *, struct irq_data *);
	int (*translate)(struct irq_domain *, struct irq_fwspec *, long unsigned int *, unsigned int *);
};

struct irq_fwspec {
	struct fwnode_handle *fwnode;
	int param_count;
	u32 param[16];
};

struct irq_glue {
	struct irq_affinity_notify notify;
	struct cpu_rmap *rmap;
	u16 index;
};

struct irq_info {
	u8 bus;
	u8 devfn;
	struct {
		u8 link;
		u16 bitmap;
	} __attribute__((packed)) irq[4];
	u8 slot;
	u8 rfu;
};

struct irq_info___2 {
	struct hlist_node node;
	int irq;
	spinlock_t lock;
	struct list_head *head;
};

struct irq_matrix {
	unsigned int matrix_bits;
	unsigned int alloc_start;
	unsigned int alloc_end;
	unsigned int alloc_size;
	unsigned int global_available;
	unsigned int global_reserved;
	unsigned int systembits_inalloc;
	unsigned int total_allocated;
	unsigned int online_maps;
	struct cpumap *maps;
	long unsigned int *system_map;
	long unsigned int scratch_map[0];
};

struct irq_override_cmp {
	const struct dmi_system_id *system;
	unsigned char irq;
	unsigned char triggering;
	unsigned char polarity;
	unsigned char shareable;
	bool override;
};

struct irq_pin_list {
	struct list_head list;
	int apic;
	int pin;
};

struct irq_remap_table {
	raw_spinlock_t lock;
	unsigned int min_index;
	u32 *table;
};

struct irq_router {
	char *name;
	u16 vendor;
	u16 device;
	int (*get)(struct pci_dev *, struct pci_dev *, int);
	int (*set)(struct pci_dev *, struct pci_dev *, int, int);
	int (*lvl)(struct pci_dev *, struct pci_dev *, int, int);
};

struct irq_router_handler {
	u16 vendor;
	int (*probe)(struct irq_router *, struct pci_dev *, u16);
};

struct irq_routing_table {
	u32 signature;
	u16 version;
	u16 size;
	u8 rtr_bus;
	u8 rtr_devfn;
	u16 exclusive_irqs;
	u16 rtr_vendor;
	u16 rtr_device;
	u32 miniport_data;
	u8 rfu[11];
	u8 checksum;
	struct irq_info slots[0];
};

struct irq_stack {
	char stack[16384];
};

typedef irqreturn_t (*irq_handler_t)(int, void *);

struct irqaction {
	irq_handler_t handler;
	void *dev_id;
	void *percpu_dev_id;
	struct irqaction *next;
	irq_handler_t thread_fn;
	struct task_struct *thread;
	struct irqaction *secondary;
	unsigned int irq;
	unsigned int flags;
	long unsigned int thread_flags;
	long unsigned int thread_mask;
	const char *name;
	struct proc_dir_entry *dir;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct irqchip_fwid {
	struct fwnode_handle fwnode;
	unsigned int type;
	char *name;
	phys_addr_t *pa;
};

struct irqentry_state {
	union {
		bool exit_rcu;
		bool lockdep;
	};
};

typedef struct irqentry_state irqentry_state_t;

struct irqstat {
	unsigned int cnt;
};

struct irt_routing_table {
	u32 signature;
	u8 size;
	u8 used;
	u16 exclusive_irqs;
	struct irq_info slots[0];
};

struct iso_directory_record {
	__u8 length[1];
	__u8 ext_attr_length[1];
	__u8 extent[8];
	__u8 size[8];
	__u8 date[7];
	__u8 flags[1];
	__u8 file_unit_size[1];
	__u8 interleave[1];
	__u8 volume_sequence_number[4];
	__u8 name_len[1];
	char name[0];
};

struct iso_inode_info {
	long unsigned int i_iget5_block;
	long unsigned int i_iget5_offset;
	unsigned int i_first_extent;
	unsigned char i_file_format;
	unsigned char i_format_parm[3];
	long unsigned int i_next_section_block;
	long unsigned int i_next_section_offset;
	off_t i_section_size;
	struct inode vfs_inode;
};

struct iso_primary_descriptor {
	__u8 type[1];
	char id[5];
	__u8 version[1];
	__u8 unused1[1];
	char system_id[32];
	char volume_id[32];
	__u8 unused2[8];
	__u8 volume_space_size[8];
	__u8 unused3[32];
	__u8 volume_set_size[4];
	__u8 volume_sequence_number[4];
	__u8 logical_block_size[4];
	__u8 path_table_size[8];
	__u8 type_l_path_table[4];
	__u8 opt_type_l_path_table[4];
	__u8 type_m_path_table[4];
	__u8 opt_type_m_path_table[4];
	__u8 root_directory_record[34];
	char volume_set_id[128];
	char publisher_id[128];
	char preparer_id[128];
	char application_id[128];
	char copyright_file_id[37];
	char abstract_file_id[37];
	char bibliographic_file_id[37];
	__u8 creation_date[17];
	__u8 modification_date[17];
	__u8 expiration_date[17];
	__u8 effective_date[17];
	__u8 file_structure_version[1];
	__u8 unused4[1];
	__u8 application_data[512];
	__u8 unused5[653];
};

struct iso_rec {
	int error_count;
	int numdesc;
};

struct iso_supplementary_descriptor {
	__u8 type[1];
	char id[5];
	__u8 version[1];
	__u8 flags[1];
	char system_id[32];
	char volume_id[32];
	__u8 unused2[8];
	__u8 volume_space_size[8];
	__u8 escape[32];
	__u8 volume_set_size[4];
	__u8 volume_sequence_number[4];
	__u8 logical_block_size[4];
	__u8 path_table_size[8];
	__u8 type_l_path_table[4];
	__u8 opt_type_l_path_table[4];
	__u8 type_m_path_table[4];
	__u8 opt_type_m_path_table[4];
	__u8 root_directory_record[34];
	char volume_set_id[128];
	char publisher_id[128];
	char preparer_id[128];
	char application_id[128];
	char copyright_file_id[37];
	char abstract_file_id[37];
	char bibliographic_file_id[37];
	__u8 creation_date[17];
	__u8 modification_date[17];
	__u8 expiration_date[17];
	__u8 effective_date[17];
	__u8 file_structure_version[1];
	__u8 unused4[1];
	__u8 application_data[512];
	__u8 unused5[653];
};

struct iso_volume_descriptor {
	__u8 type[1];
	char id[5];
	__u8 version[1];
	__u8 data[2041];
};

struct isoch_data {
	u32 maxbw;
	u32 n;
	u32 y;
	u32 l;
	u32 rq;
	struct agp_3_5_dev *dev;
};

struct isofs_fid {
	u32 block;
	u16 offset;
	u16 parent_offset;
	u32 generation;
	u32 parent_block;
	u32 parent_generation;
};

struct isofs_iget5_callback_data {
	long unsigned int block;
	long unsigned int offset;
};

struct isofs_options {
	unsigned int rock: 1;
	unsigned int joliet: 1;
	unsigned int cruft: 1;
	unsigned int hide: 1;
	unsigned int showassoc: 1;
	unsigned int nocompress: 1;
	unsigned int overriderockperm: 1;
	unsigned int uid_set: 1;
	unsigned int gid_set: 1;
	unsigned char map;
	unsigned char check;
	unsigned int blocksize;
	umode_t fmode;
	umode_t dmode;
	kgid_t gid;
	kuid_t uid;
	char *iocharset;
	s32 session;
	s32 sbsector;
};

struct nls_table;

struct isofs_sb_info {
	long unsigned int s_ninodes;
	long unsigned int s_nzones;
	long unsigned int s_firstdatazone;
	long unsigned int s_log_zone_size;
	long unsigned int s_max_size;
	int s_rock_offset;
	s32 s_sbsector;
	unsigned char s_joliet_level;
	unsigned char s_mapping;
	unsigned char s_check;
	unsigned char s_session;
	unsigned int s_high_sierra: 1;
	unsigned int s_rock: 2;
	unsigned int s_cruft: 1;
	unsigned int s_nocompress: 1;
	unsigned int s_hide: 1;
	unsigned int s_showassoc: 1;
	unsigned int s_overriderockperm: 1;
	unsigned int s_uid_set: 1;
	unsigned int s_gid_set: 1;
	umode_t s_fmode;
	umode_t s_dmode;
	kgid_t s_gid;
	kuid_t s_uid;
	struct nls_table *s_nls_iocharset;
};

struct itco_wdt_platform_data {
	char name[32];
	unsigned int version;
	bool no_reboot_use_pmc;
};

struct iter_state {
	struct seq_net_private p;
	unsigned int bucket;
};

struct itimerspec64 {
	struct timespec64 it_interval;
	struct timespec64 it_value;
};

struct ivch_priv {
	bool quiet;
	u16 width;
	u16 height;
	u16 reg_backup[24];
};

struct ivhd_dte_flags {
	struct list_head list;
	u16 segid;
	u16 devid_first;
	u16 devid_last;
	long: 64;
	struct dev_table_entry dte;
};

struct ivhd_entry {
	u8 type;
	u16 devid;
	u8 flags;
	union {
		struct {
			u32 ext;
			u32 hidh;
		};
		struct {
			u32 ext;
			u32 hidh;
		} ext_hid;
	};
	u64 cid;
	u8 uidf;
	u8 uidl;
	u8 uid;
} __attribute__((packed));

struct ivhd_header {
	u8 type;
	u8 flags;
	u16 length;
	u16 devid;
	u16 cap_ptr;
	u64 mmio_phys;
	u16 pci_seg;
	u16 info;
	u32 efr_attr;
	u64 efr_reg;
	u64 efr_reg2;
};

struct ivmd_header {
	u8 type;
	u8 flags;
	u16 length;
	u16 devid;
	u16 aux;
	u16 pci_seg;
	u8 resv[6];
	u64 range_start;
	u64 range_length;
};

struct ivrs_quirk_entry {
	u8 id;
	u32 devid;
};

struct iw_node_attr {
	struct kobj_attribute kobj_attr;
	int nid;
};

struct transaction_s;

typedef struct transaction_s transaction_t;

struct jbd2_inode {
	transaction_t *i_transaction;
	transaction_t *i_next_transaction;
	struct list_head i_list;
	struct inode *i_vfs_inode;
	long unsigned int i_flags;
	loff_t i_dirty_start;
	loff_t i_dirty_end;
};

struct jbd2_journal_block_tail {
	__be32 t_checksum;
};

typedef struct journal_s journal_t;

struct jbd2_journal_handle {
	union {
		transaction_t *h_transaction;
		journal_t *h_journal;
	};
	handle_t *h_rsv_handle;
	int h_total_credits;
	int h_revoke_credits;
	int h_revoke_credits_requested;
	int h_ref;
	int h_err;
	unsigned int h_sync: 1;
	unsigned int h_jdata: 1;
	unsigned int h_reserved: 1;
	unsigned int h_aborted: 1;
	unsigned int h_type: 8;
	unsigned int h_line_no: 16;
	long unsigned int h_start_jiffies;
	unsigned int h_requested_credits;
	unsigned int saved_alloc_context;
};

struct journal_header_s {
	__be32 h_magic;
	__be32 h_blocktype;
	__be32 h_sequence;
};

typedef struct journal_header_s journal_header_t;

struct jbd2_journal_revoke_header_s {
	journal_header_t r_header;
	__be32 r_count;
};

typedef struct jbd2_journal_revoke_header_s jbd2_journal_revoke_header_t;

struct jbd2_revoke_record_s {
	struct list_head hash;
	tid_t sequence;
	long long unsigned int blocknr;
};

struct jbd2_revoke_table_s {
	int hash_size;
	int hash_shift;
	struct list_head *hash_table;
};

struct transaction_stats_s;

struct jbd2_stats_proc_session {
	journal_t *journal;
	struct transaction_stats_s *stats;
	int start;
	int max;
};

struct rand_data;

struct shash_desc;

struct jitterentropy {
	spinlock_t jent_lock;
	struct rand_data *entropy_collector;
	struct crypto_shash *tfm;
	struct shash_desc *sdesc;
};

struct journal_block_tag3_s {
	__be32 t_blocknr;
	__be32 t_flags;
	__be32 t_blocknr_high;
	__be32 t_checksum;
};

typedef struct journal_block_tag3_s journal_block_tag3_t;

struct journal_block_tag_s {
	__be32 t_blocknr;
	__be16 t_checksum;
	__be16 t_flags;
	__be32 t_blocknr_high;
};

typedef struct journal_block_tag_s journal_block_tag_t;

struct journal_head {
	struct buffer_head *b_bh;
	spinlock_t b_state_lock;
	int b_jcount;
	unsigned int b_jlist;
	unsigned int b_modified;
	char *b_frozen_data;
	char *b_committed_data;
	transaction_t *b_transaction;
	transaction_t *b_next_transaction;
	struct journal_head *b_tnext;
	struct journal_head *b_tprev;
	transaction_t *b_cp_transaction;
	struct journal_head *b_cpnext;
	struct journal_head *b_cpprev;
	struct jbd2_buffer_trigger_type *b_triggers;
	struct jbd2_buffer_trigger_type *b_frozen_triggers;
};

struct transaction_run_stats_s {
	long unsigned int rs_wait;
	long unsigned int rs_request_delay;
	long unsigned int rs_running;
	long unsigned int rs_locked;
	long unsigned int rs_flushing;
	long unsigned int rs_logging;
	__u32 rs_handle_count;
	__u32 rs_blocks;
	__u32 rs_blocks_logged;
};

struct transaction_stats_s {
	long unsigned int ts_tid;
	long unsigned int ts_requested;
	struct transaction_run_stats_s run;
};

struct journal_superblock_s;

typedef struct journal_superblock_s journal_superblock_t;

struct journal_s {
	long unsigned int j_flags;
	int j_errno;
	struct mutex j_abort_mutex;
	struct buffer_head *j_sb_buffer;
	journal_superblock_t *j_superblock;
	rwlock_t j_state_lock;
	int j_barrier_count;
	struct mutex j_barrier;
	transaction_t *j_running_transaction;
	transaction_t *j_committing_transaction;
	transaction_t *j_checkpoint_transactions;
	wait_queue_head_t j_wait_transaction_locked;
	wait_queue_head_t j_wait_done_commit;
	wait_queue_head_t j_wait_commit;
	wait_queue_head_t j_wait_updates;
	wait_queue_head_t j_wait_reserved;
	wait_queue_head_t j_fc_wait;
	struct mutex j_checkpoint_mutex;
	struct buffer_head *j_chkpt_bhs[64];
	struct shrinker *j_shrinker;
	struct percpu_counter j_checkpoint_jh_count;
	transaction_t *j_shrink_transaction;
	long unsigned int j_head;
	long unsigned int j_tail;
	long unsigned int j_free;
	long unsigned int j_first;
	long unsigned int j_last;
	long unsigned int j_fc_first;
	long unsigned int j_fc_off;
	long unsigned int j_fc_last;
	struct block_device *j_dev;
	int j_blocksize;
	long long unsigned int j_blk_offset;
	char j_devname[56];
	struct block_device *j_fs_dev;
	errseq_t j_fs_dev_wb_err;
	unsigned int j_total_len;
	atomic_t j_reserved_credits;
	spinlock_t j_list_lock;
	struct inode *j_inode;
	tid_t j_tail_sequence;
	tid_t j_transaction_sequence;
	tid_t j_commit_sequence;
	tid_t j_commit_request;
	__u8 j_uuid[16];
	struct task_struct *j_task;
	int j_max_transaction_buffers;
	int j_revoke_records_per_block;
	int j_transaction_overhead_buffers;
	long unsigned int j_commit_interval;
	struct timer_list j_commit_timer;
	spinlock_t j_revoke_lock;
	struct jbd2_revoke_table_s *j_revoke;
	struct jbd2_revoke_table_s *j_revoke_table[2];
	struct buffer_head **j_wbuf;
	struct buffer_head **j_fc_wbuf;
	int j_wbufsize;
	int j_fc_wbufsize;
	pid_t j_last_sync_writer;
	u64 j_average_commit_time;
	u32 j_min_batch_time;
	u32 j_max_batch_time;
	void (*j_commit_callback)(journal_t *, transaction_t *);
	int (*j_submit_inode_data_buffers)(struct jbd2_inode *);
	int (*j_finish_inode_data_buffers)(struct jbd2_inode *);
	spinlock_t j_history_lock;
	struct proc_dir_entry *j_proc_entry;
	struct transaction_stats_s j_stats;
	unsigned int j_failed_commit;
	void *j_private;
	__u32 j_csum_seed;
	void (*j_fc_cleanup_callback)(struct journal_s *, int, tid_t);
	int (*j_fc_replay_callback)(struct journal_s *, struct buffer_head *, enum passtype, int, tid_t);
	int (*j_bmap)(struct journal_s *, sector_t *);
};

struct journal_superblock_s {
	journal_header_t s_header;
	__be32 s_blocksize;
	__be32 s_maxlen;
	__be32 s_first;
	__be32 s_sequence;
	__be32 s_start;
	__be32 s_errno;
	__be32 s_feature_compat;
	__be32 s_feature_incompat;
	__be32 s_feature_ro_compat;
	__u8 s_uuid[16];
	__be32 s_nr_users;
	__be32 s_dynsuper;
	__be32 s_max_transaction;
	__be32 s_max_trans_data;
	__u8 s_checksum_type;
	__u8 s_padding2[3];
	__be32 s_num_fc_blks;
	__be32 s_head;
	__u32 s_padding[40];
	__be32 s_checksum;
	__u8 s_users[768];
};

struct jump_entry {
	s32 code;
	s32 target;
	long int key;
};

struct jump_label_patch {
	const void *code;
	int size;
};

struct k_itimer;

struct k_clock {
	int (*clock_getres)(const clockid_t, struct timespec64 *);
	int (*clock_set)(const clockid_t, const struct timespec64 *);
	int (*clock_get_timespec)(const clockid_t, struct timespec64 *);
	ktime_t (*clock_get_ktime)(const clockid_t);
	int (*clock_adj)(const clockid_t, struct __kernel_timex *);
	int (*timer_create)(struct k_itimer *);
	int (*nsleep)(const clockid_t, int, const struct timespec64 *);
	int (*timer_set)(struct k_itimer *, int, struct itimerspec64 *, struct itimerspec64 *);
	int (*timer_del)(struct k_itimer *);
	void (*timer_get)(struct k_itimer *, struct itimerspec64 *);
	void (*timer_rearm)(struct k_itimer *);
	s64 (*timer_forward)(struct k_itimer *, ktime_t);
	ktime_t (*timer_remaining)(struct k_itimer *, ktime_t);
	int (*timer_try_to_cancel)(struct k_itimer *);
	void (*timer_arm)(struct k_itimer *, ktime_t, bool, bool);
	void (*timer_wait_running)(struct k_itimer *);
};

struct kernel_siginfo {
	struct {
		int si_signo;
		int si_errno;
		int si_code;
		union __sifields _sifields;
	};
};

struct sigqueue {
	struct list_head list;
	int flags;
	kernel_siginfo_t info;
	struct ucounts *ucounts;
};

struct signal_struct;

struct k_itimer {
	struct hlist_node list;
	struct hlist_node ignored_list;
	struct hlist_node t_hash;
	spinlock_t it_lock;
	const struct k_clock *kclock;
	clockid_t it_clock;
	timer_t it_id;
	int it_status;
	bool it_sig_periodic;
	s64 it_overrun;
	s64 it_overrun_last;
	unsigned int it_signal_seq;
	unsigned int it_sigqueue_seq;
	int it_sigev_notify;
	enum pid_type it_pid_type;
	ktime_t it_interval;
	struct signal_struct *it_signal;
	union {
		struct pid *it_pid;
		struct task_struct *it_process;
	};
	struct sigqueue sigq;
	rcuref_t rcuref;
	union {
		struct {
			struct hrtimer timer;
		} real;
		struct cpu_timer cpu;
		struct {
			struct alarm alarmtimer;
		} alarm;
	} it;
	struct callback_head rcu;
};

typedef void __signalfn_t(int);

typedef __signalfn_t *__sighandler_t;

typedef void __restorefn_t(void);

typedef __restorefn_t *__sigrestore_t;

struct sigaction {
	__sighandler_t sa_handler;
	long unsigned int sa_flags;
	__sigrestore_t sa_restorer;
	sigset_t sa_mask;
};

struct k_sigaction {
	struct sigaction sa;
};

struct kallsym_iter {
	loff_t pos;
	loff_t pos_mod_end;
	loff_t pos_ftrace_mod_end;
	loff_t pos_bpf_end;
	long unsigned int value;
	unsigned int nameoff;
	char type;
	char name[512];
	char module_name[56];
	int exported;
	int show_value;
};

struct karatsuba_ctx {
	struct karatsuba_ctx *next;
	mpi_ptr_t tspace;
	mpi_size_t tspace_size;
	mpi_ptr_t tp;
	mpi_size_t tp_size;
};

struct kaslr_memory_region {
	long unsigned int *base;
	long unsigned int *end;
	long unsigned int size_tb;
};

struct kbd_led_trigger {
	struct led_trigger trigger;
	unsigned int mask;
};

struct kbd_repeat {
	int delay;
	int period;
};

struct kbd_struct {
	unsigned char lockstate;
	unsigned char slockstate;
	unsigned char ledmode: 1;
	unsigned char ledflagstate: 4;
	char: 3;
	unsigned char default_ledflagstate: 4;
	unsigned char kbdmode: 3;
	int: 1;
	unsigned char modeflags: 5;
};

struct kbdiacr {
	unsigned char diacr;
	unsigned char base;
	unsigned char result;
};

struct kbdiacrs {
	unsigned int kb_cnt;
	struct kbdiacr kbdiacr[256];
};

struct kbdiacruc {
	unsigned int diacr;
	unsigned int base;
	unsigned int result;
};

struct kbdiacrsuc {
	unsigned int kb_cnt;
	struct kbdiacruc kbdiacruc[256];
};

struct kbentry {
	unsigned char kb_table;
	unsigned char kb_index;
	short unsigned int kb_value;
};

struct kbkeycode {
	unsigned int scancode;
	unsigned int keycode;
};

struct kbsentry {
	unsigned char kb_func;
	unsigned char kb_string[512];
};

struct kcmp_epoll_slot {
	__u32 efd;
	__u32 tfd;
	__u32 toff;
};

typedef void (*dm_kcopyd_notify_fn)(int, long unsigned int, void *);

struct kcopyd_job {
	struct dm_kcopyd_client *kc;
	struct list_head list;
	unsigned int flags;
	int read_err;
	long unsigned int write_err;
	enum req_op op;
	struct dm_io_region source;
	unsigned int num_dests;
	struct dm_io_region dests[8];
	struct page_list *pages;
	dm_kcopyd_notify_fn fn;
	void *context;
	struct mutex lock;
	atomic_t sub_jobs;
	sector_t progress;
	sector_t write_offset;
	struct kcopyd_job *master_job;
};

struct kcore_list {
	struct list_head list;
	long unsigned int addr;
	size_t size;
	int type;
};

struct kcsan_scoped_access {};

struct kern_ipc_perm {
	spinlock_t lock;
	bool deleted;
	int id;
	key_t key;
	kuid_t uid;
	kgid_t gid;
	kuid_t cuid;
	kgid_t cgid;
	umode_t mode;
	long unsigned int seq;
	void *security;
	struct rhash_head khtnode;
	struct callback_head rcu;
	refcount_t refcount;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct kernel_clone_args {
	u64 flags;
	int *pidfd;
	int *child_tid;
	int *parent_tid;
	const char *name;
	int exit_signal;
	u32 kthread: 1;
	u32 io_thread: 1;
	u32 user_worker: 1;
	u32 no_files: 1;
	long unsigned int stack;
	long unsigned int stack_size;
	long unsigned int tls;
	pid_t *set_tid;
	size_t set_tid_size;
	int cgroup;
	int idle;
	int (*fn)(void *);
	void *fn_arg;
	struct cgroup *cgrp;
	struct css_set *cset;
	unsigned int kill_seq;
};

struct kernel_cpustat {
	u64 cpustat[10];
};

struct kernel_ethtool_ringparam {
	u32 rx_buf_len;
	u8 tcp_data_split;
	u8 tx_push;
	u8 rx_push;
	u32 cqe_size;
	u32 tx_push_buf_len;
	u32 tx_push_buf_max_len;
	u32 hds_thresh;
	u32 hds_thresh_max;
};

struct kernel_ethtool_ts_info {
	u32 cmd;
	u32 so_timestamping;
	int phc_index;
	enum hwtstamp_provider_qualifier phc_qualifier;
	enum hwtstamp_tx_types tx_types;
	enum hwtstamp_rx_filters rx_filters;
};

struct kernel_hwtstamp_config {
	int flags;
	int tx_type;
	int rx_filter;
	struct ifreq *ifr;
	bool copied_to_user;
	enum hwtstamp_source source;
	enum hwtstamp_provider_qualifier qualifier;
};

struct kernel_param_ops;

struct kparam_string;

struct kparam_array;

struct kernel_param {
	const char *name;
	struct module *mod;
	const struct kernel_param_ops *ops;
	const u16 perm;
	s8 level;
	u8 flags;
	union {
		void *arg;
		const struct kparam_string *str;
		const struct kparam_array *arr;
	};
};

struct kernel_param_ops {
	unsigned int flags;
	int (*set)(const char *, const struct kernel_param *);
	int (*get)(char *, const struct kernel_param *);
	void (*free)(void *);
};

struct kernel_pkey_params {
	struct key *key;
	const char *encoding;
	const char *hash_algo;
	char *info;
	__u32 in_len;
	union {
		__u32 out_len;
		__u32 in2_len;
	};
	enum kernel_pkey_operation op: 8;
};

struct kernel_pkey_query {
	__u32 supported_ops;
	__u32 key_size;
	__u16 max_data_size;
	__u16 max_sig_size;
	__u16 max_enc_size;
	__u16 max_dec_size;
};

struct kernel_stat {
	long unsigned int irqs_sum;
	unsigned int softirqs[10];
};

struct kernel_symbol {
	int value_offset;
	int name_offset;
	int namespace_offset;
};

struct kernel_vm86_regs {
	struct pt_regs pt;
	short unsigned int es;
	short unsigned int __esh;
	short unsigned int ds;
	short unsigned int __dsh;
	short unsigned int fs;
	short unsigned int __fsh;
	short unsigned int gs;
	short unsigned int __gsh;
};

struct kernfs_open_node;

struct kernfs_elem_attr {
	const struct kernfs_ops *ops;
	struct kernfs_open_node *open;
	loff_t size;
	struct kernfs_node *notify_next;
};

struct kernfs_elem_dir {
	long unsigned int subdirs;
	struct rb_root children;
	struct kernfs_root *root;
	long unsigned int rev;
};

struct kernfs_elem_symlink {
	struct kernfs_node *target_kn;
};

struct kernfs_global_locks {
	struct mutex open_file_mutex[1024];
};

struct simple_xattrs {
	struct rb_root rb_root;
	rwlock_t lock;
};

struct kernfs_iattrs {
	kuid_t ia_uid;
	kgid_t ia_gid;
	struct timespec64 ia_atime;
	struct timespec64 ia_mtime;
	struct timespec64 ia_ctime;
	struct simple_xattrs xattrs;
	atomic_t nr_user_xattrs;
	atomic_t user_xattr_size;
};

struct kernfs_node {
	atomic_t count;
	atomic_t active;
	struct kernfs_node *parent;
	const char *name;
	struct rb_node rb;
	const void *ns;
	unsigned int hash;
	short unsigned int flags;
	umode_t mode;
	union {
		struct kernfs_elem_dir dir;
		struct kernfs_elem_symlink symlink;
		struct kernfs_elem_attr attr;
	};
	u64 id;
	void *priv;
	struct kernfs_iattrs *iattr;
	struct callback_head rcu;
};

struct kernfs_open_file {
	struct kernfs_node *kn;
	struct file *file;
	struct seq_file *seq_file;
	void *priv;
	struct mutex mutex;
	struct mutex prealloc_mutex;
	int event;
	struct list_head list;
	char *prealloc_buf;
	size_t atomic_write_len;
	bool mmapped: 1;
	bool released: 1;
	const struct vm_operations_struct *vm_ops;
};

struct kernfs_open_node {
	struct callback_head callback_head;
	atomic_t event;
	wait_queue_head_t poll;
	struct list_head files;
	unsigned int nr_mmapped;
	unsigned int nr_to_release;
};

struct kernfs_ops {
	int (*open)(struct kernfs_open_file *);
	void (*release)(struct kernfs_open_file *);
	int (*seq_show)(struct seq_file *, void *);
	void * (*seq_start)(struct seq_file *, loff_t *);
	void * (*seq_next)(struct seq_file *, void *, loff_t *);
	void (*seq_stop)(struct seq_file *, void *);
	ssize_t (*read)(struct kernfs_open_file *, char *, size_t, loff_t);
	size_t atomic_write_len;
	bool prealloc;
	ssize_t (*write)(struct kernfs_open_file *, char *, size_t, loff_t);
	__poll_t (*poll)(struct kernfs_open_file *, struct poll_table_struct *);
	int (*mmap)(struct kernfs_open_file *, struct vm_area_struct *);
	loff_t (*llseek)(struct kernfs_open_file *, loff_t, int);
};

struct kernfs_syscall_ops;

struct kernfs_root {
	struct kernfs_node *kn;
	unsigned int flags;
	struct idr ino_idr;
	u32 last_id_lowbits;
	u32 id_highbits;
	struct kernfs_syscall_ops *syscall_ops;
	struct list_head supers;
	wait_queue_head_t deactivate_waitq;
	struct rw_semaphore kernfs_rwsem;
	struct rw_semaphore kernfs_iattr_rwsem;
	struct rw_semaphore kernfs_supers_rwsem;
	struct callback_head rcu;
};

struct kernfs_super_info {
	struct super_block *sb;
	struct kernfs_root *root;
	const void *ns;
	struct list_head node;
};

struct kernfs_syscall_ops {
	int (*show_options)(struct seq_file *, struct kernfs_root *);
	int (*mkdir)(struct kernfs_node *, const char *, umode_t);
	int (*rmdir)(struct kernfs_node *);
	int (*rename)(struct kernfs_node *, struct kernfs_node *, const char *);
	int (*show_path)(struct seq_file *, struct kernfs_node *, struct kernfs_root *);
};

struct kexec_load_limit {
	struct mutex mutex;
	int limit;
};

struct kexec_segment {
	union {
		void *buf;
		void *kbuf;
	};
	size_t bufsz;
	long unsigned int mem;
	size_t memsz;
};

struct key_type;

struct key_tag;

struct keyring_index_key {
	long unsigned int hash;
	union {
		struct {
			u16 desc_len;
			char desc[6];
		};
		long unsigned int x;
	};
	struct key_type *type;
	struct key_tag *domain_tag;
	const char *description;
};

union key_payload {
	void *rcu_data0;
	void *data[4];
};

struct key_user;

struct key_restriction;

struct key {
	refcount_t usage;
	key_serial_t serial;
	union {
		struct list_head graveyard_link;
		struct rb_node serial_node;
	};
	struct rw_semaphore sem;
	struct key_user *user;
	void *security;
	union {
		time64_t expiry;
		time64_t revoked_at;
	};
	time64_t last_used_at;
	kuid_t uid;
	kgid_t gid;
	key_perm_t perm;
	short unsigned int quotalen;
	short unsigned int datalen;
	short int state;
	long unsigned int flags;
	union {
		struct keyring_index_key index_key;
		struct {
			long unsigned int hash;
			long unsigned int len_desc;
			struct key_type *type;
			struct key_tag *domain_tag;
			char *description;
		};
	};
	union {
		union key_payload payload;
		struct {
			struct list_head name_link;
			struct assoc_array keys;
		};
	};
	struct key_restriction *restrict_link;
};

struct key_entry {
	int type;
	u32 code;
	union {
		u16 keycode;
		struct {
			u8 code;
			u8 value;
		} sw;
	};
};

struct key_match_data {
	bool (*cmp)(const struct key *, const struct key_match_data *);
	const void *raw_data;
	void *preparsed;
	unsigned int lookup_type;
};

struct key_parse {
	struct key_params p;
	int idx;
	int type;
	bool def;
	bool defmgmt;
	bool defbeacon;
	bool def_uni;
	bool def_multi;
};

struct key_preparsed_payload {
	const char *orig_description;
	char *description;
	union key_payload payload;
	const void *data;
	size_t datalen;
	size_t quotalen;
	time64_t expiry;
};

typedef int (*key_restrict_link_func_t)(struct key *, const struct key_type *, const union key_payload *, struct key *);

struct key_restriction {
	key_restrict_link_func_t check;
	struct key *key;
	struct key_type *keytype;
};

struct key_security_struct {
	u32 sid;
};

struct key_tag {
	struct callback_head rcu;
	refcount_t usage;
	bool removed;
};

typedef int (*request_key_actor_t)(struct key *, void *);

struct key_type {
	const char *name;
	size_t def_datalen;
	unsigned int flags;
	int (*vet_description)(const char *);
	int (*preparse)(struct key_preparsed_payload *);
	void (*free_preparse)(struct key_preparsed_payload *);
	int (*instantiate)(struct key *, struct key_preparsed_payload *);
	int (*update)(struct key *, struct key_preparsed_payload *);
	int (*match_preparse)(struct key_match_data *);
	void (*match_free)(struct key_match_data *);
	void (*revoke)(struct key *);
	void (*destroy)(struct key *);
	void (*describe)(const struct key *, struct seq_file *);
	long int (*read)(const struct key *, char *, size_t);
	request_key_actor_t request_key;
	struct key_restriction * (*lookup_restriction)(const char *);
	int (*asym_query)(const struct kernel_pkey_params *, struct kernel_pkey_query *);
	int (*asym_eds_op)(struct kernel_pkey_params *, const void *, void *);
	int (*asym_verify_signature)(struct kernel_pkey_params *, const void *, const void *);
	struct list_head link;
	struct lock_class_key lock_class;
};

struct key_user {
	struct rb_node node;
	struct mutex cons_lock;
	spinlock_t lock;
	refcount_t usage;
	atomic_t nkeys;
	atomic_t nikeys;
	kuid_t uid;
	int qnkeys;
	int qnbytes;
};

struct key_vector {
	t_key key;
	unsigned char pos;
	unsigned char bits;
	unsigned char slen;
	union {
		struct hlist_head leaf;
		struct {
			struct {} __empty_tnode;
			struct key_vector *tnode[0];
		};
	};
};

struct keyboard_notifier_param {
	struct vc_data *vc;
	int down;
	int shift;
	int ledstate;
	unsigned int value;
};

struct keyctl_dh_params {
	union {
		__s32 private;
		__s32 priv;
	};
	__s32 prime;
	__s32 base;
};

struct keyctl_kdf_params {
	char *hashname;
	char *otherinfo;
	__u32 otherinfolen;
	__u32 __spare[8];
};

struct keyctl_pkey_params {
	__s32 key_id;
	__u32 in_len;
	union {
		__u32 out_len;
		__u32 in2_len;
	};
	__u32 __spare[7];
};

struct keyctl_pkey_query {
	__u32 supported_ops;
	__u32 key_size;
	__u16 max_data_size;
	__u16 max_sig_size;
	__u16 max_enc_size;
	__u16 max_dec_size;
	__u32 __spare[10];
};

struct keyring_read_iterator_context {
	size_t buflen;
	size_t count;
	key_serial_t *buffer;
};

struct __key_reference_with_attributes;

typedef struct __key_reference_with_attributes *key_ref_t;

struct keyring_search_context {
	struct keyring_index_key index_key;
	const struct cred *cred;
	struct key_match_data match_data;
	unsigned int flags;
	int (*iterator)(const void *, void *);
	int skipped_ret;
	bool possessed;
	key_ref_t result;
	time64_t now;
};

struct rcu_gp_oldstate {
	long unsigned int rgos_norm;
	long unsigned int rgos_exp;
};

struct kfree_rcu_cpu;

struct kfree_rcu_cpu_work {
	struct rcu_work rcu_work;
	struct callback_head *head_free;
	struct rcu_gp_oldstate head_free_gp_snap;
	struct list_head bulk_head_free[2];
	struct kfree_rcu_cpu *krcp;
};

struct kfree_rcu_cpu {
	struct callback_head *head;
	long unsigned int head_gp_snap;
	atomic_t head_count;
	struct list_head bulk_head[2];
	atomic_t bulk_count[2];
	struct kfree_rcu_cpu_work krw_arr[2];
	raw_spinlock_t lock;
	struct delayed_work monitor_work;
	bool initialized;
	struct delayed_work page_cache_work;
	atomic_t backoff_page_cache_fill;
	atomic_t work_in_progress;
	struct hrtimer hrtimer;
	struct llist_head bkvcache;
	int nr_bkv_objs;
};

struct kimage_arch {
	pgd_t *pgd;
	p4d_t *p4d;
	pud_t *pud;
	pmd_t *pmd;
	pte_t *pte;
};

struct kimage {
	kimage_entry_t head;
	kimage_entry_t *entry;
	kimage_entry_t *last_entry;
	long unsigned int start;
	struct page *control_code_page;
	struct page *swap_page;
	void *vmcoreinfo_data_copy;
	long unsigned int nr_segments;
	struct kexec_segment segment[16];
	struct list_head control_pages;
	struct list_head dest_pages;
	struct list_head unusable_pages;
	long unsigned int control_page;
	unsigned int type: 1;
	unsigned int preserve_context: 1;
	unsigned int file_mode: 1;
	unsigned int hotplug_support: 1;
	struct kimage_arch arch;
	int hp_action;
	int elfcorehdr_index;
	bool elfcorehdr_updated;
	void *elf_headers;
	long unsigned int elf_headers_sz;
	long unsigned int elf_load_addr;
};

struct kioctx_cpu;

struct kioctx {
	struct percpu_ref users;
	atomic_t dead;
	struct percpu_ref reqs;
	long unsigned int user_id;
	struct kioctx_cpu *cpu;
	unsigned int req_batch;
	unsigned int max_reqs;
	unsigned int nr_events;
	long unsigned int mmap_base;
	long unsigned int mmap_size;
	struct folio **ring_folios;
	long int nr_pages;
	struct rcu_work free_rwork;
	struct ctx_rq_wait *rq_wait;
	long: 64;
	long: 64;
	long: 64;
	struct {
		atomic_t reqs_available;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
	};
	struct {
		spinlock_t ctx_lock;
		struct list_head active_reqs;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
	};
	struct {
		struct mutex ring_lock;
		wait_queue_head_t wait;
		long: 64;
	};
	struct {
		unsigned int tail;
		unsigned int completed_events;
		spinlock_t completion_lock;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
	};
	struct folio *internal_folios[8];
	struct file *aio_ring_file;
	unsigned int id;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct kioctx_cpu {
	unsigned int reqs_available;
};

struct kioctx_table {
	struct callback_head rcu;
	unsigned int nr;
	struct kioctx *table[0];
};

struct klist_waiter {
	struct list_head list;
	struct klist_node *node;
	struct task_struct *process;
	int woken;
};

struct km_event {
	union {
		u32 hard;
		u32 proto;
		u32 byid;
		u32 aevent;
		u32 type;
	} data;
	u32 seq;
	u32 portid;
	u32 event;
	struct net *net;
};

struct kmalloc_info_struct {
	const char *name[3];
	unsigned int size;
};

struct kmalloced_param {
	struct list_head list;
	char val[0];
};

struct kmap_ctrl {};

typedef struct kmem_cache *kmem_buckets[14];

struct reciprocal_value {
	u32 m;
	u8 sh1;
	u8 sh2;
};

struct kmem_cache_order_objects {
	unsigned int x;
};

struct kmem_cache_cpu;

struct kmem_cache_node;

struct kmem_cache {
	struct kmem_cache_cpu *cpu_slab;
	slab_flags_t flags;
	long unsigned int min_partial;
	unsigned int size;
	unsigned int object_size;
	struct reciprocal_value reciprocal_size;
	unsigned int offset;
	unsigned int cpu_partial;
	unsigned int cpu_partial_slabs;
	struct kmem_cache_order_objects oo;
	struct kmem_cache_order_objects min;
	gfp_t allocflags;
	int refcount;
	void (*ctor)(void *);
	unsigned int inuse;
	unsigned int align;
	unsigned int red_left_pad;
	const char *name;
	struct list_head list;
	struct kobject kobj;
	unsigned int remote_node_defrag_ratio;
	struct kmem_cache_node *node[64];
};

struct kmem_cache_args {
	unsigned int align;
	unsigned int useroffset;
	unsigned int usersize;
	unsigned int freeptr_offset;
	bool use_freeptr_offset;
	void (*ctor)(void *);
};

struct kmem_cache_cpu {
	union {
		struct {
			void **freelist;
			long unsigned int tid;
		};
		freelist_aba_t freelist_tid;
	};
	struct slab *slab;
	struct slab *partial;
	local_lock_t lock;
};

union kmem_cache_iter_priv {
	struct bpf_iter_kmem_cache it;
	struct bpf_iter_kmem_cache_kern kit;
};

struct kmem_cache_node {
	spinlock_t list_lock;
	long unsigned int nr_partial;
	struct list_head partial;
	atomic_long_t nr_slabs;
	atomic_long_t total_objects;
	struct list_head full;
};

struct kmem_obj_info {
	void *kp_ptr;
	struct slab *kp_slab;
	void *kp_objp;
	long unsigned int kp_data_offset;
	struct kmem_cache *kp_slab_cache;
	void *kp_ret;
	void *kp_stack[16];
	void *kp_free_stack[16];
};

struct kmsg_dump_detail {
	enum kmsg_dump_reason reason;
	const char *description;
};

struct kmsg_dump_iter {
	u64 cur_seq;
	u64 next_seq;
};

struct kobj_engine {
	struct kobject base;
	struct intel_engine_cs *engine;
};

struct probe;

struct kobj_map {
	struct probe *probes[255];
	struct mutex *lock;
};

struct kobj_ns_type_operations {
	enum kobj_ns_type type;
	bool (*current_may_mount)(void);
	void * (*grab_current_ns)(void);
	const void * (*netlink_ns)(struct sock *);
	const void * (*initial_ns)(void);
	void (*drop_ns)(void *);
};

struct kobj_uevent_env {
	char *argv[3];
	char *envp[64];
	int envp_idx;
	char buf[2048];
	int buflen;
};

struct kparam_array {
	unsigned int max;
	unsigned int elemsize;
	unsigned int *num;
	const struct kernel_param_ops *ops;
	void *elem;
};

struct kparam_string {
	unsigned int maxlen;
	char *string;
};

struct kpp_request;

struct kpp_alg {
	int (*set_secret)(struct crypto_kpp *, const void *, unsigned int);
	int (*generate_public_key)(struct kpp_request *);
	int (*compute_shared_secret)(struct kpp_request *);
	unsigned int (*max_size)(struct crypto_kpp *);
	int (*init)(struct crypto_kpp *);
	void (*exit)(struct crypto_kpp *);
	struct crypto_alg base;
};

struct kpp_instance {
	void (*free)(struct kpp_instance *);
	union {
		struct {
			char head[48];
			struct crypto_instance base;
		} s;
		struct kpp_alg alg;
	};
};

struct kpp_request {
	struct crypto_async_request base;
	struct scatterlist *src;
	struct scatterlist *dst;
	unsigned int src_len;
	unsigned int dst_len;
	void *__ctx[0];
};

typedef int (*kprobe_pre_handler_t)(struct kprobe *, struct pt_regs *);

typedef void (*kprobe_post_handler_t)(struct kprobe *, struct pt_regs *, long unsigned int);

struct kprobe {
	struct hlist_node hlist;
	struct list_head list;
	long unsigned int nmissed;
	kprobe_opcode_t *addr;
	const char *symbol_name;
	unsigned int offset;
	kprobe_pre_handler_t pre_handler;
	kprobe_post_handler_t post_handler;
	kprobe_opcode_t opcode;
	struct arch_specific_insn ainsn;
	u32 flags;
};

struct kprobe_blacklist_entry {
	struct list_head list;
	long unsigned int start_addr;
	long unsigned int end_addr;
};

struct prev_kprobe {
	struct kprobe *kp;
	long unsigned int status;
	long unsigned int old_flags;
	long unsigned int saved_flags;
};

struct kprobe_ctlblk {
	long unsigned int kprobe_status;
	long unsigned int kprobe_old_flags;
	long unsigned int kprobe_saved_flags;
	struct prev_kprobe prev_kprobe;
};

struct kprobe_insn_cache {
	struct mutex mutex;
	void * (*alloc)(void);
	void (*free)(void *);
	const char *sym;
	struct list_head pages;
	size_t insn_size;
	int nr_garbage;
};

struct kprobe_insn_page {
	struct list_head list;
	kprobe_opcode_t *insns;
	struct kprobe_insn_cache *cache;
	int nused;
	int ngarbage;
	char slot_used[0];
};

struct kprobe_trace_entry_head {
	struct trace_entry ent;
	long unsigned int ip;
};

struct krb5_ctx {
	int initiate;
	u32 enctype;
	u32 flags;
	const struct gss_krb5_enctype *gk5e;
	struct crypto_sync_skcipher *enc;
	struct crypto_sync_skcipher *seq;
	struct crypto_sync_skcipher *acceptor_enc;
	struct crypto_sync_skcipher *initiator_enc;
	struct crypto_sync_skcipher *acceptor_enc_aux;
	struct crypto_sync_skcipher *initiator_enc_aux;
	struct crypto_ahash *acceptor_sign;
	struct crypto_ahash *initiator_sign;
	struct crypto_ahash *initiator_integ;
	struct crypto_ahash *acceptor_integ;
	u8 Ksess[32];
	u8 cksum[32];
	atomic_t seq_send;
	atomic64_t seq_send64;
	time64_t endtime;
	struct xdr_netobj mech_used;
};

struct kretprobe_instance;

typedef int (*kretprobe_handler_t)(struct kretprobe_instance *, struct pt_regs *);

struct rethook;

struct kretprobe {
	struct kprobe kp;
	kretprobe_handler_t handler;
	kretprobe_handler_t entry_handler;
	int maxactive;
	int nmissed;
	size_t data_size;
	struct rethook *rh;
};

struct kretprobe_blackpoint {
	const char *name;
	void *addr;
};

struct rethook_node {
	struct callback_head rcu;
	struct llist_node llist;
	struct rethook *rethook;
	long unsigned int ret_addr;
	long unsigned int frame;
};

struct kretprobe_instance {
	struct rethook_node node;
	char data[0];
};

struct kretprobe_trace_entry_head {
	struct trace_entry ent;
	long unsigned int func;
	long unsigned int ret_ip;
};

struct kset_uevent_ops;

struct kset {
	struct list_head list;
	spinlock_t list_lock;
	struct kobject kobj;
	const struct kset_uevent_ops *uevent_ops;
};

struct kset_uevent_ops {
	int (* const filter)(const struct kobject *);
	const char * (* const name)(const struct kobject *);
	int (* const uevent)(const struct kobject *, struct kobj_uevent_env *);
};

struct ksignal {
	struct k_sigaction ka;
	kernel_siginfo_t info;
	int sig;
};

struct kstat {
	u32 result_mask;
	umode_t mode;
	unsigned int nlink;
	uint32_t blksize;
	u64 attributes;
	u64 attributes_mask;
	u64 ino;
	dev_t dev;
	dev_t rdev;
	kuid_t uid;
	kgid_t gid;
	loff_t size;
	struct timespec64 atime;
	struct timespec64 mtime;
	struct timespec64 ctime;
	struct timespec64 btime;
	u64 blocks;
	u64 mnt_id;
	u64 change_cookie;
	u64 subvol;
	u32 dio_mem_align;
	u32 dio_offset_align;
	u32 dio_read_offset_align;
	u32 atomic_write_unit_min;
	u32 atomic_write_unit_max;
	u32 atomic_write_segments_max;
};

struct kstatfs {
	long int f_type;
	long int f_bsize;
	u64 f_blocks;
	u64 f_bfree;
	u64 f_bavail;
	u64 f_files;
	u64 f_ffree;
	__kernel_fsid_t f_fsid;
	long int f_namelen;
	long int f_frsize;
	long int f_flags;
	long int f_spare[4];
};

struct statmount {
	__u32 size;
	__u32 mnt_opts;
	__u64 mask;
	__u32 sb_dev_major;
	__u32 sb_dev_minor;
	__u64 sb_magic;
	__u32 sb_flags;
	__u32 fs_type;
	__u64 mnt_id;
	__u64 mnt_parent_id;
	__u32 mnt_id_old;
	__u32 mnt_parent_id_old;
	__u64 mnt_attr;
	__u64 mnt_propagation;
	__u64 mnt_peer_group;
	__u64 mnt_master;
	__u64 propagate_from;
	__u32 mnt_root;
	__u32 mnt_point;
	__u64 mnt_ns_id;
	__u32 fs_subtype;
	__u32 sb_source;
	__u32 opt_num;
	__u32 opt_array;
	__u32 opt_sec_num;
	__u32 opt_sec_array;
	__u64 __spare2[46];
	char str[0];
};

struct seq_file {
	char *buf;
	size_t size;
	size_t from;
	size_t count;
	size_t pad_until;
	loff_t index;
	loff_t read_pos;
	struct mutex lock;
	const struct seq_operations *op;
	int poll_event;
	const struct file *file;
	void *private;
};

struct kstatmount {
	struct statmount *buf;
	size_t bufsize;
	struct vfsmount *mnt;
	u64 mask;
	struct path root;
	struct statmount sm;
	struct seq_file seq;
};

struct ktermios {
	tcflag_t c_iflag;
	tcflag_t c_oflag;
	tcflag_t c_cflag;
	tcflag_t c_lflag;
	cc_t c_line;
	cc_t c_cc[19];
	speed_t c_ispeed;
	speed_t c_ospeed;
};

struct kthread {
	long unsigned int flags;
	unsigned int cpu;
	unsigned int node;
	int started;
	int result;
	int (*threadfn)(void *);
	void *data;
	struct completion parked;
	struct completion exited;
	struct cgroup_subsys_state *blkcg_css;
	char *full_name;
	struct task_struct *task;
	struct list_head hotplug_node;
	struct cpumask *preferred_affinity;
};

struct kthread_create_info {
	char *full_name;
	int (*threadfn)(void *);
	void *data;
	int node;
	struct task_struct *result;
	struct completion *done;
	struct list_head list;
};

struct kthread_delayed_work {
	struct kthread_work work;
	struct timer_list timer;
};

struct kthread_flush_work {
	struct kthread_work work;
	struct completion done;
};

struct kthread_worker {
	unsigned int flags;
	raw_spinlock_t lock;
	struct list_head work_list;
	struct list_head delayed_work_list;
	struct task_struct *task;
	struct kthread_work *current_work;
};

struct kvfree_rcu_bulk_data {
	struct list_head list;
	struct rcu_gp_oldstate gp_snap;
	long unsigned int nr_records;
	void *records[0];
};

struct kvm_memslots {
	u64 generation;
	atomic_long_t last_used_slot;
	struct rb_root_cached hva_tree;
	struct rb_root gfn_tree;
	struct hlist_head id_hash[128];
	int node_idx;
};

struct kvm_vm_stat_generic {
	u64 remote_tlb_flush;
	u64 remote_tlb_flush_requests;
};

struct kvm_vm_stat {
	struct kvm_vm_stat_generic generic;
	u64 mmu_shadow_zapped;
	u64 mmu_pte_write;
	u64 mmu_pde_zapped;
	u64 mmu_flooded;
	u64 mmu_recycled;
	u64 mmu_cache_miss;
	u64 mmu_unsync;
	union {
		struct {
			atomic64_t pages_4k;
			atomic64_t pages_2m;
			atomic64_t pages_1g;
		};
		atomic64_t pages[3];
	};
	u64 nx_lpage_splits;
	u64 max_mmu_page_hash_collisions;
	u64 max_mmu_rmap_size;
};

struct kvm_pic;

struct kvm_ioapic;

struct kvm_pit;

struct kvm_xen_hvm_config {
	__u32 flags;
	__u32 msr;
	__u64 blob_addr_32;
	__u64 blob_addr_64;
	__u8 blob_size_32;
	__u8 blob_size_64;
	__u8 pad2[30];
};

struct vhost_task;

struct once {
	atomic_t state;
	struct mutex lock;
};

struct kvm_mmu_memory_cache {
	gfp_t gfp_zero;
	gfp_t gfp_custom;
	u64 init_value;
	struct kmem_cache *kmem_cache;
	int capacity;
	int nobjs;
	void **objects;
};

struct kvm_apic_map;

struct kvm_x86_msr_filter;

struct kvm_x86_pmu_event_filter;

struct kvm_arch {
	long unsigned int n_used_mmu_pages;
	long unsigned int n_requested_mmu_pages;
	long unsigned int n_max_mmu_pages;
	unsigned int indirect_shadow_pages;
	u8 mmu_valid_gen;
	u8 vm_type;
	bool has_private_mem;
	bool has_protected_state;
	bool pre_fault_allowed;
	struct hlist_head mmu_page_hash[4096];
	struct list_head active_mmu_pages;
	struct list_head possible_nx_huge_pages;
	spinlock_t mmu_unsync_pages_lock;
	u64 shadow_mmio_value;
	struct iommu_domain *iommu_domain;
	bool iommu_noncoherent;
	atomic_t noncoherent_dma_count;
	atomic_t assigned_device_count;
	struct kvm_pic *vpic;
	struct kvm_ioapic *vioapic;
	struct kvm_pit *vpit;
	atomic_t vapics_in_nmi_mode;
	struct mutex apic_map_lock;
	struct kvm_apic_map *apic_map;
	atomic_t apic_map_dirty;
	bool apic_access_memslot_enabled;
	bool apic_access_memslot_inhibited;
	struct rw_semaphore apicv_update_lock;
	long unsigned int apicv_inhibit_reasons;
	gpa_t wall_clock;
	bool mwait_in_guest;
	bool hlt_in_guest;
	bool pause_in_guest;
	bool cstate_in_guest;
	long unsigned int irq_sources_bitmap;
	s64 kvmclock_offset;
	raw_spinlock_t tsc_write_lock;
	u64 last_tsc_nsec;
	u64 last_tsc_write;
	u32 last_tsc_khz;
	u64 last_tsc_offset;
	u64 cur_tsc_nsec;
	u64 cur_tsc_write;
	u64 cur_tsc_offset;
	u64 cur_tsc_generation;
	int nr_vcpus_matched_tsc;
	u32 default_tsc_khz;
	bool user_set_tsc;
	u64 apic_bus_cycle_ns;
	seqcount_raw_spinlock_t pvclock_sc;
	bool use_master_clock;
	u64 master_kernel_ns;
	u64 master_cycle_now;
	struct delayed_work kvmclock_update_work;
	struct delayed_work kvmclock_sync_work;
	struct kvm_xen_hvm_config xen_hvm_config;
	struct hlist_head mask_notifier_list;
	bool backwards_tsc_observed;
	bool boot_vcpu_runs_old_kvmclock;
	u32 bsp_vcpu_id;
	u64 disabled_quirks;
	enum kvm_irqchip_mode irqchip_mode;
	u8 nr_reserved_ioapic_pins;
	bool disabled_lapic_found;
	bool x2apic_format;
	bool x2apic_broadcast_quirk_disabled;
	bool guest_can_read_msr_platform_info;
	bool exception_payload_enabled;
	bool triple_fault_event;
	bool bus_lock_detection_enabled;
	bool enable_pmu;
	u32 notify_window;
	u32 notify_vmexit_flags;
	bool exit_on_emulation_error;
	u32 user_space_msr_mask;
	struct kvm_x86_msr_filter *msr_filter;
	u32 hypercall_exit_enabled;
	bool sgx_provisioning_allowed;
	struct kvm_x86_pmu_event_filter *pmu_event_filter;
	struct vhost_task *nx_huge_page_recovery_thread;
	u64 nx_huge_page_last;
	struct once nx_once;
	atomic64_t tdp_mmu_pages;
	struct list_head tdp_mmu_roots;
	spinlock_t tdp_mmu_pages_lock;
	bool shadow_root_allocated;
	u32 max_vcpu_ids;
	bool disable_nx_huge_pages;
	struct kvm_mmu_memory_cache split_shadow_page_cache;
	struct kvm_mmu_memory_cache split_page_header_cache;
	struct kvm_mmu_memory_cache split_desc_cache;
	gfn_t gfn_direct_bits;
};

struct kvm_io_bus;

struct kvm_stat_data;

struct kvm {
	rwlock_t mmu_lock;
	struct mutex slots_lock;
	struct mutex slots_arch_lock;
	struct mm_struct *mm;
	long unsigned int nr_memslot_pages;
	struct kvm_memslots __memslots[2];
	struct kvm_memslots *memslots[1];
	struct xarray vcpu_array;
	atomic_t nr_memslots_dirty_logging;
	spinlock_t mn_invalidate_lock;
	long unsigned int mn_active_invalidate_count;
	struct rcuwait mn_memslots_update_rcuwait;
	spinlock_t gpc_lock;
	struct list_head gpc_list;
	atomic_t online_vcpus;
	int max_vcpus;
	int created_vcpus;
	int last_boosted_vcpu;
	struct list_head vm_list;
	struct mutex lock;
	struct kvm_io_bus *buses[5];
	struct list_head ioeventfds;
	struct kvm_vm_stat stat;
	struct kvm_arch arch;
	refcount_t users_count;
	struct mutex irq_lock;
	struct list_head devices;
	u64 manual_dirty_log_protect;
	struct dentry *debugfs_dentry;
	struct kvm_stat_data **debugfs_stat_data;
	struct srcu_struct srcu;
	struct srcu_struct irq_srcu;
	pid_t userspace_pid;
	bool override_halt_poll_ns;
	unsigned int max_halt_poll_ns;
	u32 dirty_ring_size;
	bool dirty_ring_with_bitmap;
	bool vm_bugged;
	bool vm_dead;
	char stats_id[48];
};

struct kvm_lapic;

struct kvm_apic_map {
	struct callback_head rcu;
	enum kvm_apic_logical_mode logical_mode;
	u32 max_apic_id;
	union {
		struct kvm_lapic *xapic_flat_map[8];
		struct kvm_lapic *xapic_cluster_map[64];
	};
	struct kvm_lapic *phys_map[0];
};

struct kvm_rmap_head;

struct kvm_lpage_info;

struct kvm_arch_memory_slot {
	struct kvm_rmap_head *rmap[3];
	struct kvm_lpage_info *lpage_info[2];
	short unsigned int *gfn_write_track;
};

struct kvm_clock_pairing {
	__s64 sec;
	__s64 nsec;
	__u64 tsc;
	__u32 flags;
	__u32 pad[9];
};

union kvm_mmu_page_role {
	u32 word;
	struct {
		unsigned int level: 4;
		unsigned int has_4_byte_gpte: 1;
		unsigned int quadrant: 2;
		unsigned int direct: 1;
		unsigned int access: 3;
		unsigned int invalid: 1;
		unsigned int efer_nx: 1;
		unsigned int cr0_wp: 1;
		unsigned int smep_andnot_wp: 1;
		unsigned int smap_andnot_wp: 1;
		unsigned int ad_disabled: 1;
		unsigned int guest_mode: 1;
		unsigned int passthrough: 1;
		unsigned int is_mirror: 1;
		char: 4;
		unsigned int smm: 8;
	};
};

union kvm_mmu_extended_role {
	u32 word;
	struct {
		unsigned int valid: 1;
		unsigned int execonly: 1;
		unsigned int cr4_pse: 1;
		unsigned int cr4_pke: 1;
		unsigned int cr4_smap: 1;
		unsigned int cr4_smep: 1;
		unsigned int cr4_la57: 1;
		unsigned int efer_lma: 1;
	};
};

union kvm_cpu_role {
	u64 as_u64;
	struct {
		union kvm_mmu_page_role base;
		union kvm_mmu_extended_role ext;
	};
};

struct kvm_cpuid_entry2 {
	__u32 function;
	__u32 index;
	__u32 flags;
	__u32 eax;
	__u32 ebx;
	__u32 ecx;
	__u32 edx;
	__u32 padding[3];
};

struct kvm_debug_exit_arch {
	__u32 exception;
	__u32 pad;
	__u64 pc;
	__u64 dr6;
	__u64 dr7;
};

struct kvm_dirty_gfn {
	__u32 flags;
	__u32 slot;
	__u64 offset;
};

struct kvm_dirty_ring {
	u32 dirty_index;
	u32 reset_index;
	u32 size;
	u32 soft_limit;
	struct kvm_dirty_gfn *dirty_gfns;
	int index;
};

struct kvm_dtable {
	__u64 base;
	__u16 limit;
	__u16 padding[3];
};

struct kvm_enc_region {
	__u64 addr;
	__u64 size;
};

struct kvm_hyperv_exit {
	__u32 type;
	__u32 pad1;
	union {
		struct {
			__u32 msr;
			__u32 pad2;
			__u64 control;
			__u64 evt_page;
			__u64 msg_page;
		} synic;
		struct {
			__u64 input;
			__u64 result;
			__u64 params[2];
		} hcall;
		struct {
			__u32 msr;
			__u32 pad2;
			__u64 control;
			__u64 status;
			__u64 send_page;
			__u64 recv_page;
			__u64 pending_page;
		} syndbg;
	} u;
};

struct kvm_io_device;

struct kvm_io_range {
	gpa_t addr;
	int len;
	struct kvm_io_device *dev;
};

struct kvm_io_bus {
	int dev_count;
	int ioeventfd_count;
	struct kvm_io_range range[0];
};

struct kvm_lpage_info {
	int disallow_lpage;
};

struct kvm_memory_slot {
	struct hlist_node id_node[2];
	struct interval_tree_node hva_node[2];
	struct rb_node gfn_node[2];
	gfn_t base_gfn;
	long unsigned int npages;
	long unsigned int *dirty_bitmap;
	struct kvm_arch_memory_slot arch;
	long unsigned int userspace_addr;
	u32 flags;
	short int id;
	u16 as_id;
};

struct kvm_mmio_fragment {
	gpa_t gpa;
	void *data;
	unsigned int len;
};

struct kvm_page_fault;

struct x86_exception;

struct kvm_mmu_page;

struct kvm_mmu_root_info {
	gpa_t pgd;
	hpa_t hpa;
};

struct rsvd_bits_validate {
	u64 rsvd_bits_mask[10];
	u64 bad_mt_xwr;
};

struct kvm_vcpu;

struct kvm_mmu {
	long unsigned int (*get_guest_pgd)(struct kvm_vcpu *);
	u64 (*get_pdptr)(struct kvm_vcpu *, int);
	int (*page_fault)(struct kvm_vcpu *, struct kvm_page_fault *);
	void (*inject_page_fault)(struct kvm_vcpu *, struct x86_exception *);
	gpa_t (*gva_to_gpa)(struct kvm_vcpu *, struct kvm_mmu *, gpa_t, u64, struct x86_exception *);
	int (*sync_spte)(struct kvm_vcpu *, struct kvm_mmu_page *, int);
	struct kvm_mmu_root_info root;
	hpa_t mirror_root_hpa;
	union kvm_cpu_role cpu_role;
	union kvm_mmu_page_role root_role;
	u32 pkru_mask;
	struct kvm_mmu_root_info prev_roots[3];
	u8 permissions[16];
	u64 *pae_root;
	u64 *pml4_root;
	u64 *pml5_root;
	struct rsvd_bits_validate shadow_zero_check;
	struct rsvd_bits_validate guest_rsvd_check;
	u64 pdptrs[4];
};

struct kvm_mtrr {
	u64 var[16];
	u64 fixed_64k;
	u64 fixed_16k[2];
	u64 fixed_4k[8];
	u64 deftype;
};

struct kvm_vmx_nested_state_hdr {
	__u64 vmxon_pa;
	__u64 vmcs12_pa;
	struct {
		__u16 flags;
	} smm;
	__u16 pad;
	__u32 flags;
	__u64 preemption_timer_deadline;
};

struct kvm_svm_nested_state_hdr {
	__u64 vmcb_pa;
};

struct kvm_vmx_nested_state_data {
	__u8 vmcs12[4096];
	__u8 shadow_vmcs12[4096];
};

struct kvm_svm_nested_state_data {
	__u8 vmcb12[4096];
};

struct kvm_nested_state {
	__u16 flags;
	__u16 format;
	__u32 size;
	union {
		struct kvm_vmx_nested_state_hdr vmx;
		struct kvm_svm_nested_state_hdr svm;
		__u8 pad[120];
	} hdr;
	union {
		struct {
			struct {} __empty_vmx;
			struct kvm_vmx_nested_state_data vmx[0];
		};
		struct {
			struct {} __empty_svm;
			struct kvm_svm_nested_state_data svm[0];
		};
	} data;
};

struct kvm_pio_request {
	long unsigned int linear_rip;
	long unsigned int count;
	int in;
	int port;
	int size;
};

struct kvm_pmc {
	enum pmc_type type;
	u8 idx;
	bool is_paused;
	bool intr;
	u64 counter;
	u64 emulated_counter;
	u64 eventsel;
	struct perf_event *perf_event;
	struct kvm_vcpu *vcpu;
	u64 current_config;
};

struct kvm_pmu {
	u8 version;
	unsigned int nr_arch_gp_counters;
	unsigned int nr_arch_fixed_counters;
	unsigned int available_event_types;
	u64 fixed_ctr_ctrl;
	u64 fixed_ctr_ctrl_rsvd;
	u64 global_ctrl;
	u64 global_status;
	u64 counter_bitmask[2];
	u64 global_ctrl_rsvd;
	u64 global_status_rsvd;
	u64 reserved_bits;
	u64 raw_event_mask;
	struct kvm_pmc gp_counters[8];
	struct kvm_pmc fixed_counters[3];
	union {
		long unsigned int reprogram_pmi[1];
		atomic64_t __reprogram_pmi;
	};
	long unsigned int all_valid_pmc_idx[1];
	long unsigned int pmc_in_use[1];
	u64 ds_area;
	u64 pebs_enable;
	u64 pebs_enable_rsvd;
	u64 pebs_data_cfg;
	u64 pebs_data_cfg_rsvd;
	u64 host_cross_mapped_mask;
	bool need_cleanup;
	u8 event_count;
};

struct kvm_ptp_clock {
	struct ptp_clock *ptp_clock;
	struct ptp_clock_info caps;
};

struct kvm_queued_exception {
	bool pending;
	bool injected;
	bool has_error_code;
	u8 vector;
	u32 error_code;
	long unsigned int payload;
	bool has_payload;
};

struct kvm_queued_interrupt {
	bool injected;
	bool soft;
	u8 nr;
};

struct kvm_regs {
	__u64 rax;
	__u64 rbx;
	__u64 rcx;
	__u64 rdx;
	__u64 rsi;
	__u64 rdi;
	__u64 rsp;
	__u64 rbp;
	__u64 r8;
	__u64 r9;
	__u64 r10;
	__u64 r11;
	__u64 r12;
	__u64 r13;
	__u64 r14;
	__u64 r15;
	__u64 rip;
	__u64 rflags;
};

struct kvm_rmap_head {
	long unsigned int val;
};

struct kvm_xen_exit {
	__u32 type;
	union {
		struct {
			__u32 longmode;
			__u32 cpl;
			__u64 input;
			__u64 result;
			__u64 params[6];
		} hcall;
	} u;
};

struct kvm_segment {
	__u64 base;
	__u32 limit;
	__u16 selector;
	__u8 type;
	__u8 present;
	__u8 dpl;
	__u8 db;
	__u8 s;
	__u8 l;
	__u8 g;
	__u8 avl;
	__u8 unusable;
	__u8 padding;
};

struct kvm_sregs {
	struct kvm_segment cs;
	struct kvm_segment ds;
	struct kvm_segment es;
	struct kvm_segment fs;
	struct kvm_segment gs;
	struct kvm_segment ss;
	struct kvm_segment tr;
	struct kvm_segment ldt;
	struct kvm_dtable gdt;
	struct kvm_dtable idt;
	__u64 cr0;
	__u64 cr2;
	__u64 cr3;
	__u64 cr4;
	__u64 cr8;
	__u64 efer;
	__u64 apic_base;
	__u64 interrupt_bitmap[4];
};

struct kvm_vcpu_events {
	struct {
		__u8 injected;
		__u8 nr;
		__u8 has_error_code;
		__u8 pending;
		__u32 error_code;
	} exception;
	struct {
		__u8 injected;
		__u8 nr;
		__u8 soft;
		__u8 shadow;
	} interrupt;
	struct {
		__u8 injected;
		__u8 pending;
		__u8 masked;
		__u8 pad;
	} nmi;
	__u32 sipi_vector;
	__u32 flags;
	struct {
		__u8 smm;
		__u8 pending;
		__u8 smm_inside_nmi;
		__u8 latched_init;
	} smi;
	struct {
		__u8 pending;
	} triple_fault;
	__u8 reserved[26];
	__u8 exception_has_payload;
	__u64 exception_payload;
};

struct kvm_sync_regs {
	struct kvm_regs regs;
	struct kvm_sregs sregs;
	struct kvm_vcpu_events events;
};

struct kvm_run {
	__u8 request_interrupt_window;
	__u8 immediate_exit__unsafe;
	__u8 padding1[6];
	__u32 exit_reason;
	__u8 ready_for_interrupt_injection;
	__u8 if_flag;
	__u16 flags;
	__u64 cr8;
	__u64 apic_base;
	union {
		struct {
			__u64 hardware_exit_reason;
		} hw;
		struct {
			__u64 hardware_entry_failure_reason;
			__u32 cpu;
		} fail_entry;
		struct {
			__u32 exception;
			__u32 error_code;
		} ex;
		struct {
			__u8 direction;
			__u8 size;
			__u16 port;
			__u32 count;
			__u64 data_offset;
		} io;
		struct {
			struct kvm_debug_exit_arch arch;
		} debug;
		struct {
			__u64 phys_addr;
			__u8 data[8];
			__u32 len;
			__u8 is_write;
		} mmio;
		struct {
			__u64 phys_addr;
			__u8 data[8];
			__u32 len;
			__u8 is_write;
		} iocsr_io;
		struct {
			__u64 nr;
			__u64 args[6];
			__u64 ret;
			union {
				__u64 flags;
			};
		} hypercall;
		struct {
			__u64 rip;
			__u32 is_write;
			__u32 pad;
		} tpr_access;
		struct {
			__u8 icptcode;
			__u16 ipa;
			__u32 ipb;
		} s390_sieic;
		__u64 s390_reset_flags;
		struct {
			__u64 trans_exc_code;
			__u32 pgm_code;
		} s390_ucontrol;
		struct {
			__u32 dcrn;
			__u32 data;
			__u8 is_write;
		} dcr;
		struct {
			__u32 suberror;
			__u32 ndata;
			__u64 data[16];
		} internal;
		struct {
			__u32 suberror;
			__u32 ndata;
			__u64 flags;
			union {
				struct {
					__u8 insn_size;
					__u8 insn_bytes[15];
				};
			};
		} emulation_failure;
		struct {
			__u64 gprs[32];
		} osi;
		struct {
			__u64 nr;
			__u64 ret;
			__u64 args[9];
		} papr_hcall;
		struct {
			__u16 subchannel_id;
			__u16 subchannel_nr;
			__u32 io_int_parm;
			__u32 io_int_word;
			__u32 ipb;
			__u8 dequeued;
		} s390_tsch;
		struct {
			__u32 epr;
		} epr;
		struct {
			__u32 type;
			__u32 ndata;
			union {
				__u64 data[16];
			};
		} system_event;
		struct {
			__u64 addr;
			__u8 ar;
			__u8 reserved;
			__u8 fc;
			__u8 sel1;
			__u16 sel2;
		} s390_stsi;
		struct {
			__u8 vector;
		} eoi;
		struct kvm_hyperv_exit hyperv;
		struct {
			__u64 esr_iss;
			__u64 fault_ipa;
		} arm_nisv;
		struct {
			__u8 error;
			__u8 pad[7];
			__u32 reason;
			__u32 index;
			__u64 data;
		} msr;
		struct kvm_xen_exit xen;
		struct {
			long unsigned int extension_id;
			long unsigned int function_id;
			long unsigned int args[6];
			long unsigned int ret[2];
		} riscv_sbi;
		struct {
			long unsigned int csr_num;
			long unsigned int new_value;
			long unsigned int write_mask;
			long unsigned int ret_value;
		} riscv_csr;
		struct {
			__u32 flags;
		} notify;
		struct {
			__u64 flags;
			__u64 gpa;
			__u64 size;
		} memory_fault;
		char padding[256];
	};
	__u64 kvm_valid_regs;
	__u64 kvm_dirty_regs;
	union {
		struct kvm_sync_regs regs;
		char padding[2048];
	} s;
};

struct kvm_stat_data {
	struct kvm *kvm;
	const struct _kvm_stats_desc *desc;
	enum kvm_stat_kind kind;
};

struct kvm_steal_time {
	__u64 steal;
	__u32 version;
	__u32 flags;
	__u8 preempted;
	__u8 u8_pad[3];
	__u32 pad[11];
};

struct kvm_task_sleep_head {
	raw_spinlock_t lock;
	struct hlist_head list;
};

struct kvm_task_sleep_node {
	struct hlist_node link;
	struct swait_queue_head wq;
	u32 token;
	int cpu;
};

struct x86_emulate_ctxt;

struct pvclock_vcpu_time_info {
	u32 version;
	u32 pad0;
	u64 tsc_timestamp;
	u64 system_time;
	u32 tsc_to_system_mul;
	s8 tsc_shift;
	u8 flags;
	u8 pad[2];
};

struct kvm_vcpu_arch {
	long unsigned int regs[17];
	u32 regs_avail;
	u32 regs_dirty;
	long unsigned int cr0;
	long unsigned int cr0_guest_owned_bits;
	long unsigned int cr2;
	long unsigned int cr3;
	long unsigned int cr4;
	long unsigned int cr4_guest_owned_bits;
	long unsigned int cr4_guest_rsvd_bits;
	long unsigned int cr8;
	u32 host_pkru;
	u32 pkru;
	u32 hflags;
	u64 efer;
	u64 host_debugctl;
	u64 apic_base;
	struct kvm_lapic *apic;
	bool load_eoi_exitmap_pending;
	long unsigned int ioapic_handled_vectors[4];
	long unsigned int apic_attention;
	int32_t apic_arb_prio;
	int mp_state;
	u64 ia32_misc_enable_msr;
	u64 smbase;
	u64 smi_count;
	bool at_instruction_boundary;
	bool tpr_access_reporting;
	bool xfd_no_write_intercept;
	u64 ia32_xss;
	u64 microcode_version;
	u64 arch_capabilities;
	u64 perf_capabilities;
	struct kvm_mmu *mmu;
	struct kvm_mmu root_mmu;
	struct kvm_mmu guest_mmu;
	struct kvm_mmu nested_mmu;
	struct kvm_mmu *walk_mmu;
	struct kvm_mmu_memory_cache mmu_pte_list_desc_cache;
	struct kvm_mmu_memory_cache mmu_shadow_page_cache;
	struct kvm_mmu_memory_cache mmu_shadowed_info_cache;
	struct kvm_mmu_memory_cache mmu_page_header_cache;
	struct kvm_mmu_memory_cache mmu_external_spt_cache;
	struct fpu_guest guest_fpu;
	u64 xcr0;
	u64 guest_supported_xcr0;
	struct kvm_pio_request pio;
	void *pio_data;
	void *sev_pio_data;
	unsigned int sev_pio_count;
	u8 event_exit_inst_len;
	bool exception_from_userspace;
	struct kvm_queued_exception exception;
	struct kvm_queued_exception exception_vmexit;
	struct kvm_queued_interrupt interrupt;
	int halt_request;
	int cpuid_nent;
	struct kvm_cpuid_entry2 *cpuid_entries;
	bool is_amd_compatible;
	u32 cpu_caps[28];
	u64 reserved_gpa_bits;
	int maxphyaddr;
	struct x86_emulate_ctxt *emulate_ctxt;
	bool emulate_regs_need_sync_to_vcpu;
	bool emulate_regs_need_sync_from_vcpu;
	int (*complete_userspace_io)(struct kvm_vcpu *);
	gpa_t time;
	struct pvclock_vcpu_time_info hv_clock;
	unsigned int hw_tsc_khz;
	struct gfn_to_pfn_cache pv_time;
	bool pvclock_set_guest_stopped_request;
	struct {
		u8 preempted;
		u64 msr_val;
		u64 last_steal;
		struct gfn_to_hva_cache cache;
	} st;
	u64 l1_tsc_offset;
	u64 tsc_offset;
	u64 last_guest_tsc;
	u64 last_host_tsc;
	u64 tsc_offset_adjustment;
	u64 this_tsc_nsec;
	u64 this_tsc_write;
	u64 this_tsc_generation;
	bool tsc_catchup;
	bool tsc_always_catchup;
	s8 virtual_tsc_shift;
	u32 virtual_tsc_mult;
	u32 virtual_tsc_khz;
	s64 ia32_tsc_adjust_msr;
	u64 msr_ia32_power_ctl;
	u64 l1_tsc_scaling_ratio;
	u64 tsc_scaling_ratio;
	atomic_t nmi_queued;
	unsigned int nmi_pending;
	bool nmi_injected;
	bool smi_pending;
	u8 handling_intr_from_guest;
	struct kvm_mtrr mtrr_state;
	u64 pat;
	unsigned int switch_db_regs;
	long unsigned int db[4];
	long unsigned int dr6;
	long unsigned int dr7;
	long unsigned int eff_db[4];
	long unsigned int guest_debug_dr7;
	u64 msr_platform_info;
	u64 msr_misc_features_enables;
	u64 mcg_cap;
	u64 mcg_status;
	u64 mcg_ctl;
	u64 mcg_ext_ctl;
	u64 *mce_banks;
	u64 *mci_ctl2_banks;
	u64 mmio_gva;
	unsigned int mmio_access;
	gfn_t mmio_gfn;
	u64 mmio_gen;
	struct kvm_pmu pmu;
	long unsigned int singlestep_rip;
	cpumask_var_t wbinvd_dirty_mask;
	long unsigned int last_retry_eip;
	long unsigned int last_retry_addr;
	struct {
		bool halted;
		gfn_t gfns[64];
		struct gfn_to_hva_cache data;
		u64 msr_en_val;
		u64 msr_int_val;
		u16 vec;
		u32 id;
		bool send_user_only;
		u32 host_apf_flags;
		bool delivery_as_pf_vmexit;
		bool pageready_pending;
	} apf;
	struct {
		u64 length;
		u64 status;
	} osvw;
	struct {
		u64 msr_val;
		struct gfn_to_hva_cache data;
	} pv_eoi;
	u64 msr_kvm_poll_control;
	struct {
		bool pv_unhalted;
	} pv;
	int pending_ioapic_eoi;
	int pending_external_vector;
	bool preempted_in_kernel;
	bool l1tf_flush_l1d;
	int last_vmentry_cpu;
	u64 msr_hwcr;
	struct {
		u32 features;
		bool enforce;
	} pv_cpuid;
	bool guest_state_protected;
	bool pdptrs_from_userspace;
};

struct kvm_vcpu_stat_generic {
	u64 halt_successful_poll;
	u64 halt_attempted_poll;
	u64 halt_poll_invalid;
	u64 halt_wakeup;
	u64 halt_poll_success_ns;
	u64 halt_poll_fail_ns;
	u64 halt_wait_ns;
	u64 halt_poll_success_hist[32];
	u64 halt_poll_fail_hist[32];
	u64 halt_wait_hist[32];
	u64 blocking;
};

struct kvm_vcpu_stat {
	struct kvm_vcpu_stat_generic generic;
	u64 pf_taken;
	u64 pf_fixed;
	u64 pf_emulate;
	u64 pf_spurious;
	u64 pf_fast;
	u64 pf_mmio_spte_created;
	u64 pf_guest;
	u64 tlb_flush;
	u64 invlpg;
	u64 exits;
	u64 io_exits;
	u64 mmio_exits;
	u64 signal_exits;
	u64 irq_window_exits;
	u64 nmi_window_exits;
	u64 l1d_flush;
	u64 halt_exits;
	u64 request_irq_exits;
	u64 irq_exits;
	u64 host_state_reload;
	u64 fpu_reload;
	u64 insn_emulation;
	u64 insn_emulation_fail;
	u64 hypercalls;
	u64 irq_injections;
	u64 nmi_injections;
	u64 req_event;
	u64 nested_run;
	u64 directed_yield_attempted;
	u64 directed_yield_successful;
	u64 preemption_reported;
	u64 preemption_other;
	u64 guest_mode;
	u64 notify_window_exits;
};

struct kvm_vcpu {
	struct kvm *kvm;
	int cpu;
	int vcpu_id;
	int vcpu_idx;
	int ____srcu_idx;
	int mode;
	u64 requests;
	long unsigned int guest_debug;
	struct mutex mutex;
	struct kvm_run *run;
	struct rcuwait wait;
	struct pid *pid;
	rwlock_t pid_lock;
	int sigset_active;
	sigset_t sigset;
	unsigned int halt_poll_ns;
	bool valid_wakeup;
	int mmio_needed;
	int mmio_read_completed;
	int mmio_is_write;
	int mmio_cur_fragment;
	int mmio_nr_fragments;
	struct kvm_mmio_fragment mmio_fragments[2];
	bool wants_to_run;
	bool preempted;
	bool ready;
	bool scheduled_out;
	struct kvm_vcpu_arch arch;
	struct kvm_vcpu_stat stat;
	char stats_id[48];
	struct kvm_dirty_ring dirty_ring;
	struct kvm_memory_slot *last_used_slot;
	u64 last_used_slot_gen;
};

struct kvm_vcpu_pv_apf_data {
	__u32 flags;
	__u32 token;
	__u8 pad[56];
};

struct msr_bitmap_range {
	u32 flags;
	u32 nmsrs;
	u32 base;
	long unsigned int *bitmap;
};

struct kvm_x86_msr_filter {
	u8 count;
	bool default_allow: 1;
	struct msr_bitmap_range ranges[16];
};

struct kvm_x86_nested_ops {
	void (*leave_nested)(struct kvm_vcpu *);
	bool (*is_exception_vmexit)(struct kvm_vcpu *, u8, u32);
	int (*check_events)(struct kvm_vcpu *);
	bool (*has_events)(struct kvm_vcpu *, bool);
	void (*triple_fault)(struct kvm_vcpu *);
	int (*get_state)(struct kvm_vcpu *, struct kvm_nested_state *, unsigned int);
	int (*set_state)(struct kvm_vcpu *, struct kvm_nested_state *, struct kvm_nested_state *);
	bool (*get_nested_state_pages)(struct kvm_vcpu *);
	int (*write_log_dirty)(struct kvm_vcpu *, gpa_t);
	int (*enable_evmcs)(struct kvm_vcpu *, uint16_t *);
	uint16_t (*get_evmcs_version)(struct kvm_vcpu *);
	void (*hv_inject_synthetic_vmexit_post_tlb_flush)(struct kvm_vcpu *);
};

typedef void cpu_emergency_virt_cb(void);

struct x86_instruction_info;

struct msr_data;

struct kvm_x86_ops {
	const char *name;
	int (*check_processor_compatibility)(void);
	int (*enable_virtualization_cpu)(void);
	void (*disable_virtualization_cpu)(void);
	cpu_emergency_virt_cb *emergency_disable_virtualization_cpu;
	void (*hardware_unsetup)(void);
	bool (*has_emulated_msr)(struct kvm *, u32);
	void (*vcpu_after_set_cpuid)(struct kvm_vcpu *);
	unsigned int vm_size;
	int (*vm_init)(struct kvm *);
	void (*vm_destroy)(struct kvm *);
	int (*vcpu_precreate)(struct kvm *);
	int (*vcpu_create)(struct kvm_vcpu *);
	void (*vcpu_free)(struct kvm_vcpu *);
	void (*vcpu_reset)(struct kvm_vcpu *, bool);
	void (*prepare_switch_to_guest)(struct kvm_vcpu *);
	void (*vcpu_load)(struct kvm_vcpu *, int);
	void (*vcpu_put)(struct kvm_vcpu *);
	void (*update_exception_bitmap)(struct kvm_vcpu *);
	int (*get_msr)(struct kvm_vcpu *, struct msr_data *);
	int (*set_msr)(struct kvm_vcpu *, struct msr_data *);
	u64 (*get_segment_base)(struct kvm_vcpu *, int);
	void (*get_segment)(struct kvm_vcpu *, struct kvm_segment *, int);
	int (*get_cpl)(struct kvm_vcpu *);
	int (*get_cpl_no_cache)(struct kvm_vcpu *);
	void (*set_segment)(struct kvm_vcpu *, struct kvm_segment *, int);
	void (*get_cs_db_l_bits)(struct kvm_vcpu *, int *, int *);
	bool (*is_valid_cr0)(struct kvm_vcpu *, long unsigned int);
	void (*set_cr0)(struct kvm_vcpu *, long unsigned int);
	void (*post_set_cr3)(struct kvm_vcpu *, long unsigned int);
	bool (*is_valid_cr4)(struct kvm_vcpu *, long unsigned int);
	void (*set_cr4)(struct kvm_vcpu *, long unsigned int);
	int (*set_efer)(struct kvm_vcpu *, u64);
	void (*get_idt)(struct kvm_vcpu *, struct desc_ptr *);
	void (*set_idt)(struct kvm_vcpu *, struct desc_ptr *);
	void (*get_gdt)(struct kvm_vcpu *, struct desc_ptr *);
	void (*set_gdt)(struct kvm_vcpu *, struct desc_ptr *);
	void (*sync_dirty_debug_regs)(struct kvm_vcpu *);
	void (*set_dr6)(struct kvm_vcpu *, long unsigned int);
	void (*set_dr7)(struct kvm_vcpu *, long unsigned int);
	void (*cache_reg)(struct kvm_vcpu *, enum kvm_reg);
	long unsigned int (*get_rflags)(struct kvm_vcpu *);
	void (*set_rflags)(struct kvm_vcpu *, long unsigned int);
	bool (*get_if_flag)(struct kvm_vcpu *);
	void (*flush_tlb_all)(struct kvm_vcpu *);
	void (*flush_tlb_current)(struct kvm_vcpu *);
	void (*flush_tlb_gva)(struct kvm_vcpu *, gva_t);
	void (*flush_tlb_guest)(struct kvm_vcpu *);
	int (*vcpu_pre_run)(struct kvm_vcpu *);
	enum exit_fastpath_completion (*vcpu_run)(struct kvm_vcpu *, bool);
	int (*handle_exit)(struct kvm_vcpu *, enum exit_fastpath_completion);
	int (*skip_emulated_instruction)(struct kvm_vcpu *);
	void (*update_emulated_instruction)(struct kvm_vcpu *);
	void (*set_interrupt_shadow)(struct kvm_vcpu *, int);
	u32 (*get_interrupt_shadow)(struct kvm_vcpu *);
	void (*patch_hypercall)(struct kvm_vcpu *, unsigned char *);
	void (*inject_irq)(struct kvm_vcpu *, bool);
	void (*inject_nmi)(struct kvm_vcpu *);
	void (*inject_exception)(struct kvm_vcpu *);
	void (*cancel_injection)(struct kvm_vcpu *);
	int (*interrupt_allowed)(struct kvm_vcpu *, bool);
	int (*nmi_allowed)(struct kvm_vcpu *, bool);
	bool (*get_nmi_mask)(struct kvm_vcpu *);
	void (*set_nmi_mask)(struct kvm_vcpu *, bool);
	bool (*is_vnmi_pending)(struct kvm_vcpu *);
	bool (*set_vnmi_pending)(struct kvm_vcpu *);
	void (*enable_nmi_window)(struct kvm_vcpu *);
	void (*enable_irq_window)(struct kvm_vcpu *);
	void (*update_cr8_intercept)(struct kvm_vcpu *, int, int);
	const bool x2apic_icr_is_split;
	const long unsigned int required_apicv_inhibits;
	bool allow_apicv_in_x2apic_without_x2apic_virtualization;
	void (*refresh_apicv_exec_ctrl)(struct kvm_vcpu *);
	void (*hwapic_isr_update)(struct kvm_vcpu *, int);
	void (*load_eoi_exitmap)(struct kvm_vcpu *, u64 *);
	void (*set_virtual_apic_mode)(struct kvm_vcpu *);
	void (*set_apic_access_page_addr)(struct kvm_vcpu *);
	void (*deliver_interrupt)(struct kvm_lapic *, int, int, int);
	int (*sync_pir_to_irr)(struct kvm_vcpu *);
	int (*set_tss_addr)(struct kvm *, unsigned int);
	int (*set_identity_map_addr)(struct kvm *, u64);
	u8 (*get_mt_mask)(struct kvm_vcpu *, gfn_t, bool);
	void (*load_mmu_pgd)(struct kvm_vcpu *, hpa_t, int);
	int (*link_external_spt)(struct kvm *, gfn_t, enum pg_level, void *);
	int (*set_external_spte)(struct kvm *, gfn_t, enum pg_level, kvm_pfn_t);
	int (*free_external_spt)(struct kvm *, gfn_t, enum pg_level, void *);
	int (*remove_external_spte)(struct kvm *, gfn_t, enum pg_level, kvm_pfn_t);
	bool (*has_wbinvd_exit)(void);
	u64 (*get_l2_tsc_offset)(struct kvm_vcpu *);
	u64 (*get_l2_tsc_multiplier)(struct kvm_vcpu *);
	void (*write_tsc_offset)(struct kvm_vcpu *);
	void (*write_tsc_multiplier)(struct kvm_vcpu *);
	void (*get_exit_info)(struct kvm_vcpu *, u32 *, u64 *, u64 *, u32 *, u32 *);
	void (*get_entry_info)(struct kvm_vcpu *, u32 *, u32 *);
	int (*check_intercept)(struct kvm_vcpu *, struct x86_instruction_info *, enum x86_intercept_stage, struct x86_exception *);
	void (*handle_exit_irqoff)(struct kvm_vcpu *);
	int cpu_dirty_log_size;
	void (*update_cpu_dirty_logging)(struct kvm_vcpu *);
	const struct kvm_x86_nested_ops *nested_ops;
	void (*vcpu_blocking)(struct kvm_vcpu *);
	void (*vcpu_unblocking)(struct kvm_vcpu *);
	int (*pi_update_irte)(struct kvm *, unsigned int, uint32_t, bool);
	void (*pi_start_assignment)(struct kvm *);
	void (*apicv_pre_state_restore)(struct kvm_vcpu *);
	void (*apicv_post_state_restore)(struct kvm_vcpu *);
	bool (*dy_apicv_has_pending_interrupt)(struct kvm_vcpu *);
	int (*set_hv_timer)(struct kvm_vcpu *, u64, bool *);
	void (*cancel_hv_timer)(struct kvm_vcpu *);
	void (*setup_mce)(struct kvm_vcpu *);
	int (*dev_get_attr)(u32, u64, u64 *);
	int (*mem_enc_ioctl)(struct kvm *, void *);
	int (*mem_enc_register_region)(struct kvm *, struct kvm_enc_region *);
	int (*mem_enc_unregister_region)(struct kvm *, struct kvm_enc_region *);
	int (*vm_copy_enc_context_from)(struct kvm *, unsigned int);
	int (*vm_move_enc_context_from)(struct kvm *, unsigned int);
	void (*guest_memory_reclaimed)(struct kvm *);
	int (*get_feature_msr)(u32, u64 *);
	int (*check_emulate_instruction)(struct kvm_vcpu *, int, void *, int);
	bool (*apic_init_signal_blocked)(struct kvm_vcpu *);
	int (*enable_l2_tlb_flush)(struct kvm_vcpu *);
	void (*migrate_timers)(struct kvm_vcpu *);
	void (*msr_filter_changed)(struct kvm_vcpu *);
	int (*complete_emulated_msr)(struct kvm_vcpu *, int);
	void (*vcpu_deliver_sipi_vector)(struct kvm_vcpu *, u8);
	long unsigned int (*vcpu_get_apicv_inhibit_reasons)(struct kvm_vcpu *);
	gva_t (*get_untagged_addr)(struct kvm_vcpu *, gva_t, unsigned int);
	void * (*alloc_apic_backing_page)(struct kvm_vcpu *);
	int (*gmem_prepare)(struct kvm *, kvm_pfn_t, gfn_t, int);
	void (*gmem_invalidate)(kvm_pfn_t, kvm_pfn_t);
	int (*private_max_mapping_level)(struct kvm *, kvm_pfn_t);
};

struct kvm_x86_pmu_event_filter {
	__u32 action;
	__u32 nevents;
	__u32 fixed_counter_bitmap;
	__u32 flags;
	__u32 nr_includes;
	__u32 nr_excludes;
	__u64 *includes;
	__u64 *excludes;
	__u64 events[0];
};

struct kyber_cpu_latency {
	atomic_t buckets[48];
};

struct kyber_ctx_queue {
	spinlock_t lock;
	struct list_head rq_list[4];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct sbq_wait {
	struct sbitmap_queue *sbq;
	struct wait_queue_entry wait;
};

struct kyber_hctx_data {
	spinlock_t lock;
	struct list_head rqs[4];
	unsigned int cur_domain;
	unsigned int batching;
	struct kyber_ctx_queue *kcqs;
	struct sbitmap kcq_map[4];
	struct sbq_wait domain_wait[4];
	struct sbq_wait_state *domain_ws[4];
	atomic_t wait_index[4];
};

struct kyber_queue_data {
	struct request_queue *q;
	dev_t dev;
	struct sbitmap_queue domain_tokens[4];
	unsigned int async_depth;
	struct kyber_cpu_latency *cpu_latency;
	struct timer_list timer;
	unsigned int latency_buckets[48];
	long unsigned int latency_timeout[3];
	int domain_p99[3];
	u64 latency_targets[3];
};

union l1_cache {
	struct {
		unsigned int line_size: 8;
		unsigned int lines_per_tag: 8;
		unsigned int assoc: 8;
		unsigned int size_in_kb: 8;
	};
	unsigned int val;
};

union l2_cache {
	struct {
		unsigned int line_size: 8;
		unsigned int lines_per_tag: 4;
		unsigned int assoc: 4;
		unsigned int size_in_kb: 16;
	};
	unsigned int val;
};

union l3_cache {
	struct {
		unsigned int line_size: 8;
		unsigned int lines_per_tag: 4;
		unsigned int assoc: 4;
		unsigned int res: 2;
		unsigned int size_encoded: 14;
	};
	unsigned int val;
};

struct latch_tree_ops {
	bool (*less)(struct latch_tree_node *, struct latch_tree_node *);
	int (*comp)(void *, struct latch_tree_node *);
};

struct latch_tree_root {
	seqcount_latch_t seq;
	struct rb_root tree[2];
};

struct latched_seq {
	seqcount_latch_t latch;
	u64 val[2];
};

struct sched_domain;

struct lb_env {
	struct sched_domain *sd;
	struct rq *src_rq;
	int src_cpu;
	int dst_cpu;
	struct rq *dst_rq;
	struct cpumask *dst_grpmask;
	int new_dst_cpu;
	enum cpu_idle_type idle;
	long int imbalance;
	struct cpumask *cpus;
	unsigned int flags;
	unsigned int loop;
	unsigned int loop_break;
	unsigned int loop_max;
	enum fbq_type fbq_type;
	enum migration_type migration_type;
	struct list_head tasks;
};

struct ld_semaphore {
	atomic_long_t count;
	raw_spinlock_t wait_lock;
	unsigned int wait_readers;
	struct list_head read_wait;
	struct list_head write_wait;
};

struct ldsem_waiter {
	struct list_head list;
	struct task_struct *task;
};

struct ldt_struct {
	struct desc_struct *entries;
	unsigned int nr_entries;
	int slot;
};

struct ldttss_desc {
	u16 limit0;
	u16 base0;
	u16 base1: 8;
	u16 type: 5;
	u16 dpl: 2;
	u16 p: 1;
	u16 limit1: 4;
	u16 zero0: 3;
	u16 g: 1;
	u16 base2: 8;
	u32 base3;
	u32 zero1;
};

typedef struct ldttss_desc ldt_desc;

typedef struct ldttss_desc tss_desc;

struct lease_manager_operations {
	bool (*lm_break)(struct file_lease *);
	int (*lm_change)(struct file_lease *, int, struct list_head *);
	void (*lm_setup)(struct file_lease *, void **);
	bool (*lm_breaker_owns_lease)(struct file_lease *);
};

struct mc_subled;

struct led_classdev_mc {
	struct led_classdev led_cdev;
	unsigned int num_colors;
	struct mc_subled *subled_info;
};

struct led_hw_trigger_type {
	int dummy;
};

struct led_init_data {
	struct fwnode_handle *fwnode;
	const char *default_label;
	const char *devicename;
	bool devname_mandatory;
};

struct led_lookup_data {
	struct list_head list;
	const char *provider;
	const char *dev_id;
	const char *con_id;
};

struct led_pattern {
	u32 delta_t;
	int brightness;
};

struct led_properties {
	u32 color;
	bool color_present;
	const char *function;
	u32 func_enum;
	bool func_enum_present;
	const char *label;
};

struct legacy_fs_context {
	char *legacy_data;
	size_t data_size;
	enum legacy_fs_param param_type;
};

struct legacy_pic {
	int nr_legacy_irqs;
	struct irq_chip *chip;
	void (*mask)(unsigned int);
	void (*unmask)(unsigned int);
	void (*mask_all)(void);
	void (*restore_mask)(void);
	void (*init)(int);
	int (*probe)(void);
	int (*irq_pending)(unsigned int);
	void (*make_irq)(unsigned int);
};

struct legacy_ring {
	struct intel_gt *gt;
	u8 class;
	u8 instance;
};

struct level_datum {
	struct mls_level level;
	unsigned char isalias;
};

struct lg4ff_alternate_mode {
	const u16 product_id;
	const char *tag;
	const char *name;
};

struct lg4ff_compat_mode_switch {
	const u8 cmd_count;
	const u8 cmd[0];
};

struct lg4ff_wheel_data {
	const u32 product_id;
	u16 combine;
	u16 range;
	const u16 min_range;
	const u16 max_range;
	u8 led_state;
	struct led_classdev *led[5];
	const u32 alternate_modes;
	const char * const real_tag;
	const char * const real_name;
	const u16 real_product_id;
	void (*set_range)(struct hid_device *, u16);
};

struct lg4ff_device_entry {
	spinlock_t report_lock;
	struct hid_report *report;
	struct lg4ff_wheel_data wdata;
};

struct lg4ff_multimode_wheel {
	const u16 product_id;
	const u32 alternate_modes;
	const char *real_tag;
	const char *real_name;
};

struct lg4ff_wheel {
	const u32 product_id;
	const short int *ff_effects;
	const u16 min_range;
	const u16 max_range;
	void (*set_range)(struct hid_device *, u16);
};

struct lg4ff_wheel_ident_info {
	const u32 modes;
	const u16 mask;
	const u16 result;
	const u16 real_product_id;
};

struct lg_drv_data {
	long unsigned int quirks;
	void *device_props;
};

struct lg_g15_led {
	struct led_classdev cdev;
	enum led_brightness brightness;
	enum lg_g15_led_type led;
	u8 red;
	u8 green;
	u8 blue;
};

struct lg_g15_data {
	u8 transfer_buf[20];
	struct mutex mutex;
	struct work_struct work;
	struct input_dev *input;
	struct hid_device *hdev;
	enum lg_g15_model model;
	struct lg_g15_led leds[6];
	bool game_mode_enabled;
};

struct lifebook_data {
	struct input_dev *dev2;
	char phys[32];
};

struct limit_names {
	const char *name;
	const char *unit;
};

struct linear_c {
	struct dm_dev *dev;
	sector_t start;
};

struct linger {
	int l_onoff;
	int l_linger;
};

struct link_config_limits {
	int min_rate;
	int max_rate;
	int min_lane_count;
	int max_lane_count;
	struct {
		int min_bpp;
		int max_bpp;
	} pipe;
	struct {
		int min_bpp_x16;
		int max_bpp_x16;
	} link;
};

struct link_container {
	struct ieee80211_link_data data;
	struct ieee80211_bss_conf conf;
};

struct link_ctl_info {
	snd_ctl_elem_type_t type;
	int count;
	int min_val;
	int max_val;
};

struct snd_ctl_elem_id {
	unsigned int numid;
	snd_ctl_elem_iface_t iface;
	unsigned int device;
	unsigned int subdevice;
	unsigned char name[44];
	unsigned int index;
};

struct snd_ctl_elem_info;

typedef int snd_kcontrol_info_t(struct snd_kcontrol *, struct snd_ctl_elem_info *);

struct snd_ctl_elem_value;

typedef int snd_kcontrol_get_t(struct snd_kcontrol *, struct snd_ctl_elem_value *);

typedef int snd_kcontrol_put_t(struct snd_kcontrol *, struct snd_ctl_elem_value *);

typedef int snd_kcontrol_tlv_rw_t(struct snd_kcontrol *, int, unsigned int, unsigned int *);

struct snd_ctl_file;

struct snd_kcontrol_volatile {
	struct snd_ctl_file *owner;
	unsigned int access;
};

struct snd_kcontrol {
	struct list_head list;
	struct snd_ctl_elem_id id;
	unsigned int count;
	snd_kcontrol_info_t *info;
	snd_kcontrol_get_t *get;
	snd_kcontrol_put_t *put;
	union {
		snd_kcontrol_tlv_rw_t *c;
		const unsigned int *p;
	} tlv;
	long unsigned int private_value;
	void *private_data;
	void (*private_free)(struct snd_kcontrol *);
	struct snd_kcontrol_volatile vd[0];
};

struct link_master;

struct link_follower {
	struct list_head list;
	struct link_master *master;
	struct link_ctl_info info;
	int vals[2];
	unsigned int flags;
	struct snd_kcontrol *kctl;
	struct snd_kcontrol follower;
};

struct link_master {
	struct list_head followers;
	struct link_ctl_info info;
	int val;
	unsigned int tlv[4];
	void (*hook)(void *, int);
	void *hook_private_data;
};

struct link_mode_info {
	int speed;
	u8 lanes;
	u8 duplex;
};

struct link_sta_info {
	u8 addr[6];
	u8 link_id;
	u8 op_mode_nss;
	u8 capa_nss;
	struct rhlist_head link_hash_node;
	struct sta_info *sta;
	struct ieee80211_key *gtk[8];
	struct ieee80211_sta_rx_stats *pcpu_rx_stats;
	struct ieee80211_sta_rx_stats rx_stats;
	struct {
		struct ewma_signal signal;
		struct ewma_signal chain_signal[4];
	} rx_stats_avg;
	struct {
		long unsigned int filtered;
		long unsigned int retry_failed;
		long unsigned int retry_count;
		unsigned int lost_packets;
		long unsigned int last_pkt_time;
		u64 msdu_retries[17];
		u64 msdu_failed[17];
		long unsigned int last_ack;
		s8 last_ack_signal;
		bool ack_signal_filled;
		struct ewma_avg_signal avg_ack_signal;
	} status_stats;
	struct {
		u64 packets[4];
		u64 bytes[4];
		struct ieee80211_tx_rate last_rate;
		struct rate_info last_rate_info;
		u64 msdu[17];
	} tx_stats;
	enum ieee80211_sta_rx_bandwidth cur_max_bandwidth;
	enum ieee80211_sta_rx_bandwidth rx_omi_bw_rx;
	enum ieee80211_sta_rx_bandwidth rx_omi_bw_tx;
	enum ieee80211_sta_rx_bandwidth rx_omi_bw_staging;
	struct ieee80211_link_sta *pub;
};

struct link_station_del_parameters {
	const u8 *mld_mac;
	u32 link_id;
};

struct sta_txpwr {
	s16 power;
	enum nl80211_tx_power_setting type;
};

struct link_station_parameters {
	const u8 *mld_mac;
	int link_id;
	const u8 *link_mac;
	const u8 *supported_rates;
	u8 supported_rates_len;
	const struct ieee80211_ht_cap *ht_capa;
	const struct ieee80211_vht_cap *vht_capa;
	u8 opmode_notif;
	bool opmode_notif_used;
	const struct ieee80211_he_cap_elem *he_capa;
	u8 he_capa_len;
	struct sta_txpwr txpwr;
	bool txpwr_set;
	const struct ieee80211_he_6ghz_capa *he_6ghz_capa;
	const struct ieee80211_eht_cap_elem *eht_capa;
	u8 eht_capa_len;
};

struct linked_page {
	struct linked_page *next;
	char data[4088];
};

struct linked_reg {
	u8 frameno;
	union {
		u8 spi;
		u8 regno;
	};
	bool is_reg;
};

struct linked_regs {
	int cnt;
	struct linked_reg entries[6];
};

struct linkinfo_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_link_ksettings ksettings;
	struct ethtool_link_settings *lsettings;
};

struct linkmodes_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_link_ksettings ksettings;
	struct ethtool_link_settings *lsettings;
	bool peer_empty;
};

struct linkstate_reply_data {
	struct ethnl_reply_data base;
	int link;
	int sqi;
	int sqi_max;
	struct ethtool_link_ext_stats link_stats;
	bool link_ext_state_provided;
	struct ethtool_link_ext_state_info ethtool_link_ext_state_info;
};

struct linux_binprm;

struct linux_binfmt {
	struct list_head lh;
	struct module *module;
	int (*load_binary)(struct linux_binprm *);
	int (*load_shlib)(struct file *);
	int (*core_dump)(struct coredump_params *);
	long unsigned int min_coredump;
};

struct rlimit {
	__kernel_ulong_t rlim_cur;
	__kernel_ulong_t rlim_max;
};

struct linux_binprm {
	struct vm_area_struct *vma;
	long unsigned int vma_pages;
	long unsigned int argmin;
	struct mm_struct *mm;
	long unsigned int p;
	unsigned int have_execfd: 1;
	unsigned int execfd_creds: 1;
	unsigned int secureexec: 1;
	unsigned int point_of_no_return: 1;
	unsigned int comm_from_dentry: 1;
	unsigned int is_check: 1;
	struct file *executable;
	struct file *interpreter;
	struct file *file;
	struct cred *cred;
	int unsafe;
	unsigned int per_clear;
	int argc;
	int envc;
	const char *filename;
	const char *interp;
	const char *fdpath;
	unsigned int interp_flags;
	int execfd;
	long unsigned int loader;
	long unsigned int exec;
	struct rlimit rlim_stack;
	char buf[256];
};

struct linux_binprm__safe_trusted {
	struct file *file;
};

struct linux_dirent {
	long unsigned int d_ino;
	long unsigned int d_off;
	short unsigned int d_reclen;
	char d_name[0];
};

struct linux_dirent64 {
	u64 d_ino;
	s64 d_off;
	short unsigned int d_reclen;
	unsigned char d_type;
	char d_name[0];
};

struct linux_efi_initrd {
	long unsigned int base;
	long unsigned int size;
};

struct linux_efi_memreserve {
	int size;
	atomic_t count;
	phys_addr_t next;
	struct {
		phys_addr_t base;
		phys_addr_t size;
	} entry[0];
};

struct linux_efi_random_seed {
	u32 size;
	u8 bits[0];
};

struct linux_efi_tpm_eventlog {
	u32 size;
	u32 final_events_preboot_size;
	u8 version;
	u8 log[0];
};

struct linux_mib {
	long unsigned int mibs[133];
};

struct list_lru_node;

struct list_lru {
	struct list_lru_node *node;
};

struct list_lru_one {
	struct list_head list;
	long int nr_items;
	spinlock_t lock;
};

struct list_lru_node {
	struct list_lru_one lru;
	atomic_long_t nr_items;
	long: 64;
	long: 64;
	long: 64;
};

struct listener {
	struct list_head list;
	pid_t pid;
	char valid;
};

struct listener_list {
	struct rw_semaphore sem;
	struct list_head list;
};

struct listeners {
	struct callback_head rcu;
	long unsigned int masks[0];
};

struct load_info {
	const char *name;
	struct module *mod;
	Elf64_Ehdr *hdr;
	long unsigned int len;
	Elf64_Shdr *sechdrs;
	char *secstrings;
	char *strtab;
	long unsigned int symoffs;
	long unsigned int stroffs;
	long unsigned int init_typeoffs;
	long unsigned int core_typeoffs;
	bool sig_ok;
	long unsigned int mod_kallsyms_init_off;
	struct {
		unsigned int sym;
		unsigned int str;
		unsigned int mod;
		unsigned int vers;
		unsigned int info;
		unsigned int pcpu;
		unsigned int vers_ext_crc;
		unsigned int vers_ext_name;
	} index;
};

struct location;

struct loc_track {
	long unsigned int max;
	long unsigned int count;
	struct location *loc;
	loff_t idx;
};

struct local_event {
	local_lock_t lock;
	__u32 count;
};

struct local_ports {
	u32 range;
	bool warned;
};

struct location {
	depot_stack_handle_t handle;
	long unsigned int count;
	long unsigned int addr;
	long unsigned int waste;
	long long int sum_time;
	long int min_time;
	long int max_time;
	long int min_pid;
	long int max_pid;
	long unsigned int cpus[1];
	nodemask_t nodes;
};

struct lock_manager {
	struct list_head list;
	bool block_opens;
};

struct lock_manager_operations {
	void *lm_mod_owner;
	fl_owner_t (*lm_get_owner)(fl_owner_t);
	void (*lm_put_owner)(fl_owner_t);
	void (*lm_notify)(struct file_lock *);
	int (*lm_grant)(struct file_lock *, int);
	bool (*lm_lock_expirable)(struct file_lock *);
	void (*lm_expire_lock)(void);
};

struct lockd_net {
	unsigned int nlmsvc_users;
	long unsigned int next_gc;
	long unsigned int nrhosts;
	struct delayed_work grace_period_end;
	struct lock_manager lockd_manager;
	struct list_head nsm_handles;
};

struct locks_iterator {
	int li_cpu;
	loff_t li_pos;
};

struct log_header_core {
	uint32_t magic;
	uint32_t version;
	uint64_t nr_regions;
};

struct log_header_disk;

struct log_c {
	struct dm_target *ti;
	int touched_dirtied;
	int touched_cleaned;
	int flush_failed;
	uint32_t region_size;
	unsigned int region_count;
	region_t sync_count;
	unsigned int bitset_uint32_count;
	uint32_t *clean_bits;
	uint32_t *sync_bits;
	uint32_t *recovering_bits;
	int sync_search;
	enum sync sync;
	struct dm_io_request io_req;
	int log_dev_failed;
	int log_dev_flush_failed;
	struct dm_dev *log_dev;
	struct log_header_core header;
	struct dm_io_region header_location;
	struct log_header_disk *disk_header;
};

struct log_header_disk {
	__le32 magic;
	__le32 version;
	__le64 nr_regions;
};

struct logic_pio_host_ops {
	u32 (*in)(void *, long unsigned int, size_t);
	void (*out)(void *, long unsigned int, u32, size_t);
	u32 (*ins)(void *, long unsigned int, void *, size_t, unsigned int);
	void (*outs)(void *, long unsigned int, const void *, size_t, unsigned int);
};

struct logic_pio_hwaddr {
	struct list_head list;
	const struct fwnode_handle *fwnode;
	resource_size_t hw_start;
	resource_size_t io_start;
	resource_size_t size;
	long unsigned int flags;
	void *hostdata;
	const struct logic_pio_host_ops *ops;
};

struct lookup_args {
	int offset;
	const struct in6_addr *addr;
};

struct loop_cmd {
	struct list_head list_entry;
	bool use_aio;
	atomic_t ref;
	long int ret;
	struct kiocb iocb;
	struct bio_vec *bvec;
	struct cgroup_subsys_state *blkcg_css;
	struct cgroup_subsys_state *memcg_css;
};

struct loop_info64 {
	__u64 lo_device;
	__u64 lo_inode;
	__u64 lo_rdevice;
	__u64 lo_offset;
	__u64 lo_sizelimit;
	__u32 lo_number;
	__u32 lo_encrypt_type;
	__u32 lo_encrypt_key_size;
	__u32 lo_flags;
	__u8 lo_file_name[64];
	__u8 lo_crypt_name[64];
	__u8 lo_encrypt_key[32];
	__u64 lo_init[2];
};

struct loop_config {
	__u32 fd;
	__u32 block_size;
	struct loop_info64 info;
	__u64 __reserved[8];
};

struct loop_device {
	int lo_number;
	loff_t lo_offset;
	loff_t lo_sizelimit;
	int lo_flags;
	char lo_file_name[64];
	struct file *lo_backing_file;
	struct block_device *lo_device;
	gfp_t old_gfp_mask;
	spinlock_t lo_lock;
	int lo_state;
	spinlock_t lo_work_lock;
	struct workqueue_struct *workqueue;
	struct work_struct rootcg_work;
	struct list_head rootcg_cmd_list;
	struct list_head idle_worker_list;
	struct rb_root worker_tree;
	struct timer_list timer;
	bool sysfs_inited;
	struct request_queue *lo_queue;
	struct blk_mq_tag_set tag_set;
	struct gendisk *lo_disk;
	struct mutex lo_mutex;
	bool idr_visible;
};

struct loop_info {
	int lo_number;
	__kernel_old_dev_t lo_device;
	long unsigned int lo_inode;
	__kernel_old_dev_t lo_rdevice;
	int lo_offset;
	int lo_encrypt_type;
	int lo_encrypt_key_size;
	int lo_flags;
	char lo_name[64];
	unsigned char lo_encrypt_key[32];
	long unsigned int lo_init[2];
	char reserved[4];
};

struct loop_worker {
	struct rb_node rb_node;
	struct work_struct work;
	struct list_head cmd_list;
	struct list_head idle_list;
	struct loop_device *lo;
	struct cgroup_subsys_state *blkcg_css;
	long unsigned int last_ran_at;
};

union lower_chunk {
	union lower_chunk *next;
	long unsigned int data[256];
};

struct lpi_constraints {
	acpi_handle handle;
	int min_dstate;
};

struct lpi_device_constraint {
	int uid;
	int min_dstate;
	int function_states;
};

struct lpi_device_constraint_amd {
	char *name;
	int enabled;
	int function_states;
	int min_dstate;
};

struct lpi_device_info {
	char *name;
	int enabled;
	union acpi_object *package;
};

struct lpit_residency_info {
	struct acpi_generic_address gaddr;
	u64 frequency;
	void *iomem_addr;
};

struct lpm_trie_node;

struct lpm_trie {
	struct bpf_map map;
	struct lpm_trie_node *root;
	struct bpf_mem_alloc ma;
	size_t n_entries;
	size_t max_prefixlen;
	size_t data_size;
	raw_spinlock_t lock;
};

struct lpm_trie_node {
	struct lpm_trie_node *child[2];
	u32 prefixlen;
	u32 flags;
	u8 data[0];
};

struct lpss8250_board;

struct lpss8250 {
	struct dw8250_port_data data;
	struct lpss8250_board *board;
	struct dw_dma_chip dma_chip;
	struct dw_dma_slave dma_param;
	u8 dma_maxburst;
};

struct lpss8250_board {
	long unsigned int freq;
	unsigned int base_baud;
	int (*setup)(struct lpss8250 *, struct uart_port *);
	void (*exit)(struct lpss8250 *);
};

struct lri {
	i915_reg_t reg;
	u32 value;
};

struct zswap_lruvec_state {};

struct lruvec {
	struct list_head lists[5];
	spinlock_t lru_lock;
	long unsigned int anon_cost;
	long unsigned int file_cost;
	atomic_long_t nonresident_age;
	long unsigned int refaults[2];
	long unsigned int flags;
	struct zswap_lruvec_state zswap_lruvec_state;
};

struct skcipher_alg_common {
	unsigned int min_keysize;
	unsigned int max_keysize;
	unsigned int ivsize;
	unsigned int chunksize;
	unsigned int statesize;
	struct crypto_alg base;
};

struct lskcipher_alg {
	int (*setkey)(struct crypto_lskcipher *, const u8 *, unsigned int);
	int (*encrypt)(struct crypto_lskcipher *, const u8 *, u8 *, unsigned int, u8 *, u32);
	int (*decrypt)(struct crypto_lskcipher *, const u8 *, u8 *, unsigned int, u8 *, u32);
	int (*init)(struct crypto_lskcipher *);
	void (*exit)(struct crypto_lskcipher *);
	struct skcipher_alg_common co;
};

struct lskcipher_instance {
	void (*free)(struct lskcipher_instance *);
	union {
		struct {
			char head[64];
			struct crypto_instance base;
		} s;
		struct lskcipher_alg alg;
	};
};

struct lsm_blob_sizes {
	int lbs_cred;
	int lbs_file;
	int lbs_ib;
	int lbs_inode;
	int lbs_sock;
	int lbs_superblock;
	int lbs_ipc;
	int lbs_key;
	int lbs_msg_msg;
	int lbs_perf_event;
	int lbs_task;
	int lbs_xattr_count;
	int lbs_tun_dev;
	int lbs_bdev;
};

struct lsm_context {
	char *context;
	u32 len;
	int id;
};

struct lsm_ctx {
	__u64 id;
	__u64 flags;
	__u64 len;
	__u64 ctx_len;
	__u8 ctx[0];
};

struct lsm_ibendport_audit {
	const char *dev_name;
	u8 port;
};

struct lsm_ibpkey_audit {
	u64 subnet_prefix;
	u16 pkey;
};

struct lsm_id {
	const char *name;
	u64 id;
};

struct lsm_info {
	const char *name;
	enum lsm_order order;
	long unsigned int flags;
	int *enabled;
	int (*init)(void);
	struct lsm_blob_sizes *blobs;
};

struct lsm_ioctlop_audit {
	struct path path;
	u16 cmd;
};

struct lsm_network_audit {
	int netif;
	const struct sock *sk;
	u16 family;
	__be16 dport;
	__be16 sport;
	union {
		struct {
			__be32 daddr;
			__be32 saddr;
		} v4;
		struct {
			struct in6_addr daddr;
			struct in6_addr saddr;
		} v6;
	} fam;
};

struct security_hook_list;

struct lsm_static_call {
	struct static_call_key *key;
	void *trampoline;
	struct security_hook_list *hl;
	struct static_key_false *active;
};

struct lsm_static_calls_table {
	struct lsm_static_call binder_set_context_mgr[2];
	struct lsm_static_call binder_transaction[2];
	struct lsm_static_call binder_transfer_binder[2];
	struct lsm_static_call binder_transfer_file[2];
	struct lsm_static_call ptrace_access_check[2];
	struct lsm_static_call ptrace_traceme[2];
	struct lsm_static_call capget[2];
	struct lsm_static_call capset[2];
	struct lsm_static_call capable[2];
	struct lsm_static_call quotactl[2];
	struct lsm_static_call quota_on[2];
	struct lsm_static_call syslog[2];
	struct lsm_static_call settime[2];
	struct lsm_static_call vm_enough_memory[2];
	struct lsm_static_call bprm_creds_for_exec[2];
	struct lsm_static_call bprm_creds_from_file[2];
	struct lsm_static_call bprm_check_security[2];
	struct lsm_static_call bprm_committing_creds[2];
	struct lsm_static_call bprm_committed_creds[2];
	struct lsm_static_call fs_context_submount[2];
	struct lsm_static_call fs_context_dup[2];
	struct lsm_static_call fs_context_parse_param[2];
	struct lsm_static_call sb_alloc_security[2];
	struct lsm_static_call sb_delete[2];
	struct lsm_static_call sb_free_security[2];
	struct lsm_static_call sb_free_mnt_opts[2];
	struct lsm_static_call sb_eat_lsm_opts[2];
	struct lsm_static_call sb_mnt_opts_compat[2];
	struct lsm_static_call sb_remount[2];
	struct lsm_static_call sb_kern_mount[2];
	struct lsm_static_call sb_show_options[2];
	struct lsm_static_call sb_statfs[2];
	struct lsm_static_call sb_mount[2];
	struct lsm_static_call sb_umount[2];
	struct lsm_static_call sb_pivotroot[2];
	struct lsm_static_call sb_set_mnt_opts[2];
	struct lsm_static_call sb_clone_mnt_opts[2];
	struct lsm_static_call move_mount[2];
	struct lsm_static_call dentry_init_security[2];
	struct lsm_static_call dentry_create_files_as[2];
	struct lsm_static_call path_notify[2];
	struct lsm_static_call inode_alloc_security[2];
	struct lsm_static_call inode_free_security[2];
	struct lsm_static_call inode_free_security_rcu[2];
	struct lsm_static_call inode_init_security[2];
	struct lsm_static_call inode_init_security_anon[2];
	struct lsm_static_call inode_create[2];
	struct lsm_static_call inode_post_create_tmpfile[2];
	struct lsm_static_call inode_link[2];
	struct lsm_static_call inode_unlink[2];
	struct lsm_static_call inode_symlink[2];
	struct lsm_static_call inode_mkdir[2];
	struct lsm_static_call inode_rmdir[2];
	struct lsm_static_call inode_mknod[2];
	struct lsm_static_call inode_rename[2];
	struct lsm_static_call inode_readlink[2];
	struct lsm_static_call inode_follow_link[2];
	struct lsm_static_call inode_permission[2];
	struct lsm_static_call inode_setattr[2];
	struct lsm_static_call inode_post_setattr[2];
	struct lsm_static_call inode_getattr[2];
	struct lsm_static_call inode_xattr_skipcap[2];
	struct lsm_static_call inode_setxattr[2];
	struct lsm_static_call inode_post_setxattr[2];
	struct lsm_static_call inode_getxattr[2];
	struct lsm_static_call inode_listxattr[2];
	struct lsm_static_call inode_removexattr[2];
	struct lsm_static_call inode_post_removexattr[2];
	struct lsm_static_call inode_set_acl[2];
	struct lsm_static_call inode_post_set_acl[2];
	struct lsm_static_call inode_get_acl[2];
	struct lsm_static_call inode_remove_acl[2];
	struct lsm_static_call inode_post_remove_acl[2];
	struct lsm_static_call inode_need_killpriv[2];
	struct lsm_static_call inode_killpriv[2];
	struct lsm_static_call inode_getsecurity[2];
	struct lsm_static_call inode_setsecurity[2];
	struct lsm_static_call inode_listsecurity[2];
	struct lsm_static_call inode_getlsmprop[2];
	struct lsm_static_call inode_copy_up[2];
	struct lsm_static_call inode_copy_up_xattr[2];
	struct lsm_static_call inode_setintegrity[2];
	struct lsm_static_call kernfs_init_security[2];
	struct lsm_static_call file_permission[2];
	struct lsm_static_call file_alloc_security[2];
	struct lsm_static_call file_release[2];
	struct lsm_static_call file_free_security[2];
	struct lsm_static_call file_ioctl[2];
	struct lsm_static_call file_ioctl_compat[2];
	struct lsm_static_call mmap_addr[2];
	struct lsm_static_call mmap_file[2];
	struct lsm_static_call file_mprotect[2];
	struct lsm_static_call file_lock[2];
	struct lsm_static_call file_fcntl[2];
	struct lsm_static_call file_set_fowner[2];
	struct lsm_static_call file_send_sigiotask[2];
	struct lsm_static_call file_receive[2];
	struct lsm_static_call file_open[2];
	struct lsm_static_call file_post_open[2];
	struct lsm_static_call file_truncate[2];
	struct lsm_static_call task_alloc[2];
	struct lsm_static_call task_free[2];
	struct lsm_static_call cred_alloc_blank[2];
	struct lsm_static_call cred_free[2];
	struct lsm_static_call cred_prepare[2];
	struct lsm_static_call cred_transfer[2];
	struct lsm_static_call cred_getsecid[2];
	struct lsm_static_call cred_getlsmprop[2];
	struct lsm_static_call kernel_act_as[2];
	struct lsm_static_call kernel_create_files_as[2];
	struct lsm_static_call kernel_module_request[2];
	struct lsm_static_call kernel_load_data[2];
	struct lsm_static_call kernel_post_load_data[2];
	struct lsm_static_call kernel_read_file[2];
	struct lsm_static_call kernel_post_read_file[2];
	struct lsm_static_call task_fix_setuid[2];
	struct lsm_static_call task_fix_setgid[2];
	struct lsm_static_call task_fix_setgroups[2];
	struct lsm_static_call task_setpgid[2];
	struct lsm_static_call task_getpgid[2];
	struct lsm_static_call task_getsid[2];
	struct lsm_static_call current_getlsmprop_subj[2];
	struct lsm_static_call task_getlsmprop_obj[2];
	struct lsm_static_call task_setnice[2];
	struct lsm_static_call task_setioprio[2];
	struct lsm_static_call task_getioprio[2];
	struct lsm_static_call task_prlimit[2];
	struct lsm_static_call task_setrlimit[2];
	struct lsm_static_call task_setscheduler[2];
	struct lsm_static_call task_getscheduler[2];
	struct lsm_static_call task_movememory[2];
	struct lsm_static_call task_kill[2];
	struct lsm_static_call task_prctl[2];
	struct lsm_static_call task_to_inode[2];
	struct lsm_static_call userns_create[2];
	struct lsm_static_call ipc_permission[2];
	struct lsm_static_call ipc_getlsmprop[2];
	struct lsm_static_call msg_msg_alloc_security[2];
	struct lsm_static_call msg_msg_free_security[2];
	struct lsm_static_call msg_queue_alloc_security[2];
	struct lsm_static_call msg_queue_free_security[2];
	struct lsm_static_call msg_queue_associate[2];
	struct lsm_static_call msg_queue_msgctl[2];
	struct lsm_static_call msg_queue_msgsnd[2];
	struct lsm_static_call msg_queue_msgrcv[2];
	struct lsm_static_call shm_alloc_security[2];
	struct lsm_static_call shm_free_security[2];
	struct lsm_static_call shm_associate[2];
	struct lsm_static_call shm_shmctl[2];
	struct lsm_static_call shm_shmat[2];
	struct lsm_static_call sem_alloc_security[2];
	struct lsm_static_call sem_free_security[2];
	struct lsm_static_call sem_associate[2];
	struct lsm_static_call sem_semctl[2];
	struct lsm_static_call sem_semop[2];
	struct lsm_static_call netlink_send[2];
	struct lsm_static_call d_instantiate[2];
	struct lsm_static_call getselfattr[2];
	struct lsm_static_call setselfattr[2];
	struct lsm_static_call getprocattr[2];
	struct lsm_static_call setprocattr[2];
	struct lsm_static_call ismaclabel[2];
	struct lsm_static_call secid_to_secctx[2];
	struct lsm_static_call lsmprop_to_secctx[2];
	struct lsm_static_call secctx_to_secid[2];
	struct lsm_static_call release_secctx[2];
	struct lsm_static_call inode_invalidate_secctx[2];
	struct lsm_static_call inode_notifysecctx[2];
	struct lsm_static_call inode_setsecctx[2];
	struct lsm_static_call inode_getsecctx[2];
	struct lsm_static_call unix_stream_connect[2];
	struct lsm_static_call unix_may_send[2];
	struct lsm_static_call socket_create[2];
	struct lsm_static_call socket_post_create[2];
	struct lsm_static_call socket_socketpair[2];
	struct lsm_static_call socket_bind[2];
	struct lsm_static_call socket_connect[2];
	struct lsm_static_call socket_listen[2];
	struct lsm_static_call socket_accept[2];
	struct lsm_static_call socket_sendmsg[2];
	struct lsm_static_call socket_recvmsg[2];
	struct lsm_static_call socket_getsockname[2];
	struct lsm_static_call socket_getpeername[2];
	struct lsm_static_call socket_getsockopt[2];
	struct lsm_static_call socket_setsockopt[2];
	struct lsm_static_call socket_shutdown[2];
	struct lsm_static_call socket_sock_rcv_skb[2];
	struct lsm_static_call socket_getpeersec_stream[2];
	struct lsm_static_call socket_getpeersec_dgram[2];
	struct lsm_static_call sk_alloc_security[2];
	struct lsm_static_call sk_free_security[2];
	struct lsm_static_call sk_clone_security[2];
	struct lsm_static_call sk_getsecid[2];
	struct lsm_static_call sock_graft[2];
	struct lsm_static_call inet_conn_request[2];
	struct lsm_static_call inet_csk_clone[2];
	struct lsm_static_call inet_conn_established[2];
	struct lsm_static_call secmark_relabel_packet[2];
	struct lsm_static_call secmark_refcount_inc[2];
	struct lsm_static_call secmark_refcount_dec[2];
	struct lsm_static_call req_classify_flow[2];
	struct lsm_static_call tun_dev_alloc_security[2];
	struct lsm_static_call tun_dev_create[2];
	struct lsm_static_call tun_dev_attach_queue[2];
	struct lsm_static_call tun_dev_attach[2];
	struct lsm_static_call tun_dev_open[2];
	struct lsm_static_call sctp_assoc_request[2];
	struct lsm_static_call sctp_bind_connect[2];
	struct lsm_static_call sctp_sk_clone[2];
	struct lsm_static_call sctp_assoc_established[2];
	struct lsm_static_call mptcp_add_subflow[2];
	struct lsm_static_call key_alloc[2];
	struct lsm_static_call key_permission[2];
	struct lsm_static_call key_getsecurity[2];
	struct lsm_static_call key_post_create_or_update[2];
	struct lsm_static_call audit_rule_init[2];
	struct lsm_static_call audit_rule_known[2];
	struct lsm_static_call audit_rule_match[2];
	struct lsm_static_call audit_rule_free[2];
	struct lsm_static_call bpf[2];
	struct lsm_static_call bpf_map[2];
	struct lsm_static_call bpf_prog[2];
	struct lsm_static_call bpf_map_create[2];
	struct lsm_static_call bpf_map_free[2];
	struct lsm_static_call bpf_prog_load[2];
	struct lsm_static_call bpf_prog_free[2];
	struct lsm_static_call bpf_token_create[2];
	struct lsm_static_call bpf_token_free[2];
	struct lsm_static_call bpf_token_cmd[2];
	struct lsm_static_call bpf_token_capable[2];
	struct lsm_static_call locked_down[2];
	struct lsm_static_call perf_event_open[2];
	struct lsm_static_call perf_event_alloc[2];
	struct lsm_static_call perf_event_read[2];
	struct lsm_static_call perf_event_write[2];
	struct lsm_static_call uring_override_creds[2];
	struct lsm_static_call uring_sqpoll[2];
	struct lsm_static_call uring_cmd[2];
	struct lsm_static_call initramfs_populated[2];
	struct lsm_static_call bdev_alloc_security[2];
	struct lsm_static_call bdev_free_security[2];
	struct lsm_static_call bdev_setintegrity[2];
};

struct lwq {
	spinlock_t lock;
	struct llist_node *ready;
	struct llist_head new;
};

struct lwq_node {
	struct llist_node node;
};

struct lwtunnel_encap_ops {
	int (*build_state)(struct net *, struct nlattr *, unsigned int, const void *, struct lwtunnel_state **, struct netlink_ext_ack *);
	void (*destroy_state)(struct lwtunnel_state *);
	int (*output)(struct net *, struct sock *, struct sk_buff *);
	int (*input)(struct sk_buff *);
	int (*fill_encap)(struct sk_buff *, struct lwtunnel_state *);
	int (*get_encap_size)(struct lwtunnel_state *);
	int (*cmp_encap)(struct lwtunnel_state *, struct lwtunnel_state *);
	int (*xmit)(struct sk_buff *);
	struct module *owner;
};

struct lwtunnel_state {
	__u16 type;
	__u16 flags;
	__u16 headroom;
	atomic_t refcnt;
	int (*orig_output)(struct net *, struct sock *, struct sk_buff *);
	int (*orig_input)(struct sk_buff *);
	struct callback_head rcu;
	__u8 data[0];
};

struct lzma2_dec {
	enum lzma2_seq sequence;
	enum lzma2_seq next_sequence;
	uint32_t uncompressed;
	uint32_t compressed;
	bool need_dict_reset;
	bool need_props;
};

struct lzma_len_dec {
	uint16_t choice;
	uint16_t choice2;
	uint16_t low[128];
	uint16_t mid[128];
	uint16_t high[256];
};

struct lzma_dec {
	uint32_t rep0;
	uint32_t rep1;
	uint32_t rep2;
	uint32_t rep3;
	enum lzma_state state;
	uint32_t len;
	uint32_t lc;
	uint32_t literal_pos_mask;
	uint32_t pos_mask;
	uint16_t is_match[192];
	uint16_t is_rep[12];
	uint16_t is_rep0[12];
	uint16_t is_rep1[12];
	uint16_t is_rep2[12];
	uint16_t is_rep0_long[192];
	uint16_t dist_slot[256];
	uint16_t dist_special[114];
	uint16_t dist_align[16];
	struct lzma_len_dec match_len_dec;
	struct lzma_len_dec rep_len_dec;
	uint16_t literal[12288];
};

struct lzma_header {
	uint8_t pos;
	uint32_t dict_size;
	uint64_t dst_size;
} __attribute__((packed));

struct lzo_ctx {
	void *lzo_comp_mem;
};

struct lzorle_ctx {
	void *lzorle_comp_mem;
};

struct ma_topiary {
	struct maple_enode *head;
	struct maple_enode *tail;
	struct maple_tree *mtree;
};

struct maple_node;

struct ma_wr_state {
	struct ma_state *mas;
	struct maple_node *node;
	long unsigned int r_min;
	long unsigned int r_max;
	enum maple_type type;
	unsigned char offset_end;
	long unsigned int *pivots;
	long unsigned int end_piv;
	void **slots;
	void *entry;
	void *content;
};

struct mac80211_qos_map {
	struct cfg80211_qos_map qos_map;
	struct callback_head callback_head;
};

struct machine_ops {
	void (*restart)(char *);
	void (*halt)(void);
	void (*power_off)(void);
	void (*shutdown)(void);
	void (*crash_shutdown)(struct pt_regs *);
	void (*emergency_restart)(void);
};

struct macsec_info {
	sci_t sci;
};

struct mmu_gather;

struct madvise_walk_private {
	struct mmu_gather *tlb;
	bool pageout;
};

struct mafield {
	const char *prefix;
	int field;
};

struct map_attribute {
	struct attribute attr;
	ssize_t (*show)(struct efi_runtime_map_entry *, char *);
};

struct map_files_info {
	long unsigned int start;
	long unsigned int end;
	fmode_t mode;
};

struct map_info___2 {
	struct map_info___2 *next;
	struct mm_struct *mm;
	long unsigned int vaddr;
};

struct map_iter {
	void *key;
	bool done;
};

struct map_range {
	long unsigned int start;
	long unsigned int end;
	unsigned int page_size_mask;
};

struct maple_alloc {
	long unsigned int total;
	unsigned char node_count;
	unsigned int request_count;
	struct maple_alloc *slot[30];
};

struct maple_pnode;

struct maple_metadata {
	unsigned char end;
	unsigned char gap;
};

struct maple_arange_64 {
	struct maple_pnode *parent;
	long unsigned int pivot[9];
	void *slot[10];
	long unsigned int gap[10];
	struct maple_metadata meta;
};

struct maple_big_node {
	long unsigned int pivot[33];
	union {
		struct maple_enode *slot[34];
		struct {
			long unsigned int padding[21];
			long unsigned int gap[21];
		};
	};
	unsigned char b_end;
	enum maple_type type;
};

struct maple_range_64 {
	struct maple_pnode *parent;
	long unsigned int pivot[15];
	union {
		void *slot[16];
		struct {
			void *pad[15];
			struct maple_metadata meta;
		};
	};
};

struct maple_node {
	union {
		struct {
			struct maple_pnode *parent;
			void *slot[31];
		};
		struct {
			void *pad;
			struct callback_head rcu;
			struct maple_enode *piv_parent;
			unsigned char parent_slot;
			enum maple_type type;
			unsigned char slot_len;
			unsigned int ma_flags;
		};
		struct maple_range_64 mr64;
		struct maple_arange_64 ma64;
		struct maple_alloc alloc;
	};
};

struct maple_subtree_state {
	struct ma_state *orig_l;
	struct ma_state *orig_r;
	struct ma_state *l;
	struct ma_state *m;
	struct ma_state *r;
	struct ma_topiary *free;
	struct ma_topiary *destroy;
	struct maple_big_node *bn;
};

struct maple_topiary {
	struct maple_pnode *parent;
	struct maple_enode *next;
};

struct maple_tree {
	union {
		spinlock_t ma_lock;
		lockdep_map_p ma_external_lock;
	};
	unsigned int ma_flags;
	void *ma_root;
};

struct mapped_device {
	struct mutex suspend_lock;
	struct mutex table_devices_lock;
	struct list_head table_devices;
	void *map;
	long unsigned int flags;
	struct mutex type_lock;
	enum dm_queue_mode type;
	int numa_node_id;
	struct request_queue *queue;
	atomic_t holders;
	atomic_t open_count;
	struct dm_target *immutable_target;
	struct target_type *immutable_target_type;
	char name[16];
	struct gendisk *disk;
	struct dax_device *dax_dev;
	wait_queue_head_t wait;
	long unsigned int *pending_io;
	struct hd_geometry geometry;
	struct workqueue_struct *wq;
	struct work_struct work;
	spinlock_t deferred_lock;
	struct bio_list deferred;
	struct work_struct requeue_work;
	struct dm_io *requeue_list;
	void *interface_ptr;
	wait_queue_head_t eventq;
	atomic_t event_nr;
	atomic_t uevent_seq;
	struct list_head uevent_list;
	spinlock_t uevent_lock;
	bool init_tio_pdu: 1;
	struct blk_mq_tag_set *tag_set;
	struct dm_stats stats;
	unsigned int internal_suspend_count;
	int swap_bios;
	struct semaphore swap_bios_semaphore;
	struct mutex swap_bios_lock;
	struct dm_md_mempools *mempools;
	struct dm_kobject_holder kobj_holder;
	struct srcu_struct io_barrier;
};

struct masq_dev_work {
	struct work_struct work;
	struct net *net;
	netns_tracker ns_tracker;
	union nf_inet_addr addr;
	int ifindex;
	int (*iter)(struct nf_conn *, void *);
};

struct match_token {
	int token;
	const char *pattern;
};

struct math_emu_info {
	long int ___orig_eip;
	struct pt_regs *regs;
};

struct mb_cache {
	struct hlist_bl_head *c_hash;
	int c_bucket_bits;
	long unsigned int c_max_entries;
	spinlock_t c_list_lock;
	struct list_head c_list;
	long unsigned int c_entry_count;
	struct shrinker *c_shrink;
	struct work_struct c_shrink_work;
};

struct mb_cache_entry {
	struct list_head e_list;
	struct hlist_bl_node e_hash_list;
	atomic_t e_refcnt;
	u32 e_key;
	long unsigned int e_flags;
	u64 e_value;
};

struct mbox_controller;

struct mbox_client;

struct mbox_chan {
	struct mbox_controller *mbox;
	unsigned int txdone_method;
	struct mbox_client *cl;
	struct completion tx_complete;
	void *active_req;
	unsigned int msg_count;
	unsigned int msg_free;
	void *msg_data[20];
	spinlock_t lock;
	void *con_priv;
};

struct mbox_chan_ops {
	int (*send_data)(struct mbox_chan *, void *);
	int (*flush)(struct mbox_chan *, long unsigned int);
	int (*startup)(struct mbox_chan *);
	void (*shutdown)(struct mbox_chan *);
	bool (*last_tx_done)(struct mbox_chan *);
	bool (*peek_data)(struct mbox_chan *);
};

struct mbox_client {
	struct device *dev;
	bool tx_block;
	long unsigned int tx_tout;
	bool knows_txdone;
	void (*rx_callback)(struct mbox_client *, void *);
	void (*tx_prepare)(struct mbox_client *, void *);
	void (*tx_done)(struct mbox_client *, void *, int);
};

struct mbox_controller {
	struct device *dev;
	const struct mbox_chan_ops *ops;
	struct mbox_chan *chans;
	int num_chans;
	bool txdone_irq;
	bool txdone_poll;
	unsigned int txpoll_period;
	struct mbox_chan * (*of_xlate)(struct mbox_controller *, const struct of_phandle_args *);
	struct hrtimer poll_hrt;
	spinlock_t poll_hrt_lock;
	struct list_head node;
};

struct mc146818_get_time_callback_param {
	struct rtc_time *time;
	unsigned char ctrl;
	unsigned char century;
};

struct mc_subled {
	unsigned int color_index;
	unsigned int brightness;
	unsigned int intensity;
	unsigned int channel;
};

struct mca_config {
	__u64 lmce_disabled: 1;
	__u64 disabled: 1;
	__u64 ser: 1;
	__u64 recovery: 1;
	__u64 bios_cmci_threshold: 1;
	__u64 initialized: 1;
	__u64 __reserved: 58;
	bool dont_log_ce;
	bool cmci_disabled;
	bool ignore_ce;
	bool print_all;
	int monarch_timeout;
	int panic_timeout;
	u32 rip_msr;
	s8 bootlog;
};

struct storm_bank {
	u64 history;
	u64 timestamp;
	bool in_storm_mode;
	bool poll_only;
};

struct mca_storm_desc {
	struct storm_bank banks[64];
	u8 stormy_bank_count;
	bool poll_mode;
};

struct mce {
	__u64 status;
	__u64 misc;
	__u64 addr;
	__u64 mcgstatus;
	__u64 ip;
	__u64 tsc;
	__u64 time;
	__u8 cpuvendor;
	__u8 inject_flags;
	__u8 severity;
	__u8 pad;
	__u32 cpuid;
	__u8 cs;
	__u8 bank;
	__u8 cpu;
	__u8 finished;
	__u32 extcpu;
	__u32 socketid;
	__u32 apicid;
	__u64 mcgcap;
	__u64 synd;
	__u64 ipid;
	__u64 ppin;
	__u32 microcode;
	__u64 kflags;
};

struct mce_bank {
	u64 ctl;
	__u64 init: 1;
	__u64 lsb_in_status: 1;
	__u64 __reserved_1: 62;
};

struct mce_bank_dev {
	struct device_attribute attr;
	char attrname[16];
	u8 bank;
};

union vendor_info {
	struct {
		u64 synd1;
		u64 synd2;
	} amd;
};

struct mce_hw_err {
	struct mce m;
	union vendor_info vendor;
};

struct mce_evt_llist {
	struct llist_node llnode;
	struct mce_hw_err err;
};

struct mce_vendor_flags {
	__u64 overflow_recov: 1;
	__u64 succor: 1;
	__u64 smca: 1;
	__u64 zen_ifu_quirk: 1;
	__u64 amd_threshold: 1;
	__u64 p5: 1;
	__u64 winchip: 1;
	__u64 snb_ifu_quirk: 1;
	__u64 skx_repmov_quirk: 1;
	__u64 __reserved_0: 55;
};

struct mcs_group {
	u8 shift;
	u16 duration[14];
};

struct mcs_group___2 {
	u16 flags;
	u8 streams;
	u8 shift;
	u8 bw;
	u16 duration[10];
};

struct mcs_spinlock {
	struct mcs_spinlock *next;
	int locked;
	int count;
};

struct md5_state {
	u32 hash[4];
	u32 block[16];
	u64 byte_count;
};

struct md_bitmap_stats {
	u64 events_cleared;
	int behind_writes;
	bool behind_wait;
	long unsigned int missing_pages;
	long unsigned int file_pages;
	long unsigned int sync_size;
	long unsigned int pages;
	struct file *file;
};

struct md_rdev;

struct md_cluster_operations {
	int (*join)(struct mddev *, int);
	int (*leave)(struct mddev *);
	int (*slot_number)(struct mddev *);
	int (*resync_info_update)(struct mddev *, sector_t, sector_t);
	int (*resync_start_notify)(struct mddev *);
	int (*resync_status_get)(struct mddev *);
	void (*resync_info_get)(struct mddev *, sector_t *, sector_t *);
	int (*metadata_update_start)(struct mddev *);
	int (*metadata_update_finish)(struct mddev *);
	void (*metadata_update_cancel)(struct mddev *);
	int (*resync_start)(struct mddev *);
	int (*resync_finish)(struct mddev *);
	int (*area_resyncing)(struct mddev *, int, sector_t, sector_t);
	int (*add_new_disk)(struct mddev *, struct md_rdev *);
	void (*add_new_disk_cancel)(struct mddev *);
	int (*new_disk_ack)(struct mddev *, bool);
	int (*remove_disk)(struct mddev *, struct md_rdev *);
	void (*load_bitmaps)(struct mddev *, int);
	int (*gather_bitmaps)(struct md_rdev *);
	int (*resize_bitmaps)(struct mddev *, sector_t, sector_t);
	int (*lock_all_bitmaps)(struct mddev *);
	void (*unlock_all_bitmaps)(struct mddev *);
	void (*update_size)(struct mddev *, sector_t);
};

struct md_io_clone {
	struct mddev *mddev;
	struct bio *orig_bio;
	long unsigned int start_time;
	sector_t offset;
	long unsigned int sectors;
	struct bio bio_clone;
};

struct md_personality {
	char *name;
	int level;
	struct list_head list;
	struct module *owner;
	bool (*make_request)(struct mddev *, struct bio *);
	int (*run)(struct mddev *);
	int (*start)(struct mddev *);
	void (*free)(struct mddev *, void *);
	void (*status)(struct seq_file *, struct mddev *);
	void (*error_handler)(struct mddev *, struct md_rdev *);
	int (*hot_add_disk)(struct mddev *, struct md_rdev *);
	int (*hot_remove_disk)(struct mddev *, struct md_rdev *);
	int (*spare_active)(struct mddev *);
	sector_t (*sync_request)(struct mddev *, sector_t, sector_t, int *);
	int (*resize)(struct mddev *, sector_t);
	sector_t (*size)(struct mddev *, sector_t, int);
	int (*check_reshape)(struct mddev *);
	int (*start_reshape)(struct mddev *);
	void (*finish_reshape)(struct mddev *);
	void (*update_reshape_pos)(struct mddev *);
	void (*prepare_suspend)(struct mddev *);
	void (*quiesce)(struct mddev *, int);
	void * (*takeover)(struct mddev *);
	int (*change_consistency_policy)(struct mddev *, const char *);
	void (*bitmap_sector)(struct mddev *, sector_t *, long unsigned int *);
};

struct serial_in_rdev;

struct md_rdev {
	struct list_head same_set;
	sector_t sectors;
	struct mddev *mddev;
	int last_events;
	struct block_device *meta_bdev;
	struct block_device *bdev;
	struct file *bdev_file;
	struct page *sb_page;
	struct page *bb_page;
	int sb_loaded;
	__u64 sb_events;
	sector_t data_offset;
	sector_t new_data_offset;
	sector_t sb_start;
	int sb_size;
	int preferred_minor;
	struct kobject kobj;
	long unsigned int flags;
	wait_queue_head_t blocked_wait;
	int desc_nr;
	int raid_disk;
	int new_raid_disk;
	int saved_raid_disk;
	union {
		sector_t recovery_offset;
		sector_t journal_tail;
	};
	atomic_t nr_pending;
	atomic_t read_errors;
	time64_t last_read_error;
	atomic_t corrected_errors;
	struct serial_in_rdev *serial;
	struct kernfs_node *sysfs_state;
	struct kernfs_node *sysfs_unack_badblocks;
	struct kernfs_node *sysfs_badblocks;
	struct badblocks badblocks;
	struct {
		short int offset;
		unsigned int size;
		sector_t sector;
	} ppl;
};

struct md_setup_args {
	int minor;
	int partitioned;
	int level;
	int chunk;
	char *device_names;
};

struct md_sysfs_entry {
	struct attribute attr;
	ssize_t (*show)(struct mddev *, char *);
	ssize_t (*store)(struct mddev *, const char *, size_t);
};

struct md_thread {
	void (*run)(struct md_thread *);
	struct mddev *mddev;
	wait_queue_head_t wqueue;
	long unsigned int flags;
	struct task_struct *tsk;
	long unsigned int timeout;
	void *private;
};

struct md_cluster_info;

struct mddev {
	void *private;
	struct md_personality *pers;
	dev_t unit;
	int md_minor;
	struct list_head disks;
	long unsigned int flags;
	long unsigned int sb_flags;
	int suspended;
	struct mutex suspend_mutex;
	struct percpu_ref active_io;
	int ro;
	int sysfs_active;
	struct gendisk *gendisk;
	struct kobject kobj;
	int hold_active;
	int major_version;
	int minor_version;
	int patch_version;
	int persistent;
	int external;
	char metadata_type[17];
	int chunk_sectors;
	time64_t ctime;
	time64_t utime;
	int level;
	int layout;
	char clevel[16];
	int raid_disks;
	int max_disks;
	sector_t dev_sectors;
	sector_t array_sectors;
	int external_size;
	__u64 events;
	int can_decrease_events;
	char uuid[16];
	sector_t reshape_position;
	int delta_disks;
	int new_level;
	int new_layout;
	int new_chunk_sectors;
	int reshape_backwards;
	struct md_thread *thread;
	struct md_thread *sync_thread;
	enum sync_action last_sync_action;
	sector_t curr_resync;
	sector_t curr_resync_completed;
	long unsigned int resync_mark;
	sector_t resync_mark_cnt;
	sector_t curr_mark_cnt;
	sector_t resync_max_sectors;
	atomic64_t resync_mismatches;
	sector_t suspend_lo;
	sector_t suspend_hi;
	int sync_speed_min;
	int sync_speed_max;
	int parallel_resync;
	int ok_start_degraded;
	long unsigned int recovery;
	int recovery_disabled;
	int in_sync;
	struct mutex open_mutex;
	struct mutex reconfig_mutex;
	atomic_t active;
	atomic_t openers;
	int changed;
	int degraded;
	atomic_t recovery_active;
	wait_queue_head_t recovery_wait;
	sector_t recovery_cp;
	sector_t resync_min;
	sector_t resync_max;
	struct kernfs_node *sysfs_state;
	struct kernfs_node *sysfs_action;
	struct kernfs_node *sysfs_completed;
	struct kernfs_node *sysfs_degraded;
	struct kernfs_node *sysfs_level;
	struct work_struct del_work;
	struct work_struct sync_work;
	spinlock_t lock;
	wait_queue_head_t sb_wait;
	atomic_t pending_writes;
	unsigned int safemode;
	unsigned int safemode_delay;
	struct timer_list safemode_timer;
	struct percpu_ref writes_pending;
	int sync_checkers;
	void *bitmap;
	struct bitmap_operations *bitmap_ops;
	struct {
		struct file *file;
		loff_t offset;
		long unsigned int space;
		loff_t default_offset;
		long unsigned int default_space;
		struct mutex mutex;
		long unsigned int chunksize;
		long unsigned int daemon_sleep;
		long unsigned int max_write_behind;
		int external;
		int nodes;
		char cluster_name[64];
	} bitmap_info;
	atomic_t max_corr_read_errors;
	struct list_head all_mddevs;
	const struct attribute_group *to_remove;
	struct bio_set bio_set;
	struct bio_set sync_set;
	struct bio_set io_clone_set;
	struct work_struct event_work;
	mempool_t *serial_info_pool;
	void (*sync_super)(struct mddev *, struct md_rdev *);
	struct md_cluster_info *cluster_info;
	unsigned int good_device_nr;
	unsigned int noio_flag;
	struct list_head deleting;
	atomic_t sync_seq;
	bool has_superblocks: 1;
	bool fail_last_dev: 1;
	bool serialize_policy: 1;
};

struct mdio_board_info {
	const char *bus_id;
	char modalias[32];
	int mdio_addr;
	const void *platform_data;
};

struct mdio_board_entry {
	struct list_head list;
	struct mdio_board_info board_info;
};

struct mdio_bus_stat_attr {
	int addr;
	unsigned int field_offset;
};

struct mdio_bus_stats {
	u64_stats_t transfers;
	u64_stats_t errors;
	u64_stats_t writes;
	u64_stats_t reads;
	struct u64_stats_sync syncp;
};

struct mdio_device {
	struct device dev;
	struct mii_bus *bus;
	char modalias[32];
	int (*bus_match)(struct device *, const struct device_driver *);
	void (*device_free)(struct mdio_device *);
	void (*device_remove)(struct mdio_device *);
	int addr;
	int flags;
	int reset_state;
	struct gpio_desc *reset_gpio;
	struct reset_control *reset_ctrl;
	unsigned int reset_assert_delay;
	unsigned int reset_deassert_delay;
};

struct mdio_device_id {
	__u32 phy_id;
	__u32 phy_id_mask;
};

struct mdio_driver_common {
	struct device_driver driver;
	int flags;
};

struct mdio_driver {
	struct mdio_driver_common mdiodrv;
	int (*probe)(struct mdio_device *);
	void (*remove)(struct mdio_device *);
	void (*shutdown)(struct mdio_device *);
};

struct mdiobus_devres {
	struct mii_bus *mii;
};

struct mdp_device_descriptor_s {
	__u32 number;
	__u32 major;
	__u32 minor;
	__u32 raid_disk;
	__u32 state;
	__u32 reserved[27];
};

typedef struct mdp_device_descriptor_s mdp_disk_t;

struct mdp_superblock_1 {
	__le32 magic;
	__le32 major_version;
	__le32 feature_map;
	__le32 pad0;
	__u8 set_uuid[16];
	char set_name[32];
	__le64 ctime;
	__le32 level;
	__le32 layout;
	__le64 size;
	__le32 chunksize;
	__le32 raid_disks;
	union {
		__le32 bitmap_offset;
		struct {
			__le16 offset;
			__le16 size;
		} ppl;
	};
	__le32 new_level;
	__le64 reshape_position;
	__le32 delta_disks;
	__le32 new_layout;
	__le32 new_chunk;
	__le32 new_offset;
	__le64 data_offset;
	__le64 data_size;
	__le64 super_offset;
	union {
		__le64 recovery_offset;
		__le64 journal_tail;
	};
	__le32 dev_number;
	__le32 cnt_corrected_read;
	__u8 device_uuid[16];
	__u8 devflags;
	__u8 bblog_shift;
	__le16 bblog_size;
	__le32 bblog_offset;
	__le64 utime;
	__le64 events;
	__le64 resync_offset;
	__le32 sb_csum;
	__le32 max_dev;
	__u8 pad3[32];
	__le16 dev_roles[0];
};

struct mdp_superblock_s {
	__u32 md_magic;
	__u32 major_version;
	__u32 minor_version;
	__u32 patch_version;
	__u32 gvalid_words;
	__u32 set_uuid0;
	__u32 ctime;
	__u32 level;
	__u32 size;
	__u32 nr_disks;
	__u32 raid_disks;
	__u32 md_minor;
	__u32 not_persistent;
	__u32 set_uuid1;
	__u32 set_uuid2;
	__u32 set_uuid3;
	__u32 gstate_creserved[16];
	__u32 utime;
	__u32 state;
	__u32 active_disks;
	__u32 working_disks;
	__u32 failed_disks;
	__u32 spare_disks;
	__u32 sb_csum;
	__u32 events_lo;
	__u32 events_hi;
	__u32 cp_events_lo;
	__u32 cp_events_hi;
	__u32 recovery_cp;
	__u64 reshape_position;
	__u32 new_level;
	__u32 delta_disks;
	__u32 new_layout;
	__u32 new_chunk;
	__u32 gstate_sreserved[14];
	__u32 layout;
	__u32 chunk_size;
	__u32 root_pv;
	__u32 root_block;
	__u32 pstate_reserved[60];
	mdp_disk_t disks[27];
	__u32 reserved[0];
	mdp_disk_t this_disk;
};

typedef struct mdp_superblock_s mdp_super_t;

struct mdu_array_info_s {
	int major_version;
	int minor_version;
	int patch_version;
	unsigned int ctime;
	int level;
	int size;
	int nr_disks;
	int raid_disks;
	int md_minor;
	int not_persistent;
	unsigned int utime;
	int state;
	int active_disks;
	int working_disks;
	int failed_disks;
	int spare_disks;
	int layout;
	int chunk_size;
};

typedef struct mdu_array_info_s mdu_array_info_t;

struct mdu_bitmap_file_s {
	char pathname[4096];
};

typedef struct mdu_bitmap_file_s mdu_bitmap_file_t;

struct mdu_disk_info_s {
	int number;
	int major;
	int minor;
	int raid_disk;
	int state;
};

typedef struct mdu_disk_info_s mdu_disk_info_t;

struct mdu_version_s {
	int major;
	int minor;
	int patchlevel;
};

typedef struct mdu_version_s mdu_version_t;

struct measure_breadcrumb {
	struct i915_request rq;
	struct intel_ring ring;
	u32 cs[2048];
};

struct media_event_desc {
	__u8 media_event_code: 4;
	__u8 reserved1: 4;
	__u8 door_open: 1;
	__u8 media_present: 1;
	__u8 reserved2: 6;
	__u8 start_slot;
	__u8 end_slot;
};

struct mei_aux_device {
	struct auxiliary_device aux_dev;
	int irq;
	struct resource bar;
	struct resource ext_op_mem;
	bool slow_firmware;
};

struct mei_bus_message {
	u8 hbm_cmd;
	u8 data[0];
};

struct mei_fw_status {
	int count;
	u32 status[6];
};

struct mei_cfg {
	const struct mei_fw_status fw_status;
	bool (*quirk_probe)(const struct pci_dev *);
	const char *kind;
	size_t dma_size[3];
	u32 fw_ver_supported: 1;
	u32 hw_trc_supported: 1;
};

struct mei_dma_data {
	u8 buffer_id;
	void *vaddr;
	dma_addr_t daddr;
	size_t size;
};

struct mei_device;

struct mei_me_client;

struct mei_cl_device;

struct mei_cl {
	struct list_head link;
	struct mei_device *dev;
	enum file_state state;
	wait_queue_head_t tx_wait;
	wait_queue_head_t rx_wait;
	wait_queue_head_t wait;
	wait_queue_head_t ev_wait;
	struct fasync_struct *ev_async;
	int status;
	struct mei_me_client *me_cl;
	const struct file *fp;
	u8 host_client_id;
	struct list_head vtag_map;
	u8 tx_flow_ctrl_creds;
	u8 rx_flow_ctrl_creds;
	u8 timer_count;
	u8 notify_en;
	u8 notify_ev;
	u8 tx_cb_queued;
	enum mei_file_transaction_states writing_state;
	struct list_head rd_pending;
	spinlock_t rd_completed_lock;
	struct list_head rd_completed;
	struct mei_dma_data dma;
	u8 dma_mapped;
	struct mei_cl_device *cldev;
};

struct mei_msg_data {
	size_t size;
	unsigned char *data;
};

struct mei_ext_hdr;

struct mei_cl_cb {
	struct list_head list;
	struct mei_cl *cl;
	enum mei_cb_file_ops fop_type;
	struct mei_msg_data buf;
	size_t buf_idx;
	u8 vtag;
	const struct file *fp;
	int status;
	u32 internal: 1;
	u32 blocking: 1;
	struct mei_ext_hdr *ext_hdr;
};

typedef void (*mei_cldev_cb_t)(struct mei_cl_device *);

struct mei_cl_device {
	struct list_head bus_list;
	struct mei_device *bus;
	struct device dev;
	struct mei_me_client *me_cl;
	struct mei_cl *cl;
	char name[32];
	struct work_struct rx_work;
	mei_cldev_cb_t rx_cb;
	struct work_struct notif_work;
	mei_cldev_cb_t notif_cb;
	unsigned int do_match: 1;
	unsigned int is_added: 1;
	void *priv_data;
};

struct mei_cl_device_id {
	char name[32];
	uuid_le uuid;
	__u8 version;
	kernel_ulong_t driver_info;
};

struct mei_cl_driver {
	struct device_driver driver;
	const char *name;
	const struct mei_cl_device_id *id_table;
	int (*probe)(struct mei_cl_device *, const struct mei_cl_device_id *);
	void (*remove)(struct mei_cl_device *);
};

struct mei_cl_vtag {
	struct list_head list;
	const struct file *fp;
	u8 vtag;
	u8 pending_read: 1;
};

struct mei_client {
	__u32 max_msg_length;
	__u8 protocol_version;
	__u8 reserved[3];
};

struct mei_connect_client_data {
	union {
		uuid_le in_client_uuid;
		struct mei_client out_client_properties;
	};
};

struct mei_connect_client_vtag {
	uuid_le in_client_uuid;
	__u8 vtag;
	__u8 reserved[3];
};

struct mei_connect_client_data_vtag {
	union {
		struct mei_connect_client_vtag connect;
		struct mei_client out_client_properties;
	};
};

struct mei_dev_timeouts {
	long unsigned int hw_ready;
	int connect;
	long unsigned int cl_connect;
	int client_init;
	long unsigned int pgi;
	unsigned int d0i3;
	long unsigned int hbm;
	long unsigned int mkhi_recv;
};

struct mei_dma_dscr {
	void *vaddr;
	dma_addr_t daddr;
	size_t size;
};

struct mei_fw_version {
	u8 platform;
	u8 major;
	u16 minor;
	u16 buildno;
	u16 hotfix;
};

struct mei_hw_ops;

struct mei_device {
	struct device *dev;
	struct cdev cdev;
	int minor;
	struct list_head write_list;
	struct list_head write_waiting_list;
	struct list_head ctrl_wr_list;
	struct list_head ctrl_rd_list;
	u8 tx_queue_limit;
	struct list_head file_list;
	long int open_handle_count;
	struct mutex device_lock;
	struct delayed_work timer_work;
	bool recvd_hw_ready;
	wait_queue_head_t wait_hw_ready;
	wait_queue_head_t wait_pg;
	wait_queue_head_t wait_hbm_start;
	long unsigned int reset_count;
	enum mei_dev_state dev_state;
	enum mei_hbm_state hbm_state;
	enum mei_dev_pxp_mode pxp_mode;
	u16 init_clients_timer;
	enum mei_pg_event pg_event;
	struct dev_pm_domain pg_domain;
	unsigned char rd_msg_buf[512];
	u32 rd_msg_hdr[512];
	int rd_msg_hdr_count;
	bool hbuf_is_ready;
	struct mei_dma_dscr dr_dscr[3];
	struct hbm_version version;
	unsigned int hbm_f_pg_supported: 1;
	unsigned int hbm_f_dc_supported: 1;
	unsigned int hbm_f_dot_supported: 1;
	unsigned int hbm_f_ev_supported: 1;
	unsigned int hbm_f_fa_supported: 1;
	unsigned int hbm_f_ie_supported: 1;
	unsigned int hbm_f_os_supported: 1;
	unsigned int hbm_f_dr_supported: 1;
	unsigned int hbm_f_vt_supported: 1;
	unsigned int hbm_f_cap_supported: 1;
	unsigned int hbm_f_cd_supported: 1;
	unsigned int hbm_f_gsc_supported: 1;
	struct mei_fw_version fw_ver[3];
	unsigned int fw_f_fw_ver_supported: 1;
	unsigned int fw_ver_received: 1;
	struct rw_semaphore me_clients_rwsem;
	struct list_head me_clients;
	long unsigned int me_clients_map[4];
	long unsigned int host_clients_map[4];
	bool allow_fixed_address;
	bool override_fixed_address;
	struct mei_dev_timeouts timeouts;
	struct work_struct reset_work;
	struct work_struct bus_rescan_work;
	struct list_head device_list;
	struct mutex cl_bus_lock;
	const char *kind;
	struct dentry *dbgfs_dir;
	struct mei_fw_status saved_fw_status;
	enum mei_dev_state saved_dev_state;
	bool saved_fw_status_flag;
	enum mei_dev_reset_to_pxp gsc_reset_to_pxp;
	const struct mei_hw_ops *ops;
	char hw[0];
};

struct mei_ext_hdr {
	u8 type;
	u8 length;
};

struct mei_ext_hdr_gsc_f2h {
	struct mei_ext_hdr hdr;
	u8 client_id;
	u8 reserved;
	u32 fence_id;
	u32 written;
};

struct mei_gsc_sgl {
	u32 low;
	u32 high;
	u32 length;
};

struct mei_ext_hdr_gsc_h2f {
	struct mei_ext_hdr hdr;
	u8 client_id;
	u8 addr_type;
	u32 fence_id;
	u8 input_address_count;
	u8 output_address_count;
	u8 reserved[2];
	struct mei_gsc_sgl sgl[0];
};

struct mei_ext_hdr_vtag {
	struct mei_ext_hdr hdr;
	u8 vtag;
	u8 reserved;
};

struct mei_ext_meta_hdr {
	u8 count;
	u8 size;
	u8 reserved[2];
	u8 hdrs[0];
};

struct mei_fixup {
	const uuid_le uuid;
	void (*hook)(struct mei_cl_device *);
};

struct mei_hbm_cl_cmd {
	u8 hbm_cmd;
	u8 me_addr;
	u8 host_addr;
	u8 data;
};

struct mei_hw_ops {
	bool (*host_is_ready)(struct mei_device *);
	bool (*hw_is_ready)(struct mei_device *);
	int (*hw_reset)(struct mei_device *, bool);
	int (*hw_start)(struct mei_device *);
	int (*hw_config)(struct mei_device *);
	int (*fw_status)(struct mei_device *, struct mei_fw_status *);
	int (*trc_status)(struct mei_device *, u32 *);
	enum mei_pg_state (*pg_state)(struct mei_device *);
	bool (*pg_in_transition)(struct mei_device *);
	bool (*pg_is_enabled)(struct mei_device *);
	void (*intr_clear)(struct mei_device *);
	void (*intr_enable)(struct mei_device *);
	void (*intr_disable)(struct mei_device *);
	void (*synchronize_irq)(struct mei_device *);
	int (*hbuf_free_slots)(struct mei_device *);
	bool (*hbuf_is_ready)(struct mei_device *);
	u32 (*hbuf_depth)(const struct mei_device *);
	int (*write)(struct mei_device *, const void *, size_t, const void *, size_t);
	int (*rdbuf_full_slots)(struct mei_device *);
	u32 (*read_hdr)(const struct mei_device *);
	int (*read)(struct mei_device *, unsigned char *, long unsigned int);
};

struct mei_me_client {
	struct list_head list;
	struct kref refcnt;
	struct mei_client_properties props;
	u8 client_id;
	u8 tx_flow_ctrl_creds;
	u8 connect_count;
	u8 bus_added;
};

struct mei_me_hw {
	const struct mei_cfg *cfg;
	void *mem_addr;
	int irq;
	enum mei_pg_state pg_state;
	bool d0i3_supported;
	u8 hbuf_depth;
	int (*read_fws)(const struct mei_device *, int, u32 *);
	struct task_struct *polling_thread;
	wait_queue_head_t wait_active;
	bool is_active;
};

struct mei_msg_hdr {
	u32 me_addr: 8;
	u32 host_addr: 8;
	u32 length: 9;
	u32 reserved: 3;
	u32 extended: 1;
	u32 dma_ring: 1;
	u32 internal: 1;
	u32 msg_complete: 1;
	u32 extension[0];
};

struct mei_nfc_cmd {
	u8 command;
	u8 status;
	u16 req_id;
	u32 reserved;
	u16 data_size;
	u8 sub_command;
	u8 data[0];
} __attribute__((packed));

struct mei_nfc_if_version {
	u8 radio_version_sw[3];
	u8 reserved[3];
	u8 radio_version_hw[3];
	u8 i2c_addr;
	u8 fw_ivn;
	u8 vendor_id;
	u8 radio_type;
};

struct mei_nfc_reply {
	u8 command;
	u8 status;
	u16 req_id;
	u32 reserved;
	u16 data_size;
	u8 sub_command;
	u8 reply_status;
	u8 data[0];
};

struct mei_os_ver {
	__le16 build;
	__le16 reserved1;
	u8 os_type;
	u8 major;
	u8 minor;
	u8 reserved2;
};

struct stats {
	__le32 tx_good_frames;
	__le32 tx_max_collisions;
	__le32 tx_late_collisions;
	__le32 tx_underruns;
	__le32 tx_lost_crs;
	__le32 tx_deferred;
	__le32 tx_single_collisions;
	__le32 tx_multiple_collisions;
	__le32 tx_total_collisions;
	__le32 rx_good_frames;
	__le32 rx_crc_errors;
	__le32 rx_alignment_errors;
	__le32 rx_resource_errors;
	__le32 rx_overrun_errors;
	__le32 rx_cdt_errors;
	__le32 rx_short_frame_errors;
	__le32 fc_xmt_pause;
	__le32 fc_rcv_pause;
	__le32 fc_rcv_unsupported;
	__le16 xmt_tco_frames;
	__le16 rcv_tco_frames;
	__le32 complete;
};

struct mem {
	struct {
		u32 signature;
		u32 result;
	} selftest;
	struct stats stats;
	u8 dump_buf[596];
};

struct pglist_data;

typedef struct pglist_data pg_data_t;

struct mem_cgroup_reclaim_cookie {
	pg_data_t *pgdat;
	int generation;
};

struct quota_format_type;

struct mem_dqinfo {
	struct quota_format_type *dqi_format;
	int dqi_fmt_id;
	struct list_head dqi_dirty_list;
	long unsigned int dqi_flags;
	unsigned int dqi_bgrace;
	unsigned int dqi_igrace;
	qsize_t dqi_max_spc_limit;
	qsize_t dqi_max_ino_limit;
	void *dqi_priv;
};

struct mem_entry {
	u32 offset;
	u32 len;
};

struct mem_extent {
	struct list_head hook;
	long unsigned int start;
	long unsigned int end;
};

struct mem_section_usage;

struct mem_section {
	long unsigned int section_mem_map;
	struct mem_section_usage *usage;
};

struct mem_section_usage {
	struct callback_head rcu;
	long unsigned int subsection_map[1];
	long unsigned int pageblock_flags[0];
};

struct mem_size_stats {
	long unsigned int resident;
	long unsigned int shared_clean;
	long unsigned int shared_dirty;
	long unsigned int private_clean;
	long unsigned int private_dirty;
	long unsigned int referenced;
	long unsigned int anonymous;
	long unsigned int lazyfree;
	long unsigned int anonymous_thp;
	long unsigned int shmem_thp;
	long unsigned int file_thp;
	long unsigned int swap;
	long unsigned int shared_hugetlb;
	long unsigned int private_hugetlb;
	long unsigned int ksm;
	u64 pss;
	u64 pss_anon;
	u64 pss_file;
	u64 pss_shmem;
	u64 pss_dirty;
	u64 pss_locked;
	u64 swap_pss;
};

struct mem_zone_bm_rtree {
	struct list_head list;
	struct list_head nodes;
	struct list_head leaves;
	long unsigned int start_pfn;
	long unsigned int end_pfn;
	struct rtree_node *rtree;
	int levels;
	unsigned int blocks;
};

struct memblock_region;

struct memblock_type {
	long unsigned int cnt;
	long unsigned int max;
	phys_addr_t total_size;
	struct memblock_region *regions;
	char *name;
};

struct memblock {
	bool bottom_up;
	phys_addr_t current_limit;
	struct memblock_type memory;
	struct memblock_type reserved;
};

struct memblock_region {
	phys_addr_t base;
	phys_addr_t size;
	enum memblock_flags flags;
	int nid;
};

struct membuf {
	void *p;
	size_t left;
};

struct memdev {
	const char *name;
	const struct file_operations *fops;
	fmode_t fmode;
	umode_t mode;
};

struct memmap_attribute {
	struct attribute attr;
	ssize_t (*show)(struct firmware_map_entry *, char *);
};

struct memory_bitmap {
	struct list_head zones;
	struct linked_page *p_list;
	struct bm_position cur;
};

struct memory_dev_type {
	struct list_head tier_sibling;
	struct list_head list;
	int adistance;
	nodemask_t nodes;
	struct kref kref;
};

struct memory_notify {
	long unsigned int altmap_start_pfn;
	long unsigned int altmap_nr_pages;
	long unsigned int start_pfn;
	long unsigned int nr_pages;
	int status_change_nid_normal;
	int status_change_nid;
};

struct memory_tier {
	struct list_head list;
	struct list_head memory_types;
	int adistance_start;
	struct device dev;
	nodemask_t lower_tier_mask;
};

struct mempolicy {
	atomic_t refcnt;
	short unsigned int mode;
	short unsigned int flags;
	nodemask_t nodes;
	int home_node;
	union {
		nodemask_t cpuset_mems_allowed;
		nodemask_t user_nodemask;
	} w;
};

struct mempolicy_operations {
	int (*create)(struct mempolicy *, const nodemask_t *);
	void (*rebind)(struct mempolicy *, const nodemask_t *);
};

struct memtype {
	u64 start;
	u64 end;
	u64 subtree_max_end;
	enum page_cache_mode type;
	struct rb_node rb;
};

struct menu_device {
	int needs_update;
	int tick_wakeup;
	u64 next_timer_ns;
	unsigned int bucket;
	unsigned int correction_factor[6];
	unsigned int intervals[8];
	int interval_ptr;
};

struct mesh_csa_settings {
	struct callback_head callback_head;
	struct cfg80211_csa_settings settings;
};

struct mesh_path {
	u8 dst[6];
	u8 mpp[6];
	struct rhash_head rhash;
	struct hlist_node walk_list;
	struct hlist_node gate_list;
	struct ieee80211_sub_if_data *sdata;
	struct sta_info *next_hop;
	struct timer_list timer;
	struct sk_buff_head frame_queue;
	struct callback_head rcu;
	u32 sn;
	u32 metric;
	u8 hop_count;
	long unsigned int exp_time;
	u32 discovery_timeout;
	u8 discovery_retries;
	enum mesh_path_flags flags;
	spinlock_t state_lock;
	u8 rann_snd_addr[6];
	u32 rann_metric;
	long unsigned int last_preq_to_root;
	long unsigned int fast_tx_check;
	bool is_root;
	bool is_gate;
	u32 path_change_count;
};

struct mesh_rmc {
	struct hlist_head bucket[256];
	u32 idx_mask;
};

struct mesh_setup {
	struct cfg80211_chan_def chandef;
	const u8 *mesh_id;
	u8 mesh_id_len;
	u8 sync_method;
	u8 path_sel_proto;
	u8 path_metric;
	u8 auth_id;
	const u8 *ie;
	u8 ie_len;
	bool is_authenticated;
	bool is_secure;
	bool user_mpm;
	u8 dtim_period;
	u16 beacon_interval;
	int mcast_rate[6];
	u32 basic_rates;
	struct cfg80211_bitrate_mask beacon_rate;
	bool userspace_handles_dfs;
	bool control_port_over_nl80211;
};

struct xfrm_md_info {
	u32 if_id;
	int link;
	struct dst_entry *dst_orig;
};

struct metadata_dst {
	struct dst_entry dst;
	enum metadata_type type;
	union {
		struct ip_tunnel_info tun_info;
		struct hw_port_info port_info;
		struct macsec_info macsec_info;
		struct xfrm_md_info xfrm_info;
	} u;
};

struct mr_mfc {
	struct rhlist_head mnode;
	short unsigned int mfc_parent;
	int mfc_flags;
	union {
		struct {
			long unsigned int expires;
			struct sk_buff_head unresolved;
		} unres;
		struct {
			long unsigned int last_assert;
			int minvif;
			int maxvif;
			atomic_long_t bytes;
			atomic_long_t pkt;
			atomic_long_t wrong_if;
			long unsigned int lastuse;
			unsigned char ttls[32];
			refcount_t refcount;
		} res;
	} mfc_un;
	struct list_head list;
	struct callback_head rcu;
	void (*free)(struct callback_head *);
};

struct mfc_cache_cmp_arg {
	__be32 mfc_mcastgrp;
	__be32 mfc_origin;
};

struct mfc_cache {
	struct mr_mfc _c;
	union {
		struct {
			__be32 mfc_mcastgrp;
			__be32 mfc_origin;
		};
		struct mfc_cache_cmp_arg cmparg;
	};
};

struct mfc_entry_notifier_info {
	struct fib_notifier_info info;
	struct mr_mfc *mfc;
	u32 tb_id;
};

struct mfcctl {
	struct in_addr mfcc_origin;
	struct in_addr mfcc_mcastgrp;
	vifi_t mfcc_parent;
	unsigned char mfcc_ttls[32];
	unsigned int mfcc_pkt_cnt;
	unsigned int mfcc_byte_cnt;
	unsigned int mfcc_wrong_if;
	int mfcc_expire;
};

struct mgmt_frame_regs {
	u32 global_stypes;
	u32 interface_stypes;
	u32 global_mcast_stypes;
	u32 interface_mcast_stypes;
};

struct michael_mic_ctx {
	u32 l;
	u32 r;
};

struct microcode_header_amd {
	u32 data_code;
	u32 patch_id;
	u16 mc_patch_data_id;
	u8 mc_patch_data_len;
	u8 init_flag;
	u32 mc_patch_data_checksum;
	u32 nb_dev_id;
	u32 sb_dev_id;
	u16 processor_rev_id;
	u8 nb_rev_id;
	u8 sb_rev_id;
	u8 bios_api_rev;
	u8 reserved1[3];
	u32 match_reg[8];
};

struct microcode_amd {
	struct microcode_header_amd hdr;
	unsigned int mpb[0];
};

struct microcode_header_intel {
	unsigned int hdrver;
	unsigned int rev;
	unsigned int date;
	unsigned int sig;
	unsigned int cksum;
	unsigned int ldrver;
	unsigned int pf;
	unsigned int datasize;
	unsigned int totalsize;
	unsigned int metasize;
	unsigned int min_req_ver;
	unsigned int reserved;
};

struct microcode_intel {
	struct microcode_header_intel hdr;
	unsigned int bits[0];
};

struct microcode_ops {
	enum ucode_state (*request_microcode_fw)(int, struct device *);
	void (*microcode_fini_cpu)(int);
	enum ucode_state (*apply_microcode)(int);
	int (*collect_cpu_info)(int, struct cpu_signature *);
	void (*finalize_late_load)(int);
	unsigned int nmi_safe: 1;
	unsigned int use_nmi: 1;
};

struct mid8250_board;

struct mid8250 {
	int line;
	int dma_index;
	struct pci_dev *dma_dev;
	struct uart_8250_dma dma;
	struct mid8250_board *board;
	struct hsu_dma_chip dma_chip;
};

struct mid8250_board {
	long unsigned int freq;
	unsigned int base_baud;
	unsigned int bar;
	int (*setup)(struct mid8250 *, struct uart_port *);
	void (*exit)(struct mid8250 *);
};

struct migrate_pages_stats {
	int nr_succeeded;
	int nr_failed_pages;
	int nr_thp_succeeded;
	int nr_thp_failed;
	int nr_thp_split;
	int nr_split;
};

struct migrate_struct {
	ext4_lblk_t first_block;
	ext4_lblk_t last_block;
	ext4_lblk_t curr_block;
	ext4_fsblk_t first_pblock;
	ext4_fsblk_t last_pblock;
};

struct set_affinity_pending;

struct migration_arg {
	struct task_struct *task;
	int dest_cpu;
	struct set_affinity_pending *pending;
};

struct migration_mpol {
	struct mempolicy *pol;
	long unsigned int ilx;
};

struct migration_target_control {
	int nid;
	nodemask_t *nmask;
	gfp_t gfp_mask;
	enum migrate_reason reason;
};

struct phy_package_shared;

struct mii_bus {
	struct module *owner;
	const char *name;
	char id[61];
	void *priv;
	int (*read)(struct mii_bus *, int, int);
	int (*write)(struct mii_bus *, int, int, u16);
	int (*read_c45)(struct mii_bus *, int, int, int);
	int (*write_c45)(struct mii_bus *, int, int, int, u16);
	int (*reset)(struct mii_bus *);
	struct mdio_bus_stats stats[32];
	struct mutex mdio_lock;
	struct device *parent;
	enum {
		MDIOBUS_ALLOCATED = 1,
		MDIOBUS_REGISTERED = 2,
		MDIOBUS_UNREGISTERED = 3,
		MDIOBUS_RELEASED = 4,
	} state;
	struct device dev;
	struct mdio_device *mdio_map[32];
	u32 phy_mask;
	u32 phy_ignore_ta_mask;
	int irq[32];
	int reset_delay_us;
	int reset_post_delay_us;
	struct gpio_desc *reset_gpiod;
	struct mutex shared_lock;
	struct phy_package_shared *shared[32];
};

struct mii_if_info {
	int phy_id;
	int advertising;
	int phy_id_mask;
	int reg_num_mask;
	unsigned int full_duplex: 1;
	unsigned int force_media: 1;
	unsigned int supports_gmii: 1;
	struct net_device *dev;
	int (*mdio_read)(struct net_device *, int, int);
	void (*mdio_write)(struct net_device *, int, int, int);
};

struct mii_ioctl_data {
	__u16 phy_id;
	__u16 reg_num;
	__u16 val_in;
	__u16 val_out;
};

struct mii_timestamper {
	bool (*rxtstamp)(struct mii_timestamper *, struct sk_buff *, int);
	void (*txtstamp)(struct mii_timestamper *, struct sk_buff *, int);
	int (*hwtstamp)(struct mii_timestamper *, struct kernel_hwtstamp_config *, struct netlink_ext_ack *);
	void (*link_state)(struct mii_timestamper *, struct phy_device *);
	int (*ts_info)(struct mii_timestamper *, struct kernel_ethtool_ts_info *);
	struct device *device;
};

struct min_heap_callbacks {
	bool (*less)(const void *, const void *, void *);
	void (*swp)(void *, void *, void *);
};

struct min_heap_char {
	size_t nr;
	size_t size;
	char *data;
	char preallocated[0];
};

typedef struct min_heap_char min_heap_char;

struct min_max_quirk {
	const char * const *pnp_ids;
	struct {
		u32 min;
		u32 max;
	} board_id;
	u32 x_min;
	u32 x_max;
	u32 y_min;
	u32 y_max;
};

struct mini_Qdisc {
	struct tcf_proto *filter_list;
	struct tcf_block *block;
	struct gnet_stats_basic_sync *cpu_bstats;
	struct gnet_stats_queue *cpu_qstats;
	long unsigned int rcu_state;
};

struct mini_Qdisc_pair {
	struct mini_Qdisc miniq1;
	struct mini_Qdisc miniq2;
	struct mini_Qdisc **p_miniq;
};

struct minimode {
	short int w;
	short int h;
	short int r;
	short int rb;
};

struct minmax_sample {
	u32 t;
	u32 v;
};

struct minmax {
	struct minmax_sample s[3];
};

struct minstrel_sample_category {
	u8 sample_group;
	u16 sample_rates[5];
	u16 cur_sample_rates[5];
};

struct minstrel_rate_stats {
	u16 attempts;
	u16 last_attempts;
	u16 success;
	u16 last_success;
	u32 att_hist;
	u32 succ_hist;
	u16 prob_avg;
	u16 prob_avg_1;
	u8 retry_count;
	u8 retry_count_rtscts;
	bool retry_updated;
};

struct minstrel_mcs_group_data {
	u8 index;
	u8 column;
	u16 max_group_tp_rate[4];
	u16 max_group_prob_rate;
	struct minstrel_rate_stats rates[10];
};

struct minstrel_ht_sta {
	struct ieee80211_sta *sta;
	unsigned int ampdu_len;
	unsigned int ampdu_packets;
	unsigned int avg_ampdu_len;
	u16 max_tp_rate[4];
	u16 max_prob_rate;
	long unsigned int last_stats_update;
	unsigned int overhead;
	unsigned int overhead_rtscts;
	unsigned int overhead_legacy;
	unsigned int overhead_legacy_rtscts;
	unsigned int total_packets;
	unsigned int sample_packets;
	u32 tx_flags;
	bool use_short_preamble;
	u8 band;
	u8 sample_seq;
	u16 sample_rate;
	long unsigned int sample_time;
	struct minstrel_sample_category sample[3];
	u16 supported[42];
	struct minstrel_mcs_group_data groups[42];
};

struct minstrel_priv {
	struct ieee80211_hw *hw;
	unsigned int cw_min;
	unsigned int cw_max;
	unsigned int max_retry;
	unsigned int segment_size;
	unsigned int update_interval;
	u8 cck_rates[4];
	u8 ofdm_rates[48];
};

struct mipi_dsi_device {
	struct mipi_dsi_host *host;
	struct device dev;
	bool attached;
	char name[20];
	unsigned int channel;
	unsigned int lanes;
	enum mipi_dsi_pixel_format format;
	long unsigned int mode_flags;
	long unsigned int hs_rate;
	long unsigned int lp_rate;
	struct drm_dsc_config *dsc;
};

struct mipi_dsi_device_info {
	char type[20];
	u32 channel;
	struct device_node *node;
};

struct mipi_dsi_driver {
	struct device_driver driver;
	int (*probe)(struct mipi_dsi_device *);
	void (*remove)(struct mipi_dsi_device *);
	void (*shutdown)(struct mipi_dsi_device *);
};

struct mipi_dsi_msg;

struct mipi_dsi_host_ops {
	int (*attach)(struct mipi_dsi_host *, struct mipi_dsi_device *);
	int (*detach)(struct mipi_dsi_host *, struct mipi_dsi_device *);
	ssize_t (*transfer)(struct mipi_dsi_host *, const struct mipi_dsi_msg *);
};

struct mipi_dsi_msg {
	u8 channel;
	u8 type;
	u16 flags;
	size_t tx_len;
	const void *tx_buf;
	size_t rx_len;
	void *rx_buf;
};

struct mipi_dsi_multi_context {
	struct mipi_dsi_device *dsi;
	int accum_err;
};

struct mipi_dsi_packet {
	size_t size;
	u8 header[4];
	size_t payload_length;
	const u8 *payload;
};

struct mirror_set;

struct mirror {
	struct mirror_set *ms;
	atomic_t error_count;
	long unsigned int error_type;
	struct dm_dev *dev;
	sector_t offset;
};

struct mirror_set {
	struct dm_target *ti;
	struct list_head list;
	uint64_t features;
	spinlock_t lock;
	struct bio_list reads;
	struct bio_list writes;
	struct bio_list failures;
	struct bio_list holds;
	struct dm_region_hash *rh;
	struct dm_kcopyd_client *kcopyd_client;
	struct dm_io_client *io_client;
	region_t nr_regions;
	int in_sync;
	int log_failure;
	int leg_failure;
	atomic_t suspend;
	atomic_t default_mirror;
	struct workqueue_struct *kmirrord_wq;
	struct work_struct kmirrord_work;
	struct timer_list timer;
	long unsigned int timer_pending;
	struct work_struct trigger_event;
	unsigned int nr_mirrors;
	struct mirror mirror[0];
};

struct misc_res {
	u64 max;
	atomic64_t watermark;
	atomic64_t usage;
	atomic64_t events;
	atomic64_t events_local;
};

struct misc_cg {
	struct cgroup_subsys_state css;
	struct cgroup_file events_file;
	struct cgroup_file events_local_file;
	struct misc_res res[0];
};

struct miscdevice {
	int minor;
	const char *name;
	const struct file_operations *fops;
	struct list_head list;
	struct device *parent;
	struct device *this_device;
	const struct attribute_group **groups;
	const char *nodename;
	umode_t mode;
};

struct mkhi_fw_ver_block {
	u16 minor;
	u8 major;
	u8 platform;
	u16 buildno;
	u16 hotfix;
};

struct mkhi_fw_ver {
	struct mkhi_fw_ver_block ver[3];
};

struct mkhi_rule_id {
	__le16 rule_type;
	u8 feature_id;
	u8 reserved;
};

struct mkhi_fwcaps {
	struct mkhi_rule_id id;
	u8 len;
	u8 data[0];
} __attribute__((packed));

struct mkhi_msg_hdr {
	u8 group_id;
	u8 command;
	u8 reserved;
	u8 result;
};

struct mkhi_gfx_mem_ready {
	struct mkhi_msg_hdr hdr;
	u32 flags;
};

struct mkhi_msg {
	struct mkhi_msg_hdr hdr;
	u8 data[0];
};

struct ml_effect_state {
	struct ff_effect *effect;
	long unsigned int flags;
	int count;
	long unsigned int play_at;
	long unsigned int stop_at;
	long unsigned int adj_at;
};

struct ml_device {
	void *private;
	struct ml_effect_state states[16];
	int gain;
	struct timer_list timer;
	struct input_dev *dev;
	int (*play_effect)(struct input_dev *, void *, struct ff_effect *);
};

struct mld2_grec {
	__u8 grec_type;
	__u8 grec_auxwords;
	__be16 grec_nsrcs;
	struct in6_addr grec_mca;
	struct in6_addr grec_src[0];
};

struct mld2_query {
	struct icmp6hdr mld2q_hdr;
	struct in6_addr mld2q_mca;
	__u8 mld2q_qrv: 3;
	__u8 mld2q_suppress: 1;
	__u8 mld2q_resv2: 4;
	__u8 mld2q_qqic;
	__be16 mld2q_nsrcs;
	struct in6_addr mld2q_srcs[0];
};

struct mld2_report {
	struct icmp6hdr mld2r_hdr;
	struct mld2_grec mld2r_grec[0];
};

struct mld_msg {
	struct icmp6hdr mld_hdr;
	struct in6_addr mld_mca;
};

struct mlock_fbatch {
	local_lock_t lock;
	struct folio_batch fbatch;
};

struct mm_cid {
	u64 time;
	int cid;
	int recent_cid;
};

struct mm_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_mm_state state;
	struct ethtool_mm_stats stats;
};

struct xol_area;

struct uprobes_state {
	struct xol_area *xol_area;
};

struct mmu_notifier_subscriptions;

struct mm_struct {
	struct {
		struct {
			atomic_t mm_count;
			long: 64;
			long: 64;
			long: 64;
			long: 64;
			long: 64;
			long: 64;
			long: 64;
		};
		struct maple_tree mm_mt;
		long unsigned int mmap_base;
		long unsigned int mmap_legacy_base;
		long unsigned int mmap_compat_base;
		long unsigned int mmap_compat_legacy_base;
		long unsigned int task_size;
		pgd_t *pgd;
		atomic_t membarrier_state;
		atomic_t mm_users;
		struct mm_cid *pcpu_cid;
		long unsigned int mm_cid_next_scan;
		unsigned int nr_cpus_allowed;
		atomic_t max_nr_cid;
		raw_spinlock_t cpus_allowed_lock;
		atomic_long_t pgtables_bytes;
		int map_count;
		spinlock_t page_table_lock;
		struct rw_semaphore mmap_lock;
		struct list_head mmlist;
		seqcount_t mm_lock_seq;
		long unsigned int hiwater_rss;
		long unsigned int hiwater_vm;
		long unsigned int total_vm;
		long unsigned int locked_vm;
		atomic64_t pinned_vm;
		long unsigned int data_vm;
		long unsigned int exec_vm;
		long unsigned int stack_vm;
		long unsigned int def_flags;
		seqcount_t write_protect_seq;
		spinlock_t arg_lock;
		long unsigned int start_code;
		long unsigned int end_code;
		long unsigned int start_data;
		long unsigned int end_data;
		long unsigned int start_brk;
		long unsigned int brk;
		long unsigned int start_stack;
		long unsigned int arg_start;
		long unsigned int arg_end;
		long unsigned int env_start;
		long unsigned int env_end;
		long unsigned int saved_auxv[52];
		struct percpu_counter rss_stat[4];
		struct linux_binfmt *binfmt;
		mm_context_t context;
		long unsigned int flags;
		spinlock_t ioctx_lock;
		struct kioctx_table *ioctx_table;
		struct user_namespace *user_ns;
		struct file *exe_file;
		struct mmu_notifier_subscriptions *notifier_subscriptions;
		atomic_t tlb_flush_pending;
		atomic_t tlb_flush_batched;
		struct uprobes_state uprobes_state;
		atomic_long_t hugetlb_usage;
		struct work_struct async_put_work;
		struct iommu_mm_data *iommu_mm;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
	};
	long unsigned int cpu_bitmap[0];
};

struct mm_struct__safe_rcu_or_null {
	struct file *exe_file;
};

struct mm_walk_ops;

struct mm_walk {
	const struct mm_walk_ops *ops;
	struct mm_struct *mm;
	pgd_t *pgd;
	struct vm_area_struct *vma;
	enum page_walk_action action;
	bool no_vma;
	void *private;
};

struct mm_walk_ops {
	int (*pgd_entry)(pgd_t *, long unsigned int, long unsigned int, struct mm_walk *);
	int (*p4d_entry)(p4d_t *, long unsigned int, long unsigned int, struct mm_walk *);
	int (*pud_entry)(pud_t *, long unsigned int, long unsigned int, struct mm_walk *);
	int (*pmd_entry)(pmd_t *, long unsigned int, long unsigned int, struct mm_walk *);
	int (*pte_entry)(pte_t *, long unsigned int, long unsigned int, struct mm_walk *);
	int (*pte_hole)(long unsigned int, long unsigned int, int, struct mm_walk *);
	int (*hugetlb_entry)(pte_t *, long unsigned int, long unsigned int, long unsigned int, struct mm_walk *);
	int (*test_walk)(long unsigned int, long unsigned int, struct mm_walk *);
	int (*pre_vma)(long unsigned int, long unsigned int, struct mm_walk *);
	void (*post_vma)(struct mm_walk *);
	int (*install_pte)(long unsigned int, long unsigned int, pte_t *, struct mm_walk *);
	enum page_walk_lock walk_lock;
};

struct mmap_arg_struct32 {
	unsigned int addr;
	unsigned int len;
	unsigned int prot;
	unsigned int flags;
	unsigned int fd;
	unsigned int offset;
};

struct vma_munmap_struct {
	struct vma_iterator *vmi;
	struct vm_area_struct *vma;
	struct vm_area_struct *prev;
	struct vm_area_struct *next;
	struct list_head *uf;
	long unsigned int start;
	long unsigned int end;
	long unsigned int unmap_start;
	long unsigned int unmap_end;
	int vma_count;
	bool unlock;
	bool clear_ptes;
	long unsigned int nr_pages;
	long unsigned int locked_vm;
	long unsigned int nr_accounted;
	long unsigned int exec_vm;
	long unsigned int stack_vm;
	long unsigned int data_vm;
};

struct mmap_state {
	struct mm_struct *mm;
	struct vma_iterator *vmi;
	long unsigned int addr;
	long unsigned int end;
	long unsigned int pgoff;
	long unsigned int pglen;
	long unsigned int flags;
	struct file *file;
	long unsigned int charged;
	bool retry_merge;
	struct vm_area_struct *prev;
	struct vm_area_struct *next;
	struct vma_munmap_struct vms;
	struct ma_state mas_detach;
	struct maple_tree mt_detach;
};

struct mmap_unlock_irq_work {
	struct irq_work irq_work;
	struct mm_struct *mm;
};

struct mminit_pfnnid_cache {
	long unsigned int last_start;
	long unsigned int last_end;
	int last_nid;
};

struct mmp_struct {
	__le32 mmp_magic;
	__le32 mmp_seq;
	__le64 mmp_time;
	char mmp_nodename[64];
	char mmp_bdevname[32];
	__le16 mmp_check_interval;
	__le16 mmp_pad1;
	__le32 mmp_pad2[226];
	__le32 mmp_checksum;
};

struct mmpin {
	struct user_struct *user;
	unsigned int num_pg;
};

struct user_msghdr {
	void *msg_name;
	int msg_namelen;
	struct iovec *msg_iov;
	__kernel_size_t msg_iovlen;
	void *msg_control;
	__kernel_size_t msg_controllen;
	unsigned int msg_flags;
};

struct mmsghdr {
	struct user_msghdr msg_hdr;
	unsigned int msg_len;
};

struct encoded_page;

struct mmu_gather_batch {
	struct mmu_gather_batch *next;
	unsigned int nr;
	unsigned int max;
	struct encoded_page *encoded_pages[0];
};

struct mmu_table_batch;

struct mmu_gather {
	struct mm_struct *mm;
	struct mmu_table_batch *batch;
	long unsigned int start;
	long unsigned int end;
	unsigned int fullmm: 1;
	unsigned int need_flush_all: 1;
	unsigned int freed_tables: 1;
	unsigned int delayed_rmap: 1;
	unsigned int cleared_ptes: 1;
	unsigned int cleared_pmds: 1;
	unsigned int cleared_puds: 1;
	unsigned int cleared_p4ds: 1;
	unsigned int vma_exec: 1;
	unsigned int vma_huge: 1;
	unsigned int vma_pfn: 1;
	unsigned int batch_count;
	struct mmu_gather_batch *active;
	struct mmu_gather_batch local;
	struct page *__pages[8];
};

struct mmu_notifier_range;

struct mmu_interval_notifier_ops {
	bool (*invalidate)(struct mmu_interval_notifier *, const struct mmu_notifier_range *, long unsigned int);
};

struct mmu_notifier_ops {
	void (*release)(struct mmu_notifier *, struct mm_struct *);
	int (*clear_flush_young)(struct mmu_notifier *, struct mm_struct *, long unsigned int, long unsigned int);
	int (*clear_young)(struct mmu_notifier *, struct mm_struct *, long unsigned int, long unsigned int);
	int (*test_young)(struct mmu_notifier *, struct mm_struct *, long unsigned int);
	int (*invalidate_range_start)(struct mmu_notifier *, const struct mmu_notifier_range *);
	void (*invalidate_range_end)(struct mmu_notifier *, const struct mmu_notifier_range *);
	void (*arch_invalidate_secondary_tlbs)(struct mmu_notifier *, struct mm_struct *, long unsigned int, long unsigned int);
	struct mmu_notifier * (*alloc_notifier)(struct mm_struct *);
	void (*free_notifier)(struct mmu_notifier *);
};

struct mmu_notifier_range {
	struct mm_struct *mm;
	long unsigned int start;
	long unsigned int end;
	unsigned int flags;
	enum mmu_notifier_event event;
	void *owner;
};

struct mmu_notifier_subscriptions {
	struct hlist_head list;
	bool has_itree;
	spinlock_t lock;
	long unsigned int invalidate_seq;
	long unsigned int active_invalidate_ranges;
	struct rb_root_cached itree;
	wait_queue_head_t wq;
	struct hlist_head deferred_list;
};

struct mmu_table_batch {
	struct callback_head rcu;
	unsigned int nr;
	void *tables[0];
};

struct mnt_id_req {
	__u32 size;
	__u32 spare;
	__u64 mnt_id;
	__u64 param;
	__u64 mnt_ns_id;
};

struct uid_gid_extent {
	u32 first;
	u32 lower_first;
	u32 count;
};

struct uid_gid_map {
	union {
		struct {
			struct uid_gid_extent extent[5];
			u32 nr_extents;
		};
		struct {
			struct uid_gid_extent *forward;
			struct uid_gid_extent *reverse;
		};
	};
};

struct mnt_idmap {
	struct uid_gid_map uid_map;
	struct uid_gid_map gid_map;
	refcount_t count;
};

struct mount;

struct mnt_namespace {
	struct ns_common ns;
	struct mount *root;
	struct {
		struct rb_root mounts;
		struct rb_node *mnt_last_node;
		struct rb_node *mnt_first_node;
	};
	struct user_namespace *user_ns;
	struct ucounts *ucounts;
	u64 seq;
	union {
		wait_queue_head_t poll;
		struct callback_head mnt_ns_rcu;
	};
	u64 event;
	unsigned int nr_mounts;
	unsigned int pending_mounts;
	struct rb_node mnt_ns_tree_node;
	struct list_head mnt_ns_list;
	refcount_t passive;
};

struct mnt_ns_info {
	__u32 size;
	__u32 nr_mounts;
	__u64 mnt_ns_id;
};

struct mnt_pcp {
	int mnt_count;
	int mnt_writers;
};

struct orc_entry;

struct mod_arch_specific {
	unsigned int num_orcs;
	int *orc_unwind_ip;
	struct orc_entry *orc_unwind;
};

struct mod_initfree {
	struct llist_node node;
	void *init_text;
	void *init_data;
	void *init_rodata;
};

struct mod_kallsyms {
	Elf64_Sym *symtab;
	unsigned int num_symtab;
	char *strtab;
	char *typetab;
};

struct mod_tree_node {
	struct module *mod;
	struct latch_tree_node node;
};

struct mod_tree_root {
	struct latch_tree_root root;
	long unsigned int addr_min;
	long unsigned int addr_max;
};

struct mode_page_header {
	__be16 mode_data_length;
	__u8 medium_type;
	__u8 reserved1;
	__u8 reserved2;
	__u8 reserved3;
	__be16 desc_length;
};

struct modesel_head {
	__u8 reserved1;
	__u8 medium;
	__u8 reserved2;
	__u8 block_desc_length;
	__u8 density;
	__u8 number_of_blocks_hi;
	__u8 number_of_blocks_med;
	__u8 number_of_blocks_lo;
	__u8 reserved3;
	__u8 block_length_hi;
	__u8 block_length_med;
	__u8 block_length_lo;
};

struct module_param_attrs;

struct module_kobject {
	struct kobject kobj;
	struct module *mod;
	struct kobject *drivers_dir;
	struct module_param_attrs *mp;
	struct completion *kobj_completion;
};

struct module_memory {
	void *base;
	void *rw_copy;
	bool is_rox;
	unsigned int size;
	struct mod_tree_node mtn;
};

struct module_attribute;

struct module_sect_attrs;

struct module_notes_attrs;

struct trace_event_call;

struct trace_eval_map;

struct static_call_site;

struct module {
	enum module_state state;
	struct list_head list;
	char name[56];
	struct module_kobject mkobj;
	struct module_attribute *modinfo_attrs;
	const char *version;
	const char *srcversion;
	struct kobject *holders_dir;
	const struct kernel_symbol *syms;
	const u32 *crcs;
	unsigned int num_syms;
	struct mutex param_lock;
	struct kernel_param *kp;
	unsigned int num_kp;
	unsigned int num_gpl_syms;
	const struct kernel_symbol *gpl_syms;
	const u32 *gpl_crcs;
	bool using_gplonly_symbols;
	bool async_probe_requested;
	unsigned int num_exentries;
	struct exception_table_entry *extable;
	int (*init)(void);
	struct module_memory mem[7];
	struct mod_arch_specific arch;
	long unsigned int taints;
	unsigned int num_bugs;
	struct list_head bug_list;
	struct bug_entry *bug_table;
	struct mod_kallsyms *kallsyms;
	struct mod_kallsyms core_kallsyms;
	struct module_sect_attrs *sect_attrs;
	struct module_notes_attrs *notes_attrs;
	char *args;
	void *percpu;
	unsigned int percpu_size;
	void *noinstr_text_start;
	unsigned int noinstr_text_size;
	unsigned int num_tracepoints;
	tracepoint_ptr_t *tracepoints_ptrs;
	unsigned int num_srcu_structs;
	struct srcu_struct **srcu_struct_ptrs;
	unsigned int num_bpf_raw_events;
	struct bpf_raw_event_map *bpf_raw_events;
	unsigned int btf_data_size;
	unsigned int btf_base_data_size;
	void *btf_data;
	void *btf_base_data;
	struct jump_entry *jump_entries;
	unsigned int num_jump_entries;
	unsigned int num_trace_bprintk_fmt;
	const char **trace_bprintk_fmt_start;
	struct trace_event_call **trace_events;
	unsigned int num_trace_events;
	struct trace_eval_map **trace_evals;
	unsigned int num_trace_evals;
	void *kprobes_text_start;
	unsigned int kprobes_text_size;
	long unsigned int *kprobe_blacklist;
	unsigned int num_kprobe_blacklist;
	int num_static_call_sites;
	struct static_call_site *static_call_sites;
	struct list_head source_list;
	struct list_head target_list;
	void (*exit)(void);
	atomic_t refcnt;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct module_attribute {
	struct attribute attr;
	ssize_t (*show)(const struct module_attribute *, struct module_kobject *, char *);
	ssize_t (*store)(const struct module_attribute *, struct module_kobject *, const char *, size_t);
	void (*setup)(struct module *, const char *);
	int (*test)(struct module *);
	void (*free)(struct module *);
};

struct module_notes_attrs {
	struct attribute_group grp;
	struct bin_attribute attrs[0];
};

struct param_attribute {
	struct module_attribute mattr;
	const struct kernel_param *param;
};

struct module_param_attrs {
	unsigned int num;
	struct attribute_group grp;
	struct param_attribute attrs[0];
};

struct module_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_module_power_mode_params power;
};

struct module_sect_attrs {
	struct attribute_group grp;
	struct bin_attribute attrs[0];
};

struct module_string {
	struct list_head next;
	struct module *module;
	char *str;
};

struct module_use {
	struct list_head source_list;
	struct list_head target_list;
	struct module *source;
	struct module *target;
};

struct module_version_attribute {
	struct module_attribute mattr;
	const char *module_name;
	const char *version;
};

struct mon_bin_hdr;

struct mon_bin_get {
	struct mon_bin_hdr *hdr;
	void *data;
	size_t alloc;
};

struct mon_bin_get32 {
	u32 hdr32;
	u32 data32;
	u32 alloc32;
};

struct mon_bin_hdr {
	u64 id;
	unsigned char type;
	unsigned char xfer_type;
	unsigned char epnum;
	unsigned char devnum;
	short unsigned int busnum;
	char flag_setup;
	char flag_data;
	s64 ts_sec;
	s32 ts_usec;
	int status;
	unsigned int len_urb;
	unsigned int len_cap;
	union {
		unsigned char setup[8];
		struct iso_rec iso;
	} s;
	int interval;
	int start_frame;
	unsigned int xfer_flags;
	unsigned int ndesc;
};

struct mon_bin_isodesc {
	int iso_status;
	unsigned int iso_off;
	unsigned int iso_len;
	u32 _pad;
};

struct mon_bin_mfetch {
	u32 *offvec;
	u32 nfetch;
	u32 nflush;
};

struct mon_bin_mfetch32 {
	u32 offvec32;
	u32 nfetch32;
	u32 nflush32;
};

struct mon_bin_stats {
	u32 queued;
	u32 dropped;
};

struct usb_bus;

struct mon_bus {
	struct list_head bus_link;
	spinlock_t lock;
	struct usb_bus *u_bus;
	int text_inited;
	int bin_inited;
	struct dentry *dent_s;
	struct dentry *dent_t;
	struct dentry *dent_u;
	struct device *classdev;
	int nreaders;
	struct list_head r_list;
	struct kref ref;
	unsigned int cnt_events;
	unsigned int cnt_text_lost;
};

struct mon_iso_desc {
	int status;
	unsigned int offset;
	unsigned int length;
};

struct mon_event_text {
	struct list_head e_link;
	int type;
	long unsigned int id;
	unsigned int tstamp;
	int busnum;
	char devnum;
	char epnum;
	char is_in;
	char xfertype;
	int length;
	int status;
	int interval;
	int start_frame;
	int error_count;
	char setup_flag;
	char data_flag;
	int numdesc;
	struct mon_iso_desc isodesc[5];
	unsigned char setup[8];
	unsigned char data[32];
};

struct mon_pgmap {
	struct page *pg;
	unsigned char *ptr;
};

struct mon_reader {
	struct list_head r_link;
	struct mon_bus *m_bus;
	void *r_data;
	void (*rnf_submit)(void *, struct urb *);
	void (*rnf_error)(void *, struct urb *, int);
	void (*rnf_complete)(void *, struct urb *, int);
};

struct mon_reader_bin {
	spinlock_t b_lock;
	unsigned int b_size;
	unsigned int b_cnt;
	unsigned int b_in;
	unsigned int b_out;
	unsigned int b_read;
	struct mon_pgmap *b_vec;
	wait_queue_head_t b_wait;
	struct mutex fetch_lock;
	int mmap_active;
	struct mon_reader r;
	unsigned int cnt_lost;
};

struct mon_reader_text {
	struct kmem_cache *e_slab;
	int nevents;
	struct list_head e_list;
	struct mon_reader r;
	wait_queue_head_t wait;
	int printf_size;
	size_t printf_offset;
	size_t printf_togo;
	char *printf_buf;
	struct mutex printf_lock;
	char slab_name[30];
};

struct mon_text_ptr {
	int cnt;
	int limit;
	char *pbuf;
};

struct motion_output_report_02 {
	u8 type;
	u8 zero;
	u8 r;
	u8 g;
	u8 b;
	u8 zero2;
	u8 rumble;
};

struct vfsmount {
	struct dentry *mnt_root;
	struct super_block *mnt_sb;
	int mnt_flags;
	struct mnt_idmap *mnt_idmap;
};

struct mountpoint;

struct mount {
	struct hlist_node mnt_hash;
	struct mount *mnt_parent;
	struct dentry *mnt_mountpoint;
	struct vfsmount mnt;
	union {
		struct rb_node mnt_node;
		struct callback_head mnt_rcu;
		struct llist_node mnt_llist;
	};
	struct mnt_pcp *mnt_pcp;
	struct list_head mnt_mounts;
	struct list_head mnt_child;
	struct list_head mnt_instance;
	const char *mnt_devname;
	struct list_head mnt_list;
	struct list_head mnt_expire;
	struct list_head mnt_share;
	struct list_head mnt_slave_list;
	struct list_head mnt_slave;
	struct mount *mnt_master;
	struct mnt_namespace *mnt_ns;
	struct mountpoint *mnt_mp;
	union {
		struct hlist_node mnt_mp_list;
		struct hlist_node mnt_umount;
	};
	struct list_head mnt_umounting;
	struct fsnotify_mark_connector *mnt_fsnotify_marks;
	__u32 mnt_fsnotify_mask;
	int mnt_id;
	u64 mnt_id_unique;
	int mnt_group_id;
	int mnt_expiry_mark;
	struct hlist_head mnt_pins;
	struct hlist_head mnt_stuck_children;
};

struct mount_attr {
	__u64 attr_set;
	__u64 attr_clr;
	__u64 propagation;
	__u64 userns_fd;
};

struct mount_kattr {
	unsigned int attr_set;
	unsigned int attr_clr;
	unsigned int propagation;
	unsigned int lookup_flags;
	bool recurse;
	struct user_namespace *mnt_userns;
	struct mnt_idmap *mnt_idmap;
};

struct mount_opts {
	int token;
	int mount_opt;
	int flags;
};

struct mountpoint {
	struct hlist_node m_hash;
	struct dentry *m_dentry;
	struct hlist_head m_list;
	int m_count;
};

struct mountres {
	int errno;
	struct nfs_fh *fh;
	unsigned int *auth_count;
	rpc_authflavor_t *auth_flavors;
};

struct movable_operations {
	bool (*isolate_page)(struct page *, isolate_mode_t);
	int (*migrate_page)(struct page *, struct page *, enum migrate_mode);
	void (*putback_page)(struct page *);
};

struct move_extent {
	__u32 reserved;
	__u32 donor_fd;
	__u64 orig_start;
	__u64 donor_start;
	__u64 len;
	__u64 moved_len;
};

struct mp_chip_data {
	struct list_head irq_2_pin;
	struct IO_APIC_route_entry entry;
	bool is_level;
	bool active_low;
	bool isa_irq;
	u32 count;
};

struct mpage_da_data {
	struct inode *inode;
	struct writeback_control *wbc;
	unsigned int can_map: 1;
	long unsigned int first_page;
	long unsigned int next_page;
	long unsigned int last_page;
	struct ext4_map_blocks map;
	struct ext4_io_submit io_submit;
	unsigned int do_map: 1;
	unsigned int scanned_until_end: 1;
	unsigned int journalled_more_data: 1;
};

struct mpage_data {
	struct bio *bio;
	sector_t last_block_in_bio;
	get_block_t *get_block;
};

struct mpage_readpage_args {
	struct bio *bio;
	struct folio *folio;
	unsigned int nr_pages;
	bool is_readahead;
	sector_t last_block_in_bio;
	struct buffer_head map_bh;
	long unsigned int first_logical_block;
	get_block_t *get_block;
};

struct mpath_info {
	u32 filled;
	u32 frame_qlen;
	u32 sn;
	u32 metric;
	u32 exptime;
	u32 discovery_timeout;
	u8 discovery_retries;
	u8 flags;
	u8 hop_count;
	u32 path_change_count;
	int generation;
};

struct mpc_bus {
	unsigned char type;
	unsigned char busid;
	unsigned char bustype[6];
};

struct mpc_cpu {
	unsigned char type;
	unsigned char apicid;
	unsigned char apicver;
	unsigned char cpuflag;
	unsigned int cpufeature;
	unsigned int featureflag;
	unsigned int reserved[2];
};

struct mpc_intsrc {
	unsigned char type;
	unsigned char irqtype;
	short unsigned int irqflag;
	unsigned char srcbus;
	unsigned char srcbusirq;
	unsigned char dstapic;
	unsigned char dstirq;
};

struct mpc_lintsrc {
	unsigned char type;
	unsigned char irqtype;
	short unsigned int irqflag;
	unsigned char srcbusid;
	unsigned char srcbusirq;
	unsigned char destapic;
	unsigned char destapiclint;
};

struct mpc_table {
	char signature[4];
	short unsigned int length;
	char spec;
	char checksum;
	char oem[8];
	char productid[12];
	unsigned int oemptr;
	short unsigned int oemsize;
	short unsigned int oemcount;
	unsigned int lapic;
	unsigned int reserved;
};

struct mpf_intel {
	char signature[4];
	unsigned int physptr;
	unsigned char length;
	unsigned char specification;
	unsigned char checksum;
	unsigned char feature1;
	unsigned char feature2;
	unsigned char feature3;
	unsigned char feature4;
	unsigned char feature5;
};

struct mpls_label {
	__be32 entry;
};

struct mpls_shim_hdr {
	__be32 label_stack_entry;
};

struct mptcp_out_options {};

struct mptcp_sock {};

struct mq_inflight {
	struct block_device *part;
	unsigned int inflight[2];
};

struct mq_sched {
	struct Qdisc **qdiscs;
};

struct mqueue_fs_context {
	struct ipc_namespace *ipc_ns;
	bool newns;
};

struct sigevent {
	sigval_t sigev_value;
	int sigev_signo;
	int sigev_notify;
	union {
		int _pad[12];
		int _tid;
		struct {
			void (*_function)(sigval_t);
			void *_attribute;
		} _sigev_thread;
	} _sigev_un;
};

struct posix_msg_tree_node;

struct mqueue_inode_info {
	spinlock_t lock;
	struct inode vfs_inode;
	wait_queue_head_t wait_q;
	struct rb_root msg_tree;
	struct rb_node *msg_tree_rightmost;
	struct posix_msg_tree_node *node_cache;
	struct mq_attr attr;
	struct sigevent notify;
	struct pid *notify_owner;
	u32 notify_self_exec_id;
	struct user_namespace *notify_user_ns;
	struct ucounts *ucounts;
	struct sock *notify_sock;
	struct sk_buff *notify_cookie;
	struct ext_wait_queue e_wait_q[2];
	long unsigned int qsize;
};

struct mr_table;

struct mr_mfc_iter {
	struct seq_net_private p;
	struct mr_table *mrt;
	struct list_head *cache;
	spinlock_t *lock;
};

struct mr_table_ops {
	const struct rhashtable_params *rht_params;
	void *cmparg_any;
};

struct vif_device {
	struct net_device *dev;
	netdevice_tracker dev_tracker;
	long unsigned int bytes_in;
	long unsigned int bytes_out;
	long unsigned int pkt_in;
	long unsigned int pkt_out;
	long unsigned int rate_limit;
	unsigned char threshold;
	short unsigned int flags;
	int link;
	struct netdev_phys_item_id dev_parent_id;
	__be32 local;
	__be32 remote;
};

struct mr_table {
	struct list_head list;
	possible_net_t net;
	struct mr_table_ops ops;
	u32 id;
	struct sock *mroute_sk;
	struct timer_list ipmr_expire_timer;
	struct list_head mfc_unres_queue;
	struct vif_device vif_table[32];
	struct rhltable mfc_hash;
	struct list_head mfc_cache_list;
	int maxvif;
	atomic_t cache_resolve_queue_len;
	bool mroute_do_assert;
	bool mroute_do_pim;
	bool mroute_do_wrvifwhole;
	int mroute_reg_vif_num;
};

struct mr_vif_iter {
	struct seq_net_private p;
	struct mr_table *mrt;
	int ct;
};

struct mrw_feature_desc {
	__be16 feature_code;
	__u8 curr: 1;
	__u8 persistent: 1;
	__u8 feature_version: 4;
	__u8 reserved1: 2;
	__u8 add_len;
	__u8 write: 1;
	__u8 reserved2: 7;
	__u8 reserved3;
	__u8 reserved4;
	__u8 reserved5;
};

struct ms_data {
	long unsigned int quirks;
	struct hid_device *hdev;
	struct work_struct ff_worker;
	__u8 strong;
	__u8 weak;
	void *output_report_dmabuf;
};

struct ms_hyperv_info {
	u32 features;
	u32 priv_high;
	u32 misc_features;
	u32 hints;
	u32 nested_features;
	u32 max_vp_index;
	u32 max_lp_index;
	u8 vtl;
	union {
		u32 isolation_config_a;
		struct {
			u32 paravisor_present: 1;
			u32 reserved_a1: 31;
		};
	};
	union {
		u32 isolation_config_b;
		struct {
			u32 cvm_type: 4;
			u32 reserved_b1: 1;
			u32 shared_gpa_boundary_active: 1;
			u32 shared_gpa_boundary_bits: 6;
			u32 reserved_b2: 20;
		};
	};
	u64 shared_gpa_boundary;
};

struct msdos_dir_entry {
	__u8 name[11];
	__u8 attr;
	__u8 lcase;
	__u8 ctime_cs;
	__le16 ctime;
	__le16 cdate;
	__le16 adate;
	__le16 starthi;
	__le16 time;
	__le16 date;
	__le16 start;
	__le32 size;
};

struct msdos_dir_slot {
	__u8 id;
	__u8 name0_4[10];
	__u8 attr;
	__u8 reserved;
	__u8 alias_checksum;
	__u8 name5_10[12];
	__le16 start;
	__u8 name11_12[4];
};

struct msdos_inode_info {
	spinlock_t cache_lru_lock;
	struct list_head cache_lru;
	int nr_caches;
	unsigned int cache_valid_id;
	loff_t mmu_private;
	int i_start;
	int i_logstart;
	int i_attrs;
	loff_t i_pos;
	struct hlist_node i_fat_hash;
	struct hlist_node i_dir_hash;
	struct rw_semaphore truncate_lock;
	struct timespec64 i_crtime;
	struct inode vfs_inode;
};

struct msdos_partition {
	u8 boot_ind;
	u8 head;
	u8 sector;
	u8 cyl;
	u8 sys_ind;
	u8 end_head;
	u8 end_sector;
	u8 end_cyl;
	__le32 start_sect;
	__le32 nr_sects;
};

struct msdos_sb_info {
	short unsigned int sec_per_clus;
	short unsigned int cluster_bits;
	unsigned int cluster_size;
	unsigned char fats;
	unsigned char fat_bits;
	short unsigned int fat_start;
	long unsigned int fat_length;
	long unsigned int dir_start;
	short unsigned int dir_entries;
	long unsigned int data_start;
	long unsigned int max_cluster;
	long unsigned int root_cluster;
	long unsigned int fsinfo_sector;
	struct mutex fat_lock;
	struct mutex nfs_build_inode_lock;
	struct mutex s_lock;
	unsigned int prev_free;
	unsigned int free_clusters;
	unsigned int free_clus_valid;
	struct fat_mount_options options;
	struct nls_table *nls_disk;
	struct nls_table *nls_io;
	const void *dir_ops;
	int dir_per_block;
	int dir_per_block_bits;
	unsigned int vol_id;
	int fatent_shift;
	const struct fatent_operations *fatent_ops;
	struct inode *fat_inode;
	struct inode *fsinfo_inode;
	struct ratelimit_state ratelimit;
	spinlock_t inode_hash_lock;
	struct hlist_head inode_hashtable[256];
	spinlock_t dir_hash_lock;
	struct hlist_head dir_hashtable[256];
	unsigned int dirty;
	struct callback_head rcu;
};

struct msg_msgseg;

struct msg_msg {
	struct list_head m_list;
	long int m_type;
	size_t m_ts;
	struct msg_msgseg *next;
	void *security;
};

struct msg_msgseg {
	struct msg_msgseg *next;
};

struct msg_queue {
	struct kern_ipc_perm q_perm;
	time64_t q_stime;
	time64_t q_rtime;
	time64_t q_ctime;
	long unsigned int q_cbytes;
	long unsigned int q_qnum;
	long unsigned int q_qbytes;
	struct pid *q_lspid;
	struct pid *q_lrpid;
	struct list_head q_messages;
	struct list_head q_receivers;
	struct list_head q_senders;
	long: 64;
	long: 64;
};

struct msg_receiver {
	struct list_head r_list;
	struct task_struct *r_tsk;
	int r_mode;
	long int r_msgtype;
	long int r_maxsize;
	struct msg_msg *r_msg;
};

struct msg_security_struct {
	u32 sid;
};

struct msg_sender {
	struct list_head list;
	struct task_struct *tsk;
	size_t msgsz;
};

struct msgbuf {
	__kernel_long_t mtype;
	char mtext[1];
};

struct msginfo {
	int msgpool;
	int msgmap;
	int msgmax;
	int msgmnb;
	int msgmni;
	int msgssz;
	int msgtql;
	short unsigned int msgseg;
};

struct msi_ctrl {
	unsigned int domid;
	unsigned int first;
	unsigned int last;
	unsigned int nirqs;
};

struct x86_msi_addr_lo {
	union {
		struct {
			u32 reserved_0: 2;
			u32 dest_mode_logical: 1;
			u32 redirect_hint: 1;
			u32 reserved_1: 1;
			u32 virt_destid_8_14: 7;
			u32 destid_0_7: 8;
			u32 base_address: 12;
		};
		struct {
			u32 dmar_reserved_0: 2;
			u32 dmar_index_15: 1;
			u32 dmar_subhandle_valid: 1;
			u32 dmar_format: 1;
			u32 dmar_index_0_14: 15;
			u32 dmar_base_address: 12;
		};
	};
};

typedef struct x86_msi_addr_lo arch_msi_msg_addr_lo_t;

struct x86_msi_addr_hi {
	u32 reserved: 8;
	u32 destid_8_31: 24;
};

typedef struct x86_msi_addr_hi arch_msi_msg_addr_hi_t;

struct x86_msi_data {
	union {
		struct {
			u32 vector: 8;
			u32 delivery_mode: 3;
			u32 dest_mode_logical: 1;
			u32 reserved: 2;
			u32 active_low: 1;
			u32 is_level: 1;
		};
		u32 dmar_subhandle;
	};
};

typedef struct x86_msi_data arch_msi_msg_data_t;

struct msi_msg {
	union {
		u32 address_lo;
		arch_msi_msg_addr_lo_t arch_addr_lo;
	};
	union {
		u32 address_hi;
		arch_msi_msg_addr_hi_t arch_addr_hi;
	};
	union {
		u32 data;
		arch_msi_msg_data_t arch_data;
	};
};

struct pci_msi_desc {
	union {
		u32 msi_mask;
		u32 msix_ctrl;
	};
	struct {
		u8 is_msix: 1;
		u8 multiple: 3;
		u8 multi_cap: 3;
		u8 can_mask: 1;
		u8 is_64: 1;
		u8 is_virtual: 1;
		unsigned int default_irq;
	} msi_attrib;
	union {
		u8 mask_pos;
		void *mask_base;
	};
};

union msi_domain_cookie {
	u64 value;
	void *ptr;
	void *iobase;
};

union msi_instance_cookie {
	u64 value;
	void *ptr;
};

struct msi_desc_data {
	union msi_domain_cookie dcookie;
	union msi_instance_cookie icookie;
};

struct msi_desc {
	unsigned int irq;
	unsigned int nvec_used;
	struct device *dev;
	struct msi_msg msg;
	struct irq_affinity_desc *affinity;
	const void *iommu_cookie;
	struct device_attribute *sysfs_attrs;
	void (*write_msi_msg)(struct msi_desc *, void *);
	void *write_msi_msg_data;
	u16 msi_index;
	union {
		struct pci_msi_desc pci;
		struct msi_desc_data data;
	};
};

struct msi_dev_domain {
	struct xarray store;
	struct irq_domain *domain;
};

struct msi_device_data {
	long unsigned int properties;
	struct mutex mutex;
	struct msi_dev_domain __domains[1];
	long unsigned int __iter_idx;
};

struct msi_domain_ops;

struct msi_domain_info {
	u32 flags;
	enum irq_domain_bus_token bus_token;
	unsigned int hwsize;
	struct msi_domain_ops *ops;
	struct irq_chip *chip;
	void *chip_data;
	irq_flow_handler_t handler;
	void *handler_data;
	const char *handler_name;
	void *data;
};

struct msi_domain_ops {
	irq_hw_number_t (*get_hwirq)(struct msi_domain_info *, msi_alloc_info_t *);
	int (*msi_init)(struct irq_domain *, struct msi_domain_info *, unsigned int, irq_hw_number_t, msi_alloc_info_t *);
	void (*msi_free)(struct irq_domain *, struct msi_domain_info *, unsigned int);
	int (*msi_prepare)(struct irq_domain *, struct device *, int, msi_alloc_info_t *);
	void (*prepare_desc)(struct irq_domain *, msi_alloc_info_t *, struct msi_desc *);
	void (*set_desc)(msi_alloc_info_t *, struct msi_desc *);
	int (*domain_alloc_irqs)(struct irq_domain *, struct device *, int);
	void (*domain_free_irqs)(struct irq_domain *, struct device *);
	void (*msi_post_free)(struct irq_domain *, struct device *);
	int (*msi_translate)(struct irq_domain *, struct irq_fwspec *, irq_hw_number_t *, unsigned int *);
};

struct msi_domain_template {
	char name[48];
	struct irq_chip chip;
	struct msi_domain_ops ops;
	struct msi_domain_info info;
};

struct msi_map {
	int index;
	int virq;
};

struct msi_parent_ops {
	u32 supported_flags;
	u32 required_flags;
	u32 bus_select_token;
	u32 bus_select_mask;
	const char *prefix;
	bool (*init_dev_msi_info)(struct device *, struct irq_domain *, struct irq_domain *, struct msi_domain_info *);
};

struct msqid64_ds {
	struct ipc64_perm msg_perm;
	long int msg_stime;
	long int msg_rtime;
	long int msg_ctime;
	long unsigned int msg_cbytes;
	long unsigned int msg_qnum;
	long unsigned int msg_qbytes;
	__kernel_pid_t msg_lspid;
	__kernel_pid_t msg_lrpid;
	long unsigned int __unused4;
	long unsigned int __unused5;
};

struct msg;

struct msqid_ds {
	struct ipc_perm msg_perm;
	struct msg *msg_first;
	struct msg *msg_last;
	__kernel_old_time_t msg_stime;
	__kernel_old_time_t msg_rtime;
	__kernel_old_time_t msg_ctime;
	long unsigned int msg_lcbytes;
	long unsigned int msg_lqbytes;
	short unsigned int msg_cbytes;
	short unsigned int msg_qnum;
	short unsigned int msg_qbytes;
	__kernel_ipc_pid_t msg_lspid;
	__kernel_ipc_pid_t msg_lrpid;
};

struct msr {
	union {
		struct {
			u32 l;
			u32 h;
		};
		u64 q;
	};
};

struct msr_data {
	bool host_initiated;
	u32 index;
	u64 data;
};

struct msr_enumeration {
	u32 msr_no;
	u32 feature;
};

struct msr_info {
	u32 msr_no;
	struct msr reg;
	struct msr *msrs;
	int err;
};

struct msr_info_completion {
	struct msr_info msr;
	struct completion done;
};

struct msr_regs_info {
	u32 *regs;
	int err;
};

struct mtl_gsc_ver_msg_in {
	struct intel_gsc_mtl_header header;
	struct intel_gsc_mkhi_header mkhi;
};

struct mtl_gsc_ver_msg_out {
	struct intel_gsc_mtl_header header;
	struct intel_gsc_mkhi_header mkhi;
	u16 proj_major;
	u16 compat_major;
	u16 compat_minor;
	u16 reserved[5];
};

struct pxp_cmd_header {
	u32 api_version;
	u32 command_id;
	union {
		u32 status;
		u32 stream_id;
	};
	u32 buffer_len;
};

struct pxp43_new_huc_auth_in {
	struct pxp_cmd_header header;
	u64 huc_base_address;
	u32 huc_size;
} __attribute__((packed));

struct mtl_huc_auth_msg_in {
	struct intel_gsc_mtl_header header;
	struct pxp43_new_huc_auth_in huc_in;
};

struct pxp43_huc_auth_out {
	struct pxp_cmd_header header;
};

struct mtl_huc_auth_msg_out {
	struct intel_gsc_mtl_header header;
	struct pxp43_huc_auth_out huc_out;
};

struct mtrr_gentry {
	__u64 base;
	__u32 size;
	__u32 regnum;
	__u32 type;
	__u32 _pad;
};

struct mtrr_gentry32 {
	compat_ulong_t regnum;
	compat_uint_t base;
	compat_uint_t size;
	compat_uint_t type;
};

struct mtrr_ops {
	u32 var_regs;
	void (*set)(unsigned int, long unsigned int, long unsigned int, mtrr_type);
	void (*get)(unsigned int, long unsigned int *, long unsigned int *, mtrr_type *);
	int (*get_free_region)(long unsigned int, long unsigned int, int);
	int (*validate_add_page)(long unsigned int, long unsigned int, unsigned int);
	int (*have_wrcomb)(void);
};

struct mtrr_sentry {
	__u64 base;
	__u32 size;
	__u32 type;
};

struct mtrr_sentry32 {
	compat_ulong_t base;
	compat_uint_t size;
	compat_uint_t type;
};

struct mtrr_var_range {
	__u32 base_lo;
	__u32 base_hi;
	__u32 mask_lo;
	__u32 mask_hi;
};

struct mtrr_state_type {
	struct mtrr_var_range var_ranges[256];
	mtrr_type fixed_ranges[88];
	unsigned char enabled;
	bool have_fixed;
	mtrr_type def_type;
};

struct multi_stop_data {
	cpu_stop_fn_t fn;
	void *data;
	unsigned int num_threads;
	const struct cpumask *active_cpus;
	enum multi_stop_state state;
	atomic_t thread_ack;
};

struct multiprocess_signals {
	sigset_t signal;
	struct hlist_node node;
};

typedef struct mutex *class_mutex_t;

typedef class_mutex_t class_mutex_intr_t;

struct mutex_waiter {
	struct list_head list;
	struct task_struct *task;
	struct ww_acquire_ctx *ww_ctx;
};

struct mwait_cpu_dead {
	unsigned int control;
	unsigned int status;
};

struct my_u {
	__le64 a;
	__le64 b;
};

struct my_u0 {
	__le64 a;
	__le64 b;
};

struct my_u1 {
	__le64 a;
	__le64 b;
	__le64 c;
	__le64 d;
};

struct n_tty_data {
	size_t read_head;
	size_t commit_head;
	size_t canon_head;
	size_t echo_head;
	size_t echo_commit;
	size_t echo_mark;
	long unsigned int char_map[4];
	long unsigned int overrun_time;
	unsigned int num_overrun;
	bool no_room;
	unsigned char lnext: 1;
	unsigned char erasing: 1;
	unsigned char raw: 1;
	unsigned char real_raw: 1;
	unsigned char icanon: 1;
	unsigned char push: 1;
	u8 read_buf[4096];
	long unsigned int read_flags[64];
	u8 echo_buf[4096];
	size_t read_tail;
	size_t line_start;
	size_t lookahead_count;
	unsigned int column;
	unsigned int canon_column;
	size_t echo_tail;
	struct mutex atomic_read_lock;
	struct mutex output_lock;
};

struct saved {
	struct path link;
	struct delayed_call done;
	const char *name;
	unsigned int seq;
};

struct nameidata {
	struct path path;
	struct qstr last;
	struct path root;
	struct inode *inode;
	unsigned int flags;
	unsigned int state;
	unsigned int seq;
	unsigned int next_seq;
	unsigned int m_seq;
	unsigned int r_seq;
	int last_type;
	unsigned int depth;
	int total_link_count;
	struct saved *stack;
	struct saved internal[2];
	struct filename *name;
	const char *pathname;
	struct nameidata *saved;
	unsigned int root_seq;
	int dfd;
	vfsuid_t dir_vfsuid;
	umode_t dir_mode;
};

struct page_frag_cache {
	long unsigned int encoded_page;
	__u32 offset;
	__u32 pagecnt_bias;
};

struct napi_alloc_cache {
	local_lock_t bh_lock;
	struct page_frag_cache page;
	unsigned int skb_count;
	void *skb_cache[64];
};

struct napi_config {
	u64 gro_flush_timeout;
	u64 irq_suspend_timeout;
	u32 defer_hard_irqs;
	unsigned int napi_id;
};

struct napi_gro_cb {
	union {
		struct {
			void *frag0;
			unsigned int frag0_len;
		};
		struct {
			struct sk_buff *last;
			long unsigned int age;
		};
	};
	int data_offset;
	u16 flush;
	u16 count;
	u16 proto;
	u16 pad;
	union {
		struct {
			u16 gro_remcsum_start;
			u8 same_flow: 1;
			u8 encap_mark: 1;
			u8 csum_valid: 1;
			u8 csum_cnt: 3;
			u8 free: 2;
			u8 is_ipv6: 1;
			u8 is_fou: 1;
			u8 ip_fixedid: 1;
			u8 recursion_counter: 4;
			u8 is_flist: 1;
		};
		struct {
			u16 gro_remcsum_start;
			u8 same_flow: 1;
			u8 encap_mark: 1;
			u8 csum_valid: 1;
			u8 csum_cnt: 3;
			u8 free: 2;
			u8 is_ipv6: 1;
			u8 is_fou: 1;
			u8 ip_fixedid: 1;
			u8 recursion_counter: 4;
			u8 is_flist: 1;
		} zeroed;
	};
	__wsum csum;
	union {
		struct {
			u16 network_offset;
			u16 inner_network_offset;
		};
		u16 network_offsets[2];
	};
};

struct nat_keepalive {
	struct net *net;
	u16 family;
	xfrm_address_t saddr;
	xfrm_address_t daddr;
	__be16 encap_sport;
	__be16 encap_dport;
	__u32 smark;
};

struct nat_keepalive_work_ctx {
	time64_t next_run;
	time64_t now;
};

struct nf_nat_hooks_net {
	struct nf_hook_ops *nat_hook_ops;
	unsigned int users;
};

struct nat_net {
	struct nf_nat_hooks_net nat_proto_net[11];
};

struct nbcon_state {
	union {
		unsigned int atom;
		struct {
			unsigned int prio: 2;
			unsigned int req_prio: 2;
			unsigned int unsafe: 1;
			unsigned int unsafe_takeover: 1;
			unsigned int cpu: 24;
		};
	};
};

struct nbcon_write_context {
	struct nbcon_context ctxt;
	char *outbuf;
	unsigned int len;
	bool unsafe_takeover;
};

struct nd_msg {
	struct icmp6hdr icmph;
	struct in6_addr target;
	__u8 opt[0];
};

struct nd_opt_hdr {
	__u8 nd_opt_type;
	__u8 nd_opt_len;
};

struct nda_cacheinfo {
	__u32 ndm_confirmed;
	__u32 ndm_used;
	__u32 ndm_updated;
	__u32 ndm_refcnt;
};

struct ndisc_options;

struct prefix_info;

struct ndisc_ops {
	int (*parse_options)(const struct net_device *, struct nd_opt_hdr *, struct ndisc_options *);
	void (*update)(const struct net_device *, struct neighbour *, u32, u8, const struct ndisc_options *);
	int (*opt_addr_space)(const struct net_device *, u8, struct neighbour *, u8 *, u8 **);
	void (*fill_addr_option)(const struct net_device *, struct sk_buff *, u8, const u8 *);
	void (*prefix_rcv_add_addr)(struct net *, struct net_device *, const struct prefix_info *, struct inet6_dev *, struct in6_addr *, int, u32, bool, bool, __u32, u32, bool);
};

struct ndisc_options {
	struct nd_opt_hdr *nd_opt_array[15];
	struct nd_opt_hdr *nd_useropts;
	struct nd_opt_hdr *nd_useropts_end;
};

struct ndmsg {
	__u8 ndm_family;
	__u8 ndm_pad1;
	__u16 ndm_pad2;
	__s32 ndm_ifindex;
	__u16 ndm_state;
	__u8 ndm_flags;
	__u8 ndm_type;
};

struct ndo_fdb_dump_context {
	long unsigned int ifindex;
	long unsigned int fdb_idx;
};

struct ndt_config {
	__u16 ndtc_key_len;
	__u16 ndtc_entry_size;
	__u32 ndtc_entries;
	__u32 ndtc_last_flush;
	__u32 ndtc_last_rand;
	__u32 ndtc_hash_rnd;
	__u32 ndtc_hash_mask;
	__u32 ndtc_hash_chain_gc;
	__u32 ndtc_proxy_qlen;
};

struct ndt_stats {
	__u64 ndts_allocs;
	__u64 ndts_destroys;
	__u64 ndts_hash_grows;
	__u64 ndts_res_failed;
	__u64 ndts_lookups;
	__u64 ndts_hits;
	__u64 ndts_rcv_probes_mcast;
	__u64 ndts_rcv_probes_ucast;
	__u64 ndts_periodic_gc_runs;
	__u64 ndts_forced_gc_runs;
	__u64 ndts_table_fulls;
};

struct ndtmsg {
	__u8 ndtm_family;
	__u8 ndtm_pad1;
	__u16 ndtm_pad2;
};

struct nduseroptmsg {
	unsigned char nduseropt_family;
	unsigned char nduseropt_pad1;
	short unsigned int nduseropt_opts_len;
	int nduseropt_ifindex;
	__u8 nduseropt_icmp_type;
	__u8 nduseropt_icmp_code;
	short unsigned int nduseropt_pad2;
	unsigned int nduseropt_pad3;
};

struct neigh_dump_filter {
	int master_idx;
	int dev_idx;
};

struct neigh_hash_table {
	struct hlist_head *hash_heads;
	unsigned int hash_shift;
	__u32 hash_rnd[4];
	struct callback_head rcu;
};

struct neigh_ops {
	int family;
	void (*solicit)(struct neighbour *, struct sk_buff *);
	void (*error_report)(struct neighbour *, struct sk_buff *);
	int (*output)(struct neighbour *, struct sk_buff *);
	int (*connected_output)(struct neighbour *, struct sk_buff *);
};

struct neigh_parms {
	possible_net_t net;
	struct net_device *dev;
	netdevice_tracker dev_tracker;
	struct list_head list;
	int (*neigh_setup)(struct neighbour *);
	struct neigh_table *tbl;
	void *sysctl_table;
	int dead;
	refcount_t refcnt;
	struct callback_head callback_head;
	int reachable_time;
	u32 qlen;
	int data[14];
	long unsigned int data_state[1];
};

struct neigh_seq_state {
	struct seq_net_private p;
	struct neigh_table *tbl;
	struct neigh_hash_table *nht;
	void * (*neigh_sub_iter)(struct neigh_seq_state *, struct neighbour *, loff_t *);
	unsigned int bucket;
	unsigned int flags;
};

struct neigh_statistics {
	long unsigned int allocs;
	long unsigned int destroys;
	long unsigned int hash_grows;
	long unsigned int res_failed;
	long unsigned int lookups;
	long unsigned int hits;
	long unsigned int rcv_probes_mcast;
	long unsigned int rcv_probes_ucast;
	long unsigned int periodic_gc_runs;
	long unsigned int forced_gc_runs;
	long unsigned int unres_discards;
	long unsigned int table_fulls;
};

struct neigh_sysctl_table {
	struct ctl_table_header *sysctl_header;
	struct ctl_table neigh_vars[21];
};

struct pneigh_entry;

struct neigh_table {
	int family;
	unsigned int entry_size;
	unsigned int key_len;
	__be16 protocol;
	__u32 (*hash)(const void *, const struct net_device *, __u32 *);
	bool (*key_eq)(const struct neighbour *, const void *);
	int (*constructor)(struct neighbour *);
	int (*pconstructor)(struct pneigh_entry *);
	void (*pdestructor)(struct pneigh_entry *);
	void (*proxy_redo)(struct sk_buff *);
	int (*is_multicast)(const void *);
	bool (*allow_add)(const struct net_device *, struct netlink_ext_ack *);
	char *id;
	struct neigh_parms parms;
	struct list_head parms_list;
	int gc_interval;
	int gc_thresh1;
	int gc_thresh2;
	int gc_thresh3;
	long unsigned int last_flush;
	struct delayed_work gc_work;
	struct delayed_work managed_work;
	struct timer_list proxy_timer;
	struct sk_buff_head proxy_queue;
	atomic_t entries;
	atomic_t gc_entries;
	struct list_head gc_list;
	struct list_head managed_list;
	rwlock_t lock;
	long unsigned int last_rand;
	struct neigh_statistics *stats;
	struct neigh_hash_table *nht;
	struct pneigh_entry **phash_buckets;
};

struct neighbour {
	struct hlist_node hash;
	struct hlist_node dev_list;
	struct neigh_table *tbl;
	struct neigh_parms *parms;
	long unsigned int confirmed;
	long unsigned int updated;
	rwlock_t lock;
	refcount_t refcnt;
	unsigned int arp_queue_len_bytes;
	struct sk_buff_head arp_queue;
	struct timer_list timer;
	long unsigned int used;
	atomic_t probes;
	u8 nud_state;
	u8 type;
	u8 dead;
	u8 protocol;
	u32 flags;
	seqlock_t ha_lock;
	long: 0;
	unsigned char ha[32];
	struct hh_cache hh;
	int (*output)(struct neighbour *, struct sk_buff *);
	const struct neigh_ops *ops;
	struct list_head gc_list;
	struct list_head managed_list;
	struct callback_head rcu;
	struct net_device *dev;
	netdevice_tracker dev_tracker;
	u8 primary_key[0];
};

struct neighbour_cb {
	long unsigned int sched_next;
	unsigned int flags;
};

union nested_table {
	union nested_table *table;
	struct rhash_lock_head *bucket;
};

struct ref_tracker_dir {};

struct raw_notifier_head {
	struct notifier_block *head;
};

struct prot_inuse;

struct netns_core {
	struct ctl_table_header *sysctl_hdr;
	int sysctl_somaxconn;
	int sysctl_optmem_max;
	u8 sysctl_txrehash;
	u8 sysctl_tstamp_allow_data;
	struct prot_inuse *prot_inuse;
	struct cpumask *rps_default_mask;
};

struct tcp_mib;

struct udp_mib;

struct netns_mib {
	struct ipstats_mib *ip_statistics;
	struct ipstats_mib *ipv6_statistics;
	struct tcp_mib *tcp_statistics;
	struct linux_mib *net_statistics;
	struct udp_mib *udp_statistics;
	struct udp_mib *udp_stats_in6;
	struct udp_mib *udplite_statistics;
	struct udp_mib *udplite_stats_in6;
	struct icmp_mib *icmp_statistics;
	struct icmpmsg_mib *icmpmsg_statistics;
	struct icmpv6_mib *icmpv6_statistics;
	struct icmpv6msg_mib *icmpv6msg_statistics;
	struct proc_dir_entry *proc_net_devsnmp6;
};

struct netns_packet {
	struct mutex sklist_lock;
	struct hlist_head sklist;
};

struct unix_table {
	spinlock_t *locks;
	struct hlist_head *buckets;
};

struct netns_unix {
	struct unix_table table;
	int sysctl_max_dgram_qlen;
	struct ctl_table_header *ctl;
};

struct netns_nexthop {
	struct rb_root rb_root;
	struct hlist_head *devhash;
	unsigned int seq;
	u32 last_id_allocated;
	struct blocking_notifier_head notifier_chain;
};

struct ping_group_range {
	seqlock_t lock;
	kgid_t range[2];
};

struct sysctl_fib_multipath_hash_seed {
	u32 user_seed;
	u32 mp_seed;
};

struct netns_ipv4 {
	__u8 __cacheline_group_begin__netns_ipv4_read_tx[0];
	u8 sysctl_tcp_early_retrans;
	u8 sysctl_tcp_tso_win_divisor;
	u8 sysctl_tcp_tso_rtt_log;
	u8 sysctl_tcp_autocorking;
	int sysctl_tcp_min_snd_mss;
	unsigned int sysctl_tcp_notsent_lowat;
	int sysctl_tcp_limit_output_bytes;
	int sysctl_tcp_min_rtt_wlen;
	int sysctl_tcp_wmem[3];
	u8 sysctl_ip_fwd_use_pmtu;
	__u8 __cacheline_group_end__netns_ipv4_read_tx[0];
	__u8 __cacheline_group_begin__netns_ipv4_read_txrx[0];
	u8 sysctl_tcp_moderate_rcvbuf;
	__u8 __cacheline_group_end__netns_ipv4_read_txrx[0];
	__u8 __cacheline_group_begin__netns_ipv4_read_rx[0];
	u8 sysctl_ip_early_demux;
	u8 sysctl_tcp_early_demux;
	u8 sysctl_tcp_l3mdev_accept;
	int sysctl_tcp_reordering;
	int sysctl_tcp_rmem[3];
	__u8 __cacheline_group_end__netns_ipv4_read_rx[0];
	long: 64;
	struct inet_timewait_death_row tcp_death_row;
	struct udp_table *udp_table;
	struct ctl_table_header *forw_hdr;
	struct ctl_table_header *frags_hdr;
	struct ctl_table_header *ipv4_hdr;
	struct ctl_table_header *route_hdr;
	struct ctl_table_header *xfrm4_hdr;
	struct ipv4_devconf *devconf_all;
	struct ipv4_devconf *devconf_dflt;
	struct ip_ra_chain *ra_chain;
	struct mutex ra_mutex;
	struct fib_rules_ops *rules_ops;
	struct fib_table *fib_main;
	struct fib_table *fib_default;
	unsigned int fib_rules_require_fldissect;
	bool fib_has_custom_rules;
	bool fib_has_custom_local_routes;
	bool fib_offload_disabled;
	u8 sysctl_tcp_shrink_window;
	struct hlist_head *fib_table_hash;
	struct sock *fibnl;
	struct sock *mc_autojoin_sk;
	struct inet_peer_base *peers;
	struct fqdir *fqdir;
	u8 sysctl_icmp_echo_ignore_all;
	u8 sysctl_icmp_echo_enable_probe;
	u8 sysctl_icmp_echo_ignore_broadcasts;
	u8 sysctl_icmp_ignore_bogus_error_responses;
	u8 sysctl_icmp_errors_use_inbound_ifaddr;
	int sysctl_icmp_ratelimit;
	int sysctl_icmp_ratemask;
	int sysctl_icmp_msgs_per_sec;
	int sysctl_icmp_msgs_burst;
	atomic_t icmp_global_credit;
	u32 icmp_global_stamp;
	u32 ip_rt_min_pmtu;
	int ip_rt_mtu_expires;
	int ip_rt_min_advmss;
	struct local_ports ip_local_ports;
	u8 sysctl_tcp_ecn;
	u8 sysctl_tcp_ecn_fallback;
	u8 sysctl_ip_default_ttl;
	u8 sysctl_ip_no_pmtu_disc;
	u8 sysctl_ip_fwd_update_priority;
	u8 sysctl_ip_nonlocal_bind;
	u8 sysctl_ip_autobind_reuse;
	u8 sysctl_ip_dynaddr;
	u8 sysctl_udp_early_demux;
	u8 sysctl_nexthop_compat_mode;
	u8 sysctl_fwmark_reflect;
	u8 sysctl_tcp_fwmark_accept;
	u8 sysctl_tcp_mtu_probing;
	int sysctl_tcp_mtu_probe_floor;
	int sysctl_tcp_base_mss;
	int sysctl_tcp_probe_threshold;
	u32 sysctl_tcp_probe_interval;
	int sysctl_tcp_keepalive_time;
	int sysctl_tcp_keepalive_intvl;
	u8 sysctl_tcp_keepalive_probes;
	u8 sysctl_tcp_syn_retries;
	u8 sysctl_tcp_synack_retries;
	u8 sysctl_tcp_syncookies;
	u8 sysctl_tcp_migrate_req;
	u8 sysctl_tcp_comp_sack_nr;
	u8 sysctl_tcp_backlog_ack_defer;
	u8 sysctl_tcp_pingpong_thresh;
	u8 sysctl_tcp_retries1;
	u8 sysctl_tcp_retries2;
	u8 sysctl_tcp_orphan_retries;
	u8 sysctl_tcp_tw_reuse;
	unsigned int sysctl_tcp_tw_reuse_delay;
	int sysctl_tcp_fin_timeout;
	u8 sysctl_tcp_sack;
	u8 sysctl_tcp_window_scaling;
	u8 sysctl_tcp_timestamps;
	int sysctl_tcp_rto_min_us;
	u8 sysctl_tcp_recovery;
	u8 sysctl_tcp_thin_linear_timeouts;
	u8 sysctl_tcp_slow_start_after_idle;
	u8 sysctl_tcp_retrans_collapse;
	u8 sysctl_tcp_stdurg;
	u8 sysctl_tcp_rfc1337;
	u8 sysctl_tcp_abort_on_overflow;
	u8 sysctl_tcp_fack;
	int sysctl_tcp_max_reordering;
	int sysctl_tcp_adv_win_scale;
	u8 sysctl_tcp_dsack;
	u8 sysctl_tcp_app_win;
	u8 sysctl_tcp_frto;
	u8 sysctl_tcp_nometrics_save;
	u8 sysctl_tcp_no_ssthresh_metrics_save;
	u8 sysctl_tcp_workaround_signed_windows;
	int sysctl_tcp_challenge_ack_limit;
	u8 sysctl_tcp_min_tso_segs;
	u8 sysctl_tcp_reflect_tos;
	int sysctl_tcp_invalid_ratelimit;
	int sysctl_tcp_pacing_ss_ratio;
	int sysctl_tcp_pacing_ca_ratio;
	unsigned int sysctl_tcp_child_ehash_entries;
	long unsigned int sysctl_tcp_comp_sack_delay_ns;
	long unsigned int sysctl_tcp_comp_sack_slack_ns;
	int sysctl_max_syn_backlog;
	int sysctl_tcp_fastopen;
	const struct tcp_congestion_ops *tcp_congestion_control;
	struct tcp_fastopen_context *tcp_fastopen_ctx;
	unsigned int sysctl_tcp_fastopen_blackhole_timeout;
	atomic_t tfo_active_disable_times;
	long unsigned int tfo_active_disable_stamp;
	u32 tcp_challenge_timestamp;
	u32 tcp_challenge_count;
	u8 sysctl_tcp_plb_enabled;
	u8 sysctl_tcp_plb_idle_rehash_rounds;
	u8 sysctl_tcp_plb_rehash_rounds;
	u8 sysctl_tcp_plb_suspend_rto_sec;
	int sysctl_tcp_plb_cong_thresh;
	int sysctl_udp_wmem_min;
	int sysctl_udp_rmem_min;
	u8 sysctl_fib_notify_on_flag_change;
	u8 sysctl_tcp_syn_linear_timeouts;
	u8 sysctl_igmp_llm_reports;
	int sysctl_igmp_max_memberships;
	int sysctl_igmp_max_msf;
	int sysctl_igmp_qrv;
	struct ping_group_range ping_group_range;
	atomic_t dev_addr_genid;
	unsigned int sysctl_udp_child_hash_entries;
	long unsigned int *sysctl_local_reserved_ports;
	int sysctl_ip_prot_sock;
	struct mr_table *mrt;
	struct sysctl_fib_multipath_hash_seed sysctl_fib_multipath_hash_seed;
	u32 sysctl_fib_multipath_hash_fields;
	u8 sysctl_fib_multipath_use_neigh;
	u8 sysctl_fib_multipath_hash_policy;
	struct fib_notifier_ops *notifier_ops;
	unsigned int fib_seq;
	struct fib_notifier_ops *ipmr_notifier_ops;
	unsigned int ipmr_seq;
	atomic_t rt_genid;
	siphash_key_t ip_id_key;
	struct hlist_head *inet_addr_lst;
	struct delayed_work addr_chk_work;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct netns_sysctl_ipv6 {
	struct ctl_table_header *hdr;
	struct ctl_table_header *route_hdr;
	struct ctl_table_header *icmp_hdr;
	struct ctl_table_header *frags_hdr;
	struct ctl_table_header *xfrm6_hdr;
	int flush_delay;
	int ip6_rt_max_size;
	int ip6_rt_gc_min_interval;
	int ip6_rt_gc_timeout;
	int ip6_rt_gc_interval;
	int ip6_rt_gc_elasticity;
	int ip6_rt_mtu_expires;
	int ip6_rt_min_advmss;
	u32 multipath_hash_fields;
	u8 multipath_hash_policy;
	u8 bindv6only;
	u8 flowlabel_consistency;
	u8 auto_flowlabels;
	int icmpv6_time;
	u8 icmpv6_echo_ignore_all;
	u8 icmpv6_echo_ignore_multicast;
	u8 icmpv6_echo_ignore_anycast;
	long unsigned int icmpv6_ratemask[4];
	long unsigned int *icmpv6_ratemask_ptr;
	u8 anycast_src_echo_reply;
	u8 ip_nonlocal_bind;
	u8 fwmark_reflect;
	u8 flowlabel_state_ranges;
	int idgen_retries;
	int idgen_delay;
	int flowlabel_reflect;
	int max_dst_opts_cnt;
	int max_hbh_opts_cnt;
	int max_dst_opts_len;
	int max_hbh_opts_len;
	int seg6_flowlabel;
	u32 ioam6_id;
	u64 ioam6_id_wide;
	u8 skip_notify_on_dev_down;
	u8 fib_notify_on_flag_change;
	u8 icmpv6_error_anycast_as_unicast;
};

struct rt6_statistics;

struct seg6_pernet_data;

struct netns_ipv6 {
	struct dst_ops ip6_dst_ops;
	struct netns_sysctl_ipv6 sysctl;
	struct ipv6_devconf *devconf_all;
	struct ipv6_devconf *devconf_dflt;
	struct inet_peer_base *peers;
	struct fqdir *fqdir;
	struct fib6_info *fib6_null_entry;
	struct rt6_info *ip6_null_entry;
	struct rt6_statistics *rt6_stats;
	struct timer_list ip6_fib_timer;
	struct hlist_head *fib_table_hash;
	struct fib6_table *fib6_main_tbl;
	struct list_head fib6_walkers;
	rwlock_t fib6_walker_lock;
	spinlock_t fib6_gc_lock;
	atomic_t ip6_rt_gc_expire;
	long unsigned int ip6_rt_last_gc;
	unsigned char flowlabel_has_excl;
	struct sock *ndisc_sk;
	struct sock *tcp_sk;
	struct sock *igmp_sk;
	struct sock *mc_autojoin_sk;
	struct hlist_head *inet6_addr_lst;
	spinlock_t addrconf_hash_lock;
	struct delayed_work addr_chk_work;
	atomic_t dev_addr_genid;
	atomic_t fib6_sernum;
	struct seg6_pernet_data *seg6_data;
	struct fib_notifier_ops *notifier_ops;
	struct fib_notifier_ops *ip6mr_notifier_ops;
	unsigned int ipmr_seq;
	struct {
		struct hlist_head head;
		spinlock_t lock;
		u32 seq;
	} ip6addrlbl_table;
	struct ioam6_pernet_data *ioam6_data;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct nf_logger;

struct nf_hook_entries;

struct netns_nf {
	struct proc_dir_entry *proc_netfilter;
	const struct nf_logger *nf_loggers[11];
	struct ctl_table_header *nf_log_dir_header;
	struct nf_hook_entries *hooks_ipv4[5];
	struct nf_hook_entries *hooks_ipv6[5];
	unsigned int defrag_ipv4_users;
	unsigned int defrag_ipv6_users;
};

struct nf_ct_event_notifier;

struct nf_generic_net {
	unsigned int timeout;
};

struct nf_tcp_net {
	unsigned int timeouts[14];
	u8 tcp_loose;
	u8 tcp_be_liberal;
	u8 tcp_max_retrans;
	u8 tcp_ignore_invalid_rst;
};

struct nf_udp_net {
	unsigned int timeouts[2];
};

struct nf_icmp_net {
	unsigned int timeout;
};

struct nf_ip_net {
	struct nf_generic_net generic;
	struct nf_tcp_net tcp;
	struct nf_udp_net udp;
	struct nf_icmp_net icmp;
	struct nf_icmp_net icmpv6;
};

struct netns_ct {
	u8 sysctl_log_invalid;
	u8 sysctl_events;
	u8 sysctl_acct;
	u8 sysctl_tstamp;
	u8 sysctl_checksum;
	struct ip_conntrack_stat *stat;
	struct nf_ct_event_notifier *nf_conntrack_event_cb;
	struct nf_ip_net nf_ct_proto;
};

struct netns_bpf {
	struct bpf_prog_array *run_array[2];
	struct bpf_prog *progs[2];
	struct list_head links[2];
};

struct xfrm_policy_hash {
	struct hlist_head *table;
	unsigned int hmask;
	u8 dbits4;
	u8 sbits4;
	u8 dbits6;
	u8 sbits6;
};

struct xfrm_policy_hthresh {
	struct work_struct work;
	seqlock_t lock;
	u8 lbits4;
	u8 rbits4;
	u8 lbits6;
	u8 rbits6;
};

struct netns_xfrm {
	struct list_head state_all;
	struct hlist_head *state_bydst;
	struct hlist_head *state_bysrc;
	struct hlist_head *state_byspi;
	struct hlist_head *state_byseq;
	struct hlist_head *state_cache_input;
	unsigned int state_hmask;
	unsigned int state_num;
	struct work_struct state_hash_work;
	struct list_head policy_all;
	struct hlist_head *policy_byidx;
	unsigned int policy_idx_hmask;
	unsigned int idx_generator;
	struct xfrm_policy_hash policy_bydst[3];
	unsigned int policy_count[6];
	struct work_struct policy_hash_work;
	struct xfrm_policy_hthresh policy_hthresh;
	struct list_head inexact_bins;
	struct sock *nlsk;
	struct sock *nlsk_stash;
	u32 sysctl_aevent_etime;
	u32 sysctl_aevent_rseqth;
	int sysctl_larval_drop;
	u32 sysctl_acq_expires;
	u8 policy_default[3];
	struct ctl_table_header *sysctl_hdr;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct dst_ops xfrm4_dst_ops;
	struct dst_ops xfrm6_dst_ops;
	spinlock_t xfrm_state_lock;
	seqcount_spinlock_t xfrm_state_hash_generation;
	seqcount_spinlock_t xfrm_policy_hash_generation;
	spinlock_t xfrm_policy_lock;
	struct mutex xfrm_cfg_mutex;
	struct delayed_work nat_keepalive_work;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct uevent_sock;

struct net_generic;

struct net {
	refcount_t passive;
	spinlock_t rules_mod_lock;
	unsigned int dev_base_seq;
	u32 ifindex;
	spinlock_t nsid_lock;
	atomic_t fnhe_genid;
	struct list_head list;
	struct list_head exit_list;
	struct llist_node defer_free_list;
	struct llist_node cleanup_list;
	struct key_tag *key_domain;
	struct user_namespace *user_ns;
	struct ucounts *ucounts;
	struct idr netns_ids;
	struct ns_common ns;
	struct ref_tracker_dir refcnt_tracker;
	struct ref_tracker_dir notrefcnt_tracker;
	struct list_head dev_base_head;
	struct proc_dir_entry *proc_net;
	struct proc_dir_entry *proc_net_stat;
	struct ctl_table_set sysctls;
	struct sock *rtnl;
	struct sock *genl_sock;
	struct uevent_sock *uevent_sock;
	struct hlist_head *dev_name_head;
	struct hlist_head *dev_index_head;
	struct xarray dev_by_index;
	struct raw_notifier_head netdev_chain;
	u32 hash_mix;
	struct net_device *loopback_dev;
	struct list_head rules_ops;
	struct netns_core core;
	struct netns_mib mib;
	struct netns_packet packet;
	struct netns_unix unx;
	struct netns_nexthop nexthop;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct netns_ipv4 ipv4;
	struct netns_ipv6 ipv6;
	struct netns_nf nf;
	struct netns_ct ct;
	struct net_generic *gen;
	struct netns_bpf bpf;
	long: 64;
	long: 64;
	struct netns_xfrm xfrm;
	u64 net_cookie;
	struct sock *diag_nlsk;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct netdev_tc_txq {
	u16 count;
	u16 offset;
};

typedef rx_handler_result_t rx_handler_func_t(struct sk_buff **);

struct net_device_stats {
	union {
		long unsigned int rx_packets;
		atomic_long_t __rx_packets;
	};
	union {
		long unsigned int tx_packets;
		atomic_long_t __tx_packets;
	};
	union {
		long unsigned int rx_bytes;
		atomic_long_t __rx_bytes;
	};
	union {
		long unsigned int tx_bytes;
		atomic_long_t __tx_bytes;
	};
	union {
		long unsigned int rx_errors;
		atomic_long_t __rx_errors;
	};
	union {
		long unsigned int tx_errors;
		atomic_long_t __tx_errors;
	};
	union {
		long unsigned int rx_dropped;
		atomic_long_t __rx_dropped;
	};
	union {
		long unsigned int tx_dropped;
		atomic_long_t __tx_dropped;
	};
	union {
		long unsigned int multicast;
		atomic_long_t __multicast;
	};
	union {
		long unsigned int collisions;
		atomic_long_t __collisions;
	};
	union {
		long unsigned int rx_length_errors;
		atomic_long_t __rx_length_errors;
	};
	union {
		long unsigned int rx_over_errors;
		atomic_long_t __rx_over_errors;
	};
	union {
		long unsigned int rx_crc_errors;
		atomic_long_t __rx_crc_errors;
	};
	union {
		long unsigned int rx_frame_errors;
		atomic_long_t __rx_frame_errors;
	};
	union {
		long unsigned int rx_fifo_errors;
		atomic_long_t __rx_fifo_errors;
	};
	union {
		long unsigned int rx_missed_errors;
		atomic_long_t __rx_missed_errors;
	};
	union {
		long unsigned int tx_aborted_errors;
		atomic_long_t __tx_aborted_errors;
	};
	union {
		long unsigned int tx_carrier_errors;
		atomic_long_t __tx_carrier_errors;
	};
	union {
		long unsigned int tx_fifo_errors;
		atomic_long_t __tx_fifo_errors;
	};
	union {
		long unsigned int tx_heartbeat_errors;
		atomic_long_t __tx_heartbeat_errors;
	};
	union {
		long unsigned int tx_window_errors;
		atomic_long_t __tx_window_errors;
	};
	union {
		long unsigned int rx_compressed;
		atomic_long_t __rx_compressed;
	};
	union {
		long unsigned int tx_compressed;
		atomic_long_t __tx_compressed;
	};
};

struct sfp_bus;

struct udp_tunnel_nic;

struct net_device_ops;

struct xps_dev_maps;

struct pcpu_lstats;

struct pcpu_sw_netstats;

struct pcpu_dstats;

struct netdev_rx_queue;

struct netpoll_info;

struct netdev_name_node;

struct xdp_metadata_ops;

struct xsk_tx_metadata_ops;

struct net_device_core_stats;

struct xdp_dev_bulk_queue;

struct netdev_stat_ops;

struct netdev_queue_mgmt_ops;

struct netprio_map;

struct phy_link_topology;

struct udp_tunnel_nic_info;

struct netdev_config;

struct rtnl_hw_stats64;

struct net_device {
	__u8 __cacheline_group_begin__net_device_read_tx[0];
	union {
		struct {
			long unsigned int priv_flags: 32;
			long unsigned int lltx: 1;
		};
		struct {
			long unsigned int priv_flags: 32;
			long unsigned int lltx: 1;
		} priv_flags_fast;
	};
	const struct net_device_ops *netdev_ops;
	const struct header_ops *header_ops;
	struct netdev_queue *_tx;
	netdev_features_t gso_partial_features;
	unsigned int real_num_tx_queues;
	unsigned int gso_max_size;
	unsigned int gso_ipv4_max_size;
	u16 gso_max_segs;
	s16 num_tc;
	unsigned int mtu;
	short unsigned int needed_headroom;
	struct netdev_tc_txq tc_to_txq[16];
	struct xps_dev_maps *xps_maps[2];
	struct nf_hook_entries *nf_hooks_egress;
	struct bpf_mprog_entry *tcx_egress;
	__u8 __cacheline_group_end__net_device_read_tx[0];
	__u8 __cacheline_group_begin__net_device_read_txrx[0];
	union {
		struct pcpu_lstats *lstats;
		struct pcpu_sw_netstats *tstats;
		struct pcpu_dstats *dstats;
	};
	long unsigned int state;
	unsigned int flags;
	short unsigned int hard_header_len;
	netdev_features_t features;
	struct inet6_dev *ip6_ptr;
	__u8 __cacheline_group_end__net_device_read_txrx[0];
	__u8 __cacheline_group_begin__net_device_read_rx[0];
	struct bpf_prog *xdp_prog;
	struct list_head ptype_specific;
	int ifindex;
	unsigned int real_num_rx_queues;
	struct netdev_rx_queue *_rx;
	unsigned int gro_max_size;
	unsigned int gro_ipv4_max_size;
	rx_handler_func_t *rx_handler;
	void *rx_handler_data;
	possible_net_t nd_net;
	struct netpoll_info *npinfo;
	struct bpf_mprog_entry *tcx_ingress;
	__u8 __cacheline_group_end__net_device_read_rx[0];
	char name[16];
	struct netdev_name_node *name_node;
	struct dev_ifalias *ifalias;
	long unsigned int mem_end;
	long unsigned int mem_start;
	long unsigned int base_addr;
	struct list_head dev_list;
	struct list_head napi_list;
	struct list_head unreg_list;
	struct list_head close_list;
	struct list_head ptype_all;
	struct {
		struct list_head upper;
		struct list_head lower;
	} adj_list;
	xdp_features_t xdp_features;
	const struct xdp_metadata_ops *xdp_metadata_ops;
	const struct xsk_tx_metadata_ops *xsk_tx_metadata_ops;
	short unsigned int gflags;
	short unsigned int needed_tailroom;
	netdev_features_t hw_features;
	netdev_features_t wanted_features;
	netdev_features_t vlan_features;
	netdev_features_t hw_enc_features;
	netdev_features_t mpls_features;
	unsigned int min_mtu;
	unsigned int max_mtu;
	short unsigned int type;
	unsigned char min_header_len;
	unsigned char name_assign_type;
	int group;
	struct net_device_stats stats;
	struct net_device_core_stats *core_stats;
	atomic_t carrier_up_count;
	atomic_t carrier_down_count;
	const struct ethtool_ops *ethtool_ops;
	const struct ndisc_ops *ndisc_ops;
	unsigned int operstate;
	unsigned char link_mode;
	unsigned char if_port;
	unsigned char dma;
	unsigned char perm_addr[32];
	unsigned char addr_assign_type;
	unsigned char addr_len;
	unsigned char upper_level;
	unsigned char lower_level;
	short unsigned int neigh_priv_len;
	short unsigned int dev_id;
	short unsigned int dev_port;
	int irq;
	u32 priv_len;
	spinlock_t addr_list_lock;
	struct netdev_hw_addr_list uc;
	struct netdev_hw_addr_list mc;
	struct netdev_hw_addr_list dev_addrs;
	struct kset *queues_kset;
	unsigned int promiscuity;
	unsigned int allmulti;
	bool uc_promisc;
	struct in_device *ip_ptr;
	struct hlist_head fib_nh_head;
	struct wireless_dev *ieee80211_ptr;
	const unsigned char *dev_addr;
	unsigned int num_rx_queues;
	unsigned int xdp_zc_max_segs;
	struct netdev_queue *ingress_queue;
	struct nf_hook_entries *nf_hooks_ingress;
	unsigned char broadcast[32];
	struct cpu_rmap *rx_cpu_rmap;
	struct hlist_node index_hlist;
	unsigned int num_tx_queues;
	struct Qdisc *qdisc;
	unsigned int tx_queue_len;
	spinlock_t tx_global_lock;
	struct xdp_dev_bulk_queue *xdp_bulkq;
	struct hlist_head qdisc_hash[16];
	struct timer_list watchdog_timer;
	int watchdog_timeo;
	u32 proto_down_reason;
	struct list_head todo_list;
	int *pcpu_refcnt;
	struct ref_tracker_dir refcnt_tracker;
	struct list_head link_watch_list;
	u8 reg_state;
	bool dismantle;
	enum {
		RTNL_LINK_INITIALIZED = 0,
		RTNL_LINK_INITIALIZING = 1,
	} rtnl_link_state: 16;
	bool needs_free_netdev;
	void (*priv_destructor)(struct net_device *);
	void *ml_priv;
	enum netdev_ml_priv_type ml_priv_type;
	enum netdev_stat_type pcpu_stat_type: 8;
	struct device dev;
	const struct attribute_group *sysfs_groups[4];
	const struct attribute_group *sysfs_rx_queue_group;
	const struct rtnl_link_ops *rtnl_link_ops;
	const struct netdev_stat_ops *stat_ops;
	const struct netdev_queue_mgmt_ops *queue_mgmt_ops;
	unsigned int tso_max_size;
	u16 tso_max_segs;
	u8 prio_tc_map[16];
	struct netprio_map *priomap;
	struct phy_link_topology *link_topo;
	struct phy_device *phydev;
	struct sfp_bus *sfp_bus;
	struct lock_class_key *qdisc_tx_busylock;
	bool proto_down;
	bool threaded;
	long unsigned int see_all_hwtstamp_requests: 1;
	long unsigned int change_proto_down: 1;
	long unsigned int netns_local: 1;
	long unsigned int fcoe_mtu: 1;
	struct list_head net_notifier_list;
	const struct udp_tunnel_nic_info *udp_tunnel_nic_info;
	struct udp_tunnel_nic *udp_tunnel_nic;
	struct netdev_config *cfg;
	struct netdev_config *cfg_pending;
	struct ethtool_netdev_state *ethtool;
	struct bpf_xdp_entity xdp_state[3];
	u8 dev_addr_shadow[32];
	netdevice_tracker linkwatch_dev_tracker;
	netdevice_tracker watchdog_dev_tracker;
	netdevice_tracker dev_registered_tracker;
	struct rtnl_hw_stats64 *offload_xstats_l3;
	struct devlink_port *devlink_port;
	struct hlist_head page_pools;
	struct dim_irq_moder *irq_moder;
	u64 max_pacing_offload_horizon;
	struct napi_config *napi_config;
	long unsigned int gro_flush_timeout;
	u32 napi_defer_hard_irqs;
	bool up;
	struct mutex lock;
	struct hlist_head neighbours[2];
	struct hwtstamp_provider *hwprov;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	u8 priv[0];
};

struct net_device_core_stats {
	long unsigned int rx_dropped;
	long unsigned int tx_dropped;
	long unsigned int rx_nohandler;
	long unsigned int rx_otherhost_dropped;
};

struct net_device_devres {
	struct net_device *ndev;
};

struct rtnl_link_stats64;

struct netdev_bpf;

struct xdp_frame;

struct skb_shared_hwtstamps;

struct net_device_ops {
	int (*ndo_init)(struct net_device *);
	void (*ndo_uninit)(struct net_device *);
	int (*ndo_open)(struct net_device *);
	int (*ndo_stop)(struct net_device *);
	netdev_tx_t (*ndo_start_xmit)(struct sk_buff *, struct net_device *);
	netdev_features_t (*ndo_features_check)(struct sk_buff *, struct net_device *, netdev_features_t);
	u16 (*ndo_select_queue)(struct net_device *, struct sk_buff *, struct net_device *);
	void (*ndo_change_rx_flags)(struct net_device *, int);
	void (*ndo_set_rx_mode)(struct net_device *);
	int (*ndo_set_mac_address)(struct net_device *, void *);
	int (*ndo_validate_addr)(struct net_device *);
	int (*ndo_do_ioctl)(struct net_device *, struct ifreq *, int);
	int (*ndo_eth_ioctl)(struct net_device *, struct ifreq *, int);
	int (*ndo_siocbond)(struct net_device *, struct ifreq *, int);
	int (*ndo_siocwandev)(struct net_device *, struct if_settings *);
	int (*ndo_siocdevprivate)(struct net_device *, struct ifreq *, void *, int);
	int (*ndo_set_config)(struct net_device *, struct ifmap *);
	int (*ndo_change_mtu)(struct net_device *, int);
	int (*ndo_neigh_setup)(struct net_device *, struct neigh_parms *);
	void (*ndo_tx_timeout)(struct net_device *, unsigned int);
	void (*ndo_get_stats64)(struct net_device *, struct rtnl_link_stats64 *);
	bool (*ndo_has_offload_stats)(const struct net_device *, int);
	int (*ndo_get_offload_stats)(int, const struct net_device *, void *);
	struct net_device_stats * (*ndo_get_stats)(struct net_device *);
	int (*ndo_vlan_rx_add_vid)(struct net_device *, __be16, u16);
	int (*ndo_vlan_rx_kill_vid)(struct net_device *, __be16, u16);
	void (*ndo_poll_controller)(struct net_device *);
	int (*ndo_netpoll_setup)(struct net_device *);
	void (*ndo_netpoll_cleanup)(struct net_device *);
	int (*ndo_set_vf_mac)(struct net_device *, int, u8 *);
	int (*ndo_set_vf_vlan)(struct net_device *, int, u16, u8, __be16);
	int (*ndo_set_vf_rate)(struct net_device *, int, int, int);
	int (*ndo_set_vf_spoofchk)(struct net_device *, int, bool);
	int (*ndo_set_vf_trust)(struct net_device *, int, bool);
	int (*ndo_get_vf_config)(struct net_device *, int, struct ifla_vf_info *);
	int (*ndo_set_vf_link_state)(struct net_device *, int, int);
	int (*ndo_get_vf_stats)(struct net_device *, int, struct ifla_vf_stats *);
	int (*ndo_set_vf_port)(struct net_device *, int, struct nlattr **);
	int (*ndo_get_vf_port)(struct net_device *, int, struct sk_buff *);
	int (*ndo_get_vf_guid)(struct net_device *, int, struct ifla_vf_guid *, struct ifla_vf_guid *);
	int (*ndo_set_vf_guid)(struct net_device *, int, u64, int);
	int (*ndo_set_vf_rss_query_en)(struct net_device *, int, bool);
	int (*ndo_setup_tc)(struct net_device *, enum tc_setup_type, void *);
	int (*ndo_rx_flow_steer)(struct net_device *, const struct sk_buff *, u16, u32);
	int (*ndo_add_slave)(struct net_device *, struct net_device *, struct netlink_ext_ack *);
	int (*ndo_del_slave)(struct net_device *, struct net_device *);
	struct net_device * (*ndo_get_xmit_slave)(struct net_device *, struct sk_buff *, bool);
	struct net_device * (*ndo_sk_get_lower_dev)(struct net_device *, struct sock *);
	netdev_features_t (*ndo_fix_features)(struct net_device *, netdev_features_t);
	int (*ndo_set_features)(struct net_device *, netdev_features_t);
	int (*ndo_neigh_construct)(struct net_device *, struct neighbour *);
	void (*ndo_neigh_destroy)(struct net_device *, struct neighbour *);
	int (*ndo_fdb_add)(struct ndmsg *, struct nlattr **, struct net_device *, const unsigned char *, u16, u16, bool *, struct netlink_ext_ack *);
	int (*ndo_fdb_del)(struct ndmsg *, struct nlattr **, struct net_device *, const unsigned char *, u16, bool *, struct netlink_ext_ack *);
	int (*ndo_fdb_del_bulk)(struct nlmsghdr *, struct net_device *, struct netlink_ext_ack *);
	int (*ndo_fdb_dump)(struct sk_buff *, struct netlink_callback *, struct net_device *, struct net_device *, int *);
	int (*ndo_fdb_get)(struct sk_buff *, struct nlattr **, struct net_device *, const unsigned char *, u16, u32, u32, struct netlink_ext_ack *);
	int (*ndo_mdb_add)(struct net_device *, struct nlattr **, u16, struct netlink_ext_ack *);
	int (*ndo_mdb_del)(struct net_device *, struct nlattr **, struct netlink_ext_ack *);
	int (*ndo_mdb_del_bulk)(struct net_device *, struct nlattr **, struct netlink_ext_ack *);
	int (*ndo_mdb_dump)(struct net_device *, struct sk_buff *, struct netlink_callback *);
	int (*ndo_mdb_get)(struct net_device *, struct nlattr **, u32, u32, struct netlink_ext_ack *);
	int (*ndo_bridge_setlink)(struct net_device *, struct nlmsghdr *, u16, struct netlink_ext_ack *);
	int (*ndo_bridge_getlink)(struct sk_buff *, u32, u32, struct net_device *, u32, int);
	int (*ndo_bridge_dellink)(struct net_device *, struct nlmsghdr *, u16);
	int (*ndo_change_carrier)(struct net_device *, bool);
	int (*ndo_get_phys_port_id)(struct net_device *, struct netdev_phys_item_id *);
	int (*ndo_get_port_parent_id)(struct net_device *, struct netdev_phys_item_id *);
	int (*ndo_get_phys_port_name)(struct net_device *, char *, size_t);
	void * (*ndo_dfwd_add_station)(struct net_device *, struct net_device *);
	void (*ndo_dfwd_del_station)(struct net_device *, void *);
	int (*ndo_set_tx_maxrate)(struct net_device *, int, u32);
	int (*ndo_get_iflink)(const struct net_device *);
	int (*ndo_fill_metadata_dst)(struct net_device *, struct sk_buff *);
	void (*ndo_set_rx_headroom)(struct net_device *, int);
	int (*ndo_bpf)(struct net_device *, struct netdev_bpf *);
	int (*ndo_xdp_xmit)(struct net_device *, int, struct xdp_frame **, u32);
	struct net_device * (*ndo_xdp_get_xmit_slave)(struct net_device *, struct xdp_buff *);
	int (*ndo_xsk_wakeup)(struct net_device *, u32, u32);
	int (*ndo_tunnel_ctl)(struct net_device *, struct ip_tunnel_parm_kern *, int);
	struct net_device * (*ndo_get_peer_dev)(struct net_device *);
	int (*ndo_fill_forward_path)(struct net_device_path_ctx *, struct net_device_path *);
	ktime_t (*ndo_get_tstamp)(struct net_device *, const struct skb_shared_hwtstamps *, bool);
	int (*ndo_hwtstamp_get)(struct net_device *, struct kernel_hwtstamp_config *);
	int (*ndo_hwtstamp_set)(struct net_device *, struct kernel_hwtstamp_config *, struct netlink_ext_ack *);
};

struct net_device_path {
	enum net_device_path_type type;
	const struct net_device *dev;
	union {
		struct {
			u16 id;
			__be16 proto;
			u8 h_dest[6];
		} encap;
		struct {
			enum {
				DEV_PATH_BR_VLAN_KEEP = 0,
				DEV_PATH_BR_VLAN_TAG = 1,
				DEV_PATH_BR_VLAN_UNTAG = 2,
				DEV_PATH_BR_VLAN_UNTAG_HW = 3,
			} vlan_mode;
			u16 vlan_id;
			__be16 vlan_proto;
		} bridge;
		struct {
			int port;
			u16 proto;
		} dsa;
		struct {
			u8 wdma_idx;
			u8 queue;
			u16 wcid;
			u8 bss;
			u8 amsdu;
		} mtk_wdma;
	};
};

struct net_device_path_ctx {
	const struct net_device *dev;
	u8 daddr[6];
	int num_vlans;
	struct {
		u16 id;
		__be16 proto;
	} vlan[2];
};

struct net_device_path_stack {
	int num_paths;
	struct net_device_path path[5];
};

struct net_devmem_dmabuf_binding {
	struct dma_buf *dmabuf;
	struct dma_buf_attachment *attachment;
	struct sg_table *sgt;
	struct net_device *dev;
	struct gen_pool *chunk_pool;
	refcount_t ref;
	struct list_head list;
	struct xarray bound_rxqs;
	u32 id;
};

struct rtnl_link_stats64 {
	__u64 rx_packets;
	__u64 tx_packets;
	__u64 rx_bytes;
	__u64 tx_bytes;
	__u64 rx_errors;
	__u64 tx_errors;
	__u64 rx_dropped;
	__u64 tx_dropped;
	__u64 multicast;
	__u64 collisions;
	__u64 rx_length_errors;
	__u64 rx_over_errors;
	__u64 rx_crc_errors;
	__u64 rx_frame_errors;
	__u64 rx_fifo_errors;
	__u64 rx_missed_errors;
	__u64 tx_aborted_errors;
	__u64 tx_carrier_errors;
	__u64 tx_fifo_errors;
	__u64 tx_heartbeat_errors;
	__u64 tx_window_errors;
	__u64 rx_compressed;
	__u64 tx_compressed;
	__u64 rx_nohandler;
	__u64 rx_otherhost_dropped;
};

struct net_failover_info {
	struct net_device *primary_dev;
	struct net_device *standby_dev;
	struct rtnl_link_stats64 primary_stats;
	struct rtnl_link_stats64 standby_stats;
	struct rtnl_link_stats64 failover_stats;
	spinlock_t stats_lock;
};

struct net_fill_args {
	u32 portid;
	u32 seq;
	int flags;
	int cmd;
	int nsid;
	bool add_ref;
	int ref_nsid;
};

struct net_generic {
	union {
		struct {
			unsigned int len;
			struct callback_head rcu;
		} s;
		struct {
			struct {} __empty_ptr;
			void *ptr[0];
		};
	};
};

struct offload_callbacks {
	struct sk_buff * (*gso_segment)(struct sk_buff *, netdev_features_t);
	struct sk_buff * (*gro_receive)(struct list_head *, struct sk_buff *);
	int (*gro_complete)(struct sk_buff *, int);
};

struct packet_offload {
	__be16 type;
	u16 priority;
	struct offload_callbacks callbacks;
	struct list_head list;
};

struct net_offload {
	struct offload_callbacks callbacks;
	unsigned int flags;
	u32 secret;
};

struct net_protocol {
	int (*handler)(struct sk_buff *);
	int (*err_handler)(struct sk_buff *, u32);
	unsigned int no_policy: 1;
	unsigned int icmp_strict_tag_validation: 1;
	u32 secret;
};

struct rps_sock_flow_table;

struct net_hotdata {
	struct packet_offload ip_packet_offload;
	struct net_offload tcpv4_offload;
	struct net_protocol tcp_protocol;
	struct net_offload udpv4_offload;
	struct net_protocol udp_protocol;
	struct packet_offload ipv6_packet_offload;
	struct net_offload tcpv6_offload;
	struct inet6_protocol tcpv6_protocol;
	struct inet6_protocol udpv6_protocol;
	struct net_offload udpv6_offload;
	struct list_head offload_base;
	struct list_head ptype_all;
	struct kmem_cache *skbuff_cache;
	struct kmem_cache *skbuff_fclone_cache;
	struct kmem_cache *skb_small_head_cache;
	struct rps_sock_flow_table *rps_sock_flow_table;
	u32 rps_cpu_mask;
	int gro_normal_batch;
	int netdev_budget;
	int netdev_budget_usecs;
	int tstamp_prequeue;
	int max_backlog;
	int dev_tx_weight;
	int dev_rx_weight;
	int sysctl_max_skb_frags;
	int sysctl_skb_defer_max;
	int sysctl_mem_pcpu_rsv;
};

struct net_iov {
	long unsigned int __unused_padding;
	long unsigned int pp_magic;
	struct page_pool *pp;
	struct dmabuf_genpool_chunk_owner *owner;
	long unsigned int dma_addr;
	atomic_long_t pp_ref_count;
};

struct net_packet_attrs {
	const unsigned char *src;
	const unsigned char *dst;
	u32 ip_src;
	u32 ip_dst;
	bool tcp;
	u16 sport;
	u16 dport;
	int timeout;
	int size;
	int max_size;
	u8 id;
	u16 queue_mapping;
};

struct net_proto_family {
	int family;
	int (*create)(struct net *, struct socket *, int, int);
	struct module *owner;
};

struct net_rate_estimator {
	struct gnet_stats_basic_sync *bstats;
	spinlock_t *stats_lock;
	bool running;
	struct gnet_stats_basic_sync *cpu_bstats;
	u8 ewma_log;
	u8 intvl_log;
	seqcount_t seq;
	u64 last_packets;
	u64 last_bytes;
	u64 avpps;
	u64 avbps;
	long unsigned int next_jiffies;
	struct timer_list timer;
	struct callback_head rcu;
};

struct net_test {
	char name[32];
	int (*fn)(struct net_device *);
};

struct packet_type {
	__be16 type;
	bool ignore_outgoing;
	struct net_device *dev;
	netdevice_tracker dev_tracker;
	int (*func)(struct sk_buff *, struct net_device *, struct packet_type *, struct net_device *);
	void (*list_func)(struct list_head *, struct packet_type *, struct net_device *);
	bool (*id_match)(struct packet_type *, struct sock *);
	struct net *af_packet_net;
	void *af_packet_priv;
	struct list_head list;
};

struct net_test_priv {
	struct net_packet_attrs *packet;
	struct packet_type pt;
	struct completion comp;
	int double_vlan;
	int vlan_id;
	int ok;
};

struct netconfmsg {
	__u8 ncm_family;
};

struct netconsole_target_stats {
	u64_stats_t xmit_drop_count;
	u64_stats_t enomem_count;
	struct u64_stats_sync syncp;
};

struct netpoll {
	struct net_device *dev;
	netdevice_tracker dev_tracker;
	char dev_name[16];
	const char *name;
	union inet_addr local_ip;
	union inet_addr remote_ip;
	bool ipv6;
	u16 local_port;
	u16 remote_port;
	u8 remote_mac[6];
	struct sk_buff_head skb_pool;
};

struct netconsole_target {
	struct list_head list;
	struct netconsole_target_stats stats;
	bool enabled;
	bool extended;
	bool release;
	struct netpoll np;
};

struct netdev_adjacent {
	struct net_device *dev;
	netdevice_tracker dev_tracker;
	bool master;
	bool ignore;
	u16 ref_nr;
	void *private;
	struct list_head list;
	struct callback_head rcu;
};

struct netdev_bonding_info {
	ifslave slave;
	ifbond master;
};

struct xsk_buff_pool;

struct netdev_bpf {
	enum bpf_netdev_command command;
	union {
		struct {
			u32 flags;
			struct bpf_prog *prog;
			struct netlink_ext_ack *extack;
		};
		struct {
			struct bpf_offloaded_map *offmap;
		};
		struct {
			struct xsk_buff_pool *pool;
			u16 queue_id;
		} xsk;
	};
};

struct netdev_config {
	u32 hds_thresh;
	u8 hds_config;
};

struct netdev_hw_addr {
	struct list_head list;
	struct rb_node node;
	unsigned char addr[32];
	unsigned char type;
	bool global_use;
	int sync_cnt;
	int refcount;
	int synced;
	struct callback_head callback_head;
};

struct netdev_lag_lower_state_info {
	u8 link_up: 1;
	u8 tx_enabled: 1;
};

struct netdev_lag_upper_info {
	enum netdev_lag_tx_type tx_type;
	enum netdev_lag_hash hash_type;
};

struct netdev_name_node {
	struct hlist_node hlist;
	struct list_head list;
	struct net_device *dev;
	const char *name;
	struct callback_head rcu;
};

struct netdev_nested_priv {
	unsigned char flags;
	void *data;
};

struct netdev_net_notifier {
	struct list_head list;
	struct notifier_block *nb;
};

struct netdev_nl_dump_ctx {
	long unsigned int ifindex;
	unsigned int rxq_idx;
	unsigned int txq_idx;
	unsigned int napi_id;
};

struct netdev_notifier_info {
	struct net_device *dev;
	struct netlink_ext_ack *extack;
};

struct netdev_notifier_bonding_info {
	struct netdev_notifier_info info;
	struct netdev_bonding_info bonding_info;
};

struct netdev_notifier_change_info {
	struct netdev_notifier_info info;
	unsigned int flags_changed;
};

struct netdev_notifier_changelowerstate_info {
	struct netdev_notifier_info info;
	void *lower_state_info;
};

struct netdev_notifier_changeupper_info {
	struct netdev_notifier_info info;
	struct net_device *upper_dev;
	bool master;
	bool linking;
	void *upper_info;
};

struct netdev_notifier_info_ext {
	struct netdev_notifier_info info;
	union {
		u32 mtu;
	} ext;
};

struct netdev_notifier_offload_xstats_rd;

struct netdev_notifier_offload_xstats_ru;

struct netdev_notifier_offload_xstats_info {
	struct netdev_notifier_info info;
	enum netdev_offload_xstats_type type;
	union {
		struct netdev_notifier_offload_xstats_rd *report_delta;
		struct netdev_notifier_offload_xstats_ru *report_used;
	};
};

struct rtnl_hw_stats64 {
	__u64 rx_packets;
	__u64 tx_packets;
	__u64 rx_bytes;
	__u64 tx_bytes;
	__u64 rx_errors;
	__u64 tx_errors;
	__u64 rx_dropped;
	__u64 tx_dropped;
	__u64 multicast;
};

struct netdev_notifier_offload_xstats_rd {
	struct rtnl_hw_stats64 stats;
	bool used;
};

struct netdev_notifier_offload_xstats_ru {
	bool used;
};

struct netdev_notifier_pre_changeaddr_info {
	struct netdev_notifier_info info;
	const unsigned char *dev_addr;
};

struct netdev_queue {
	struct net_device *dev;
	netdevice_tracker dev_tracker;
	struct Qdisc *qdisc;
	struct Qdisc *qdisc_sleeping;
	struct kobject kobj;
	long unsigned int tx_maxrate;
	atomic_long_t trans_timeout;
	struct net_device *sb_dev;
	long: 64;
	long: 64;
	struct dql dql;
	spinlock_t _xmit_lock;
	int xmit_lock_owner;
	long unsigned int trans_start;
	long unsigned int state;
	struct napi_struct *napi;
	int numa_node;
	long: 64;
	long: 64;
	long: 64;
};

struct netdev_queue_attribute {
	struct attribute attr;
	ssize_t (*show)(struct netdev_queue *, char *);
	ssize_t (*store)(struct netdev_queue *, const char *, size_t);
};

struct netdev_queue_mgmt_ops {
	size_t ndo_queue_mem_size;
	int (*ndo_queue_mem_alloc)(struct net_device *, void *, int);
	void (*ndo_queue_mem_free)(struct net_device *, void *);
	int (*ndo_queue_start)(struct net_device *, void *, int);
	int (*ndo_queue_stop)(struct net_device *, void *, int);
};

struct netdev_queue_stats_rx {
	u64 bytes;
	u64 packets;
	u64 alloc_fail;
	u64 hw_drops;
	u64 hw_drop_overruns;
	u64 csum_unnecessary;
	u64 csum_none;
	u64 csum_bad;
	u64 hw_gro_packets;
	u64 hw_gro_bytes;
	u64 hw_gro_wire_packets;
	u64 hw_gro_wire_bytes;
	u64 hw_drop_ratelimits;
};

struct netdev_queue_stats_tx {
	u64 bytes;
	u64 packets;
	u64 hw_drops;
	u64 hw_drop_errors;
	u64 csum_none;
	u64 needs_csum;
	u64 hw_gso_packets;
	u64 hw_gso_bytes;
	u64 hw_gso_wire_packets;
	u64 hw_gso_wire_bytes;
	u64 hw_drop_ratelimits;
	u64 stop;
	u64 wake;
};

struct xdp_mem_info {
	u32 type;
	u32 id;
};

struct xdp_rxq_info {
	struct net_device *dev;
	u32 queue_index;
	u32 reg_state;
	struct xdp_mem_info mem;
	u32 frag_size;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct pp_memory_provider_params {
	void *mp_priv;
};

struct rps_map;

struct rps_dev_flow_table;

struct netdev_rx_queue {
	struct xdp_rxq_info xdp_rxq;
	struct rps_map *rps_map;
	struct rps_dev_flow_table *rps_flow_table;
	struct kobject kobj;
	struct net_device *dev;
	netdevice_tracker dev_tracker;
	struct napi_struct *napi;
	struct pp_memory_provider_params mp_params;
	long: 64;
	long: 64;
	long: 64;
};

struct netdev_stat_ops {
	void (*get_queue_stats_rx)(struct net_device *, int, struct netdev_queue_stats_rx *);
	void (*get_queue_stats_tx)(struct net_device *, int, struct netdev_queue_stats_tx *);
	void (*get_base_stats)(struct net_device *, struct netdev_queue_stats_rx *, struct netdev_queue_stats_tx *);
};

struct netdev_xmit {
	u16 recursion;
	u8 more;
	u8 skip_txqueue;
};

struct netevent_redirect {
	struct dst_entry *old;
	struct dst_entry *new;
	struct neighbour *neigh;
	const void *daddr;
};

typedef void (*netfs_io_terminated_t)(void *, ssize_t, bool);

struct netfs_io_subrequest;

struct netfs_cache_ops {
	void (*end_operation)(struct netfs_cache_resources *);
	int (*read)(struct netfs_cache_resources *, loff_t, struct iov_iter *, enum netfs_read_from_hole, netfs_io_terminated_t, void *);
	int (*write)(struct netfs_cache_resources *, loff_t, struct iov_iter *, netfs_io_terminated_t, void *);
	void (*issue_write)(struct netfs_io_subrequest *);
	void (*expand_readahead)(struct netfs_cache_resources *, long long unsigned int *, long long unsigned int *, long long unsigned int);
	enum netfs_io_source (*prepare_read)(struct netfs_io_subrequest *, long long unsigned int);
	void (*prepare_write_subreq)(struct netfs_io_subrequest *);
	int (*prepare_write)(struct netfs_cache_resources *, loff_t *, size_t *, size_t, loff_t, bool);
	enum netfs_io_source (*prepare_ondemand_read)(struct netfs_cache_resources *, loff_t, size_t *, loff_t, long unsigned int *, ino_t);
	int (*query_occupancy)(struct netfs_cache_resources *, loff_t, size_t, size_t, loff_t *, size_t *);
};

struct netfs_cache_resources {
	const struct netfs_cache_ops *ops;
	void *cache_priv;
	void *cache_priv2;
	unsigned int debug_id;
	unsigned int inval_counter;
};

struct netfs_group;

struct netfs_folio {
	struct netfs_group *netfs_group;
	unsigned int dirty_offset;
	unsigned int dirty_len;
};

struct netfs_group {
	refcount_t ref;
	void (*free)(struct netfs_group *);
};

struct netfs_request_ops;

struct netfs_inode {
	struct inode inode;
	const struct netfs_request_ops *ops;
	struct mutex wb_lock;
	loff_t remote_i_size;
	loff_t zero_point;
	atomic_t io_count;
	long unsigned int flags;
};

struct netfs_io_stream {
	struct netfs_io_subrequest *construct;
	size_t sreq_max_len;
	unsigned int sreq_max_segs;
	unsigned int submit_off;
	unsigned int submit_len;
	unsigned int submit_extendable_to;
	void (*prepare_write)(struct netfs_io_subrequest *);
	void (*issue_write)(struct netfs_io_subrequest *);
	struct list_head subrequests;
	struct netfs_io_subrequest *front;
	long long unsigned int collected_to;
	size_t transferred;
	enum netfs_io_source source;
	short unsigned int error;
	unsigned char stream_nr;
	bool avail;
	bool active;
	bool need_retry;
	bool failed;
};

struct rolling_buffer {
	struct folio_queue *head;
	struct folio_queue *tail;
	struct iov_iter iter;
	u8 next_head_slot;
	u8 first_tail_slot;
};

struct netfs_io_request {
	union {
		struct work_struct work;
		struct callback_head rcu;
	};
	struct inode *inode;
	struct address_space *mapping;
	struct kiocb *iocb;
	struct netfs_cache_resources cache_resources;
	struct netfs_io_request *copy_to_cache;
	struct readahead_control *ractl;
	struct list_head proc_link;
	struct netfs_io_stream io_streams[2];
	struct netfs_group *group;
	struct rolling_buffer buffer;
	wait_queue_head_t waitq;
	void *netfs_priv;
	void *netfs_priv2;
	struct bio_vec *direct_bv;
	unsigned int direct_bv_count;
	unsigned int debug_id;
	unsigned int rsize;
	unsigned int wsize;
	atomic_t subreq_counter;
	unsigned int nr_group_rel;
	spinlock_t lock;
	long long unsigned int submitted;
	long long unsigned int len;
	size_t transferred;
	long int error;
	enum netfs_io_origin origin;
	bool direct_bv_unpin;
	long long unsigned int i_size;
	long long unsigned int start;
	atomic64_t issued_to;
	long long unsigned int collected_to;
	long long unsigned int cleaned_to;
	long long unsigned int abandon_to;
	long unsigned int no_unlock_folio;
	unsigned char front_folio_order;
	refcount_t ref;
	long unsigned int flags;
	const struct netfs_request_ops *netfs_ops;
	void (*cleanup)(struct netfs_io_request *);
};

struct netfs_io_subrequest {
	struct netfs_io_request *rreq;
	struct work_struct work;
	struct list_head rreq_link;
	struct iov_iter io_iter;
	long long unsigned int start;
	size_t len;
	size_t transferred;
	refcount_t ref;
	short int error;
	short unsigned int debug_index;
	unsigned int nr_segs;
	u8 retry_count;
	enum netfs_io_source source;
	unsigned char stream_nr;
	long unsigned int flags;
};

struct netfs_request_ops {
	mempool_t *request_pool;
	mempool_t *subrequest_pool;
	int (*init_request)(struct netfs_io_request *, struct file *);
	void (*free_request)(struct netfs_io_request *);
	void (*free_subrequest)(struct netfs_io_subrequest *);
	void (*expand_readahead)(struct netfs_io_request *);
	int (*prepare_read)(struct netfs_io_subrequest *);
	void (*issue_read)(struct netfs_io_subrequest *);
	bool (*is_still_valid)(struct netfs_io_request *);
	int (*check_write_begin)(struct file *, loff_t, unsigned int, struct folio **, void **);
	void (*done)(struct netfs_io_request *);
	void (*update_i_size)(struct inode *, loff_t);
	void (*post_modify)(struct inode *);
	void (*begin_writeback)(struct netfs_io_request *);
	void (*prepare_write)(struct netfs_io_subrequest *);
	void (*issue_write)(struct netfs_io_subrequest *);
	void (*retry_request)(struct netfs_io_request *, struct netfs_io_stream *);
	void (*invalidate_cache)(struct netfs_io_request *);
};

struct netif_security_struct {
	struct net *ns;
	int ifindex;
	u32 sid;
};

struct netlbl_af4list {
	__be32 addr;
	__be32 mask;
	u32 valid;
	struct list_head list;
};

struct netlbl_af6list {
	struct in6_addr addr;
	struct in6_addr mask;
	u32 valid;
	struct list_head list;
};

struct netlbl_audit {
	struct lsm_prop prop;
	kuid_t loginuid;
	unsigned int sessionid;
};

struct netlbl_calipso_doiwalk_arg {
	struct netlink_callback *nl_cb;
	struct sk_buff *skb;
	u32 seq;
};

struct netlbl_lsm_secattr;

struct netlbl_calipso_ops {
	int (*doi_add)(struct calipso_doi *, struct netlbl_audit *);
	void (*doi_free)(struct calipso_doi *);
	int (*doi_remove)(u32, struct netlbl_audit *);
	struct calipso_doi * (*doi_getdef)(u32);
	void (*doi_putdef)(struct calipso_doi *);
	int (*doi_walk)(u32 *, int (*)(struct calipso_doi *, void *), void *);
	int (*sock_getattr)(struct sock *, struct netlbl_lsm_secattr *);
	int (*sock_setattr)(struct sock *, const struct calipso_doi *, const struct netlbl_lsm_secattr *);
	void (*sock_delattr)(struct sock *);
	int (*req_setattr)(struct request_sock *, const struct calipso_doi *, const struct netlbl_lsm_secattr *);
	void (*req_delattr)(struct request_sock *);
	int (*opt_getattr)(const unsigned char *, struct netlbl_lsm_secattr *);
	unsigned char * (*skbuff_optptr)(const struct sk_buff *);
	int (*skbuff_setattr)(struct sk_buff *, const struct calipso_doi *, const struct netlbl_lsm_secattr *);
	int (*skbuff_delattr)(struct sk_buff *);
	void (*cache_invalidate)(void);
	int (*cache_add)(const unsigned char *, const struct netlbl_lsm_secattr *);
};

struct netlbl_cipsov4_doiwalk_arg {
	struct netlink_callback *nl_cb;
	struct sk_buff *skb;
	u32 seq;
};

struct netlbl_domaddr_map;

struct netlbl_dommap_def {
	u32 type;
	union {
		struct netlbl_domaddr_map *addrsel;
		struct cipso_v4_doi *cipso;
		struct calipso_doi *calipso;
	};
};

struct netlbl_dom_map {
	char *domain;
	struct netlbl_dommap_def def;
	u16 family;
	u32 valid;
	struct list_head list;
	struct callback_head rcu;
};

struct netlbl_domaddr4_map {
	struct netlbl_dommap_def def;
	struct netlbl_af4list list;
};

struct netlbl_domaddr6_map {
	struct netlbl_dommap_def def;
	struct netlbl_af6list list;
};

struct netlbl_domaddr_map {
	struct list_head list4;
	struct list_head list6;
};

struct netlbl_domhsh_tbl {
	struct list_head *tbl;
	u32 size;
};

struct netlbl_domhsh_walk_arg {
	struct netlink_callback *nl_cb;
	struct sk_buff *skb;
	u32 seq;
};

struct netlbl_domhsh_walk_arg___2 {
	struct netlbl_audit *audit_info;
	u32 doi;
};

struct netlbl_lsm_cache {
	refcount_t refcount;
	void (*free)(const void *);
	void *data;
};

struct netlbl_lsm_catmap {
	u32 startbit;
	u64 bitmap[4];
	struct netlbl_lsm_catmap *next;
};

struct netlbl_lsm_secattr {
	u32 flags;
	u32 type;
	char *domain;
	struct netlbl_lsm_cache *cache;
	struct {
		struct {
			struct netlbl_lsm_catmap *cat;
			u32 lvl;
		} mls;
		u32 secid;
	} attr;
};

struct netlbl_unlhsh_addr4 {
	u32 secid;
	struct netlbl_af4list list;
	struct callback_head rcu;
};

struct netlbl_unlhsh_addr6 {
	u32 secid;
	struct netlbl_af6list list;
	struct callback_head rcu;
};

struct netlbl_unlhsh_iface {
	int ifindex;
	struct list_head addr4_list;
	struct list_head addr6_list;
	u32 valid;
	struct list_head list;
	struct callback_head rcu;
};

struct netlbl_unlhsh_tbl {
	struct list_head *tbl;
	u32 size;
};

struct netlbl_unlhsh_walk_arg {
	struct netlink_callback *nl_cb;
	struct sk_buff *skb;
	u32 seq;
};

struct netlink_broadcast_data {
	struct sock *exclude_sk;
	struct net *net;
	u32 portid;
	u32 group;
	int failure;
	int delivery_failure;
	int congested;
	int delivered;
	gfp_t allocation;
	struct sk_buff *skb;
	struct sk_buff *skb2;
	int (*tx_filter)(struct sock *, struct sk_buff *, void *);
	void *tx_data;
};

struct netlink_callback {
	struct sk_buff *skb;
	const struct nlmsghdr *nlh;
	int (*dump)(struct sk_buff *, struct netlink_callback *);
	int (*done)(struct netlink_callback *);
	void *data;
	struct module *module;
	struct netlink_ext_ack *extack;
	u16 family;
	u16 answer_flags;
	u32 min_dump_alloc;
	unsigned int prev_seq;
	unsigned int seq;
	int flags;
	bool strict_check;
	union {
		u8 ctx[48];
		long int args[6];
	};
};

struct netlink_compare_arg {
	possible_net_t pnet;
	u32 portid;
};

struct netlink_dump_control {
	int (*start)(struct netlink_callback *);
	int (*dump)(struct sk_buff *, struct netlink_callback *);
	int (*done)(struct netlink_callback *);
	struct netlink_ext_ack *extack;
	void *data;
	struct module *module;
	u32 min_dump_alloc;
	int flags;
};

struct netlink_ext_ack {
	const char *_msg;
	const struct nlattr *bad_attr;
	const struct nla_policy *policy;
	const struct nlattr *miss_nest;
	u16 miss_type;
	u8 cookie[20];
	u8 cookie_len;
	char _msg_buf[80];
};

struct netlink_kernel_cfg {
	unsigned int groups;
	unsigned int flags;
	void (*input)(struct sk_buff *);
	int (*bind)(struct net *, int);
	void (*unbind)(struct net *, int);
	void (*release)(struct sock *, long unsigned int *);
};

struct netlink_notify {
	struct net *net;
	u32 portid;
	int protocol;
};

struct netlink_policy_dump_state {
	unsigned int policy_idx;
	unsigned int attr_idx;
	unsigned int n_alloc;
	struct {
		const struct nla_policy *policy;
		unsigned int maxtype;
	} policies[0];
};

struct netlink_range_validation {
	u64 min;
	u64 max;
};

struct netlink_range_validation_signed {
	s64 min;
	s64 max;
};

struct netlink_set_err_data {
	struct sock *exclude_sk;
	u32 portid;
	u32 group;
	int code;
};

struct scm_creds {
	u32 pid;
	kuid_t uid;
	kgid_t gid;
};

struct netlink_skb_parms {
	struct scm_creds creds;
	__u32 portid;
	__u32 dst_group;
	__u32 flags;
	struct sock *sk;
	bool nsid_is_set;
	int nsid;
};

struct netlink_sock {
	struct sock sk;
	long unsigned int flags;
	u32 portid;
	u32 dst_portid;
	u32 dst_group;
	u32 subscriptions;
	u32 ngroups;
	long unsigned int *groups;
	long unsigned int state;
	size_t max_recvmsg_len;
	wait_queue_head_t wait;
	bool bound;
	bool cb_running;
	int dump_done_errno;
	struct netlink_callback cb;
	struct mutex nl_cb_mutex;
	void (*netlink_rcv)(struct sk_buff *);
	int (*netlink_bind)(struct net *, int);
	void (*netlink_unbind)(struct net *, int);
	void (*netlink_release)(struct sock *, long unsigned int *);
	struct module *module;
	struct rhash_head node;
	struct callback_head rcu;
};

struct netlink_table {
	struct rhashtable hash;
	struct hlist_head mc_list;
	struct listeners *listeners;
	unsigned int flags;
	unsigned int groups;
	struct mutex *cb_mutex;
	struct module *module;
	int (*bind)(struct net *, int);
	void (*unbind)(struct net *, int);
	void (*release)(struct sock *, long unsigned int *);
	int registered;
};

struct netlink_tap {
	struct net_device *dev;
	struct module *module;
	struct list_head list;
};

struct netlink_tap_net {
	struct list_head netlink_tap_all;
	struct mutex netlink_tap_lock;
};

struct netnode_security_struct {
	union {
		__be32 ipv4;
		struct in6_addr ipv6;
	} addr;
	u32 sid;
	u16 family;
};

struct netpoll_info {
	refcount_t refcnt;
	struct semaphore dev_lock;
	struct sk_buff_head txq;
	struct delayed_work tx_work;
	struct netpoll *netpoll;
	struct callback_head rcu;
};

struct netport_security_struct {
	u32 sid;
	u16 port;
	u8 protocol;
};

struct netprio_map {
	struct callback_head rcu;
	u32 priomap_len;
	u32 priomap[0];
};

struct netsfhdr {
	__be32 version;
	__be64 magic;
	u8 id;
} __attribute__((packed));

struct new_utsname {
	char sysname[65];
	char nodename[65];
	char release[65];
	char version[65];
	char machine[65];
	char domainname[65];
};

struct nh_info;

struct nh_group;

struct nexthop {
	struct rb_node rb_node;
	struct list_head fi_list;
	struct list_head f6i_list;
	struct list_head fdb_list;
	struct list_head grp_list;
	struct net *net;
	u32 id;
	u8 protocol;
	u8 nh_flags;
	bool is_group;
	refcount_t refcnt;
	struct callback_head rcu;
	union {
		struct nh_info *nh_info;
		struct nh_group *nh_grp;
	};
};

struct nexthop_grp {
	__u32 id;
	__u8 weight;
	__u8 weight_high;
	__u16 resvd2;
};

struct nf_conntrack {
	refcount_t use;
};

struct nf_conntrack_tuple_hash {
	struct hlist_nulls_node hnnode;
	struct nf_conntrack_tuple tuple;
};

struct nf_ct_dccp {
	u_int8_t role[2];
	u_int8_t state;
	u_int8_t last_pkt;
	u_int8_t last_dir;
	u_int64_t handshake_seq;
};

struct nf_ct_udp {
	long unsigned int stream_ts;
};

struct nf_ct_gre {
	unsigned int stream_timeout;
	unsigned int timeout;
};

union nf_conntrack_proto {
	struct nf_ct_dccp dccp;
	struct ip_ct_sctp sctp;
	struct ip_ct_tcp tcp;
	struct nf_ct_udp udp;
	struct nf_ct_gre gre;
	unsigned int tmpl_padto;
};

struct nf_ct_ext;

struct nf_conn {
	struct nf_conntrack ct_general;
	spinlock_t lock;
	u32 timeout;
	struct nf_conntrack_tuple_hash tuplehash[2];
	long unsigned int status;
	possible_net_t ct_net;
	struct hlist_node nat_bysource;
	struct {} __nfct_init_offset;
	struct nf_conn *master;
	u_int32_t secmark;
	struct nf_ct_ext *ext;
	union nf_conntrack_proto proto;
};

struct nf_conn___init {
	struct nf_conn ct;
};

struct nf_conn_counter {
	atomic64_t packets;
	atomic64_t bytes;
};

struct nf_conn_acct {
	struct nf_conn_counter counter[2];
};

struct nf_conntrack_helper;

struct nf_conn_help {
	struct nf_conntrack_helper *helper;
	struct hlist_head expectations;
	u8 expecting[4];
	long: 0;
	char data[32];
};

struct nf_conn_labels {
	long unsigned int bits[2];
};

union nf_conntrack_nat_help {};

struct nf_conn_nat {
	union nf_conntrack_nat_help help;
	int masq_index;
};

struct nf_ct_seqadj {
	u32 correction_pos;
	s32 offset_before;
	s32 offset_after;
};

struct nf_conn_seqadj {
	struct nf_ct_seqadj seq[2];
};

struct nf_conn_synproxy {
	u32 isn;
	u32 its;
	u32 tsoff;
};

struct nf_ct_timeout;

struct nf_conn_timeout {
	struct nf_ct_timeout *timeout;
};

struct nf_conn_tstamp {
	u_int64_t start;
	u_int64_t stop;
};

struct nf_conntrack_tuple_mask {
	struct {
		union nf_inet_addr u3;
		union nf_conntrack_man_proto u;
	} src;
};

struct nf_conntrack_expect {
	struct hlist_node lnode;
	struct hlist_node hnode;
	struct nf_conntrack_tuple tuple;
	struct nf_conntrack_tuple_mask mask;
	refcount_t use;
	unsigned int flags;
	unsigned int class;
	void (*expectfn)(struct nf_conn *, struct nf_conntrack_expect *);
	struct nf_conntrack_helper *helper;
	struct nf_conn *master;
	struct timer_list timeout;
	union nf_inet_addr saved_addr;
	union nf_conntrack_man_proto saved_proto;
	enum ip_conntrack_dir dir;
	struct callback_head rcu;
};

struct nf_conntrack_expect_policy {
	unsigned int max_expected;
	unsigned int timeout;
	char name[16];
};

struct nf_conntrack_helper {
	struct hlist_node hnode;
	char name[16];
	refcount_t refcnt;
	struct module *me;
	const struct nf_conntrack_expect_policy *expect_policy;
	struct nf_conntrack_tuple tuple;
	int (*help)(struct sk_buff *, unsigned int, struct nf_conn *, enum ip_conntrack_info);
	void (*destroy)(struct nf_conn *);
	int (*from_nlattr)(struct nlattr *, struct nf_conn *);
	int (*to_nlattr)(struct sk_buff *, const struct nf_conn *);
	unsigned int expect_class_max;
	unsigned int flags;
	unsigned int queue_num;
	u16 data_len;
	char nat_mod_name[16];
};

struct nf_conntrack_l4proto {
	u_int8_t l4proto;
	bool allow_clash;
	u16 nlattr_size;
	bool (*can_early_drop)(const struct nf_conn *);
	int (*to_nlattr)(struct sk_buff *, struct nlattr *, struct nf_conn *, bool);
	int (*from_nlattr)(struct nlattr **, struct nf_conn *);
	int (*tuple_to_nlattr)(struct sk_buff *, const struct nf_conntrack_tuple *);
	unsigned int (*nlattr_tuple_size)(void);
	int (*nlattr_to_tuple)(struct nlattr **, struct nf_conntrack_tuple *, u_int32_t);
	const struct nla_policy *nla_policy;
	struct {
		int (*nlattr_to_obj)(struct nlattr **, struct net *, void *);
		int (*obj_to_nlattr)(struct sk_buff *, const void *);
		u16 obj_size;
		u16 nlattr_max;
		const struct nla_policy *nla_policy;
	} ctnl_timeout;
};

struct nf_conntrack_nat_helper {
	struct list_head list;
	char mod_name[16];
	struct module *module;
};

struct nf_conntrack_net {
	atomic_t count;
	unsigned int expect_count;
	unsigned int users4;
	unsigned int users6;
	unsigned int users_bridge;
	struct ctl_table_header *sysctl_header;
};

struct nf_ct_bridge_info {
	struct nf_hook_ops *ops;
	unsigned int ops_size;
	struct module *me;
};

struct nf_ct_ext {
	u8 offset[4];
	u8 len;
	unsigned int gen_id;
	long: 0;
	char data[0];
};

struct nf_ct_ftp_master {
	u_int32_t seq_aft_nl[4];
	u_int16_t seq_aft_nl_num[2];
	u_int16_t flags[2];
};

struct nf_ct_helper_expectfn {
	struct list_head head;
	const char *name;
	void (*expectfn)(struct nf_conn *, struct nf_conntrack_expect *);
};

struct nf_ct_hook {
	int (*update)(struct net *, struct sk_buff *);
	void (*destroy)(struct nf_conntrack *);
	bool (*get_tuple_skb)(struct nf_conntrack_tuple *, const struct sk_buff *);
	void (*attach)(struct sk_buff *, const struct sk_buff *);
	void (*set_closing)(struct nf_conntrack *);
	int (*confirm)(struct sk_buff *);
};

struct nf_ct_iter_data {
	struct net *net;
	void *data;
	u32 portid;
	int report;
};

struct nf_ct_sip_master {
	unsigned int register_cseq;
	unsigned int invite_cseq;
	__be16 forced_dport;
};

struct nf_ct_tcp_flags {
	__u8 flags;
	__u8 mask;
};

struct nf_ct_timeout {
	__u16 l3num;
	const struct nf_conntrack_l4proto *l4proto;
	char data[0];
};

struct nf_defrag_hook {
	struct module *owner;
	int (*enable)(struct net *);
	void (*disable)(struct net *);
};

struct nf_hook_entry {
	nf_hookfn *hook;
	void *priv;
};

struct nf_hook_entries {
	u16 num_hook_entries;
	struct nf_hook_entry hooks[0];
};

struct nf_hook_entries_rcu_head {
	struct callback_head head;
	void *allocation;
};

struct nf_hook_state {
	u8 hook;
	u8 pf;
	struct net_device *in;
	struct net_device *out;
	struct sock *sk;
	struct net *net;
	int (*okfn)(struct net *, struct sock *, struct sk_buff *);
};

struct nf_queue_entry;

struct nf_ipv6_ops {
	void (*route_input)(struct sk_buff *);
	int (*fragment)(struct net *, struct sock *, struct sk_buff *, int (*)(struct net *, struct sock *, struct sk_buff *));
	int (*reroute)(struct sk_buff *, const struct nf_queue_entry *);
};

struct nf_log_buf {
	unsigned int count;
	char buf[1020];
};

struct nf_loginfo;

typedef void nf_logfn(struct net *, u_int8_t, unsigned int, const struct sk_buff *, const struct net_device *, const struct net_device *, const struct nf_loginfo *, const char *);

struct nf_logger {
	char *name;
	enum nf_log_type type;
	nf_logfn *logfn;
	struct module *me;
};

struct nf_loginfo {
	u_int8_t type;
	union {
		struct {
			u_int32_t copy_len;
			u_int16_t group;
			u_int16_t qthreshold;
			u_int16_t flags;
		} ulog;
		struct {
			u_int8_t level;
			u_int8_t logflags;
		} log;
	} u;
};

struct nf_mttg_trav {
	struct list_head *head;
	struct list_head *curr;
	uint8_t class;
};

struct nf_nat_hook {
	int (*parse_nat_setup)(struct nf_conn *, enum nf_nat_manip_type, const struct nlattr *);
	void (*decode_session)(struct sk_buff *, struct flowi *);
	void (*remove_nat_bysrc)(struct nf_conn *);
};

struct nf_nat_lookup_hook_priv {
	struct nf_hook_entries *entries;
	struct callback_head callback_head;
};

struct nf_nat_proto_clean {
	u8 l3proto;
	u8 l4proto;
};

struct nf_nat_range2 {
	unsigned int flags;
	union nf_inet_addr min_addr;
	union nf_inet_addr max_addr;
	union nf_conntrack_man_proto min_proto;
	union nf_conntrack_man_proto max_proto;
	union nf_conntrack_man_proto base_proto;
};

struct nf_nat_sip_hooks {
	unsigned int (*msg)(struct sk_buff *, unsigned int, unsigned int, const char **, unsigned int *);
	void (*seq_adjust)(struct sk_buff *, unsigned int, s16);
	unsigned int (*expect)(struct sk_buff *, unsigned int, unsigned int, const char **, unsigned int *, struct nf_conntrack_expect *, unsigned int, unsigned int);
	unsigned int (*sdp_addr)(struct sk_buff *, unsigned int, unsigned int, const char **, unsigned int *, unsigned int, enum sdp_header_types, enum sdp_header_types, const union nf_inet_addr *);
	unsigned int (*sdp_port)(struct sk_buff *, unsigned int, unsigned int, const char **, unsigned int *, unsigned int, unsigned int, u_int16_t);
	unsigned int (*sdp_session)(struct sk_buff *, unsigned int, unsigned int, const char **, unsigned int *, unsigned int, const union nf_inet_addr *);
	unsigned int (*sdp_media)(struct sk_buff *, unsigned int, unsigned int, const char **, unsigned int *, struct nf_conntrack_expect *, struct nf_conntrack_expect *, unsigned int, unsigned int, union nf_inet_addr *);
};

struct nf_queue_entry {
	struct list_head list;
	struct sk_buff *skb;
	unsigned int id;
	unsigned int hook_index;
	struct nf_hook_state state;
	u16 size;
};

struct nf_queue_handler {
	int (*outfn)(struct nf_queue_entry *, unsigned int);
	void (*nf_hook_drop)(struct net *);
};

struct nf_sockopt_ops {
	struct list_head list;
	u_int8_t pf;
	int set_optmin;
	int set_optmax;
	int (*set)(struct sock *, int, sockptr_t, unsigned int);
	int get_optmin;
	int get_optmax;
	int (*get)(struct sock *, int, void *, int *);
	struct module *owner;
};

struct nfgenmsg {
	__u8 nfgen_family;
	__u8 version;
	__be16 res_id;
};

struct nfnl_callback;

struct nfnetlink_subsystem {
	const char *name;
	__u8 subsys_id;
	__u8 cb_count;
	const struct nfnl_callback *cb;
	struct module *owner;
	int (*commit)(struct net *, struct sk_buff *);
	int (*abort)(struct net *, struct sk_buff *, enum nfnl_abort_action);
	bool (*valid_genid)(struct net *, u32);
};

struct nfnl_info;

struct nfnl_callback {
	int (*call)(struct sk_buff *, const struct nfnl_info *, const struct nlattr * const *);
	const struct nla_policy *policy;
	enum nfnl_callback_type type;
	__u16 attr_count;
};

struct nfnl_ct_hook {
	size_t (*build_size)(const struct nf_conn *);
	int (*build)(struct sk_buff *, struct nf_conn *, enum ip_conntrack_info, u_int16_t, u_int16_t);
	int (*parse)(const struct nlattr *, struct nf_conn *);
	int (*attach_expect)(const struct nlattr *, struct nf_conn *, u32, u32);
	void (*seq_adjust)(struct sk_buff *, struct nf_conn *, enum ip_conntrack_info, s32);
};

struct nfnl_err {
	struct list_head head;
	struct nlmsghdr *nlh;
	int err;
	struct netlink_ext_ack extack;
};

struct nfnl_info {
	struct net *net;
	struct sock *sk;
	const struct nlmsghdr *nlh;
	const struct nfgenmsg *nfmsg;
	struct netlink_ext_ack *extack;
};

struct nfnl_log_net {
	spinlock_t instances_lock;
	struct hlist_head instance_table[16];
	atomic_t global_seq;
};

struct nfnl_net {
	struct sock *nfnl;
};

struct nfs2_fh {
	char data[32];
};

struct nfs3_accessargs {
	struct nfs_fh *fh;
	__u32 access;
};

struct nfs_fattr;

struct nfs3_accessres {
	struct nfs_fattr *fattr;
	__u32 access;
};

struct nfs3_createargs {
	struct nfs_fh *fh;
	const char *name;
	unsigned int len;
	struct iattr *sattr;
	enum nfs3_createmode createmode;
	__be32 verifier[2];
};

struct rpc_procinfo;

struct rpc_message {
	const struct rpc_procinfo *rpc_proc;
	void *rpc_argp;
	void *rpc_resp;
	const struct cred *rpc_cred;
};

struct nfs3_mkdirargs {
	struct nfs_fh *fh;
	const char *name;
	unsigned int len;
	struct iattr *sattr;
};

struct nfs3_symlinkargs {
	struct nfs_fh *fromfh;
	const char *fromname;
	unsigned int fromlen;
	struct page **pages;
	unsigned int pathlen;
	struct iattr *sattr;
};

struct nfs3_mknodargs {
	struct nfs_fh *fh;
	const char *name;
	unsigned int len;
	enum nfs3_ftype type;
	struct iattr *sattr;
	dev_t rdev;
};

struct nfs3_diropres {
	struct nfs_fattr *dir_attr;
	struct nfs_fh *fh;
	struct nfs_fattr *fattr;
};

struct nfs_fsid {
	uint64_t major;
	uint64_t minor;
};

struct nfs4_string;

struct nfs4_threshold;

struct nfs4_label;

struct nfs_fattr {
	unsigned int valid;
	umode_t mode;
	__u32 nlink;
	kuid_t uid;
	kgid_t gid;
	dev_t rdev;
	__u64 size;
	union {
		struct {
			__u32 blocksize;
			__u32 blocks;
		} nfs2;
		struct {
			__u64 used;
		} nfs3;
	} du;
	struct nfs_fsid fsid;
	__u64 fileid;
	__u64 mounted_on_fileid;
	struct timespec64 atime;
	struct timespec64 mtime;
	struct timespec64 ctime;
	__u64 change_attr;
	__u64 pre_change_attr;
	__u64 pre_size;
	struct timespec64 pre_mtime;
	struct timespec64 pre_ctime;
	long unsigned int time_start;
	long unsigned int gencount;
	struct nfs4_string *owner_name;
	struct nfs4_string *group_name;
	struct nfs4_threshold *mdsthreshold;
	struct nfs4_label *label;
};

struct nfs3_createdata {
	struct rpc_message msg;
	union {
		struct nfs3_createargs create;
		struct nfs3_mkdirargs mkdir;
		struct nfs3_symlinkargs symlink;
		struct nfs3_mknodargs mknod;
	} arg;
	struct nfs3_diropres res;
	struct nfs_fh fh;
	struct nfs_fattr fattr;
	struct nfs_fattr dir_attr;
};

struct nfs3_diropargs {
	struct nfs_fh *fh;
	const char *name;
	unsigned int len;
};

struct nfs3_fh {
	short unsigned int size;
	unsigned char data[64];
};

struct nfs3_getaclargs {
	struct nfs_fh *fh;
	int mask;
	struct page **pages;
};

struct nfs3_getaclres {
	struct nfs_fattr *fattr;
	int mask;
	unsigned int acl_access_count;
	unsigned int acl_default_count;
	struct posix_acl *acl_access;
	struct posix_acl *acl_default;
};

struct nfs3_linkargs {
	struct nfs_fh *fromfh;
	struct nfs_fh *tofh;
	const char *toname;
	unsigned int tolen;
};

struct nfs3_linkres {
	struct nfs_fattr *dir_attr;
	struct nfs_fattr *fattr;
};

struct nfs3_readdirargs {
	struct nfs_fh *fh;
	__u64 cookie;
	__be32 verf[2];
	bool plus;
	unsigned int count;
	struct page **pages;
};

struct nfs3_readdirres {
	struct nfs_fattr *dir_attr;
	__be32 *verf;
	bool plus;
};

struct nfs3_readlinkargs {
	struct nfs_fh *fh;
	unsigned int pgbase;
	unsigned int pglen;
	struct page **pages;
};

struct nfs3_sattrargs {
	struct nfs_fh *fh;
	struct iattr *sattr;
	unsigned int guard;
	struct timespec64 guardtime;
};

struct nfs3_setaclargs {
	struct inode *inode;
	int mask;
	struct posix_acl *acl_access;
	struct posix_acl *acl_default;
	size_t len;
	unsigned int npages;
	struct page **pages;
};

struct nfs4_sequence_args {
	struct nfs4_slot *sa_slot;
	u8 sa_cache_this: 1;
	u8 sa_privileged: 1;
};

struct nfs4_accessargs {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fh;
	const u32 *bitmask;
	u32 access;
};

struct nfs4_sequence_res {
	struct nfs4_slot *sr_slot;
	long unsigned int sr_timestamp;
	int sr_status;
	u32 sr_status_flags;
	u32 sr_highest_slotid;
	u32 sr_target_highest_slotid;
};

struct nfs_server;

struct nfs4_accessres {
	struct nfs4_sequence_res seq_res;
	const struct nfs_server *server;
	struct nfs_fattr *fattr;
	u32 supported;
	u32 access;
};

struct nfs4_add_xprt_data {
	struct nfs_client *clp;
	const struct cred *cred;
};

struct nfs4_cached_acl {
	enum nfs4_acl_type type;
	int cached;
	size_t len;
	char data[0];
};

struct nfs4_call_sync_data {
	const struct nfs_server *seq_server;
	struct nfs4_sequence_args *seq_args;
	struct nfs4_sequence_res *seq_res;
};

struct nfs4_change_info {
	u32 atomic;
	u64 before;
	u64 after;
};

struct nfs4_channel_attrs {
	u32 max_rqst_sz;
	u32 max_resp_sz;
	u32 max_resp_sz_cached;
	u32 max_ops;
	u32 max_reqs;
};

struct nfs_seqid;

struct nfs4_layoutreturn_args;

struct nfs_closeargs {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *fh;
	nfs4_stateid stateid;
	struct nfs_seqid *seqid;
	fmode_t fmode;
	u32 share_access;
	const u32 *bitmask;
	u32 bitmask_store[3];
	struct nfs4_layoutreturn_args *lr_args;
};

struct nfs4_layoutreturn_res;

struct nfs_closeres {
	struct nfs4_sequence_res seq_res;
	nfs4_stateid stateid;
	struct nfs_fattr *fattr;
	struct nfs_seqid *seqid;
	const struct nfs_server *server;
	struct nfs4_layoutreturn_res *lr_res;
	int lr_ret;
};

struct pnfs_layout_hdr;

struct pnfs_layout_range {
	u32 iomode;
	u64 offset;
	u64 length;
};

struct nfs4_xdr_opaque_data;

struct nfs4_layoutreturn_args {
	struct nfs4_sequence_args seq_args;
	struct pnfs_layout_hdr *layout;
	struct inode *inode;
	struct pnfs_layout_range range;
	nfs4_stateid stateid;
	__u32 layout_type;
	struct nfs4_xdr_opaque_data *ld_private;
};

struct nfs4_layoutreturn_res {
	struct nfs4_sequence_res seq_res;
	u32 lrs_present;
	nfs4_stateid stateid;
};

struct nfs4_xdr_opaque_ops;

struct nfs4_xdr_opaque_data {
	const struct nfs4_xdr_opaque_ops *ops;
	void *data;
};

struct nfs4_state;

struct nfs4_closedata {
	struct inode *inode;
	struct nfs4_state *state;
	struct nfs_closeargs arg;
	struct nfs_closeres res;
	struct {
		struct nfs4_layoutreturn_args arg;
		struct nfs4_layoutreturn_res res;
		struct nfs4_xdr_opaque_data ld_private;
		u32 roc_barrier;
		bool roc;
	} lr;
	struct nfs_fattr fattr;
	long unsigned int timestamp;
};

struct nfs4_create_arg {
	struct nfs4_sequence_args seq_args;
	u32 ftype;
	union {
		struct {
			struct page **pages;
			unsigned int len;
		} symlink;
		struct {
			u32 specdata1;
			u32 specdata2;
		} device;
	} u;
	const struct qstr *name;
	const struct nfs_server *server;
	const struct iattr *attrs;
	const struct nfs_fh *dir_fh;
	const u32 *bitmask;
	const struct nfs4_label *label;
	umode_t umask;
};

struct nfs4_create_res {
	struct nfs4_sequence_res seq_res;
	const struct nfs_server *server;
	struct nfs_fh *fh;
	struct nfs_fattr *fattr;
	struct nfs4_change_info dir_cinfo;
};

struct nfs4_createdata {
	struct rpc_message msg;
	struct nfs4_create_arg arg;
	struct nfs4_create_res res;
	struct nfs_fh fh;
	struct nfs_fattr fattr;
};

struct nfs4_delegattr {
	struct timespec64 atime;
	struct timespec64 mtime;
	bool atime_set;
	bool mtime_set;
};

struct nfs4_delegreturnargs {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fhandle;
	const nfs4_stateid *stateid;
	const u32 *bitmask;
	u32 bitmask_store[3];
	struct nfs4_layoutreturn_args *lr_args;
	struct nfs4_delegattr *sattr_args;
};

struct nfs4_delegreturnres {
	struct nfs4_sequence_res seq_res;
	struct nfs_fattr *fattr;
	struct nfs_server *server;
	struct nfs4_layoutreturn_res *lr_res;
	int lr_ret;
	bool sattr_res;
	int sattr_ret;
};

struct nfs4_delegreturndata {
	struct nfs4_delegreturnargs args;
	struct nfs4_delegreturnres res;
	struct nfs_fh fh;
	nfs4_stateid stateid;
	long unsigned int timestamp;
	struct {
		struct nfs4_layoutreturn_args arg;
		struct nfs4_layoutreturn_res res;
		struct nfs4_xdr_opaque_data ld_private;
		u32 roc_barrier;
		bool roc;
	} lr;
	struct nfs4_delegattr sattr;
	struct nfs_fattr fattr;
	int rpc_status;
	struct inode *inode;
};

struct nfs4_exception {
	struct nfs4_state *state;
	struct inode *inode;
	nfs4_stateid *stateid;
	long int timeout;
	short unsigned int retrans;
	unsigned char task_is_privileged: 1;
	unsigned char delay: 1;
	unsigned char recovering: 1;
	unsigned char retry: 1;
	bool interruptible;
};

struct nfs4_string {
	unsigned int len;
	char *data;
};

struct nfs4_pathname {
	unsigned int ncomponents;
	struct nfs4_string components[512];
};

struct nfs4_fs_location {
	unsigned int nservers;
	struct nfs4_string servers[10];
	struct nfs4_pathname rootpath;
};

struct nfs4_fs_locations {
	struct nfs_fattr *fattr;
	const struct nfs_server *server;
	struct nfs4_pathname fs_path;
	int nlocations;
	struct nfs4_fs_location locations[10];
};

struct nfs4_fs_locations_arg {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *dir_fh;
	const struct nfs_fh *fh;
	const struct qstr *name;
	struct page *page;
	const u32 *bitmask;
	clientid4 clientid;
	unsigned char migration: 1;
	unsigned char renew: 1;
};

struct nfs4_fs_locations_res {
	struct nfs4_sequence_res seq_res;
	struct nfs4_fs_locations *fs_locations;
	unsigned char migration: 1;
	unsigned char renew: 1;
};

struct nfs4_fsid_present_arg {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fh;
	clientid4 clientid;
	unsigned char renew: 1;
};

struct nfs4_fsid_present_res {
	struct nfs4_sequence_res seq_res;
	struct nfs_fh *fh;
	unsigned char renew: 1;
};

struct nfs4_fsinfo_arg {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fh;
	const u32 *bitmask;
};

struct nfs_fsinfo;

struct nfs4_fsinfo_res {
	struct nfs4_sequence_res seq_res;
	struct nfs_fsinfo *fsinfo;
};

struct nfs4_get_lease_time_args {
	struct nfs4_sequence_args la_seq_args;
};

struct nfs4_get_lease_time_res;

struct nfs4_get_lease_time_data {
	struct nfs4_get_lease_time_args *args;
	struct nfs4_get_lease_time_res *res;
	struct nfs_client *clp;
};

struct nfs4_get_lease_time_res {
	struct nfs4_sequence_res lr_seq_res;
	struct nfs_fsinfo *lr_fsinfo;
};

struct nfs4_getattr_arg {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fh;
	const u32 *bitmask;
};

struct nfs4_getattr_res {
	struct nfs4_sequence_res seq_res;
	const struct nfs_server *server;
	struct nfs_fattr *fattr;
};

struct nfs4_label {
	uint32_t lfs;
	uint32_t pi;
	u32 lsmid;
	u32 len;
	char *label;
};

struct nfs4_layoutdriver_data {
	struct page **pages;
	__u32 pglen;
	__u32 len;
};

struct nfs_open_context;

struct nfs4_layoutget_args {
	struct nfs4_sequence_args seq_args;
	__u32 type;
	struct pnfs_layout_range range;
	__u64 minlength;
	__u32 maxcount;
	struct inode *inode;
	struct nfs_open_context *ctx;
	nfs4_stateid stateid;
	struct nfs4_layoutdriver_data layout;
};

struct nfs4_layoutget_res {
	struct nfs4_sequence_res seq_res;
	int status;
	__u32 return_on_close;
	struct pnfs_layout_range range;
	__u32 type;
	nfs4_stateid stateid;
	struct nfs4_layoutdriver_data *layoutp;
};

struct nfs4_layoutget {
	struct nfs4_layoutget_args args;
	struct nfs4_layoutget_res res;
	const struct cred *cred;
	struct pnfs_layout_hdr *lo;
	gfp_t gfp_flags;
};

struct nfs4_link_arg {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fh;
	const struct nfs_fh *dir_fh;
	const struct qstr *name;
	const u32 *bitmask;
};

struct nfs4_link_res {
	struct nfs4_sequence_res seq_res;
	const struct nfs_server *server;
	struct nfs_fattr *fattr;
	struct nfs4_change_info cinfo;
	struct nfs_fattr *dir_attr;
};

struct nfs_seqid_counter {
	ktime_t create_time;
	u64 owner_id;
	int flags;
	u32 counter;
	spinlock_t lock;
	struct list_head list;
	struct rpc_wait_queue wait;
};

struct nfs4_lock_state {
	struct list_head ls_locks;
	struct nfs4_state *ls_state;
	long unsigned int ls_flags;
	struct nfs_seqid_counter ls_seqid;
	nfs4_stateid ls_stateid;
	refcount_t ls_count;
	fl_owner_t ls_owner;
};

struct nfs_lowner {
	__u64 clientid;
	__u64 id;
	dev_t s_dev;
};

struct nfs_lock_args {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *fh;
	struct file_lock *fl;
	struct nfs_seqid *lock_seqid;
	nfs4_stateid lock_stateid;
	struct nfs_seqid *open_seqid;
	nfs4_stateid open_stateid;
	struct nfs_lowner lock_owner;
	unsigned char block: 1;
	unsigned char reclaim: 1;
	unsigned char new_lock: 1;
	unsigned char new_lock_owner: 1;
};

struct nfs_lock_res {
	struct nfs4_sequence_res seq_res;
	nfs4_stateid stateid;
	struct nfs_seqid *lock_seqid;
	struct nfs_seqid *open_seqid;
};

struct nfs4_lockdata {
	struct nfs_lock_args arg;
	struct nfs_lock_res res;
	struct nfs4_lock_state *lsp;
	struct nfs_open_context *ctx;
	struct file_lock fl;
	long unsigned int timestamp;
	int rpc_status;
	int cancelled;
	struct nfs_server *server;
};

struct nfs4_lookup_arg {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *dir_fh;
	const struct qstr *name;
	const u32 *bitmask;
};

struct nfs4_lookup_res {
	struct nfs4_sequence_res seq_res;
	const struct nfs_server *server;
	struct nfs_fattr *fattr;
	struct nfs_fh *fh;
};

struct nfs4_lookup_root_arg {
	struct nfs4_sequence_args seq_args;
	const u32 *bitmask;
};

struct nfs4_lookupp_arg {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fh;
	const u32 *bitmask;
};

struct nfs4_lookupp_res {
	struct nfs4_sequence_res seq_res;
	const struct nfs_server *server;
	struct nfs_fattr *fattr;
	struct nfs_fh *fh;
};

struct nfs4_mig_recovery_ops {
	int (*get_locations)(struct nfs_server *, struct nfs_fh *, struct nfs4_fs_locations *, struct page *, const struct cred *);
	int (*fsid_present)(struct inode *, const struct cred *);
};

struct rpc_xprt;

struct rpc_call_ops;

struct nfs4_state_recovery_ops;

struct nfs4_state_maintenance_ops;

struct nfs4_minor_version_ops {
	u32 minor_version;
	unsigned int init_caps;
	int (*init_client)(struct nfs_client *);
	void (*shutdown_client)(struct nfs_client *);
	bool (*match_stateid)(const nfs4_stateid *, const nfs4_stateid *);
	int (*find_root_sec)(struct nfs_server *, struct nfs_fh *, struct nfs_fsinfo *);
	void (*free_lock_state)(struct nfs_server *, struct nfs4_lock_state *);
	int (*test_and_free_expired)(struct nfs_server *, const nfs4_stateid *, const struct cred *);
	struct nfs_seqid * (*alloc_seqid)(struct nfs_seqid_counter *, gfp_t);
	void (*session_trunk)(struct rpc_clnt *, struct rpc_xprt *, void *);
	const struct rpc_call_ops *call_sync_ops;
	const struct nfs4_state_recovery_ops *reboot_recovery_ops;
	const struct nfs4_state_recovery_ops *nograce_recovery_ops;
	const struct nfs4_state_maintenance_ops *state_renewal_ops;
	const struct nfs4_mig_recovery_ops *mig_recovery_ops;
};

struct nfs_string {
	unsigned int len;
	const char *data;
};

struct nfs4_mount_data {
	int version;
	int flags;
	int rsize;
	int wsize;
	int timeo;
	int retrans;
	int acregmin;
	int acregmax;
	int acdirmin;
	int acdirmax;
	struct nfs_string client_addr;
	struct nfs_string mnt_path;
	struct nfs_string hostname;
	unsigned int host_addrlen;
	struct sockaddr *host_addr;
	int proto;
	int auth_flavourlen;
	int *auth_flavours;
};

struct nfs4_open_caps {
	u32 oa_share_access[1];
	u32 oa_share_deny[1];
	u32 oa_share_access_want[1];
	u32 oa_open_claim[1];
	u32 oa_createmode[1];
};

struct nfs4_open_createattrs {
	struct nfs4_label *label;
	struct iattr *sattr;
	const __u32 verf[2];
};

struct nfs4_open_delegation {
	__u32 open_delegation_type;
	union {
		struct {
			fmode_t type;
			__u32 do_recall;
			nfs4_stateid stateid;
			long unsigned int pagemod_limit;
		};
		struct {
			__u32 why_no_delegation;
			__u32 will_notify;
		};
	};
};

struct stateowner_id {
	__u64 create_time;
	__u64 uniquifier;
};

struct nfs_openargs {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fh;
	struct nfs_seqid *seqid;
	int open_flags;
	fmode_t fmode;
	u32 share_access;
	u32 access;
	__u64 clientid;
	struct stateowner_id id;
	union {
		struct {
			struct iattr *attrs;
			nfs4_verifier verifier;
		};
		nfs4_stateid delegation;
		__u32 delegation_type;
	} u;
	const struct qstr *name;
	const struct nfs_server *server;
	const u32 *bitmask;
	const u32 *open_bitmap;
	enum open_claim_type4 claim;
	enum createmode4 createmode;
	const struct nfs4_label *label;
	umode_t umask;
	struct nfs4_layoutget_args *lg_args;
};

struct nfs_openres {
	struct nfs4_sequence_res seq_res;
	nfs4_stateid stateid;
	struct nfs_fh fh;
	struct nfs4_change_info cinfo;
	__u32 rflags;
	struct nfs_fattr *f_attr;
	struct nfs_seqid *seqid;
	const struct nfs_server *server;
	__u32 attrset[3];
	struct nfs4_string *owner;
	struct nfs4_string *group_owner;
	struct nfs4_open_delegation delegation;
	__u32 access_request;
	__u32 access_supported;
	__u32 access_result;
	struct nfs4_layoutget_res *lg_res;
};

struct nfs_open_confirmargs {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fh;
	nfs4_stateid *stateid;
	struct nfs_seqid *seqid;
};

struct nfs_open_confirmres {
	struct nfs4_sequence_res seq_res;
	nfs4_stateid stateid;
	struct nfs_seqid *seqid;
};

struct nfs4_state_owner;

struct nfs4_opendata {
	struct kref kref;
	struct nfs_openargs o_arg;
	struct nfs_openres o_res;
	struct nfs_open_confirmargs c_arg;
	struct nfs_open_confirmres c_res;
	struct nfs4_string owner_name;
	struct nfs4_string group_name;
	struct nfs4_label *a_label;
	struct nfs_fattr f_attr;
	struct dentry *dir;
	struct dentry *dentry;
	struct nfs4_state_owner *owner;
	struct nfs4_state *state;
	struct iattr attrs;
	struct nfs4_layoutget *lgp;
	long unsigned int timestamp;
	bool rpc_done;
	bool file_created;
	bool is_recover;
	bool cancelled;
	int rpc_status;
};

struct nfs4_pathconf_arg {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fh;
	const u32 *bitmask;
};

struct nfs_pathconf;

struct nfs4_pathconf_res {
	struct nfs4_sequence_res seq_res;
	struct nfs_pathconf *pathconf;
};

struct nfs4_readdir_arg {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fh;
	u64 cookie;
	nfs4_verifier verifier;
	u32 count;
	struct page **pages;
	unsigned int pgbase;
	const u32 *bitmask;
	bool plus;
};

struct nfs4_readdir_res {
	struct nfs4_sequence_res seq_res;
	nfs4_verifier verifier;
	unsigned int pgbase;
};

struct nfs4_readlink {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fh;
	unsigned int pgbase;
	unsigned int pglen;
	struct page **pages;
};

struct nfs4_readlink_res {
	struct nfs4_sequence_res seq_res;
};

struct nfs4_renewdata {
	struct nfs_client *client;
	long unsigned int timestamp;
};

struct rpcsec_gss_info {
	struct rpcsec_gss_oid oid;
	u32 qop;
	u32 service;
};

struct nfs4_secinfo4 {
	u32 flavor;
	struct rpcsec_gss_info flavor_info;
};

struct nfs4_secinfo_arg {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *dir_fh;
	const struct qstr *name;
};

struct nfs4_secinfo_flavors {
	unsigned int num_flavors;
	struct nfs4_secinfo4 flavors[0];
};

struct nfs4_secinfo_res {
	struct nfs4_sequence_res seq_res;
	struct nfs4_secinfo_flavors *flavors;
};

struct nfs4_server_caps_arg {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *fhandle;
	const u32 *bitmask;
};

struct nfs4_server_caps_res {
	struct nfs4_sequence_res seq_res;
	u32 attr_bitmask[3];
	u32 exclcreat_bitmask[3];
	u32 acl_bitmask;
	u32 has_links;
	u32 has_symlinks;
	u32 fh_expire_type;
	u32 case_insensitive;
	u32 case_preserving;
	struct nfs4_open_caps open_caps;
};

struct nfs4_sessionid {
	unsigned char data[16];
};

struct nfs4_session;

struct nfs4_slot_table {
	struct nfs4_session *session;
	struct nfs4_slot *slots;
	long unsigned int used_slots[16];
	spinlock_t slot_tbl_lock;
	struct rpc_wait_queue slot_tbl_waitq;
	wait_queue_head_t slot_waitq;
	u32 max_slots;
	u32 max_slotid;
	u32 highest_used_slotid;
	u32 target_highest_slotid;
	u32 server_highest_slotid;
	s32 d_target_highest_slotid;
	s32 d2_target_highest_slotid;
	long unsigned int generation;
	struct completion complete;
	long unsigned int slot_tbl_state;
};

struct nfs4_session {
	struct nfs4_sessionid sess_id;
	u32 flags;
	long unsigned int session_state;
	u32 hash_alg;
	u32 ssv_len;
	struct nfs4_channel_attrs fc_attrs;
	struct nfs4_slot_table fc_slot_table;
	struct nfs4_channel_attrs bc_attrs;
	struct nfs4_slot_table bc_slot_table;
	struct nfs_client *clp;
};

struct nfs4_setclientid {
	const nfs4_verifier *sc_verifier;
	u32 sc_prog;
	unsigned int sc_netid_len;
	char sc_netid[6];
	unsigned int sc_uaddr_len;
	char sc_uaddr[58];
	struct nfs_client *sc_clnt;
	struct rpc_cred *sc_cred;
};

struct nfs4_setclientid_res {
	u64 clientid;
	nfs4_verifier confirm;
};

struct nfs4_slot {
	struct nfs4_slot_table *table;
	struct nfs4_slot *next;
	long unsigned int generation;
	u32 slot_nr;
	u32 seq_nr;
	u32 seq_nr_last_acked;
	u32 seq_nr_highest_sent;
	unsigned int privileged: 1;
	unsigned int seq_done: 1;
};

struct nfs4_state {
	struct list_head open_states;
	struct list_head inode_states;
	struct list_head lock_states;
	struct nfs4_state_owner *owner;
	struct inode *inode;
	long unsigned int flags;
	spinlock_t state_lock;
	seqlock_t seqlock;
	nfs4_stateid stateid;
	nfs4_stateid open_stateid;
	unsigned int n_rdonly;
	unsigned int n_wronly;
	unsigned int n_rdwr;
	fmode_t state;
	refcount_t count;
	wait_queue_head_t waitq;
	struct callback_head callback_head;
};

struct nfs4_state_maintenance_ops {
	int (*sched_state_renewal)(struct nfs_client *, const struct cred *, unsigned int);
	const struct cred * (*get_state_renewal_cred)(struct nfs_client *);
	int (*renew_lease)(struct nfs_client *, const struct cred *);
};

struct nfs4_state_owner {
	struct nfs_server *so_server;
	struct list_head so_lru;
	long unsigned int so_expires;
	struct rb_node so_server_node;
	const struct cred *so_cred;
	spinlock_t so_lock;
	atomic_t so_count;
	long unsigned int so_flags;
	struct list_head so_states;
	struct nfs_seqid_counter so_seqid;
	struct mutex so_delegreturn_mutex;
};

struct nfs4_state_recovery_ops {
	int owner_flag_bit;
	int state_flag_bit;
	int (*recover_open)(struct nfs4_state_owner *, struct nfs4_state *);
	int (*recover_lock)(struct nfs4_state *, struct file_lock *);
	int (*establish_clid)(struct nfs_client *, const struct cred *);
	int (*reclaim_complete)(struct nfs_client *, const struct cred *);
	int (*detect_trunking)(struct nfs_client *, struct nfs_client **, const struct cred *);
};

struct nfs4_statfs_arg {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fh;
	const u32 *bitmask;
};

struct nfs_fsstat;

struct nfs4_statfs_res {
	struct nfs4_sequence_res seq_res;
	struct nfs_fsstat *fsstat;
};

struct nfs4_threshold {
	__u32 bm;
	__u32 l_type;
	__u64 rd_sz;
	__u64 wr_sz;
	__u64 rd_io_sz;
	__u64 wr_io_sz;
};

struct nfs_locku_args {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *fh;
	struct file_lock *fl;
	struct nfs_seqid *seqid;
	nfs4_stateid stateid;
};

struct nfs_locku_res {
	struct nfs4_sequence_res seq_res;
	nfs4_stateid stateid;
	struct nfs_seqid *seqid;
};

struct nfs_lock_context;

struct nfs4_unlockdata {
	struct nfs_locku_args arg;
	struct nfs_locku_res res;
	struct nfs4_lock_state *lsp;
	struct nfs_open_context *ctx;
	struct nfs_lock_context *l_ctx;
	struct file_lock fl;
	struct nfs_server *server;
	long unsigned int timestamp;
};

struct nfs4_xdr_opaque_ops {
	void (*encode)(struct xdr_stream *, const void *, const struct nfs4_xdr_opaque_data *);
	void (*free)(struct nfs4_xdr_opaque_data *);
};

struct nfs_access_entry {
	struct rb_node rb_node;
	struct list_head lru;
	kuid_t fsuid;
	kgid_t fsgid;
	struct group_info *group_info;
	u64 timestamp;
	__u32 mask;
	struct callback_head callback_head;
};

struct nfs_auth_info {
	unsigned int flavor_len;
	rpc_authflavor_t flavors[12];
};

struct nfs_cache_array_entry {
	u64 cookie;
	u64 ino;
	const char *name;
	unsigned int name_len;
	unsigned char d_type;
};

struct nfs_cache_array {
	u64 change_attr;
	u64 last_cookie;
	unsigned int size;
	unsigned char folio_full: 1;
	unsigned char folio_is_eof: 1;
	unsigned char cookies_are_ordered: 1;
	struct nfs_cache_array_entry array[0];
};

struct svc_serv;

struct nfs_callback_data {
	unsigned int users;
	struct svc_serv *serv;
};

struct xprtsec_parms {
	enum xprtsec_policies policy;
	key_serial_t cert_serial;
	key_serial_t privkey_serial;
};

struct nfs41_server_owner;

struct nfs41_server_scope;

struct nfs41_impl_id;

struct nfs_rpc_ops;

struct nfs_subversion;

struct nfs_client {
	refcount_t cl_count;
	atomic_t cl_mds_count;
	int cl_cons_state;
	long unsigned int cl_res_state;
	long unsigned int cl_flags;
	struct __kernel_sockaddr_storage cl_addr;
	size_t cl_addrlen;
	char *cl_hostname;
	char *cl_acceptor;
	struct list_head cl_share_link;
	struct list_head cl_superblocks;
	struct rpc_clnt *cl_rpcclient;
	const struct nfs_rpc_ops *rpc_ops;
	int cl_proto;
	struct nfs_subversion *cl_nfs_mod;
	u32 cl_minorversion;
	unsigned int cl_nconnect;
	unsigned int cl_max_connect;
	const char *cl_principal;
	struct xprtsec_parms cl_xprtsec;
	struct list_head cl_ds_clients;
	u64 cl_clientid;
	nfs4_verifier cl_confirm;
	long unsigned int cl_state;
	spinlock_t cl_lock;
	long unsigned int cl_lease_time;
	long unsigned int cl_last_renewal;
	struct delayed_work cl_renewd;
	struct rpc_wait_queue cl_rpcwaitq;
	struct idmap *cl_idmap;
	const char *cl_owner_id;
	u32 cl_cb_ident;
	const struct nfs4_minor_version_ops *cl_mvops;
	long unsigned int cl_mig_gen;
	struct nfs4_slot_table *cl_slot_tbl;
	u32 cl_seqid;
	u32 cl_exchange_flags;
	struct nfs4_session *cl_session;
	bool cl_preserve_clid;
	struct nfs41_server_owner *cl_serverowner;
	struct nfs41_server_scope *cl_serverscope;
	struct nfs41_impl_id *cl_implid;
	long unsigned int cl_sp4_flags;
	char cl_ipaddr[48];
	struct net *cl_net;
	struct list_head pending_cb_stateids;
	struct callback_head rcu;
};

struct rpc_timeout;

struct nfs_client_initdata {
	long unsigned int init_flags;
	const char *hostname;
	const struct __kernel_sockaddr_storage *addr;
	const char *nodename;
	const char *ip_addr;
	size_t addrlen;
	struct nfs_subversion *nfs_mod;
	int proto;
	u32 minorversion;
	unsigned int nconnect;
	unsigned int max_connect;
	struct net *net;
	const struct rpc_timeout *timeparms;
	const struct cred *cred;
	struct xprtsec_parms xprtsec;
	long unsigned int connect_timeout;
	long unsigned int reconnect_timeout;
};

struct nfs_clone_mount {
	struct super_block *sb;
	struct dentry *dentry;
	struct nfs_fattr *fattr;
	unsigned int inherited_bsize;
};

struct nfs_commit_data;

struct nfs_commit_info;

struct nfs_page;

struct nfs_commit_completion_ops {
	void (*completion)(struct nfs_commit_data *);
	void (*resched_write)(struct nfs_commit_info *, struct nfs_page *);
};

struct rpc_wait {
	struct list_head list;
	struct list_head links;
	struct list_head timer_list;
};

struct rpc_rqst;

struct rpc_task {
	atomic_t tk_count;
	int tk_status;
	struct list_head tk_task;
	void (*tk_callback)(struct rpc_task *);
	void (*tk_action)(struct rpc_task *);
	long unsigned int tk_timeout;
	long unsigned int tk_runstate;
	struct rpc_wait_queue *tk_waitqueue;
	union {
		struct work_struct tk_work;
		struct rpc_wait tk_wait;
	} u;
	struct rpc_message tk_msg;
	void *tk_calldata;
	const struct rpc_call_ops *tk_ops;
	struct rpc_clnt *tk_client;
	struct rpc_xprt *tk_xprt;
	struct rpc_cred *tk_op_cred;
	struct rpc_rqst *tk_rqstp;
	struct workqueue_struct *tk_workqueue;
	ktime_t tk_start;
	pid_t tk_owner;
	int tk_rpc_status;
	short unsigned int tk_flags;
	short unsigned int tk_timeouts;
	short unsigned int tk_pid;
	unsigned char tk_priority: 2;
	unsigned char tk_garb_retry: 2;
	unsigned char tk_cred_retry: 2;
};

struct nfs_write_verifier {
	char data[8];
};

struct nfs_writeverf {
	struct nfs_write_verifier verifier;
	enum nfs3_stable_how committed;
};

struct nfs_commitargs {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *fh;
	__u64 offset;
	__u32 count;
	const u32 *bitmask;
};

struct nfs_commitres {
	struct nfs4_sequence_res seq_res;
	__u32 op_status;
	struct nfs_fattr *fattr;
	struct nfs_writeverf *verf;
	const struct nfs_server *server;
};

struct nfs_direct_req;

struct pnfs_layout_segment;

struct nfs_commit_data {
	struct rpc_task task;
	struct inode *inode;
	const struct cred *cred;
	struct nfs_fattr fattr;
	struct nfs_writeverf verf;
	struct list_head pages;
	struct list_head list;
	struct nfs_direct_req *dreq;
	struct nfs_commitargs args;
	struct nfs_commitres res;
	struct nfs_open_context *context;
	struct pnfs_layout_segment *lseg;
	struct nfs_client *ds_clp;
	int ds_commit_index;
	loff_t lwb;
	const struct rpc_call_ops *mds_ops;
	const struct nfs_commit_completion_ops *completion_ops;
	int (*commit_done_cb)(struct rpc_task *, struct nfs_commit_data *);
	long unsigned int flags;
};

struct nfs_mds_commit_info;

struct pnfs_ds_commit_info;

struct nfs_commit_info {
	struct inode *inode;
	struct nfs_mds_commit_info *mds;
	struct pnfs_ds_commit_info *ds;
	struct nfs_direct_req *dreq;
	const struct nfs_commit_completion_ops *completion_ops;
};

struct nfs_delegation {
	struct list_head super_list;
	const struct cred *cred;
	struct inode *inode;
	nfs4_stateid stateid;
	fmode_t type;
	long unsigned int pagemod_limit;
	__u64 change_attr;
	long unsigned int test_gen;
	long unsigned int flags;
	refcount_t refcount;
	spinlock_t lock;
	struct callback_head rcu;
};

struct nfs_mds_commit_info {
	atomic_t rpcs_out;
	atomic_long_t ncommit;
	struct list_head list;
};

struct pnfs_ds_commit_info {};

struct nfs_direct_req {
	struct kref kref;
	struct nfs_open_context *ctx;
	struct nfs_lock_context *l_ctx;
	struct kiocb *iocb;
	struct inode *inode;
	atomic_t io_count;
	spinlock_t lock;
	loff_t io_start;
	ssize_t count;
	ssize_t max_count;
	ssize_t error;
	struct completion completion;
	struct nfs_mds_commit_info mds_cinfo;
	struct pnfs_ds_commit_info ds_cinfo;
	struct work_struct work;
	int flags;
};

struct nfs_entry {
	__u64 ino;
	__u64 cookie;
	const char *name;
	unsigned int len;
	int eof;
	struct nfs_fh *fh;
	struct nfs_fattr *fattr;
	unsigned char d_type;
	struct nfs_server *server;
};

struct nfsd_file;

struct nfs_file_localio {
	struct nfsd_file *ro_file;
	struct nfsd_file *rw_file;
	struct list_head list;
	void *nfs_uuid;
};

struct nfs_find_desc {
	struct nfs_fh *fh;
	struct nfs_fattr *fattr;
};

struct nfs_fs_context {
	bool internal;
	bool skip_reconfig_option_check;
	bool need_mount;
	bool sloppy;
	unsigned int flags;
	unsigned int rsize;
	unsigned int wsize;
	unsigned int timeo;
	unsigned int retrans;
	unsigned int acregmin;
	unsigned int acregmax;
	unsigned int acdirmin;
	unsigned int acdirmax;
	unsigned int namlen;
	unsigned int options;
	unsigned int bsize;
	struct nfs_auth_info auth_info;
	rpc_authflavor_t selected_flavor;
	struct xprtsec_parms xprtsec;
	char *client_address;
	unsigned int version;
	unsigned int minorversion;
	char *fscache_uniq;
	short unsigned int protofamily;
	short unsigned int mountfamily;
	bool has_sec_mnt_opts;
	int lock_status;
	struct {
		union {
			struct sockaddr address;
			struct __kernel_sockaddr_storage _address;
		};
		size_t addrlen;
		char *hostname;
		u32 version;
		int port;
		short unsigned int protocol;
	} mount_server;
	struct {
		union {
			struct sockaddr address;
			struct __kernel_sockaddr_storage _address;
		};
		size_t addrlen;
		char *hostname;
		char *export_path;
		int port;
		short unsigned int protocol;
		short unsigned int nconnect;
		short unsigned int max_connect;
		short unsigned int export_path_len;
	} nfs_server;
	struct nfs_fh *mntfh;
	struct nfs_server *server;
	struct nfs_subversion *nfs_mod;
	struct nfs_clone_mount clone_data;
};

struct nfs_fsinfo {
	struct nfs_fattr *fattr;
	__u32 rtmax;
	__u32 rtpref;
	__u32 rtmult;
	__u32 wtmax;
	__u32 wtpref;
	__u32 wtmult;
	__u32 dtpref;
	__u64 maxfilesize;
	struct timespec64 time_delta;
	__u32 lease_time;
	__u32 nlayouttypes;
	__u32 layouttype[8];
	__u32 blksize;
	__u32 clone_blksize;
	enum nfs4_change_attr_type change_attr_type;
	__u32 xattr_support;
};

struct nfs_fsstat {
	struct nfs_fattr *fattr;
	__u64 tbytes;
	__u64 fbytes;
	__u64 abytes;
	__u64 tfiles;
	__u64 ffiles;
	__u64 afiles;
};

struct nfs_getaclargs {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *fh;
	enum nfs4_acl_type acl_type;
	size_t acl_len;
	struct page **acl_pages;
};

struct nfs_getaclres {
	struct nfs4_sequence_res seq_res;
	enum nfs4_acl_type acl_type;
	size_t acl_len;
	size_t acl_data_offset;
	int acl_flags;
	struct page *acl_scratch;
};

struct nfs_inode {
	__u64 fileid;
	struct nfs_fh fh;
	long unsigned int flags;
	long unsigned int cache_validity;
	long unsigned int read_cache_jiffies;
	long unsigned int attrtimeo;
	long unsigned int attrtimeo_timestamp;
	long unsigned int attr_gencount;
	struct rb_root access_cache;
	struct list_head access_cache_entry_lru;
	struct list_head access_cache_inode_lru;
	union {
		struct {
			long unsigned int cache_change_attribute;
			__be32 cookieverf[2];
			struct rw_semaphore rmdir_sem;
		};
		struct {
			atomic_long_t nrequests;
			atomic_long_t redirtied_pages;
			struct nfs_mds_commit_info commit_info;
			struct mutex commit_mutex;
		};
	};
	struct list_head open_files;
	struct {
		int cnt;
		struct {
			u64 start;
			u64 end;
		} gap[16];
	} *ooo;
	struct nfs4_cached_acl *nfs4_acl;
	struct list_head open_states;
	struct nfs_delegation *delegation;
	struct rw_semaphore rwsem;
	struct pnfs_layout_hdr *layout;
	__u64 write_io;
	__u64 read_io;
	union {
		struct inode vfs_inode;
	};
};

struct nfs_io_completion {
	void (*complete)(void *);
	void *data;
	struct kref refcount;
};

struct nfs_iostats {
	long long unsigned int bytes[8];
	long unsigned int events[27];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct nfs_lock_context {
	refcount_t count;
	struct list_head list;
	struct nfs_open_context *open_context;
	fl_owner_t lockowner;
	atomic_t io_count;
	struct callback_head callback_head;
};

struct nfs_lockt_args {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *fh;
	struct file_lock *fl;
	struct nfs_lowner lock_owner;
};

struct nfs_lockt_res {
	struct nfs4_sequence_res seq_res;
	struct file_lock *denied;
};

struct sockaddr_in {
	__kernel_sa_family_t sin_family;
	__be16 sin_port;
	struct in_addr sin_addr;
	unsigned char __pad[8];
};

struct nfs_mount_data {
	int version;
	int fd;
	struct nfs2_fh old_root;
	int flags;
	int rsize;
	int wsize;
	int timeo;
	int retrans;
	int acregmin;
	int acregmax;
	int acdirmin;
	int acdirmax;
	struct sockaddr_in addr;
	char hostname[256];
	int namlen;
	unsigned int bsize;
	struct nfs3_fh root;
	int pseudoflavor;
	char context[257];
};

struct nfs_mount_request {
	struct __kernel_sockaddr_storage *sap;
	size_t salen;
	char *hostname;
	char *dirpath;
	u32 version;
	short unsigned int protocol;
	struct nfs_fh *fh;
	int noresvport;
	unsigned int *auth_flav_len;
	rpc_authflavor_t *auth_flavs;
	struct net *net;
};

struct rpc_program;

struct rpc_stat {
	const struct rpc_program *program;
	unsigned int netcnt;
	unsigned int netudpcnt;
	unsigned int nettcpcnt;
	unsigned int nettcpconn;
	unsigned int netreconn;
	unsigned int rpccnt;
	unsigned int rpcretrans;
	unsigned int rpcauthrefresh;
	unsigned int rpcgarbage;
};

struct nfs_netns_client;

struct nfs_net {
	struct cache_detail *nfs_dns_resolve;
	struct rpc_pipe *bl_device_pipe;
	struct bl_dev_msg bl_mount_reply;
	wait_queue_head_t bl_wq;
	struct mutex bl_mutex;
	struct list_head nfs_client_list;
	struct list_head nfs_volume_list;
	struct idr cb_ident_idr;
	short unsigned int nfs_callback_tcpport;
	short unsigned int nfs_callback_tcpport6;
	int cb_users[1];
	struct nfs_netns_client *nfs_client;
	spinlock_t nfs_client_lock;
	ktime_t boot_time;
	struct rpc_stat rpcstats;
	struct proc_dir_entry *proc_nfsfs;
};

struct nfs_netns_client {
	struct kobject kobject;
	struct kobject nfs_net_kobj;
	struct net *net;
	const char *identifier;
};

struct nfs_open_context {
	struct nfs_lock_context lock_context;
	fl_owner_t flock_owner;
	struct dentry *dentry;
	const struct cred *cred;
	struct rpc_cred *ll_cred;
	struct nfs4_state *state;
	fmode_t mode;
	int error;
	long unsigned int flags;
	struct nfs4_threshold *mdsthreshold;
	struct list_head list;
	struct callback_head callback_head;
	struct nfs_file_localio nfl;
};

struct nfs_open_dir_context {
	struct list_head list;
	atomic_t cache_hits;
	atomic_t cache_misses;
	long unsigned int attr_gencount;
	__be32 verf[2];
	__u64 dir_cookie;
	__u64 last_cookie;
	long unsigned int page_index;
	unsigned int dtsize;
	bool force_clear;
	bool eof;
	struct callback_head callback_head;
};

struct nfs_page {
	struct list_head wb_list;
	union {
		struct page *wb_page;
		struct folio *wb_folio;
	};
	struct nfs_lock_context *wb_lock_context;
	long unsigned int wb_index;
	unsigned int wb_offset;
	unsigned int wb_pgbase;
	unsigned int wb_bytes;
	struct kref wb_kref;
	long unsigned int wb_flags;
	struct nfs_write_verifier wb_verf;
	struct nfs_page *wb_this_page;
	struct nfs_page *wb_head;
	short unsigned int wb_nio;
};

struct nfs_page_array {
	struct page **pagevec;
	unsigned int npages;
	struct page *page_array[8];
};

struct nfs_page_iter_page {
	const struct nfs_page *req;
	size_t count;
};

struct nfs_pgio_mirror {
	struct list_head pg_list;
	long unsigned int pg_bytes_written;
	size_t pg_count;
	size_t pg_bsize;
	unsigned int pg_base;
	unsigned char pg_recoalesce: 1;
};

struct nfs_pageio_ops;

struct nfs_rw_ops;

struct nfs_pgio_completion_ops;

struct nfs_pageio_descriptor {
	struct inode *pg_inode;
	const struct nfs_pageio_ops *pg_ops;
	const struct nfs_rw_ops *pg_rw_ops;
	int pg_ioflags;
	int pg_error;
	const struct rpc_call_ops *pg_rpc_callops;
	const struct nfs_pgio_completion_ops *pg_completion_ops;
	struct pnfs_layout_segment *pg_lseg;
	struct nfs_io_completion *pg_io_completion;
	struct nfs_direct_req *pg_dreq;
	unsigned int pg_bsize;
	u32 pg_mirror_count;
	struct nfs_pgio_mirror *pg_mirrors;
	struct nfs_pgio_mirror pg_mirrors_static[1];
	struct nfs_pgio_mirror *pg_mirrors_dynamic;
	u32 pg_mirror_idx;
	short unsigned int pg_maxretrans;
	unsigned char pg_moreio: 1;
};

struct nfs_pageio_ops {
	void (*pg_init)(struct nfs_pageio_descriptor *, struct nfs_page *);
	size_t (*pg_test)(struct nfs_pageio_descriptor *, struct nfs_page *, struct nfs_page *);
	int (*pg_doio)(struct nfs_pageio_descriptor *);
	unsigned int (*pg_get_mirror_count)(struct nfs_pageio_descriptor *, struct nfs_page *);
	void (*pg_cleanup)(struct nfs_pageio_descriptor *);
	struct nfs_pgio_mirror * (*pg_get_mirror)(struct nfs_pageio_descriptor *, u32);
	u32 (*pg_set_mirror)(struct nfs_pageio_descriptor *, u32);
};

struct nfs_pathconf {
	struct nfs_fattr *fattr;
	__u32 max_link;
	__u32 max_namelen;
};

struct nfs_pgio_args {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *fh;
	struct nfs_open_context *context;
	struct nfs_lock_context *lock_context;
	nfs4_stateid stateid;
	__u64 offset;
	__u32 count;
	unsigned int pgbase;
	struct page **pages;
	union {
		unsigned int replen;
		struct {
			const u32 *bitmask;
			u32 bitmask_store[3];
			enum nfs3_stable_how stable;
		};
	};
};

struct nfs_pgio_header;

struct nfs_pgio_completion_ops {
	void (*error_cleanup)(struct list_head *, int);
	void (*init_hdr)(struct nfs_pgio_header *);
	void (*completion)(struct nfs_pgio_header *);
	void (*reschedule_io)(struct nfs_pgio_header *);
};

struct nfs_pgio_res {
	struct nfs4_sequence_res seq_res;
	struct nfs_fattr *fattr;
	__u64 count;
	__u32 op_status;
	union {
		struct {
			unsigned int replen;
			int eof;
			void *scratch;
		};
		struct {
			struct nfs_writeverf *verf;
			const struct nfs_server *server;
		};
	};
};

struct nfs_pgio_header {
	struct inode *inode;
	const struct cred *cred;
	struct list_head pages;
	struct nfs_page *req;
	struct nfs_writeverf verf;
	fmode_t rw_mode;
	struct pnfs_layout_segment *lseg;
	loff_t io_start;
	const struct rpc_call_ops *mds_ops;
	void (*release)(struct nfs_pgio_header *);
	const struct nfs_pgio_completion_ops *completion_ops;
	const struct nfs_rw_ops *rw_ops;
	struct nfs_io_completion *io_completion;
	struct nfs_direct_req *dreq;
	int pnfs_error;
	int error;
	unsigned int good_bytes;
	long unsigned int flags;
	struct rpc_task task;
	struct nfs_fattr fattr;
	struct nfs_pgio_args args;
	struct nfs_pgio_res res;
	long unsigned int timestamp;
	int (*pgio_done_cb)(struct rpc_task *, struct nfs_pgio_header *);
	__u64 mds_offset;
	struct nfs_page_array page_array;
	struct nfs_client *ds_clp;
	u32 ds_commit_idx;
	u32 pgio_mirror_idx;
};

struct nfs_readdir_arg {
	struct dentry *dentry;
	const struct cred *cred;
	__be32 *verf;
	u64 cookie;
	struct page **pages;
	unsigned int page_len;
	bool plus;
};

struct nfs_readdir_descriptor {
	struct file *file;
	struct folio *folio;
	struct dir_context *ctx;
	long unsigned int folio_index;
	long unsigned int folio_index_max;
	u64 dir_cookie;
	u64 last_cookie;
	loff_t current_index;
	__be32 verf[2];
	long unsigned int dir_verifier;
	long unsigned int timestamp;
	long unsigned int gencount;
	long unsigned int attr_gencount;
	unsigned int cache_entry_index;
	unsigned int buffer_fills;
	unsigned int dtsize;
	bool clear_cache;
	bool plus;
	bool eob;
	bool eof;
};

struct nfs_readdir_res {
	__be32 *verf;
};

struct nfs_referral_count {
	struct list_head list;
	const struct task_struct *task;
	unsigned int referral_count;
};

struct nfs_release_lockowner_args {
	struct nfs4_sequence_args seq_args;
	struct nfs_lowner lock_owner;
};

struct nfs_release_lockowner_res {
	struct nfs4_sequence_res seq_res;
};

struct nfs_release_lockowner_data {
	struct nfs4_lock_state *lsp;
	struct nfs_server *server;
	struct nfs_release_lockowner_args args;
	struct nfs_release_lockowner_res res;
	long unsigned int timestamp;
};

struct nfs_removeargs {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fh;
	struct qstr name;
};

struct nfs_removeres {
	struct nfs4_sequence_res seq_res;
	struct nfs_server *server;
	struct nfs_fattr *dir_attr;
	struct nfs4_change_info cinfo;
};

struct nfs_renameargs {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *old_dir;
	const struct nfs_fh *new_dir;
	const struct qstr *old_name;
	const struct qstr *new_name;
};

struct nfs_renameres {
	struct nfs4_sequence_res seq_res;
	struct nfs_server *server;
	struct nfs4_change_info old_cinfo;
	struct nfs_fattr *old_fattr;
	struct nfs4_change_info new_cinfo;
	struct nfs_fattr *new_fattr;
};

struct nfs_renamedata {
	struct nfs_renameargs args;
	struct nfs_renameres res;
	struct rpc_task task;
	const struct cred *cred;
	struct inode *old_dir;
	struct dentry *old_dentry;
	struct nfs_fattr old_fattr;
	struct inode *new_dir;
	struct dentry *new_dentry;
	struct nfs_fattr new_fattr;
	void (*complete)(struct rpc_task *, struct nfs_renamedata *);
	long int timeout;
	bool cancelled;
};

struct nlmclnt_operations;

struct nfs_unlinkdata;

struct nfs_rpc_ops {
	u32 version;
	const struct dentry_operations *dentry_ops;
	const struct inode_operations *dir_inode_ops;
	const struct inode_operations *file_inode_ops;
	const struct file_operations *file_ops;
	const struct nlmclnt_operations *nlmclnt_ops;
	int (*getroot)(struct nfs_server *, struct nfs_fh *, struct nfs_fsinfo *);
	int (*submount)(struct fs_context *, struct nfs_server *);
	int (*try_get_tree)(struct fs_context *);
	int (*getattr)(struct nfs_server *, struct nfs_fh *, struct nfs_fattr *, struct inode *);
	int (*setattr)(struct dentry *, struct nfs_fattr *, struct iattr *);
	int (*lookup)(struct inode *, struct dentry *, const struct qstr *, struct nfs_fh *, struct nfs_fattr *);
	int (*lookupp)(struct inode *, struct nfs_fh *, struct nfs_fattr *);
	int (*access)(struct inode *, struct nfs_access_entry *, const struct cred *);
	int (*readlink)(struct inode *, struct page *, unsigned int, unsigned int);
	int (*create)(struct inode *, struct dentry *, struct iattr *, int);
	int (*remove)(struct inode *, struct dentry *);
	void (*unlink_setup)(struct rpc_message *, struct dentry *, struct inode *);
	void (*unlink_rpc_prepare)(struct rpc_task *, struct nfs_unlinkdata *);
	int (*unlink_done)(struct rpc_task *, struct inode *);
	void (*rename_setup)(struct rpc_message *, struct dentry *, struct dentry *);
	void (*rename_rpc_prepare)(struct rpc_task *, struct nfs_renamedata *);
	int (*rename_done)(struct rpc_task *, struct inode *, struct inode *);
	int (*link)(struct inode *, struct inode *, const struct qstr *);
	int (*symlink)(struct inode *, struct dentry *, struct folio *, unsigned int, struct iattr *);
	int (*mkdir)(struct inode *, struct dentry *, struct iattr *);
	int (*rmdir)(struct inode *, const struct qstr *);
	int (*readdir)(struct nfs_readdir_arg *, struct nfs_readdir_res *);
	int (*mknod)(struct inode *, struct dentry *, struct iattr *, dev_t);
	int (*statfs)(struct nfs_server *, struct nfs_fh *, struct nfs_fsstat *);
	int (*fsinfo)(struct nfs_server *, struct nfs_fh *, struct nfs_fsinfo *);
	int (*pathconf)(struct nfs_server *, struct nfs_fh *, struct nfs_pathconf *);
	int (*set_capabilities)(struct nfs_server *, struct nfs_fh *);
	int (*decode_dirent)(struct xdr_stream *, struct nfs_entry *, bool);
	int (*pgio_rpc_prepare)(struct rpc_task *, struct nfs_pgio_header *);
	void (*read_setup)(struct nfs_pgio_header *, struct rpc_message *);
	int (*read_done)(struct rpc_task *, struct nfs_pgio_header *);
	void (*write_setup)(struct nfs_pgio_header *, struct rpc_message *, struct rpc_clnt **);
	int (*write_done)(struct rpc_task *, struct nfs_pgio_header *);
	void (*commit_setup)(struct nfs_commit_data *, struct rpc_message *, struct rpc_clnt **);
	void (*commit_rpc_prepare)(struct rpc_task *, struct nfs_commit_data *);
	int (*commit_done)(struct rpc_task *, struct nfs_commit_data *);
	int (*lock)(struct file *, int, struct file_lock *);
	int (*lock_check_bounds)(const struct file_lock *);
	void (*clear_acl_cache)(struct inode *);
	void (*close_context)(struct nfs_open_context *, int);
	struct inode * (*open_context)(struct inode *, struct nfs_open_context *, int, struct iattr *, int *);
	int (*have_delegation)(struct inode *, fmode_t, int);
	int (*return_delegation)(struct inode *);
	struct nfs_client * (*alloc_client)(const struct nfs_client_initdata *);
	struct nfs_client * (*init_client)(struct nfs_client *, const struct nfs_client_initdata *);
	void (*free_client)(struct nfs_client *);
	struct nfs_server * (*create_server)(struct fs_context *);
	struct nfs_server * (*clone_server)(struct nfs_server *, struct nfs_fh *, struct nfs_fattr *, rpc_authflavor_t);
	int (*discover_trunking)(struct nfs_server *, struct nfs_fh *);
	void (*enable_swap)(struct inode *);
	void (*disable_swap)(struct inode *);
};

struct rpc_task_setup;

struct nfs_rw_ops {
	struct nfs_pgio_header * (*rw_alloc_header)(void);
	void (*rw_free_header)(struct nfs_pgio_header *);
	int (*rw_done)(struct rpc_task *, struct nfs_pgio_header *, struct inode *);
	void (*rw_result)(struct rpc_task *, struct nfs_pgio_header *);
	void (*rw_initiate)(struct nfs_pgio_header *, struct rpc_message *, const struct nfs_rpc_ops *, struct rpc_task_setup *, int);
};

struct nfs_seqid {
	struct nfs_seqid_counter *sequence;
	struct list_head list;
	struct rpc_task *task;
};

struct pnfs_layoutdriver_type;

struct nlm_host;

struct nfs_server {
	struct nfs_client *nfs_client;
	struct list_head client_link;
	struct list_head master_link;
	struct rpc_clnt *client;
	struct rpc_clnt *client_acl;
	struct nlm_host *nlm_host;
	struct nfs_iostats *io_stats;
	wait_queue_head_t write_congestion_wait;
	atomic_long_t writeback;
	unsigned int write_congested;
	unsigned int flags;
	unsigned int fattr_valid;
	unsigned int caps;
	unsigned int rsize;
	unsigned int rpages;
	unsigned int wsize;
	unsigned int wpages;
	unsigned int wtmult;
	unsigned int dtsize;
	short unsigned int port;
	unsigned int bsize;
	unsigned int acregmin;
	unsigned int acregmax;
	unsigned int acdirmin;
	unsigned int acdirmax;
	unsigned int namelen;
	unsigned int options;
	unsigned int clone_blksize;
	enum nfs4_change_attr_type change_attr_type;
	struct nfs_fsid fsid;
	int s_sysfs_id;
	__u64 maxfilesize;
	struct timespec64 time_delta;
	long unsigned int mount_time;
	struct super_block *super;
	dev_t s_dev;
	struct nfs_auth_info auth_info;
	u32 pnfs_blksize;
	u32 attr_bitmask[3];
	u32 attr_bitmask_nl[3];
	u32 exclcreat_bitmask[3];
	u32 cache_consistency_bitmask[3];
	u32 acl_bitmask;
	u32 fh_expire_type;
	struct pnfs_layoutdriver_type *pnfs_curr_ld;
	struct rpc_wait_queue roc_rpcwaitq;
	void *pnfs_ld_data;
	struct rb_root state_owners;
	atomic64_t owner_ctr;
	struct list_head state_owners_lru;
	struct list_head layouts;
	struct list_head delegations;
	struct list_head ss_copies;
	struct list_head ss_src_copies;
	long unsigned int delegation_gen;
	long unsigned int mig_gen;
	long unsigned int mig_status;
	void (*destroy)(struct nfs_server *);
	atomic_t active;
	struct __kernel_sockaddr_storage mountd_address;
	size_t mountd_addrlen;
	u32 mountd_version;
	short unsigned int mountd_port;
	short unsigned int mountd_protocol;
	struct rpc_wait_queue uoc_rpcwaitq;
	unsigned int read_hdrsize;
	const struct cred *cred;
	bool has_sec_mnt_opts;
	struct kobject kobj;
	struct callback_head rcu;
};

struct nfs_setaclargs {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *fh;
	enum nfs4_acl_type acl_type;
	size_t acl_len;
	struct page **acl_pages;
};

struct nfs_setaclres {
	struct nfs4_sequence_res seq_res;
};

struct nfs_setattrargs {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *fh;
	nfs4_stateid stateid;
	struct iattr *iap;
	const struct nfs_server *server;
	const u32 *bitmask;
	const struct nfs4_label *label;
};

struct nfs_setattrres {
	struct nfs4_sequence_res seq_res;
	struct nfs_fattr *fattr;
	const struct nfs_server *server;
};

struct rpc_version;

struct super_operations;

struct xattr_handler;

struct nfs_subversion {
	struct module *owner;
	struct file_system_type *nfs_fs;
	const struct rpc_version *rpc_vers;
	const struct nfs_rpc_ops *rpc_ops;
	const struct super_operations *sops;
	const struct xattr_handler * const *xattr;
};

struct nfs_unlinkdata {
	struct nfs_removeargs args;
	struct nfs_removeres res;
	struct dentry *dentry;
	wait_queue_head_t wq;
	const struct cred *cred;
	struct nfs_fattr dir_attr;
	long int timeout;
};

struct xdr_array2_desc;

typedef int (*xdr_xcode_elem_t)(struct xdr_array2_desc *, void *);

struct xdr_array2_desc {
	unsigned int elem_size;
	unsigned int array_len;
	unsigned int array_maxlen;
	xdr_xcode_elem_t xcode;
};

struct nfsacl_decode_desc {
	struct xdr_array2_desc desc;
	unsigned int count;
	struct posix_acl *acl;
};

struct nfsacl_encode_desc {
	struct xdr_array2_desc desc;
	unsigned int count;
	struct posix_acl *acl;
	int typeflag;
	kuid_t uid;
	kgid_t gid;
};

struct posix_acl_entry {
	short int e_tag;
	short unsigned int e_perm;
	union {
		kuid_t e_uid;
		kgid_t e_gid;
	};
};

struct posix_acl {
	refcount_t a_refcount;
	unsigned int a_count;
	struct callback_head a_rcu;
	struct posix_acl_entry a_entries[0];
};

struct nfsacl_simple_acl {
	struct posix_acl acl;
	struct posix_acl_entry ace[4];
};

struct nft_ct_frag6_pernet {
	struct ctl_table_header *nf_frag_frags_hdr;
	struct fqdir *fqdir;
};

struct nfulnl_instance {
	struct hlist_node hlist;
	spinlock_t lock;
	refcount_t use;
	unsigned int qlen;
	struct sk_buff *skb;
	struct timer_list timer;
	struct net *net;
	netns_tracker ns_tracker;
	struct user_namespace *peer_user_ns;
	u32 peer_portid;
	unsigned int flushtimeout;
	unsigned int nlbufsiz;
	unsigned int qthreshold;
	u_int32_t copy_range;
	u_int32_t seq;
	u_int16_t group_num;
	u_int16_t flags;
	u_int8_t copy_mode;
	struct callback_head rcu;
};

struct nfulnl_msg_config_cmd {
	__u8 command;
};

struct nfulnl_msg_config_mode {
	__be32 copy_range;
	__u8 copy_mode;
	__u8 _pad;
} __attribute__((packed));

struct nfulnl_msg_packet_hdr {
	__be16 hw_protocol;
	__u8 hook;
	__u8 _pad;
};

struct nfulnl_msg_packet_hw {
	__be16 hw_addrlen;
	__u16 _pad;
	__u8 hw_addr[8];
};

struct nfulnl_msg_packet_timestamp {
	__be64 sec;
	__be64 usec;
};

struct nh_config {
	u32 nh_id;
	u8 nh_family;
	u8 nh_protocol;
	u8 nh_blackhole;
	u8 nh_fdb;
	u32 nh_flags;
	int nh_ifindex;
	struct net_device *dev;
	union {
		__be32 ipv4;
		struct in6_addr ipv6;
	} gw;
	struct nlattr *nh_grp;
	u16 nh_grp_type;
	u16 nh_grp_res_num_buckets;
	long unsigned int nh_grp_res_idle_timer;
	long unsigned int nh_grp_res_unbalanced_timer;
	bool nh_grp_res_has_num_buckets;
	bool nh_grp_res_has_idle_timer;
	bool nh_grp_res_has_unbalanced_timer;
	bool nh_hw_stats;
	struct nlattr *nh_encap;
	u16 nh_encap_type;
	u32 nlflags;
	struct nl_info nlinfo;
};

struct nh_dump_filter {
	u32 nh_id;
	int dev_idx;
	int master_idx;
	bool group_filter;
	bool fdb_filter;
	u32 res_bucket_nh_id;
	u32 op_flags;
};

struct nh_grp_entry_stats;

struct nh_grp_entry {
	struct nexthop *nh;
	struct nh_grp_entry_stats *stats;
	u16 weight;
	union {
		struct {
			atomic_t upper_bound;
		} hthr;
		struct {
			struct list_head uw_nh_entry;
			u16 count_buckets;
			u16 wants_buckets;
		} res;
	};
	struct list_head nh_list;
	struct nexthop *nh_parent;
	u64 packets_hw;
};

struct nh_res_table;

struct nh_group {
	struct nh_group *spare;
	u16 num_nh;
	bool is_multipath;
	bool hash_threshold;
	bool resilient;
	bool fdb_nh;
	bool has_v4;
	bool hw_stats;
	struct nh_res_table *res_table;
	struct nh_grp_entry nh_entries[0];
};

struct nh_grp_entry_stats {
	u64_stats_t packets;
	struct u64_stats_sync syncp;
};

struct nh_info {
	struct hlist_node dev_hash;
	struct nexthop *nh_parent;
	u8 family;
	bool reject_nh;
	bool fdb_nh;
	union {
		struct fib_nh_common fib_nhc;
		struct fib_nh fib_nh;
		struct fib6_nh fib6_nh;
	};
};

struct nh_notifier_single_info {
	struct net_device *dev;
	u8 gw_family;
	union {
		__be32 ipv4;
		struct in6_addr ipv6;
	};
	u32 id;
	u8 is_reject: 1;
	u8 is_fdb: 1;
	u8 has_encap: 1;
};

struct nh_notifier_grp_entry_info {
	u16 weight;
	struct nh_notifier_single_info nh;
};

struct nh_notifier_grp_hw_stats_entry_info {
	u32 id;
	u64 packets;
};

struct nh_notifier_grp_hw_stats_info {
	u16 num_nh;
	bool hw_stats_used;
	struct nh_notifier_grp_hw_stats_entry_info stats[0];
};

struct nh_notifier_grp_info {
	u16 num_nh;
	bool is_fdb;
	bool hw_stats;
	struct nh_notifier_grp_entry_info nh_entries[0];
};

struct nh_notifier_res_table_info;

struct nh_notifier_res_bucket_info;

struct nh_notifier_info {
	struct net *net;
	struct netlink_ext_ack *extack;
	u32 id;
	enum nh_notifier_info_type type;
	union {
		struct nh_notifier_single_info *nh;
		struct nh_notifier_grp_info *nh_grp;
		struct nh_notifier_res_table_info *nh_res_table;
		struct nh_notifier_res_bucket_info *nh_res_bucket;
		struct nh_notifier_grp_hw_stats_info *nh_grp_hw_stats;
	};
};

struct nh_notifier_res_bucket_info {
	u16 bucket_index;
	unsigned int idle_timer_ms;
	bool force;
	struct nh_notifier_single_info old_nh;
	struct nh_notifier_single_info new_nh;
};

struct nh_notifier_res_table_info {
	u16 num_nh_buckets;
	bool hw_stats;
	struct nh_notifier_single_info nhs[0];
};

struct nh_res_bucket {
	struct nh_grp_entry *nh_entry;
	atomic_long_t used_time;
	long unsigned int migrated_time;
	bool occupied;
	u8 nh_flags;
};

struct nh_res_table {
	struct net *net;
	u32 nhg_id;
	struct delayed_work upkeep_dw;
	struct list_head uw_nh_entries;
	long unsigned int unbalanced_since;
	u32 idle_timer;
	u32 unbalanced_timer;
	u16 num_nh_buckets;
	struct nh_res_bucket nh_buckets[0];
};

struct nhlt_specific_cfg {
	u32 size;
	u8 caps[0];
};

struct nhlt_endpoint {
	u32 length;
	u8 linktype;
	u8 instance_id;
	u16 vendor_id;
	u16 device_id;
	u16 revision_id;
	u32 subsystem_id;
	u8 device_type;
	u8 direction;
	u8 virtual_bus_id;
	struct nhlt_specific_cfg config;
} __attribute__((packed));

struct nhlt_acpi_table {
	struct acpi_table_header header;
	u8 endpoint_count;
	struct nhlt_endpoint desc[0];
} __attribute__((packed));

struct nhlt_device_specific_config {
	u8 virtual_slot;
	u8 config_type;
};

struct nhlt_dmic_array_config {
	struct nhlt_device_specific_config device_config;
	u8 array_type;
};

struct wav_fmt {
	u16 fmt_tag;
	u16 channels;
	u32 samples_per_sec;
	u32 avg_bytes_per_sec;
	u16 block_align;
	u16 bits_per_sample;
	u16 cb_size;
} __attribute__((packed));

union samples {
	u16 valid_bits_per_sample;
	u16 samples_per_block;
	u16 reserved;
};

struct wav_fmt_ext {
	struct wav_fmt fmt;
	union samples sample;
	u32 channel_mask;
	u8 sub_fmt[16];
};

struct nhlt_fmt_cfg {
	struct wav_fmt_ext fmt_ext;
	struct nhlt_specific_cfg config;
};

struct nhlt_fmt {
	u8 fmt_count;
	struct nhlt_fmt_cfg fmt_config[0];
} __attribute__((packed));

struct nhlt_vendor_dmic_array_config {
	struct nhlt_dmic_array_config dmic_config;
	u8 nb_mics;
};

struct nhmsg {
	unsigned char nh_family;
	unsigned char nh_scope;
	unsigned char nh_protocol;
	unsigned char resvd;
	unsigned int nh_flags;
};

struct rfd {
	__le16 status;
	__le16 command;
	__le32 link;
	__le32 rbd;
	__le16 actual_size;
	__le16 size;
};

struct param_range {
	u32 min;
	u32 max;
	u32 count;
};

struct params {
	struct param_range rfds;
	struct param_range cbs;
};

struct rx;

struct nic {
	u32 msg_enable;
	struct net_device *netdev;
	struct pci_dev *pdev;
	u16 (*mdio_ctrl)(struct nic *, u32, u32, u32, u16);
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct rx *rxs;
	struct rx *rx_to_use;
	struct rx *rx_to_clean;
	struct rfd blank_rfd;
	enum ru_state ru_running;
	long: 64;
	long: 64;
	spinlock_t cb_lock;
	spinlock_t cmd_lock;
	struct csr *csr;
	enum scb_cmd_lo cuc_cmd;
	unsigned int cbs_avail;
	struct napi_struct napi;
	struct cb *cbs;
	struct cb *cb_to_use;
	struct cb *cb_to_send;
	struct cb *cb_to_clean;
	__le16 tx_command;
	long: 64;
	long: 64;
	enum {
		ich = 1,
		promiscuous = 2,
		multicast_all = 4,
		wol_magic = 8,
		ich_10h_workaround = 16,
	} flags;
	enum mac mac;
	enum phy phy;
	struct params params;
	struct timer_list watchdog;
	struct mii_if_info mii;
	struct work_struct tx_timeout_task;
	enum loopback loopback;
	struct mem *mem;
	dma_addr_t dma_addr;
	struct dma_pool *cbs_pool;
	dma_addr_t cbs_dma_addr;
	u8 adaptive_ifs;
	u8 tx_threshold;
	u32 tx_frames;
	u32 tx_collisions;
	u32 tx_deferred;
	u32 tx_single_collisions;
	u32 tx_multiple_collisions;
	u32 tx_fc_pause;
	u32 tx_tco_frames;
	u32 rx_fc_pause;
	u32 rx_fc_unsupported;
	u32 rx_tco_frames;
	u32 rx_short_frame_errors;
	u32 rx_over_length_errors;
	u16 eeprom_wc;
	__le16 eeprom[256];
	spinlock_t mdio_lock;
	const struct firmware *fw;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct nl80211_bss_select_rssi_adjust {
	__u8 band;
	__s8 delta;
};

struct nl80211_pattern_support {
	__u32 max_patterns;
	__u32 min_pattern_len;
	__u32 max_pattern_len;
	__u32 max_pkt_offset;
};

struct nl80211_coalesce_rule_support {
	__u32 max_rules;
	struct nl80211_pattern_support pat;
	__u32 max_delay;
};

struct nl80211_dump_wiphy_state {
	s64 filter_wiphy;
	long int start;
	long int split_start;
	long int band_start;
	long int chan_start;
	long int capa_start;
	bool split;
};

struct nl80211_mlme_event {
	enum nl80211_commands cmd;
	const u8 *buf;
	size_t buf_len;
	int uapsd_queues;
	const u8 *req_ies;
	size_t req_ies_len;
	bool reconnect;
};

struct nl80211_sta_flag_update {
	__u32 mask;
	__u32 set;
};

struct nl80211_txrate_he {
	__u16 mcs[8];
};

struct nl80211_txrate_vht {
	__u16 mcs[8];
};

struct nl80211_vendor_cmd_info {
	__u32 vendor_id;
	__u32 subcmd;
};

struct nl80211_wowlan_tcp_data_token_feature {
	__u32 min_len;
	__u32 max_len;
	__u32 bufsize;
};

struct nl_pktinfo {
	__u32 group;
};

struct rhashtable_walker {
	struct list_head list;
	struct bucket_table *tbl;
};

struct rhashtable_iter {
	struct rhashtable *ht;
	struct rhash_head *p;
	struct rhlist_head *list;
	struct rhashtable_walker walker;
	unsigned int slot;
	unsigned int skip;
	bool end_of_table;
};

struct nl_seq_iter {
	struct seq_net_private p;
	struct rhashtable_iter hti;
	int link;
};

struct nla_bitfield32 {
	__u32 value;
	__u32 selector;
};

struct nla_policy {
	u8 type;
	u8 validation_type;
	u16 len;
	union {
		u16 strict_start_type;
		const u32 bitfield32_valid;
		const u32 mask;
		const char *reject_message;
		const struct nla_policy *nested_policy;
		const struct netlink_range_validation *range;
		const struct netlink_range_validation_signed *range_signed;
		struct {
			s16 min;
			s16 max;
		};
		int (*validate)(const struct nlattr *, struct netlink_ext_ack *);
	};
};

struct nlattr {
	__u16 nla_len;
	__u16 nla_type;
};

struct nlm_cookie {
	unsigned char data[32];
	unsigned int len;
};

struct nlm_lock {
	char *caller;
	unsigned int len;
	struct nfs_fh fh;
	struct xdr_netobj oh;
	u32 svid;
	u64 lock_start;
	u64 lock_len;
	struct file_lock fl;
};

struct nlm_args {
	struct nlm_cookie cookie;
	struct nlm_lock lock;
	u32 block;
	u32 reclaim;
	u32 state;
	u32 monitor;
	u32 fsm_access;
	u32 fsm_mode;
};

struct nlm_rqst;

struct nlm_file;

struct nlm_block {
	struct kref b_count;
	struct list_head b_list;
	struct list_head b_flist;
	struct nlm_rqst *b_call;
	struct svc_serv *b_daemon;
	struct nlm_host *b_host;
	long unsigned int b_when;
	unsigned int b_id;
	unsigned char b_granted;
	struct nlm_file *b_file;
	struct cache_req *b_cache_req;
	struct cache_deferred_req *b_deferred_req;
	unsigned int b_flags;
};

struct nlm_share;

struct nlm_file {
	struct hlist_node f_list;
	struct nfs_fh f_handle;
	struct file *f_file[2];
	struct nlm_share *f_shares;
	struct list_head f_blocks;
	unsigned int f_locks;
	unsigned int f_count;
	struct mutex f_mutex;
};

struct nsm_handle;

struct nlm_host {
	struct hlist_node h_hash;
	struct __kernel_sockaddr_storage h_addr;
	size_t h_addrlen;
	struct __kernel_sockaddr_storage h_srcaddr;
	size_t h_srcaddrlen;
	struct rpc_clnt *h_rpcclnt;
	char *h_name;
	u32 h_version;
	short unsigned int h_proto;
	short unsigned int h_reclaiming: 1;
	short unsigned int h_server: 1;
	short unsigned int h_noresvport: 1;
	short unsigned int h_inuse: 1;
	wait_queue_head_t h_gracewait;
	struct rw_semaphore h_rwsem;
	u32 h_state;
	u32 h_nsmstate;
	u32 h_pidcount;
	refcount_t h_count;
	struct mutex h_mutex;
	long unsigned int h_nextrebind;
	long unsigned int h_expires;
	struct list_head h_lockowners;
	spinlock_t h_lock;
	struct list_head h_granted;
	struct list_head h_reclaim;
	struct nsm_handle *h_nsmhandle;
	char *h_addrbuf;
	struct net *net;
	const struct cred *h_cred;
	char nodename[65];
	const struct nlmclnt_operations *h_nlmclnt_ops;
};

struct nlm_lockowner {
	struct list_head list;
	refcount_t count;
	struct nlm_host *host;
	fl_owner_t owner;
	uint32_t pid;
};

struct nlm_lookup_host_info {
	const int server;
	const struct sockaddr *sap;
	const size_t salen;
	const short unsigned int protocol;
	const u32 version;
	const char *hostname;
	const size_t hostname_len;
	const int noresvport;
	struct net *net;
	const struct cred *cred;
};

struct nsm_private {
	unsigned char data[16];
};

struct nlm_reboot {
	char *mon;
	unsigned int len;
	u32 state;
	struct nsm_private priv;
};

struct nlm_res {
	struct nlm_cookie cookie;
	__be32 status;
	struct nlm_lock lock;
};

struct nlm_rqst {
	refcount_t a_count;
	unsigned int a_flags;
	struct nlm_host *a_host;
	struct nlm_args a_args;
	struct nlm_res a_res;
	struct nlm_block *a_block;
	unsigned int a_retries;
	u8 a_owner[74];
	void *a_callback_data;
};

struct nlm_share {
	struct nlm_share *s_next;
	struct nlm_host *s_host;
	struct nlm_file *s_file;
	struct xdr_netobj s_owner;
	u32 s_access;
	u32 s_mode;
};

struct nlm_wait {
	struct list_head b_list;
	wait_queue_head_t b_wait;
	struct nlm_host *b_host;
	struct file_lock *b_lock;
	__be32 b_status;
};

struct nlmclnt_initdata {
	const char *hostname;
	const struct sockaddr *address;
	size_t addrlen;
	short unsigned int protocol;
	u32 nfs_version;
	int noresvport;
	struct net *net;
	const struct nlmclnt_operations *nlmclnt_ops;
	const struct cred *cred;
};

struct nlmclnt_operations {
	void (*nlmclnt_alloc_call)(void *);
	bool (*nlmclnt_unlock_prepare)(struct rpc_task *, void *);
	void (*nlmclnt_release_call)(void *);
};

struct nlmsg_perm {
	u16 nlmsg_type;
	u32 perm;
};

struct nlmsghdr {
	__u32 nlmsg_len;
	__u16 nlmsg_type;
	__u16 nlmsg_flags;
	__u32 nlmsg_seq;
	__u32 nlmsg_pid;
};

struct nlmsgerr {
	int error;
	struct nlmsghdr msg;
};

struct nlmsvc_binding {
	__be32 (*fopen)(struct svc_rqst *, struct nfs_fh *, struct file **, int);
	void (*fclose)(struct file *);
};

struct nls_table {
	const char *charset;
	const char *alias;
	int (*uni2char)(wchar_t, unsigned char *, int);
	int (*char2uni)(const unsigned char *, int, wchar_t *);
	const unsigned char *charset2lower;
	const unsigned char *charset2upper;
	struct module *owner;
	struct nls_table *next;
};

struct nmi_desc {
	raw_spinlock_t lock;
	struct list_head head;
};

struct nmi_stats {
	unsigned int normal;
	unsigned int unknown;
	unsigned int external;
	unsigned int swallow;
	long unsigned int recv_jiffies;
	long unsigned int idt_seq;
	long unsigned int idt_nmi_seq;
	long unsigned int idt_ignored;
	atomic_long_t idt_calls;
	long unsigned int idt_seq_snap;
	long unsigned int idt_nmi_seq_snap;
	long unsigned int idt_ignored_snap;
	long int idt_calls_snap;
};

typedef int (*nmi_handler_t)(unsigned int, struct pt_regs *);

struct nmiaction {
	struct list_head list;
	nmi_handler_t handler;
	u64 max_duration;
	long unsigned int flags;
	const char *name;
};

struct node {
	struct device dev;
	struct list_head access_list;
};

struct node_access_nodes {
	struct device dev;
	struct list_head list_node;
	unsigned int access;
};

struct node_attr {
	struct device_attribute attr;
	enum node_states state;
};

struct node_groups {
	unsigned int id;
	union {
		unsigned int ngroups;
		unsigned int ncpus;
	};
};

struct node_hstate {
	struct kobject *hugepages_kobj;
	struct kobject *hstate_kobjs[2];
};

struct node_memory_type_map {
	struct memory_dev_type *memtype;
	int map_count;
};

struct nodemask_scratch {
	nodemask_t mask1;
	nodemask_t mask2;
};

struct nosave_region {
	struct list_head list;
	long unsigned int start_pfn;
	long unsigned int end_pfn;
};

struct notification {
	atomic_t requests;
	u32 flags;
	u64 next_id;
	struct list_head notifications;
};

struct ns2501_configuration {
	u8 sync;
	u8 conf;
	u8 syncb;
	u8 dither;
	u8 pll_a;
	u16 pll_b;
	u16 hstart;
	u16 hstop;
	u16 vstart;
	u16 vstop;
	u16 vsync;
	u16 vtotal;
	u16 hpos;
	u16 vpos;
	u16 voffs;
	u16 hscale;
	u16 vscale;
};

struct ns2501_priv {
	bool quiet;
	const struct ns2501_configuration *conf;
};

struct ns2501_reg {
	u8 offset;
	u8 value;
};

struct ns_get_path_bpf_map_args {
	struct bpf_offloaded_map *offmap;
	struct bpf_map_info *info;
};

struct ns_get_path_bpf_prog_args {
	struct bpf_prog *prog;
	struct bpf_prog_info *info;
};

struct ns_get_path_task_args {
	const struct proc_ns_operations *ns_ops;
	struct task_struct *task;
};

struct nsm_args {
	struct nsm_private *priv;
	u32 prog;
	u32 vers;
	u32 proc;
	char *mon_name;
	const char *nodename;
};

struct nsm_handle {
	struct list_head sm_link;
	refcount_t sm_count;
	char *sm_mon_name;
	char *sm_name;
	struct __kernel_sockaddr_storage sm_addr;
	size_t sm_addrlen;
	unsigned int sm_monitored: 1;
	unsigned int sm_sticky: 1;
	struct nsm_private sm_priv;
	char sm_addrbuf[51];
};

struct nsm_res {
	u32 status;
	u32 state;
};

struct uts_namespace;

struct time_namespace;

struct nsproxy {
	refcount_t count;
	struct uts_namespace *uts_ns;
	struct ipc_namespace *ipc_ns;
	struct mnt_namespace *mnt_ns;
	struct pid_namespace *pid_ns_for_children;
	struct net *net_ns;
	struct time_namespace *time_ns;
	struct time_namespace *time_ns_for_children;
	struct cgroup_namespace *cgroup_ns;
};

struct nsset {
	unsigned int flags;
	struct nsproxy *nsproxy;
	struct fs_struct *fs;
	const struct cred *cred;
};

struct nt_partition_info {
	u32 xlink_enabled;
	u32 target_part_low;
	u32 target_part_high;
	u32 reserved;
};

struct ntb_ctrl_regs {
	u32 partition_status;
	u32 partition_op;
	u32 partition_ctrl;
	u32 bar_setup;
	u32 bar_error;
	u16 lut_table_entries;
	u16 lut_table_offset;
	u32 lut_error;
	u16 req_id_table_size;
	u16 req_id_table_offset;
	u32 req_id_error;
	u32 reserved1[7];
	struct {
		u32 ctl;
		u32 win_size;
		u64 xlate_addr;
	} bar_entry[6];
	struct {
		u32 win_size;
		u32 reserved[3];
	} bar_ext_entry[6];
	u32 reserved2[192];
	u32 req_id_table[512];
	u32 reserved3[256];
	u64 lut_entry[512];
};

struct ntb_info_regs {
	u8 partition_count;
	u8 partition_id;
	u16 reserved1;
	u64 ep_map;
	u16 requester_id;
	u16 reserved2;
	u32 reserved3[4];
	struct nt_partition_info ntp_info[48];
} __attribute__((packed));

struct ntp_data {
	long unsigned int tick_usec;
	u64 tick_length;
	u64 tick_length_base;
	int time_state;
	int time_status;
	s64 time_offset;
	long int time_constant;
	long int time_maxerror;
	long int time_esterror;
	s64 time_freq;
	time64_t time_reftime;
	long int time_adjust;
	s64 ntp_tick_adj;
	time64_t ntp_next_leap_sec;
};

struct ntrig_data {
	__u16 x;
	__u16 y;
	__u16 w;
	__u16 h;
	__u16 id;
	bool tipswitch;
	bool confidence;
	bool first_contact_touch;
	bool reading_mt;
	__u8 mt_footer[4];
	__u8 mt_foot_count;
	__s8 act_state;
	__s8 deactivate_slack;
	__s8 activate_slack;
	__u16 min_width;
	__u16 min_height;
	__u16 activation_width;
	__u16 activation_height;
	__u16 sensor_logical_width;
	__u16 sensor_logical_height;
	__u16 sensor_physical_width;
	__u16 sensor_physical_height;
};

struct numa_maps {
	long unsigned int pages;
	long unsigned int anon;
	long unsigned int active;
	long unsigned int writeback;
	long unsigned int mapcount_max;
	long unsigned int dirty;
	long unsigned int swapcache;
	long unsigned int node[64];
};

struct proc_maps_private {
	struct inode *inode;
	struct task_struct *task;
	struct mm_struct *mm;
	struct vma_iterator iter;
	struct mempolicy *task_mempolicy;
};

struct numa_maps_private {
	struct proc_maps_private proc_maps;
	struct numa_maps md;
};

struct numa_memblk {
	u64 start;
	u64 end;
	int nid;
};

struct numa_meminfo {
	int nr_blks;
	struct numa_memblk blk[128];
};

struct nv_ethtool_str {
	char name[32];
};

struct nv_skb_map {
	struct sk_buff *skb;
	dma_addr_t dma;
	unsigned int dma_len: 31;
	unsigned int dma_single: 1;
	struct ring_desc_ex *first_tx_desc;
	struct nv_skb_map *next_tx_ctx;
};

struct nv_txrx_stats {
	u64 stat_rx_packets;
	u64 stat_rx_bytes;
	u64 stat_rx_missed_errors;
	u64 stat_rx_dropped;
	u64 stat_tx_packets;
	u64 stat_tx_bytes;
	u64 stat_tx_dropped;
};

struct nvmem_cell_entry;

struct nvmem_cell {
	struct nvmem_cell_entry *entry;
	const char *id;
	int index;
};

typedef int (*nvmem_cell_post_process_t)(void *, const char *, int, unsigned int, void *, size_t);

struct nvmem_device;

struct nvmem_cell_entry {
	const char *name;
	int offset;
	size_t raw_len;
	int bytes;
	int bit_offset;
	int nbits;
	nvmem_cell_post_process_t read_post_process;
	void *priv;
	struct device_node *np;
	struct nvmem_device *nvmem;
	struct list_head node;
};

struct nvmem_cell_info {
	const char *name;
	unsigned int offset;
	size_t raw_len;
	unsigned int bytes;
	unsigned int bit_offset;
	unsigned int nbits;
	struct device_node *np;
	nvmem_cell_post_process_t read_post_process;
	void *priv;
};

struct nvmem_cell_lookup {
	const char *nvmem_name;
	const char *cell_name;
	const char *dev_id;
	const char *con_id;
	struct list_head node;
};

struct nvmem_cell_table {
	const char *nvmem_name;
	const struct nvmem_cell_info *cells;
	size_t ncells;
	struct list_head node;
};

typedef int (*nvmem_reg_read_t)(void *, unsigned int, void *, size_t);

typedef int (*nvmem_reg_write_t)(void *, unsigned int, void *, size_t);

struct nvmem_keepout;

struct nvmem_layout;

struct nvmem_config {
	struct device *dev;
	const char *name;
	int id;
	struct module *owner;
	const struct nvmem_cell_info *cells;
	int ncells;
	bool add_legacy_fixed_of_cells;
	void (*fixup_dt_cell_info)(struct nvmem_device *, struct nvmem_cell_info *);
	const struct nvmem_keepout *keepout;
	unsigned int nkeepout;
	enum nvmem_type type;
	bool read_only;
	bool root_only;
	bool ignore_wp;
	struct nvmem_layout *layout;
	struct device_node *of_node;
	nvmem_reg_read_t reg_read;
	nvmem_reg_write_t reg_write;
	int size;
	int word_size;
	int stride;
	void *priv;
	bool compat;
	struct device *base_dev;
};

struct nvmem_device {
	struct module *owner;
	struct device dev;
	struct list_head node;
	int stride;
	int word_size;
	int id;
	struct kref refcnt;
	size_t size;
	bool read_only;
	bool root_only;
	int flags;
	enum nvmem_type type;
	struct bin_attribute eeprom;
	struct device *base_dev;
	struct list_head cells;
	void (*fixup_dt_cell_info)(struct nvmem_device *, struct nvmem_cell_info *);
	const struct nvmem_keepout *keepout;
	unsigned int nkeepout;
	nvmem_reg_read_t reg_read;
	nvmem_reg_write_t reg_write;
	struct gpio_desc *wp_gpio;
	struct nvmem_layout *layout;
	void *priv;
	bool sysfs_cells_populated;
};

struct nvmem_keepout {
	unsigned int start;
	unsigned int end;
	unsigned char value;
};

struct nvmem_layout {
	struct device dev;
	struct nvmem_device *nvmem;
	int (*add_cells)(struct nvmem_layout *);
};

struct nvram_ops {
	ssize_t (*get_size)(void);
	unsigned char (*read_byte)(int);
	void (*write_byte)(unsigned char, int);
	ssize_t (*read)(char *, size_t, loff_t *);
	ssize_t (*write)(char *, size_t, loff_t *);
	long int (*initialize)(void);
	long int (*set_checksum)(void);
};

struct nvs_page {
	long unsigned int phys_start;
	unsigned int size;
	void *kaddr;
	void *data;
	bool unmap;
	struct list_head node;
};

struct nvs_region {
	__u64 phys_start;
	__u64 size;
	struct list_head node;
};

struct objpool_head;

typedef int (*objpool_fini_cb)(struct objpool_head *, void *);

struct objpool_slot;

struct objpool_head {
	int obj_size;
	int nr_objs;
	int nr_possible_cpus;
	int capacity;
	gfp_t gfp;
	refcount_t ref;
	long unsigned int flags;
	struct objpool_slot **cpu_slots;
	objpool_fini_cb release;
	void *context;
};

struct objpool_slot {
	uint32_t head;
	uint32_t tail;
	uint32_t last;
	uint32_t mask;
	void *entries[0];
};

struct obs_kernel_param {
	const char *str;
	int (*setup_func)(char *);
	int early;
};

struct ocb_setup {
	struct cfg80211_chan_def chandef;
};

struct ocontext {
	union {
		char *name;
		struct {
			u8 protocol;
			u16 low_port;
			u16 high_port;
		} port;
		struct {
			u32 addr;
			u32 mask;
		} node;
		struct {
			u32 addr[4];
			u32 mask[4];
		} node6;
		struct {
			u64 subnet_prefix;
			u16 low_pkey;
			u16 high_pkey;
		} ibpkey;
		struct {
			char *dev_name;
			u8 port;
		} ibendport;
	} u;
	union {
		u32 sclass;
		u32 behavior;
	} v;
	struct context___2 context[2];
	u32 sid[2];
	struct ocontext *next;
};

struct od_dbs_tuners {
	unsigned int powersave_bias;
};

struct od_ops {
	unsigned int (*powersave_bias_target)(struct cpufreq_policy *, unsigned int, unsigned int);
};

struct policy_dbs_info {
	struct cpufreq_policy *policy;
	struct mutex update_mutex;
	u64 last_sample_time;
	s64 sample_delay_ns;
	atomic_t work_count;
	struct irq_work irq_work;
	struct work_struct work;
	struct dbs_data *dbs_data;
	struct list_head list;
	unsigned int rate_mult;
	unsigned int idle_periods;
	bool is_shared;
	bool work_in_progress;
};

struct od_policy_dbs_info {
	struct policy_dbs_info policy_dbs;
	unsigned int freq_lo;
	unsigned int freq_lo_delay_us;
	unsigned int freq_hi_delay_us;
	unsigned int sample_type: 1;
};

struct of_device_id {
	char name[32];
	char type[32];
	char compatible[128];
	const void *data;
};

struct of_phandle_args {
	struct device_node *np;
	int args_count;
	uint32_t args[16];
};

struct offset_ctx {
	struct maple_tree mt;
	long unsigned int next_offset;
};

struct ohci {
	void *registers;
};

struct ohci_driver_overrides {
	const char *product_desc;
	size_t extra_priv_size;
	int (*reset)(struct usb_hcd *);
};

struct ohci_hcca {
	__hc32 int_table[32];
	__hc32 frame_no;
	__hc32 done_head;
	u8 reserved_for_hc[116];
	u8 what[4];
};

struct ohci_regs;

struct ohci_hcd {
	spinlock_t lock;
	struct ohci_regs *regs;
	struct ohci_hcca *hcca;
	dma_addr_t hcca_dma;
	struct ed *ed_rm_list;
	struct ed *ed_bulktail;
	struct ed *ed_controltail;
	struct ed *periodic[32];
	void (*start_hnp)(struct ohci_hcd *);
	struct dma_pool *td_cache;
	struct dma_pool *ed_cache;
	struct td *td_hash[64];
	struct td *dl_start;
	struct td *dl_end;
	struct list_head pending;
	struct list_head eds_in_use;
	enum ohci_rh_state rh_state;
	int num_ports;
	int load[32];
	u32 hc_control;
	long unsigned int next_statechange;
	u32 fminterval;
	unsigned int autostop: 1;
	unsigned int working: 1;
	unsigned int restart_work: 1;
	long unsigned int flags;
	unsigned int prev_frame_no;
	unsigned int wdh_cnt;
	unsigned int prev_wdh_cnt;
	u32 prev_donehead;
	struct timer_list io_watchdog;
	struct work_struct nec_work;
	struct dentry *debug_dir;
	long unsigned int priv[0];
};

struct ohci_roothub_regs {
	__hc32 a;
	__hc32 b;
	__hc32 status;
	__hc32 portstatus[15];
};

struct ohci_regs {
	__hc32 revision;
	__hc32 control;
	__hc32 cmdstatus;
	__hc32 intrstatus;
	__hc32 intrenable;
	__hc32 intrdisable;
	__hc32 hcca;
	__hc32 ed_periodcurrent;
	__hc32 ed_controlhead;
	__hc32 ed_controlcurrent;
	__hc32 ed_bulkhead;
	__hc32 ed_bulkcurrent;
	__hc32 donehead;
	__hc32 fminterval;
	__hc32 fmremaining;
	__hc32 fmnumber;
	__hc32 periodicstart;
	__hc32 lsthresh;
	struct ohci_roothub_regs roothub;
	long: 64;
	long: 64;
};

struct old_timespec32 {
	old_time32_t tv_sec;
	s32 tv_nsec;
};

struct old_itimerspec32 {
	struct old_timespec32 it_interval;
	struct old_timespec32 it_value;
};

struct old_itimerval32 {
	struct old_timeval32 it_interval;
	struct old_timeval32 it_value;
};

struct old_linux_dirent {
	long unsigned int d_ino;
	long unsigned int d_offset;
	short unsigned int d_namlen;
	char d_name[0];
};

struct old_serial_port {
	unsigned int uart;
	unsigned int baud_base;
	unsigned int port;
	unsigned int irq;
	upf_t flags;
	unsigned char io_type;
	unsigned char *iomem_base;
	short unsigned int iomem_reg_shift;
};

struct old_timex32 {
	u32 modes;
	s32 offset;
	s32 freq;
	s32 maxerror;
	s32 esterror;
	s32 status;
	s32 constant;
	s32 precision;
	s32 tolerance;
	struct old_timeval32 time;
	s32 tick;
	s32 ppsfreq;
	s32 jitter;
	s32 shift;
	s32 stabil;
	s32 jitcnt;
	s32 calcnt;
	s32 errcnt;
	s32 stbcnt;
	s32 tai;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct old_utimbuf32 {
	old_time32_t actime;
	old_time32_t modtime;
};

struct old_utsname {
	char sysname[65];
	char nodename[65];
	char release[65];
	char version[65];
	char machine[65];
};

struct oldold_utsname {
	char sysname[9];
	char nodename[9];
	char release[9];
	char version[9];
	char machine[9];
};

struct once_work {
	struct work_struct work;
	struct static_key_true *key;
	struct module *module;
};

struct online_data {
	unsigned int cpu;
	bool online;
};

struct oom_control {
	struct zonelist *zonelist;
	nodemask_t *nodemask;
	struct mem_cgroup *memcg;
	const gfp_t gfp_mask;
	const int order;
	long unsigned int totalpages;
	struct task_struct *chosen;
	long int chosen_points;
	enum oom_constraint constraint;
};

struct open_flags {
	int open_flag;
	umode_t mode;
	int acc_mode;
	int intent;
	int lookup_flags;
};

struct opregion_acpi {
	u32 drdy;
	u32 csts;
	u32 cevt;
	u8 rsvd1[20];
	u32 didl[8];
	u32 cpdl[8];
	u32 cadl[8];
	u32 nadl[8];
	u32 aslp;
	u32 tidx;
	u32 chpd;
	u32 clid;
	u32 cdck;
	u32 sxsw;
	u32 evts;
	u32 cnot;
	u32 nrdy;
	u32 did2[7];
	u32 cpd2[7];
	u8 rsvd2[4];
};

struct opregion_asle {
	u32 ardy;
	u32 aslc;
	u32 tche;
	u32 alsi;
	u32 bclp;
	u32 pfit;
	u32 cblv;
	u16 bclm[20];
	u32 cpfm;
	u32 epfm;
	u8 plut[74];
	u32 pfmb;
	u32 cddv;
	u32 pcft;
	u32 srot;
	u32 iuer;
	u64 fdss;
	u32 fdsp;
	u32 stat;
	u64 rvda;
	u32 rvds;
	u8 rsvd[58];
} __attribute__((packed));

struct opregion_asle_ext {
	u32 phed;
	u8 bddc[256];
	u8 rsvd[764];
};

struct opregion_header {
	u8 signature[16];
	u32 size;
	struct {
		u8 rsvd;
		u8 revision;
		u8 minor;
		u8 major;
	} over;
	u8 bios_ver[32];
	u8 vbios_ver[16];
	u8 driver_ver[16];
	u32 mboxes;
	u32 driver_model;
	u32 pcon;
	u8 dver[32];
	u8 rsvd[124];
};

struct opregion_swsci {
	u32 scic;
	u32 parm;
	u32 dslp;
	u8 rsvd[244];
};

struct optimistic_spin_node {
	struct optimistic_spin_node *next;
	struct optimistic_spin_node *prev;
	int locked;
	int cpu;
};

struct optimized_kprobe {
	struct kprobe kp;
	struct list_head list;
	struct arch_optimized_insn optinsn;
};

struct orc_entry {
	s16 sp_offset;
	s16 bp_offset;
	unsigned int sp_reg: 4;
	unsigned int bp_reg: 4;
	unsigned int type: 3;
	unsigned int signal: 1;
} __attribute__((packed));

struct orlov_stats {
	__u64 free_clusters;
	__u32 free_inodes;
	__u32 used_dirs;
};

struct osnoise_entry {
	struct trace_entry ent;
	u64 noise;
	u64 runtime;
	u64 max_sample;
	unsigned int hw_count;
	unsigned int nmi_count;
	unsigned int irq_count;
	unsigned int softirq_count;
	unsigned int thread_count;
};

struct x86_cpu_id {
	__u16 vendor;
	__u16 family;
	__u16 model;
	__u16 steppings;
	__u16 feature;
	__u16 flags;
	kernel_ulong_t driver_data;
};

struct override_status_id {
	struct acpi_device_id hid[2];
	struct x86_cpu_id cpu_ids[2];
	struct dmi_system_id dmi_ids[2];
	const char *uid;
	const char *path;
	long long unsigned int status;
};

struct p2sb_res_cache {
	u32 bus_dev_id;
	struct resource res;
};

struct p4_event_alias {
	u64 original;
	u64 alternative;
};

struct p4_event_bind {
	unsigned int opcode;
	unsigned int escr_msr[2];
	unsigned int escr_emask;
	unsigned int shared;
	signed char cntr[6];
};

struct p4_pebs_bind {
	unsigned int metric_pebs;
	unsigned int metric_vert;
};

struct p9_trans_module;

struct p9_client {
	spinlock_t lock;
	unsigned int msize;
	unsigned char proto_version;
	struct p9_trans_module *trans_mod;
	enum p9_trans_status status;
	void *trans;
	struct kmem_cache *fcall_cache;
	union {
		struct {
			int rfd;
			int wfd;
		} fd;
		struct {
			u16 port;
			bool privport;
		} tcp;
	} trans_opts;
	struct idr fids;
	struct idr reqs;
	char name[65];
};

struct p9_fcall {
	u32 size;
	u8 id;
	u16 tag;
	size_t offset;
	size_t capacity;
	struct kmem_cache *cache;
	u8 *sdata;
	bool zc;
};

struct p9_conn;

struct p9_poll_wait {
	struct p9_conn *conn;
	wait_queue_entry_t wait;
	wait_queue_head_t *wait_addr;
};

struct p9_req_t;

struct p9_conn {
	struct list_head mux_list;
	struct p9_client *client;
	int err;
	spinlock_t req_lock;
	struct list_head req_list;
	struct list_head unsent_req_list;
	struct p9_req_t *rreq;
	struct p9_req_t *wreq;
	char tmp_buf[7];
	struct p9_fcall rc;
	int wpos;
	int wsize;
	char *wbuf;
	struct list_head poll_pending_link;
	struct p9_poll_wait poll_wait[2];
	poll_table pt;
	struct work_struct rq;
	struct work_struct wq;
	long unsigned int wsched;
};

struct p9_qid {
	u8 type;
	u32 version;
	u64 path;
};

struct p9_dirent {
	struct p9_qid qid;
	u64 d_off;
	unsigned char d_type;
	char d_name[256];
};

struct p9_fd_opts {
	int rfd;
	int wfd;
	u16 port;
	bool privport;
};

struct p9_fid {
	struct p9_client *clnt;
	u32 fid;
	refcount_t count;
	int mode;
	struct p9_qid qid;
	u32 iounit;
	kuid_t uid;
	void *rdir;
	struct hlist_node dlist;
	struct hlist_node ilist;
};

struct p9_flock {
	u8 type;
	u32 flags;
	u64 start;
	u64 length;
	u32 proc_id;
	char *client_id;
};

struct p9_getlock {
	u8 type;
	u64 start;
	u64 length;
	u32 proc_id;
	char *client_id;
};

struct p9_iattr_dotl {
	u32 valid;
	u32 mode;
	kuid_t uid;
	kgid_t gid;
	u64 size;
	u64 atime_sec;
	u64 atime_nsec;
	u64 mtime_sec;
	u64 mtime_nsec;
};

struct p9_rdir {
	int head;
	int tail;
	uint8_t buf[0];
};

struct p9_req_t {
	int status;
	int t_err;
	refcount_t refcount;
	wait_queue_head_t wq;
	struct p9_fcall tc;
	struct p9_fcall rc;
	struct list_head req_list;
};

struct p9_rstatfs {
	u32 type;
	u32 bsize;
	u64 blocks;
	u64 bfree;
	u64 bavail;
	u64 files;
	u64 ffree;
	u64 fsid;
	u32 namelen;
};

struct p9_stat_dotl {
	u64 st_result_mask;
	struct p9_qid qid;
	u32 st_mode;
	kuid_t st_uid;
	kgid_t st_gid;
	u64 st_nlink;
	u64 st_rdev;
	u64 st_size;
	u64 st_blksize;
	u64 st_blocks;
	u64 st_atime_sec;
	u64 st_atime_nsec;
	u64 st_mtime_sec;
	u64 st_mtime_nsec;
	u64 st_ctime_sec;
	u64 st_ctime_nsec;
	u64 st_btime_sec;
	u64 st_btime_nsec;
	u64 st_gen;
	u64 st_data_version;
};

struct p9_trans_fd {
	struct file *rd;
	struct file *wr;
	struct p9_conn conn;
};

struct p9_trans_module {
	struct list_head list;
	char *name;
	int maxsize;
	bool pooled_rbuffers;
	int def;
	struct module *owner;
	int (*create)(struct p9_client *, const char *, char *);
	void (*close)(struct p9_client *);
	int (*request)(struct p9_client *, struct p9_req_t *);
	int (*cancel)(struct p9_client *, struct p9_req_t *);
	int (*cancelled)(struct p9_client *, struct p9_req_t *);
	int (*zc_request)(struct p9_client *, struct p9_req_t *, struct iov_iter *, struct iov_iter *, int, int, int);
	int (*show_options)(struct seq_file *, struct p9_client *);
};

struct p9_wstat {
	u16 size;
	u16 type;
	u32 dev;
	struct p9_qid qid;
	u32 mode;
	u32 atime;
	u32 mtime;
	u64 length;
	const char *name;
	const char *uid;
	const char *gid;
	const char *muid;
	char *extension;
	kuid_t n_uid;
	kgid_t n_gid;
	kuid_t n_muid;
};

struct pacct_struct {
	int ac_flag;
	long int ac_exitcode;
	long unsigned int ac_mem;
	u64 ac_utime;
	u64 ac_stime;
	long unsigned int ac_minflt;
	long unsigned int ac_majflt;
};

struct scsi_sense_hdr;

struct packet_command {
	unsigned char cmd[12];
	unsigned char *buffer;
	unsigned int buflen;
	int stat;
	struct scsi_sense_hdr *sshdr;
	unsigned char data_direction;
	int quiet;
	int timeout;
	void *reserved[1];
};

struct packet_fanout {
	possible_net_t net;
	unsigned int num_members;
	u32 max_num_members;
	u16 id;
	u8 type;
	u8 flags;
	union {
		atomic_t rr_cur;
		struct bpf_prog *bpf_prog;
	};
	struct list_head list;
	spinlock_t lock;
	refcount_t sk_ref;
	long: 64;
	struct packet_type prot_hook;
	struct sock *arr[0];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct packet_mclist {
	struct packet_mclist *next;
	int ifindex;
	int count;
	short unsigned int type;
	short unsigned int alen;
	unsigned char addr[32];
};

struct packet_mreq_max {
	int mr_ifindex;
	short unsigned int mr_type;
	short unsigned int mr_alen;
	unsigned char mr_address[32];
};

struct pgv;

struct tpacket_kbdq_core {
	struct pgv *pkbdq;
	unsigned int feature_req_word;
	unsigned int hdrlen;
	unsigned char reset_pending_on_curr_blk;
	unsigned char delete_blk_timer;
	short unsigned int kactive_blk_num;
	short unsigned int blk_sizeof_priv;
	short unsigned int last_kactive_blk_num;
	char *pkblk_start;
	char *pkblk_end;
	int kblk_size;
	unsigned int max_frame_len;
	unsigned int knum_blocks;
	uint64_t knxt_seq_num;
	char *prev;
	char *nxt_offset;
	struct sk_buff *skb;
	rwlock_t blk_fill_in_prog_lock;
	short unsigned int retire_blk_tov;
	short unsigned int version;
	long unsigned int tov_in_jiffies;
	struct timer_list retire_blk_timer;
};

struct packet_ring_buffer {
	struct pgv *pg_vec;
	unsigned int head;
	unsigned int frames_per_block;
	unsigned int frame_size;
	unsigned int frame_max;
	unsigned int pg_vec_order;
	unsigned int pg_vec_pages;
	unsigned int pg_vec_len;
	unsigned int *pending_refcnt;
	union {
		long unsigned int *rx_owner_map;
		struct tpacket_kbdq_core prb_bdqc;
	};
};

struct packet_rollover {
	int sock;
	atomic_long_t num;
	atomic_long_t num_huge;
	atomic_long_t num_failed;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	u32 history[16];
};

struct sockaddr_pkt {
	short unsigned int spkt_family;
	unsigned char spkt_device[14];
	__be16 spkt_protocol;
};

struct sockaddr_ll {
	short unsigned int sll_family;
	__be16 sll_protocol;
	int sll_ifindex;
	short unsigned int sll_hatype;
	unsigned char sll_pkttype;
	unsigned char sll_halen;
	unsigned char sll_addr[8];
};

struct packet_skb_cb {
	union {
		struct sockaddr_pkt pkt;
		union {
			unsigned int origlen;
			struct sockaddr_ll ll;
		};
	} sa;
};

struct tpacket_stats {
	unsigned int tp_packets;
	unsigned int tp_drops;
};

struct tpacket_stats_v3 {
	unsigned int tp_packets;
	unsigned int tp_drops;
	unsigned int tp_freeze_q_cnt;
};

union tpacket_stats_u {
	struct tpacket_stats stats1;
	struct tpacket_stats_v3 stats3;
};

struct packet_sock {
	struct sock sk;
	struct packet_fanout *fanout;
	union tpacket_stats_u stats;
	struct packet_ring_buffer rx_ring;
	struct packet_ring_buffer tx_ring;
	int copy_thresh;
	spinlock_t bind_lock;
	struct mutex pg_vec_lock;
	long unsigned int flags;
	int ifindex;
	u8 vnet_hdr_sz;
	__be16 num;
	struct packet_rollover *rollover;
	struct packet_mclist *mclist;
	atomic_long_t mapped;
	enum tpacket_versions tp_version;
	unsigned int tp_hdrlen;
	unsigned int tp_reserve;
	unsigned int tp_tstamp;
	struct completion skb_completion;
	struct net_device *cached_dev;
	long: 64;
	long: 64;
	struct packet_type prot_hook;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	atomic_t tp_drops;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct padata_cpumask {
	cpumask_var_t pcpu;
	cpumask_var_t cbcpu;
};

struct padata_instance {
	struct hlist_node cpu_online_node;
	struct hlist_node cpu_dead_node;
	struct workqueue_struct *parallel_wq;
	struct workqueue_struct *serial_wq;
	struct list_head pslist;
	struct padata_cpumask cpumask;
	struct kobject kobj;
	struct mutex lock;
	u8 flags;
};

struct padata_list {
	struct list_head list;
	spinlock_t lock;
};

struct padata_mt_job {
	void (*thread_fn)(long unsigned int, long unsigned int, void *);
	void *fn_arg;
	long unsigned int start;
	long unsigned int size;
	long unsigned int align;
	long unsigned int min_chunk;
	int max_threads;
	bool numa_aware;
};

struct padata_mt_job_state {
	spinlock_t lock;
	struct completion completion;
	struct padata_mt_job *job;
	int nworks;
	int nworks_fini;
	long unsigned int chunk_size;
};

struct parallel_data;

struct padata_priv {
	struct list_head list;
	struct parallel_data *pd;
	int cb_cpu;
	unsigned int seq_nr;
	int info;
	void (*parallel)(struct padata_priv *);
	void (*serial)(struct padata_priv *);
};

struct padata_serial_queue {
	struct padata_list serial;
	struct work_struct work;
	struct parallel_data *pd;
};

struct padata_shell {
	struct padata_instance *pinst;
	struct parallel_data *pd;
	struct parallel_data *opd;
	struct list_head list;
};

struct padata_sysfs_entry {
	struct attribute attr;
	ssize_t (*show)(struct padata_instance *, struct attribute *, char *);
	ssize_t (*store)(struct padata_instance *, struct attribute *, const char *, size_t);
};

struct padata_work {
	struct work_struct pw_work;
	struct list_head pw_list;
	void *pw_data;
};

typedef struct page *pgtable_t;

struct printf_spec;

struct page_flags_fields {
	int width;
	int shift;
	int mask;
	const struct printf_spec *spec;
	const char *name;
};

struct page_list {
	struct page_list *next;
	struct page *page;
};

struct page_pool_params_fast {
	unsigned int order;
	unsigned int pool_size;
	int nid;
	struct device *dev;
	struct napi_struct *napi;
	enum dma_data_direction dma_dir;
	unsigned int max_len;
	unsigned int offset;
};

struct pp_alloc_cache {
	u32 count;
	netmem_ref cache[128];
};

struct ptr_ring {
	int producer;
	spinlock_t producer_lock;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	int consumer_head;
	int consumer_tail;
	spinlock_t consumer_lock;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	int size;
	int batch;
	void **queue;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct page_pool_params_slow {
	struct net_device *netdev;
	unsigned int queue_idx;
	unsigned int flags;
	void (*init_callback)(netmem_ref, void *);
	void *init_arg;
};

struct page_pool {
	struct page_pool_params_fast p;
	int cpuid;
	u32 pages_state_hold_cnt;
	bool has_init_callback: 1;
	bool dma_map: 1;
	bool dma_sync: 1;
	bool dma_sync_for_cpu: 1;
	long: 0;
	__u8 __cacheline_group_begin__frag[0];
	long int frag_users;
	netmem_ref frag_page;
	unsigned int frag_offset;
	long: 0;
	__u8 __cacheline_group_end__frag[0];
	long: 64;
	struct {} __cacheline_group_pad__frag;
	struct delayed_work release_dw;
	void (*disconnect)(void *);
	long unsigned int defer_start;
	long unsigned int defer_warn;
	u32 xdp_mem_id;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct pp_alloc_cache alloc;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct ptr_ring ring;
	void *mp_priv;
	atomic_t pages_state_release_cnt;
	refcount_t user_cnt;
	u64 destroy_cnt;
	struct page_pool_params_slow slow;
	struct {
		struct hlist_node list;
		u64 detach_time;
		u32 id;
	} user;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct page_pool_dump_cb {
	long unsigned int ifindex;
	u32 pp_id;
};

struct page_pool_params {
	union {
		struct {
			unsigned int order;
			unsigned int pool_size;
			int nid;
			struct device *dev;
			struct napi_struct *napi;
			enum dma_data_direction dma_dir;
			unsigned int max_len;
			unsigned int offset;
		};
		struct page_pool_params_fast fast;
	};
	union {
		struct {
			struct net_device *netdev;
			unsigned int queue_idx;
			unsigned int flags;
			void (*init_callback)(netmem_ref, void *);
			void *init_arg;
		};
		struct page_pool_params_slow slow;
	};
};

struct page_region {
	__u64 start;
	__u64 end;
	__u64 categories;
};

struct page_req_dsc {
	union {
		struct {
			u64 type: 8;
			u64 pasid_present: 1;
			u64 rsvd: 7;
			u64 rid: 16;
			u64 pasid: 20;
			u64 exe_req: 1;
			u64 pm_req: 1;
			u64 rsvd2: 10;
		};
		u64 qw_0;
	};
	union {
		struct {
			u64 rd_req: 1;
			u64 wr_req: 1;
			u64 lpig: 1;
			u64 prg_index: 9;
			u64 addr: 52;
		};
		u64 qw_1;
	};
	u64 qw_2;
	u64 qw_3;
};

struct page_vma_mapped_walk {
	long unsigned int pfn;
	long unsigned int nr_pages;
	long unsigned int pgoff;
	struct vm_area_struct *vma;
	long unsigned int address;
	pmd_t *pmd;
	pte_t *pte;
	spinlock_t *ptl;
	unsigned int flags;
};

struct pm_scan_arg {
	__u64 size;
	__u64 flags;
	__u64 start;
	__u64 end;
	__u64 walk_end;
	__u64 vec;
	__u64 vec_len;
	__u64 max_pages;
	__u64 category_inverted;
	__u64 category_mask;
	__u64 category_anyof_mask;
	__u64 return_mask;
};

struct pagemap_scan_private {
	struct pm_scan_arg arg;
	long unsigned int masks_of_interest;
	long unsigned int cur_vma_category;
	struct page_region *vec_buf;
	long unsigned int vec_buf_len;
	long unsigned int vec_buf_index;
	long unsigned int found_pages;
	struct page_region *vec_out;
};

struct pagemapread {
	int pos;
	int len;
	pagemap_entry_t *buffer;
	bool show_pfn;
};

struct pagerange_state {
	long unsigned int cur_pfn;
	int ram;
	int not_ram;
};

struct pages_devres {
	long unsigned int addr;
	unsigned int order;
};

struct pages_or_folios {
	union {
		struct page **pages;
		struct folio **folios;
		void **entries;
	};
	bool has_folios;
	long int nr_entries;
};

struct panel_bridge {
	struct drm_bridge bridge;
	struct drm_connector connector;
	struct drm_panel *panel;
	u32 connector_type;
};

struct parallel_data {
	struct padata_shell *ps;
	struct padata_list *reorder_list;
	struct padata_serial_queue *squeue;
	refcount_t refcnt;
	unsigned int seq_nr;
	unsigned int processed;
	int cpu;
	struct padata_cpumask cpumask;
	struct work_struct reorder_work;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	spinlock_t lock;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct thermal_genl_cpu_caps;

struct param {
	struct nlattr **attrs;
	struct sk_buff *msg;
	const char *name;
	int tz_id;
	int cdev_id;
	int trip_id;
	int trip_temp;
	int trip_type;
	int trip_hyst;
	int temp;
	int prev_temp;
	int direction;
	int cdev_state;
	int cdev_max_state;
	struct thermal_genl_cpu_caps *cpu_capabilities;
	int cpu_capabilities_count;
};

struct paravirt_callee_save {
	void *func;
};

struct pv_cpu_ops {
	void (*io_delay)(void);
};

struct pv_irq_ops {};

struct pv_mmu_ops {
	void (*flush_tlb_user)(void);
	void (*flush_tlb_kernel)(void);
	void (*flush_tlb_one_user)(long unsigned int);
	void (*flush_tlb_multi)(const struct cpumask *, const struct flush_tlb_info *);
	void (*tlb_remove_table)(struct mmu_gather *, void *);
	void (*exit_mmap)(struct mm_struct *);
	void (*notify_page_enc_status_changed)(long unsigned int, int, bool);
};

struct pv_lock_ops {
	void (*queued_spin_lock_slowpath)(struct qspinlock *, u32);
	struct paravirt_callee_save queued_spin_unlock;
	void (*wait)(u8 *, u8);
	void (*kick)(int);
	struct paravirt_callee_save vcpu_is_preempted;
};

struct paravirt_patch_template {
	struct pv_cpu_ops cpu;
	struct pv_irq_ops irq;
	struct pv_mmu_ops mmu;
	struct pv_lock_ops lock;
};

struct sync_semaphore {
	u32 semaphore;
	u8 unused[60];
};

struct parent_scratch {
	union guc_descs descs;
	struct sync_semaphore go;
	struct sync_semaphore join[9];
	u8 unused[1216];
	u32 wq[512];
};

struct partition_meta_info {
	char uuid[37];
	u8 volname[64];
};

struct parsed_partitions {
	struct gendisk *disk;
	char name[32];
	struct {
		sector_t from;
		sector_t size;
		int flags;
		bool has_info;
		struct partition_meta_info info;
	} *parts;
	int next;
	int limit;
	bool access_beyond_eod;
	char *pp_buf;
};

struct partial_cluster {
	ext4_fsblk_t pclu;
	ext4_lblk_t lblk;
	enum {
		initial = 0,
		tofree = 1,
		nofree = 2,
	} state;
};

struct partial_context {
	gfp_t flags;
	unsigned int orig_size;
	void *object;
};

struct partial_page {
	unsigned int offset;
	unsigned int len;
	long unsigned int private;
};

struct pasid_dir_entry {
	u64 val;
};

struct pasid_entry {
	u64 val[8];
};

struct pasid_table {
	void *table;
	int order;
	u32 max_pasid;
};

struct patch_digest {
	u32 patch_id;
	u8 sha256[32];
};

struct pause_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_pauseparam pauseparam;
	struct ethtool_pause_stats pausestat;
};

struct pause_req_info {
	struct ethnl_req_info base;
	enum ethtool_mac_stats_src src;
};

struct pbe {
	void *address;
	void *orig_address;
	struct pbe *next;
};

struct pcc_mbox_chan {
	struct mbox_chan *mchan;
	u64 shmem_base_addr;
	void *shmem;
	u64 shmem_size;
	u32 latency;
	u32 max_access_rate;
	u16 min_turnaround_time;
};

struct pcc_chan_reg {
	void *vaddr;
	struct acpi_generic_address *gas;
	u64 preserve_mask;
	u64 set_mask;
	u64 status_mask;
};

struct pcc_chan_info {
	struct pcc_mbox_chan chan;
	struct pcc_chan_reg db;
	struct pcc_chan_reg plat_irq_ack;
	struct pcc_chan_reg cmd_complete;
	struct pcc_chan_reg cmd_update;
	struct pcc_chan_reg error;
	int plat_irq;
	u8 type;
	unsigned int plat_irq_flags;
	bool chan_in_use;
};

struct pcc_data {
	struct pcc_mbox_chan *pcc_chan;
	void *pcc_comm_addr;
	struct completion done;
	struct mbox_client cl;
	struct acpi_pcc_info ctx;
};

struct pccard_io_map {
	u_char map;
	u_char flags;
	u_short speed;
	phys_addr_t start;
	phys_addr_t stop;
};

typedef struct pccard_io_map pccard_io_map;

struct pccard_mem_map {
	u_char map;
	u_char flags;
	u_short speed;
	phys_addr_t static_start;
	u_int card_start;
	struct resource *res;
};

typedef struct pccard_mem_map pccard_mem_map;

struct pcmcia_socket;

struct socket_state_t;

typedef struct socket_state_t socket_state_t;

struct pccard_operations {
	int (*init)(struct pcmcia_socket *);
	int (*suspend)(struct pcmcia_socket *);
	int (*get_status)(struct pcmcia_socket *, u_int *);
	int (*set_socket)(struct pcmcia_socket *, socket_state_t *);
	int (*set_io_map)(struct pcmcia_socket *, struct pccard_io_map *);
	int (*set_mem_map)(struct pcmcia_socket *, struct pccard_mem_map *);
};

struct pccard_resource_ops {
	int (*validate_mem)(struct pcmcia_socket *);
	int (*find_io)(struct pcmcia_socket *, unsigned int, unsigned int *, unsigned int, unsigned int, struct resource **);
	struct resource * (*find_mem)(long unsigned int, long unsigned int, long unsigned int, int, struct pcmcia_socket *);
	int (*init)(struct pcmcia_socket *);
	void (*exit)(struct pcmcia_socket *);
};

struct pci2phy_map {
	struct list_head list;
	int segment;
	int pbus_to_dieid[256];
};

struct pci_acs {
	u16 cap;
	u16 ctrl;
	u16 fw_ctrl;
};

struct pci_bits {
	unsigned int reg;
	unsigned int width;
	long unsigned int mask;
	long unsigned int val;
};

struct pci_bus {
	struct list_head node;
	struct pci_bus *parent;
	struct list_head children;
	struct list_head devices;
	struct pci_dev *self;
	struct list_head slots;
	struct resource *resource[4];
	struct list_head resources;
	struct resource busn_res;
	struct pci_ops *ops;
	void *sysdata;
	struct proc_dir_entry *procdir;
	unsigned char number;
	unsigned char primary;
	unsigned char max_bus_speed;
	unsigned char cur_bus_speed;
	char name[48];
	short unsigned int bridge_ctl;
	pci_bus_flags_t bus_flags;
	struct device *bridge;
	struct device dev;
	struct bin_attribute *legacy_io;
	struct bin_attribute *legacy_mem;
	unsigned int is_added: 1;
	unsigned int unsafe_warn: 1;
};

struct pci_bus_region {
	pci_bus_addr_t start;
	pci_bus_addr_t end;
};

struct pci_bus_resource {
	struct list_head list;
	struct resource *res;
};

struct pci_cap_saved_data {
	u16 cap_nr;
	bool cap_extended;
	unsigned int size;
	u32 data[0];
};

struct pci_cap_saved_state {
	struct hlist_node next;
	struct pci_cap_saved_data cap;
};

struct pci_check_idx_range {
	int start;
	int end;
};

struct pci_vpd {
	struct mutex lock;
	unsigned int len;
	u8 cap;
};

struct rcec_ea;

struct pcie_link_state;

struct pcie_bwctrl_data;

struct pci_sriov;

struct pci_dev {
	struct list_head bus_list;
	struct pci_bus *bus;
	struct pci_bus *subordinate;
	void *sysdata;
	struct proc_dir_entry *procent;
	struct pci_slot *slot;
	unsigned int devfn;
	short unsigned int vendor;
	short unsigned int device;
	short unsigned int subsystem_vendor;
	short unsigned int subsystem_device;
	unsigned int class;
	u8 revision;
	u8 hdr_type;
	struct rcec_ea *rcec_ea;
	struct pci_dev *rcec;
	u32 devcap;
	u8 pcie_cap;
	u8 msi_cap;
	u8 msix_cap;
	u8 pcie_mpss: 3;
	u8 rom_base_reg;
	u8 pin;
	u16 pcie_flags_reg;
	long unsigned int *dma_alias_mask;
	struct pci_driver *driver;
	u64 dma_mask;
	struct device_dma_parameters dma_parms;
	pci_power_t current_state;
	u8 pm_cap;
	unsigned int pme_support: 5;
	unsigned int pme_poll: 1;
	unsigned int pinned: 1;
	unsigned int config_rrs_sv: 1;
	unsigned int imm_ready: 1;
	unsigned int d1_support: 1;
	unsigned int d2_support: 1;
	unsigned int no_d1d2: 1;
	unsigned int no_d3cold: 1;
	unsigned int bridge_d3: 1;
	unsigned int d3cold_allowed: 1;
	unsigned int mmio_always_on: 1;
	unsigned int wakeup_prepared: 1;
	unsigned int skip_bus_pm: 1;
	unsigned int ignore_hotplug: 1;
	unsigned int hotplug_user_indicators: 1;
	unsigned int clear_retrain_link: 1;
	unsigned int d3hot_delay;
	unsigned int d3cold_delay;
	u16 l1ss;
	struct pcie_link_state *link_state;
	unsigned int ltr_path: 1;
	unsigned int pasid_no_tlp: 1;
	unsigned int eetlp_prefix_max: 3;
	pci_channel_state_t error_state;
	struct device dev;
	int cfg_size;
	unsigned int irq;
	struct resource resource[11];
	struct resource driver_exclusive_resource;
	bool match_driver;
	unsigned int transparent: 1;
	unsigned int io_window: 1;
	unsigned int pref_window: 1;
	unsigned int pref_64_window: 1;
	unsigned int multifunction: 1;
	unsigned int is_busmaster: 1;
	unsigned int no_msi: 1;
	unsigned int no_64bit_msi: 1;
	unsigned int block_cfg_access: 1;
	unsigned int broken_parity_status: 1;
	unsigned int irq_reroute_variant: 2;
	unsigned int msi_enabled: 1;
	unsigned int msix_enabled: 1;
	unsigned int ari_enabled: 1;
	unsigned int ats_enabled: 1;
	unsigned int pasid_enabled: 1;
	unsigned int pri_enabled: 1;
	unsigned int tph_enabled: 1;
	unsigned int is_managed: 1;
	unsigned int is_msi_managed: 1;
	unsigned int needs_freset: 1;
	unsigned int state_saved: 1;
	unsigned int is_physfn: 1;
	unsigned int is_virtfn: 1;
	unsigned int is_hotplug_bridge: 1;
	unsigned int shpc_managed: 1;
	unsigned int is_thunderbolt: 1;
	unsigned int untrusted: 1;
	unsigned int external_facing: 1;
	unsigned int broken_intx_masking: 1;
	unsigned int io_window_1k: 1;
	unsigned int irq_managed: 1;
	unsigned int non_compliant_bars: 1;
	unsigned int is_probed: 1;
	unsigned int link_active_reporting: 1;
	unsigned int no_vf_scan: 1;
	unsigned int no_command_memory: 1;
	unsigned int rom_bar_overlap: 1;
	unsigned int rom_attr_enabled: 1;
	pci_dev_flags_t dev_flags;
	atomic_t enable_cnt;
	spinlock_t pcie_cap_lock;
	u32 saved_config_space[16];
	struct hlist_head saved_cap_space;
	struct bin_attribute *res_attr[11];
	struct bin_attribute *res_attr_wc[11];
	void *msix_base;
	raw_spinlock_t msi_lock;
	struct pci_vpd vpd;
	struct pcie_bwctrl_data *link_bwctrl;
	union {
		struct pci_sriov *sriov;
		struct pci_dev *physfn;
	};
	u16 ats_cap;
	u8 ats_stu;
	u16 pri_cap;
	u32 pri_reqs_alloc;
	unsigned int pasid_required: 1;
	u16 pasid_cap;
	u16 pasid_features;
	u16 acs_cap;
	u8 supported_speeds;
	phys_addr_t rom;
	size_t romlen;
	const char *driver_override;
	long unsigned int priv_flags;
	u8 reset_methods[8];
};

struct pci_dev_acs_enabled {
	u16 vendor;
	u16 device;
	int (*acs_enabled)(struct pci_dev *, u16);
};

struct pci_dev_acs_ops {
	u16 vendor;
	u16 device;
	int (*enable_acs)(struct pci_dev *);
	int (*disable_acs_redir)(struct pci_dev *);
};

struct pci_dev_reset_methods {
	u16 vendor;
	u16 device;
	int (*reset)(struct pci_dev *, bool);
};

struct pci_dev_resource {
	struct list_head list;
	struct resource *res;
	struct pci_dev *dev;
	resource_size_t start;
	resource_size_t end;
	resource_size_t add_size;
	resource_size_t min_align;
	long unsigned int flags;
};

struct pci_device_id {
	__u32 vendor;
	__u32 device;
	__u32 subvendor;
	__u32 subdevice;
	__u32 class;
	__u32 class_mask;
	kernel_ulong_t driver_data;
	__u32 override_only;
};

struct pci_domain_busn_res {
	struct list_head list;
	struct resource res;
	int domain_nr;
};

struct pci_dynids {
	spinlock_t lock;
	struct list_head list;
};

struct pci_error_handlers;

struct pci_driver {
	const char *name;
	const struct pci_device_id *id_table;
	int (*probe)(struct pci_dev *, const struct pci_device_id *);
	void (*remove)(struct pci_dev *);
	int (*suspend)(struct pci_dev *, pm_message_t);
	int (*resume)(struct pci_dev *);
	void (*shutdown)(struct pci_dev *);
	int (*sriov_configure)(struct pci_dev *, int);
	int (*sriov_set_msix_vec_count)(struct pci_dev *, int);
	u32 (*sriov_get_vf_total_msix)(struct pci_dev *);
	const struct pci_error_handlers *err_handler;
	const struct attribute_group **groups;
	const struct attribute_group **dev_groups;
	struct device_driver driver;
	struct pci_dynids dynids;
	bool driver_managed_dma;
};

struct pci_dynid {
	struct list_head node;
	struct pci_device_id id;
};

struct pci_error_handlers {
	pci_ers_result_t (*error_detected)(struct pci_dev *, pci_channel_state_t);
	pci_ers_result_t (*mmio_enabled)(struct pci_dev *);
	pci_ers_result_t (*slot_reset)(struct pci_dev *);
	void (*reset_prepare)(struct pci_dev *);
	void (*reset_done)(struct pci_dev *);
	void (*resume)(struct pci_dev *);
	void (*cor_error_detected)(struct pci_dev *);
};

struct pci_extra_dev {
	struct pci_dev *dev[4];
};

struct pci_filp_private {
	enum pci_mmap_state mmap_state;
	int write_combine;
};

struct pci_fixup {
	u16 vendor;
	u16 device;
	u32 class;
	unsigned int class_shift;
	int hook_offset;
};

struct pci_host_bridge {
	struct device dev;
	struct pci_bus *bus;
	struct pci_ops *ops;
	struct pci_ops *child_ops;
	void *sysdata;
	int busnr;
	int domain_nr;
	struct list_head windows;
	struct list_head dma_ranges;
	u8 (*swizzle_irq)(struct pci_dev *, u8 *);
	int (*map_irq)(const struct pci_dev *, u8, u8);
	void (*release_fn)(struct pci_host_bridge *);
	int (*enable_device)(struct pci_host_bridge *, struct pci_dev *);
	void (*disable_device)(struct pci_host_bridge *, struct pci_dev *);
	void *release_data;
	unsigned int ignore_reset_delay: 1;
	unsigned int no_ext_tags: 1;
	unsigned int no_inc_mrrs: 1;
	unsigned int native_aer: 1;
	unsigned int native_pcie_hotplug: 1;
	unsigned int native_shpc_hotplug: 1;
	unsigned int native_pme: 1;
	unsigned int native_ltr: 1;
	unsigned int native_dpc: 1;
	unsigned int native_cxl_error: 1;
	unsigned int preserve_config: 1;
	unsigned int size_windows: 1;
	unsigned int msi_domain: 1;
	resource_size_t (*align_resource)(struct pci_dev *, const struct resource *, resource_size_t, resource_size_t, resource_size_t);
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long unsigned int private[0];
};

struct pci_hostbridge_probe {
	u32 bus;
	u32 slot;
	u32 vendor;
	u32 device;
};

struct pci_mmcfg_hostbridge_probe {
	u32 bus;
	u32 devfn;
	u32 vendor;
	u32 device;
	const char * (*probe)(void);
};

struct pci_mmcfg_region {
	struct list_head list;
	struct resource res;
	u64 address;
	char *virt;
	u16 segment;
	u8 start_bus;
	u8 end_bus;
	char name[30];
};

struct pci_ops {
	int (*add_bus)(struct pci_bus *);
	void (*remove_bus)(struct pci_bus *);
	void * (*map_bus)(struct pci_bus *, unsigned int, int);
	int (*read)(struct pci_bus *, unsigned int, int, int, u32 *);
	int (*write)(struct pci_bus *, unsigned int, int, int, u32);
};

struct pci_osc_bit_struct {
	u32 bit;
	char *desc;
};

struct pci_p2pdma_map_state {
	struct dev_pagemap *pgmap;
	int map;
	u64 bus_off;
};

struct pci_pme_device {
	struct list_head list;
	struct pci_dev *dev;
};

struct pci_raw_ops {
	int (*read)(unsigned int, unsigned int, unsigned int, int, int, u32 *);
	int (*write)(unsigned int, unsigned int, unsigned int, int, int, u32);
};

struct pci_reset_fn_method {
	int (*reset_fn)(struct pci_dev *, bool);
	char *name;
};

struct pci_root_info {
	struct list_head list;
	char name[12];
	struct list_head resources;
	struct resource busn;
	int node;
	int link;
};

struct pci_sysdata {
	int domain;
	int node;
	struct acpi_device *companion;
	void *iommu;
	void *fwnode;
};

struct pci_root_info___2 {
	struct acpi_pci_root_info common;
	struct pci_sysdata sd;
	bool mcfg_added;
	u8 start_bus;
	u8 end_bus;
};

struct pci_root_res {
	struct list_head list;
	struct resource res;
};

struct pci_saved_state {
	u32 config_space[16];
	struct pci_cap_saved_data cap[0];
};

struct serial_private;

struct pciserial_board;

struct pci_serial_quirk {
	u32 vendor;
	u32 device;
	u32 subvendor;
	u32 subdevice;
	int (*probe)(struct pci_dev *);
	int (*init)(struct pci_dev *);
	int (*setup)(struct serial_private *, const struct pciserial_board *, struct uart_8250_port *, int);
	void (*exit)(struct pci_dev *);
};

struct setup_data {
	__u64 next;
	__u32 type;
	__u32 len;
	__u8 data[0];
};

struct pci_setup_rom {
	struct setup_data data;
	uint16_t vendor;
	uint16_t devid;
	uint64_t pcilen;
	long unsigned int segment;
	long unsigned int bus;
	long unsigned int device;
	long unsigned int function;
	uint8_t romdata[0];
};

struct pci_slot {
	struct pci_bus *bus;
	struct list_head list;
	struct hotplug_slot *hotplug;
	unsigned char number;
	struct kobject kobj;
};

struct pci_slot_attribute {
	struct attribute attr;
	ssize_t (*show)(struct pci_slot *, char *);
	ssize_t (*store)(struct pci_slot *, const char *, size_t);
};

struct pci_sriov {
	int pos;
	int nres;
	u32 cap;
	u16 ctrl;
	u16 total_VFs;
	u16 initial_VFs;
	u16 num_VFs;
	u16 offset;
	u16 stride;
	u16 vf_device;
	u32 pgsz;
	u8 link;
	u8 max_VF_buses;
	u16 driver_max_VFs;
	struct pci_dev *dev;
	struct pci_dev *self;
	u32 class;
	u8 hdr_type;
	u16 subsystem_vendor;
	u16 subsystem_device;
	resource_size_t barsz[6];
	bool drivers_autoprobe;
};

struct pcibios_fwaddrmap {
	struct list_head list;
	struct pci_dev *dev;
	resource_size_t fw_addr[11];
};

struct pcie_bwctrl_data {
	struct mutex set_speed_mutex;
	atomic_t lbms_count;
	struct thermal_cooling_device *cdev;
};

struct pcie_device {
	int irq;
	struct pci_dev *port;
	u32 service;
	void *priv_data;
	struct device device;
};

struct pcie_link_state {
	struct pci_dev *pdev;
	struct pci_dev *downstream;
	struct pcie_link_state *root;
	struct pcie_link_state *parent;
	struct list_head sibling;
	u32 aspm_support: 7;
	u32 aspm_enabled: 7;
	u32 aspm_capable: 7;
	u32 aspm_default: 7;
	int: 4;
	u32 aspm_disable: 7;
	u32 clkpm_capable: 1;
	u32 clkpm_enabled: 1;
	u32 clkpm_default: 1;
	u32 clkpm_disable: 1;
};

struct pcie_pme_service_data {
	spinlock_t lock;
	struct pcie_device *srv;
	struct work_struct work;
	bool noirq;
};

struct pcie_port_service_driver {
	const char *name;
	int (*probe)(struct pcie_device *);
	void (*remove)(struct pcie_device *);
	int (*suspend)(struct pcie_device *);
	int (*resume_noirq)(struct pcie_device *);
	int (*resume)(struct pcie_device *);
	int (*runtime_suspend)(struct pcie_device *);
	int (*runtime_resume)(struct pcie_device *);
	int (*slot_reset)(struct pcie_device *);
	int port_type;
	u32 service;
	struct device_driver driver;
};

struct pcim_addr_devres {
	enum pcim_addr_devres_type type;
	void *baseaddr;
	long unsigned int offset;
	long unsigned int len;
	int bar;
};

struct pcim_intx_devres {
	int orig_intx;
};

struct pcim_iomap_devres {
	void *table[6];
};

struct pciserial_board {
	unsigned int flags;
	unsigned int num_ports;
	unsigned int base_baud;
	unsigned int uart_offset;
	unsigned int reg_shift;
	unsigned int first_offset;
};

struct pcm_format_data {
	unsigned char width;
	unsigned char phys;
	signed char le;
	signed char signd;
	unsigned char silence[8];
};

struct resource_map;

struct pcmcia_align_data {
	long unsigned int mask;
	long unsigned int offset;
	struct resource_map *map;
};

struct pcmcia_callback {
	struct module *owner;
	int (*add)(struct pcmcia_socket *);
	int (*remove)(struct pcmcia_socket *);
	void (*requery)(struct pcmcia_socket *);
	int (*validate)(struct pcmcia_socket *, unsigned int *);
	int (*suspend)(struct pcmcia_socket *);
	int (*early_resume)(struct pcmcia_socket *);
	int (*resume)(struct pcmcia_socket *);
};

struct pcmcia_device;

struct pcmcia_cfg_mem {
	struct pcmcia_device *p_dev;
	int (*conf_check)(struct pcmcia_device *, void *);
	void *priv_data;
	cisparse_t parse;
	cistpl_cftable_entry_t dflt;
};

struct pcmcia_device {
	struct pcmcia_socket *socket;
	char *devname;
	u8 device_no;
	u8 func;
	struct config_t *function_config;
	struct list_head socket_device_list;
	unsigned int irq;
	struct resource *resource[6];
	resource_size_t card_addr;
	unsigned int vpp;
	unsigned int config_flags;
	unsigned int config_base;
	unsigned int config_index;
	unsigned int config_regs;
	unsigned int io_lines;
	u16 suspended: 1;
	u16 _irq: 1;
	u16 _io: 1;
	u16 _win: 4;
	u16 _locked: 1;
	u16 allow_func_id_match: 1;
	u16 has_manf_id: 1;
	u16 has_card_id: 1;
	u16 has_func_id: 1;
	u16 reserved: 4;
	u8 func_id;
	u16 manf_id;
	u16 card_id;
	char *prod_id[4];
	u64 dma_mask;
	struct device dev;
	void *priv;
	unsigned int open;
};

struct pcmcia_device_id {
	__u16 match_flags;
	__u16 manf_id;
	__u16 card_id;
	__u8 func_id;
	__u8 function;
	__u8 device_no;
	__u32 prod_id_hash[4];
	const char *prod_id[4];
	kernel_ulong_t driver_info;
	char *cisfile;
};

struct pcmcia_dynids {
	struct mutex lock;
	struct list_head list;
};

struct pcmcia_driver {
	const char *name;
	int (*probe)(struct pcmcia_device *);
	void (*remove)(struct pcmcia_device *);
	int (*suspend)(struct pcmcia_device *);
	int (*resume)(struct pcmcia_device *);
	struct module *owner;
	const struct pcmcia_device_id *id_table;
	struct device_driver drv;
	struct pcmcia_dynids dynids;
};

struct pcmcia_dynid {
	struct list_head node;
	struct pcmcia_device_id id;
};

struct pcmcia_loop_get {
	size_t len;
	cisdata_t **buf;
};

struct tuple_t;

typedef struct tuple_t tuple_t;

struct pcmcia_loop_mem {
	struct pcmcia_device *p_dev;
	void *priv_data;
	int (*loop_tuple)(struct pcmcia_device *, tuple_t *, void *);
};

struct socket_state_t {
	u_int flags;
	u_int csc_mask;
	u_char Vcc;
	u_char Vpp;
	u_char io_irq;
};

struct pcmcia_socket {
	struct module *owner;
	socket_state_t socket;
	u_int state;
	u_int suspended_state;
	u_short functions;
	u_short lock_count;
	pccard_mem_map cis_mem;
	void *cis_virt;
	io_window_t io[2];
	pccard_mem_map win[4];
	struct list_head cis_cache;
	size_t fake_cis_len;
	u8 *fake_cis;
	struct list_head socket_list;
	struct completion socket_released;
	unsigned int sock;
	u_int features;
	u_int irq_mask;
	u_int map_size;
	u_int io_offset;
	u_int pci_irq;
	struct pci_dev *cb_dev;
	u8 resource_setup_done;
	struct pccard_operations *ops;
	struct pccard_resource_ops *resource_ops;
	void *resource_data;
	void (*zoom_video)(struct pcmcia_socket *, int);
	int (*power_hook)(struct pcmcia_socket *, int);
	void (*tune_bridge)(struct pcmcia_socket *, struct pci_bus *);
	struct task_struct *thread;
	struct completion thread_done;
	unsigned int thread_events;
	unsigned int sysfs_events;
	struct mutex skt_mutex;
	struct mutex ops_mutex;
	spinlock_t thread_lock;
	struct pcmcia_callback *callback;
	struct list_head devices_list;
	u8 device_count;
	u8 pcmcia_pfc;
	atomic_t present;
	unsigned int pcmcia_irq;
	struct device dev;
	void *driver_data;
	int resume_status;
};

struct pcpu_group_info {
	int nr_units;
	long unsigned int base_offset;
	unsigned int *cpu_map;
};

struct pcpu_alloc_info {
	size_t static_size;
	size_t reserved_size;
	size_t dyn_size;
	size_t unit_size;
	size_t atom_size;
	size_t alloc_size;
	size_t __ai_size;
	int nr_groups;
	struct pcpu_group_info groups[0];
};

struct pcpu_block_md {
	int scan_hint;
	int scan_hint_start;
	int contig_hint;
	int contig_hint_start;
	int left_free;
	int right_free;
	int first_free;
	int nr_bits;
};

struct pcpu_chunk {
	struct list_head list;
	int free_bytes;
	struct pcpu_block_md chunk_md;
	long unsigned int *bound_map;
	void *base_addr;
	long unsigned int *alloc_map;
	struct pcpu_block_md *md_blocks;
	void *data;
	bool immutable;
	bool isolated;
	int start_offset;
	int end_offset;
	int nr_pages;
	int nr_populated;
	int nr_empty_pop_pages;
	long unsigned int populated[0];
	long: 64;
};

struct pcpu_dstats {
	u64_stats_t rx_packets;
	u64_stats_t rx_bytes;
	u64_stats_t tx_packets;
	u64_stats_t tx_bytes;
	u64_stats_t rx_drops;
	u64_stats_t tx_drops;
	struct u64_stats_sync syncp;
	long: 64;
	long: 64;
};

struct pcpu_gen_cookie {
	local_t nesting;
	u64 last;
};

struct pcpu_hot {
	union {
		struct {
			struct task_struct *current_task;
			int preempt_count;
			int cpu_number;
			u64 call_depth;
			long unsigned int top_of_stack;
			void *hardirq_stack_ptr;
			u16 softirq_pending;
			bool hardirq_stack_inuse;
		};
		u8 pad[64];
	};
};

struct pcpu_lstats {
	u64_stats_t packets;
	u64_stats_t bytes;
	struct u64_stats_sync syncp;
};

struct pcpu_sw_netstats {
	u64_stats_t rx_packets;
	u64_stats_t rx_bytes;
	u64_stats_t tx_packets;
	u64_stats_t tx_bytes;
	struct u64_stats_sync syncp;
};

struct pde_opener {
	struct list_head lh;
	struct file *file;
	bool closing;
	struct completion *c;
};

struct pdev_archdata {};

struct pdom_dev_data {
	struct iommu_dev_data *dev_data;
	ioasid_t pasid;
	struct list_head list;
};

struct pdom_iommu_info {
	struct amd_iommu *iommu;
	u32 refcnt;
};

struct pebs_basic {
	u64 format_group: 32;
	u64 retire_latency: 16;
	u64 format_size: 16;
	u64 ip;
	u64 applicable_counters;
	u64 tsc;
};

struct pebs_gprs {
	u64 flags;
	u64 ip;
	u64 ax;
	u64 cx;
	u64 dx;
	u64 bx;
	u64 sp;
	u64 bp;
	u64 si;
	u64 di;
	u64 r8;
	u64 r9;
	u64 r10;
	u64 r11;
	u64 r12;
	u64 r13;
	u64 r14;
	u64 r15;
};

struct pebs_meminfo {
	u64 address;
	u64 aux;
	union {
		u64 mem_latency;
		struct {
			u64 instr_latency: 16;
			u64 pad2: 16;
			u64 cache_latency: 16;
			u64 pad3: 16;
		};
	};
	u64 tsx_tuning;
};

struct pebs_record_core {
	u64 flags;
	u64 ip;
	u64 ax;
	u64 bx;
	u64 cx;
	u64 dx;
	u64 si;
	u64 di;
	u64 bp;
	u64 sp;
	u64 r8;
	u64 r9;
	u64 r10;
	u64 r11;
	u64 r12;
	u64 r13;
	u64 r14;
	u64 r15;
};

struct pebs_record_nhm {
	u64 flags;
	u64 ip;
	u64 ax;
	u64 bx;
	u64 cx;
	u64 dx;
	u64 si;
	u64 di;
	u64 bp;
	u64 sp;
	u64 r8;
	u64 r9;
	u64 r10;
	u64 r11;
	u64 r12;
	u64 r13;
	u64 r14;
	u64 r15;
	u64 status;
	u64 dla;
	u64 dse;
	u64 lat;
};

struct pebs_record_skl {
	u64 flags;
	u64 ip;
	u64 ax;
	u64 bx;
	u64 cx;
	u64 dx;
	u64 si;
	u64 di;
	u64 bp;
	u64 sp;
	u64 r8;
	u64 r9;
	u64 r10;
	u64 r11;
	u64 r12;
	u64 r13;
	u64 r14;
	u64 r15;
	u64 status;
	u64 dla;
	u64 dse;
	u64 lat;
	u64 real_ip;
	u64 tsx_tuning;
	u64 tsc;
};

struct pebs_xmm {
	u64 xmm[32];
};

struct pending_reservation {
	struct rb_node rb_node;
	ext4_lblk_t lclu;
};

struct per_cpu_nodestat {
	s8 stat_threshold;
	s8 vm_node_stat_diff[46];
};

struct per_cpu_pages {
	spinlock_t lock;
	int count;
	int high;
	int high_min;
	int high_max;
	int batch;
	u8 flags;
	u8 alloc_factor;
	u8 expire;
	short int free_count;
	struct list_head lists[12];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct per_cpu_zonestat {
	s8 vm_stat_diff[10];
	s8 stat_threshold;
	long unsigned int vm_numa_event[6];
};

struct percpu_cluster {
	local_lock_t lock;
	unsigned int next[1];
};

struct percpu_free_defer {
	struct callback_head rcu;
	void *ptr;
};

typedef void percpu_ref_func_t(struct percpu_ref *);

struct percpu_ref_data {
	atomic_long_t count;
	percpu_ref_func_t *release;
	percpu_ref_func_t *confirm_switch;
	bool force_atomic: 1;
	bool allow_reinit: 1;
	struct callback_head rcu;
	struct percpu_ref *ref;
};

struct perf_addr_filter {
	struct list_head entry;
	struct path path;
	long unsigned int offset;
	long unsigned int size;
	enum perf_addr_filter_action_t action;
};

struct perf_addr_filter_range {
	long unsigned int start;
	long unsigned int size;
};

struct perf_addr_filters_head {
	struct list_head list;
	raw_spinlock_t lock;
	unsigned int nr_file_filters;
};

struct perf_amd_iommu {
	struct list_head list;
	struct pmu pmu;
	struct amd_iommu *iommu;
	char name[16];
	u8 max_banks;
	u8 max_counters;
	u64 cntr_assign_mask;
	raw_spinlock_t lock;
};

struct perf_event_header {
	__u32 type;
	__u16 misc;
	__u16 size;
};

struct perf_aux_event {
	struct perf_event_header header;
	u64 hw_id;
};

struct perf_aux_event___2 {
	struct perf_event_header header;
	u32 pid;
	u32 tid;
};

struct perf_aux_event___3 {
	struct perf_event_header header;
	u64 offset;
	u64 size;
	u64 flags;
};

struct perf_bpf_event {
	struct bpf_prog *prog;
	struct {
		struct perf_event_header header;
		u16 type;
		u16 flags;
		u32 id;
		u8 tag[8];
	} event_id;
};

struct perf_event_mmap_page;

struct perf_buffer {
	refcount_t refcount;
	struct callback_head callback_head;
	int nr_pages;
	int overwrite;
	int paused;
	atomic_t poll;
	local_t head;
	unsigned int nest;
	local_t events;
	local_t wakeup;
	local_t lost;
	long int watermark;
	long int aux_watermark;
	spinlock_t event_lock;
	struct list_head event_list;
	atomic_t mmap_count;
	long unsigned int mmap_locked;
	struct user_struct *mmap_user;
	struct mutex aux_mutex;
	long int aux_head;
	unsigned int aux_nest;
	long int aux_wakeup;
	long unsigned int aux_pgoff;
	int aux_nr_pages;
	int aux_overwrite;
	atomic_t aux_mmap_count;
	long unsigned int aux_mmap_locked;
	void (*free_aux)(void *);
	refcount_t aux_refcount;
	int aux_in_sampling;
	int aux_in_pause_resume;
	void **aux_pages;
	void *aux_priv;
	struct perf_event_mmap_page *user_page;
	void *data_pages[0];
};

struct perf_callchain_entry {
	__u64 nr;
	__u64 ip[0];
};

struct perf_callchain_entry_ctx {
	struct perf_callchain_entry *entry;
	u32 max_stack;
	u32 nr;
	short int contexts;
	bool contexts_maxed;
};

union perf_capabilities {
	struct {
		u64 lbr_format: 6;
		u64 pebs_trap: 1;
		u64 pebs_arch_reg: 1;
		u64 pebs_format: 4;
		u64 smm_freeze: 1;
		u64 full_width_write: 1;
		u64 pebs_baseline: 1;
		u64 perf_metrics: 1;
		u64 pebs_output_pt_available: 1;
		u64 pebs_timing_info: 1;
		u64 anythread_deprecated: 1;
		u64 rdpmc_metrics_clear: 1;
	};
	u64 capabilities;
};

struct perf_cgroup_info;

struct perf_cgroup {
	struct cgroup_subsys_state css;
	struct perf_cgroup_info *info;
};

struct perf_cgroup_event {
	char *path;
	int path_size;
	struct {
		struct perf_event_header header;
		u64 id;
		char path[0];
	} event_id;
};

struct perf_cgroup_info {
	u64 time;
	u64 timestamp;
	u64 timeoffset;
	int active;
};

struct perf_comm_event {
	struct task_struct *task;
	char *comm;
	int comm_size;
	struct {
		struct perf_event_header header;
		u32 pid;
		u32 tid;
	} event_id;
};

struct perf_event_groups {
	struct rb_root tree;
	u64 index;
};

struct perf_event_context {
	raw_spinlock_t lock;
	struct mutex mutex;
	struct list_head pmu_ctx_list;
	struct perf_event_groups pinned_groups;
	struct perf_event_groups flexible_groups;
	struct list_head event_list;
	int nr_events;
	int nr_user;
	int is_active;
	int nr_task_data;
	int nr_stat;
	int nr_freq;
	int rotate_disable;
	refcount_t refcount;
	struct task_struct *task;
	u64 time;
	u64 timestamp;
	u64 timeoffset;
	struct perf_event_context *parent_ctx;
	u64 parent_gen;
	u64 generation;
	int pin_count;
	int nr_cgroups;
	struct callback_head callback_head;
	local_t nr_no_switch_fast;
};

struct perf_cpu_context {
	struct perf_event_context ctx;
	struct perf_event_context *task_ctx;
	int online;
	struct perf_cgroup *cgrp;
	int heap_size;
	struct perf_event **heap;
	struct perf_event *heap_default[2];
};

struct perf_event_pmu_context {
	struct pmu *pmu;
	struct perf_event_context *ctx;
	struct list_head pmu_ctx_entry;
	struct list_head pinned_active;
	struct list_head flexible_active;
	unsigned int embedded: 1;
	unsigned int nr_events;
	unsigned int nr_cgroups;
	unsigned int nr_freq;
	atomic_t refcount;
	struct callback_head callback_head;
	void *task_ctx_data;
	int rotate_necessary;
};

struct perf_cpu_pmu_context {
	struct perf_event_pmu_context epc;
	struct perf_event_pmu_context *task_epc;
	struct list_head sched_cb_entry;
	int sched_cb_usage;
	int active_oncpu;
	int exclusive;
	raw_spinlock_t hrtimer_lock;
	struct hrtimer hrtimer;
	ktime_t hrtimer_interval;
	unsigned int hrtimer_active;
};

struct perf_domain {
	struct em_perf_domain *em_pd;
	struct perf_domain *next;
	struct callback_head rcu;
};

struct perf_event_attr {
	__u32 type;
	__u32 size;
	__u64 config;
	union {
		__u64 sample_period;
		__u64 sample_freq;
	};
	__u64 sample_type;
	__u64 read_format;
	__u64 disabled: 1;
	__u64 inherit: 1;
	__u64 pinned: 1;
	__u64 exclusive: 1;
	__u64 exclude_user: 1;
	__u64 exclude_kernel: 1;
	__u64 exclude_hv: 1;
	__u64 exclude_idle: 1;
	__u64 mmap: 1;
	__u64 comm: 1;
	__u64 freq: 1;
	__u64 inherit_stat: 1;
	__u64 enable_on_exec: 1;
	__u64 task: 1;
	__u64 watermark: 1;
	__u64 precise_ip: 2;
	__u64 mmap_data: 1;
	__u64 sample_id_all: 1;
	__u64 exclude_host: 1;
	__u64 exclude_guest: 1;
	__u64 exclude_callchain_kernel: 1;
	__u64 exclude_callchain_user: 1;
	__u64 mmap2: 1;
	__u64 comm_exec: 1;
	__u64 use_clockid: 1;
	__u64 context_switch: 1;
	__u64 write_backward: 1;
	__u64 namespaces: 1;
	__u64 ksymbol: 1;
	__u64 bpf_event: 1;
	__u64 aux_output: 1;
	__u64 cgroup: 1;
	__u64 text_poke: 1;
	__u64 build_id: 1;
	__u64 inherit_thread: 1;
	__u64 remove_on_exec: 1;
	__u64 sigtrap: 1;
	__u64 __reserved_1: 26;
	union {
		__u32 wakeup_events;
		__u32 wakeup_watermark;
	};
	__u32 bp_type;
	union {
		__u64 bp_addr;
		__u64 kprobe_func;
		__u64 uprobe_path;
		__u64 config1;
	};
	union {
		__u64 bp_len;
		__u64 kprobe_addr;
		__u64 probe_offset;
		__u64 config2;
	};
	__u64 branch_sample_type;
	__u64 sample_regs_user;
	__u32 sample_stack_user;
	__s32 clockid;
	__u64 sample_regs_intr;
	__u32 aux_watermark;
	__u16 sample_max_stack;
	__u16 __reserved_2;
	__u32 aux_sample_size;
	union {
		__u32 aux_action;
		struct {
			__u32 aux_start_paused: 1;
			__u32 aux_pause: 1;
			__u32 aux_resume: 1;
			__u32 __reserved_3: 29;
		};
	};
	__u64 sig_data;
	__u64 config3;
};

typedef void (*perf_overflow_handler_t)(struct perf_event *, struct perf_sample_data *, struct pt_regs *);

struct perf_event {
	struct list_head event_entry;
	struct list_head sibling_list;
	struct list_head active_list;
	struct rb_node group_node;
	u64 group_index;
	struct list_head migrate_entry;
	struct hlist_node hlist_entry;
	struct list_head active_entry;
	int nr_siblings;
	int event_caps;
	int group_caps;
	unsigned int group_generation;
	struct perf_event *group_leader;
	struct pmu *pmu;
	void *pmu_private;
	enum perf_event_state state;
	unsigned int attach_state;
	local64_t count;
	atomic64_t child_count;
	u64 total_time_enabled;
	u64 total_time_running;
	u64 tstamp;
	struct perf_event_attr attr;
	u16 header_size;
	u16 id_header_size;
	u16 read_size;
	struct hw_perf_event hw;
	struct perf_event_context *ctx;
	struct perf_event_pmu_context *pmu_ctx;
	atomic_long_t refcount;
	atomic64_t child_total_time_enabled;
	atomic64_t child_total_time_running;
	struct mutex child_mutex;
	struct list_head child_list;
	struct perf_event *parent;
	int oncpu;
	int cpu;
	struct list_head owner_entry;
	struct task_struct *owner;
	struct mutex mmap_mutex;
	atomic_t mmap_count;
	struct perf_buffer *rb;
	struct list_head rb_entry;
	long unsigned int rcu_batches;
	int rcu_pending;
	wait_queue_head_t waitq;
	struct fasync_struct *fasync;
	unsigned int pending_wakeup;
	unsigned int pending_kill;
	unsigned int pending_disable;
	long unsigned int pending_addr;
	struct irq_work pending_irq;
	struct irq_work pending_disable_irq;
	struct callback_head pending_task;
	unsigned int pending_work;
	struct rcuwait pending_work_wait;
	atomic_t event_limit;
	struct perf_addr_filters_head addr_filters;
	struct perf_addr_filter_range *addr_filter_ranges;
	long unsigned int addr_filters_gen;
	struct perf_event *aux_event;
	void (*destroy)(struct perf_event *);
	struct callback_head callback_head;
	struct pid_namespace *ns;
	u64 id;
	atomic64_t lost_samples;
	u64 (*clock)(void);
	perf_overflow_handler_t overflow_handler;
	void *overflow_handler_context;
	struct bpf_prog *prog;
	u64 bpf_cookie;
	struct trace_event_call *tp_event;
	struct event_filter *filter;
	struct perf_cgroup *cgrp;
	void *security;
	struct list_head sb_list;
	__u32 orig_type;
};

struct perf_event_min_heap {
	size_t nr;
	size_t size;
	struct perf_event **data;
	struct perf_event *preallocated[0];
};

struct perf_event_mmap_page {
	__u32 version;
	__u32 compat_version;
	__u32 lock;
	__u32 index;
	__s64 offset;
	__u64 time_enabled;
	__u64 time_running;
	union {
		__u64 capabilities;
		struct {
			__u64 cap_bit0: 1;
			__u64 cap_bit0_is_deprecated: 1;
			__u64 cap_user_rdpmc: 1;
			__u64 cap_user_time: 1;
			__u64 cap_user_time_zero: 1;
			__u64 cap_user_time_short: 1;
			__u64 cap_____res: 58;
		};
	};
	__u16 pmc_width;
	__u16 time_shift;
	__u32 time_mult;
	__u64 time_offset;
	__u64 time_zero;
	__u32 size;
	__u32 __reserved_1;
	__u64 time_cycles;
	__u64 time_mask;
	__u8 __reserved[928];
	__u64 data_head;
	__u64 data_tail;
	__u64 data_offset;
	__u64 data_size;
	__u64 aux_head;
	__u64 aux_tail;
	__u64 aux_offset;
	__u64 aux_size;
};

struct perf_event_query_bpf {
	__u32 ids_len;
	__u32 prog_cnt;
	__u32 ids[0];
};

struct perf_event_security_struct {
	u32 sid;
};

struct perf_ibs {
	struct pmu pmu;
	unsigned int msr;
	u64 config_mask;
	u64 cnt_mask;
	u64 enable_mask;
	u64 valid_mask;
	u64 max_period;
	long unsigned int offset_mask[1];
	int offset_max;
	unsigned int fetch_count_reset_broken: 1;
	unsigned int fetch_ignore_if_zero_rip: 1;
	struct cpu_perf_ibs *pcpu;
	u64 (*get_count)(u64);
};

struct perf_ibs_data {
	u32 size;
	union {
		u32 data[0];
		u32 caps;
	};
	u64 regs[8];
};

struct perf_ksymbol_event {
	const char *name;
	int name_len;
	struct {
		struct perf_event_header header;
		u64 addr;
		u32 len;
		u16 ksym_type;
		u16 flags;
	} event_id;
};

struct perf_mmap_event {
	struct vm_area_struct *vma;
	const char *file_name;
	int file_size;
	int maj;
	int min;
	u64 ino;
	u64 ino_generation;
	u32 prot;
	u32 flags;
	u8 build_id[20];
	u32 build_id_size;
	struct {
		struct perf_event_header header;
		u32 pid;
		u32 tid;
		u64 start;
		u64 len;
		u64 pgoff;
	} event_id;
};

struct perf_msr {
	u64 msr;
	struct attribute_group *grp;
	bool (*test)(int, void *);
	bool no_check;
	u64 mask;
};

struct perf_ns_link_info {
	__u64 dev;
	__u64 ino;
};

struct perf_namespaces_event {
	struct task_struct *task;
	struct {
		struct perf_event_header header;
		u32 pid;
		u32 tid;
		u64 nr_namespaces;
		struct perf_ns_link_info link_info[7];
	} event_id;
};

struct perf_open_properties {
	u32 sample_flags;
	u64 single_context: 1;
	u64 hold_preemption: 1;
	u64 ctx_handle;
	int metrics_set;
	int oa_format;
	bool oa_periodic;
	int oa_period_exponent;
	struct intel_engine_cs *engine;
	bool has_sseu;
	struct intel_sseu sseu;
	u64 poll_oa_period;
};

struct perf_pmu_events_attr {
	struct device_attribute attr;
	u64 id;
	const char *event_str;
};

struct perf_pmu_events_ht_attr {
	struct device_attribute attr;
	u64 id;
	const char *event_str_ht;
	const char *event_str_noht;
};

struct perf_pmu_events_hybrid_attr {
	struct device_attribute attr;
	u64 id;
	const char *event_str;
	u64 pmu_type;
};

struct perf_pmu_format_hybrid_attr {
	struct device_attribute attr;
	u64 pmu_type;
};

typedef long unsigned int (*perf_copy_f)(void *, const void *, long unsigned int, long unsigned int);

struct perf_raw_frag {
	union {
		struct perf_raw_frag *next;
		long unsigned int pad;
	};
	perf_copy_f copy;
	void *data;
	u32 size;
} __attribute__((packed));

struct perf_raw_record {
	struct perf_raw_frag frag;
	u32 size;
};

struct perf_read_data {
	struct perf_event *event;
	bool group;
	int ret;
};

struct perf_read_event {
	struct perf_event_header header;
	u32 pid;
	u32 tid;
};

struct sched_state {
	int weight;
	int event;
	int counter;
	int unassigned;
	int nr_gp;
	u64 used;
};

struct perf_sched {
	int max_weight;
	int max_events;
	int max_gp;
	int saved_states;
	struct event_constraint **constraints;
	struct sched_state state;
	struct sched_state saved[2];
};

struct perf_switch_event {
	struct task_struct *task;
	struct task_struct *next_prev;
	struct {
		struct perf_event_header header;
		u32 next_prev_pid;
		u32 next_prev_tid;
	} event_id;
};

struct perf_task_event {
	struct task_struct *task;
	struct perf_event_context *task_ctx;
	struct {
		struct perf_event_header header;
		u32 pid;
		u32 ppid;
		u32 tid;
		u32 ptid;
		u64 time;
	} event_id;
};

struct perf_text_poke_event {
	const void *old_bytes;
	const void *new_bytes;
	size_t pad;
	u16 old_len;
	u16 new_len;
	struct {
		struct perf_event_header header;
		u64 addr;
	} event_id;
};

struct pericom8250 {
	void *virt;
	unsigned int nr;
	int line[0];
};

struct perm_datum {
	u32 value;
};

struct pernet_operations {
	struct list_head list;
	int (*init)(struct net *);
	void (*pre_exit)(struct net *);
	void (*exit)(struct net *);
	void (*exit_batch)(struct list_head *);
	void (*exit_batch_rtnl)(struct list_head *, struct list_head *);
	unsigned int * const id;
	const size_t size;
};

struct pf_desc {
	u32 pseudoflavor;
	u32 qop;
	u32 service;
	char *name;
	char *auth_domain_name;
	struct auth_domain *domain;
	bool datatouch;
};

struct skb_array {
	struct ptr_ring ring;
};

struct pfifo_fast_priv {
	struct skb_array q[3];
};

struct ptdump_range;

struct ptdump_state {
	void (*note_page)(struct ptdump_state *, long unsigned int, int, u64);
	void (*effective_prot)(struct ptdump_state *, int, u64);
	const struct ptdump_range *range;
};

struct pg_state {
	struct ptdump_state ptdump;
	int level;
	pgprotval_t current_prot;
	pgprotval_t effective_prot;
	pgprotval_t prot_levels[5];
	long unsigned int start_address;
	const struct addr_marker *marker;
	long unsigned int lines;
	bool to_dmesg;
	bool check_wx;
	long unsigned int wx_pages;
	struct seq_file *seq;
};

struct zone {
	long unsigned int _watermark[4];
	long unsigned int watermark_boost;
	long unsigned int nr_reserved_highatomic;
	long unsigned int nr_free_highatomic;
	long int lowmem_reserve[4];
	int node;
	struct pglist_data *zone_pgdat;
	struct per_cpu_pages *per_cpu_pageset;
	struct per_cpu_zonestat *per_cpu_zonestats;
	int pageset_high_min;
	int pageset_high_max;
	int pageset_batch;
	long unsigned int zone_start_pfn;
	atomic_long_t managed_pages;
	long unsigned int spanned_pages;
	long unsigned int present_pages;
	const char *name;
	int initialized;
	long: 64;
	struct cacheline_padding _pad1_;
	struct free_area free_area[11];
	long unsigned int flags;
	spinlock_t lock;
	long: 64;
	long: 64;
	long: 64;
	struct cacheline_padding _pad2_;
	long unsigned int percpu_drift_mark;
	long unsigned int compact_cached_free_pfn;
	long unsigned int compact_cached_migrate_pfn[2];
	long unsigned int compact_init_migrate_pfn;
	long unsigned int compact_init_free_pfn;
	unsigned int compact_considered;
	unsigned int compact_defer_shift;
	int compact_order_failed;
	bool compact_blockskip_flush;
	bool contiguous;
	long: 0;
	struct cacheline_padding _pad3_;
	atomic_long_t vm_stat[10];
	atomic_long_t vm_numa_event[6];
};

struct zoneref {
	struct zone *zone;
	int zone_idx;
};

struct zonelist {
	struct zoneref _zonerefs[257];
};

struct pglist_data {
	struct zone node_zones[4];
	struct zonelist node_zonelists[2];
	int nr_zones;
	long unsigned int node_start_pfn;
	long unsigned int node_present_pages;
	long unsigned int node_spanned_pages;
	int node_id;
	wait_queue_head_t kswapd_wait;
	wait_queue_head_t pfmemalloc_wait;
	wait_queue_head_t reclaim_wait[4];
	atomic_t nr_writeback_throttled;
	long unsigned int nr_reclaim_start;
	struct task_struct *kswapd;
	int kswapd_order;
	enum zone_type kswapd_highest_zoneidx;
	int kswapd_failures;
	int kcompactd_max_order;
	enum zone_type kcompactd_highest_zoneidx;
	wait_queue_head_t kcompactd_wait;
	struct task_struct *kcompactd;
	bool proactive_compact_trigger;
	long unsigned int totalreserve_pages;
	long unsigned int min_unmapped_pages;
	long unsigned int min_slab_pages;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct cacheline_padding _pad1_;
	struct lruvec __lruvec;
	long unsigned int flags;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct cacheline_padding _pad2_;
	struct per_cpu_nodestat *per_cpu_nodestats;
	atomic_long_t vm_stat[46];
	struct memory_tier *memtier;
};

struct pgv {
	char *buffer;
};

struct phc_vclocks_reply_data {
	struct ethnl_reply_data base;
	int num;
	int *index;
};

struct phy_attrs {
	u32 bus_width;
	u32 max_link_rate;
	enum phy_mode mode;
};

struct phy_ops;

struct phy___3 {
	struct device dev;
	int id;
	const struct phy_ops *ops;
	struct mutex mutex;
	int init_count;
	int power_count;
	struct phy_attrs attrs;
	struct regulator *pwr;
	struct dentry *debugfs;
};

struct phy_c45_device_ids {
	u32 devices_in_package;
	u32 mmds_present;
	u32 device_ids[32];
};

struct phy_configure_opts_mipi_dphy {
	unsigned int clk_miss;
	unsigned int clk_post;
	unsigned int clk_pre;
	unsigned int clk_prepare;
	unsigned int clk_settle;
	unsigned int clk_term_en;
	unsigned int clk_trail;
	unsigned int clk_zero;
	unsigned int d_term_en;
	unsigned int eot;
	unsigned int hs_exit;
	unsigned int hs_prepare;
	unsigned int hs_settle;
	unsigned int hs_skip;
	unsigned int hs_trail;
	unsigned int hs_zero;
	unsigned int init;
	unsigned int lpx;
	unsigned int ta_get;
	unsigned int ta_go;
	unsigned int ta_sure;
	unsigned int wakeup;
	long unsigned int hs_clk_rate;
	long unsigned int lp_clk_rate;
	unsigned char lanes;
};

struct phy_configure_opts_dp {
	unsigned int link_rate;
	unsigned int lanes;
	unsigned int voltage[4];
	unsigned int pre[4];
	u8 ssc: 1;
	u8 set_rate: 1;
	u8 set_lanes: 1;
	u8 set_voltages: 1;
};

struct phy_configure_opts_lvds {
	unsigned int bits_per_lane_and_dclk_cycle;
	long unsigned int differential_clk_rate;
	unsigned int lanes;
	bool is_slave;
};

union phy_configure_opts {
	struct phy_configure_opts_mipi_dphy mipi_dphy;
	struct phy_configure_opts_dp dp;
	struct phy_configure_opts_lvds lvds;
};

struct phylink;

struct pse_control;

struct phy_driver;

struct phy_device {
	struct mdio_device mdio;
	const struct phy_driver *drv;
	struct device_link *devlink;
	u32 phyindex;
	u32 phy_id;
	struct phy_c45_device_ids c45_ids;
	unsigned int is_c45: 1;
	unsigned int is_internal: 1;
	unsigned int is_pseudo_fixed_link: 1;
	unsigned int is_gigabit_capable: 1;
	unsigned int has_fixups: 1;
	unsigned int suspended: 1;
	unsigned int suspended_by_mdio_bus: 1;
	unsigned int sysfs_links: 1;
	unsigned int loopback_enabled: 1;
	unsigned int downshifted_rate: 1;
	unsigned int is_on_sfp_module: 1;
	unsigned int mac_managed_pm: 1;
	unsigned int wol_enabled: 1;
	unsigned int autoneg: 1;
	unsigned int link: 1;
	unsigned int autoneg_complete: 1;
	unsigned int interrupts: 1;
	unsigned int irq_suspended: 1;
	unsigned int irq_rerun: 1;
	unsigned int default_timestamp: 1;
	int rate_matching;
	enum phy_state state;
	u32 dev_flags;
	phy_interface_t interface;
	long unsigned int possible_interfaces[1];
	int speed;
	int duplex;
	int port;
	int pause;
	int asym_pause;
	u8 master_slave_get;
	u8 master_slave_set;
	u8 master_slave_state;
	long unsigned int supported[2];
	long unsigned int advertising[2];
	long unsigned int lp_advertising[2];
	long unsigned int adv_old[2];
	long unsigned int supported_eee[2];
	long unsigned int advertising_eee[2];
	long unsigned int eee_broken_modes[2];
	bool enable_tx_lpi;
	bool eee_active;
	struct eee_config eee_cfg;
	long unsigned int host_interfaces[1];
	struct list_head leds;
	int irq;
	void *priv;
	struct phy_package_shared *shared;
	struct sk_buff *skb;
	void *ehdr;
	struct nlattr *nest;
	struct delayed_work state_queue;
	struct mutex lock;
	bool sfp_bus_attached;
	struct sfp_bus *sfp_bus;
	struct phylink *phylink;
	struct net_device *attached_dev;
	struct mii_timestamper *mii_ts;
	struct pse_control *psec;
	u8 mdix;
	u8 mdix_ctrl;
	int pma_extable;
	unsigned int link_down_events;
	void (*phy_link_change)(struct phy_device *, bool);
	void (*adjust_link)(struct net_device *);
};

struct phy_device_node {
	enum phy_upstream upstream_type;
	union {
		struct net_device *netdev;
		struct phy_device *phydev;
	} upstream;
	struct sfp_bus *parent_sfp_bus;
	struct phy_device *phy;
};

struct phy_driver {
	struct mdio_driver_common mdiodrv;
	u32 phy_id;
	char *name;
	u32 phy_id_mask;
	const long unsigned int * const features;
	u32 flags;
	const void *driver_data;
	int (*soft_reset)(struct phy_device *);
	int (*config_init)(struct phy_device *);
	int (*probe)(struct phy_device *);
	int (*get_features)(struct phy_device *);
	unsigned int (*inband_caps)(struct phy_device *, phy_interface_t);
	int (*config_inband)(struct phy_device *, unsigned int);
	int (*get_rate_matching)(struct phy_device *, phy_interface_t);
	int (*suspend)(struct phy_device *);
	int (*resume)(struct phy_device *);
	int (*config_aneg)(struct phy_device *);
	int (*aneg_done)(struct phy_device *);
	int (*read_status)(struct phy_device *);
	int (*config_intr)(struct phy_device *);
	irqreturn_t (*handle_interrupt)(struct phy_device *);
	void (*remove)(struct phy_device *);
	int (*match_phy_device)(struct phy_device *);
	int (*set_wol)(struct phy_device *, struct ethtool_wolinfo *);
	void (*get_wol)(struct phy_device *, struct ethtool_wolinfo *);
	void (*link_change_notify)(struct phy_device *);
	int (*read_mmd)(struct phy_device *, int, u16);
	int (*write_mmd)(struct phy_device *, int, u16, u16);
	int (*read_page)(struct phy_device *);
	int (*write_page)(struct phy_device *, int);
	int (*module_info)(struct phy_device *, struct ethtool_modinfo *);
	int (*module_eeprom)(struct phy_device *, struct ethtool_eeprom *, u8 *);
	int (*cable_test_start)(struct phy_device *);
	int (*cable_test_tdr_start)(struct phy_device *, const struct phy_tdr_config *);
	int (*cable_test_get_status)(struct phy_device *, bool *);
	void (*get_phy_stats)(struct phy_device *, struct ethtool_eth_phy_stats *, struct ethtool_phy_stats *);
	void (*get_link_stats)(struct phy_device *, struct ethtool_link_ext_stats *);
	int (*update_stats)(struct phy_device *);
	int (*get_sset_count)(struct phy_device *);
	void (*get_strings)(struct phy_device *, u8 *);
	void (*get_stats)(struct phy_device *, struct ethtool_stats *, u64 *);
	int (*get_tunable)(struct phy_device *, struct ethtool_tunable *, void *);
	int (*set_tunable)(struct phy_device *, struct ethtool_tunable *, const void *);
	int (*set_loopback)(struct phy_device *, bool);
	int (*get_sqi)(struct phy_device *);
	int (*get_sqi_max)(struct phy_device *);
	int (*get_plca_cfg)(struct phy_device *, struct phy_plca_cfg *);
	int (*set_plca_cfg)(struct phy_device *, const struct phy_plca_cfg *);
	int (*get_plca_status)(struct phy_device *, struct phy_plca_status *);
	int (*led_brightness_set)(struct phy_device *, u8, enum led_brightness);
	int (*led_blink_set)(struct phy_device *, u8, long unsigned int *, long unsigned int *);
	int (*led_hw_is_supported)(struct phy_device *, u8, long unsigned int);
	int (*led_hw_control_set)(struct phy_device *, u8, long unsigned int);
	int (*led_hw_control_get)(struct phy_device *, u8, long unsigned int *);
	int (*led_polarity_set)(struct phy_device *, int, long unsigned int);
};

struct phy_fixup {
	struct list_head list;
	char bus_id[64];
	u32 phy_uid;
	u32 phy_uid_mask;
	int (*run)(struct phy_device *);
};

struct phy_link_topology {
	struct xarray phys;
	u32 next_phy_index;
};

struct phy_ops {
	int (*init)(struct phy___3 *);
	int (*exit)(struct phy___3 *);
	int (*power_on)(struct phy___3 *);
	int (*power_off)(struct phy___3 *);
	int (*set_mode)(struct phy___3 *, enum phy_mode, int);
	int (*set_media)(struct phy___3 *, enum phy_media);
	int (*set_speed)(struct phy___3 *, int);
	int (*configure)(struct phy___3 *, union phy_configure_opts *);
	int (*validate)(struct phy___3 *, enum phy_mode, int, union phy_configure_opts *);
	int (*reset)(struct phy___3 *);
	int (*calibrate)(struct phy___3 *);
	int (*connect)(struct phy___3 *, int);
	int (*disconnect)(struct phy___3 *, int);
	void (*release)(struct phy___3 *);
	struct module *owner;
};

struct phy_package_shared {
	u8 base_addr;
	struct device_node *np;
	refcount_t refcnt;
	long unsigned int flags;
	size_t priv_size;
	void *priv;
};

struct phy_plca_cfg {
	int version;
	int enabled;
	int node_id;
	int node_cnt;
	int to_tmr;
	int burst_cnt;
	int burst_tmr;
};

struct phy_plca_status {
	bool pst;
};

struct phy_reg {
	u16 reg;
	u16 val;
};

struct phy_req_info {
	struct ethnl_req_info base;
	struct phy_device_node *pdn;
};

struct phy_setting {
	u32 speed;
	u8 duplex;
	u8 bit;
};

struct phy_tdr_config {
	u32 first;
	u32 last;
	u32 step;
	s8 pair;
};

struct phylib_stubs {
	int (*hwtstamp_get)(struct phy_device *, struct kernel_hwtstamp_config *);
	int (*hwtstamp_set)(struct phy_device *, struct kernel_hwtstamp_config *, struct netlink_ext_ack *);
	void (*get_phy_stats)(struct phy_device *, struct ethtool_eth_phy_stats *, struct ethtool_phy_stats *);
	void (*get_link_ext_stats)(struct phy_device *, struct ethtool_link_ext_stats *);
};

struct phys_vec {
	phys_addr_t paddr;
	u32 len;
};

struct upid {
	int nr;
	struct pid_namespace *ns;
};

struct pid {
	refcount_t count;
	unsigned int level;
	spinlock_t lock;
	struct dentry *stashed;
	u64 ino;
	struct rb_node pidfs_node;
	struct hlist_head tasks[4];
	struct hlist_head inodes;
	wait_queue_head_t wait_pidfd;
	struct callback_head rcu;
	struct upid numbers[0];
};

union proc_op {
	int (*proc_get_link)(struct dentry *, struct path *);
	int (*proc_show)(struct seq_file *, struct pid_namespace *, struct pid *, struct task_struct *);
	int lsmid;
};

struct pid_entry {
	const char *name;
	unsigned int len;
	umode_t mode;
	const struct inode_operations *iop;
	const struct file_operations *fop;
	union proc_op op;
};

struct pid_namespace {
	struct idr idr;
	struct callback_head rcu;
	unsigned int pid_allocated;
	struct task_struct *child_reaper;
	struct kmem_cache *pid_cachep;
	unsigned int level;
	int pid_max;
	struct pid_namespace *parent;
	struct fs_pin *bacct;
	struct user_namespace *user_ns;
	struct ucounts *ucounts;
	int reboot;
	struct ns_common ns;
	struct work_struct work;
	struct ctl_table_set set;
	struct ctl_table_header *sysctls;
	int memfd_noexec_scope;
};

struct pidfd_info {
	__u64 mask;
	__u64 cgroupid;
	__u32 pid;
	__u32 tgid;
	__u32 ppid;
	__u32 ruid;
	__u32 rgid;
	__u32 euid;
	__u32 egid;
	__u32 suid;
	__u32 sgid;
	__u32 fsuid;
	__u32 fsgid;
	__u32 spare0[1];
};

struct pidff_usage {
	struct hid_field *field;
	s32 *value;
};

struct pidff_device {
	struct hid_device *hid;
	struct hid_report *reports[13];
	struct pidff_usage set_effect[7];
	struct pidff_usage set_envelope[5];
	struct pidff_usage set_condition[8];
	struct pidff_usage set_periodic[5];
	struct pidff_usage set_constant[2];
	struct pidff_usage set_ramp[3];
	struct pidff_usage device_gain[1];
	struct pidff_usage block_load[2];
	struct pidff_usage pool[3];
	struct pidff_usage effect_operation[2];
	struct pidff_usage block_free[1];
	struct hid_field *create_new_effect_type;
	struct hid_field *set_effect_type;
	struct hid_field *effect_direction;
	struct hid_field *device_control;
	struct hid_field *block_load_status;
	struct hid_field *effect_operation_status;
	int control_id[2];
	int type_id[11];
	int status_id[2];
	int operation_id[2];
	int pid_id[64];
};

struct pids_cgroup {
	struct cgroup_subsys_state css;
	atomic64_t counter;
	atomic64_t limit;
	int64_t watermark;
	struct cgroup_file events_file;
	struct cgroup_file events_local_file;
	atomic64_t events[2];
	atomic64_t events_local[2];
};

struct piix_host_priv {
	const int *map;
	u32 saved_iocfg;
	void *sidpr;
};

struct piix_map_db {
	const u32 mask;
	const u16 port_enable;
	const int map[0];
};

struct pimreghdr {
	__u8 type;
	__u8 reserved;
	__be16 csum;
	__be32 flags;
};

struct pinctrl_map_mux {
	const char *group;
	const char *function;
};

struct pinctrl_map_configs {
	const char *group_or_pin;
	long unsigned int *configs;
	unsigned int num_configs;
};

struct pinctrl_map {
	const char *dev_name;
	const char *name;
	enum pinctrl_map_type type;
	const char *ctrl_dev_name;
	union {
		struct pinctrl_map_mux mux;
		struct pinctrl_map_configs configs;
	} data;
};

struct ping_iter_state {
	struct seq_net_private p;
	int bucket;
	sa_family_t family;
};

struct ping_table {
	struct hlist_head hash[64];
	spinlock_t lock;
};

struct pingfakehdr {
	struct icmphdr icmph;
	struct msghdr *msg;
	sa_family_t family;
	__wsum wcheck;
};

struct pingv6_ops {
	int (*ipv6_recv_error)(struct sock *, struct msghdr *, int, int *);
	void (*ip6_datagram_recv_common_ctl)(struct sock *, struct msghdr *, struct sk_buff *);
	void (*ip6_datagram_recv_specific_ctl)(struct sock *, struct msghdr *, struct sk_buff *);
	int (*icmpv6_err_convert)(u8, u8, int *);
	void (*ipv6_icmp_error)(struct sock *, struct sk_buff *, int, __be16, u32, u8 *);
	int (*ipv6_chk_addr)(struct net *, const struct in6_addr *, const struct net_device *, int);
};

struct pipe_buffer;

struct pipe_buf_operations {
	int (*confirm)(struct pipe_inode_info *, struct pipe_buffer *);
	void (*release)(struct pipe_inode_info *, struct pipe_buffer *);
	bool (*try_steal)(struct pipe_inode_info *, struct pipe_buffer *);
	bool (*get)(struct pipe_inode_info *, struct pipe_buffer *);
};

struct pipe_buffer {
	struct page *page;
	unsigned int offset;
	unsigned int len;
	const struct pipe_buf_operations *ops;
	unsigned int flags;
	long unsigned int private;
};

union pipe_index {
	long unsigned int head_tail;
	struct {
		pipe_index_t head;
		pipe_index_t tail;
	};
};

struct pipe_inode_info {
	struct mutex mutex;
	wait_queue_head_t rd_wait;
	wait_queue_head_t wr_wait;
	union {
		long unsigned int head_tail;
		struct {
			pipe_index_t head;
			pipe_index_t tail;
		};
	};
	unsigned int max_usage;
	unsigned int ring_size;
	unsigned int nr_accounted;
	unsigned int readers;
	unsigned int writers;
	unsigned int files;
	unsigned int r_counter;
	unsigned int w_counter;
	bool poll_usage;
	struct page *tmp_page;
	struct fasync_struct *fasync_readers;
	struct fasync_struct *fasync_writers;
	struct pipe_buffer *bufs;
	struct user_struct *user;
};

struct pipe_wait {
	struct trace_iterator *iter;
	int wait_index;
};

struct pkcs1pad_ctx {
	struct crypto_akcipher *child;
	unsigned int key_size;
};

struct pkcs1pad_inst_ctx {
	struct crypto_akcipher_spawn spawn;
};

struct pkcs1pad_request {
	struct scatterlist in_sg[2];
	struct scatterlist out_sg[1];
	uint8_t *in_buf;
	uint8_t *out_buf;
	struct akcipher_request child_req;
};

struct x509_certificate;

struct pkcs7_signed_info;

struct pkcs7_message {
	struct x509_certificate *certs;
	struct x509_certificate *crl;
	struct pkcs7_signed_info *signed_infos;
	u8 version;
	bool have_authattrs;
	enum OID data_type;
	size_t data_len;
	size_t data_hdrlen;
	const void *data;
};

struct pkcs7_parse_context {
	struct pkcs7_message *msg;
	struct pkcs7_signed_info *sinfo;
	struct pkcs7_signed_info **ppsinfo;
	struct x509_certificate *certs;
	struct x509_certificate **ppcerts;
	long unsigned int data;
	enum OID last_oid;
	unsigned int x509_index;
	unsigned int sinfo_index;
	const void *raw_serial;
	unsigned int raw_serial_size;
	unsigned int raw_issuer_size;
	const void *raw_issuer;
	const void *raw_skid;
	unsigned int raw_skid_size;
	bool expect_skid;
};

struct pkcs7_signed_info {
	struct pkcs7_signed_info *next;
	struct x509_certificate *signer;
	unsigned int index;
	bool unsupported_crypto;
	bool blacklisted;
	const void *msgdigest;
	unsigned int msgdigest_len;
	unsigned int authattrs_len;
	const void *authattrs;
	long unsigned int aa_set;
	time64_t signing_time;
	struct public_key_signature *sig;
};

struct pkru_state {
	u32 pkru;
	u32 pad;
};

struct plat_serial8250_port {
	long unsigned int iobase;
	void *membase;
	resource_size_t mapbase;
	resource_size_t mapsize;
	unsigned int uartclk;
	unsigned int irq;
	long unsigned int irqflags;
	void *private_data;
	unsigned char regshift;
	unsigned char iotype;
	unsigned char hub6;
	unsigned char has_sysrq;
	unsigned int type;
	upf_t flags;
	u16 bugs;
	unsigned int (*serial_in)(struct uart_port *, int);
	void (*serial_out)(struct uart_port *, int, int);
	u32 (*dl_read)(struct uart_8250_port *);
	void (*dl_write)(struct uart_8250_port *, u32);
	void (*set_termios)(struct uart_port *, struct ktermios *, const struct ktermios *);
	void (*set_ldisc)(struct uart_port *, struct ktermios *);
	unsigned int (*get_mctrl)(struct uart_port *);
	int (*handle_irq)(struct uart_port *);
	void (*pm)(struct uart_port *, unsigned int, unsigned int);
	void (*handle_break)(struct uart_port *);
};

struct stepping_desc {
	const enum intel_step *map;
	size_t size;
};

struct subplatform_desc;

struct platform_desc {
	struct intel_display_platforms platforms;
	const char *name;
	const struct subplatform_desc *subplatforms;
	const struct intel_display_device_info *info;
	struct stepping_desc step_info;
};

struct mfd_cell;

struct platform_device_id;

struct platform_device {
	const char *name;
	int id;
	bool id_auto;
	struct device dev;
	u64 platform_dma_mask;
	struct device_dma_parameters dma_parms;
	u32 num_resources;
	struct resource *resource;
	const struct platform_device_id *id_entry;
	const char *driver_override;
	struct mfd_cell *mfd_cell;
	struct pdev_archdata archdata;
};

struct platform_device_id {
	char name[20];
	kernel_ulong_t driver_data;
};

struct platform_device_info {
	struct device *parent;
	struct fwnode_handle *fwnode;
	bool of_node_reused;
	const char *name;
	int id;
	const struct resource *res;
	unsigned int num_res;
	const void *data;
	size_t size_data;
	u64 dma_mask;
	const struct property_entry *properties;
};

struct platform_driver {
	int (*probe)(struct platform_device *);
	void (*remove)(struct platform_device *);
	void (*shutdown)(struct platform_device *);
	int (*suspend)(struct platform_device *, pm_message_t);
	int (*resume)(struct platform_device *);
	struct device_driver driver;
	const struct platform_device_id *id_table;
	bool prevent_deferred_probe;
	bool driver_managed_dma;
};

struct platform_hibernation_ops {
	int (*begin)(pm_message_t);
	void (*end)(void);
	int (*pre_snapshot)(void);
	void (*finish)(void);
	int (*prepare)(void);
	int (*enter)(void);
	void (*leave)(void);
	int (*pre_restore)(void);
	void (*restore_cleanup)(void);
	void (*recover)(void);
};

struct platform_object {
	struct platform_device pdev;
	char name[0];
};

struct platform_s2idle_ops {
	int (*begin)(void);
	int (*prepare)(void);
	int (*prepare_late)(void);
	void (*check)(void);
	bool (*wake)(void);
	void (*restore_early)(void);
	void (*restore)(void);
	void (*end)(void);
};

struct platform_suspend_ops {
	int (*valid)(suspend_state_t);
	int (*begin)(suspend_state_t);
	int (*prepare)(void);
	int (*prepare_late)(void);
	int (*enter)(suspend_state_t);
	void (*wake)(void);
	void (*finish)(void);
	bool (*suspend_again)(void);
	void (*end)(void);
	void (*recover)(void);
};

struct plca_reply_data {
	struct ethnl_reply_data base;
	struct phy_plca_cfg plca_cfg;
	struct phy_plca_status plca_st;
};

struct plff_device {
	struct hid_report *report;
	s32 maxval;
	s32 *strong;
	s32 *weak;
};

struct pm_subsys_data {
	spinlock_t lock;
	unsigned int refcount;
};

struct pm_vt_switch {
	struct list_head head;
	struct device *dev;
	bool required;
};

struct pmap {
	size_t offset;
	const char *name;
};

struct pmu_event_list {
	raw_spinlock_t lock;
	struct list_head list;
};

struct pneigh_entry {
	struct pneigh_entry *next;
	possible_net_t net;
	struct net_device *dev;
	netdevice_tracker dev_tracker;
	u32 flags;
	u8 protocol;
	u32 key[0];
};

struct pnfs_layout_segment {
	struct list_head pls_list;
	struct list_head pls_lc_list;
	struct list_head pls_commits;
	struct pnfs_layout_range pls_range;
	refcount_t pls_refcount;
	u32 pls_seq;
	long unsigned int pls_flags;
	struct pnfs_layout_hdr *pls_layout;
};

struct pnp_protocol;

struct pnp_id;

struct pnp_card {
	struct device dev;
	unsigned char number;
	struct list_head global_list;
	struct list_head protocol_list;
	struct list_head devices;
	struct pnp_protocol *protocol;
	struct pnp_id *id;
	char name[50];
	unsigned char pnpver;
	unsigned char productver;
	unsigned int serial;
	unsigned char checksum;
	struct proc_dir_entry *procdir;
};

struct pnp_card_device_id {
	__u8 id[8];
	kernel_ulong_t driver_data;
	struct {
		__u8 id[8];
	} devs[8];
};

struct pnp_device_id;

struct pnp_driver {
	const char *name;
	const struct pnp_device_id *id_table;
	unsigned int flags;
	int (*probe)(struct pnp_dev *, const struct pnp_device_id *);
	void (*remove)(struct pnp_dev *);
	void (*shutdown)(struct pnp_dev *);
	int (*suspend)(struct pnp_dev *, pm_message_t);
	int (*resume)(struct pnp_dev *);
	struct device_driver driver;
};

struct pnp_card_link;

struct pnp_card_driver {
	struct list_head global_list;
	char *name;
	const struct pnp_card_device_id *id_table;
	unsigned int flags;
	int (*probe)(struct pnp_card_link *, const struct pnp_card_device_id *);
	void (*remove)(struct pnp_card_link *);
	int (*suspend)(struct pnp_card_link *, pm_message_t);
	int (*resume)(struct pnp_card_link *);
	struct pnp_driver link;
};

struct pnp_card_link {
	struct pnp_card *card;
	struct pnp_card_driver *driver;
	void *driver_data;
	pm_message_t pm_state;
};

struct pnp_dev {
	struct device dev;
	u64 dma_mask;
	unsigned int number;
	int status;
	struct list_head global_list;
	struct list_head protocol_list;
	struct list_head card_list;
	struct list_head rdev_list;
	struct pnp_protocol *protocol;
	struct pnp_card *card;
	struct pnp_driver *driver;
	struct pnp_card_link *card_link;
	struct pnp_id *id;
	int active;
	int capabilities;
	unsigned int num_dependent_sets;
	struct list_head resources;
	struct list_head options;
	char name[50];
	int flags;
	struct proc_dir_entry *procent;
	void *data;
};

struct pnp_device_id {
	__u8 id[8];
	kernel_ulong_t driver_data;
};

struct pnp_dma {
	unsigned char map;
	unsigned char flags;
};

struct pnp_fixup {
	char id[7];
	void (*quirk_function)(struct pnp_dev *);
};

struct pnp_id {
	char id[8];
	struct pnp_id *next;
};

struct pnp_info_buffer {
	char *buffer;
	char *curr;
	long unsigned int size;
	long unsigned int len;
	int stop;
	int error;
};

typedef struct pnp_info_buffer pnp_info_buffer_t;

struct pnp_irq {
	pnp_irq_mask_t map;
	unsigned char flags;
};

struct pnp_mem {
	resource_size_t min;
	resource_size_t max;
	resource_size_t align;
	resource_size_t size;
	unsigned char flags;
};

struct pnp_port {
	resource_size_t min;
	resource_size_t max;
	resource_size_t align;
	resource_size_t size;
	unsigned char flags;
};

struct pnp_option {
	struct list_head list;
	unsigned int flags;
	long unsigned int type;
	union {
		struct pnp_port port;
		struct pnp_irq irq;
		struct pnp_dma dma;
		struct pnp_mem mem;
	} u;
};

struct pnp_protocol {
	struct list_head protocol_list;
	char *name;
	int (*get)(struct pnp_dev *);
	int (*set)(struct pnp_dev *);
	int (*disable)(struct pnp_dev *);
	bool (*can_wakeup)(struct pnp_dev *);
	int (*suspend)(struct pnp_dev *, pm_message_t);
	int (*resume)(struct pnp_dev *);
	unsigned char number;
	struct device dev;
	struct list_head cards;
	struct list_head devices;
};

struct pnp_resource {
	struct list_head list;
	struct resource res;
};

struct policy_file;

struct policy_data {
	struct policydb *p;
	struct policy_file *fp;
};

struct policy_file {
	char *data;
	size_t len;
};

struct policy_load_memory {
	size_t len;
	void *data;
};

struct role_datum;

struct user_datum;

struct type_datum;

struct role_allow;

struct policydb {
	int mls_enabled;
	struct symtab symtab[8];
	char **sym_val_to_name[8];
	struct class_datum **class_val_to_struct;
	struct role_datum **role_val_to_struct;
	struct user_datum **user_val_to_struct;
	struct type_datum **type_val_to_struct;
	struct avtab te_avtab;
	struct hashtab role_tr;
	struct ebitmap filename_trans_ttypes;
	struct hashtab filename_trans;
	u32 compat_filename_trans_count;
	struct cond_bool_datum **bool_val_to_struct;
	struct avtab te_cond_avtab;
	struct cond_node *cond_list;
	u32 cond_list_len;
	struct role_allow *role_allow;
	struct ocontext *ocontexts[9];
	struct genfs *genfs;
	struct hashtab range_tr;
	struct ebitmap *type_attr_map_array;
	struct ebitmap policycaps;
	struct ebitmap permissive_map;
	size_t len;
	unsigned int policyvers;
	unsigned int reject_unknown: 1;
	unsigned int allow_unknown: 1;
	u16 process_class;
	u32 process_trans_perms;
};

struct policydb_compat_info {
	unsigned int version;
	unsigned int sym_num;
	unsigned int ocon_num;
};

struct pollfd {
	int fd;
	short int events;
	short int revents;
};

struct poll_list {
	struct poll_list *next;
	unsigned int len;
	struct pollfd entries[0];
};

struct poll_table_entry {
	struct file *filp;
	__poll_t key;
	wait_queue_entry_t wait;
	wait_queue_head_t *wait_address;
};

struct poll_table_page {
	struct poll_table_page *next;
	struct poll_table_entry *entry;
	struct poll_table_entry entries[0];
};

struct poll_wqueues {
	poll_table pt;
	struct poll_table_page *table;
	struct task_struct *polling_task;
	int triggered;
	int error;
	int inline_index;
	struct poll_table_entry inline_entries[9];
};

struct worker_pool;

struct pool_workqueue {
	struct worker_pool *pool;
	struct workqueue_struct *wq;
	int work_color;
	int flush_color;
	int refcnt;
	int nr_in_flight[16];
	bool plugged;
	int nr_active;
	struct list_head inactive_works;
	struct list_head pending_node;
	struct list_head pwqs_node;
	struct list_head mayday_node;
	u64 stats[8];
	struct kthread_work release_work;
	struct callback_head rcu;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct port_stats {
	long unsigned int bytes_sent;
	long unsigned int bytes_received;
	long unsigned int bytes_discarded;
};

struct ports_device;

struct port_buffer;

struct virtqueue;

struct port___3 {
	struct list_head list;
	struct ports_device *portdev;
	struct port_buffer *inbuf;
	spinlock_t inbuf_lock;
	spinlock_t outvq_lock;
	struct virtqueue *in_vq;
	struct virtqueue *out_vq;
	struct dentry *debugfs_file;
	struct port_stats stats;
	struct console___2 cons;
	struct cdev *cdev;
	struct device *dev;
	struct kref kref;
	wait_queue_head_t waitqueue;
	char *name;
	struct fasync_struct *async_queue;
	u32 id;
	bool outvq_full;
	bool host_connected;
	bool guest_connected;
};

struct port_buffer {
	char *buf;
	size_t size;
	size_t len;
	size_t offset;
	dma_addr_t dma;
	struct device *dev;
	struct list_head list;
	unsigned int sgpages;
	struct scatterlist sg[0];
};

struct port_identity {
	struct clock_identity clock_identity;
	__be16 port_number;
};

struct portdrv_service_data {
	struct pcie_port_service_driver *drv;
	struct device *dev;
	u32 service;
};

struct virtio_console_control {
	__virtio32 id;
	__virtio16 event;
	__virtio16 value;
};

struct virtio_device;

struct ports_device {
	struct list_head list;
	struct work_struct control_work;
	struct work_struct config_work;
	struct list_head ports;
	spinlock_t ports_lock;
	spinlock_t c_ivq_lock;
	spinlock_t c_ovq_lock;
	u32 max_nr_ports;
	struct virtio_device *vdev;
	struct virtqueue *c_ivq;
	struct virtqueue *c_ovq;
	struct virtio_console_control cpkt;
	struct virtqueue **in_vqs;
	struct virtqueue **out_vqs;
	int chr_major;
};

struct ports_driver_data {
	struct dentry *debugfs_dir;
	struct list_head portdevs;
	struct list_head consoles;
};

struct posix_acl_xattr_entry {
	__le16 e_tag;
	__le16 e_perm;
	__le32 e_id;
};

struct posix_acl_xattr_header {
	__le32 a_version;
};

struct posix_clock;

struct posix_clock_context;

struct posix_clock_operations {
	struct module *owner;
	int (*clock_adjtime)(struct posix_clock *, struct __kernel_timex *);
	int (*clock_gettime)(struct posix_clock *, struct timespec64 *);
	int (*clock_getres)(struct posix_clock *, struct timespec64 *);
	int (*clock_settime)(struct posix_clock *, const struct timespec64 *);
	long int (*ioctl)(struct posix_clock_context *, unsigned int, long unsigned int);
	int (*open)(struct posix_clock_context *, fmode_t);
	__poll_t (*poll)(struct posix_clock_context *, struct file *, poll_table *);
	int (*release)(struct posix_clock_context *);
	ssize_t (*read)(struct posix_clock_context *, uint, char *, size_t);
};

struct posix_clock {
	struct posix_clock_operations ops;
	struct cdev cdev;
	struct device *dev;
	struct rw_semaphore rwsem;
	bool zombie;
};

struct posix_clock_context {
	struct posix_clock *clk;
	void *private_clkdata;
};

struct posix_clock_desc {
	struct file *fp;
	struct posix_clock *clk;
};

struct posix_cputimer_base {
	u64 nextevt;
	struct timerqueue_head tqhead;
};

struct posix_cputimers {
	struct posix_cputimer_base bases[3];
	unsigned int timers_active;
	unsigned int expiry_active;
};

struct posix_cputimers_work {
	struct callback_head work;
	struct mutex mutex;
	unsigned int scheduled;
};

struct posix_msg_tree_node {
	struct rb_node rb_node;
	struct list_head msg_list;
	int priority;
};

struct postprocess_bh_ctx {
	struct work_struct work;
	struct buffer_head *bh;
};

struct power_supply_battery_info;

struct power_supply {
	const struct power_supply_desc *desc;
	char **supplied_to;
	size_t num_supplicants;
	char **supplied_from;
	size_t num_supplies;
	struct device_node *of_node;
	void *drv_data;
	struct device dev;
	struct work_struct changed_work;
	struct delayed_work deferred_register_work;
	spinlock_t changed_lock;
	bool changed;
	bool update_groups;
	bool initialized;
	bool removing;
	atomic_t use_cnt;
	struct power_supply_battery_info *battery_info;
	struct rw_semaphore extensions_sem;
	struct list_head extensions;
	struct thermal_zone_device *tzd;
	struct thermal_cooling_device *tcd;
	struct led_trigger *trig;
	struct led_trigger *charging_trig;
	struct led_trigger *full_trig;
	struct led_trigger *charging_blink_full_solid_trig;
	struct led_trigger *charging_orange_full_green_trig;
};

struct power_supply_attr {
	const char *prop_name;
	char attr_name[31];
	struct device_attribute dev_attr;
	const char * const *text_values;
	int text_values_len;
};

struct power_supply_maintenance_charge_table;

struct power_supply_battery_ocv_table;

struct power_supply_resistance_temp_table;

struct power_supply_vbat_ri_table;

struct power_supply_battery_info {
	unsigned int technology;
	int energy_full_design_uwh;
	int charge_full_design_uah;
	int voltage_min_design_uv;
	int voltage_max_design_uv;
	int tricklecharge_current_ua;
	int precharge_current_ua;
	int precharge_voltage_max_uv;
	int charge_term_current_ua;
	int charge_restart_voltage_uv;
	int overvoltage_limit_uv;
	int constant_charge_current_max_ua;
	int constant_charge_voltage_max_uv;
	const struct power_supply_maintenance_charge_table *maintenance_charge;
	int maintenance_charge_size;
	int alert_low_temp_charge_current_ua;
	int alert_low_temp_charge_voltage_uv;
	int alert_high_temp_charge_current_ua;
	int alert_high_temp_charge_voltage_uv;
	int factory_internal_resistance_uohm;
	int factory_internal_resistance_charging_uohm;
	int ocv_temp[20];
	int temp_ambient_alert_min;
	int temp_ambient_alert_max;
	int temp_alert_min;
	int temp_alert_max;
	int temp_min;
	int temp_max;
	const struct power_supply_battery_ocv_table *ocv_table[20];
	int ocv_table_size[20];
	const struct power_supply_resistance_temp_table *resist_table;
	int resist_table_size;
	const struct power_supply_vbat_ri_table *vbat2ri_discharging;
	int vbat2ri_discharging_size;
	const struct power_supply_vbat_ri_table *vbat2ri_charging;
	int vbat2ri_charging_size;
	int bti_resistance_ohm;
	int bti_resistance_tolerance;
};

struct power_supply_battery_ocv_table {
	int ocv;
	int capacity;
};

struct power_supply_config {
	struct device_node *of_node;
	struct fwnode_handle *fwnode;
	void *drv_data;
	const struct attribute_group **attr_grp;
	char **supplied_to;
	size_t num_supplicants;
	bool no_wakeup_source;
};

struct power_supply_ext {
	const char * const name;
	u8 charge_behaviours;
	const enum power_supply_property *properties;
	size_t num_properties;
	int (*get_property)(struct power_supply *, const struct power_supply_ext *, void *, enum power_supply_property, union power_supply_propval *);
	int (*set_property)(struct power_supply *, const struct power_supply_ext *, void *, enum power_supply_property, const union power_supply_propval *);
	int (*property_is_writeable)(struct power_supply *, const struct power_supply_ext *, void *, enum power_supply_property);
};

struct power_supply_ext_registration {
	struct list_head list_head;
	const struct power_supply_ext *ext;
	struct device *dev;
	void *data;
};

struct power_supply_hwmon {
	struct power_supply *psy;
	long unsigned int *props;
};

struct power_supply_led_trigger {
	struct led_trigger trig;
	struct power_supply *psy;
};

struct power_supply_maintenance_charge_table {
	int charge_current_max_ua;
	int charge_voltage_max_uv;
	int charge_safety_timer_minutes;
};

union power_supply_propval {
	int intval;
	const char *strval;
};

struct power_supply_resistance_temp_table {
	int temp;
	int resistance;
};

struct power_supply_vbat_ri_table {
	int vbat_uv;
	int ri_uohm;
};

struct ppin_info {
	int feature;
	int msr_ppin_ctl;
	int msr_ppin;
};

struct pppoe_tag {
	__be16 tag_type;
	__be16 tag_len;
	char tag_data[0];
};

struct pppoe_hdr {
	__u8 type: 4;
	__u8 ver: 4;
	__u8 code;
	__be16 sid;
	__be16 length;
	struct pppoe_tag tag[0];
};

struct pps_bind_args {
	int tsformat;
	int edge;
	int consumer;
};

struct pps_device;

struct pps_source_info {
	char name[32];
	char path[32];
	int mode;
	void (*echo)(struct pps_device *, int, void *);
	struct module *owner;
	struct device *dev;
};

struct pps_ktime {
	__s64 sec;
	__s32 nsec;
	__u32 flags;
};

struct pps_kparams {
	int api_version;
	int mode;
	struct pps_ktime assert_off_tu;
	struct pps_ktime clear_off_tu;
};

struct pps_device {
	struct pps_source_info info;
	struct pps_kparams params;
	__u32 assert_sequence;
	__u32 clear_sequence;
	struct pps_ktime assert_tu;
	struct pps_ktime clear_tu;
	int current_mode;
	unsigned int last_ev;
	wait_queue_head_t queue;
	unsigned int id;
	const void *lookup_cookie;
	struct device dev;
	struct fasync_struct *async_queue;
	spinlock_t lock;
};

struct pps_event_time {
	struct timespec64 ts_real;
};

struct pps_kinfo {
	__u32 assert_sequence;
	__u32 clear_sequence;
	struct pps_ktime assert_tu;
	struct pps_ktime clear_tu;
	int current_mode;
};

struct pps_fdata {
	struct pps_kinfo info;
	struct pps_ktime timeout;
};

struct pps_ktime_compat {
	__s64 sec;
	__s32 nsec;
	__u32 flags;
};

struct pps_kinfo_compat {
	__u32 assert_sequence;
	__u32 clear_sequence;
	struct pps_ktime_compat assert_tu;
	struct pps_ktime_compat clear_tu;
	int current_mode;
} __attribute__((packed));

struct pps_fdata_compat {
	struct pps_kinfo_compat info;
	struct pps_ktime_compat timeout;
} __attribute__((packed));

struct pps_registers {
	i915_reg_t pp_ctrl;
	i915_reg_t pp_stat;
	i915_reg_t pp_on;
	i915_reg_t pp_off;
	i915_reg_t pp_div;
};

struct pptp_gre_header {
	struct gre_base_hdr gre_hd;
	__be16 payload_len;
	__be16 call_id;
	__be32 seq;
	__be32 ack;
};

struct pr_clear {
	__u64 key;
	__u32 flags;
	__u32 __pad;
};

struct pr_cont_work_struct {
	bool comma;
	work_func_t func;
	long int ctr;
};

struct pr_held_reservation {
	u64 key;
	u32 generation;
	enum pr_type type;
};

struct pr_keys {
	u32 generation;
	u32 num_keys;
	u64 keys[0];
};

struct pr_ops {
	int (*pr_register)(struct block_device *, u64, u64, u32);
	int (*pr_reserve)(struct block_device *, u64, enum pr_type, u32);
	int (*pr_release)(struct block_device *, u64, enum pr_type);
	int (*pr_preempt)(struct block_device *, u64, u64, enum pr_type, bool);
	int (*pr_clear)(struct block_device *, u64);
	int (*pr_read_keys)(struct block_device *, struct pr_keys *);
	int (*pr_read_reservation)(struct block_device *, struct pr_held_reservation *);
};

struct pr_preempt {
	__u64 old_key;
	__u64 new_key;
	__u32 type;
	__u32 flags;
};

struct pr_registration {
	__u64 old_key;
	__u64 new_key;
	__u32 flags;
	__u32 __pad;
};

struct pr_reservation {
	__u64 key;
	__u32 type;
	__u32 flags;
};

struct prb_data_blk_lpos {
	long unsigned int begin;
	long unsigned int next;
};

struct prb_data_block {
	long unsigned int id;
	char data[0];
};

struct prb_data_ring {
	unsigned int size_bits;
	char *data;
	atomic_long_t head_lpos;
	atomic_long_t tail_lpos;
};

struct prb_desc {
	atomic_long_t state_var;
	struct prb_data_blk_lpos text_blk_lpos;
};

struct printk_info;

struct prb_desc_ring {
	unsigned int count_bits;
	struct prb_desc *descs;
	struct printk_info *infos;
	atomic_long_t head_id;
	atomic_long_t tail_id;
	atomic_long_t last_finalized_seq;
};

struct printk_ringbuffer;

struct prb_reserved_entry {
	struct printk_ringbuffer *rb;
	long unsigned int irqflags;
	long unsigned int id;
	unsigned int text_space;
};

struct prctl_mm_map {
	__u64 start_code;
	__u64 end_code;
	__u64 start_data;
	__u64 end_data;
	__u64 start_brk;
	__u64 brk;
	__u64 start_stack;
	__u64 arg_start;
	__u64 arg_end;
	__u64 env_start;
	__u64 env_end;
	__u64 *auxv;
	__u32 auxv_size;
	__u32 exe_fd;
};

struct prefix_cacheinfo {
	__u32 preferred_time;
	__u32 valid_time;
};

struct prefix_info {
	__u8 type;
	__u8 length;
	__u8 prefix_len;
	union {
		__u8 flags;
		struct {
			__u8 reserved: 4;
			__u8 preferpd: 1;
			__u8 routeraddr: 1;
			__u8 autoconf: 1;
			__u8 onlink: 1;
		};
	};
	__be32 valid;
	__be32 prefered;
	__be32 reserved2;
	struct in6_addr prefix;
};

struct prefixmsg {
	unsigned char prefix_family;
	unsigned char prefix_pad1;
	short unsigned int prefix_pad2;
	int prefix_ifindex;
	unsigned char prefix_type;
	unsigned char prefix_len;
	unsigned char prefix_flags;
	unsigned char prefix_pad3;
};

struct prepend_buffer {
	char *buf;
	int len;
};

struct print_entry {
	struct trace_entry ent;
	long unsigned int ip;
	char buf[0];
};

struct printf_spec {
	unsigned char flags;
	unsigned char base;
	short int precision;
	int field_width;
};

struct printk_info {
	u64 seq;
	u64 ts_nsec;
	u16 text_len;
	u8 facility;
	u8 flags: 5;
	u8 level: 3;
	u32 caller_id;
	struct dev_printk_info dev_info;
};

struct printk_message {
	struct printk_buffers *pbufs;
	unsigned int outbuf_len;
	u64 seq;
	long unsigned int dropped;
};

struct printk_record {
	struct printk_info *info;
	char *text_buf;
	unsigned int text_buf_size;
};

struct printk_ringbuffer {
	struct prb_desc_ring desc_ring;
	struct prb_data_ring text_data_ring;
	atomic_long_t fail;
};

struct prioq_match_arg {
	int client;
	int timestamp;
};

struct snd_seq_remove_events;

struct prioq_remove_match_arg {
	int client;
	struct snd_seq_remove_events *info;
};

struct privflags_reply_data {
	struct ethnl_reply_data base;
	const char (*priv_flag_names)[32];
	unsigned int n_priv_flags;
	u32 priv_flags;
};

struct prm_buffer {
	u8 prm_status;
	u64 efi_status;
	u8 prm_cmd;
	guid_t handler_guid;
} __attribute__((packed));

struct prm_mmio_info;

struct prm_context_buffer {
	char signature[4];
	u16 revision;
	u16 reserved;
	guid_t identifier;
	u64 static_data_buffer;
	struct prm_mmio_info *mmio_ranges;
};

struct prm_handler_info {
	efi_guid_t guid;
	efi_status_t (*handler_addr)(u64, void *);
	u64 static_data_buffer_addr;
	u64 acpi_param_buffer_addr;
	struct list_head handler_list;
};

struct prm_mmio_addr_range {
	u64 phys_addr;
	u64 virt_addr;
	u32 length;
} __attribute__((packed));

struct prm_mmio_info {
	u64 mmio_count;
	struct prm_mmio_addr_range addr_ranges[0];
};

struct prm_module_info {
	guid_t guid;
	u16 major_rev;
	u16 minor_rev;
	u16 handler_count;
	struct prm_mmio_info *mmio_info;
	bool updatable;
	struct list_head module_list;
	struct prm_handler_info handlers[0];
};

typedef struct kobject *kobj_probe_t(dev_t, int *, void *);

struct probe {
	struct probe *next;
	dev_t dev;
	long unsigned int range;
	struct module *owner;
	kobj_probe_t *get;
	int (*lock)(dev_t, void *);
	void *data;
};

struct probe_arg {
	struct fetch_insn *code;
	bool dynamic;
	unsigned int offset;
	unsigned int count;
	const char *name;
	const char *comm;
	char *fmt;
	const struct fetch_type *type;
};

struct probe_entry_arg {
	struct fetch_insn *code;
	unsigned int size;
};

struct probe_resp {
	struct callback_head callback_head;
	int len;
	u16 cntdwn_counter_offsets[2];
	u8 data[0];
};

typedef int (*proc_write_t)(struct file *, char *, size_t);

struct proc_ops;

struct proc_dir_entry {
	atomic_t in_use;
	refcount_t refcnt;
	struct list_head pde_openers;
	spinlock_t pde_unload_lock;
	struct completion *pde_unload_completion;
	const struct inode_operations *proc_iops;
	union {
		const struct proc_ops *proc_ops;
		const struct file_operations *proc_dir_ops;
	};
	const struct dentry_operations *proc_dops;
	union {
		const struct seq_operations *seq_ops;
		int (*single_show)(struct seq_file *, void *);
	};
	proc_write_t write;
	void *data;
	unsigned int state_size;
	unsigned int low_ino;
	nlink_t nlink;
	kuid_t uid;
	kgid_t gid;
	loff_t size;
	struct proc_dir_entry *parent;
	struct rb_root subdir;
	struct rb_node subdir_node;
	char *name;
	umode_t mode;
	u8 flags;
	u8 namelen;
	char inline_name[0];
};

struct sid_proc_event {
	__kernel_pid_t process_pid;
	__kernel_pid_t process_tgid;
};

struct ptrace_proc_event {
	__kernel_pid_t process_pid;
	__kernel_pid_t process_tgid;
	__kernel_pid_t tracer_pid;
	__kernel_pid_t tracer_tgid;
};

struct proc_event {
	enum proc_cn_event what;
	__u32 cpu;
	__u64 timestamp_ns;
	union {
		struct {
			__u32 err;
		} ack;
		struct fork_proc_event fork;
		struct exec_proc_event exec;
		struct id_proc_event id;
		struct sid_proc_event sid;
		struct ptrace_proc_event ptrace;
		struct comm_proc_event comm;
		struct coredump_proc_event coredump;
		struct exit_proc_event exit;
	} event_data;
};

struct proc_fs_context {
	struct pid_namespace *pid_ns;
	unsigned int mask;
	enum proc_hidepid hidepid;
	int gid;
	enum proc_pidonly pidonly;
};

struct proc_fs_info {
	struct pid_namespace *pid_ns;
	struct dentry *proc_self;
	struct dentry *proc_thread_self;
	kgid_t pid_gid;
	enum proc_hidepid hide_pid;
	enum proc_pidonly pidonly;
	struct callback_head rcu;
};

struct proc_fs_opts {
	int flag;
	const char *str;
};

struct proc_inode {
	struct pid *pid;
	unsigned int fd;
	union proc_op op;
	struct proc_dir_entry *pde;
	struct ctl_table_header *sysctl;
	const struct ctl_table *sysctl_entry;
	struct hlist_node sibling_inodes;
	const struct proc_ns_operations *ns_ops;
	struct inode vfs_inode;
};

struct proc_input {
	enum proc_cn_mcast_op mcast_op;
	enum proc_cn_event event_type;
};

struct proc_mounts {
	struct mnt_namespace *ns;
	struct path root;
	int (*show)(struct seq_file *, struct vfsmount *);
};

struct proc_nfs_info {
	int flag;
	const char *str;
	const char *nostr;
};

struct proc_ns_operations {
	const char *name;
	const char *real_ns_name;
	int type;
	struct ns_common * (*get)(struct task_struct *);
	void (*put)(struct ns_common *);
	int (*install)(struct nsset *, struct ns_common *);
	struct user_namespace * (*owner)(struct ns_common *);
	struct ns_common * (*get_parent)(struct ns_common *);
};

struct proc_ops {
	unsigned int proc_flags;
	int (*proc_open)(struct inode *, struct file *);
	ssize_t (*proc_read)(struct file *, char *, size_t, loff_t *);
	ssize_t (*proc_read_iter)(struct kiocb *, struct iov_iter *);
	ssize_t (*proc_write)(struct file *, const char *, size_t, loff_t *);
	loff_t (*proc_lseek)(struct file *, loff_t, int);
	int (*proc_release)(struct inode *, struct file *);
	__poll_t (*proc_poll)(struct file *, struct poll_table_struct *);
	long int (*proc_ioctl)(struct file *, unsigned int, long unsigned int);
	long int (*proc_compat_ioctl)(struct file *, unsigned int, long unsigned int);
	int (*proc_mmap)(struct file *, struct vm_area_struct *);
	long unsigned int (*proc_get_unmapped_area)(struct file *, long unsigned int, long unsigned int, long unsigned int, long unsigned int);
};

struct proc_timens_offset {
	int clockid;
	struct timespec64 val;
};

struct process_timer {
	struct timer_list timer;
	struct task_struct *task;
};

struct procmap_query {
	__u64 size;
	__u64 query_flags;
	__u64 query_addr;
	__u64 vma_start;
	__u64 vma_end;
	__u64 vma_flags;
	__u64 vma_page_size;
	__u64 vma_offset;
	__u64 inode;
	__u32 dev_major;
	__u32 dev_minor;
	__u32 vma_name_size;
	__u32 build_id_size;
	__u64 vma_name_addr;
	__u64 build_id_addr;
};

struct prog_entry {
	int target;
	int when_to_branch;
	struct filter_pred *pred;
};

struct prog_poke_elem {
	struct list_head list;
	struct bpf_prog_aux *aux;
};

struct prog_test_member1 {
	int a;
};

struct prog_test_member {
	struct prog_test_member1 m;
	int c;
};

struct prog_test_ref_kfunc {
	int a;
	int b;
	struct prog_test_member memb;
	struct prog_test_ref_kfunc *next;
	refcount_t cnt;
};

struct property {
	char *name;
	int length;
	void *value;
	struct property *next;
};

struct prot_inuse {
	int all;
	int val[64];
};

struct protection_domain {
	struct list_head dev_list;
	struct iommu_domain domain;
	struct amd_io_pgtable iop;
	spinlock_t lock;
	u16 id;
	enum protection_domain_mode pd_mode;
	bool dirty_tracking;
	struct xarray iommu_array;
	struct mmu_notifier mn;
	struct list_head dev_data_list;
};

struct smc_hashinfo;

struct proto_accept_arg;

struct sk_psock;

struct timewait_sock_ops;

struct raw_hashinfo;

struct proto {
	void (*close)(struct sock *, long int);
	int (*pre_connect)(struct sock *, struct sockaddr *, int);
	int (*connect)(struct sock *, struct sockaddr *, int);
	int (*disconnect)(struct sock *, int);
	struct sock * (*accept)(struct sock *, struct proto_accept_arg *);
	int (*ioctl)(struct sock *, int, int *);
	int (*init)(struct sock *);
	void (*destroy)(struct sock *);
	void (*shutdown)(struct sock *, int);
	int (*setsockopt)(struct sock *, int, int, sockptr_t, unsigned int);
	int (*getsockopt)(struct sock *, int, int, char *, int *);
	void (*keepalive)(struct sock *, int);
	int (*compat_ioctl)(struct sock *, unsigned int, long unsigned int);
	int (*sendmsg)(struct sock *, struct msghdr *, size_t);
	int (*recvmsg)(struct sock *, struct msghdr *, size_t, int, int *);
	void (*splice_eof)(struct socket *);
	int (*bind)(struct sock *, struct sockaddr *, int);
	int (*bind_add)(struct sock *, struct sockaddr *, int);
	int (*backlog_rcv)(struct sock *, struct sk_buff *);
	bool (*bpf_bypass_getsockopt)(int, int);
	void (*release_cb)(struct sock *);
	int (*hash)(struct sock *);
	void (*unhash)(struct sock *);
	void (*rehash)(struct sock *);
	int (*get_port)(struct sock *, short unsigned int);
	void (*put_port)(struct sock *);
	int (*psock_update_sk_prot)(struct sock *, struct sk_psock *, bool);
	unsigned int inuse_idx;
	bool (*stream_memory_free)(const struct sock *, int);
	bool (*sock_is_readable)(struct sock *);
	void (*enter_memory_pressure)(struct sock *);
	void (*leave_memory_pressure)(struct sock *);
	atomic_long_t *memory_allocated;
	int *per_cpu_fw_alloc;
	struct percpu_counter *sockets_allocated;
	long unsigned int *memory_pressure;
	long int *sysctl_mem;
	int *sysctl_wmem;
	int *sysctl_rmem;
	u32 sysctl_wmem_offset;
	u32 sysctl_rmem_offset;
	int max_header;
	bool no_autobind;
	struct kmem_cache *slab;
	unsigned int obj_size;
	unsigned int ipv6_pinfo_offset;
	slab_flags_t slab_flags;
	unsigned int useroffset;
	unsigned int usersize;
	unsigned int *orphan_count;
	struct request_sock_ops *rsk_prot;
	struct timewait_sock_ops *twsk_prot;
	union {
		struct inet_hashinfo *hashinfo;
		struct udp_table *udp_table;
		struct raw_hashinfo *raw_hash;
		struct smc_hashinfo *smc_hash;
	} h;
	struct module *owner;
	char name[32];
	struct list_head node;
	int (*diag_destroy)(struct sock *, int);
};

struct proto_accept_arg {
	int flags;
	int err;
	int is_empty;
	bool kern;
};

typedef int (*sk_read_actor_t)(read_descriptor_t *, struct sk_buff *, unsigned int, size_t);

typedef int (*skb_read_actor_t)(struct sock *, struct sk_buff *);

struct proto_ops {
	int family;
	struct module *owner;
	int (*release)(struct socket *);
	int (*bind)(struct socket *, struct sockaddr *, int);
	int (*connect)(struct socket *, struct sockaddr *, int, int);
	int (*socketpair)(struct socket *, struct socket *);
	int (*accept)(struct socket *, struct socket *, struct proto_accept_arg *);
	int (*getname)(struct socket *, struct sockaddr *, int);
	__poll_t (*poll)(struct file *, struct socket *, struct poll_table_struct *);
	int (*ioctl)(struct socket *, unsigned int, long unsigned int);
	int (*compat_ioctl)(struct socket *, unsigned int, long unsigned int);
	int (*gettstamp)(struct socket *, void *, bool, bool);
	int (*listen)(struct socket *, int);
	int (*shutdown)(struct socket *, int);
	int (*setsockopt)(struct socket *, int, int, sockptr_t, unsigned int);
	int (*getsockopt)(struct socket *, int, int, char *, int *);
	void (*show_fdinfo)(struct seq_file *, struct socket *);
	int (*sendmsg)(struct socket *, struct msghdr *, size_t);
	int (*recvmsg)(struct socket *, struct msghdr *, size_t, int);
	int (*mmap)(struct file *, struct socket *, struct vm_area_struct *);
	ssize_t (*splice_read)(struct socket *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);
	void (*splice_eof)(struct socket *);
	int (*set_peek_off)(struct sock *, int);
	int (*peek_len)(struct socket *);
	int (*read_sock)(struct sock *, read_descriptor_t *, sk_read_actor_t);
	int (*read_skb)(struct sock *, skb_read_actor_t);
	int (*sendmsg_locked)(struct sock *, struct msghdr *, size_t);
	int (*set_rcvlowat)(struct sock *, int);
};

struct prt_quirk {
	const struct dmi_system_id *system;
	unsigned int segment;
	unsigned int bus;
	unsigned int device;
	unsigned char pin;
	const char *source;
	const char *actual_source;
};

struct ps2pp_info {
	u8 model;
	u8 kind;
	u16 features;
};

struct psample_group {
	struct list_head list;
	struct net *net;
	u32 group_num;
	u32 refcount;
	u32 seq;
	struct callback_head rcu;
};

struct psched_pktrate {
	u64 rate_pkts_ps;
	u32 mult;
	u8 shift;
};

struct psched_ratecfg {
	u64 rate_bytes_ps;
	u32 mult;
	u16 overhead;
	u16 mpu;
	u8 linklayer;
	u8 shift;
};

struct pse_control_config {
	enum ethtool_podl_pse_admin_state podl_admin_control;
	enum ethtool_c33_pse_admin_state c33_admin_control;
};

struct pse_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_pse_control_status status;
};

struct pseudo_fs_context {
	const struct super_operations *ops;
	const struct export_operations *eops;
	const struct xattr_handler * const *xattr;
	const struct dentry_operations *dops;
	long unsigned int magic;
};

struct psi_group {};

struct psmouse_protocol;

struct psmouse {
	void *private;
	struct input_dev *dev;
	struct ps2dev ps2dev;
	struct delayed_work resync_work;
	const char *vendor;
	const char *name;
	const struct psmouse_protocol *protocol;
	unsigned char packet[8];
	unsigned char badbyte;
	unsigned char pktcnt;
	unsigned char pktsize;
	unsigned char oob_data_type;
	unsigned char extra_buttons;
	bool acks_disable_command;
	unsigned int model;
	long unsigned int last;
	long unsigned int out_of_sync_cnt;
	long unsigned int num_resyncs;
	enum psmouse_state state;
	char devname[64];
	char phys[32];
	unsigned int rate;
	unsigned int resolution;
	unsigned int resetafter;
	unsigned int resync_time;
	bool smartscroll;
	psmouse_ret_t (*protocol_handler)(struct psmouse *);
	void (*set_rate)(struct psmouse *, unsigned int);
	void (*set_resolution)(struct psmouse *, unsigned int);
	void (*set_scale)(struct psmouse *, enum psmouse_scale);
	int (*reconnect)(struct psmouse *);
	int (*fast_reconnect)(struct psmouse *);
	void (*disconnect)(struct psmouse *);
	void (*cleanup)(struct psmouse *);
	int (*poll)(struct psmouse *);
	void (*pt_activate)(struct psmouse *);
	void (*pt_deactivate)(struct psmouse *);
};

struct psmouse_attribute {
	struct device_attribute dattr;
	void *data;
	ssize_t (*show)(struct psmouse *, void *, char *);
	ssize_t (*set)(struct psmouse *, void *, const char *, size_t);
	bool protect;
};

struct psmouse_protocol {
	enum psmouse_type type;
	bool maxproto;
	bool ignore_parity;
	bool try_passthru;
	bool smbus_companion;
	const char *name;
	const char *alias;
	int (*detect)(struct psmouse *, bool);
	int (*init)(struct psmouse *);
};

struct psmouse_smbus_dev {
	struct i2c_board_info board;
	struct psmouse *psmouse;
	struct i2c_client *client;
	struct list_head node;
	bool dead;
	bool need_deactivate;
};

struct psmouse_smbus_removal_work {
	struct work_struct work;
	struct i2c_client *client;
};

struct pstate_funcs {
	int (*get_max)(int);
	int (*get_max_physical)(int);
	int (*get_min)(int);
	int (*get_turbo)(int);
	int (*get_scaling)(void);
	int (*get_cpu_scaling)(int);
	int (*get_aperf_mperf_shift)(void);
	u64 (*get_val)(struct cpudata *, int);
	void (*get_vid)(struct cpudata *);
};

struct psy_am_i_supplied_data {
	struct power_supply *psy;
	unsigned int count;
};

struct psy_for_each_psy_cb_data {
	int (*fn)(struct power_supply *, void *);
	void *data;
};

struct psy_get_supplier_prop_data {
	struct power_supply *psy;
	enum power_supply_property psp;
	union power_supply_propval *val;
};

struct pt_filter {
	long unsigned int msr_a;
	long unsigned int msr_b;
	long unsigned int config;
};

struct pt_filters {
	struct pt_filter filter[4];
	unsigned int nr_filters;
};

struct pt {
	struct perf_output_handle handle;
	struct pt_filters filters;
	int handle_nmi;
	int vmx_on;
	int pause_allowed;
	int resume_allowed;
	u64 output_base;
	u64 output_mask;
};

struct pt_address_range {
	long unsigned int msr_a;
	long unsigned int msr_b;
	unsigned int reg_off;
};

struct topa;

struct topa_entry;

struct pt_buffer {
	struct list_head tables;
	struct topa *first;
	struct topa *last;
	struct topa *cur;
	unsigned int cur_idx;
	size_t output_off;
	long unsigned int nr_pages;
	local_t data_size;
	local64_t head;
	bool snapshot;
	bool single;
	bool wrapped;
	long int stop_pos;
	long int intr_pos;
	struct topa_entry *stop_te;
	struct topa_entry *intr_te;
	void **data_pages;
};

struct pt_cap_desc {
	const char *name;
	u32 leaf;
	u8 reg;
	u32 mask;
};

struct pt_pmu {
	struct pmu pmu;
	u32 caps[8];
	bool vmx;
	bool branch_en_always_on;
	long unsigned int max_nonturbo_ratio;
	unsigned int tsc_art_num;
	unsigned int tsc_art_den;
};

struct pt_regs_offset {
	const char *name;
	int offset;
};

struct ptdesc {
	long unsigned int __page_flags;
	union {
		struct callback_head pt_rcu_head;
		struct list_head pt_list;
		struct {
			long unsigned int _pt_pad_1;
			pgtable_t pmd_huge_pte;
		};
	};
	long unsigned int __page_mapping;
	union {
		long unsigned int pt_index;
		struct mm_struct *pt_mm;
		atomic_t pt_frag_refcount;
		atomic_t pt_share_count;
	};
	union {
		long unsigned int _pt_pad_2;
		spinlock_t ptl;
	};
	unsigned int __page_type;
	atomic_t __page_refcount;
};

struct ptdump_range {
	long unsigned int start;
	long unsigned int end;
};

struct ptp_clock {
	struct posix_clock clock;
	struct device dev;
	struct ptp_clock_info *info;
	dev_t devid;
	int index;
	struct pps_device *pps_source;
	long int dialed_frequency;
	struct list_head tsevqs;
	spinlock_t tsevqs_lock;
	struct mutex pincfg_mux;
	wait_queue_head_t tsev_wq;
	int defunct;
	struct device_attribute *pin_dev_attr;
	struct attribute **pin_attr;
	struct attribute_group pin_attr_group;
	const struct attribute_group *pin_attr_groups[2];
	struct kthread_worker *kworker;
	struct kthread_delayed_work aux_work;
	unsigned int max_vclocks;
	unsigned int n_vclocks;
	int *vclock_index;
	struct mutex n_vclocks_mux;
	bool is_virtual_clock;
	bool has_cycles;
	struct dentry *debugfs_root;
};

struct ptp_clock_caps {
	int max_adj;
	int n_alarm;
	int n_ext_ts;
	int n_per_out;
	int pps;
	int n_pins;
	int cross_timestamping;
	int adjust_phase;
	int max_phase_adj;
	int rsv[11];
};

struct ptp_clock_event {
	int type;
	int index;
	union {
		u64 timestamp;
		s64 offset;
		struct pps_event_time pps_times;
	};
};

struct ptp_extts_request {
	unsigned int index;
	unsigned int flags;
	unsigned int rsv[2];
};

struct ptp_clock_time {
	__s64 sec;
	__u32 nsec;
	__u32 reserved;
};

struct ptp_perout_request {
	union {
		struct ptp_clock_time start;
		struct ptp_clock_time phase;
	};
	struct ptp_clock_time period;
	unsigned int index;
	unsigned int flags;
	union {
		struct ptp_clock_time on;
		unsigned int rsv[4];
	};
};

struct ptp_clock_request {
	enum {
		PTP_CLK_REQ_EXTTS = 0,
		PTP_CLK_REQ_PEROUT = 1,
		PTP_CLK_REQ_PPS = 2,
	} type;
	union {
		struct ptp_extts_request extts;
		struct ptp_perout_request perout;
	};
};

struct ptp_extts_event {
	struct ptp_clock_time t;
	unsigned int index;
	unsigned int flags;
	unsigned int rsv[2];
};

struct ptp_header {
	u8 tsmt;
	u8 ver;
	__be16 message_length;
	u8 domain_number;
	u8 reserved1;
	u8 flag_field[2];
	__be64 correction;
	__be32 reserved2;
	struct port_identity source_port_identity;
	__be16 sequence_id;
	u8 control;
	u8 log_message_interval;
} __attribute__((packed));

struct ptp_pin_desc {
	char name[64];
	unsigned int index;
	unsigned int func;
	unsigned int chan;
	unsigned int rsv[5];
};

struct ptp_sys_offset {
	unsigned int n_samples;
	unsigned int rsv[3];
	struct ptp_clock_time ts[51];
};

struct ptp_sys_offset_extended {
	unsigned int n_samples;
	__kernel_clockid_t clockid;
	unsigned int rsv[2];
	struct ptp_clock_time ts[75];
};

struct ptp_sys_offset_precise {
	struct ptp_clock_time device;
	struct ptp_clock_time sys_realtime;
	struct ptp_clock_time sys_monoraw;
	unsigned int rsv[4];
};

struct ptp_system_timestamp {
	struct timespec64 pre_ts;
	struct timespec64 post_ts;
	clockid_t clockid;
};

struct ptp_vclock {
	struct ptp_clock *pclock;
	struct ptp_clock_info info;
	struct ptp_clock *clock;
	struct hlist_node vclock_hash_node;
	struct cyclecounter cc;
	struct timecounter tc;
	struct mutex lock;
};

struct ptrace_peeksiginfo_args {
	__u64 off;
	__u32 flags;
	__s32 nr;
};

struct ptrace_rseq_configuration {
	__u64 rseq_abi_pointer;
	__u32 rseq_abi_size;
	__u32 signature;
	__u32 flags;
	__u32 pad;
};

struct ptrace_sud_config {
	__u64 mode;
	__u64 selector;
	__u64 offset;
	__u64 len;
};

struct ptrace_syscall_info {
	__u8 op;
	__u8 pad[3];
	__u32 arch;
	__u64 instruction_pointer;
	__u64 stack_pointer;
	union {
		struct {
			__u64 nr;
			__u64 args[6];
		} entry;
		struct {
			__s64 rval;
			__u8 is_error;
		} exit;
		struct {
			__u64 nr;
			__u64 args[6];
			__u32 ret_data;
		} seccomp;
	};
};

struct pts_mount_opts {
	int setuid;
	int setgid;
	kuid_t uid;
	kgid_t gid;
	umode_t mode;
	umode_t ptmxmode;
	int reserve;
	int max;
};

struct pts_fs_info {
	struct ida allocated_ptys;
	struct pts_mount_opts mount_opts;
	struct super_block *sb;
	struct dentry *ptmx_dentry;
};

struct public_key {
	void *key;
	u32 keylen;
	enum OID algo;
	void *params;
	u32 paramlen;
	bool key_is_private;
	const char *id_type;
	const char *pkey_algo;
	long unsigned int key_eflags;
};

struct public_key_signature {
	struct asymmetric_key_id *auth_ids[3];
	u8 *s;
	u8 *digest;
	u32 s_size;
	u32 digest_size;
	const char *pkey_algo;
	const char *hash_algo;
	const char *encoding;
};

struct pv_info {
	const char *name;
};

struct pvclock_vsyscall_time_info {
	struct pvclock_vcpu_time_info pvti;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct pvclock_wall_clock {
	u32 version;
	u32 sec;
	u32 nsec;
};

struct pwm_args {
	u64 period;
	enum pwm_polarity polarity;
};

struct pwm_capture {
	unsigned int period;
	unsigned int duty_cycle;
};

struct pwm_chip;

struct pwm_device {
	const char *label;
	long unsigned int flags;
	unsigned int hwpwm;
	struct pwm_chip *chip;
	struct pwm_args args;
	struct pwm_state state;
	struct pwm_state last;
};

struct pwm_ops;

struct pwm_chip {
	struct device dev;
	const struct pwm_ops *ops;
	struct module *owner;
	unsigned int id;
	unsigned int npwm;
	struct pwm_device * (*of_xlate)(struct pwm_chip *, const struct of_phandle_args *);
	bool atomic;
	bool uses_pwmchip_alloc;
	bool operational;
	union {
		struct mutex nonatomic_lock;
		spinlock_t atomic_lock;
	};
	struct pwm_device pwms[0];
};

struct pwm_waveform;

struct pwm_ops {
	int (*request)(struct pwm_chip *, struct pwm_device *);
	void (*free)(struct pwm_chip *, struct pwm_device *);
	int (*capture)(struct pwm_chip *, struct pwm_device *, struct pwm_capture *, long unsigned int);
	size_t sizeof_wfhw;
	int (*round_waveform_tohw)(struct pwm_chip *, struct pwm_device *, const struct pwm_waveform *, void *);
	int (*round_waveform_fromhw)(struct pwm_chip *, struct pwm_device *, const void *, struct pwm_waveform *);
	int (*read_waveform)(struct pwm_chip *, struct pwm_device *, void *);
	int (*write_waveform)(struct pwm_chip *, struct pwm_device *, const void *);
	int (*apply)(struct pwm_chip *, struct pwm_device *, const struct pwm_state *);
	int (*get_state)(struct pwm_chip *, struct pwm_device *, struct pwm_state *);
};

struct pwm_waveform {
	u64 period_length_ns;
	u64 duty_length_ns;
	u64 duty_offset_ns;
};

struct pxp42_create_arb_in {
	struct pxp_cmd_header header;
	u32 protection_mode;
	u32 session_id;
};

struct pxp42_create_arb_out {
	struct pxp_cmd_header header;
};

struct pxp42_inv_stream_key_in {
	struct pxp_cmd_header header;
	u32 rsvd[3];
};

struct pxp42_inv_stream_key_out {
	struct pxp_cmd_header header;
	u32 rsvd;
};

struct pxp43_start_huc_auth_in {
	struct pxp_cmd_header header;
	__le64 huc_base_address;
};

struct q_inval {
	raw_spinlock_t q_lock;
	void *desc;
	int *desc_status;
	int free_head;
	int free_tail;
	int free_cnt;
};

struct qc_dqblk {
	int d_fieldmask;
	u64 d_spc_hardlimit;
	u64 d_spc_softlimit;
	u64 d_ino_hardlimit;
	u64 d_ino_softlimit;
	u64 d_space;
	u64 d_ino_count;
	s64 d_ino_timer;
	s64 d_spc_timer;
	int d_ino_warns;
	int d_spc_warns;
	u64 d_rt_spc_hardlimit;
	u64 d_rt_spc_softlimit;
	u64 d_rt_space;
	s64 d_rt_spc_timer;
	int d_rt_spc_warns;
};

struct qc_info {
	int i_fieldmask;
	unsigned int i_flags;
	unsigned int i_spc_timelimit;
	unsigned int i_ino_timelimit;
	unsigned int i_rt_spc_timelimit;
	unsigned int i_spc_warnlimit;
	unsigned int i_ino_warnlimit;
	unsigned int i_rt_spc_warnlimit;
};

struct qc_type_state {
	unsigned int flags;
	unsigned int spc_timelimit;
	unsigned int ino_timelimit;
	unsigned int rt_spc_timelimit;
	unsigned int spc_warnlimit;
	unsigned int ino_warnlimit;
	unsigned int rt_spc_warnlimit;
	long long unsigned int ino;
	blkcnt_t blocks;
	blkcnt_t nextents;
};

struct qc_state {
	unsigned int s_incoredqs;
	struct qc_type_state s_state[3];
};

struct qdisc_dump_args {
	struct qdisc_walker w;
	struct sk_buff *skb;
	struct netlink_callback *cb;
};

struct tc_ratespec {
	unsigned char cell_log;
	__u8 linklayer;
	short unsigned int overhead;
	short int cell_align;
	short unsigned int mpu;
	__u32 rate;
};

struct qdisc_rate_table {
	struct tc_ratespec rate;
	u32 data[256];
	struct qdisc_rate_table *next;
	int refcnt;
};

struct tc_sizespec {
	unsigned char cell_log;
	unsigned char size_log;
	short int cell_align;
	int overhead;
	unsigned int linklayer;
	unsigned int mpu;
	unsigned int mtu;
	unsigned int tsize;
};

struct qdisc_size_table {
	struct callback_head rcu;
	struct list_head list;
	struct tc_sizespec szopts;
	int refcnt;
	u16 data[0];
};

struct qdisc_watchdog {
	struct hrtimer timer;
	struct Qdisc *qdisc;
};

struct qi_desc {
	u64 qw0;
	u64 qw1;
	u64 qw2;
	u64 qw3;
};

struct qi_batch {
	struct qi_desc descs[16];
	unsigned int index;
};

struct qnode {
	struct mcs_spinlock mcs;
};

struct qt_disk_dqdbheader {
	__le32 dqdh_next_free;
	__le32 dqdh_prev_free;
	__le16 dqdh_entries;
	__le16 dqdh_pad1;
	__le32 dqdh_pad2;
};

struct qtree_fmt_operations {
	void (*mem2disk_dqblk)(void *, struct dquot *);
	void (*disk2mem_dqblk)(struct dquot *, void *);
	int (*is_id)(void *, struct dquot *);
};

struct qtree_mem_dqinfo {
	struct super_block *dqi_sb;
	int dqi_type;
	unsigned int dqi_blocks;
	unsigned int dqi_free_blk;
	unsigned int dqi_free_entry;
	unsigned int dqi_blocksize_bits;
	unsigned int dqi_entry_size;
	unsigned int dqi_usable_bs;
	unsigned int dqi_qtree_depth;
	const struct qtree_fmt_operations *dqi_ops;
};

struct queue_limits {
	blk_features_t features;
	blk_flags_t flags;
	long unsigned int seg_boundary_mask;
	long unsigned int virt_boundary_mask;
	unsigned int max_hw_sectors;
	unsigned int max_dev_sectors;
	unsigned int chunk_sectors;
	unsigned int max_sectors;
	unsigned int max_user_sectors;
	unsigned int max_segment_size;
	unsigned int min_segment_size;
	unsigned int physical_block_size;
	unsigned int logical_block_size;
	unsigned int alignment_offset;
	unsigned int io_min;
	unsigned int io_opt;
	unsigned int max_discard_sectors;
	unsigned int max_hw_discard_sectors;
	unsigned int max_user_discard_sectors;
	unsigned int max_secure_erase_sectors;
	unsigned int max_write_zeroes_sectors;
	unsigned int max_hw_zone_append_sectors;
	unsigned int max_zone_append_sectors;
	unsigned int discard_granularity;
	unsigned int discard_alignment;
	unsigned int zone_write_granularity;
	unsigned int atomic_write_hw_max;
	unsigned int atomic_write_max_sectors;
	unsigned int atomic_write_hw_boundary;
	unsigned int atomic_write_boundary_sectors;
	unsigned int atomic_write_hw_unit_min;
	unsigned int atomic_write_unit_min;
	unsigned int atomic_write_hw_unit_max;
	unsigned int atomic_write_unit_max;
	short unsigned int max_segments;
	short unsigned int max_integrity_segments;
	short unsigned int max_discard_segments;
	unsigned int max_open_zones;
	unsigned int max_active_zones;
	unsigned int dma_alignment;
	unsigned int dma_pad_mask;
	struct blk_integrity integrity;
};

struct queue_pages {
	struct list_head *pagelist;
	long unsigned int flags;
	nodemask_t *nmask;
	long unsigned int start;
	long unsigned int end;
	struct vm_area_struct *first;
	struct folio *large;
	long int nr_failed;
};

struct queue_sysfs_entry {
	struct attribute attr;
	ssize_t (*show)(struct gendisk *, char *);
	ssize_t (*store)(struct gendisk *, const char *, size_t);
	int (*store_limit)(struct gendisk *, const char *, size_t, struct queue_limits *);
	void (*load_module)(struct gendisk *, const char *, size_t);
};

struct quirk_entry {
	u16 vid;
	u16 pid;
	u32 flags;
};

struct quirk_entry___2 {
	u32 nominal_freq;
	u32 lowest_freq;
};

struct quirk_printer_struct {
	__u16 vendorId;
	__u16 productId;
	unsigned int quirks;
};

struct quirks_list_struct {
	struct hid_device_id hid_bl_item;
	struct list_head node;
};

struct quota_format_ops {
	int (*check_quota_file)(struct super_block *, int);
	int (*read_file_info)(struct super_block *, int);
	int (*write_file_info)(struct super_block *, int);
	int (*free_file_info)(struct super_block *, int);
	int (*read_dqblk)(struct dquot *);
	int (*commit_dqblk)(struct dquot *);
	int (*release_dqblk)(struct dquot *);
	int (*get_next_id)(struct super_block *, struct kqid *);
};

struct quota_format_type {
	int qf_fmt_id;
	const struct quota_format_ops *qf_ops;
	struct module *qf_owner;
	struct quota_format_type *qf_next;
};

struct quota_info {
	unsigned int flags;
	struct rw_semaphore dqio_sem;
	struct inode *files[3];
	struct mem_dqinfo info[3];
	const struct quota_format_ops *ops[3];
};

struct quota_module_name {
	int qm_fmt_id;
	char *qm_mod_name;
};

struct quotactl_ops {
	int (*quota_on)(struct super_block *, int, int, const struct path *);
	int (*quota_off)(struct super_block *, int);
	int (*quota_enable)(struct super_block *, unsigned int);
	int (*quota_disable)(struct super_block *, unsigned int);
	int (*quota_sync)(struct super_block *, int);
	int (*set_info)(struct super_block *, int, struct qc_info *);
	int (*get_dqblk)(struct super_block *, struct kqid, struct qc_dqblk *);
	int (*get_nextdqblk)(struct super_block *, struct kqid *, struct qc_dqblk *);
	int (*set_dqblk)(struct super_block *, struct kqid, struct qc_dqblk *);
	int (*get_state)(struct super_block *, struct qc_state *);
	int (*rm_xquota)(struct super_block *, unsigned int);
};

struct ra_msg {
	struct icmp6hdr icmph;
	__be32 reachable_time;
	__be32 retrans_timer;
};

struct radiotap_align_size {
	uint8_t align: 4;
	uint8_t size: 4;
};

struct xa_node;

struct radix_tree_iter {
	long unsigned int index;
	long unsigned int next_index;
	long unsigned int tags;
	struct xa_node *node;
};

struct radix_tree_preload {
	local_lock_t lock;
	unsigned int nr;
	struct xa_node *nodes;
};

struct ramfs_mount_opts {
	umode_t mode;
};

struct ramfs_fs_info {
	struct ramfs_mount_opts mount_opts;
};

struct rand_data {
	void *hash_state;
	__u64 prev_time;
	__u64 last_delta;
	__s64 last_delta2;
	unsigned int flags;
	unsigned int osr;
	unsigned char *mem;
	unsigned int memlocation;
	unsigned int memblocks;
	unsigned int memblocksize;
	unsigned int memaccessloops;
	unsigned int rct_count;
	unsigned int apt_cutoff;
	unsigned int apt_cutoff_permanent;
	unsigned int apt_observations;
	unsigned int apt_count;
	unsigned int apt_base;
	unsigned int health_failure;
	unsigned int apt_base_set: 1;
};

struct range_node {
	struct rb_node rn_rbnode;
	struct rb_node rb_range_size;
	u32 rn_start;
	u32 rn_last;
	u32 __rn_subtree_last;
};

struct range_trans {
	u32 source_type;
	u32 target_type;
	u32 target_class;
};

struct rapl_model {
	struct perf_msr *rapl_pkg_msrs;
	struct perf_msr *rapl_core_msrs;
	long unsigned int pkg_events;
	long unsigned int core_events;
	unsigned int msr_power_unit;
	enum rapl_unit_quirk unit_quirk;
};

struct rapl_pmu {
	raw_spinlock_t lock;
	int n_active;
	int cpu;
	struct list_head active_list;
	struct pmu *pmu;
	ktime_t timer_interval;
	struct hrtimer hrtimer;
};

struct rapl_pmus {
	struct pmu pmu;
	unsigned int nr_rapl_pmu;
	unsigned int cntr_mask;
	struct rapl_pmu *rapl_pmu[0];
};

struct rate_control_ops;

struct rate_control_alg {
	struct list_head list;
	const struct rate_control_ops *ops;
};

struct rate_control_ops {
	long unsigned int capa;
	const char *name;
	void * (*alloc)(struct ieee80211_hw *);
	void (*add_debugfs)(struct ieee80211_hw *, void *, struct dentry *);
	void (*free)(void *);
	void * (*alloc_sta)(void *, struct ieee80211_sta *, gfp_t);
	void (*rate_init)(void *, struct ieee80211_supported_band *, struct cfg80211_chan_def *, struct ieee80211_sta *, void *);
	void (*rate_update)(void *, struct ieee80211_supported_band *, struct cfg80211_chan_def *, struct ieee80211_sta *, void *, u32);
	void (*free_sta)(void *, struct ieee80211_sta *, void *);
	void (*tx_status_ext)(void *, struct ieee80211_supported_band *, void *, struct ieee80211_tx_status *);
	void (*tx_status)(void *, struct ieee80211_supported_band *, struct ieee80211_sta *, void *, struct sk_buff *);
	void (*get_rate)(void *, struct ieee80211_sta *, void *, struct ieee80211_tx_rate_control *);
	void (*add_sta_debugfs)(void *, void *, struct dentry *);
	u32 (*get_expected_throughput)(void *);
};

struct rate_control_ref {
	const struct rate_control_ops *ops;
	void *priv;
};

struct rate_sample {
	u64 prior_mstamp;
	u32 prior_delivered;
	u32 prior_delivered_ce;
	s32 delivered;
	s32 delivered_ce;
	long int interval_us;
	u32 snd_interval_us;
	u32 rcv_interval_us;
	long int rtt_us;
	int losses;
	u32 acked_sacked;
	u32 prior_in_flight;
	u32 last_end_seq;
	bool is_app_limited;
	bool is_retrans;
	bool is_ack_delayed;
};

struct raw6_frag_vec {
	struct msghdr *msg;
	int hlen;
	char c[4];
};

struct raw6_sock {
	struct inet_sock inet;
	__u32 checksum;
	__u32 offset;
	struct icmp6_filter filter;
	__u32 ip6mr_table;
	struct ipv6_pinfo inet6;
};

struct raw_data_entry {
	struct trace_entry ent;
	unsigned int id;
	char buf[0];
};

struct raw_frag_vec {
	struct msghdr *msg;
	union {
		struct icmphdr icmph;
		char c[1];
	} hdr;
	int hlen;
};

struct raw_hashinfo {
	spinlock_t lock;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct hlist_head ht[256];
};

struct raw_iter_state {
	struct seq_net_private p;
	int bucket;
};

struct raw_sock {
	struct inet_sock inet;
	struct icmp_filter filter;
	u32 ipmr_table;
};

struct rb_augment_callbacks {
	void (*propagate)(struct rb_node *, struct rb_node *);
	void (*copy)(struct rb_node *, struct rb_node *);
	void (*rotate)(struct rb_node *, struct rb_node *);
};

struct rb_event_info {
	u64 ts;
	u64 delta;
	u64 before;
	u64 after;
	long unsigned int length;
	struct buffer_page *tail_page;
	int add_timestamp;
};

struct rb_irq_work {
	struct irq_work work;
	wait_queue_head_t waiters;
	wait_queue_head_t full_waiters;
	atomic_t seq;
	bool waiters_pending;
	bool full_waiters_pending;
	bool wakeup_full;
};

struct rb_list {
	struct rb_root root;
	struct list_head head;
	spinlock_t lock;
};

struct rb_time_struct {
	local64_t time;
};

typedef struct rb_time_struct rb_time_t;

struct rb_wait_data {
	struct rb_irq_work *irq_work;
	int seq;
};

struct rc {
	long int (*fill)(void *, long unsigned int);
	uint8_t *ptr;
	uint8_t *buffer;
	uint8_t *buffer_end;
	long int buffer_size;
	uint32_t code;
	uint32_t range;
	uint32_t bound;
	void (*error)(char *);
};

struct rc_dec {
	uint32_t range;
	uint32_t code;
	uint32_t init_bytes_left;
	const uint8_t *in;
	size_t in_pos;
	size_t in_limit;
};

struct rc_map_table;

struct rc_map {
	struct rc_map_table *scan;
	unsigned int size;
	unsigned int len;
	unsigned int alloc;
	enum rc_proto rc_proto;
	const char *name;
	spinlock_t lock;
};

struct ir_raw_event_ctrl;

struct rc_scancode_filter {
	u32 data;
	u32 mask;
};

struct rc_dev {
	struct device dev;
	bool managed_alloc;
	const struct attribute_group *sysfs_groups[5];
	const char *device_name;
	const char *input_phys;
	struct input_id input_id;
	const char *driver_name;
	const char *map_name;
	struct rc_map rc_map;
	struct mutex lock;
	unsigned int minor;
	struct ir_raw_event_ctrl *raw;
	struct input_dev *input_dev;
	enum rc_driver_type driver_type;
	bool idle;
	bool encode_wakeup;
	u64 allowed_protocols;
	u64 enabled_protocols;
	u64 allowed_wakeup_protocols;
	enum rc_proto wakeup_protocol;
	struct rc_scancode_filter scancode_filter;
	struct rc_scancode_filter scancode_wakeup_filter;
	u32 scancode_mask;
	u32 users;
	void *priv;
	spinlock_t keylock;
	bool keypressed;
	long unsigned int keyup_jiffies;
	struct timer_list timer_keyup;
	struct timer_list timer_repeat;
	u32 last_keycode;
	enum rc_proto last_protocol;
	u64 last_scancode;
	u8 last_toggle;
	u32 timeout;
	u32 min_timeout;
	u32 max_timeout;
	u32 rx_resolution;
	bool registered;
	int (*change_protocol)(struct rc_dev *, u64 *);
	int (*open)(struct rc_dev *);
	void (*close)(struct rc_dev *);
	int (*s_tx_mask)(struct rc_dev *, u32);
	int (*s_tx_carrier)(struct rc_dev *, u32);
	int (*s_tx_duty_cycle)(struct rc_dev *, u32);
	int (*s_rx_carrier_range)(struct rc_dev *, u32, u32);
	int (*tx_ir)(struct rc_dev *, unsigned int *, unsigned int);
	void (*s_idle)(struct rc_dev *, bool);
	int (*s_wideband_receiver)(struct rc_dev *, int);
	int (*s_carrier_report)(struct rc_dev *, int);
	int (*s_filter)(struct rc_dev *, struct rc_scancode_filter *);
	int (*s_wakeup_filter)(struct rc_dev *, struct rc_scancode_filter *);
	int (*s_timeout)(struct rc_dev *, unsigned int);
};

struct rc_map_table {
	u64 scancode;
	u32 keycode;
};

struct rc_parameters {
	u16 initial_xmit_delay;
	u8 first_line_bpg_offset;
	u16 initial_offset;
	u8 flatness_min_qp;
	u8 flatness_max_qp;
	u8 rc_quant_incr_limit0;
	u8 rc_quant_incr_limit1;
	struct drm_dsc_rc_range_parameters rc_range_params[15];
};

struct rc_parameters_data {
	u8 bpp;
	u8 bpc;
	struct rc_parameters params;
};

struct rcec_ea {
	u8 nextbusn;
	u8 lastbusn;
	u32 bitmap;
};

struct rchan_callbacks;

struct rchan_buf;

struct rchan {
	u32 version;
	size_t subbuf_size;
	size_t n_subbufs;
	size_t alloc_size;
	const struct rchan_callbacks *cb;
	struct kref kref;
	void *private_data;
	size_t last_toobig;
	struct rchan_buf **buf;
	int is_global;
	struct list_head list;
	struct dentry *parent;
	int has_base_filename;
	char base_filename[255];
};

struct rchan_buf {
	void *start;
	void *data;
	size_t offset;
	size_t subbufs_produced;
	size_t subbufs_consumed;
	struct rchan *chan;
	wait_queue_head_t read_wait;
	struct irq_work wakeup_work;
	struct dentry *dentry;
	struct kref kref;
	struct page **page_array;
	unsigned int page_count;
	unsigned int finalized;
	size_t *padding;
	size_t prev_padding;
	size_t bytes_consumed;
	size_t early_bytes;
	unsigned int cpu;
	long: 64;
	long: 64;
};

struct rchan_callbacks {
	int (*subbuf_start)(struct rchan_buf *, void *, void *, size_t);
	struct dentry * (*create_buf_file)(const char *, struct dentry *, umode_t, struct rchan_buf *, int *);
	int (*remove_buf_file)(struct dentry *);
};

struct rchan_percpu_buf_dispatcher {
	struct rchan_buf *buf;
	struct dentry *dentry;
};

struct rcu_cblist {
	struct callback_head *head;
	struct callback_head **tail;
	long int len;
};

union rcu_noqs {
	struct {
		u8 norm;
		u8 exp;
	} b;
	u16 s;
};

struct rcu_segcblist {
	struct callback_head *head;
	struct callback_head **tails[4];
	long unsigned int gp_seq[4];
	long int len;
	long int seglen[4];
	u8 flags;
};

struct rcu_snap_record {
	long unsigned int gp_seq;
	u64 cputime_irq;
	u64 cputime_softirq;
	u64 cputime_system;
	long unsigned int nr_hardirqs;
	unsigned int nr_softirqs;
	long long unsigned int nr_csw;
	long unsigned int jiffies;
};

struct rcu_node;

struct rcu_data {
	long unsigned int gp_seq;
	long unsigned int gp_seq_needed;
	union rcu_noqs cpu_no_qs;
	bool core_needs_qs;
	bool beenonline;
	bool gpwrap;
	bool cpu_started;
	struct rcu_node *mynode;
	long unsigned int grpmask;
	long unsigned int ticks_this_gp;
	struct irq_work defer_qs_iw;
	bool defer_qs_iw_pending;
	struct work_struct strict_work;
	struct rcu_segcblist cblist;
	long int qlen_last_fqs_check;
	long unsigned int n_cbs_invoked;
	long unsigned int n_force_qs_snap;
	long int blimit;
	int watching_snap;
	bool rcu_need_heavy_qs;
	bool rcu_urgent_qs;
	bool rcu_forced_tick;
	bool rcu_forced_tick_exp;
	long unsigned int barrier_seq_snap;
	struct callback_head barrier_head;
	int exp_watching_snap;
	struct task_struct *rcu_cpu_kthread_task;
	unsigned int rcu_cpu_kthread_status;
	char rcu_cpu_has_work;
	long unsigned int rcuc_activity;
	unsigned int softirq_snap;
	struct irq_work rcu_iw;
	bool rcu_iw_pending;
	long unsigned int rcu_iw_gp_seq;
	long unsigned int rcu_ofl_gp_seq;
	short int rcu_ofl_gp_state;
	long unsigned int rcu_onl_gp_seq;
	short int rcu_onl_gp_state;
	long unsigned int last_fqs_resched;
	long unsigned int last_sched_clock;
	struct rcu_snap_record snap_record;
	long int lazy_len;
	int cpu;
};

struct rcu_exp_work {
	long unsigned int rew_s;
	struct kthread_work rew_work;
};

struct rcu_node {
	raw_spinlock_t lock;
	long unsigned int gp_seq;
	long unsigned int gp_seq_needed;
	long unsigned int completedqs;
	long unsigned int qsmask;
	long unsigned int rcu_gp_init_mask;
	long unsigned int qsmaskinit;
	long unsigned int qsmaskinitnext;
	long unsigned int expmask;
	long unsigned int expmaskinit;
	long unsigned int expmaskinitnext;
	struct kthread_worker *exp_kworker;
	long unsigned int cbovldmask;
	long unsigned int ffmask;
	long unsigned int grpmask;
	int grplo;
	int grphi;
	u8 grpnum;
	u8 level;
	bool wait_blkd_tasks;
	struct rcu_node *parent;
	struct list_head blkd_tasks;
	struct list_head *gp_tasks;
	struct list_head *exp_tasks;
	struct list_head *boost_tasks;
	struct rt_mutex boost_mtx;
	long unsigned int boost_time;
	struct mutex kthread_mutex;
	struct task_struct *boost_kthread_task;
	unsigned int boost_kthread_status;
	long unsigned int n_boosts;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	raw_spinlock_t fqslock;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	spinlock_t exp_lock;
	long unsigned int exp_seq_rq;
	wait_queue_head_t exp_wq[4];
	struct rcu_exp_work rew;
	bool exp_need_flush;
	raw_spinlock_t exp_poll_lock;
	long unsigned int exp_seq_poll_rq;
	struct work_struct exp_poll_wq;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

union rcu_special {
	struct {
		u8 blocked;
		u8 need_qs;
		u8 exp_hint;
		u8 need_mb;
	} b;
	u32 s;
};

struct rcu_stall_chk_rdr {
	int nesting;
	union rcu_special rs;
	bool on_blkd_list;
};

struct sr_wait_node {
	atomic_t inuse;
	struct llist_node node;
};

struct rcu_state {
	struct rcu_node node[5];
	struct rcu_node *level[3];
	int ncpus;
	int n_online_cpus;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long unsigned int gp_seq;
	long unsigned int gp_max;
	struct task_struct *gp_kthread;
	struct swait_queue_head gp_wq;
	short int gp_flags;
	short int gp_state;
	long unsigned int gp_wake_time;
	long unsigned int gp_wake_seq;
	long unsigned int gp_seq_polled;
	long unsigned int gp_seq_polled_snap;
	long unsigned int gp_seq_polled_exp_snap;
	struct mutex barrier_mutex;
	atomic_t barrier_cpu_count;
	struct completion barrier_completion;
	long unsigned int barrier_sequence;
	raw_spinlock_t barrier_lock;
	struct mutex exp_mutex;
	struct mutex exp_wake_mutex;
	long unsigned int expedited_sequence;
	atomic_t expedited_need_qs;
	struct swait_queue_head expedited_wq;
	int ncpus_snap;
	u8 cbovld;
	u8 cbovldnext;
	long unsigned int jiffies_force_qs;
	long unsigned int jiffies_kick_kthreads;
	long unsigned int n_force_qs;
	long unsigned int gp_start;
	long unsigned int gp_end;
	long unsigned int gp_activity;
	long unsigned int gp_req_activity;
	long unsigned int jiffies_stall;
	int nr_fqs_jiffies_stall;
	long unsigned int jiffies_resched;
	long unsigned int n_force_qs_gpstart;
	const char *name;
	char abbr;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	arch_spinlock_t ofl_lock;
	struct llist_head srs_next;
	struct llist_node *srs_wait_tail;
	struct llist_node *srs_done_tail;
	struct sr_wait_node srs_wait_nodes[5];
	struct work_struct srs_cleanup_work;
	atomic_t srs_cleanups_pending;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct rcu_synchronize {
	struct callback_head head;
	struct completion completion;
};

struct rcu_tasks;

typedef void (*rcu_tasks_gp_func_t)(struct rcu_tasks *);

typedef void (*pregp_func_t)(struct list_head *);

typedef void (*pertask_func_t)(struct task_struct *, struct list_head *);

typedef void (*postscan_func_t)(struct list_head *);

typedef void (*holdouts_func_t)(struct list_head *, bool, bool *);

typedef void (*postgp_func_t)(struct rcu_tasks *);

typedef void (*rcu_callback_t)(struct callback_head *);

typedef void (*call_rcu_func_t)(struct callback_head *, rcu_callback_t);

struct rcu_tasks_percpu;

struct rcu_tasks {
	struct rcuwait cbs_wait;
	raw_spinlock_t cbs_gbl_lock;
	struct mutex tasks_gp_mutex;
	int gp_state;
	int gp_sleep;
	int init_fract;
	long unsigned int gp_jiffies;
	long unsigned int gp_start;
	long unsigned int tasks_gp_seq;
	long unsigned int n_ipis;
	long unsigned int n_ipis_fails;
	struct task_struct *kthread_ptr;
	long unsigned int lazy_jiffies;
	rcu_tasks_gp_func_t gp_func;
	pregp_func_t pregp_func;
	pertask_func_t pertask_func;
	postscan_func_t postscan_func;
	holdouts_func_t holdouts_func;
	postgp_func_t postgp_func;
	call_rcu_func_t call_func;
	unsigned int wait_state;
	struct rcu_tasks_percpu *rtpcpu;
	struct rcu_tasks_percpu **rtpcp_array;
	int percpu_enqueue_shift;
	int percpu_enqueue_lim;
	int percpu_dequeue_lim;
	long unsigned int percpu_dequeue_gpseq;
	struct mutex barrier_q_mutex;
	atomic_t barrier_q_count;
	struct completion barrier_q_completion;
	long unsigned int barrier_q_seq;
	long unsigned int barrier_q_start;
	char *name;
	char *kname;
};

struct rcu_tasks_percpu {
	struct rcu_segcblist cblist;
	raw_spinlock_t lock;
	long unsigned int rtp_jiffies;
	long unsigned int rtp_n_lock_retries;
	struct timer_list lazy_timer;
	unsigned int urgent_gp;
	struct work_struct rtp_work;
	struct irq_work rtp_irq_work;
	struct callback_head barrier_q_head;
	struct list_head rtp_blkd_tasks;
	struct list_head rtp_exit_list;
	int cpu;
	int index;
	struct rcu_tasks *rtpp;
};

struct rd_msg {
	struct icmp6hdr icmph;
	struct in6_addr target;
	struct in6_addr dest;
	__u8 opt[0];
};

struct rdev_sysfs_entry {
	struct attribute attr;
	ssize_t (*show)(struct md_rdev *, char *);
	ssize_t (*store)(struct md_rdev *, const char *, size_t);
};

struct rdma_cgroup {
	struct cgroup_subsys_state css;
	struct list_head rpools;
};

struct rdmacg_device {
	struct list_head dev_node;
	struct list_head rpools;
	char *name;
};

struct rdmacg_resource {
	int max;
	int usage;
};

struct rdmacg_resource_pool {
	struct rdmacg_device *device;
	struct rdmacg_resource resources[2];
	struct list_head cg_node;
	struct list_head dev_node;
	u64 usage_sum;
	int num_max_cnt;
};

struct readahead_control {
	struct file *file;
	struct address_space *mapping;
	struct file_ra_state *ra;
	long unsigned int _index;
	unsigned int _nr_pages;
	unsigned int _batch_count;
	bool dropbehind;
	bool _workingset;
	long unsigned int _pflags;
};

struct readdir_callback {
	struct dir_context ctx;
	struct old_linux_dirent *dirent;
	int result;
};

struct real_mode_header {
	u32 text_start;
	u32 ro_end;
	u32 trampoline_start;
	u32 trampoline_header;
	u32 trampoline_start64;
	u32 trampoline_pgd;
	u32 wakeup_start;
	u32 wakeup_header;
	u32 machine_real_restart_asm;
	u32 machine_real_restart_seg;
};

struct virtnet_rq_stats {
	struct u64_stats_sync syncp;
	u64_stats_t packets;
	u64_stats_t bytes;
	u64_stats_t drops;
	u64_stats_t xdp_packets;
	u64_stats_t xdp_tx;
	u64_stats_t xdp_redirects;
	u64_stats_t xdp_drops;
	u64_stats_t kicks;
};

struct virtnet_interrupt_coalesce {
	u32 max_packets;
	u32 max_usecs;
};

struct virtnet_rq_dma;

struct receive_queue {
	struct virtqueue *vq;
	struct napi_struct napi;
	struct bpf_prog *xdp_prog;
	struct virtnet_rq_stats stats;
	u16 calls;
	bool dim_enabled;
	struct mutex dim_lock;
	struct dim dim;
	u32 packets_in_napi;
	struct virtnet_interrupt_coalesce intr_coal;
	struct page *pages;
	struct ewma_pkt_len mrg_avg_pkt_len;
	struct page_frag alloc_frag;
	struct scatterlist sg[19];
	unsigned int min_buf_len;
	char name[16];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct xdp_rxq_info xdp_rxq;
	struct virtnet_rq_dma *last_dma;
	struct xsk_buff_pool *xsk_pool;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct xdp_rxq_info xsk_rxq_info;
	struct xdp_buff **xsk_buffs;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct reciprocal_value_adv {
	u32 m;
	u8 sh;
	u8 exp;
	bool is_wide_m;
};

struct reclaim_stat {
	unsigned int nr_dirty;
	unsigned int nr_unqueued_dirty;
	unsigned int nr_congested;
	unsigned int nr_writeback;
	unsigned int nr_immediate;
	unsigned int nr_pageout;
	unsigned int nr_activate[2];
	unsigned int nr_ref_keep;
	unsigned int nr_unmap_fail;
	unsigned int nr_lazyfree_fail;
	unsigned int nr_demoted;
};

struct reclaim_state {
	long unsigned int reclaimed;
};

struct recovery_info {
	tid_t start_transaction;
	tid_t end_transaction;
	long unsigned int head_block;
	int nr_replays;
	int nr_revokes;
	int nr_revoke_hits;
};

struct reg_beacon {
	struct list_head list;
	struct ieee80211_channel chan;
};

struct reg_default {
	unsigned int reg;
	unsigned int def;
};

struct reg_field {
	unsigned int reg;
	unsigned int lsb;
	unsigned int msb;
	unsigned int id_size;
	unsigned int id_offset;
};

struct reg_regdb_apply_request {
	struct list_head list;
	const struct ieee80211_regdomain *regdom;
};

struct reg_sequence {
	unsigned int reg;
	unsigned int def;
	unsigned int delay_us;
};

struct reg_whitelist {
	i915_reg_t offset_ldw;
	i915_reg_t offset_udw;
	u8 min_graphics_ver;
	u8 max_graphics_ver;
	u8 size;
};

struct regcache_ops {
	const char *name;
	enum regcache_type type;
	int (*init)(struct regmap *);
	int (*exit)(struct regmap *);
	void (*debugfs_init)(struct regmap *);
	int (*read)(struct regmap *, unsigned int, unsigned int *);
	int (*write)(struct regmap *, unsigned int, unsigned int);
	int (*sync)(struct regmap *, unsigned int, unsigned int);
	int (*drop)(struct regmap *, unsigned int, unsigned int);
};

struct regcache_rbtree_node;

struct regcache_rbtree_ctx {
	struct rb_root root;
	struct regcache_rbtree_node *cached_rbnode;
};

struct regcache_rbtree_node {
	void *block;
	long unsigned int *cache_present;
	unsigned int base_reg;
	unsigned int blklen;
	struct rb_node node;
};

typedef int (*regex_match_func)(char *, struct regex *, int);

struct regex {
	char pattern[256];
	int len;
	int field_len;
	regex_match_func match;
};

struct region {
	unsigned int start;
	unsigned int off;
	unsigned int group_len;
	unsigned int end;
	unsigned int nbits;
};

struct region_devres {
	struct resource *parent;
	resource_size_t start;
	resource_size_t n;
};

struct register_test {
	__u32 reg;
	__u32 mask;
};

typedef void (*regmap_lock)(void *);

typedef void (*regmap_unlock)(void *);

struct regmap_format {
	size_t buf_size;
	size_t reg_bytes;
	size_t pad_bytes;
	size_t val_bytes;
	s8 reg_shift;
	void (*format_write)(struct regmap *, unsigned int, unsigned int);
	void (*format_reg)(void *, unsigned int, unsigned int);
	void (*format_val)(void *, unsigned int, unsigned int);
	unsigned int (*parse_val)(const void *);
	void (*parse_inplace)(void *);
};

struct hwspinlock;

struct regmap_bus;

struct regmap_access_table;

struct regmap {
	union {
		struct mutex mutex;
		struct {
			spinlock_t spinlock;
			long unsigned int spinlock_flags;
		};
		struct {
			raw_spinlock_t raw_spinlock;
			long unsigned int raw_spinlock_flags;
		};
	};
	struct lock_class_key *lock_key;
	regmap_lock lock;
	regmap_unlock unlock;
	void *lock_arg;
	gfp_t alloc_flags;
	unsigned int reg_base;
	struct device *dev;
	void *work_buf;
	struct regmap_format format;
	const struct regmap_bus *bus;
	void *bus_context;
	const char *name;
	bool async;
	spinlock_t async_lock;
	wait_queue_head_t async_waitq;
	struct list_head async_list;
	struct list_head async_free;
	int async_ret;
	bool debugfs_disable;
	struct dentry *debugfs;
	const char *debugfs_name;
	unsigned int debugfs_reg_len;
	unsigned int debugfs_val_len;
	unsigned int debugfs_tot_len;
	struct list_head debugfs_off_cache;
	struct mutex cache_lock;
	unsigned int max_register;
	bool max_register_is_set;
	bool (*writeable_reg)(struct device *, unsigned int);
	bool (*readable_reg)(struct device *, unsigned int);
	bool (*volatile_reg)(struct device *, unsigned int);
	bool (*precious_reg)(struct device *, unsigned int);
	bool (*writeable_noinc_reg)(struct device *, unsigned int);
	bool (*readable_noinc_reg)(struct device *, unsigned int);
	const struct regmap_access_table *wr_table;
	const struct regmap_access_table *rd_table;
	const struct regmap_access_table *volatile_table;
	const struct regmap_access_table *precious_table;
	const struct regmap_access_table *wr_noinc_table;
	const struct regmap_access_table *rd_noinc_table;
	int (*reg_read)(void *, unsigned int, unsigned int *);
	int (*reg_write)(void *, unsigned int, unsigned int);
	int (*reg_update_bits)(void *, unsigned int, unsigned int, unsigned int);
	int (*read)(void *, const void *, size_t, void *, size_t);
	int (*write)(void *, const void *, size_t);
	bool defer_caching;
	long unsigned int read_flag_mask;
	long unsigned int write_flag_mask;
	int reg_shift;
	int reg_stride;
	int reg_stride_order;
	bool force_write_field;
	const struct regcache_ops *cache_ops;
	enum regcache_type cache_type;
	unsigned int cache_size_raw;
	unsigned int cache_word_size;
	unsigned int num_reg_defaults;
	unsigned int num_reg_defaults_raw;
	bool cache_only;
	bool cache_bypass;
	bool cache_free;
	struct reg_default *reg_defaults;
	const void *reg_defaults_raw;
	void *cache;
	bool cache_dirty;
	bool no_sync_defaults;
	struct reg_sequence *patch;
	int patch_regs;
	bool use_single_read;
	bool use_single_write;
	bool can_multi_write;
	size_t max_raw_read;
	size_t max_raw_write;
	struct rb_root range_tree;
	void *selector_work_buf;
	struct hwspinlock *hwlock;
	bool can_sleep;
};

struct regmap_range;

struct regmap_access_table {
	const struct regmap_range *yes_ranges;
	unsigned int n_yes_ranges;
	const struct regmap_range *no_ranges;
	unsigned int n_no_ranges;
};

struct regmap_async {
	struct list_head list;
	struct regmap *map;
	void *work_buf;
};

typedef int (*regmap_hw_write)(void *, const void *, size_t);

typedef int (*regmap_hw_gather_write)(void *, const void *, size_t, const void *, size_t);

typedef int (*regmap_hw_async_write)(void *, const void *, size_t, const void *, size_t, struct regmap_async *);

typedef int (*regmap_hw_reg_write)(void *, unsigned int, unsigned int);

typedef int (*regmap_hw_reg_noinc_write)(void *, unsigned int, const void *, size_t);

typedef int (*regmap_hw_reg_update_bits)(void *, unsigned int, unsigned int, unsigned int);

typedef int (*regmap_hw_read)(void *, const void *, size_t, void *, size_t);

typedef int (*regmap_hw_reg_read)(void *, unsigned int, unsigned int *);

typedef int (*regmap_hw_reg_noinc_read)(void *, unsigned int, void *, size_t);

typedef void (*regmap_hw_free_context)(void *);

typedef struct regmap_async * (*regmap_hw_async_alloc)(void);

struct regmap_bus {
	bool fast_io;
	bool free_on_exit;
	regmap_hw_write write;
	regmap_hw_gather_write gather_write;
	regmap_hw_async_write async_write;
	regmap_hw_reg_write reg_write;
	regmap_hw_reg_noinc_write reg_noinc_write;
	regmap_hw_reg_update_bits reg_update_bits;
	regmap_hw_read read;
	regmap_hw_reg_read reg_read;
	regmap_hw_reg_noinc_read reg_noinc_read;
	regmap_hw_free_context free_context;
	regmap_hw_async_alloc async_alloc;
	u8 read_flag_mask;
	enum regmap_endian reg_format_endian_default;
	enum regmap_endian val_format_endian_default;
	size_t max_raw_read;
	size_t max_raw_write;
};

struct regmap_range_cfg;

struct regmap_config {
	const char *name;
	int reg_bits;
	int reg_stride;
	int reg_shift;
	unsigned int reg_base;
	int pad_bits;
	int val_bits;
	bool (*writeable_reg)(struct device *, unsigned int);
	bool (*readable_reg)(struct device *, unsigned int);
	bool (*volatile_reg)(struct device *, unsigned int);
	bool (*precious_reg)(struct device *, unsigned int);
	bool (*writeable_noinc_reg)(struct device *, unsigned int);
	bool (*readable_noinc_reg)(struct device *, unsigned int);
	int (*reg_read)(void *, unsigned int, unsigned int *);
	int (*reg_write)(void *, unsigned int, unsigned int);
	int (*reg_update_bits)(void *, unsigned int, unsigned int, unsigned int);
	int (*read)(void *, const void *, size_t, void *, size_t);
	int (*write)(void *, const void *, size_t);
	size_t max_raw_read;
	size_t max_raw_write;
	bool can_sleep;
	bool fast_io;
	bool io_port;
	bool disable_locking;
	regmap_lock lock;
	regmap_unlock unlock;
	void *lock_arg;
	unsigned int max_register;
	bool max_register_is_0;
	const struct regmap_access_table *wr_table;
	const struct regmap_access_table *rd_table;
	const struct regmap_access_table *volatile_table;
	const struct regmap_access_table *precious_table;
	const struct regmap_access_table *wr_noinc_table;
	const struct regmap_access_table *rd_noinc_table;
	const struct reg_default *reg_defaults;
	unsigned int num_reg_defaults;
	enum regcache_type cache_type;
	const void *reg_defaults_raw;
	unsigned int num_reg_defaults_raw;
	long unsigned int read_flag_mask;
	long unsigned int write_flag_mask;
	bool zero_flag_mask;
	bool use_single_read;
	bool use_single_write;
	bool use_relaxed_mmio;
	bool can_multi_write;
	bool use_hwlock;
	bool use_raw_spinlock;
	unsigned int hwlock_id;
	unsigned int hwlock_mode;
	enum regmap_endian reg_format_endian;
	enum regmap_endian val_format_endian;
	const struct regmap_range_cfg *ranges;
	unsigned int num_ranges;
};

struct regmap_debugfs_node {
	struct regmap *map;
	struct list_head link;
};

struct regmap_debugfs_off_cache {
	struct list_head list;
	off_t min;
	off_t max;
	unsigned int base_reg;
	unsigned int max_reg;
};

struct regmap_field {
	struct regmap *regmap;
	unsigned int mask;
	unsigned int shift;
	unsigned int reg;
	unsigned int id_size;
	unsigned int id_offset;
};

struct regmap_range {
	unsigned int range_min;
	unsigned int range_max;
};

struct regmap_range_cfg {
	const char *name;
	unsigned int range_min;
	unsigned int range_max;
	unsigned int selector_reg;
	unsigned int selector_mask;
	int selector_shift;
	unsigned int window_start;
	unsigned int window_len;
};

struct regmap_range_node {
	struct rb_node node;
	const char *name;
	struct regmap *map;
	unsigned int range_min;
	unsigned int range_max;
	unsigned int selector_reg;
	unsigned int selector_mask;
	int selector_shift;
	unsigned int window_start;
	unsigned int window_len;
};

struct regulatory_request {
	struct callback_head callback_head;
	int wiphy_idx;
	enum nl80211_reg_initiator initiator;
	enum nl80211_user_reg_hint_type user_reg_hint_type;
	char alpha2[3];
	enum nl80211_dfs_regions dfs_region;
	bool intersect;
	bool processed;
	enum environment_cap country_ie_env;
	struct list_head list;
};

struct sgt_iter {
	struct scatterlist *sgp;
	union {
		long unsigned int pfn;
		dma_addr_t dma;
	};
	unsigned int curr;
	unsigned int max;
};

struct remap_pfn {
	struct mm_struct *mm;
	long unsigned int pfn;
	pgprot_t prot;
	struct sgt_iter sgt;
	resource_size_t iobase;
};

typedef int (*remote_function_f)(void *);

struct remote_function_call {
	struct task_struct *p;
	remote_function_f func;
	void *info;
	int ret;
};

struct remote_output {
	struct perf_buffer *rb;
	int err;
};

struct renamedata {
	struct mnt_idmap *old_mnt_idmap;
	struct inode *old_dir;
	struct dentry *old_dentry;
	struct mnt_idmap *new_mnt_idmap;
	struct inode *new_dir;
	struct dentry *new_dentry;
	struct inode **delegated_inode;
	unsigned int flags;
};

struct req {
	struct req *next;
	struct completion done;
	int err;
	const char *name;
	umode_t mode;
	kuid_t uid;
	kgid_t gid;
	struct device *dev;
};

struct req_iterator {
	struct bvec_iter iter;
	struct bio *bio;
};

typedef enum rq_end_io_ret rq_end_io_fn(struct request *, blk_status_t);

struct request {
	struct request_queue *q;
	struct blk_mq_ctx *mq_ctx;
	struct blk_mq_hw_ctx *mq_hctx;
	blk_opf_t cmd_flags;
	req_flags_t rq_flags;
	int tag;
	int internal_tag;
	unsigned int timeout;
	unsigned int __data_len;
	sector_t __sector;
	struct bio *bio;
	struct bio *biotail;
	union {
		struct list_head queuelist;
		struct request *rq_next;
	};
	struct block_device *part;
	u64 alloc_time_ns;
	u64 start_time_ns;
	u64 io_start_time_ns;
	short unsigned int stats_sectors;
	short unsigned int nr_phys_segments;
	short unsigned int nr_integrity_segments;
	enum mq_rq_state state;
	atomic_t ref;
	long unsigned int deadline;
	union {
		struct hlist_node hash;
		struct llist_node ipi_list;
	};
	union {
		struct rb_node rb_node;
		struct bio_vec special_vec;
	};
	struct {
		struct io_cq *icq;
		void *priv[2];
	} elv;
	struct {
		unsigned int seq;
		rq_end_io_fn *saved_end_io;
	} flush;
	u64 fifo_time;
	rq_end_io_fn *end_io;
	void *end_io_data;
};

struct request_key_auth {
	struct callback_head rcu;
	struct key *target_key;
	struct key *dest_keyring;
	const struct cred *cred;
	void *callout_info;
	size_t callout_len;
	pid_t pid;
	char op[8];
};

struct request_queue {
	void *queuedata;
	struct elevator_queue *elevator;
	const struct blk_mq_ops *mq_ops;
	struct blk_mq_ctx *queue_ctx;
	long unsigned int queue_flags;
	unsigned int rq_timeout;
	unsigned int queue_depth;
	refcount_t refs;
	unsigned int nr_hw_queues;
	struct xarray hctx_table;
	struct percpu_ref q_usage_counter;
	struct lock_class_key io_lock_cls_key;
	struct lockdep_map io_lockdep_map;
	struct lock_class_key q_lock_cls_key;
	struct lockdep_map q_lockdep_map;
	struct request *last_merge;
	spinlock_t queue_lock;
	int quiesce_depth;
	struct gendisk *disk;
	struct kobject *mq_kobj;
	struct queue_limits limits;
	struct device *dev;
	enum rpm_status rpm_status;
	atomic_t pm_only;
	struct blk_queue_stats *stats;
	struct rq_qos *rq_qos;
	struct mutex rq_qos_mutex;
	int id;
	long unsigned int nr_requests;
	struct timer_list timeout;
	struct work_struct timeout_work;
	atomic_t nr_active_requests_shared_tags;
	struct blk_mq_tags *sched_shared_tags;
	struct list_head icq_list;
	long unsigned int blkcg_pols[1];
	struct blkcg_gq *root_blkg;
	struct list_head blkg_list;
	struct mutex blkcg_mutex;
	int node;
	spinlock_t requeue_lock;
	struct list_head requeue_list;
	struct delayed_work requeue_work;
	struct blk_trace *blk_trace;
	struct blk_flush_queue *fq;
	struct list_head flush_list;
	struct mutex sysfs_lock;
	struct mutex limits_lock;
	struct list_head unused_hctx_list;
	spinlock_t unused_hctx_lock;
	int mq_freeze_depth;
	struct callback_head callback_head;
	wait_queue_head_t mq_freeze_wq;
	struct mutex mq_freeze_lock;
	struct blk_mq_tag_set *tag_set;
	struct list_head tag_set_list;
	struct dentry *debugfs_dir;
	struct dentry *sched_debugfs_dir;
	struct dentry *rqos_debugfs_dir;
	struct mutex debugfs_mutex;
};

struct request_sense {
	__u8 error_code: 7;
	__u8 valid: 1;
	__u8 segment_number;
	__u8 sense_key: 4;
	__u8 reserved2: 1;
	__u8 ili: 1;
	__u8 reserved1: 2;
	__u8 information[4];
	__u8 add_sense_len;
	__u8 command_info[4];
	__u8 asc;
	__u8 ascq;
	__u8 fruc;
	__u8 sks[3];
	__u8 asb[46];
};

struct request_sock__safe_rcu_or_null {
	struct sock *sk;
};

struct request_sock_ops {
	int family;
	unsigned int obj_size;
	struct kmem_cache *slab;
	char *slab_name;
	int (*rtx_syn_ack)(const struct sock *, struct request_sock *);
	void (*send_ack)(const struct sock *, struct sk_buff *, struct request_sock *);
	void (*send_reset)(const struct sock *, struct sk_buff *, enum sk_rst_reason);
	void (*destructor)(struct request_sock *);
	void (*syn_ack_timeout)(const struct request_sock *);
};

struct request_wait {
	struct dma_fence_cb cb;
	struct task_struct *tsk;
};

struct res_proc_context {
	struct list_head *list;
	int (*preproc)(struct acpi_resource *, void *);
	void *preproc_data;
	int count;
	int error;
};

struct reserve_mem_table {
	char name[16];
	phys_addr_t start;
	phys_addr_t size;
};

typedef resource_size_t (*resource_alignf)(void *, const struct resource *, resource_size_t, resource_size_t);

struct resource_constraint {
	resource_size_t min;
	resource_size_t max;
	resource_size_t align;
	resource_alignf alignf;
	void *alignf_data;
};

struct resource_entry {
	struct list_head node;
	struct resource *res;
	resource_size_t offset;
	struct resource __res;
};

struct resource_map {
	u_long base;
	u_long num;
	struct resource_map *next;
};

struct resource_win {
	struct resource res;
	resource_size_t offset;
};

struct restart_block {
	long unsigned int arch_data;
	long int (*fn)(struct restart_block *);
	union {
		struct {
			u32 *uaddr;
			u32 val;
			u32 flags;
			u32 bitset;
			u64 time;
			u32 *uaddr2;
		} futex;
		struct {
			clockid_t clockid;
			enum timespec_type type;
			union {
				struct __kernel_timespec *rmtp;
				struct old_timespec32 *compat_rmtp;
			};
			u64 expires;
		} nanosleep;
		struct {
			struct pollfd *ufds;
			int nfds;
			int has_timeout;
			long unsigned int tv_sec;
			long unsigned int tv_nsec;
		} poll;
	};
};

struct restore_data_record {
	long unsigned int jump_address;
	long unsigned int jump_address_phys;
	long unsigned int cr3;
	long unsigned int magic;
	long unsigned int e820_checksum;
};

struct resume_swap_area {
	__kernel_loff_t offset;
	__u32 dev;
} __attribute__((packed));

struct resv_map {
	struct kref refs;
	spinlock_t lock;
	struct list_head regions;
	long int adds_in_progress;
	struct list_head region_cache;
	long int region_cache_count;
	struct rw_semaphore rw_sema;
	struct page_counter *reservation_counter;
	long unsigned int pages_per_hpage;
	struct cgroup_subsys_state *css;
};

struct rethook {
	void *data;
	void (*handler)(struct rethook_node *, void *, long unsigned int, struct pt_regs *);
	struct objpool_head pool;
	struct callback_head rcu;
};

struct return_consumer {
	__u64 cookie;
	__u64 id;
};

struct return_instance {
	struct hprobe hprobe;
	long unsigned int func;
	long unsigned int stack;
	long unsigned int orig_ret_vaddr;
	bool chained;
	int cons_cnt;
	struct return_instance *next;
	struct callback_head rcu;
	struct return_consumer consumer;
	struct return_consumer *extra_consumers;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct reuseport_array {
	struct bpf_map map;
	struct sock *ptrs[0];
};

struct rfkill {
	spinlock_t lock;
	enum rfkill_type type;
	long unsigned int state;
	long unsigned int hard_block_reasons;
	u32 idx;
	bool registered;
	bool persistent;
	bool polling_paused;
	bool suspended;
	bool need_sync;
	const struct rfkill_ops *ops;
	void *data;
	struct led_trigger led_trigger;
	const char *ledtrigname;
	struct device dev;
	struct list_head node;
	struct delayed_work poll_work;
	struct work_struct uevent_work;
	struct work_struct sync_work;
	char name[0];
};

struct rfkill_data {
	struct list_head list;
	struct list_head events;
	struct mutex mtx;
	wait_queue_head_t read_wait;
	bool input_handler;
	u8 max_size;
};

struct rfkill_event_ext {
	__u32 idx;
	__u8 type;
	__u8 op;
	__u8 soft;
	__u8 hard;
	__u8 hard_block_reasons;
} __attribute__((packed));

struct rfkill_int_event {
	struct list_head list;
	struct rfkill_event_ext ev;
};

struct rgb {
	u8 r;
	u8 g;
	u8 b;
};

struct rhash_lock_head {};

struct rhashtable_compare_arg {
	struct rhashtable *ht;
	const void *key;
};

struct ring_buffer_event {
	u32 type_len: 5;
	u32 time_delta: 27;
	u32 array[0];
};

struct ring_buffer_per_cpu;

struct ring_buffer_iter {
	struct ring_buffer_per_cpu *cpu_buffer;
	long unsigned int head;
	long unsigned int next_event;
	struct buffer_page *head_page;
	struct buffer_page *cache_reader_page;
	long unsigned int cache_read;
	long unsigned int cache_pages_removed;
	u64 read_stamp;
	u64 page_stamp;
	struct ring_buffer_event *event;
	size_t event_size;
	int missed_events;
};

struct ring_buffer_meta {
	int magic;
	int struct_size;
	long unsigned int text_addr;
	long unsigned int data_addr;
	long unsigned int first_buffer;
	long unsigned int head_buffer;
	long unsigned int commit_buffer;
	__u32 subbuf_size;
	__u32 nr_subbufs;
	int buffers[0];
};

struct trace_buffer_meta;

struct ring_buffer_per_cpu {
	int cpu;
	atomic_t record_disabled;
	atomic_t resize_disabled;
	struct trace_buffer *buffer;
	raw_spinlock_t reader_lock;
	arch_spinlock_t lock;
	struct lock_class_key lock_key;
	struct buffer_data_page *free_page;
	long unsigned int nr_pages;
	unsigned int current_context;
	struct list_head *pages;
	long unsigned int cnt;
	struct buffer_page *head_page;
	struct buffer_page *tail_page;
	struct buffer_page *commit_page;
	struct buffer_page *reader_page;
	long unsigned int lost_events;
	long unsigned int last_overrun;
	long unsigned int nest;
	local_t entries_bytes;
	local_t entries;
	local_t overrun;
	local_t commit_overrun;
	local_t dropped_events;
	local_t committing;
	local_t commits;
	local_t pages_touched;
	local_t pages_lost;
	local_t pages_read;
	long int last_pages_touch;
	size_t shortest_full;
	long unsigned int read;
	long unsigned int read_bytes;
	rb_time_t write_stamp;
	rb_time_t before_stamp;
	u64 event_stamp[5];
	u64 read_stamp;
	long unsigned int pages_removed;
	unsigned int mapped;
	unsigned int user_mapped;
	struct mutex mapping_lock;
	long unsigned int *subbuf_ids;
	struct trace_buffer_meta *meta_page;
	struct ring_buffer_meta *ring_meta;
	long int nr_pages_to_update;
	struct list_head new_pages;
	struct work_struct update_pages_work;
	struct completion update_done;
	struct rb_irq_work irq_work;
};

struct ring_desc {
	__le32 buf;
	__le32 flaglen;
};

struct ring_desc_ex {
	__le32 bufhigh;
	__le32 buflow;
	__le32 txvlan;
	__le32 flaglen;
};

struct ring_info {
	struct sk_buff *skb;
	u32 len;
};

struct ring_info___2 {
	u8 *data;
	dma_addr_t mapping;
};

struct rings_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_ringparam ringparam;
	struct kernel_ethtool_ringparam kernel_ringparam;
	u32 supported_ring_params;
};

struct rlimit64 {
	__u64 rlim_cur;
	__u64 rlim_max;
};

struct rmap_walk_arg {
	struct folio *folio;
	bool map_unused_to_zeropage;
};

struct rmap_walk_control {
	void *arg;
	bool try_lock;
	bool contended;
	bool (*rmap_one)(struct folio *, struct vm_area_struct *, long unsigned int, void *);
	int (*done)(struct folio *);
	struct anon_vma * (*anon_lock)(const struct folio *, struct rmap_walk_control *);
	bool (*invalid_vma)(struct vm_area_struct *, void *);
};

struct rmi_2d_axis_alignment {
	bool swap_axes;
	bool flip_x;
	bool flip_y;
	u16 clip_x_low;
	u16 clip_y_low;
	u16 clip_x_high;
	u16 clip_y_high;
	u16 offset_x;
	u16 offset_y;
	u8 delta_x_threshold;
	u8 delta_y_threshold;
};

struct rmi_2d_sensor_platform_data {
	struct rmi_2d_axis_alignment axis_align;
	enum rmi_sensor_type sensor_type;
	int x_mm;
	int y_mm;
	int disable_report_mask;
	u16 rezero_wait;
	bool topbuttonpad;
	bool kernel_tracking;
	int dmax;
	int dribble;
	int palm_detect;
};

struct rmi_device_platform_data_spi {
	u32 block_delay_us;
	u32 split_read_block_delay_us;
	u32 read_delay_us;
	u32 write_delay_us;
	u32 split_read_byte_delay_us;
	u32 pre_delay_us;
	u32 post_delay_us;
	u8 bits_per_word;
	u16 mode;
	void *cs_assert_data;
	int (*cs_assert)(const void *, const bool);
};

struct rmi_f01_power_management {
	enum rmi_reg_state nosleep;
	u8 wakeup_threshold;
	u8 doze_holdoff;
	u8 doze_interval;
};

struct rmi_gpio_data {
	bool buttonpad;
	bool trackstick_buttons;
	bool disable;
};

struct rmi_device_platform_data {
	int reset_delay_ms;
	int irq;
	struct rmi_device_platform_data_spi spi_data;
	struct rmi_2d_sensor_platform_data sensor_pdata;
	struct rmi_f01_power_management power_management;
	struct rmi_gpio_data gpio_data;
};

struct rnd_state {
	__u32 s1;
	__u32 s2;
	__u32 s3;
	__u32 s4;
};

struct rng_alg {
	int (*generate)(struct crypto_rng *, const u8 *, unsigned int, u8 *, unsigned int);
	int (*seed)(struct crypto_rng *, const u8 *, unsigned int);
	void (*set_ent)(struct crypto_rng *, const u8 *, unsigned int);
	unsigned int seedsize;
	struct crypto_alg base;
};

struct robust_list {
	struct robust_list *next;
};

struct robust_list_head {
	struct robust_list list;
	long int futex_offset;
	struct robust_list *list_op_pending;
};

struct rock_ridge {
	__u8 signature[2];
	__u8 len;
	__u8 version;
	union {
		struct SU_SP_s SP;
		struct SU_CE_s CE;
		struct SU_ER_s ER;
		struct RR_RR_s RR;
		struct RR_PX_s PX;
		struct RR_PN_s PN;
		struct RR_SL_s SL;
		struct RR_NM_s NM;
		struct RR_CL_s CL;
		struct RR_PL_s PL;
		struct RR_TF_s TF;
		struct RR_ZF_s ZF;
	} u;
};

struct rock_state {
	void *buffer;
	unsigned char *chr;
	int len;
	int cont_size;
	int cont_extent;
	int cont_offset;
	int cont_loops;
	struct inode *inode;
};

struct role_allow {
	u32 role;
	u32 new_role;
	struct role_allow *next;
};

struct role_datum {
	u32 value;
	u32 bounds;
	struct ebitmap dominates;
	struct ebitmap types;
};

struct role_trans_datum {
	u32 new_role;
};

struct role_trans_key {
	u32 role;
	u32 type;
	u32 tclass;
};

struct root_device {
	struct device dev;
	struct module *owner;
};

struct root_domain {
	atomic_t refcount;
	atomic_t rto_count;
	struct callback_head rcu;
	cpumask_var_t span;
	cpumask_var_t online;
	bool overloaded;
	bool overutilized;
	cpumask_var_t dlo_mask;
	atomic_t dlo_count;
	struct dl_bw dl_bw;
	struct cpudl cpudl;
	u64 visit_gen;
	struct irq_work rto_push_work;
	raw_spinlock_t rto_lock;
	int rto_loop;
	int rto_cpu;
	atomic_t rto_loop_next;
	atomic_t rto_loop_start;
	cpumask_var_t rto_mask;
	struct cpupri cpupri;
	struct perf_domain *pd;
};

struct root_entry {
	u64 lo;
	u64 hi;
};

struct rpc_add_xprt_test {
	void (*add_xprt_test)(struct rpc_clnt *, struct rpc_xprt *, void *);
	void *data;
};

struct rpc_auth_create_args {
	rpc_authflavor_t pseudoflavor;
	const char *target_name;
};

struct rpc_authops {
	struct module *owner;
	rpc_authflavor_t au_flavor;
	char *au_name;
	struct rpc_auth * (*create)(const struct rpc_auth_create_args *, struct rpc_clnt *);
	void (*destroy)(struct rpc_auth *);
	int (*hash_cred)(struct auth_cred *, unsigned int);
	struct rpc_cred * (*lookup_cred)(struct rpc_auth *, struct auth_cred *, int);
	struct rpc_cred * (*crcreate)(struct rpc_auth *, struct auth_cred *, int, gfp_t);
	rpc_authflavor_t (*info2flavor)(struct rpcsec_gss_info *);
	int (*flavor2info)(rpc_authflavor_t, struct rpcsec_gss_info *);
	int (*key_timeout)(struct rpc_auth *, struct rpc_cred *);
	int (*ping)(struct rpc_clnt *);
};

struct rpc_buffer {
	size_t len;
	char data[0];
};

struct rpc_call_ops {
	void (*rpc_call_prepare)(struct rpc_task *, void *);
	void (*rpc_call_done)(struct rpc_task *, void *);
	void (*rpc_count_stats)(struct rpc_task *, void *);
	void (*rpc_release)(void *);
};

struct rpc_xprt_switch;

struct rpc_cb_add_xprt_calldata {
	struct rpc_xprt_switch *xps;
	struct rpc_xprt *xprt;
};

struct rpc_pipe_dir_head {
	struct list_head pdh_entries;
	struct dentry *pdh_dentry;
};

struct rpc_rtt {
	long unsigned int timeo;
	long unsigned int srtt[5];
	long unsigned int sdrtt[5];
	int ntimeouts[5];
};

struct rpc_timeout {
	long unsigned int to_initval;
	long unsigned int to_maxval;
	long unsigned int to_increment;
	unsigned int to_retries;
	unsigned char to_exponential;
};

struct rpc_xprt_iter_ops;

struct rpc_xprt_iter {
	struct rpc_xprt_switch *xpi_xpswitch;
	struct rpc_xprt *xpi_cursor;
	const struct rpc_xprt_iter_ops *xpi_ops;
};

struct rpc_iostats;

struct rpc_sysfs_client;

struct rpc_clnt {
	refcount_t cl_count;
	unsigned int cl_clid;
	struct list_head cl_clients;
	struct list_head cl_tasks;
	atomic_t cl_pid;
	spinlock_t cl_lock;
	struct rpc_xprt *cl_xprt;
	const struct rpc_procinfo *cl_procinfo;
	u32 cl_prog;
	u32 cl_vers;
	u32 cl_maxproc;
	struct rpc_auth *cl_auth;
	struct rpc_stat *cl_stats;
	struct rpc_iostats *cl_metrics;
	unsigned int cl_softrtry: 1;
	unsigned int cl_softerr: 1;
	unsigned int cl_discrtry: 1;
	unsigned int cl_noretranstimeo: 1;
	unsigned int cl_autobind: 1;
	unsigned int cl_chatty: 1;
	unsigned int cl_shutdown: 1;
	struct xprtsec_parms cl_xprtsec;
	struct rpc_rtt *cl_rtt;
	const struct rpc_timeout *cl_timeout;
	atomic_t cl_swapper;
	int cl_nodelen;
	char cl_nodename[65];
	struct rpc_pipe_dir_head cl_pipedir_objects;
	struct rpc_clnt *cl_parent;
	struct rpc_rtt cl_rtt_default;
	struct rpc_timeout cl_timeout_default;
	const struct rpc_program *cl_program;
	const char *cl_principal;
	struct rpc_sysfs_client *cl_sysfs;
	union {
		struct rpc_xprt_iter cl_xpi;
		struct work_struct cl_work;
	};
	const struct cred *cl_cred;
	unsigned int cl_max_connect;
	struct super_block *pipefs_sb;
	atomic_t cl_task_count;
};

struct svc_xprt;

struct rpc_create_args {
	struct net *net;
	int protocol;
	struct sockaddr *address;
	size_t addrsize;
	struct sockaddr *saddress;
	const struct rpc_timeout *timeout;
	const char *servername;
	const char *nodename;
	const struct rpc_program *program;
	struct rpc_stat *stats;
	u32 prognumber;
	u32 version;
	rpc_authflavor_t authflavor;
	u32 nconnect;
	long unsigned int flags;
	char *client_name;
	struct svc_xprt *bc_xprt;
	const struct cred *cred;
	unsigned int max_connect;
	struct xprtsec_parms xprtsec;
	long unsigned int connect_timeout;
	long unsigned int reconnect_timeout;
};

struct rpc_cred_cache {
	struct hlist_head *hashtable;
	unsigned int hashbits;
	spinlock_t lock;
};

struct rpc_credops {
	const char *cr_name;
	int (*cr_init)(struct rpc_auth *, struct rpc_cred *);
	void (*crdestroy)(struct rpc_cred *);
	int (*crmatch)(struct auth_cred *, struct rpc_cred *, int);
	int (*crmarshal)(struct rpc_task *, struct xdr_stream *);
	int (*crrefresh)(struct rpc_task *);
	int (*crvalidate)(struct rpc_task *, struct xdr_stream *);
	int (*crwrap_req)(struct rpc_task *, struct xdr_stream *);
	int (*crunwrap_resp)(struct rpc_task *, struct xdr_stream *);
	int (*crkey_timeout)(struct rpc_cred *);
	char * (*crstringify_acceptor)(struct rpc_cred *);
	bool (*crneed_reencode)(struct rpc_task *);
};

struct rpc_filelist {
	const char *name;
	const struct file_operations *i_fop;
	umode_t mode;
};

struct rpc_inode {
	struct inode vfs_inode;
	void *private;
	struct rpc_pipe *pipe;
	wait_queue_head_t waitq;
};

struct rpc_iostats {
	spinlock_t om_lock;
	long unsigned int om_ops;
	long unsigned int om_ntrans;
	long unsigned int om_timeouts;
	long long unsigned int om_bytes_sent;
	long long unsigned int om_bytes_recv;
	ktime_t om_queue;
	ktime_t om_rtt;
	ktime_t om_execute;
	long unsigned int om_error_status;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct rpc_pipe {
	struct list_head pipe;
	struct list_head in_upcall;
	struct list_head in_downcall;
	int pipelen;
	int nreaders;
	int nwriters;
	int flags;
	struct delayed_work queue_timeout;
	const struct rpc_pipe_ops *ops;
	spinlock_t lock;
	struct dentry *dentry;
};

struct rpc_pipe_dir_object_ops {
	int (*create)(struct dentry *, struct rpc_pipe_dir_object *);
	void (*destroy)(struct dentry *, struct rpc_pipe_dir_object *);
};

struct rpc_pipe_ops {
	ssize_t (*upcall)(struct file *, struct rpc_pipe_msg *, char *, size_t);
	ssize_t (*downcall)(struct file *, const char *, size_t);
	void (*release_pipe)(struct inode *);
	int (*open_pipe)(struct inode *);
	void (*destroy_msg)(struct rpc_pipe_msg *);
};

typedef void (*kxdreproc_t)(struct rpc_rqst *, struct xdr_stream *, const void *);

typedef int (*kxdrdproc_t)(struct rpc_rqst *, struct xdr_stream *, void *);

struct rpc_procinfo {
	u32 p_proc;
	kxdreproc_t p_encode;
	kxdrdproc_t p_decode;
	unsigned int p_arglen;
	unsigned int p_replen;
	unsigned int p_timer;
	u32 p_statidx;
	const char *p_name;
};

struct rpc_program {
	const char *name;
	u32 number;
	unsigned int nrvers;
	const struct rpc_version **version;
	struct rpc_stat *stats;
	const char *pipe_dir_name;
};

struct xdr_buf {
	struct kvec head[1];
	struct kvec tail[1];
	struct bio_vec *bvec;
	struct page **pages;
	unsigned int page_base;
	unsigned int page_len;
	unsigned int flags;
	unsigned int buflen;
	unsigned int len;
};

struct rpc_rqst {
	struct rpc_xprt *rq_xprt;
	struct xdr_buf rq_snd_buf;
	struct xdr_buf rq_rcv_buf;
	struct rpc_task *rq_task;
	struct rpc_cred *rq_cred;
	__be32 rq_xid;
	int rq_cong;
	u32 rq_seqno;
	int rq_enc_pages_num;
	struct page **rq_enc_pages;
	void (*rq_release_snd_buf)(struct rpc_rqst *);
	union {
		struct list_head rq_list;
		struct rb_node rq_recv;
	};
	struct list_head rq_xmit;
	struct list_head rq_xmit2;
	void *rq_buffer;
	size_t rq_callsize;
	void *rq_rbuffer;
	size_t rq_rcvsize;
	size_t rq_xmit_bytes_sent;
	size_t rq_reply_bytes_recvd;
	struct xdr_buf rq_private_buf;
	long unsigned int rq_majortimeo;
	long unsigned int rq_minortimeo;
	long unsigned int rq_timeout;
	ktime_t rq_rtt;
	unsigned int rq_retries;
	unsigned int rq_connect_cookie;
	atomic_t rq_pin;
	u32 rq_bytes_sent;
	ktime_t rq_xtime;
	int rq_ntrans;
};

struct rpc_sysfs_client {
	struct kobject kobject;
	struct net *net;
	struct rpc_clnt *clnt;
	struct rpc_xprt_switch *xprt_switch;
};

struct rpc_sysfs_xprt {
	struct kobject kobject;
	struct rpc_xprt *xprt;
	struct rpc_xprt_switch *xprt_switch;
};

struct rpc_sysfs_xprt_switch {
	struct kobject kobject;
	struct net *net;
	struct rpc_xprt_switch *xprt_switch;
	struct rpc_xprt *xprt;
};

struct rpc_task_setup {
	struct rpc_task *task;
	struct rpc_clnt *rpc_client;
	struct rpc_xprt *rpc_xprt;
	struct rpc_cred *rpc_op_cred;
	const struct rpc_message *rpc_message;
	const struct rpc_call_ops *callback_ops;
	void *callback_data;
	struct workqueue_struct *workqueue;
	short unsigned int flags;
	signed char priority;
};

struct rpc_version {
	u32 number;
	unsigned int nrprocs;
	const struct rpc_procinfo *procs;
	unsigned int *counts;
};

struct rpc_xprt_ops;

struct xprt_class;

struct rpc_xprt {
	struct kref kref;
	const struct rpc_xprt_ops *ops;
	unsigned int id;
	const struct rpc_timeout *timeout;
	struct __kernel_sockaddr_storage addr;
	size_t addrlen;
	int prot;
	long unsigned int cong;
	long unsigned int cwnd;
	size_t max_payload;
	struct rpc_wait_queue binding;
	struct rpc_wait_queue sending;
	struct rpc_wait_queue pending;
	struct rpc_wait_queue backlog;
	struct list_head free;
	unsigned int max_reqs;
	unsigned int min_reqs;
	unsigned int num_reqs;
	long unsigned int state;
	unsigned char resvport: 1;
	unsigned char reuseport: 1;
	atomic_t swapper;
	unsigned int bind_index;
	struct list_head xprt_switch;
	long unsigned int bind_timeout;
	long unsigned int reestablish_timeout;
	struct xprtsec_parms xprtsec;
	unsigned int connect_cookie;
	struct work_struct task_cleanup;
	struct timer_list timer;
	long unsigned int last_used;
	long unsigned int idle_timeout;
	long unsigned int connect_timeout;
	long unsigned int max_reconnect_timeout;
	atomic_long_t queuelen;
	spinlock_t transport_lock;
	spinlock_t reserve_lock;
	spinlock_t queue_lock;
	u32 xid;
	struct rpc_task *snd_task;
	struct list_head xmit_queue;
	atomic_long_t xmit_queuelen;
	struct svc_xprt *bc_xprt;
	struct rb_root recv_queue;
	struct {
		long unsigned int bind_count;
		long unsigned int connect_count;
		long unsigned int connect_start;
		long unsigned int connect_time;
		long unsigned int sends;
		long unsigned int recvs;
		long unsigned int bad_xids;
		long unsigned int max_slots;
		long long unsigned int req_u;
		long long unsigned int bklog_u;
		long long unsigned int sending_u;
		long long unsigned int pending_u;
	} stat;
	struct net *xprt_net;
	netns_tracker ns_tracker;
	const char *servername;
	const char *address_strings[6];
	struct callback_head rcu;
	const struct xprt_class *xprt_class;
	struct rpc_sysfs_xprt *xprt_sysfs;
	bool main;
};

struct rpc_xprt_iter_ops {
	void (*xpi_rewind)(struct rpc_xprt_iter *);
	struct rpc_xprt * (*xpi_xprt)(struct rpc_xprt_iter *);
	struct rpc_xprt * (*xpi_next)(struct rpc_xprt_iter *);
};

struct rpc_xprt_ops {
	void (*set_buffer_size)(struct rpc_xprt *, size_t, size_t);
	int (*reserve_xprt)(struct rpc_xprt *, struct rpc_task *);
	void (*release_xprt)(struct rpc_xprt *, struct rpc_task *);
	void (*alloc_slot)(struct rpc_xprt *, struct rpc_task *);
	void (*free_slot)(struct rpc_xprt *, struct rpc_rqst *);
	void (*rpcbind)(struct rpc_task *);
	void (*set_port)(struct rpc_xprt *, short unsigned int);
	void (*connect)(struct rpc_xprt *, struct rpc_task *);
	int (*get_srcaddr)(struct rpc_xprt *, char *, size_t);
	short unsigned int (*get_srcport)(struct rpc_xprt *);
	int (*buf_alloc)(struct rpc_task *);
	void (*buf_free)(struct rpc_task *);
	int (*prepare_request)(struct rpc_rqst *, struct xdr_buf *);
	int (*send_request)(struct rpc_rqst *);
	void (*abort_send_request)(struct rpc_rqst *);
	void (*wait_for_reply_request)(struct rpc_task *);
	void (*timer)(struct rpc_xprt *, struct rpc_task *);
	void (*release_request)(struct rpc_task *);
	void (*close)(struct rpc_xprt *);
	void (*destroy)(struct rpc_xprt *);
	void (*set_connect_timeout)(struct rpc_xprt *, long unsigned int, long unsigned int);
	void (*print_stats)(struct rpc_xprt *, struct seq_file *);
	int (*enable_swap)(struct rpc_xprt *);
	void (*disable_swap)(struct rpc_xprt *);
	void (*inject_disconnect)(struct rpc_xprt *);
	int (*bc_setup)(struct rpc_xprt *, unsigned int);
	size_t (*bc_maxpayload)(struct rpc_xprt *);
	unsigned int (*bc_num_slots)(struct rpc_xprt *);
	void (*bc_free_rqst)(struct rpc_rqst *);
	void (*bc_destroy)(struct rpc_xprt *, unsigned int);
};

struct rpc_xprt_switch {
	spinlock_t xps_lock;
	struct kref xps_kref;
	unsigned int xps_id;
	unsigned int xps_nxprts;
	unsigned int xps_nactive;
	unsigned int xps_nunique_destaddr_xprts;
	atomic_long_t xps_queuelen;
	struct list_head xps_xprt_list;
	struct net *xps_net;
	const struct rpc_xprt_iter_ops *xps_iter_ops;
	struct rpc_sysfs_xprt_switch *xps_sysfs;
	struct callback_head xps_rcu;
};

struct rpcb_info {
	u32 rpc_vers;
	const struct rpc_procinfo *rpc_proc;
};

struct rpcbind_args {
	struct rpc_xprt *r_xprt;
	u32 r_prog;
	u32 r_vers;
	u32 r_prot;
	short unsigned int r_port;
	const char *r_netid;
	const char *r_addr;
	const char *r_owner;
	int r_status;
};

struct rps_dev_flow {
	u16 cpu;
	u16 filter;
	unsigned int last_qtail;
};

struct rps_dev_flow_table {
	unsigned int mask;
	struct callback_head rcu;
	struct rps_dev_flow flows[0];
};

struct rps_map {
	unsigned int len;
	struct callback_head rcu;
	u16 cpus[0];
};

struct rps_sock_flow_table {
	u32 mask;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	u32 ents[0];
};

struct rt_prio_array {
	long unsigned int bitmap[2];
	struct list_head queue[100];
};

struct rt_rq {
	struct rt_prio_array active;
	unsigned int rt_nr_running;
	unsigned int rr_nr_running;
	struct {
		int curr;
		int next;
	} highest_prio;
	bool overloaded;
	struct plist_head pushable_tasks;
	int rt_queued;
};

struct sched_dl_entity;

typedef bool (*dl_server_has_tasks_f)(struct sched_dl_entity *);

typedef struct task_struct * (*dl_server_pick_f)(struct sched_dl_entity *);

struct sched_dl_entity {
	struct rb_node rb_node;
	u64 dl_runtime;
	u64 dl_deadline;
	u64 dl_period;
	u64 dl_bw;
	u64 dl_density;
	s64 runtime;
	u64 deadline;
	unsigned int flags;
	unsigned int dl_throttled: 1;
	unsigned int dl_yielded: 1;
	unsigned int dl_non_contending: 1;
	unsigned int dl_overrun: 1;
	unsigned int dl_server: 1;
	unsigned int dl_server_active: 1;
	unsigned int dl_defer: 1;
	unsigned int dl_defer_armed: 1;
	unsigned int dl_defer_running: 1;
	struct hrtimer dl_timer;
	struct hrtimer inactive_timer;
	struct rq *rq;
	dl_server_has_tasks_f server_has_tasks;
	dl_server_pick_f server_pick_task;
	struct sched_dl_entity *pi_se;
};

struct sched_info {
	long unsigned int pcount;
	long long unsigned int run_delay;
	long long unsigned int max_run_delay;
	long long unsigned int min_run_delay;
	long long unsigned int last_arrival;
	long long unsigned int last_queued;
};

struct rq {
	raw_spinlock_t __lock;
	unsigned int nr_running;
	long unsigned int last_blocked_load_update_tick;
	unsigned int has_blocked_load;
	long: 64;
	call_single_data_t nohz_csd;
	unsigned int nohz_tick_stopped;
	atomic_t nohz_flags;
	unsigned int ttwu_pending;
	u64 nr_switches;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct cfs_rq cfs;
	struct rt_rq rt;
	struct dl_rq dl;
	struct sched_dl_entity fair_server;
	struct list_head leaf_cfs_rq_list;
	struct list_head *tmp_alone_branch;
	unsigned int nr_uninterruptible;
	union {
		struct task_struct *donor;
		struct task_struct *curr;
	};
	struct sched_dl_entity *dl_server;
	struct task_struct *idle;
	struct task_struct *stop;
	long unsigned int next_balance;
	struct mm_struct *prev_mm;
	unsigned int clock_update_flags;
	u64 clock;
	u64 clock_task;
	u64 clock_pelt;
	long unsigned int lost_idle_time;
	u64 clock_pelt_idle;
	u64 clock_idle;
	atomic_t nr_iowait;
	int membarrier_state;
	struct root_domain *rd;
	struct sched_domain *sd;
	long unsigned int cpu_capacity;
	struct balance_callback *balance_callback;
	unsigned char nohz_idle_balance;
	unsigned char idle_balance;
	long unsigned int misfit_task_load;
	int active_balance;
	int push_cpu;
	struct cpu_stop_work active_balance_work;
	int cpu;
	int online;
	struct list_head cfs_tasks;
	long: 64;
	long: 64;
	struct sched_avg avg_rt;
	struct sched_avg avg_dl;
	u64 idle_stamp;
	u64 avg_idle;
	u64 max_idle_balance_cost;
	struct rcuwait hotplug_wait;
	u64 prev_steal_time;
	long unsigned int calc_load_update;
	long int calc_load_active;
	long: 64;
	call_single_data_t hrtick_csd;
	struct hrtimer hrtick_timer;
	ktime_t hrtick_time;
	struct sched_info rq_sched_info;
	long long unsigned int rq_cpu_time;
	unsigned int yld_count;
	unsigned int sched_count;
	unsigned int sched_goidle;
	unsigned int ttwu_count;
	unsigned int ttwu_local;
	struct cpuidle_state *idle_state;
	unsigned int nr_pinned;
	unsigned int push_busy;
	struct cpu_stop_work push_work;
	cpumask_var_t scratch_mask;
};

struct rq_depth {
	unsigned int max_depth;
	int scale_step;
	bool scaled_max;
	unsigned int queue_depth;
	unsigned int default_depth;
};

struct rq_iter_data {
	struct blk_mq_hw_ctx *hctx;
	bool has_rq;
};

struct rq_map_data {
	struct page **pages;
	long unsigned int offset;
	short unsigned int page_order;
	short unsigned int nr_entries;
	bool null_mapped;
	bool from_user;
};

struct rq_qos_ops {
	void (*throttle)(struct rq_qos *, struct bio *);
	void (*track)(struct rq_qos *, struct request *, struct bio *);
	void (*merge)(struct rq_qos *, struct request *, struct bio *);
	void (*issue)(struct rq_qos *, struct request *);
	void (*requeue)(struct rq_qos *, struct request *);
	void (*done)(struct rq_qos *, struct request *);
	void (*done_bio)(struct rq_qos *, struct bio *);
	void (*cleanup)(struct rq_qos *, struct bio *);
	void (*queue_depth_changed)(struct rq_qos *);
	void (*exit)(struct rq_qos *);
	const struct blk_mq_debugfs_attr *debugfs_attrs;
};

typedef bool acquire_inflight_cb_t(struct rq_wait *, void *);

struct rq_qos_wait_data {
	struct wait_queue_entry wq;
	struct task_struct *task;
	struct rq_wait *rqw;
	acquire_inflight_cb_t *cb;
	void *private_data;
	bool got_token;
};

struct rs_msg {
	struct icmp6hdr icmph;
	__u8 opt[0];
};

struct rsa_key {
	const u8 *n;
	const u8 *e;
	const u8 *d;
	const u8 *p;
	const u8 *q;
	const u8 *dp;
	const u8 *dq;
	const u8 *qinv;
	size_t n_sz;
	size_t e_sz;
	size_t d_sz;
	size_t p_sz;
	size_t q_sz;
	size_t dp_sz;
	size_t dq_sz;
	size_t qinv_sz;
};

struct rsa_mpi_key {
	MPI n;
	MPI e;
	MPI d;
	MPI p;
	MPI q;
	MPI dp;
	MPI dq;
	MPI qinv;
};

struct rsassa_pkcs1_ctx {
	struct crypto_akcipher *child;
	unsigned int key_size;
};

struct rsassa_pkcs1_inst_ctx {
	struct crypto_akcipher_spawn spawn;
	const struct hash_prefix *hash_prefix;
};

struct rsc {
	struct cache_head h;
	struct xdr_netobj handle;
	struct svc_cred cred;
	struct gss_svc_seq_data seqdata;
	struct gss_ctx *mechctx;
	struct callback_head callback_head;
};

struct rseq {
	__u32 cpu_id_start;
	__u32 cpu_id;
	__u64 rseq_cs;
	__u32 flags;
	__u32 node_id;
	__u32 mm_cid;
	char end[0];
};

struct rseq_cs {
	__u32 version;
	__u32 flags;
	__u64 start_ip;
	__u64 post_commit_offset;
	__u64 abort_ip;
};

struct rsi {
	struct cache_head h;
	struct xdr_netobj in_handle;
	struct xdr_netobj in_token;
	struct xdr_netobj out_handle;
	struct xdr_netobj out_token;
	int major_status;
	int minor_status;
	struct callback_head callback_head;
};

struct rss_nl_dump_ctx {
	long unsigned int ifindex;
	long unsigned int ctx_idx;
	unsigned int match_ifindex;
	unsigned int start_ctx;
};

struct rss_reply_data {
	struct ethnl_reply_data base;
	bool no_key_fields;
	u32 indir_size;
	u32 hkey_size;
	u32 hfunc;
	u32 input_xfrm;
	u32 *indir_table;
	u8 *hkey;
};

struct rss_req_info {
	struct ethnl_req_info base;
	u32 rss_context;
};

struct rsvd_count {
	int ndelayed;
	bool first_do_lblk_found;
	ext4_lblk_t first_do_lblk;
	ext4_lblk_t last_do_lblk;
	struct extent_status *left_es;
	bool partial;
	ext4_lblk_t lclu;
};

struct rt0_hdr {
	struct ipv6_rt_hdr rt_hdr;
	__u32 reserved;
	struct in6_addr addr[0];
};

struct rt6_exception {
	struct hlist_node hlist;
	struct rt6_info *rt6i;
	long unsigned int stamp;
	struct callback_head rcu;
};

struct rt6_exception_bucket {
	struct hlist_head chain;
	int depth;
};

struct rt6_info {
	struct dst_entry dst;
	struct fib6_info *from;
	int sernum;
	struct rt6key rt6i_dst;
	struct rt6key rt6i_src;
	struct in6_addr rt6i_gateway;
	struct inet6_dev *rt6i_idev;
	u32 rt6i_flags;
	short unsigned int rt6i_nfheader_len;
};

struct rt6_mtu_change_arg {
	struct net_device *dev;
	unsigned int mtu;
	struct fib6_info *f6i;
};

struct rt6_nh {
	struct fib6_info *fib6_info;
	struct fib6_config r_cfg;
	struct list_head next;
};

struct rt6_rtnl_dump_arg {
	struct sk_buff *skb;
	struct netlink_callback *cb;
	struct net *net;
	struct fib_dump_filter filter;
};

struct rt6_statistics {
	__u32 fib_nodes;
	__u32 fib_route_nodes;
	__u32 fib_rt_entries;
	__u32 fib_rt_cache;
	__u32 fib_discarded_routes;
	atomic_t fib_rt_alloc;
};

struct rt_cache_stat {
	unsigned int in_slow_tot;
	unsigned int in_slow_mc;
	unsigned int in_no_route;
	unsigned int in_brd;
	unsigned int in_martian_dst;
	unsigned int in_martian_src;
	unsigned int out_slow_tot;
	unsigned int out_slow_mc;
};

struct rt_waiter_node {
	struct rb_node entry;
	int prio;
	u64 deadline;
};

struct rt_mutex_waiter {
	struct rt_waiter_node tree;
	struct rt_waiter_node pi_tree;
	struct task_struct *task;
	struct rt_mutex_base *lock;
	unsigned int wake_state;
	struct ww_acquire_ctx *ww_ctx;
};

struct sigaltstack {
	void *ss_sp;
	int ss_flags;
	__kernel_size_t ss_size;
};

typedef struct sigaltstack stack_t;

struct sigcontext_64 {
	__u64 r8;
	__u64 r9;
	__u64 r10;
	__u64 r11;
	__u64 r12;
	__u64 r13;
	__u64 r14;
	__u64 r15;
	__u64 di;
	__u64 si;
	__u64 bp;
	__u64 bx;
	__u64 dx;
	__u64 ax;
	__u64 cx;
	__u64 sp;
	__u64 ip;
	__u64 flags;
	__u16 cs;
	__u16 gs;
	__u16 fs;
	__u16 ss;
	__u64 err;
	__u64 trapno;
	__u64 oldmask;
	__u64 cr2;
	__u64 fpstate;
	__u64 reserved1[8];
};

struct ucontext {
	long unsigned int uc_flags;
	struct ucontext *uc_link;
	stack_t uc_stack;
	struct sigcontext_64 uc_mcontext;
	sigset_t uc_sigmask;
};

struct rt_sigframe {
	char *pretcode;
	struct ucontext uc;
	struct siginfo info;
};

struct sigcontext_32 {
	__u16 gs;
	__u16 __gsh;
	__u16 fs;
	__u16 __fsh;
	__u16 es;
	__u16 __esh;
	__u16 ds;
	__u16 __dsh;
	__u32 di;
	__u32 si;
	__u32 bp;
	__u32 sp;
	__u32 bx;
	__u32 dx;
	__u32 cx;
	__u32 ax;
	__u32 trapno;
	__u32 err;
	__u32 ip;
	__u16 cs;
	__u16 __csh;
	__u32 flags;
	__u32 sp_at_signal;
	__u16 ss;
	__u16 __ssh;
	__u32 fpstate;
	__u32 oldmask;
	__u32 cr2;
};

struct ucontext_ia32 {
	unsigned int uc_flags;
	unsigned int uc_link;
	compat_stack_t uc_stack;
	struct sigcontext_32 uc_mcontext;
	compat_sigset_t uc_sigmask;
};

struct rt_sigframe_ia32 {
	u32 pretcode;
	int sig;
	u32 pinfo;
	u32 puc;
	compat_siginfo_t info;
	struct ucontext_ia32 uc;
	char retcode[8];
};

struct wake_q_node;

struct wake_q_head {
	struct wake_q_node *first;
	struct wake_q_node **lastp;
};

struct rt_wake_q_head {
	struct wake_q_head head;
	struct task_struct *rtlock_task;
};

struct rta_cacheinfo {
	__u32 rta_clntref;
	__u32 rta_lastuse;
	__s32 rta_expires;
	__u32 rta_error;
	__u32 rta_used;
	__u32 rta_id;
	__u32 rta_ts;
	__u32 rta_tsage;
};

struct rta_mfc_stats {
	__u64 mfcs_packets;
	__u64 mfcs_bytes;
	__u64 mfcs_wrong_if;
};

struct rtable {
	struct dst_entry dst;
	int rt_genid;
	unsigned int rt_flags;
	__u16 rt_type;
	__u8 rt_is_input;
	__u8 rt_uses_gateway;
	int rt_iif;
	u8 rt_gw_family;
	union {
		__be32 rt_gw4;
		struct in6_addr rt_gw6;
	};
	u32 rt_mtu_locked: 1;
	u32 rt_pmtu: 31;
};

struct rtc_param;

struct rtc_class_ops {
	int (*ioctl)(struct device *, unsigned int, long unsigned int);
	int (*read_time)(struct device *, struct rtc_time *);
	int (*set_time)(struct device *, struct rtc_time *);
	int (*read_alarm)(struct device *, struct rtc_wkalrm *);
	int (*set_alarm)(struct device *, struct rtc_wkalrm *);
	int (*proc)(struct device *, struct seq_file *);
	int (*alarm_irq_enable)(struct device *, unsigned int);
	int (*read_offset)(struct device *, long int *);
	int (*set_offset)(struct device *, long int);
	int (*param_get)(struct device *, struct rtc_param *);
	int (*param_set)(struct device *, struct rtc_param *);
};

struct rtc_timer {
	struct timerqueue_node node;
	ktime_t period;
	void (*func)(struct rtc_device *);
	struct rtc_device *rtc;
	int enabled;
};

struct rtc_device {
	struct device dev;
	struct module *owner;
	int id;
	const struct rtc_class_ops *ops;
	struct mutex ops_lock;
	struct cdev char_dev;
	long unsigned int flags;
	long unsigned int irq_data;
	spinlock_t irq_lock;
	wait_queue_head_t irq_queue;
	struct fasync_struct *async_queue;
	int irq_freq;
	int max_user_freq;
	struct timerqueue_head timerqueue;
	struct rtc_timer aie_timer;
	struct rtc_timer uie_rtctimer;
	struct hrtimer pie_timer;
	int pie_enabled;
	struct work_struct irqwork;
	long unsigned int set_offset_nsec;
	long unsigned int features[1];
	time64_t range_min;
	timeu64_t range_max;
	timeu64_t alarm_offset_max;
	time64_t start_secs;
	time64_t offset_secs;
	bool set_start_time;
};

struct rtc_param {
	__u64 param;
	union {
		__u64 uvalue;
		__s64 svalue;
		__u64 ptr;
	};
	__u32 index;
	__u32 __pad;
};

struct rtentry {
	long unsigned int rt_pad1;
	struct sockaddr rt_dst;
	struct sockaddr rt_gateway;
	struct sockaddr rt_genmask;
	short unsigned int rt_flags;
	short int rt_pad2;
	long unsigned int rt_pad3;
	void *rt_pad4;
	short int rt_metric;
	char *rt_dev;
	long unsigned int rt_mtu;
	long unsigned int rt_window;
	short unsigned int rt_irtt;
};

struct rtgenmsg {
	unsigned char rtgen_family;
};

struct rtl8139_stats {
	u64 packets;
	u64 bytes;
	struct u64_stats_sync syncp;
};

struct rtl_extra_stats {
	long unsigned int early_rx;
	long unsigned int tx_buf_mapped;
	long unsigned int tx_timeouts;
	long unsigned int rx_lost_in_ring;
};

struct rtl8139_private {
	void *mmio_addr;
	int drv_flags;
	struct pci_dev *pci_dev;
	u32 msg_enable;
	struct napi_struct napi;
	struct net_device *dev;
	unsigned char *rx_ring;
	unsigned int cur_rx;
	struct rtl8139_stats rx_stats;
	dma_addr_t rx_ring_dma;
	unsigned int tx_flag;
	long unsigned int cur_tx;
	long unsigned int dirty_tx;
	struct rtl8139_stats tx_stats;
	unsigned char *tx_buf[4];
	unsigned char *tx_bufs;
	dma_addr_t tx_bufs_dma;
	signed char phys[4];
	char twistie;
	char twist_row;
	char twist_col;
	unsigned int watchdog_fired: 1;
	unsigned int default_port: 4;
	unsigned int have_thread: 1;
	spinlock_t lock;
	spinlock_t rx_lock;
	chip_t chipset;
	u32 rx_config;
	struct rtl_extra_stats xstats;
	struct delayed_work thread;
	struct mii_if_info mii;
	unsigned int regs_len;
	long unsigned int fifo_copy_timeout;
};

struct rtl8169_counters {
	__le64 tx_packets;
	__le64 rx_packets;
	__le64 tx_errors;
	__le32 rx_errors;
	__le16 rx_missed;
	__le16 align_errors;
	__le32 tx_one_collision;
	__le32 tx_multi_collision;
	__le64 rx_unicast;
	__le64 rx_broadcast;
	__le32 rx_multicast;
	__le16 tx_aborted;
	__le16 tx_underrun;
	__le64 tx_octets;
	__le64 rx_octets;
	__le64 rx_multicast64;
	__le64 tx_unicast64;
	__le64 tx_broadcast64;
	__le64 tx_multicast64;
	__le32 tx_pause_on;
	__le32 tx_pause_off;
	__le32 tx_pause_all;
	__le32 tx_deferred;
	__le32 tx_late_collision;
	__le32 tx_all_collision;
	__le32 tx_aborted32;
	__le32 align_errors32;
	__le32 rx_frame_too_long;
	__le32 rx_runt;
	__le32 rx_pause_on;
	__le32 rx_pause_off;
	__le32 rx_pause_all;
	__le32 rx_unknown_opcode;
	__le32 rx_mac_error;
	__le32 tx_underrun32;
	__le32 rx_mac_missed;
	__le32 rx_tcam_dropped;
	__le32 tdu;
	__le32 rdu;
};

struct rtl8169_tc_offsets {
	bool inited;
	__le64 tx_errors;
	__le32 tx_multi_collision;
	__le16 tx_aborted;
	__le16 rx_missed;
};

struct r8169_led_classdev;

struct rtl_fw;

struct rtl8169_private {
	void *mmio_addr;
	struct pci_dev *pci_dev;
	struct net_device *dev;
	struct phy_device *phydev;
	struct napi_struct napi;
	enum mac_version mac_version;
	enum rtl_dash_type dash_type;
	u32 cur_rx;
	u32 cur_tx;
	u32 dirty_tx;
	struct TxDesc *TxDescArray;
	struct RxDesc *RxDescArray;
	dma_addr_t TxPhyAddr;
	dma_addr_t RxPhyAddr;
	struct page *Rx_databuff[256];
	struct ring_info tx_skb[256];
	u16 cp_cmd;
	u16 tx_lpi_timer;
	u32 irq_mask;
	int irq;
	struct clk *clk;
	struct {
		long unsigned int flags[1];
		struct work_struct work;
	} wk;
	raw_spinlock_t mac_ocp_lock;
	struct mutex led_lock;
	unsigned int supports_gmii: 1;
	unsigned int aspm_manageable: 1;
	unsigned int dash_enabled: 1;
	dma_addr_t counters_phys_addr;
	struct rtl8169_counters *counters;
	struct rtl8169_tc_offsets tc_offset;
	u32 saved_wolopts;
	const char *fw_name;
	struct rtl_fw *rtl_fw;
	struct r8169_led_classdev *leds;
	u32 ocp_base;
};

struct rtl821x_priv {
	u16 phycr1;
	u16 phycr2;
	bool has_phycr2;
	struct clk *clk;
};

struct rtl_coalesce_info {
	u32 speed;
	u32 scale_nsecs[4];
};

struct rtl_cond {
	bool (*check)(struct rtl8169_private *);
	const char *msg;
};

typedef void (*rtl_fw_write_t)(struct rtl8169_private *, int, int);

typedef int (*rtl_fw_read_t)(struct rtl8169_private *, int);

struct rtl_fw_phy_action {
	__le32 *code;
	size_t size;
};

struct rtl_fw {
	rtl_fw_write_t phy_write;
	rtl_fw_read_t phy_read;
	rtl_fw_write_t mac_mcu_write;
	rtl_fw_read_t mac_mcu_read;
	const struct firmware *fw;
	const char *fw_name;
	struct device *dev;
	char version[32];
	struct rtl_fw_phy_action phy_action;
};

struct rtl_mac_info {
	u16 mask;
	u16 val;
	enum mac_version ver;
};

struct rtm_dump_res_bucket_ctx;

struct rtm_dump_nexthop_bucket_data {
	struct rtm_dump_res_bucket_ctx *ctx;
	struct nh_dump_filter filter;
};

struct rtm_dump_nh_ctx {
	u32 idx;
};

struct rtm_dump_res_bucket_ctx {
	struct rtm_dump_nh_ctx nh;
	u16 bucket_index;
};

struct rtmsg {
	unsigned char rtm_family;
	unsigned char rtm_dst_len;
	unsigned char rtm_src_len;
	unsigned char rtm_tos;
	unsigned char rtm_table;
	unsigned char rtm_protocol;
	unsigned char rtm_scope;
	unsigned char rtm_type;
	unsigned int rtm_flags;
};

struct rtnexthop {
	short unsigned int rtnh_len;
	unsigned char rtnh_flags;
	unsigned char rtnh_hops;
	int rtnh_ifindex;
};

struct rtnl_af_ops {
	struct list_head list;
	struct srcu_struct srcu;
	int family;
	int (*fill_link_af)(struct sk_buff *, const struct net_device *, u32);
	size_t (*get_link_af_size)(const struct net_device *, u32);
	int (*validate_link_af)(const struct net_device *, const struct nlattr *, struct netlink_ext_ack *);
	int (*set_link_af)(struct net_device *, const struct nlattr *, struct netlink_ext_ack *);
	int (*fill_stats_af)(struct sk_buff *, const struct net_device *);
	size_t (*get_stats_af_size)(const struct net_device *);
};

typedef int (*rtnl_doit_func)(struct sk_buff *, struct nlmsghdr *, struct netlink_ext_ack *);

typedef int (*rtnl_dumpit_func)(struct sk_buff *, struct netlink_callback *);

struct rtnl_link {
	rtnl_doit_func doit;
	rtnl_dumpit_func dumpit;
	struct module *owner;
	unsigned int flags;
	struct callback_head rcu;
};

struct rtnl_link_ifmap {
	__u64 mem_start;
	__u64 mem_end;
	__u64 base_addr;
	__u16 irq;
	__u8 dma;
	__u8 port;
};

struct rtnl_link_ops {
	struct list_head list;
	struct srcu_struct srcu;
	const char *kind;
	size_t priv_size;
	struct net_device * (*alloc)(struct nlattr **, const char *, unsigned char, unsigned int, unsigned int);
	void (*setup)(struct net_device *);
	bool netns_refund;
	const u16 peer_type;
	unsigned int maxtype;
	const struct nla_policy *policy;
	int (*validate)(struct nlattr **, struct nlattr **, struct netlink_ext_ack *);
	int (*newlink)(struct net *, struct net_device *, struct nlattr **, struct nlattr **, struct netlink_ext_ack *);
	int (*changelink)(struct net_device *, struct nlattr **, struct nlattr **, struct netlink_ext_ack *);
	void (*dellink)(struct net_device *, struct list_head *);
	size_t (*get_size)(const struct net_device *);
	int (*fill_info)(struct sk_buff *, const struct net_device *);
	size_t (*get_xstats_size)(const struct net_device *);
	int (*fill_xstats)(struct sk_buff *, const struct net_device *);
	unsigned int (*get_num_tx_queues)(void);
	unsigned int (*get_num_rx_queues)(void);
	unsigned int slave_maxtype;
	const struct nla_policy *slave_policy;
	int (*slave_changelink)(struct net_device *, struct net_device *, struct nlattr **, struct nlattr **, struct netlink_ext_ack *);
	size_t (*get_slave_size)(const struct net_device *, const struct net_device *);
	int (*fill_slave_info)(struct sk_buff *, const struct net_device *, const struct net_device *);
	struct net * (*get_link_net)(const struct net_device *);
	size_t (*get_linkxstats_size)(const struct net_device *, int);
	int (*fill_linkxstats)(struct sk_buff *, const struct net_device *, int *, int);
};

struct rtnl_link_stats {
	__u32 rx_packets;
	__u32 tx_packets;
	__u32 rx_bytes;
	__u32 tx_bytes;
	__u32 rx_errors;
	__u32 tx_errors;
	__u32 rx_dropped;
	__u32 tx_dropped;
	__u32 multicast;
	__u32 collisions;
	__u32 rx_length_errors;
	__u32 rx_over_errors;
	__u32 rx_crc_errors;
	__u32 rx_frame_errors;
	__u32 rx_fifo_errors;
	__u32 rx_missed_errors;
	__u32 tx_aborted_errors;
	__u32 tx_carrier_errors;
	__u32 tx_fifo_errors;
	__u32 tx_heartbeat_errors;
	__u32 tx_window_errors;
	__u32 rx_compressed;
	__u32 tx_compressed;
	__u32 rx_nohandler;
};

struct rtnl_mdb_dump_ctx {
	long int idx;
};

struct rtnl_msg_handler {
	struct module *owner;
	int protocol;
	int msgtype;
	rtnl_doit_func doit;
	rtnl_dumpit_func dumpit;
	int flags;
};

struct rtnl_net_dump_cb {
	struct net *tgt_net;
	struct net *ref_net;
	struct sk_buff *skb;
	struct net_fill_args fillargs;
	int idx;
	int s_idx;
};

struct rtnl_nets {
	struct net *net[3];
	unsigned char len;
};

struct rtnl_newlink_tbs {
	struct nlattr *tb[67];
	struct nlattr *linkinfo[6];
	struct nlattr *attr[51];
	struct nlattr *slave_attr[45];
};

struct rtnl_offload_xstats_request_used {
	bool request;
	bool used;
};

struct rtnl_stats_dump_filters {
	u32 mask[6];
};

struct rtree_node {
	struct list_head list;
	long unsigned int *data;
};

struct rtvia {
	__kernel_sa_family_t rtvia_family;
	__u8 rtvia_addr[0];
};

struct rusage {
	struct __kernel_old_timeval ru_utime;
	struct __kernel_old_timeval ru_stime;
	__kernel_long_t ru_maxrss;
	__kernel_long_t ru_ixrss;
	__kernel_long_t ru_idrss;
	__kernel_long_t ru_isrss;
	__kernel_long_t ru_minflt;
	__kernel_long_t ru_majflt;
	__kernel_long_t ru_nswap;
	__kernel_long_t ru_inblock;
	__kernel_long_t ru_oublock;
	__kernel_long_t ru_msgsnd;
	__kernel_long_t ru_msgrcv;
	__kernel_long_t ru_nsignals;
	__kernel_long_t ru_nvcsw;
	__kernel_long_t ru_nivcsw;
};

typedef struct rw_semaphore *class_rwsem_read_t;

typedef struct rw_semaphore *class_rwsem_write_t;

struct rwrt_feature_desc {
	__be16 feature_code;
	__u8 curr: 1;
	__u8 persistent: 1;
	__u8 feature_version: 4;
	__u8 reserved1: 2;
	__u8 add_len;
	__u32 last_lba;
	__u32 block_size;
	__u16 blocking;
	__u8 page_present: 1;
	__u8 reserved2: 7;
	__u8 reserved3;
};

struct rwsem_waiter {
	struct list_head list;
	struct task_struct *task;
	enum rwsem_waiter_type type;
	long unsigned int timeout;
	bool handoff_set;
};

struct rx {
	struct rx *next;
	struct rx *prev;
	struct sk_buff *skb;
	dma_addr_t dma_addr;
};

struct rx_queue_attribute {
	struct attribute attr;
	ssize_t (*show)(struct netdev_rx_queue *, char *);
	ssize_t (*store)(struct netdev_rx_queue *, const char *, size_t);
};

struct rx_ring_info {
	struct sk_buff *skb;
	dma_addr_t data_addr;
	__u32 data_size;
	dma_addr_t frag_addr[2];
};

struct s3_save {
	u32 command;
	u32 dev_nt;
	u64 dcbaa_ptr;
	u32 config_reg;
};

struct s_data {
	struct sched_domain **sd;
	struct root_domain *rd;
};

struct value_name_pair;

struct sa_name_list {
	int opcode;
	const struct value_name_pair *arr;
	int arr_sz;
};

struct sadb_alg {
	__u8 sadb_alg_id;
	__u8 sadb_alg_ivlen;
	__u16 sadb_alg_minbits;
	__u16 sadb_alg_maxbits;
	__u16 sadb_alg_reserved;
};

struct saved_alias {
	struct kmem_cache *s;
	const char *name;
	struct saved_alias *next;
};

struct saved_cmdlines_buffer {
	unsigned int map_pid_to_cmdline[32769];
	unsigned int *map_cmdline_to_pid;
	unsigned int cmdline_num;
	int cmdline_idx;
	char saved_cmdlines[0];
};

struct saved_msr;

struct saved_msrs {
	unsigned int num;
	struct saved_msr *array;
};

struct saved_context {
	struct pt_regs regs;
	u16 ds;
	u16 es;
	u16 fs;
	u16 gs;
	long unsigned int kernelmode_gs_base;
	long unsigned int usermode_gs_base;
	long unsigned int fs_base;
	long unsigned int cr0;
	long unsigned int cr2;
	long unsigned int cr3;
	long unsigned int cr4;
	u64 misc_enable;
	struct saved_msrs saved_msrs;
	long unsigned int efer;
	u16 gdt_pad;
	struct desc_ptr gdt_desc;
	u16 idt_pad;
	struct desc_ptr idt;
	u16 ldt;
	u16 tss;
	long unsigned int tr;
	long unsigned int safety;
	long unsigned int return_address;
	bool misc_enable_saved;
} __attribute__((packed));

struct saved_msr {
	bool valid;
	struct msr_info info;
};

struct saved_syn {
	u32 mac_hdrlen;
	u32 network_hdrlen;
	u32 tcp_hdrlen;
	u8 data[0];
};

struct sb_writers {
	short unsigned int frozen;
	int freeze_kcount;
	int freeze_ucount;
	struct percpu_rw_semaphore rw_sem[3];
};

struct sbitmap_word {
	long unsigned int word;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long unsigned int cleared;
	raw_spinlock_t swap_lock;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct sbq_wait_state {
	wait_queue_head_t wait;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct scan_area {
	u64 addr;
	u64 size;
};

struct scan_control {
	long unsigned int nr_to_reclaim;
	nodemask_t *nodemask;
	struct mem_cgroup *target_mem_cgroup;
	long unsigned int anon_cost;
	long unsigned int file_cost;
	unsigned int may_deactivate: 2;
	unsigned int force_deactivate: 1;
	unsigned int skipped_deactivate: 1;
	unsigned int may_writepage: 1;
	unsigned int may_unmap: 1;
	unsigned int may_swap: 1;
	unsigned int no_cache_trim_mode: 1;
	unsigned int cache_trim_mode_failed: 1;
	unsigned int proactive: 1;
	unsigned int memcg_low_reclaim: 1;
	unsigned int memcg_low_skipped: 1;
	unsigned int memcg_full_walk: 1;
	unsigned int hibernation_mode: 1;
	unsigned int compaction_ready: 1;
	unsigned int cache_trim_mode: 1;
	unsigned int file_is_tiny: 1;
	unsigned int no_demotion: 1;
	s8 order;
	s8 priority;
	s8 reclaim_idx;
	gfp_t gfp_mask;
	long unsigned int nr_scanned;
	long unsigned int nr_reclaimed;
	struct {
		unsigned int dirty;
		unsigned int unqueued_dirty;
		unsigned int congested;
		unsigned int writeback;
		unsigned int immediate;
		unsigned int file_taken;
		unsigned int taken;
	} nr;
	struct reclaim_state reclaim_state;
};

struct scatter_walk {
	struct scatterlist *sg;
	unsigned int offset;
};

struct sch_frag_data {
	long unsigned int dst;
	struct qdisc_skb_cb cb;
	__be16 inner_protocol;
	u16 vlan_tci;
	__be16 vlan_proto;
	unsigned int l2_len;
	u8 l2_data[18];
	int (*xmit)(struct sk_buff *);
};

struct sched_attr {
	__u32 size;
	__u32 sched_policy;
	__u64 sched_flags;
	__s32 sched_nice;
	__u32 sched_priority;
	__u64 sched_runtime;
	__u64 sched_deadline;
	__u64 sched_period;
	__u32 sched_util_min;
	__u32 sched_util_max;
};

struct sched_cache {
	struct list_head *priolist;
};

struct sched_class {
	void (*enqueue_task)(struct rq *, struct task_struct *, int);
	bool (*dequeue_task)(struct rq *, struct task_struct *, int);
	void (*yield_task)(struct rq *);
	bool (*yield_to_task)(struct rq *, struct task_struct *);
	void (*wakeup_preempt)(struct rq *, struct task_struct *, int);
	int (*balance)(struct rq *, struct task_struct *, struct rq_flags *);
	struct task_struct * (*pick_task)(struct rq *);
	struct task_struct * (*pick_next_task)(struct rq *, struct task_struct *);
	void (*put_prev_task)(struct rq *, struct task_struct *, struct task_struct *);
	void (*set_next_task)(struct rq *, struct task_struct *, bool);
	int (*select_task_rq)(struct task_struct *, int, int);
	void (*migrate_task_rq)(struct task_struct *, int);
	void (*task_woken)(struct rq *, struct task_struct *);
	void (*set_cpus_allowed)(struct task_struct *, struct affinity_context *);
	void (*rq_online)(struct rq *);
	void (*rq_offline)(struct rq *);
	struct rq * (*find_lock_rq)(struct task_struct *, struct rq *);
	void (*task_tick)(struct rq *, struct task_struct *, int);
	void (*task_fork)(struct task_struct *);
	void (*task_dead)(struct task_struct *);
	void (*switching_to)(struct rq *, struct task_struct *);
	void (*switched_from)(struct rq *, struct task_struct *);
	void (*switched_to)(struct rq *, struct task_struct *);
	void (*reweight_task)(struct rq *, struct task_struct *, const struct load_weight *);
	void (*prio_changed)(struct rq *, struct task_struct *, int);
	unsigned int (*get_rr_interval)(struct rq *, struct task_struct *);
	void (*update_curr)(struct rq *);
	void (*task_change_group)(struct task_struct *);
};

struct sched_clock_data {
	u64 tick_raw;
	u64 tick_gtod;
	u64 clock;
};

struct sched_group;

struct sched_domain_shared;

struct sched_domain {
	struct sched_domain *parent;
	struct sched_domain *child;
	struct sched_group *groups;
	long unsigned int min_interval;
	long unsigned int max_interval;
	unsigned int busy_factor;
	unsigned int imbalance_pct;
	unsigned int cache_nice_tries;
	unsigned int imb_numa_nr;
	int nohz_idle;
	int flags;
	int level;
	long unsigned int last_balance;
	unsigned int balance_interval;
	unsigned int nr_balance_failed;
	u64 max_newidle_lb_cost;
	long unsigned int last_decay_max_lb_cost;
	unsigned int lb_count[3];
	unsigned int lb_failed[3];
	unsigned int lb_balanced[3];
	unsigned int lb_imbalance_load[3];
	unsigned int lb_imbalance_util[3];
	unsigned int lb_imbalance_task[3];
	unsigned int lb_imbalance_misfit[3];
	unsigned int lb_gained[3];
	unsigned int lb_hot_gained[3];
	unsigned int lb_nobusyg[3];
	unsigned int lb_nobusyq[3];
	unsigned int alb_count;
	unsigned int alb_failed;
	unsigned int alb_pushed;
	unsigned int sbe_count;
	unsigned int sbe_balanced;
	unsigned int sbe_pushed;
	unsigned int sbf_count;
	unsigned int sbf_balanced;
	unsigned int sbf_pushed;
	unsigned int ttwu_wake_remote;
	unsigned int ttwu_move_affine;
	unsigned int ttwu_move_balance;
	char *name;
	union {
		void *private;
		struct callback_head rcu;
	};
	struct sched_domain_shared *shared;
	unsigned int span_weight;
	long unsigned int span[0];
};

struct sched_domain_attr {
	int relax_domain_level;
};

struct sched_domain_shared {
	atomic_t ref;
	atomic_t nr_busy_cpus;
	int has_idle_cores;
	int nr_idle_scan;
};

typedef const struct cpumask * (*sched_domain_mask_f)(int);

typedef int (*sched_domain_flags_f)(void);

struct sched_group_capacity;

struct sd_data {
	struct sched_domain **sd;
	struct sched_domain_shared **sds;
	struct sched_group **sg;
	struct sched_group_capacity **sgc;
};

struct sched_domain_topology_level {
	sched_domain_mask_f mask;
	sched_domain_flags_f sd_flags;
	int flags;
	int numa_level;
	struct sd_data data;
	char *name;
};

struct sched_entity {
	struct load_weight load;
	struct rb_node run_node;
	u64 deadline;
	u64 min_vruntime;
	u64 min_slice;
	struct list_head group_node;
	unsigned char on_rq;
	unsigned char sched_delayed;
	unsigned char rel_deadline;
	unsigned char custom_slice;
	u64 exec_start;
	u64 sum_exec_runtime;
	u64 prev_sum_exec_runtime;
	u64 vruntime;
	s64 vlag;
	u64 slice;
	u64 nr_migrations;
	int depth;
	struct sched_entity *parent;
	struct cfs_rq *cfs_rq;
	struct cfs_rq *my_q;
	long unsigned int runnable_weight;
	long: 64;
	struct sched_avg avg;
};

struct sched_statistics {
	u64 wait_start;
	u64 wait_max;
	u64 wait_count;
	u64 wait_sum;
	u64 iowait_count;
	u64 iowait_sum;
	u64 sleep_start;
	u64 sleep_max;
	s64 sum_sleep_runtime;
	u64 block_start;
	u64 block_max;
	s64 sum_block_runtime;
	s64 exec_max;
	u64 slice_max;
	u64 nr_migrations_cold;
	u64 nr_failed_migrations_affine;
	u64 nr_failed_migrations_running;
	u64 nr_failed_migrations_hot;
	u64 nr_forced_migrations;
	u64 nr_wakeups;
	u64 nr_wakeups_sync;
	u64 nr_wakeups_migrate;
	u64 nr_wakeups_local;
	u64 nr_wakeups_remote;
	u64 nr_wakeups_affine;
	u64 nr_wakeups_affine_attempts;
	u64 nr_wakeups_passive;
	u64 nr_wakeups_idle;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct sched_entity_stats {
	struct sched_entity se;
	struct sched_statistics stats;
};

struct sched_group {
	struct sched_group *next;
	atomic_t ref;
	unsigned int group_weight;
	unsigned int cores;
	struct sched_group_capacity *sgc;
	int asym_prefer_cpu;
	int flags;
	long unsigned int cpumask[0];
};

struct sched_group_capacity {
	atomic_t ref;
	long unsigned int capacity;
	long unsigned int min_capacity;
	long unsigned int max_capacity;
	long unsigned int next_update;
	int imbalance;
	long unsigned int cpumask[0];
};

struct sched_param {
	int sched_priority;
};

struct sched_rt_entity {
	struct list_head run_list;
	long unsigned int timeout;
	long unsigned int watchdog_stamp;
	unsigned int time_slice;
	short unsigned int on_rq;
	short unsigned int on_list;
	struct sched_rt_entity *back;
};

struct scheduling_policy {
	u32 max_words;
	u32 num_words;
	u32 count;
	struct guc_update_scheduling_policy h2g;
};

struct scm_fp_list;

struct scm_cookie {
	struct pid *pid;
	struct scm_fp_list *fp;
	struct scm_creds creds;
	u32 secid;
};

struct unix_edge;

struct scm_fp_list {
	short int count;
	short int count_unix;
	short int max;
	bool inflight;
	bool dead;
	struct list_head vertices;
	struct unix_edge *edges;
	struct user_struct *user;
	struct file *fp[253];
};

struct scm_stat {
	atomic_t nr_fds;
	long unsigned int nr_unix_fds;
};

struct scm_timestamping {
	struct __kernel_old_timespec ts[3];
};

struct scm_timestamping64 {
	struct __kernel_timespec ts[3];
};

struct scm_timestamping_internal {
	struct timespec64 ts[3];
};

struct scm_ts_pktinfo {
	__u32 if_index;
	__u32 pkt_length;
	__u32 reserved[2];
};

struct scomp_alg {
	void * (*alloc_ctx)(struct crypto_scomp *);
	void (*free_ctx)(struct crypto_scomp *, void *);
	int (*compress)(struct crypto_scomp *, const u8 *, unsigned int, u8 *, unsigned int *, void *);
	int (*decompress)(struct crypto_scomp *, const u8 *, unsigned int, u8 *, unsigned int *, void *);
	union {
		struct {
			struct crypto_alg base;
		};
		struct comp_alg_common calg;
	};
};

struct scomp_scratch {
	spinlock_t lock;
	void *src;
	void *dst;
};

struct scratches_to_free {
	struct callback_head rcu;
	unsigned int cnt;
	void *scratches[0];
};

struct scsi_cd {
	unsigned int capacity;
	struct scsi_device *device;
	unsigned int vendor;
	long unsigned int ms_offset;
	unsigned int writeable: 1;
	unsigned int use: 1;
	unsigned int xa_flag: 1;
	unsigned int readcd_known: 1;
	unsigned int readcd_cdda: 1;
	unsigned int media_present: 1;
	int tur_mismatch;
	bool tur_changed: 1;
	bool get_event_changed: 1;
	bool ignore_get_event: 1;
	struct cdrom_device_info cdi;
	struct mutex lock;
	struct gendisk *disk;
};

typedef struct scsi_cd Scsi_CD;

struct scsi_data_buffer {
	struct sg_table table;
	unsigned int length;
};

struct scsi_cmnd {
	struct scsi_device *device;
	struct list_head eh_entry;
	struct delayed_work abort_work;
	struct callback_head rcu;
	int eh_eflags;
	int budget_token;
	long unsigned int jiffies_at_alloc;
	int retries;
	int allowed;
	unsigned char prot_op;
	unsigned char prot_type;
	unsigned char prot_flags;
	enum scsi_cmnd_submitter submitter;
	short unsigned int cmd_len;
	enum dma_data_direction sc_data_direction;
	unsigned char cmnd[32];
	struct scsi_data_buffer sdb;
	struct scsi_data_buffer *prot_sdb;
	unsigned int underflow;
	unsigned int transfersize;
	unsigned int resid_len;
	unsigned int sense_len;
	unsigned char *sense_buffer;
	int flags;
	long unsigned int state;
	unsigned int extra_len;
	unsigned char *host_scribble;
	int result;
};

struct scsi_dev_info_list {
	struct list_head dev_info_list;
	char vendor[8];
	char model[16];
	blist_flags_t flags;
	unsigned int compatible;
};

struct scsi_dev_info_list_table {
	struct list_head node;
	struct list_head scsi_dev_info_list;
	const char *name;
	int key;
};

struct scsi_vpd;

struct scsi_target;

struct scsi_device_handler;

struct scsi_device {
	struct Scsi_Host *host;
	struct request_queue *request_queue;
	struct list_head siblings;
	struct list_head same_target_siblings;
	struct sbitmap budget_map;
	atomic_t device_blocked;
	atomic_t restarts;
	spinlock_t list_lock;
	struct list_head starved_entry;
	short unsigned int queue_depth;
	short unsigned int max_queue_depth;
	short unsigned int last_queue_full_depth;
	short unsigned int last_queue_full_count;
	long unsigned int last_queue_full_time;
	long unsigned int queue_ramp_up_period;
	long unsigned int last_queue_ramp_up;
	unsigned int id;
	unsigned int channel;
	u64 lun;
	unsigned int manufacturer;
	unsigned int sector_size;
	void *hostdata;
	unsigned char type;
	char scsi_level;
	char inq_periph_qual;
	struct mutex inquiry_mutex;
	unsigned char inquiry_len;
	unsigned char *inquiry;
	const char *vendor;
	const char *model;
	const char *rev;
	struct scsi_vpd *vpd_pg0;
	struct scsi_vpd *vpd_pg83;
	struct scsi_vpd *vpd_pg80;
	struct scsi_vpd *vpd_pg89;
	struct scsi_vpd *vpd_pgb0;
	struct scsi_vpd *vpd_pgb1;
	struct scsi_vpd *vpd_pgb2;
	struct scsi_vpd *vpd_pgb7;
	struct scsi_target *sdev_target;
	blist_flags_t sdev_bflags;
	unsigned int eh_timeout;
	unsigned int manage_system_start_stop: 1;
	unsigned int manage_runtime_start_stop: 1;
	unsigned int manage_shutdown: 1;
	unsigned int force_runtime_start_on_system_start: 1;
	unsigned int removable: 1;
	unsigned int changed: 1;
	unsigned int busy: 1;
	unsigned int lockable: 1;
	unsigned int locked: 1;
	unsigned int borken: 1;
	unsigned int disconnect: 1;
	unsigned int soft_reset: 1;
	unsigned int sdtr: 1;
	unsigned int wdtr: 1;
	unsigned int ppr: 1;
	unsigned int tagged_supported: 1;
	unsigned int simple_tags: 1;
	unsigned int was_reset: 1;
	unsigned int expecting_cc_ua: 1;
	unsigned int use_10_for_rw: 1;
	unsigned int use_10_for_ms: 1;
	unsigned int set_dbd_for_ms: 1;
	unsigned int read_before_ms: 1;
	unsigned int no_report_opcodes: 1;
	unsigned int no_write_same: 1;
	unsigned int use_16_for_rw: 1;
	unsigned int use_16_for_sync: 1;
	unsigned int skip_ms_page_8: 1;
	unsigned int skip_ms_page_3f: 1;
	unsigned int skip_vpd_pages: 1;
	unsigned int try_vpd_pages: 1;
	unsigned int use_192_bytes_for_3f: 1;
	unsigned int no_start_on_add: 1;
	unsigned int allow_restart: 1;
	unsigned int start_stop_pwr_cond: 1;
	unsigned int no_uld_attach: 1;
	unsigned int select_no_atn: 1;
	unsigned int fix_capacity: 1;
	unsigned int guess_capacity: 1;
	unsigned int retry_hwerror: 1;
	unsigned int last_sector_bug: 1;
	unsigned int no_read_disc_info: 1;
	unsigned int no_read_capacity_16: 1;
	unsigned int try_rc_10_first: 1;
	unsigned int security_supported: 1;
	unsigned int is_visible: 1;
	unsigned int wce_default_on: 1;
	unsigned int no_dif: 1;
	unsigned int broken_fua: 1;
	unsigned int lun_in_cdb: 1;
	unsigned int unmap_limit_for_ws: 1;
	unsigned int rpm_autosuspend: 1;
	unsigned int ignore_media_change: 1;
	unsigned int silence_suspend: 1;
	unsigned int no_vpd_size: 1;
	unsigned int cdl_supported: 1;
	unsigned int cdl_enable: 1;
	unsigned int queue_stopped;
	bool offline_already;
	atomic_t disk_events_disable_depth;
	long unsigned int supported_events[1];
	long unsigned int pending_events[1];
	struct list_head event_list;
	struct work_struct event_work;
	unsigned int max_device_blocked;
	atomic_t iorequest_cnt;
	atomic_t iodone_cnt;
	atomic_t ioerr_cnt;
	atomic_t iotmo_cnt;
	struct device sdev_gendev;
	struct device sdev_dev;
	struct work_struct requeue_work;
	struct scsi_device_handler *handler;
	void *handler_data;
	size_t dma_drain_len;
	void *dma_drain_buf;
	unsigned int sg_timeout;
	unsigned int sg_reserved_size;
	struct bsg_device *bsg_dev;
	unsigned char access_state;
	struct mutex state_mutex;
	enum scsi_device_state sdev_state;
	struct task_struct *quiesced_by;
	long unsigned int sdev_data[0];
};

typedef void (*activate_complete)(void *, int);

struct scsi_device_handler {
	struct list_head list;
	struct module *module;
	const char *name;
	enum scsi_disposition (*check_sense)(struct scsi_device *, struct scsi_sense_hdr *);
	int (*attach)(struct scsi_device *);
	void (*detach)(struct scsi_device *);
	int (*activate)(struct scsi_device *, activate_complete, void *);
	blk_status_t (*prep_fn)(struct scsi_device *, struct request *);
	int (*set_params)(struct scsi_device *, const char *);
	void (*rescan)(struct scsi_device *);
};

struct opal_dev;

struct scsi_disk {
	struct scsi_device *device;
	struct device disk_dev;
	struct gendisk *disk;
	struct opal_dev *opal_dev;
	atomic_t openers;
	sector_t capacity;
	int max_retries;
	u32 min_xfer_blocks;
	u32 max_xfer_blocks;
	u32 opt_xfer_blocks;
	u32 max_ws_blocks;
	u32 max_unmap_blocks;
	u32 unmap_granularity;
	u32 unmap_alignment;
	u32 max_atomic;
	u32 atomic_alignment;
	u32 atomic_granularity;
	u32 max_atomic_with_boundary;
	u32 max_atomic_boundary;
	u32 index;
	unsigned int physical_block_size;
	unsigned int max_medium_access_timeouts;
	unsigned int medium_access_timed_out;
	u16 permanent_stream_count;
	u8 media_present;
	u8 write_prot;
	u8 protection_type;
	u8 provisioning_mode;
	u8 zeroing_mode;
	u8 nr_actuators;
	bool suspended;
	unsigned int ATO: 1;
	unsigned int cache_override: 1;
	unsigned int WCE: 1;
	unsigned int RCD: 1;
	unsigned int DPOFUA: 1;
	unsigned int first_scan: 1;
	unsigned int lbpme: 1;
	unsigned int lbprz: 1;
	unsigned int lbpu: 1;
	unsigned int lbpws: 1;
	unsigned int lbpws10: 1;
	unsigned int lbpvpd: 1;
	unsigned int ws10: 1;
	unsigned int ws16: 1;
	unsigned int rc_basis: 2;
	unsigned int zoned: 2;
	unsigned int urswrz: 1;
	unsigned int security: 1;
	unsigned int ignore_medium_access_errors: 1;
	unsigned int rscs: 1;
	unsigned int use_atomic_write_boundary: 1;
};

struct scsi_driver {
	struct device_driver gendrv;
	int (*resume)(struct device *);
	void (*rescan)(struct device *);
	blk_status_t (*init_command)(struct scsi_cmnd *);
	void (*uninit_command)(struct scsi_cmnd *);
	int (*done)(struct scsi_cmnd *);
	int (*eh_action)(struct scsi_cmnd *, int);
	void (*eh_reset)(struct scsi_cmnd *);
};

struct scsi_eh_save {
	int result;
	unsigned int resid_len;
	int eh_eflags;
	enum dma_data_direction data_direction;
	unsigned int underflow;
	unsigned char cmd_len;
	unsigned char prot_op;
	unsigned char cmnd[32];
	struct scsi_data_buffer sdb;
	struct scatterlist sense_sgl;
};

struct scsi_event {
	enum scsi_device_event evt_type;
	struct list_head node;
};

struct scsi_failures;

struct scsi_exec_args {
	unsigned char *sense;
	unsigned int sense_len;
	struct scsi_sense_hdr *sshdr;
	blk_mq_req_flags_t req_flags;
	int scmd_flags;
	int *resid;
	struct scsi_failures *failures;
};

struct scsi_failure {
	int result;
	u8 sense;
	u8 asc;
	u8 ascq;
	s8 allowed;
	s8 retries;
};

struct scsi_failures {
	int total_allowed;
	int total_retries;
	struct scsi_failure *failure_definitions;
};

struct scsi_host_busy_iter_data {
	bool (*fn)(struct scsi_cmnd *, void *);
	void *priv;
};

struct scsi_host_template {
	unsigned int cmd_size;
	int (*queuecommand)(struct Scsi_Host *, struct scsi_cmnd *);
	void (*commit_rqs)(struct Scsi_Host *, u16);
	struct module *module;
	const char *name;
	const char * (*info)(struct Scsi_Host *);
	int (*ioctl)(struct scsi_device *, unsigned int, void *);
	int (*compat_ioctl)(struct scsi_device *, unsigned int, void *);
	int (*init_cmd_priv)(struct Scsi_Host *, struct scsi_cmnd *);
	int (*exit_cmd_priv)(struct Scsi_Host *, struct scsi_cmnd *);
	int (*eh_abort_handler)(struct scsi_cmnd *);
	int (*eh_device_reset_handler)(struct scsi_cmnd *);
	int (*eh_target_reset_handler)(struct scsi_cmnd *);
	int (*eh_bus_reset_handler)(struct scsi_cmnd *);
	int (*eh_host_reset_handler)(struct scsi_cmnd *);
	int (*sdev_init)(struct scsi_device *);
	int (*sdev_configure)(struct scsi_device *, struct queue_limits *);
	void (*sdev_destroy)(struct scsi_device *);
	int (*target_alloc)(struct scsi_target *);
	void (*target_destroy)(struct scsi_target *);
	int (*scan_finished)(struct Scsi_Host *, long unsigned int);
	void (*scan_start)(struct Scsi_Host *);
	int (*change_queue_depth)(struct scsi_device *, int);
	void (*map_queues)(struct Scsi_Host *);
	int (*mq_poll)(struct Scsi_Host *, unsigned int);
	bool (*dma_need_drain)(struct request *);
	int (*bios_param)(struct scsi_device *, struct block_device *, sector_t, int *);
	void (*unlock_native_capacity)(struct scsi_device *);
	int (*show_info)(struct seq_file *, struct Scsi_Host *);
	int (*write_info)(struct Scsi_Host *, char *, int);
	enum scsi_timeout_action (*eh_timed_out)(struct scsi_cmnd *);
	bool (*eh_should_retry_cmd)(struct scsi_cmnd *);
	int (*host_reset)(struct Scsi_Host *, int);
	const char *proc_name;
	int can_queue;
	int this_id;
	short unsigned int sg_tablesize;
	short unsigned int sg_prot_tablesize;
	unsigned int max_sectors;
	unsigned int max_segment_size;
	unsigned int dma_alignment;
	long unsigned int dma_boundary;
	long unsigned int virt_boundary_mask;
	short int cmd_per_lun;
	bool tag_alloc_policy_rr: 1;
	unsigned int track_queue_depth: 1;
	unsigned int supported_mode: 2;
	unsigned int emulated: 1;
	unsigned int skip_settle_delay: 1;
	unsigned int no_write_same: 1;
	unsigned int host_tagset: 1;
	unsigned int queuecommand_may_block: 1;
	unsigned int max_host_blocked;
	const struct attribute_group **shost_groups;
	const struct attribute_group **sdev_groups;
	u64 vendor_id;
};

struct scsi_idlun {
	__u32 dev_id;
	__u32 host_unique_id;
};

struct scsi_io_group_descriptor {
	u8 ic_enable: 1;
	u8 cs_enble: 1;
	u8 st_enble: 1;
	u8 reserved1: 3;
	u8 io_advice_hints_mode: 2;
	u8 reserved2[3];
	u8 lbm_descriptor_type: 4;
	u8 rlbsr: 2;
	u8 reserved3: 1;
	u8 acdlu: 1;
	u8 params[2];
	u8 reserved4;
	u8 reserved5[8];
};

struct scsi_ioctl_command {
	unsigned int inlen;
	unsigned int outlen;
	unsigned char data[0];
};

struct scsi_lun {
	__u8 scsi_lun[8];
};

struct scsi_mode_data {
	__u32 length;
	__u16 block_descriptor_length;
	__u8 medium_type;
	__u8 device_specific;
	__u8 header_length;
	__u8 longlba: 1;
};

struct scsi_proc_entry {
	struct list_head entry;
	const struct scsi_host_template *sht;
	struct proc_dir_entry *proc_dir;
	unsigned int present;
};

struct scsi_sense_hdr {
	u8 response_code;
	u8 sense_key;
	u8 asc;
	u8 ascq;
	u8 byte4;
	u8 byte5;
	u8 byte6;
	u8 additional_length;
};

struct scsi_stream_status {
	u8 reserved1: 7;
	u8 perm: 1;
	u8 reserved2;
	__be16 stream_identifier;
	u8 rel_lifetime: 6;
	u8 reserved3: 2;
	u8 reserved4[3];
};

struct scsi_stream_status_header {
	__be32 len;
	u16 reserved;
	__be16 number_of_open_streams;
	struct {
		struct {} __empty_stream_status;
		struct scsi_stream_status stream_status[0];
	};
};

struct scsi_target {
	struct scsi_device *starget_sdev_user;
	struct list_head siblings;
	struct list_head devices;
	struct device dev;
	struct kref reap_ref;
	unsigned int channel;
	unsigned int id;
	unsigned int create: 1;
	unsigned int single_lun: 1;
	unsigned int pdt_1f_for_no_lun: 1;
	unsigned int no_report_luns: 1;
	unsigned int expecting_lun_change: 1;
	atomic_t target_busy;
	atomic_t target_blocked;
	unsigned int can_queue;
	unsigned int max_target_blocked;
	char scsi_level;
	enum scsi_target_state state;
	void *hostdata;
	long unsigned int starget_data[0];
};

struct scsi_varlen_cdb_hdr {
	__u8 opcode;
	__u8 control;
	__u8 misc[5];
	__u8 additional_cdb_length;
	__be16 service_action;
};

struct scsi_vpd {
	struct callback_head rcu;
	int len;
	unsigned char data[0];
};

struct sctp_paramhdr {
	__be16 type;
	__be16 length;
};

struct sctp_adaptation_ind_param {
	struct sctp_paramhdr param_hdr;
	__be32 adaptation_ind;
};

struct sctp_addip_param {
	struct sctp_paramhdr param_hdr;
	__be32 crr_id;
};

struct sctp_addiphdr {
	__be32 serial;
};

union sctp_addr {
	struct sockaddr_in v4;
	struct sockaddr_in6 v6;
	struct sockaddr sa;
};

struct sctp_ipv4addr_param {
	struct sctp_paramhdr param_hdr;
	struct in_addr addr;
};

struct sctp_ipv6addr_param {
	struct sctp_paramhdr param_hdr;
	struct in6_addr addr;
};

union sctp_addr_param {
	struct sctp_paramhdr p;
	struct sctp_ipv4addr_param v4;
	struct sctp_ipv6addr_param v6;
};

struct sctp_transport;

struct sctp_sock;

struct sctp_af {
	int (*sctp_xmit)(struct sk_buff *, struct sctp_transport *);
	int (*setsockopt)(struct sock *, int, int, sockptr_t, unsigned int);
	int (*getsockopt)(struct sock *, int, int, char *, int *);
	void (*get_dst)(struct sctp_transport *, union sctp_addr *, struct flowi *, struct sock *);
	void (*get_saddr)(struct sctp_sock *, struct sctp_transport *, struct flowi *);
	void (*copy_addrlist)(struct list_head *, struct net_device *);
	int (*cmp_addr)(const union sctp_addr *, const union sctp_addr *);
	void (*addr_copy)(union sctp_addr *, union sctp_addr *);
	void (*from_skb)(union sctp_addr *, struct sk_buff *, int);
	void (*from_sk)(union sctp_addr *, struct sock *);
	bool (*from_addr_param)(union sctp_addr *, union sctp_addr_param *, __be16, int);
	int (*to_addr_param)(const union sctp_addr *, union sctp_addr_param *);
	int (*addr_valid)(union sctp_addr *, struct sctp_sock *, const struct sk_buff *);
	enum sctp_scope (*scope)(union sctp_addr *);
	void (*inaddr_any)(union sctp_addr *, __be16);
	int (*is_any)(const union sctp_addr *);
	int (*available)(union sctp_addr *, struct sctp_sock *);
	int (*skb_iif)(const struct sk_buff *);
	int (*skb_sdif)(const struct sk_buff *);
	int (*is_ce)(const struct sk_buff *);
	void (*seq_dump_addr)(struct seq_file *, union sctp_addr *);
	void (*ecn_capable)(struct sock *);
	__u16 net_header_len;
	int sockaddr_len;
	int (*ip_options_len)(struct sock *);
	sa_family_t sa_family;
	struct list_head list;
};

struct sctp_chunk;

struct sctp_inq {
	struct list_head in_chunk_list;
	struct sctp_chunk *in_progress;
	struct work_struct immediate;
};

struct sctp_bind_addr {
	__u16 port;
	struct list_head address_list;
};

struct sctp_ep_common {
	enum sctp_endpoint_type type;
	refcount_t refcnt;
	bool dead;
	struct sock *sk;
	struct net *net;
	struct sctp_inq inqueue;
	struct sctp_bind_addr bind_addr;
};

struct sctp_cookie {
	__u32 my_vtag;
	__u32 peer_vtag;
	__u32 my_ttag;
	__u32 peer_ttag;
	ktime_t expiration;
	__u16 sinit_num_ostreams;
	__u16 sinit_max_instreams;
	__u32 initial_tsn;
	union sctp_addr peer_addr;
	__u16 my_port;
	__u8 prsctp_capable;
	__u8 padding;
	__u32 adaptation_ind;
	__u8 auth_random[36];
	__u8 auth_hmacs[10];
	__u8 auth_chunks[20];
	__u32 raw_addr_list_len;
};

struct sctp_tsnmap {
	long unsigned int *tsn_map;
	__u32 base_tsn;
	__u32 cumulative_tsn_ack_point;
	__u32 max_tsn_seen;
	__u16 len;
	__u16 pending_data;
	__u16 num_dup_tsns;
	__be32 dup_tsns[16];
};

struct sctp_inithdr_host {
	__u32 init_tag;
	__u32 a_rwnd;
	__u16 num_outbound_streams;
	__u16 num_inbound_streams;
	__u32 initial_tsn;
};

struct sctp_stream_out_ext;

struct sctp_stream_out {
	union {
		__u32 mid;
		__u16 ssn;
	};
	__u32 mid_uo;
	struct sctp_stream_out_ext *ext;
	__u8 state;
};

struct sctp_stream_in {
	union {
		__u32 mid;
		__u16 ssn;
	};
	__u32 mid_uo;
	__u32 fsn;
	__u32 fsn_uo;
	char pd_mode;
	char pd_mode_uo;
};

struct sctp_stream_interleave;

struct sctp_stream {
	struct {
		struct __genradix tree;
		struct sctp_stream_out type[0];
	} out;
	struct {
		struct __genradix tree;
		struct sctp_stream_in type[0];
	} in;
	__u16 outcnt;
	__u16 incnt;
	struct sctp_stream_out *out_curr;
	union {
		struct {
			struct list_head prio_list;
		};
		struct {
			struct list_head rr_list;
			struct sctp_stream_out_ext *rr_next;
		};
		struct {
			struct list_head fc_list;
		};
	};
	struct sctp_stream_interleave *si;
};

struct sctp_sched_ops;

struct sctp_association;

struct sctp_outq {
	struct sctp_association *asoc;
	struct list_head out_chunk_list;
	struct sctp_sched_ops *sched;
	unsigned int out_qlen;
	unsigned int error;
	struct list_head control_chunk_list;
	struct list_head sacked;
	struct list_head retransmit;
	struct list_head abandoned;
	__u32 outstanding_bytes;
	char fast_rtx;
	char cork;
};

struct sctp_ulpq {
	char pd_mode;
	struct sctp_association *asoc;
	struct sk_buff_head reasm;
	struct sk_buff_head reasm_uo;
	struct sk_buff_head lobby;
};

struct sctp_priv_assoc_stats {
	struct __kernel_sockaddr_storage obs_rto_ipaddr;
	__u64 max_obs_rto;
	__u64 isacks;
	__u64 osacks;
	__u64 opackets;
	__u64 ipackets;
	__u64 rtxchunks;
	__u64 outofseqtsns;
	__u64 idupchunks;
	__u64 gapcnt;
	__u64 ouodchunks;
	__u64 iuodchunks;
	__u64 oodchunks;
	__u64 iodchunks;
	__u64 octrlchunks;
	__u64 ictrlchunks;
};

struct sctp_endpoint;

struct sctp_random_param;

struct sctp_chunks_param;

struct sctp_hmac_algo_param;

struct sctp_auth_bytes;

struct sctp_shared_key;

struct sctp_association {
	struct sctp_ep_common base;
	struct list_head asocs;
	sctp_assoc_t assoc_id;
	struct sctp_endpoint *ep;
	struct sctp_cookie c;
	struct {
		struct list_head transport_addr_list;
		__u32 rwnd;
		__u16 transport_count;
		__u16 port;
		struct sctp_transport *primary_path;
		union sctp_addr primary_addr;
		struct sctp_transport *active_path;
		struct sctp_transport *retran_path;
		struct sctp_transport *last_sent_to;
		struct sctp_transport *last_data_from;
		struct sctp_tsnmap tsn_map;
		__be16 addip_disabled_mask;
		__u16 ecn_capable: 1;
		__u16 ipv4_address: 1;
		__u16 ipv6_address: 1;
		__u16 asconf_capable: 1;
		__u16 prsctp_capable: 1;
		__u16 reconf_capable: 1;
		__u16 intl_capable: 1;
		__u16 auth_capable: 1;
		__u16 sack_needed: 1;
		__u16 sack_generation: 1;
		__u16 zero_window_announced: 1;
		__u32 sack_cnt;
		__u32 adaptation_ind;
		struct sctp_inithdr_host i;
		void *cookie;
		int cookie_len;
		__u32 addip_serial;
		struct sctp_random_param *peer_random;
		struct sctp_chunks_param *peer_chunks;
		struct sctp_hmac_algo_param *peer_hmacs;
	} peer;
	enum sctp_state state;
	int overall_error_count;
	ktime_t cookie_life;
	long unsigned int rto_initial;
	long unsigned int rto_max;
	long unsigned int rto_min;
	int max_burst;
	int max_retrans;
	__u16 pf_retrans;
	__u16 ps_retrans;
	__u16 max_init_attempts;
	__u16 init_retries;
	long unsigned int max_init_timeo;
	long unsigned int hbinterval;
	long unsigned int probe_interval;
	__be16 encap_port;
	__u16 pathmaxrxt;
	__u32 flowlabel;
	__u8 dscp;
	__u8 pmtu_pending;
	__u32 pathmtu;
	__u32 param_flags;
	__u32 sackfreq;
	long unsigned int sackdelay;
	long unsigned int timeouts[12];
	struct timer_list timers[12];
	struct sctp_transport *shutdown_last_sent_to;
	struct sctp_transport *init_last_sent_to;
	int shutdown_retries;
	__u32 next_tsn;
	__u32 ctsn_ack_point;
	__u32 adv_peer_ack_point;
	__u32 highest_sacked;
	__u32 fast_recovery_exit;
	__u8 fast_recovery;
	__u16 unack_data;
	__u32 rtx_data_chunks;
	__u32 rwnd;
	__u32 a_rwnd;
	__u32 rwnd_over;
	__u32 rwnd_press;
	int sndbuf_used;
	atomic_t rmem_alloc;
	wait_queue_head_t wait;
	__u32 frag_point;
	__u32 user_frag;
	int init_err_counter;
	int init_cycle;
	__u16 default_stream;
	__u16 default_flags;
	__u32 default_ppid;
	__u32 default_context;
	__u32 default_timetolive;
	__u32 default_rcv_context;
	struct sctp_stream stream;
	struct sctp_outq outqueue;
	struct sctp_ulpq ulpq;
	__u32 last_ecne_tsn;
	__u32 last_cwr_tsn;
	int numduptsns;
	struct sctp_chunk *addip_last_asconf;
	struct list_head asconf_ack_list;
	struct list_head addip_chunk_list;
	__u32 addip_serial;
	int src_out_of_asoc_ok;
	union sctp_addr *asconf_addr_del_pending;
	struct sctp_transport *new_transport;
	struct list_head endpoint_shared_keys;
	struct sctp_auth_bytes *asoc_shared_key;
	struct sctp_shared_key *shkey;
	__u16 default_hmac_id;
	__u16 active_key_id;
	__u8 need_ecne: 1;
	__u8 temp: 1;
	__u8 pf_expose: 2;
	__u8 force_delay: 1;
	__u8 strreset_enable;
	__u8 strreset_outstanding;
	__u32 strreset_outseq;
	__u32 strreset_inseq;
	__u32 strreset_result[2];
	struct sctp_chunk *strreset_chunk;
	struct sctp_priv_assoc_stats stats;
	int sent_cnt_removable;
	__u16 subscribe;
	__u64 abandoned_unsent[3];
	__u64 abandoned_sent[3];
	u32 secid;
	u32 peer_secid;
	struct callback_head rcu;
};

struct sctp_assocparams {
	sctp_assoc_t sasoc_assoc_id;
	__u16 sasoc_asocmaxrxt;
	__u16 sasoc_number_peer_destinations;
	__u32 sasoc_peer_rwnd;
	__u32 sasoc_local_rwnd;
	__u32 sasoc_cookie_life;
};

struct sctp_auth_bytes {
	refcount_t refcnt;
	__u32 len;
	__u8 data[0];
};

struct sctp_authhdr {
	__be16 shkey_id;
	__be16 hmac_id;
};

struct sctp_bind_bucket {
	short unsigned int port;
	signed char fastreuse;
	signed char fastreuseport;
	kuid_t fastuid;
	struct hlist_node node;
	struct hlist_head owner;
	struct net *net;
};

struct sctp_cookie_preserve_param;

struct sctp_hostname_param;

struct sctp_cookie_param;

struct sctp_supported_addrs_param;

struct sctp_supported_ext_param;

union sctp_params {
	void *v;
	struct sctp_paramhdr *p;
	struct sctp_cookie_preserve_param *life;
	struct sctp_hostname_param *dns;
	struct sctp_cookie_param *cookie;
	struct sctp_supported_addrs_param *sat;
	struct sctp_ipv4addr_param *v4;
	struct sctp_ipv6addr_param *v6;
	union sctp_addr_param *addr;
	struct sctp_adaptation_ind_param *aind;
	struct sctp_supported_ext_param *ext;
	struct sctp_random_param *random;
	struct sctp_chunks_param *chunks;
	struct sctp_hmac_algo_param *hmac_algo;
	struct sctp_addip_param *addip;
};

struct sctp_sndrcvinfo {
	__u16 sinfo_stream;
	__u16 sinfo_ssn;
	__u16 sinfo_flags;
	__u32 sinfo_ppid;
	__u32 sinfo_context;
	__u32 sinfo_timetolive;
	__u32 sinfo_tsn;
	__u32 sinfo_cumtsn;
	sctp_assoc_t sinfo_assoc_id;
};

struct sctp_datahdr;

struct sctp_inithdr;

struct sctp_sackhdr;

struct sctp_heartbeathdr;

struct sctp_sender_hb_info;

struct sctp_shutdownhdr;

struct sctp_signed_cookie;

struct sctp_ecnehdr;

struct sctp_cwrhdr;

struct sctp_errhdr;

struct sctp_fwdtsn_hdr;

struct sctp_idatahdr;

struct sctp_ifwdtsn_hdr;

struct sctp_chunkhdr;

struct sctphdr;

struct sctp_datamsg;

struct sctp_chunk {
	struct list_head list;
	refcount_t refcnt;
	int sent_count;
	union {
		struct list_head transmitted_list;
		struct list_head stream_list;
	};
	struct list_head frag_list;
	struct sk_buff *skb;
	union {
		struct sk_buff *head_skb;
		struct sctp_shared_key *shkey;
	};
	union sctp_params param_hdr;
	union {
		__u8 *v;
		struct sctp_datahdr *data_hdr;
		struct sctp_inithdr *init_hdr;
		struct sctp_sackhdr *sack_hdr;
		struct sctp_heartbeathdr *hb_hdr;
		struct sctp_sender_hb_info *hbs_hdr;
		struct sctp_shutdownhdr *shutdown_hdr;
		struct sctp_signed_cookie *cookie_hdr;
		struct sctp_ecnehdr *ecne_hdr;
		struct sctp_cwrhdr *ecn_cwr_hdr;
		struct sctp_errhdr *err_hdr;
		struct sctp_addiphdr *addip_hdr;
		struct sctp_fwdtsn_hdr *fwdtsn_hdr;
		struct sctp_authhdr *auth_hdr;
		struct sctp_idatahdr *idata_hdr;
		struct sctp_ifwdtsn_hdr *ifwdtsn_hdr;
	} subh;
	__u8 *chunk_end;
	struct sctp_chunkhdr *chunk_hdr;
	struct sctphdr *sctp_hdr;
	struct sctp_sndrcvinfo sinfo;
	struct sctp_association *asoc;
	struct sctp_ep_common *rcvr;
	long unsigned int sent_at;
	union sctp_addr source;
	union sctp_addr dest;
	struct sctp_datamsg *msg;
	struct sctp_transport *transport;
	struct sk_buff *auth_chunk;
	__u16 rtt_in_progress: 1;
	__u16 has_tsn: 1;
	__u16 has_ssn: 1;
	__u16 singleton: 1;
	__u16 end_of_packet: 1;
	__u16 ecn_ce_done: 1;
	__u16 pdiscard: 1;
	__u16 tsn_gap_acked: 1;
	__u16 data_accepted: 1;
	__u16 auth: 1;
	__u16 has_asconf: 1;
	__u16 pmtu_probe: 1;
	__u16 tsn_missing_report: 2;
	__u16 fast_retransmit: 2;
};

struct sctp_chunkhdr {
	__u8 type;
	__u8 flags;
	__be16 length;
};

struct sctp_chunks_param {
	struct sctp_paramhdr param_hdr;
	__u8 chunks[0];
};

struct sctp_cookie_param {
	struct sctp_paramhdr p;
	__u8 body[0];
};

struct sctp_cookie_preserve_param {
	struct sctp_paramhdr param_hdr;
	__be32 lifespan_increment;
};

struct sctp_cwrhdr {
	__be32 lowest_tsn;
};

struct sctp_datahdr {
	__be32 tsn;
	__be16 stream;
	__be16 ssn;
	__u32 ppid;
};

struct sctp_datamsg {
	struct list_head chunks;
	refcount_t refcnt;
	long unsigned int expires_at;
	int send_error;
	u8 send_failed: 1;
	u8 can_delay: 1;
	u8 abandoned: 1;
};

struct sctp_ecnehdr {
	__be32 lowest_tsn;
};

struct sctp_endpoint {
	struct sctp_ep_common base;
	struct hlist_node node;
	int hashent;
	struct list_head asocs;
	__u8 secret_key[32];
	__u8 *digest;
	__u32 sndbuf_policy;
	__u32 rcvbuf_policy;
	struct crypto_shash **auth_hmacs;
	struct sctp_hmac_algo_param *auth_hmacs_list;
	struct sctp_chunks_param *auth_chunk_list;
	struct list_head endpoint_shared_keys;
	__u16 active_key_id;
	__u8 ecn_enable: 1;
	__u8 auth_enable: 1;
	__u8 intl_enable: 1;
	__u8 prsctp_enable: 1;
	__u8 asconf_enable: 1;
	__u8 reconf_enable: 1;
	__u8 strreset_enable;
	struct callback_head rcu;
};

struct sctp_errhdr {
	__be16 cause;
	__be16 length;
};

struct sctp_fwdtsn_hdr {
	__be32 new_cum_tsn;
};

struct sctp_heartbeathdr {
	struct sctp_paramhdr info;
};

struct sctp_hmac_algo_param {
	struct sctp_paramhdr param_hdr;
	__be16 hmac_ids[0];
};

struct sctp_hostname_param {
	struct sctp_paramhdr param_hdr;
	uint8_t hostname[0];
};

struct sctp_idatahdr {
	__be32 tsn;
	__be16 stream;
	__be16 reserved;
	__be32 mid;
	union {
		__u32 ppid;
		__be32 fsn;
	};
	__u8 payload[0];
};

struct sctp_ifwdtsn_hdr {
	__be32 new_cum_tsn;
};

struct sctp_inithdr {
	__be32 init_tag;
	__be32 a_rwnd;
	__be16 num_outbound_streams;
	__be16 num_inbound_streams;
	__be32 initial_tsn;
};

struct sctp_initmsg {
	__u16 sinit_num_ostreams;
	__u16 sinit_max_instreams;
	__u16 sinit_max_attempts;
	__u16 sinit_max_init_timeo;
};

struct sctp_packet {
	__u16 source_port;
	__u16 destination_port;
	__u32 vtag;
	struct list_head chunk_list;
	size_t overhead;
	size_t size;
	size_t max_size;
	struct sctp_transport *transport;
	struct sctp_chunk *auth;
	u8 has_cookie_echo: 1;
	u8 has_sack: 1;
	u8 has_auth: 1;
	u8 has_data: 1;
	u8 ipfragok: 1;
};

struct sctp_paddrparams {
	sctp_assoc_t spp_assoc_id;
	struct __kernel_sockaddr_storage spp_address;
	__u32 spp_hbinterval;
	__u16 spp_pathmaxrxt;
	__u32 spp_pathmtu;
	__u32 spp_sackdelay;
	__u32 spp_flags;
	__u32 spp_ipv6_flowlabel;
	__u8 spp_dscp;
	int: 0;
} __attribute__((packed));

struct sctp_ulpevent;

struct sctp_pf {
	void (*event_msgname)(struct sctp_ulpevent *, char *, int *);
	void (*skb_msgname)(struct sk_buff *, char *, int *);
	int (*af_supported)(sa_family_t, struct sctp_sock *);
	int (*cmp_addr)(const union sctp_addr *, const union sctp_addr *, struct sctp_sock *);
	int (*bind_verify)(struct sctp_sock *, union sctp_addr *);
	int (*send_verify)(struct sctp_sock *, union sctp_addr *);
	int (*supported_addrs)(const struct sctp_sock *, __be16 *);
	struct sock * (*create_accept_sk)(struct sock *, struct sctp_association *, bool);
	int (*addr_to_user)(struct sctp_sock *, union sctp_addr *);
	void (*to_sk_saddr)(union sctp_addr *, struct sock *);
	void (*to_sk_daddr)(union sctp_addr *, struct sock *);
	void (*copy_ip_options)(struct sock *, struct sock *);
	struct sctp_af *af;
};

struct sctp_random_param {
	struct sctp_paramhdr param_hdr;
	__u8 random_val[0];
};

struct sctp_rtoinfo {
	sctp_assoc_t srto_assoc_id;
	__u32 srto_initial;
	__u32 srto_max;
	__u32 srto_min;
};

struct sctp_sackhdr {
	__be32 cum_tsn_ack;
	__be32 a_rwnd;
	__be16 num_gap_ack_blocks;
	__be16 num_dup_tsns;
};

struct sctp_sender_hb_info {
	struct sctp_paramhdr param_hdr;
	union sctp_addr daddr;
	long unsigned int sent_at;
	__u64 hb_nonce;
	__u32 probe_size;
};

struct sctp_shared_key {
	struct list_head key_list;
	struct sctp_auth_bytes *key;
	refcount_t refcnt;
	__u16 key_id;
	__u8 deactivated;
};

struct sctp_shutdownhdr {
	__be32 cum_tsn_ack;
};

struct sctp_signed_cookie {
	__u8 signature[32];
	__u32 __pad;
	struct sctp_cookie c;
} __attribute__((packed));

struct sctp_sock {
	struct inet_sock inet;
	enum sctp_socket_type type;
	struct sctp_pf *pf;
	struct crypto_shash *hmac;
	char *sctp_hmac_alg;
	struct sctp_endpoint *ep;
	struct sctp_bind_bucket *bind_hash;
	__u16 default_stream;
	__u32 default_ppid;
	__u16 default_flags;
	__u32 default_context;
	__u32 default_timetolive;
	__u32 default_rcv_context;
	int max_burst;
	__u32 hbinterval;
	__u32 probe_interval;
	__be16 udp_port;
	__be16 encap_port;
	__u16 pathmaxrxt;
	__u32 flowlabel;
	__u8 dscp;
	__u16 pf_retrans;
	__u16 ps_retrans;
	__u32 pathmtu;
	__u32 sackdelay;
	__u32 sackfreq;
	__u32 param_flags;
	__u32 default_ss;
	struct sctp_rtoinfo rtoinfo;
	struct sctp_paddrparams paddrparam;
	struct sctp_assocparams assocparams;
	__u16 subscribe;
	struct sctp_initmsg initmsg;
	int user_frag;
	__u32 autoclose;
	__u32 adaptation_ind;
	__u32 pd_point;
	__u16 nodelay: 1;
	__u16 pf_expose: 2;
	__u16 reuse: 1;
	__u16 disable_fragments: 1;
	__u16 v4mapped: 1;
	__u16 frag_interleave: 1;
	__u16 recvrcvinfo: 1;
	__u16 recvnxtinfo: 1;
	__u16 data_ready_signalled: 1;
	atomic_t pd_mode;
	struct sk_buff_head pd_lobby;
	struct list_head auto_asconf_list;
	int do_auto_asconf;
};

struct sctp_stream_interleave {
	__u16 data_chunk_len;
	__u16 ftsn_chunk_len;
	struct sctp_chunk * (*make_datafrag)(const struct sctp_association *, const struct sctp_sndrcvinfo *, int, __u8, gfp_t);
	void (*assign_number)(struct sctp_chunk *);
	bool (*validate_data)(struct sctp_chunk *);
	int (*ulpevent_data)(struct sctp_ulpq *, struct sctp_chunk *, gfp_t);
	int (*enqueue_event)(struct sctp_ulpq *, struct sctp_ulpevent *);
	void (*renege_events)(struct sctp_ulpq *, struct sctp_chunk *, gfp_t);
	void (*start_pd)(struct sctp_ulpq *, gfp_t);
	void (*abort_pd)(struct sctp_ulpq *, gfp_t);
	void (*generate_ftsn)(struct sctp_outq *, __u32);
	bool (*validate_ftsn)(struct sctp_chunk *);
	void (*report_ftsn)(struct sctp_ulpq *, __u32);
	void (*handle_ftsn)(struct sctp_ulpq *, struct sctp_chunk *);
};

struct sctp_stream_priorities;

struct sctp_stream_out_ext {
	__u64 abandoned_unsent[3];
	__u64 abandoned_sent[3];
	struct list_head outq;
	union {
		struct {
			struct list_head prio_list;
			struct sctp_stream_priorities *prio_head;
		};
		struct {
			struct list_head rr_list;
		};
		struct {
			struct list_head fc_list;
			__u32 fc_length;
			__u16 fc_weight;
		};
	};
};

struct sctp_stream_priorities {
	struct list_head prio_sched;
	struct list_head active;
	struct sctp_stream_out_ext *next;
	__u16 prio;
	__u16 users;
};

struct sctp_supported_addrs_param {
	struct sctp_paramhdr param_hdr;
	__be16 types[0];
};

struct sctp_supported_ext_param {
	struct sctp_paramhdr param_hdr;
	__u8 chunks[0];
};

struct sctp_transport {
	struct list_head transports;
	struct rhlist_head node;
	refcount_t refcnt;
	__u32 rto_pending: 1;
	__u32 hb_sent: 1;
	__u32 pmtu_pending: 1;
	__u32 dst_pending_confirm: 1;
	__u32 sack_generation: 1;
	u32 dst_cookie;
	struct flowi fl;
	union sctp_addr ipaddr;
	struct sctp_af *af_specific;
	struct sctp_association *asoc;
	long unsigned int rto;
	__u32 rtt;
	__u32 rttvar;
	__u32 srtt;
	__u32 cwnd;
	__u32 ssthresh;
	__u32 partial_bytes_acked;
	__u32 flight_size;
	__u32 burst_limited;
	struct dst_entry *dst;
	union sctp_addr saddr;
	long unsigned int hbinterval;
	long unsigned int probe_interval;
	long unsigned int sackdelay;
	__u32 sackfreq;
	atomic_t mtu_info;
	ktime_t last_time_heard;
	long unsigned int last_time_sent;
	long unsigned int last_time_ecne_reduced;
	__be16 encap_port;
	__u16 pathmaxrxt;
	__u32 flowlabel;
	__u8 dscp;
	__u16 pf_retrans;
	__u16 ps_retrans;
	__u32 pathmtu;
	__u32 param_flags;
	int init_sent_count;
	int state;
	short unsigned int error_count;
	struct timer_list T3_rtx_timer;
	struct timer_list hb_timer;
	struct timer_list proto_unreach_timer;
	struct timer_list reconf_timer;
	struct timer_list probe_timer;
	struct list_head transmitted;
	struct sctp_packet packet;
	struct list_head send_ready;
	struct {
		__u32 next_tsn_at_change;
		char changeover_active;
		char cycling_changeover;
		char cacc_saw_newack;
	} cacc;
	struct {
		__u16 pmtu;
		__u16 probe_size;
		__u16 probe_high;
		__u8 probe_count;
		__u8 state;
	} pl;
	__u64 hb_nonce;
	struct callback_head rcu;
};

struct sctp_ulpevent {
	struct sctp_association *asoc;
	struct sctp_chunk *chunk;
	unsigned int rmem_len;
	union {
		__u32 mid;
		__u16 ssn;
	};
	union {
		__u32 ppid;
		__u32 fsn;
	};
	__u32 tsn;
	__u32 cumtsn;
	__u16 stream;
	__u16 flags;
	__u16 msg_flags;
} __attribute__((packed));

struct sctphdr {
	__be16 source;
	__be16 dest;
	__be32 vtag;
	__le32 checksum;
};

struct sd_flow_limit {
	u64 count;
	unsigned int num_buckets;
	unsigned int history_head;
	u16 history[128];
	u8 buckets[0];
};

struct sg_lb_stats {
	long unsigned int avg_load;
	long unsigned int group_load;
	long unsigned int group_capacity;
	long unsigned int group_util;
	long unsigned int group_runnable;
	unsigned int sum_nr_running;
	unsigned int sum_h_nr_running;
	unsigned int idle_cpus;
	unsigned int group_weight;
	enum group_type group_type;
	unsigned int group_asym_packing;
	unsigned int group_smt_balance;
	long unsigned int group_misfit_task_load;
};

struct sd_lb_stats {
	struct sched_group *busiest;
	struct sched_group *local;
	long unsigned int total_load;
	long unsigned int total_capacity;
	long unsigned int avg_load;
	unsigned int prefer_sibling;
	struct sg_lb_stats busiest_stat;
	struct sg_lb_stats local_stat;
};

struct shash_desc {
	struct crypto_shash *tfm;
	void *__ctx[0];
};

struct sdesc {
	struct shash_desc shash;
	char ctx[0];
};

struct sdp_media_type {
	const char *name;
	unsigned int len;
	enum sip_expectation_classes class;
};

struct sdw_intel_acpi_info {
	acpi_handle handle;
	int count;
	u32 link_mask;
};

struct xfrm_offload {
	struct {
		__u32 low;
		__u32 hi;
	} seq;
	__u32 flags;
	__u32 status;
	__u32 orig_mac_len;
	__u8 proto;
	__u8 inner_ipproto;
};

struct sec_path {
	int len;
	int olen;
	int verified_cnt;
	struct xfrm_state *xvec[6];
	struct xfrm_offload ovec[1];
};

struct seccomp_filter;

struct seccomp {
	int mode;
	atomic_t filter_count;
	struct seccomp_filter *filter;
};

struct seccomp_data {
	int nr;
	__u32 arch;
	__u64 instruction_pointer;
	__u64 args[6];
};

struct seccomp_filter {
	refcount_t refs;
	refcount_t users;
	bool log;
	bool wait_killable_recv;
	struct action_cache cache;
	struct seccomp_filter *prev;
	struct bpf_prog *prog;
	struct notification *notif;
	struct mutex notify_lock;
	wait_queue_head_t wqh;
};

struct seccomp_kaddfd {
	struct file *file;
	int fd;
	unsigned int flags;
	__u32 ioctl_flags;
	union {
		bool setfd;
		int ret;
	};
	struct completion completion;
	struct list_head list;
};

struct seccomp_knotif {
	struct task_struct *task;
	u64 id;
	const struct seccomp_data *data;
	enum notify_state state;
	int error;
	long int val;
	u32 flags;
	struct completion ready;
	struct list_head list;
	struct list_head addfd;
};

struct seccomp_log_name {
	u32 log;
	const char *name;
};

struct seccomp_notif {
	__u64 id;
	__u32 pid;
	__u32 flags;
	struct seccomp_data data;
};

struct seccomp_notif_addfd {
	__u64 id;
	__u32 flags;
	__u32 srcfd;
	__u32 newfd;
	__u32 newfd_flags;
};

struct seccomp_notif_resp {
	__u64 id;
	__s64 val;
	__s32 error;
	__u32 flags;
};

struct seccomp_notif_sizes {
	__u16 seccomp_notif;
	__u16 seccomp_notif_resp;
	__u16 seccomp_data;
};

struct security_class_mapping {
	const char *name;
	const char *perms[33];
};

struct timezone;

struct xattr;

struct sembuf;

union security_list_options {
	int (*binder_set_context_mgr)(const struct cred *);
	int (*binder_transaction)(const struct cred *, const struct cred *);
	int (*binder_transfer_binder)(const struct cred *, const struct cred *);
	int (*binder_transfer_file)(const struct cred *, const struct cred *, const struct file *);
	int (*ptrace_access_check)(struct task_struct *, unsigned int);
	int (*ptrace_traceme)(struct task_struct *);
	int (*capget)(const struct task_struct *, kernel_cap_t *, kernel_cap_t *, kernel_cap_t *);
	int (*capset)(struct cred *, const struct cred *, const kernel_cap_t *, const kernel_cap_t *, const kernel_cap_t *);
	int (*capable)(const struct cred *, struct user_namespace *, int, unsigned int);
	int (*quotactl)(int, int, int, const struct super_block *);
	int (*quota_on)(struct dentry *);
	int (*syslog)(int);
	int (*settime)(const struct timespec64 *, const struct timezone *);
	int (*vm_enough_memory)(struct mm_struct *, long int);
	int (*bprm_creds_for_exec)(struct linux_binprm *);
	int (*bprm_creds_from_file)(struct linux_binprm *, const struct file *);
	int (*bprm_check_security)(struct linux_binprm *);
	void (*bprm_committing_creds)(const struct linux_binprm *);
	void (*bprm_committed_creds)(const struct linux_binprm *);
	int (*fs_context_submount)(struct fs_context *, struct super_block *);
	int (*fs_context_dup)(struct fs_context *, struct fs_context *);
	int (*fs_context_parse_param)(struct fs_context *, struct fs_parameter *);
	int (*sb_alloc_security)(struct super_block *);
	void (*sb_delete)(struct super_block *);
	void (*sb_free_security)(struct super_block *);
	void (*sb_free_mnt_opts)(void *);
	int (*sb_eat_lsm_opts)(char *, void **);
	int (*sb_mnt_opts_compat)(struct super_block *, void *);
	int (*sb_remount)(struct super_block *, void *);
	int (*sb_kern_mount)(const struct super_block *);
	int (*sb_show_options)(struct seq_file *, struct super_block *);
	int (*sb_statfs)(struct dentry *);
	int (*sb_mount)(const char *, const struct path *, const char *, long unsigned int, void *);
	int (*sb_umount)(struct vfsmount *, int);
	int (*sb_pivotroot)(const struct path *, const struct path *);
	int (*sb_set_mnt_opts)(struct super_block *, void *, long unsigned int, long unsigned int *);
	int (*sb_clone_mnt_opts)(const struct super_block *, struct super_block *, long unsigned int, long unsigned int *);
	int (*move_mount)(const struct path *, const struct path *);
	int (*dentry_init_security)(struct dentry *, int, const struct qstr *, const char **, struct lsm_context *);
	int (*dentry_create_files_as)(struct dentry *, int, struct qstr *, const struct cred *, struct cred *);
	int (*path_notify)(const struct path *, u64, unsigned int);
	int (*inode_alloc_security)(struct inode *);
	void (*inode_free_security)(struct inode *);
	void (*inode_free_security_rcu)(void *);
	int (*inode_init_security)(struct inode *, struct inode *, const struct qstr *, struct xattr *, int *);
	int (*inode_init_security_anon)(struct inode *, const struct qstr *, const struct inode *);
	int (*inode_create)(struct inode *, struct dentry *, umode_t);
	void (*inode_post_create_tmpfile)(struct mnt_idmap *, struct inode *);
	int (*inode_link)(struct dentry *, struct inode *, struct dentry *);
	int (*inode_unlink)(struct inode *, struct dentry *);
	int (*inode_symlink)(struct inode *, struct dentry *, const char *);
	int (*inode_mkdir)(struct inode *, struct dentry *, umode_t);
	int (*inode_rmdir)(struct inode *, struct dentry *);
	int (*inode_mknod)(struct inode *, struct dentry *, umode_t, dev_t);
	int (*inode_rename)(struct inode *, struct dentry *, struct inode *, struct dentry *);
	int (*inode_readlink)(struct dentry *);
	int (*inode_follow_link)(struct dentry *, struct inode *, bool);
	int (*inode_permission)(struct inode *, int);
	int (*inode_setattr)(struct mnt_idmap *, struct dentry *, struct iattr *);
	void (*inode_post_setattr)(struct mnt_idmap *, struct dentry *, int);
	int (*inode_getattr)(const struct path *);
	int (*inode_xattr_skipcap)(const char *);
	int (*inode_setxattr)(struct mnt_idmap *, struct dentry *, const char *, const void *, size_t, int);
	void (*inode_post_setxattr)(struct dentry *, const char *, const void *, size_t, int);
	int (*inode_getxattr)(struct dentry *, const char *);
	int (*inode_listxattr)(struct dentry *);
	int (*inode_removexattr)(struct mnt_idmap *, struct dentry *, const char *);
	void (*inode_post_removexattr)(struct dentry *, const char *);
	int (*inode_set_acl)(struct mnt_idmap *, struct dentry *, const char *, struct posix_acl *);
	void (*inode_post_set_acl)(struct dentry *, const char *, struct posix_acl *);
	int (*inode_get_acl)(struct mnt_idmap *, struct dentry *, const char *);
	int (*inode_remove_acl)(struct mnt_idmap *, struct dentry *, const char *);
	void (*inode_post_remove_acl)(struct mnt_idmap *, struct dentry *, const char *);
	int (*inode_need_killpriv)(struct dentry *);
	int (*inode_killpriv)(struct mnt_idmap *, struct dentry *);
	int (*inode_getsecurity)(struct mnt_idmap *, struct inode *, const char *, void **, bool);
	int (*inode_setsecurity)(struct inode *, const char *, const void *, size_t, int);
	int (*inode_listsecurity)(struct inode *, char *, size_t);
	void (*inode_getlsmprop)(struct inode *, struct lsm_prop *);
	int (*inode_copy_up)(struct dentry *, struct cred **);
	int (*inode_copy_up_xattr)(struct dentry *, const char *);
	int (*inode_setintegrity)(const struct inode *, enum lsm_integrity_type, const void *, size_t);
	int (*kernfs_init_security)(struct kernfs_node *, struct kernfs_node *);
	int (*file_permission)(struct file *, int);
	int (*file_alloc_security)(struct file *);
	void (*file_release)(struct file *);
	void (*file_free_security)(struct file *);
	int (*file_ioctl)(struct file *, unsigned int, long unsigned int);
	int (*file_ioctl_compat)(struct file *, unsigned int, long unsigned int);
	int (*mmap_addr)(long unsigned int);
	int (*mmap_file)(struct file *, long unsigned int, long unsigned int, long unsigned int);
	int (*file_mprotect)(struct vm_area_struct *, long unsigned int, long unsigned int);
	int (*file_lock)(struct file *, unsigned int);
	int (*file_fcntl)(struct file *, unsigned int, long unsigned int);
	void (*file_set_fowner)(struct file *);
	int (*file_send_sigiotask)(struct task_struct *, struct fown_struct *, int);
	int (*file_receive)(struct file *);
	int (*file_open)(struct file *);
	int (*file_post_open)(struct file *, int);
	int (*file_truncate)(struct file *);
	int (*task_alloc)(struct task_struct *, long unsigned int);
	void (*task_free)(struct task_struct *);
	int (*cred_alloc_blank)(struct cred *, gfp_t);
	void (*cred_free)(struct cred *);
	int (*cred_prepare)(struct cred *, const struct cred *, gfp_t);
	void (*cred_transfer)(struct cred *, const struct cred *);
	void (*cred_getsecid)(const struct cred *, u32 *);
	void (*cred_getlsmprop)(const struct cred *, struct lsm_prop *);
	int (*kernel_act_as)(struct cred *, u32);
	int (*kernel_create_files_as)(struct cred *, struct inode *);
	int (*kernel_module_request)(char *);
	int (*kernel_load_data)(enum kernel_load_data_id, bool);
	int (*kernel_post_load_data)(char *, loff_t, enum kernel_load_data_id, char *);
	int (*kernel_read_file)(struct file *, enum kernel_read_file_id, bool);
	int (*kernel_post_read_file)(struct file *, char *, loff_t, enum kernel_read_file_id);
	int (*task_fix_setuid)(struct cred *, const struct cred *, int);
	int (*task_fix_setgid)(struct cred *, const struct cred *, int);
	int (*task_fix_setgroups)(struct cred *, const struct cred *);
	int (*task_setpgid)(struct task_struct *, pid_t);
	int (*task_getpgid)(struct task_struct *);
	int (*task_getsid)(struct task_struct *);
	void (*current_getlsmprop_subj)(struct lsm_prop *);
	void (*task_getlsmprop_obj)(struct task_struct *, struct lsm_prop *);
	int (*task_setnice)(struct task_struct *, int);
	int (*task_setioprio)(struct task_struct *, int);
	int (*task_getioprio)(struct task_struct *);
	int (*task_prlimit)(const struct cred *, const struct cred *, unsigned int);
	int (*task_setrlimit)(struct task_struct *, unsigned int, struct rlimit *);
	int (*task_setscheduler)(struct task_struct *);
	int (*task_getscheduler)(struct task_struct *);
	int (*task_movememory)(struct task_struct *);
	int (*task_kill)(struct task_struct *, struct kernel_siginfo *, int, const struct cred *);
	int (*task_prctl)(int, long unsigned int, long unsigned int, long unsigned int, long unsigned int);
	void (*task_to_inode)(struct task_struct *, struct inode *);
	int (*userns_create)(const struct cred *);
	int (*ipc_permission)(struct kern_ipc_perm *, short int);
	void (*ipc_getlsmprop)(struct kern_ipc_perm *, struct lsm_prop *);
	int (*msg_msg_alloc_security)(struct msg_msg *);
	void (*msg_msg_free_security)(struct msg_msg *);
	int (*msg_queue_alloc_security)(struct kern_ipc_perm *);
	void (*msg_queue_free_security)(struct kern_ipc_perm *);
	int (*msg_queue_associate)(struct kern_ipc_perm *, int);
	int (*msg_queue_msgctl)(struct kern_ipc_perm *, int);
	int (*msg_queue_msgsnd)(struct kern_ipc_perm *, struct msg_msg *, int);
	int (*msg_queue_msgrcv)(struct kern_ipc_perm *, struct msg_msg *, struct task_struct *, long int, int);
	int (*shm_alloc_security)(struct kern_ipc_perm *);
	void (*shm_free_security)(struct kern_ipc_perm *);
	int (*shm_associate)(struct kern_ipc_perm *, int);
	int (*shm_shmctl)(struct kern_ipc_perm *, int);
	int (*shm_shmat)(struct kern_ipc_perm *, char *, int);
	int (*sem_alloc_security)(struct kern_ipc_perm *);
	void (*sem_free_security)(struct kern_ipc_perm *);
	int (*sem_associate)(struct kern_ipc_perm *, int);
	int (*sem_semctl)(struct kern_ipc_perm *, int);
	int (*sem_semop)(struct kern_ipc_perm *, struct sembuf *, unsigned int, int);
	int (*netlink_send)(struct sock *, struct sk_buff *);
	void (*d_instantiate)(struct dentry *, struct inode *);
	int (*getselfattr)(unsigned int, struct lsm_ctx *, u32 *, u32);
	int (*setselfattr)(unsigned int, struct lsm_ctx *, u32, u32);
	int (*getprocattr)(struct task_struct *, const char *, char **);
	int (*setprocattr)(const char *, void *, size_t);
	int (*ismaclabel)(const char *);
	int (*secid_to_secctx)(u32, struct lsm_context *);
	int (*lsmprop_to_secctx)(struct lsm_prop *, struct lsm_context *);
	int (*secctx_to_secid)(const char *, u32, u32 *);
	void (*release_secctx)(struct lsm_context *);
	void (*inode_invalidate_secctx)(struct inode *);
	int (*inode_notifysecctx)(struct inode *, void *, u32);
	int (*inode_setsecctx)(struct dentry *, void *, u32);
	int (*inode_getsecctx)(struct inode *, struct lsm_context *);
	int (*unix_stream_connect)(struct sock *, struct sock *, struct sock *);
	int (*unix_may_send)(struct socket *, struct socket *);
	int (*socket_create)(int, int, int, int);
	int (*socket_post_create)(struct socket *, int, int, int, int);
	int (*socket_socketpair)(struct socket *, struct socket *);
	int (*socket_bind)(struct socket *, struct sockaddr *, int);
	int (*socket_connect)(struct socket *, struct sockaddr *, int);
	int (*socket_listen)(struct socket *, int);
	int (*socket_accept)(struct socket *, struct socket *);
	int (*socket_sendmsg)(struct socket *, struct msghdr *, int);
	int (*socket_recvmsg)(struct socket *, struct msghdr *, int, int);
	int (*socket_getsockname)(struct socket *);
	int (*socket_getpeername)(struct socket *);
	int (*socket_getsockopt)(struct socket *, int, int);
	int (*socket_setsockopt)(struct socket *, int, int);
	int (*socket_shutdown)(struct socket *, int);
	int (*socket_sock_rcv_skb)(struct sock *, struct sk_buff *);
	int (*socket_getpeersec_stream)(struct socket *, sockptr_t, sockptr_t, unsigned int);
	int (*socket_getpeersec_dgram)(struct socket *, struct sk_buff *, u32 *);
	int (*sk_alloc_security)(struct sock *, int, gfp_t);
	void (*sk_free_security)(struct sock *);
	void (*sk_clone_security)(const struct sock *, struct sock *);
	void (*sk_getsecid)(const struct sock *, u32 *);
	void (*sock_graft)(struct sock *, struct socket *);
	int (*inet_conn_request)(const struct sock *, struct sk_buff *, struct request_sock *);
	void (*inet_csk_clone)(struct sock *, const struct request_sock *);
	void (*inet_conn_established)(struct sock *, struct sk_buff *);
	int (*secmark_relabel_packet)(u32);
	void (*secmark_refcount_inc)(void);
	void (*secmark_refcount_dec)(void);
	void (*req_classify_flow)(const struct request_sock *, struct flowi_common *);
	int (*tun_dev_alloc_security)(void *);
	int (*tun_dev_create)(void);
	int (*tun_dev_attach_queue)(void *);
	int (*tun_dev_attach)(struct sock *, void *);
	int (*tun_dev_open)(void *);
	int (*sctp_assoc_request)(struct sctp_association *, struct sk_buff *);
	int (*sctp_bind_connect)(struct sock *, int, struct sockaddr *, int);
	void (*sctp_sk_clone)(struct sctp_association *, struct sock *, struct sock *);
	int (*sctp_assoc_established)(struct sctp_association *, struct sk_buff *);
	int (*mptcp_add_subflow)(struct sock *, struct sock *);
	int (*key_alloc)(struct key *, const struct cred *, long unsigned int);
	int (*key_permission)(key_ref_t, const struct cred *, enum key_need_perm);
	int (*key_getsecurity)(struct key *, char **);
	void (*key_post_create_or_update)(struct key *, struct key *, const void *, size_t, long unsigned int, bool);
	int (*audit_rule_init)(u32, u32, char *, void **, gfp_t);
	int (*audit_rule_known)(struct audit_krule *);
	int (*audit_rule_match)(struct lsm_prop *, u32, u32, void *);
	void (*audit_rule_free)(void *);
	int (*bpf)(int, union bpf_attr *, unsigned int);
	int (*bpf_map)(struct bpf_map *, fmode_t);
	int (*bpf_prog)(struct bpf_prog *);
	int (*bpf_map_create)(struct bpf_map *, union bpf_attr *, struct bpf_token *);
	void (*bpf_map_free)(struct bpf_map *);
	int (*bpf_prog_load)(struct bpf_prog *, union bpf_attr *, struct bpf_token *);
	void (*bpf_prog_free)(struct bpf_prog *);
	int (*bpf_token_create)(struct bpf_token *, union bpf_attr *, const struct path *);
	void (*bpf_token_free)(struct bpf_token *);
	int (*bpf_token_cmd)(const struct bpf_token *, enum bpf_cmd);
	int (*bpf_token_capable)(const struct bpf_token *, int);
	int (*locked_down)(enum lockdown_reason);
	int (*perf_event_open)(struct perf_event_attr *, int);
	int (*perf_event_alloc)(struct perf_event *);
	int (*perf_event_read)(struct perf_event *);
	int (*perf_event_write)(struct perf_event *);
	int (*uring_override_creds)(const struct cred *);
	int (*uring_sqpoll)(void);
	int (*uring_cmd)(struct io_uring_cmd *);
	void (*initramfs_populated)(void);
	int (*bdev_alloc_security)(struct block_device *);
	void (*bdev_free_security)(struct block_device *);
	int (*bdev_setintegrity)(struct block_device *, enum lsm_integrity_type, const void *, size_t);
	void *lsm_func_addr;
};

struct security_hook_list {
	struct lsm_static_call *scalls;
	union security_list_options hook;
	const struct lsm_id *lsmid;
};

struct seg6_pernet_data {
	struct mutex lock;
	struct in6_addr *tun_src;
};

struct sel_netif {
	struct list_head list;
	struct netif_security_struct nsec;
	struct callback_head callback_head;
};

struct sel_netnode {
	struct netnode_security_struct nsec;
	struct list_head list;
	struct callback_head rcu;
};

struct sel_netnode_bkt {
	unsigned int size;
	struct list_head list;
};

struct sel_netport {
	struct netport_security_struct psec;
	struct list_head list;
	struct callback_head rcu;
};

struct sel_netport_bkt {
	int size;
	struct list_head list;
};

struct select_data {
	struct dentry *start;
	union {
		long int found;
		struct dentry *victim;
	};
	struct list_head dispose;
};

struct selinux_audit_data {
	u32 ssid;
	u32 tsid;
	u16 tclass;
	u32 requested;
	u32 audited;
	u32 denied;
	int result;
};

struct selinux_audit_rule {
	u32 au_seqno;
	struct context___2 au_ctxt;
};

struct selinux_avc {
	unsigned int avc_cache_threshold;
	struct avc_cache avc_cache;
};

struct selinux_fs_info {
	struct dentry *bool_dir;
	unsigned int bool_num;
	char **bool_pending_names;
	int *bool_pending_values;
	struct dentry *class_dir;
	long unsigned int last_class_ino;
	bool policy_opened;
	struct dentry *policycap_dir;
	long unsigned int last_ino;
	struct super_block *sb;
};

struct selinux_kernel_status {
	u32 version;
	u32 sequence;
	u32 enforcing;
	u32 policyload;
	u32 deny_unknown;
};

struct selinux_policy;

struct selinux_policy_convert_data;

struct selinux_load_state {
	struct selinux_policy *policy;
	struct selinux_policy_convert_data *convert_data;
};

struct selinux_mapping;

struct selinux_map {
	struct selinux_mapping *mapping;
	u16 size;
};

struct selinux_mapping {
	u16 value;
	u16 num_perms;
	u32 perms[32];
};

struct selinux_mnt_opts {
	u32 fscontext_sid;
	u32 context_sid;
	u32 rootcontext_sid;
	u32 defcontext_sid;
};

struct sidtab;

struct selinux_policy {
	struct sidtab *sidtab;
	struct policydb policydb;
	struct selinux_map map;
	u32 latest_granting;
};

struct sidtab_convert_params {
	struct convert_context_args *args;
	struct sidtab *target;
};

struct selinux_policy_convert_data {
	struct convert_context_args args;
	struct sidtab_convert_params sidtab_params;
};

struct selinux_state {
	bool enforcing;
	bool initialized;
	bool policycap[10];
	struct page *status_page;
	struct mutex status_lock;
	struct selinux_policy *policy;
	struct mutex policy_mutex;
};

struct selnl_msg_policyload {
	__u32 seqno;
};

struct selnl_msg_setenforce {
	__s32 val;
};

struct sem {
	int semval;
	struct pid *sempid;
	spinlock_t lock;
	struct list_head pending_alter;
	struct list_head pending_const;
	time64_t sem_otime;
};

struct sem_array {
	struct kern_ipc_perm sem_perm;
	time64_t sem_ctime;
	struct list_head pending_alter;
	struct list_head pending_const;
	struct list_head list_id;
	int sem_nsems;
	int complex_count;
	unsigned int use_global_lock;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct sem sems[0];
};

struct sem_undo;

struct sem_queue {
	struct list_head list;
	struct task_struct *sleeper;
	struct sem_undo *undo;
	struct pid *pid;
	int status;
	struct sembuf *sops;
	struct sembuf *blocking;
	int nsops;
	bool alter;
	bool dupsop;
};

struct sem_undo_list;

struct sem_undo {
	struct list_head list_proc;
	struct callback_head rcu;
	struct sem_undo_list *ulp;
	struct list_head list_id;
	int semid;
	short int semadj[0];
};

struct sem_undo_list {
	refcount_t refcnt;
	spinlock_t lock;
	struct list_head list_proc;
};

struct semaphore_waiter {
	struct list_head list;
	struct task_struct *task;
	bool up;
};

struct sembuf {
	short unsigned int sem_num;
	short int sem_op;
	short int sem_flg;
};

struct semid64_ds {
	struct ipc64_perm sem_perm;
	__kernel_long_t sem_otime;
	__kernel_ulong_t __unused1;
	__kernel_long_t sem_ctime;
	__kernel_ulong_t __unused2;
	__kernel_ulong_t sem_nsems;
	__kernel_ulong_t __unused3;
	__kernel_ulong_t __unused4;
};

struct semid_ds {
	struct ipc_perm sem_perm;
	__kernel_old_time_t sem_otime;
	__kernel_old_time_t sem_ctime;
	struct sem *sem_base;
	struct sem_queue *sem_pending;
	struct sem_queue **sem_pending_last;
	struct sem_undo *undo;
	short unsigned int sem_nsems;
};

struct seminfo {
	int semmap;
	int semmni;
	int semmns;
	int semmnu;
	int semmsl;
	int semopm;
	int semume;
	int semusz;
	int semvmx;
	int semaem;
};

struct virtnet_sq_stats {
	struct u64_stats_sync syncp;
	u64_stats_t packets;
	u64_stats_t bytes;
	u64_stats_t xdp_tx;
	u64_stats_t xdp_tx_drops;
	u64_stats_t kicks;
	u64_stats_t tx_timeouts;
	u64_stats_t stop;
	u64_stats_t wake;
};

struct send_queue {
	struct virtqueue *vq;
	struct scatterlist sg[19];
	char name[16];
	struct virtnet_sq_stats stats;
	struct virtnet_interrupt_coalesce intr_coal;
	struct napi_struct napi;
	bool reset;
	struct xsk_buff_pool *xsk_pool;
	dma_addr_t xsk_hdr_dma_addr;
};

struct send_signal_irq_work {
	struct irq_work irq_work;
	struct task_struct *task;
	u32 sig;
	enum pid_type type;
	bool has_siginfo;
	struct kernel_siginfo info;
};

struct sensor_device_attribute {
	struct device_attribute dev_attr;
	int index;
};

struct seq_operations {
	void * (*start)(struct seq_file *, loff_t *);
	void (*stop)(struct seq_file *, void *);
	void * (*next)(struct seq_file *, void *, loff_t *);
	int (*show)(struct seq_file *, void *);
};

struct seqcount_rwlock {
	seqcount_t seqcount;
};

typedef struct seqcount_rwlock seqcount_rwlock_t;

struct serial8250_config {
	const char *name;
	short unsigned int fifo_size;
	short unsigned int tx_loadsz;
	unsigned char fcr;
	unsigned char rxtrig_bytes[4];
	unsigned int flags;
};

struct serial_ctrl_device {
	struct device dev;
	struct ida port_ida;
};

struct serial_icounter_struct {
	int cts;
	int dsr;
	int rng;
	int dcd;
	int rx;
	int tx;
	int frame;
	int overrun;
	int parity;
	int brk;
	int buf_overrun;
	int reserved[9];
};

struct serial_in_rdev {
	struct rb_root_cached serial_rb;
	spinlock_t serial_lock;
	wait_queue_head_t serial_io_wait;
};

struct serial_port_device {
	struct device dev;
	struct uart_port *port;
	unsigned int tx_enabled: 1;
};

struct serial_private {
	struct pci_dev *dev;
	unsigned int nr;
	struct pci_serial_quirk *quirk;
	const struct pciserial_board *board;
	int line[0];
};

struct serial_struct {
	int type;
	int line;
	unsigned int port;
	int irq;
	int flags;
	int xmit_fifo_size;
	int custom_divisor;
	int baud_base;
	short unsigned int close_delay;
	char io_type;
	char reserved_char[1];
	int hub6;
	short unsigned int closing_wait;
	short unsigned int closing_wait2;
	unsigned char *iomem_base;
	short unsigned int iomem_reg_shift;
	unsigned int port_high;
	long unsigned int iomap_base;
};

struct serial_struct32 {
	compat_int_t type;
	compat_int_t line;
	compat_uint_t port;
	compat_int_t irq;
	compat_int_t flags;
	compat_int_t xmit_fifo_size;
	compat_int_t custom_divisor;
	compat_int_t baud_base;
	short unsigned int close_delay;
	char io_type;
	char reserved_char;
	compat_int_t hub6;
	short unsigned int closing_wait;
	short unsigned int closing_wait2;
	compat_uint_t iomem_base;
	short unsigned int iomem_reg_shift;
	unsigned int port_high;
	compat_int_t reserved;
};

typedef struct serio *class_serio_pause_rx_t;

struct serio_device_id {
	__u8 type;
	__u8 extra;
	__u8 id;
	__u8 proto;
};

struct serio_driver;

struct serio {
	void *port_data;
	char name[32];
	char phys[32];
	char firmware_id[128];
	bool manual_bind;
	struct serio_device_id id;
	spinlock_t lock;
	int (*write)(struct serio *, unsigned char);
	int (*open)(struct serio *);
	void (*close)(struct serio *);
	int (*start)(struct serio *);
	void (*stop)(struct serio *);
	struct serio *parent;
	struct list_head child_node;
	struct list_head children;
	unsigned int depth;
	struct serio_driver *drv;
	struct mutex drv_mutex;
	struct device dev;
	struct list_head node;
	struct mutex *ps2_cmd_mutex;
};

struct serio_driver {
	const char *description;
	const struct serio_device_id *id_table;
	bool manual_bind;
	void (*write_wakeup)(struct serio *);
	irqreturn_t (*interrupt)(struct serio *, unsigned char, unsigned int);
	int (*connect)(struct serio *, struct serio_driver *);
	int (*reconnect)(struct serio *);
	int (*fast_reconnect)(struct serio *);
	void (*disconnect)(struct serio *);
	void (*cleanup)(struct serio *);
	struct device_driver driver;
};

struct serio_event {
	enum serio_event_type type;
	void *object;
	struct module *owner;
	struct list_head node;
};

struct serport {
	struct tty_struct *tty;
	wait_queue_head_t wait;
	struct serio *serio;
	struct serio_device_id id;
	spinlock_t lock;
	long unsigned int flags;
};

struct set_affinity_pending {
	refcount_t refs;
	unsigned int stop_pending;
	struct completion done;
	struct cpu_stop_work stop_work;
	struct migration_arg arg;
};

struct set_config_request {
	struct usb_device *udev;
	int config;
	struct work_struct work;
	struct list_head node;
};

struct set_event_iter {
	enum set_event_iter_type type;
	union {
		struct trace_event_file *file;
		struct event_mod_load *event_mod;
	};
};

struct set_mtrr_data {
	long unsigned int smp_base;
	long unsigned int smp_size;
	unsigned int smp_reg;
	mtrr_type smp_type;
};

struct set_proto_ctx_engines {
	struct drm_i915_private *i915;
	unsigned int num_engines;
	struct i915_gem_proto_engine *engines;
};

struct setup_data_node {
	u64 paddr;
	u32 type;
	u32 len;
};

struct setup_indirect {
	__u32 type;
	__u32 reserved;
	__u64 len;
	__u64 addr;
};

struct sev_config {
	__u64 debug: 1;
	__u64 ghcbs_initialized: 1;
	__u64 use_cas: 1;
	__u64 __reserved: 61;
};

struct severity {
	u64 mask;
	u64 result;
	unsigned char sev;
	short unsigned int mcgmask;
	short unsigned int mcgres;
	unsigned char ser;
	unsigned char context;
	unsigned char excp;
	unsigned char covered;
	unsigned int cpu_vfm;
	unsigned char cpu_minstepping;
	unsigned char bank_lo;
	unsigned char bank_hi;
	char *msg;
};

struct sfc_lock_data {
	i915_reg_t lock_reg;
	i915_reg_t ack_reg;
	i915_reg_t usage_reg;
	u32 lock_bit;
	u32 ack_bit;
	u32 usage_bit;
	u32 reset_bit;
};

struct sfp_eeprom_base {
	u8 phys_id;
	u8 phys_ext_id;
	u8 connector;
	u8 if_1x_copper_passive: 1;
	u8 if_1x_copper_active: 1;
	u8 if_1x_lx: 1;
	u8 if_1x_sx: 1;
	u8 e10g_base_sr: 1;
	u8 e10g_base_lr: 1;
	u8 e10g_base_lrm: 1;
	u8 e10g_base_er: 1;
	u8 sonet_oc3_short_reach: 1;
	u8 sonet_oc3_smf_intermediate_reach: 1;
	u8 sonet_oc3_smf_long_reach: 1;
	u8 unallocated_5_3: 1;
	u8 sonet_oc12_short_reach: 1;
	u8 sonet_oc12_smf_intermediate_reach: 1;
	u8 sonet_oc12_smf_long_reach: 1;
	u8 unallocated_5_7: 1;
	u8 sonet_oc48_short_reach: 1;
	u8 sonet_oc48_intermediate_reach: 1;
	u8 sonet_oc48_long_reach: 1;
	u8 sonet_reach_bit2: 1;
	u8 sonet_reach_bit1: 1;
	u8 sonet_oc192_short_reach: 1;
	u8 escon_smf_1310_laser: 1;
	u8 escon_mmf_1310_led: 1;
	u8 e1000_base_sx: 1;
	u8 e1000_base_lx: 1;
	u8 e1000_base_cx: 1;
	u8 e1000_base_t: 1;
	u8 e100_base_lx: 1;
	u8 e100_base_fx: 1;
	u8 e_base_bx10: 1;
	u8 e_base_px: 1;
	u8 fc_tech_electrical_inter_enclosure: 1;
	u8 fc_tech_lc: 1;
	u8 fc_tech_sa: 1;
	u8 fc_ll_m: 1;
	u8 fc_ll_l: 1;
	u8 fc_ll_i: 1;
	u8 fc_ll_s: 1;
	u8 fc_ll_v: 1;
	u8 unallocated_8_0: 1;
	u8 unallocated_8_1: 1;
	u8 sfp_ct_passive: 1;
	u8 sfp_ct_active: 1;
	u8 fc_tech_ll: 1;
	u8 fc_tech_sl: 1;
	u8 fc_tech_sn: 1;
	u8 fc_tech_electrical_intra_enclosure: 1;
	u8 fc_media_sm: 1;
	u8 unallocated_9_1: 1;
	u8 fc_media_m5: 1;
	u8 fc_media_m6: 1;
	u8 fc_media_tv: 1;
	u8 fc_media_mi: 1;
	u8 fc_media_tp: 1;
	u8 fc_media_tw: 1;
	u8 fc_speed_100: 1;
	u8 unallocated_10_1: 1;
	u8 fc_speed_200: 1;
	u8 fc_speed_3200: 1;
	u8 fc_speed_400: 1;
	u8 fc_speed_1600: 1;
	u8 fc_speed_800: 1;
	u8 fc_speed_1200: 1;
	u8 encoding;
	u8 br_nominal;
	u8 rate_id;
	u8 link_len[6];
	char vendor_name[16];
	u8 extended_cc;
	char vendor_oui[3];
	char vendor_pn[16];
	char vendor_rev[4];
	union {
		__be16 optical_wavelength;
		__be16 cable_compliance;
		struct {
			u8 sff8431_app_e: 1;
			u8 fc_pi_4_app_h: 1;
			u8 reserved60_2: 6;
			u8 reserved61: 8;
		} passive;
		struct {
			u8 sff8431_app_e: 1;
			u8 fc_pi_4_app_h: 1;
			u8 sff8431_lim: 1;
			u8 fc_pi_4_lim: 1;
			u8 reserved60_4: 4;
			u8 reserved61: 8;
		} active;
	};
	u8 reserved62;
	u8 cc_base;
};

struct sfp_eeprom_ext {
	__be16 options;
	u8 br_max;
	u8 br_min;
	char vendor_sn[16];
	char datecode[8];
	u8 diagmon;
	u8 enhopts;
	u8 sff8472_compliance;
	u8 cc_ext;
};

struct sfp_eeprom_id {
	struct sfp_eeprom_base base;
	struct sfp_eeprom_ext ext;
};

struct sfp_upstream_ops {
	void (*attach)(void *, struct sfp_bus *);
	void (*detach)(void *, struct sfp_bus *);
	int (*module_insert)(void *, const struct sfp_eeprom_id *);
	void (*module_remove)(void *);
	int (*module_start)(void *);
	void (*module_stop)(void *);
	void (*link_down)(void *);
	void (*link_up)(void *);
	int (*connect_phy)(void *, struct phy_device *);
	void (*disconnect_phy)(void *, struct phy_device *);
};

struct sg {
	struct ext4_group_info info;
	ext4_grpblk_t counters[18];
};

struct sg_append_table {
	struct sg_table sgt;
	struct scatterlist *prv;
	unsigned int total_nents;
};

struct sg_device {
	struct scsi_device *device;
	wait_queue_head_t open_wait;
	struct mutex open_rel_lock;
	int sg_tablesize;
	u32 index;
	struct list_head sfds;
	rwlock_t sfd_lock;
	atomic_t detaching;
	bool exclude;
	int open_cnt;
	char sgdebug;
	char name[32];
	struct cdev *cdev;
	struct kref d_ref;
};

typedef struct sg_device Sg_device;

struct sg_page_iter {
	struct scatterlist *sg;
	unsigned int sg_pgoffset;
	unsigned int __nents;
	int __pg_advance;
};

struct sg_dma_page_iter {
	struct sg_page_iter base;
};

struct sg_scatter_hold {
	short unsigned int k_use_sg;
	unsigned int sglist_len;
	unsigned int bufflen;
	struct page **pages;
	int page_order;
	char dio_in_use;
	unsigned char cmd_opcode;
};

typedef struct sg_scatter_hold Sg_scatter_hold;

struct sg_io_hdr {
	int interface_id;
	int dxfer_direction;
	unsigned char cmd_len;
	unsigned char mx_sb_len;
	short unsigned int iovec_count;
	unsigned int dxfer_len;
	void *dxferp;
	unsigned char *cmdp;
	void *sbp;
	unsigned int timeout;
	unsigned int flags;
	int pack_id;
	void *usr_ptr;
	unsigned char status;
	unsigned char masked_status;
	unsigned char msg_status;
	unsigned char sb_len_wr;
	short unsigned int host_status;
	short unsigned int driver_status;
	int resid;
	unsigned int duration;
	unsigned int info;
};

typedef struct sg_io_hdr sg_io_hdr_t;

struct sg_fd;

struct sg_request {
	struct list_head entry;
	struct sg_fd *parentfp;
	Sg_scatter_hold data;
	sg_io_hdr_t header;
	unsigned char sense_b[96];
	char res_used;
	char orphan;
	char sg_io_owned;
	char done;
	struct request *rq;
	struct bio *bio;
	struct execute_work ew;
};

typedef struct sg_request Sg_request;

struct sg_fd {
	struct list_head sfd_siblings;
	struct sg_device *parentdp;
	wait_queue_head_t read_wait;
	rwlock_t rq_list_lock;
	struct mutex f_mutex;
	int timeout;
	int timeout_user;
	Sg_scatter_hold reserve;
	struct list_head rq_list;
	struct fasync_struct *async_qp;
	Sg_request req_arr[16];
	char force_packid;
	char cmd_q;
	unsigned char next_cmd_len;
	char keep_orphan;
	char mmap_called;
	char res_in_use;
	struct kref f_ref;
	struct execute_work ew;
};

typedef struct sg_fd Sg_fd;

struct sg_header {
	int pack_len;
	int reply_len;
	int pack_id;
	int result;
	unsigned int twelve_byte: 1;
	unsigned int target_status: 5;
	unsigned int host_status: 8;
	unsigned int driver_status: 8;
	unsigned int other_flags: 10;
	unsigned char sense_buffer[16];
};

struct sg_io_v4 {
	__s32 guard;
	__u32 protocol;
	__u32 subprotocol;
	__u32 request_len;
	__u64 request;
	__u64 request_tag;
	__u32 request_attr;
	__u32 request_priority;
	__u32 request_extra;
	__u32 max_response_len;
	__u64 response;
	__u32 dout_iovec_count;
	__u32 dout_xfer_len;
	__u32 din_iovec_count;
	__u32 din_xfer_len;
	__u64 dout_xferp;
	__u64 din_xferp;
	__u32 timeout;
	__u32 flags;
	__u64 usr_ptr;
	__u32 spare_in;
	__u32 driver_status;
	__u32 transport_status;
	__u32 device_status;
	__u32 retry_delay;
	__u32 info;
	__u32 duration;
	__u32 response_len;
	__s32 din_resid;
	__s32 dout_resid;
	__u64 generated_tag;
	__u32 spare_out;
	__u32 padding;
};

struct sg_list {
	unsigned int n;
	unsigned int size;
	size_t len;
	struct scatterlist *sg;
};

struct sg_mapping_iter {
	struct page *page;
	void *addr;
	size_t length;
	size_t consumed;
	struct sg_page_iter piter;
	unsigned int __offset;
	unsigned int __remaining;
	unsigned int __flags;
};

struct sg_pool {
	size_t size;
	char *name;
	struct kmem_cache *slab;
	mempool_t *pool;
};

struct sg_proc_deviter {
	loff_t index;
	size_t max;
};

struct sg_req_info {
	char req_state;
	char orphan;
	char sg_io_owned;
	char problem;
	int pack_id;
	void *usr_ptr;
	unsigned int duration;
	int unused;
};

typedef struct sg_req_info sg_req_info_t;

struct sg_scsi_id {
	int host_no;
	int channel;
	int scsi_id;
	int lun;
	int scsi_type;
	short int h_cmd_per_lun;
	short int d_queue_depth;
	int unused[2];
};

typedef struct sg_scsi_id sg_scsi_id_t;

struct sgt_dma {
	struct scatterlist *sg;
	dma_addr_t dma;
	dma_addr_t max;
};

struct sha256_state {
	u32 state[8];
	u64 count;
	u8 buf[64];
};

struct sha3_state {
	u64 st[25];
	unsigned int rsiz;
	unsigned int rsizw;
	unsigned int partial;
	u8 buf[144];
};

struct sha512_state {
	u64 state[8];
	u64 count[2];
	u8 buf[128];
};

struct shared_policy {
	struct rb_root root;
	rwlock_t lock;
};

struct shash_alg {
	int (*init)(struct shash_desc *);
	int (*update)(struct shash_desc *, const u8 *, unsigned int);
	int (*final)(struct shash_desc *, u8 *);
	int (*finup)(struct shash_desc *, const u8 *, unsigned int, u8 *);
	int (*digest)(struct shash_desc *, const u8 *, unsigned int, u8 *);
	int (*export)(struct shash_desc *, void *);
	int (*import)(struct shash_desc *, const void *);
	int (*setkey)(struct crypto_shash *, const u8 *, unsigned int);
	int (*init_tfm)(struct crypto_shash *);
	void (*exit_tfm)(struct crypto_shash *);
	int (*clone_tfm)(struct crypto_shash *, struct crypto_shash *);
	unsigned int descsize;
	union {
		struct {
			unsigned int digestsize;
			unsigned int statesize;
			struct crypto_alg base;
		};
		struct hash_alg_common halg;
	};
};

struct shash_instance {
	void (*free)(struct shash_instance *);
	union {
		struct {
			char head[104];
			struct crypto_instance base;
		} s;
		struct shash_alg alg;
	};
};

struct shm_file_data {
	int id;
	struct ipc_namespace *ns;
	struct file *file;
	const struct vm_operations_struct *vm_ops;
};

struct shm_info {
	int used_ids;
	__kernel_ulong_t shm_tot;
	__kernel_ulong_t shm_rss;
	__kernel_ulong_t shm_swp;
	__kernel_ulong_t swap_attempts;
	__kernel_ulong_t swap_successes;
};

struct shmem_falloc {
	wait_queue_head_t *waitq;
	long unsigned int start;
	long unsigned int next;
	long unsigned int nr_falloced;
	long unsigned int nr_unswapped;
};

struct shmem_inode_info {
	spinlock_t lock;
	unsigned int seals;
	long unsigned int flags;
	long unsigned int alloced;
	long unsigned int swapped;
	union {
		struct offset_ctx dir_offsets;
		struct {
			struct list_head shrinklist;
			struct list_head swaplist;
		};
	};
	struct timespec64 i_crtime;
	struct shared_policy policy;
	struct simple_xattrs xattrs;
	long unsigned int fallocend;
	unsigned int fsflags;
	atomic_t stop_eviction;
	struct inode vfs_inode;
};

struct shmem_quota_limits {
	qsize_t usrquota_bhardlimit;
	qsize_t usrquota_ihardlimit;
	qsize_t grpquota_bhardlimit;
	qsize_t grpquota_ihardlimit;
};

struct shmem_options {
	long long unsigned int blocks;
	long long unsigned int inodes;
	struct mempolicy *mpol;
	kuid_t uid;
	kgid_t gid;
	umode_t mode;
	bool full_inums;
	int huge;
	int seen;
	bool noswap;
	short unsigned int quota_types;
	struct shmem_quota_limits qlimits;
};

struct shmem_sb_info {
	long unsigned int max_blocks;
	struct percpu_counter used_blocks;
	long unsigned int max_inodes;
	long unsigned int free_ispace;
	raw_spinlock_t stat_lock;
	umode_t mode;
	unsigned char huge;
	kuid_t uid;
	kgid_t gid;
	bool full_inums;
	bool noswap;
	ino_t next_ino;
	ino_t *ino_batch;
	struct mempolicy *mpol;
	spinlock_t shrinklist_lock;
	struct list_head shrinklist;
	long unsigned int shrinklist_len;
	struct shmem_quota_limits qlimits;
};

struct shmid64_ds {
	struct ipc64_perm shm_perm;
	__kernel_size_t shm_segsz;
	long int shm_atime;
	long int shm_dtime;
	long int shm_ctime;
	__kernel_pid_t shm_cpid;
	__kernel_pid_t shm_lpid;
	long unsigned int shm_nattch;
	long unsigned int __unused4;
	long unsigned int __unused5;
};

struct shmid_ds {
	struct ipc_perm shm_perm;
	int shm_segsz;
	__kernel_old_time_t shm_atime;
	__kernel_old_time_t shm_dtime;
	__kernel_old_time_t shm_ctime;
	__kernel_ipc_pid_t shm_cpid;
	__kernel_ipc_pid_t shm_lpid;
	short unsigned int shm_nattch;
	short unsigned int shm_unused;
	void *shm_unused2;
	void *shm_unused3;
};

struct shmid_kernel {
	struct kern_ipc_perm shm_perm;
	struct file *shm_file;
	long unsigned int shm_nattch;
	long unsigned int shm_segsz;
	time64_t shm_atim;
	time64_t shm_dtim;
	time64_t shm_ctim;
	struct pid *shm_cprid;
	struct pid *shm_lprid;
	struct ucounts *mlock_ucounts;
	struct task_struct *shm_creator;
	struct list_head shm_clist;
	struct ipc_namespace *ns;
	long: 64;
	long: 64;
	long: 64;
};

struct shminfo {
	int shmmax;
	int shmmin;
	int shmmni;
	int shmseg;
	int shmall;
};

struct shminfo64 {
	long unsigned int shmmax;
	long unsigned int shmmin;
	long unsigned int shmmni;
	long unsigned int shmseg;
	long unsigned int shmall;
	long unsigned int __unused1;
	long unsigned int __unused2;
	long unsigned int __unused3;
	long unsigned int __unused4;
};

struct shortname_info {
	unsigned char lower: 1;
	unsigned char upper: 1;
	unsigned char valid: 1;
};

struct show_busy_params {
	struct seq_file *m;
	struct blk_mq_hw_ctx *hctx;
};

struct shrink_control {
	gfp_t gfp_mask;
	int nid;
	long unsigned int nr_to_scan;
	long unsigned int nr_scanned;
	struct mem_cgroup *memcg;
};

struct shrinker {
	long unsigned int (*count_objects)(struct shrinker *, struct shrink_control *);
	long unsigned int (*scan_objects)(struct shrinker *, struct shrink_control *);
	long int batch;
	int seeks;
	unsigned int flags;
	refcount_t refcount;
	struct completion done;
	struct callback_head rcu;
	void *private_data;
	struct list_head list;
	atomic_long_t *nr_deferred;
};

struct sidtab_node_inner;

struct sidtab_node_leaf;

union sidtab_entry_inner {
	struct sidtab_node_inner *ptr_inner;
	struct sidtab_node_leaf *ptr_leaf;
};

struct sidtab_str_cache;

struct sidtab_entry {
	u32 sid;
	u32 hash;
	struct context___2 context;
	struct sidtab_str_cache *cache;
	struct hlist_node list;
};

struct sidtab_isid_entry {
	int set;
	struct sidtab_entry entry;
};

struct sidtab {
	union sidtab_entry_inner roots[4];
	u32 count;
	struct sidtab_convert_params *convert;
	bool frozen;
	spinlock_t lock;
	u32 cache_free_slots;
	struct list_head cache_lru_list;
	spinlock_t cache_lock;
	struct sidtab_isid_entry isids[27];
	struct hlist_head context_to_sid[512];
};

struct sidtab_node_inner {
	union sidtab_entry_inner entries[512];
};

struct sidtab_node_leaf {
	struct sidtab_entry entries[39];
};

struct sidtab_str_cache {
	struct callback_head rcu_member;
	struct list_head lru_member;
	struct sidtab_entry *parent;
	u32 len;
	char str[0];
};

struct sig_alg {
	int (*sign)(struct crypto_sig *, const void *, unsigned int, void *, unsigned int);
	int (*verify)(struct crypto_sig *, const void *, unsigned int, const void *, unsigned int);
	int (*set_pub_key)(struct crypto_sig *, const void *, unsigned int);
	int (*set_priv_key)(struct crypto_sig *, const void *, unsigned int);
	unsigned int (*key_size)(struct crypto_sig *);
	unsigned int (*digest_size)(struct crypto_sig *);
	unsigned int (*max_size)(struct crypto_sig *);
	int (*init)(struct crypto_sig *);
	void (*exit)(struct crypto_sig *);
	struct crypto_alg base;
};

struct sig_instance {
	void (*free)(struct sig_instance *);
	union {
		struct {
			char head[72];
			struct crypto_instance base;
		};
		struct sig_alg alg;
	};
};

typedef struct sigevent sigevent_t;

struct sigframe_ia32 {
	u32 pretcode;
	int sig;
	struct sigcontext_32 sc;
	struct _fpstate_32 fpstate_unused;
	unsigned int extramask[1];
	char retcode[8];
};

struct sighand_struct {
	spinlock_t siglock;
	refcount_t count;
	wait_queue_head_t signalfd_wqh;
	struct k_sigaction action[64];
};

struct sigpending {
	struct list_head list;
	sigset_t signal;
};

struct task_cputime_atomic {
	atomic64_t utime;
	atomic64_t stime;
	atomic64_t sum_exec_runtime;
};

struct thread_group_cputimer {
	struct task_cputime_atomic cputime_atomic;
};

struct task_io_accounting {
	u64 rchar;
	u64 wchar;
	u64 syscr;
	u64 syscw;
	u64 read_bytes;
	u64 write_bytes;
	u64 cancelled_write_bytes;
};

struct taskstats;

struct tty_audit_buf;

struct signal_struct {
	refcount_t sigcnt;
	atomic_t live;
	int nr_threads;
	int quick_threads;
	struct list_head thread_head;
	wait_queue_head_t wait_chldexit;
	struct task_struct *curr_target;
	struct sigpending shared_pending;
	struct hlist_head multiprocess;
	int group_exit_code;
	int notify_count;
	struct task_struct *group_exec_task;
	int group_stop_count;
	unsigned int flags;
	struct core_state *core_state;
	unsigned int is_child_subreaper: 1;
	unsigned int has_child_subreaper: 1;
	unsigned int next_posix_timer_id;
	struct hlist_head posix_timers;
	struct hlist_head ignored_posix_timers;
	struct hrtimer real_timer;
	ktime_t it_real_incr;
	struct cpu_itimer it[2];
	struct thread_group_cputimer cputimer;
	struct posix_cputimers posix_cputimers;
	struct pid *pids[4];
	struct pid *tty_old_pgrp;
	int leader;
	struct tty_struct *tty;
	seqlock_t stats_lock;
	u64 utime;
	u64 stime;
	u64 cutime;
	u64 cstime;
	u64 gtime;
	u64 cgtime;
	struct prev_cputime prev_cputime;
	long unsigned int nvcsw;
	long unsigned int nivcsw;
	long unsigned int cnvcsw;
	long unsigned int cnivcsw;
	long unsigned int min_flt;
	long unsigned int maj_flt;
	long unsigned int cmin_flt;
	long unsigned int cmaj_flt;
	long unsigned int inblock;
	long unsigned int oublock;
	long unsigned int cinblock;
	long unsigned int coublock;
	long unsigned int maxrss;
	long unsigned int cmaxrss;
	struct task_io_accounting ioac;
	long long unsigned int sum_sched_runtime;
	struct rlimit rlim[16];
	struct pacct_struct pacct;
	struct taskstats *stats;
	unsigned int audit_tty;
	struct tty_audit_buf *tty_audit_buf;
	bool oom_flag_origin;
	short int oom_score_adj;
	short int oom_score_adj_min;
	struct mm_struct *oom_mm;
	struct mutex cred_guard_mutex;
	struct rw_semaphore exec_update_lock;
};

struct signalfd_ctx {
	sigset_t sigmask;
};

struct signalfd_siginfo {
	__u32 ssi_signo;
	__s32 ssi_errno;
	__s32 ssi_code;
	__u32 ssi_pid;
	__u32 ssi_uid;
	__s32 ssi_fd;
	__u32 ssi_tid;
	__u32 ssi_band;
	__u32 ssi_overrun;
	__u32 ssi_trapno;
	__s32 ssi_status;
	__s32 ssi_int;
	__u64 ssi_ptr;
	__u64 ssi_utime;
	__u64 ssi_stime;
	__u64 ssi_addr;
	__u16 ssi_addr_lsb;
	__u16 __pad2;
	__s32 ssi_syscall;
	__u64 ssi_call_addr;
	__u32 ssi_arch;
	__u8 __pad[28];
};

struct sigpool_entry {
	struct crypto_ahash *hash;
	const char *alg;
	struct kref kref;
	uint16_t needs_key: 1;
	uint16_t reserved: 15;
};

struct sigpool_scratch {
	local_lock_t bh_lock;
	void *pad;
};

struct sigset_argpack {
	sigset_t *p;
	size_t size;
};

struct sil164_priv {
	bool quiet;
};

struct simple_attr {
	int (*get)(void *, u64 *);
	int (*set)(void *, u64);
	char get_buf[24];
	char set_buf[24];
	void *data;
	const char *fmt;
	struct mutex mutex;
};

struct simple_transaction_argresp {
	ssize_t size;
	char data[0];
};

struct simple_xattr {
	struct rb_node rb_node;
	char *name;
	size_t size;
	char value[0];
};

struct sioc_sg_req {
	struct in_addr src;
	struct in_addr grp;
	long unsigned int pktcnt;
	long unsigned int bytecnt;
	long unsigned int wrong_if;
};

struct sioc_vif_req {
	vifi_t vifi;
	long unsigned int icount;
	long unsigned int ocount;
	long unsigned int ibytes;
	long unsigned int obytes;
};

struct sip_handler {
	const char *method;
	unsigned int len;
	int (*request)(struct sk_buff *, unsigned int, unsigned int, const char **, unsigned int *, unsigned int);
	int (*response)(struct sk_buff *, unsigned int, unsigned int, const char **, unsigned int *, unsigned int, unsigned int);
};

struct sip_header {
	const char *name;
	const char *cname;
	const char *search;
	unsigned int len;
	unsigned int clen;
	unsigned int slen;
	int (*match_len)(const struct nf_conn *, const char *, const char *, int *);
};

struct sit_net {
	struct ip_tunnel *tunnels_r_l[16];
	struct ip_tunnel *tunnels_r[16];
	struct ip_tunnel *tunnels_l[16];
	struct ip_tunnel *tunnels_wc[1];
	struct ip_tunnel **tunnels[4];
	struct net_device *fb_tunnel_dev;
};

struct sixaxis_led {
	u8 time_enabled;
	u8 duty_length;
	u8 enabled;
	u8 duty_off;
	u8 duty_on;
};

struct sixaxis_rumble {
	u8 padding;
	u8 right_duration;
	u8 right_motor_on;
	u8 left_duration;
	u8 left_motor_force;
};

struct sixaxis_output_report {
	u8 report_id;
	struct sixaxis_rumble rumble;
	u8 padding[4];
	u8 leds_bitmap;
	struct sixaxis_led led[4];
	struct sixaxis_led _reserved;
};

union sixaxis_output_report_01 {
	struct sixaxis_output_report data;
	u8 buf[36];
};

struct sk_buff__safe_rcu_or_null {
	struct sock *sk;
};

struct sk_buff_fclones {
	struct sk_buff skb1;
	struct sk_buff skb2;
	refcount_t fclone_ref;
};

struct sk_filter {
	refcount_t refcnt;
	struct callback_head rcu;
	struct bpf_prog *prog;
};

struct sk_psock_work_state {
	u32 len;
	u32 off;
};

struct sk_psock {
	struct sock *sk;
	struct sock *sk_redir;
	u32 apply_bytes;
	u32 cork_bytes;
	u32 eval;
	bool redir_ingress;
	struct sk_msg *cork;
	struct sk_psock_progs progs;
	struct sk_buff_head ingress_skb;
	struct list_head ingress_msg;
	spinlock_t ingress_lock;
	long unsigned int state;
	struct list_head link;
	spinlock_t link_lock;
	refcount_t refcnt;
	void (*saved_unhash)(struct sock *);
	void (*saved_destroy)(struct sock *);
	void (*saved_close)(struct sock *, long int);
	void (*saved_write_space)(struct sock *);
	void (*saved_data_ready)(struct sock *);
	int (*psock_update_sk_prot)(struct sock *, struct sk_psock *, bool);
	struct proto *sk_proto;
	struct mutex work_mutex;
	struct sk_psock_work_state work_state;
	struct delayed_work work;
	struct sock *sk_pair;
	struct rcu_work rwork;
};

struct sk_psock_link {
	struct list_head list;
	struct bpf_map *map;
	void *link_raw;
};

struct sk_security_struct {
	enum {
		NLBL_UNSET = 0,
		NLBL_REQUIRE = 1,
		NLBL_LABELED = 2,
		NLBL_REQSKB = 3,
		NLBL_CONNLABELED = 4,
	} nlbl_state;
	struct netlbl_lsm_secattr *nlbl_secattr;
	u32 sid;
	u32 peer_sid;
	u16 sclass;
	enum {
		SCTP_ASSOC_UNSET = 0,
		SCTP_ASSOC_SET = 1,
	} sctp_assoc_state;
};

struct tls_msg {
	u8 control;
};

struct sk_skb_cb {
	unsigned char data[20];
	unsigned char pad[4];
	struct _strp_msg strp;
	struct tls_msg tls;
	u64 temp_reg;
};

struct skb_checksum_ops {
	__wsum (*update)(const void *, int, __wsum);
	__wsum (*combine)(__wsum, __wsum, int, int);
};

struct skb_ext {
	refcount_t refcnt;
	u8 offset[1];
	u8 chunks;
	long: 0;
	char data[0];
};

struct skb_frag {
	netmem_ref netmem;
	unsigned int len;
	unsigned int offset;
};

typedef struct skb_frag skb_frag_t;

struct skb_free_array {
	unsigned int skb_count;
	void *skb_array[16];
};

struct skb_gso_cb {
	union {
		int mac_offset;
		int data_offset;
	};
	int encap_level;
	__wsum csum;
	__u16 csum_start;
};

struct skb_seq_state {
	__u32 lower_offset;
	__u32 upper_offset;
	__u32 frag_idx;
	__u32 stepped_offset;
	struct sk_buff *root_skb;
	struct sk_buff *cur_skb;
	__u8 *frag_data;
	__u32 frag_off;
};

struct skb_shared_hwtstamps {
	union {
		ktime_t hwtstamp;
		void *netdev_data;
	};
};

struct xsk_tx_metadata_compl {
	__u64 *tx_timestamp;
};

struct skb_shared_info {
	__u8 flags;
	__u8 meta_len;
	__u8 nr_frags;
	__u8 tx_flags;
	short unsigned int gso_size;
	short unsigned int gso_segs;
	struct sk_buff *frag_list;
	union {
		struct skb_shared_hwtstamps hwtstamps;
		struct xsk_tx_metadata_compl xsk_meta;
	};
	unsigned int gso_type;
	u32 tskey;
	atomic_t dataref;
	union {
		struct {
			u32 xdp_frags_size;
			u32 xdp_frags_truesize;
		};
		void *destructor_arg;
	};
	skb_frag_t frags[17];
};

struct skcipher_alg {
	int (*setkey)(struct crypto_skcipher *, const u8 *, unsigned int);
	int (*encrypt)(struct skcipher_request *);
	int (*decrypt)(struct skcipher_request *);
	int (*export)(struct skcipher_request *, void *);
	int (*import)(struct skcipher_request *, const void *);
	int (*init)(struct crypto_skcipher *);
	void (*exit)(struct crypto_skcipher *);
	unsigned int walksize;
	union {
		struct {
			unsigned int min_keysize;
			unsigned int max_keysize;
			unsigned int ivsize;
			unsigned int chunksize;
			unsigned int statesize;
			struct crypto_alg base;
		};
		struct skcipher_alg_common co;
	};
};

struct skcipher_ctx_simple {
	struct crypto_cipher *cipher;
};

struct skcipher_instance {
	void (*free)(struct skcipher_instance *);
	union {
		struct {
			char head[88];
			struct crypto_instance base;
		} s;
		struct skcipher_alg alg;
	};
};

struct skcipher_walk {
	union {
		struct {
			void *addr;
		} virt;
	} src;
	union {
		struct {
			void *addr;
		} virt;
	} dst;
	struct scatter_walk in;
	unsigned int nbytes;
	struct scatter_walk out;
	unsigned int total;
	u8 *page;
	u8 *buffer;
	u8 *oiv;
	void *iv;
	unsigned int ivsize;
	int flags;
	unsigned int blocksize;
	unsigned int stride;
	unsigned int alignmask;
};

struct skl_dpll_regs {
	i915_reg_t ctl;
	i915_reg_t cfgcr1;
	i915_reg_t cfgcr2;
};

struct skl_hw_state {
	struct skl_ddb_entry ddb[8];
	struct skl_ddb_entry ddb_y[8];
	u16 min_ddb[8];
	u16 interim_ddb[8];
	struct skl_pipe_wm wm;
};

struct skl_plane_ddb_iter {
	u64 data_rate;
	u16 start;
	u16 size;
};

struct skl_wm_params {
	bool x_tiled;
	bool y_tiled;
	bool rc_surface;
	bool is_planar;
	u32 width;
	u8 cpp;
	u32 plane_pixel_rate;
	u32 y_min_scanlines;
	u32 plane_bytes_per_line;
	uint_fixed_16_16_t plane_blocks_per_line;
	uint_fixed_16_16_t y_tile_minimum;
	u32 linetime_us;
	u32 dbuf_block_size;
};

struct skl_wrpll_context {
	u64 min_deviation;
	u64 central_freq;
	u64 dco_freq;
	unsigned int p;
};

struct sku_microcode {
	u32 vfm;
	u8 stepping;
	u32 microcode;
};

struct sky2_status_le;

struct sky2_hw {
	void *regs;
	struct pci_dev *pdev;
	struct napi_struct napi;
	struct net_device *dev[2];
	long unsigned int flags;
	u8 chip_id;
	u8 chip_rev;
	u8 pmd_type;
	u8 ports;
	struct sky2_status_le *st_le;
	u32 st_size;
	u32 st_idx;
	dma_addr_t st_dma;
	struct timer_list watchdog_timer;
	struct work_struct restart_work;
	wait_queue_head_t msi_wait;
	char irq_name[0];
};

struct sky2_stats {
	struct u64_stats_sync syncp;
	u64 packets;
	u64 bytes;
};

struct tx_ring_info;

struct sky2_tx_le;

struct sky2_rx_le;

struct sky2_port {
	struct sky2_hw *hw;
	struct net_device *netdev;
	unsigned int port;
	u32 msg_enable;
	spinlock_t phy_lock;
	struct tx_ring_info *tx_ring;
	struct sky2_tx_le *tx_le;
	struct sky2_stats tx_stats;
	u16 tx_ring_size;
	u16 tx_cons;
	u16 tx_prod;
	u16 tx_next;
	u16 tx_pending;
	u16 tx_last_mss;
	u32 tx_last_upper;
	u32 tx_tcpsum;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct rx_ring_info *rx_ring;
	struct sky2_rx_le *rx_le;
	struct sky2_stats rx_stats;
	u16 rx_next;
	u16 rx_put;
	u16 rx_pending;
	u16 rx_data_size;
	u16 rx_nfrags;
	long unsigned int last_rx;
	struct {
		long unsigned int last;
		u32 mac_rp;
		u8 mac_lev;
		u8 fifo_rp;
		u8 fifo_lev;
	} check;
	dma_addr_t rx_le_map;
	dma_addr_t tx_le_map;
	u16 advertising;
	u16 speed;
	u8 wol;
	u8 duplex;
	u16 flags;
	enum flow_control flow_mode;
	enum flow_control flow_status;
	long: 64;
	long: 64;
	long: 64;
};

struct sky2_rx_le {
	__le32 addr;
	__le16 length;
	u8 ctrl;
	u8 opcode;
};

struct sky2_stat {
	char name[32];
	u16 offset;
};

struct sky2_status_le {
	__le32 status;
	__le16 length;
	u8 css;
	u8 opcode;
};

struct sky2_tx_le {
	__le32 addr;
	__le16 length;
	u8 ctrl;
	u8 opcode;
};

struct slab {
	long unsigned int __page_flags;
	struct kmem_cache *slab_cache;
	union {
		struct {
			union {
				struct list_head slab_list;
				struct {
					struct slab *next;
					int slabs;
				};
			};
			union {
				struct {
					void *freelist;
					union {
						long unsigned int counters;
						struct {
							unsigned int inuse: 16;
							unsigned int objects: 15;
							unsigned int frozen: 1;
						};
					};
				};
				freelist_aba_t freelist_counter;
			};
		};
		struct callback_head callback_head;
	};
	unsigned int __page_type;
	atomic_t __page_refcount;
	long: 64;
};

struct slab_attribute {
	struct attribute attr;
	ssize_t (*show)(struct kmem_cache *, char *);
	ssize_t (*store)(struct kmem_cache *, const char *, size_t);
};

struct slabinfo {
	long unsigned int active_objs;
	long unsigned int num_objs;
	long unsigned int active_slabs;
	long unsigned int num_slabs;
	long unsigned int shared_avail;
	unsigned int limit;
	unsigned int batchcount;
	unsigned int shared;
	unsigned int objects_per_slab;
	unsigned int cache_order;
};

struct slpc_override_params {
	u32 bits[8];
	u32 values[256];
};

struct slpc_shared_data_header {
	u32 size;
	u32 global_state;
	u32 display_data_addr;
};

struct slpc_task_state_data {
	union {
		u32 task_status_padding;
		struct {
			u32 status;
		};
	};
	union {
		u32 freq_padding;
		struct {
			u32 freq;
		};
	};
};

struct slpc_shared_data {
	struct slpc_shared_data_header header;
	u8 shared_data_header_pad[52];
	u8 platform_info_pad[64];
	struct slpc_task_state_data task_state_data;
	u8 task_state_data_pad[56];
	struct slpc_override_params override_params;
	u8 override_params_pad[32];
	u8 shared_data_pad[2816];
	u8 reserved_mode_definition[4096];
};

struct slub_flush_work {
	struct work_struct work;
	struct kmem_cache *s;
	bool skip;
};

struct smca_hwid;

struct smca_bank {
	const struct smca_hwid *hwid;
	u32 id;
	u8 sysfs_id;
};

struct smca_hwid {
	unsigned int bank_type;
	u32 hwid_mcatype;
};

struct smp_alt_module {
	struct module *mod;
	char *name;
	const s32 *locks;
	const s32 *locks_end;
	u8 *text;
	u8 *text_end;
	struct list_head next;
};

struct smp_call_on_cpu_struct {
	struct work_struct work;
	struct completion done;
	int (*func)(void *);
	void *data;
	int ret;
	int cpu;
};

struct smp_hotplug_thread {
	struct task_struct **store;
	struct list_head list;
	int (*thread_should_run)(unsigned int);
	void (*thread_fn)(unsigned int);
	void (*create)(unsigned int);
	void (*setup)(unsigned int);
	void (*cleanup)(unsigned int, bool);
	void (*park)(unsigned int);
	void (*unpark)(unsigned int);
	bool selfparking;
	const char *thread_comm;
};

struct smp_ops {
	void (*smp_prepare_boot_cpu)(void);
	void (*smp_prepare_cpus)(unsigned int);
	void (*smp_cpus_done)(unsigned int);
	void (*stop_other_cpus)(int);
	void (*crash_stop_other_cpus)(void);
	void (*smp_send_reschedule)(int);
	void (*cleanup_dead_cpu)(unsigned int);
	void (*poll_sync_state)(void);
	int (*kick_ap_alive)(unsigned int, struct task_struct *);
	int (*cpu_disable)(void);
	void (*cpu_die)(unsigned int);
	void (*play_dead)(void);
	void (*stop_this_cpu)(void);
	void (*send_call_func_ipi)(const struct cpumask *);
	void (*send_call_func_single_ipi)(int);
};

struct smpboot_thread_data {
	unsigned int cpu;
	unsigned int status;
	struct smp_hotplug_thread *ht;
};

struct snap {
	int slen;
	char str[80];
};

struct snapshot_handle {
	unsigned int cur;
	void *buffer;
	int sync_read;
};

struct snapshot_data {
	struct snapshot_handle handle;
	int swap;
	int mode;
	bool frozen;
	bool ready;
	bool platform_support;
	bool free_bitmaps;
	dev_t dev;
};

struct snd_aes_iec958 {
	unsigned char status[24];
	unsigned char subcode[147];
	unsigned char pad;
	unsigned char dig_subframe[4];
};

struct snd_shutdown_f_ops;

struct snd_info_entry;

struct snd_card {
	int number;
	char id[16];
	char driver[16];
	char shortname[32];
	char longname[80];
	char irq_descr[32];
	char mixername[80];
	char components[128];
	struct module *module;
	void *private_data;
	void (*private_free)(struct snd_card *);
	struct list_head devices;
	struct device *ctl_dev;
	unsigned int last_numid;
	struct rw_semaphore controls_rwsem;
	rwlock_t controls_rwlock;
	int controls_count;
	size_t user_ctl_alloc_size;
	struct list_head controls;
	struct list_head ctl_files;
	struct xarray ctl_numids;
	struct xarray ctl_hash;
	bool ctl_hash_collision;
	struct snd_info_entry *proc_root;
	struct proc_dir_entry *proc_root_link;
	struct list_head files_list;
	struct snd_shutdown_f_ops *s_f_ops;
	spinlock_t files_lock;
	int shutdown;
	struct completion *release_completion;
	struct device *dev;
	struct device card_dev;
	const struct attribute_group *dev_groups[4];
	bool registered;
	bool managed;
	bool releasing;
	int sync_irq;
	wait_queue_head_t remove_sleep;
	size_t total_pcm_alloc_bytes;
	struct mutex memory_mutex;
	unsigned int power_state;
	atomic_t power_ref;
	wait_queue_head_t power_sleep;
	wait_queue_head_t power_ref_sleep;
};

struct snd_enc_wma {
	__u32 super_block_align;
};

struct snd_enc_vorbis {
	__s32 quality;
	__u32 managed;
	__u32 max_bit_rate;
	__u32 min_bit_rate;
	__u32 downmix;
};

struct snd_enc_real {
	__u32 quant_bits;
	__u32 start_region;
	__u32 num_regions;
};

struct snd_enc_flac {
	__u32 num;
	__u32 gain;
};

struct snd_enc_generic {
	__u32 bw;
	__s32 reserved[15];
};

struct snd_dec_flac {
	__u16 sample_size;
	__u16 min_blk_size;
	__u16 max_blk_size;
	__u16 min_frame_size;
	__u16 max_frame_size;
	__u16 reserved;
};

struct snd_dec_wma {
	__u32 encoder_option;
	__u32 adv_encoder_option;
	__u32 adv_encoder_option2;
	__u32 reserved;
};

struct snd_dec_alac {
	__u32 frame_length;
	__u8 compatible_version;
	__u8 pb;
	__u8 mb;
	__u8 kb;
	__u32 max_run;
	__u32 max_frame_bytes;
};

struct snd_dec_ape {
	__u16 compatible_version;
	__u16 compression_level;
	__u32 format_flags;
	__u32 blocks_per_frame;
	__u32 final_frame_blocks;
	__u32 total_frames;
	__u32 seek_table_present;
};

union snd_codec_options {
	struct snd_enc_wma wma;
	struct snd_enc_vorbis vorbis;
	struct snd_enc_real real;
	struct snd_enc_flac flac;
	struct snd_enc_generic generic;
	struct snd_dec_flac flac_d;
	struct snd_dec_wma wma_d;
	struct snd_dec_alac alac_d;
	struct snd_dec_ape ape_d;
	struct {
		__u32 out_sample_rate;
	} src_d;
};

struct snd_codec {
	__u32 id;
	__u32 ch_in;
	__u32 ch_out;
	__u32 sample_rate;
	__u32 bit_rate;
	__u32 rate_control;
	__u32 profile;
	__u32 level;
	__u32 ch_mode;
	__u32 format;
	__u32 align;
	union snd_codec_options options;
	__u32 pcm_format;
	__u32 reserved[2];
};

struct snd_codec_desc_src {
	__u32 out_sample_rate_min;
	__u32 out_sample_rate_max;
};

struct snd_codec_desc {
	__u32 max_ch;
	__u32 sample_rates[32];
	__u32 num_sample_rates;
	__u32 bit_rate[32];
	__u32 num_bitrates;
	__u32 rate_control;
	__u32 profiles;
	__u32 modes;
	__u32 formats;
	__u32 min_buffer;
	__u32 pcm_formats;
	union {
		__u32 u_space[6];
		struct snd_codec_desc_src src;
	};
	__u32 reserved[8];
};

struct snd_compr_ops;

struct snd_compr {
	const char *name;
	struct device *dev;
	struct snd_compr_ops *ops;
	void *private_data;
	struct snd_card *card;
	unsigned int direction;
	struct mutex lock;
	int device;
	bool use_pause_in_draining;
	char id[64];
	struct snd_info_entry *proc_root;
	struct snd_info_entry *proc_info_entry;
};

struct snd_compr_caps {
	__u32 num_codecs;
	__u32 direction;
	__u32 min_fragment_size;
	__u32 max_fragment_size;
	__u32 min_fragments;
	__u32 max_fragments;
	__u32 codecs[32];
	__u32 reserved[11];
};

struct snd_compr_codec_caps {
	__u32 codec;
	__u32 num_descriptors;
	struct snd_codec_desc descriptor[32];
};

struct snd_compr_metadata {
	__u32 key;
	__u32 value[8];
};

struct snd_compr_params;

struct snd_compr_tstamp;

struct snd_compr_ops {
	int (*open)(struct snd_compr_stream *);
	int (*free)(struct snd_compr_stream *);
	int (*set_params)(struct snd_compr_stream *, struct snd_compr_params *);
	int (*get_params)(struct snd_compr_stream *, struct snd_codec *);
	int (*set_metadata)(struct snd_compr_stream *, struct snd_compr_metadata *);
	int (*get_metadata)(struct snd_compr_stream *, struct snd_compr_metadata *);
	int (*trigger)(struct snd_compr_stream *, int);
	int (*pointer)(struct snd_compr_stream *, struct snd_compr_tstamp *);
	int (*copy)(struct snd_compr_stream *, char *, size_t);
	int (*mmap)(struct snd_compr_stream *, struct vm_area_struct *);
	int (*ack)(struct snd_compr_stream *, size_t);
	int (*get_caps)(struct snd_compr_stream *, struct snd_compr_caps *);
	int (*get_codec_caps)(struct snd_compr_stream *, struct snd_compr_codec_caps *);
};

struct snd_compressed_buffer {
	__u32 fragment_size;
	__u32 fragments;
};

struct snd_compr_params {
	struct snd_compressed_buffer buffer;
	struct snd_codec codec;
	__u8 no_wake_mode;
};

struct snd_compr_runtime {
	snd_pcm_state_t state;
	struct snd_compr_ops *ops;
	void *buffer;
	u64 buffer_size;
	u32 fragment_size;
	u32 fragments;
	u64 total_bytes_available;
	u64 total_bytes_transferred;
	wait_queue_head_t sleep;
	void *private_data;
	unsigned char *dma_area;
	dma_addr_t dma_addr;
	size_t dma_bytes;
	struct snd_dma_buffer *dma_buffer_p;
};

struct snd_compr_stream {
	const char *name;
	struct snd_compr_ops *ops;
	struct snd_compr_runtime *runtime;
	struct snd_compr *device;
	struct delayed_work error_work;
	enum snd_compr_direction direction;
	bool metadata_set;
	bool next_track;
	bool partial_drain;
	bool pause_in_draining;
	void *private_data;
	struct snd_dma_buffer dma_buffer;
};

struct snd_compr_tstamp {
	__u32 byte_offset;
	__u32 copied_total;
	__u32 pcm_frames;
	__u32 pcm_io_frames;
	__u32 sampling_rate;
};

struct snd_ctl_card_info {
	int card;
	int pad;
	unsigned char id[16];
	unsigned char driver[16];
	unsigned char name[32];
	unsigned char longname[80];
	unsigned char reserved_[16];
	unsigned char mixername[80];
	unsigned char components[128];
};

struct snd_ctl_elem_info {
	struct snd_ctl_elem_id id;
	snd_ctl_elem_type_t type;
	unsigned int access;
	unsigned int count;
	__kernel_pid_t owner;
	union {
		struct {
			long int min;
			long int max;
			long int step;
		} integer;
		struct {
			long long int min;
			long long int max;
			long long int step;
		} integer64;
		struct {
			unsigned int items;
			unsigned int item;
			char name[64];
			__u64 names_ptr;
			unsigned int names_length;
		} enumerated;
		unsigned char reserved[128];
	} value;
	unsigned char reserved[64];
};

struct snd_ctl_elem_info32 {
	struct snd_ctl_elem_id id;
	s32 type;
	u32 access;
	u32 count;
	s32 owner;
	union {
		struct {
			s32 min;
			s32 max;
			s32 step;
		} integer;
		struct {
			u64 min;
			u64 max;
			u64 step;
		} integer64;
		struct {
			u32 items;
			u32 item;
			char name[64];
			u64 names_ptr;
			u32 names_length;
		} enumerated;
		unsigned char reserved[128];
	} value;
	unsigned char reserved[64];
};

struct snd_ctl_elem_list {
	unsigned int offset;
	unsigned int space;
	unsigned int used;
	unsigned int count;
	struct snd_ctl_elem_id *pids;
	unsigned char reserved[50];
};

struct snd_ctl_elem_list32 {
	u32 offset;
	u32 space;
	u32 used;
	u32 count;
	u32 pids;
	unsigned char reserved[50];
};

struct snd_ctl_elem_value {
	struct snd_ctl_elem_id id;
	unsigned int indirect: 1;
	union {
		union {
			long int value[128];
			long int *value_ptr;
		} integer;
		union {
			long long int value[64];
			long long int *value_ptr;
		} integer64;
		union {
			unsigned int item[128];
			unsigned int *item_ptr;
		} enumerated;
		union {
			unsigned char data[512];
			unsigned char *data_ptr;
		} bytes;
		struct snd_aes_iec958 iec958;
	} value;
	unsigned char reserved[128];
};

struct snd_ctl_elem_value32 {
	struct snd_ctl_elem_id id;
	unsigned int indirect;
	union {
		s32 integer[128];
		unsigned char data[512];
	} value;
	unsigned char reserved[128];
};

struct snd_ctl_event {
	int type;
	union {
		struct {
			unsigned int mask;
			struct snd_ctl_elem_id id;
		} elem;
		unsigned char data8[60];
	} data;
};

struct snd_fasync;

struct snd_ctl_file {
	struct list_head list;
	struct snd_card *card;
	struct pid *pid;
	int preferred_subdevice[2];
	wait_queue_head_t change_sleep;
	spinlock_t read_lock;
	struct snd_fasync *fasync;
	int subscribed;
	struct list_head events;
};

struct snd_ctl_layer_ops {
	struct snd_ctl_layer_ops *next;
	const char *module_name;
	void (*lregister)(struct snd_card *);
	void (*ldisconnect)(struct snd_card *);
	void (*lnotify)(struct snd_card *, unsigned int, struct snd_kcontrol *, unsigned int);
};

struct snd_ctl_tlv {
	unsigned int numid;
	unsigned int length;
	unsigned int tlv[0];
};

struct snd_device_ops;

struct snd_device {
	struct list_head list;
	struct snd_card *card;
	enum snd_device_state state;
	enum snd_device_type type;
	void *device_data;
	const struct snd_device_ops *ops;
};

struct snd_device_ops {
	int (*dev_free)(struct snd_device *);
	int (*dev_register)(struct snd_device *);
	int (*dev_disconnect)(struct snd_device *);
};

struct snd_dma_data {
	int dma;
};

struct snd_dma_sg_fallback {
	struct sg_table sgt;
	size_t count;
	struct page **pages;
	unsigned int *npages;
};

struct snd_fasync {
	struct fasync_struct *fasync;
	int signal;
	int poll;
	int on;
	struct list_head list;
};

struct snd_hda_pin_quirk {
	unsigned int codec;
	short unsigned int subvendor;
	const struct hda_pintbl *pins;
	int value;
};

struct snd_timer;

struct snd_hrtimer {
	struct snd_timer *timer;
	struct hrtimer hrt;
	bool in_callback;
};

struct snd_hwdep_dsp_status;

struct snd_hwdep_dsp_image;

struct snd_hwdep_ops {
	long long int (*llseek)(struct snd_hwdep *, struct file *, long long int, int);
	long int (*read)(struct snd_hwdep *, char *, long int, loff_t *);
	long int (*write)(struct snd_hwdep *, const char *, long int, loff_t *);
	int (*open)(struct snd_hwdep *, struct file *);
	int (*release)(struct snd_hwdep *, struct file *);
	__poll_t (*poll)(struct snd_hwdep *, struct file *, poll_table *);
	int (*ioctl)(struct snd_hwdep *, struct file *, unsigned int, long unsigned int);
	int (*ioctl_compat)(struct snd_hwdep *, struct file *, unsigned int, long unsigned int);
	int (*mmap)(struct snd_hwdep *, struct file *, struct vm_area_struct *);
	int (*dsp_status)(struct snd_hwdep *, struct snd_hwdep_dsp_status *);
	int (*dsp_load)(struct snd_hwdep *, struct snd_hwdep_dsp_image *);
};

struct snd_hwdep {
	struct snd_card *card;
	struct list_head list;
	int device;
	char id[32];
	char name[80];
	int iface;
	struct snd_hwdep_ops ops;
	wait_queue_head_t open_wait;
	void *private_data;
	void (*private_free)(struct snd_hwdep *);
	struct device *dev;
	struct mutex open_mutex;
	int used;
	unsigned int dsp_loaded;
	unsigned int exclusive: 1;
};

struct snd_hwdep_dsp_image {
	unsigned int index;
	unsigned char name[64];
	unsigned char *image;
	size_t length;
	long unsigned int driver_data;
};

struct snd_hwdep_dsp_image32 {
	u32 index;
	unsigned char name[64];
	u32 image;
	u32 length;
	u32 driver_data;
};

struct snd_hwdep_dsp_status {
	unsigned int version;
	unsigned char id[32];
	unsigned int num_dsps;
	unsigned int dsp_loaded;
	unsigned int chip_ready;
	unsigned char reserved[16];
};

struct snd_hwdep_info {
	unsigned int device;
	int card;
	unsigned char id[64];
	unsigned char name[80];
	int iface;
	unsigned char reserved[64];
};

struct snd_info_buffer {
	char *buffer;
	unsigned int curr;
	unsigned int size;
	unsigned int len;
	int stop;
	int error;
};

struct snd_info_entry_text {
	void (*read)(struct snd_info_entry *, struct snd_info_buffer *);
	void (*write)(struct snd_info_entry *, struct snd_info_buffer *);
};

struct snd_info_entry_ops;

struct snd_info_entry {
	const char *name;
	umode_t mode;
	long int size;
	short unsigned int content;
	union {
		struct snd_info_entry_text text;
		const struct snd_info_entry_ops *ops;
	} c;
	struct snd_info_entry *parent;
	struct module *module;
	void *private_data;
	void (*private_free)(struct snd_info_entry *);
	struct proc_dir_entry *p;
	struct mutex access;
	struct list_head children;
	struct list_head list;
};

struct snd_info_entry_ops {
	int (*open)(struct snd_info_entry *, short unsigned int, void **);
	int (*release)(struct snd_info_entry *, short unsigned int, void *);
	ssize_t (*read)(struct snd_info_entry *, void *, struct file *, char *, size_t, loff_t);
	ssize_t (*write)(struct snd_info_entry *, void *, struct file *, const char *, size_t, loff_t);
	loff_t (*llseek)(struct snd_info_entry *, void *, struct file *, loff_t, int);
	__poll_t (*poll)(struct snd_info_entry *, void *, struct file *, poll_table *);
	int (*ioctl)(struct snd_info_entry *, void *, struct file *, unsigned int, long unsigned int);
	int (*mmap)(struct snd_info_entry *, void *, struct inode *, struct file *, struct vm_area_struct *);
};

struct snd_info_private_data {
	struct snd_info_buffer *rbuffer;
	struct snd_info_buffer *wbuffer;
	struct snd_info_entry *entry;
	void *file_private_data;
};

struct snd_interval {
	unsigned int min;
	unsigned int max;
	unsigned int openmin: 1;
	unsigned int openmax: 1;
	unsigned int integer: 1;
	unsigned int empty: 1;
};

struct snd_jack {
	struct list_head kctl_list;
	struct snd_card *card;
	const char *id;
	struct input_dev *input_dev;
	struct mutex input_dev_lock;
	int registered;
	int type;
	char name[100];
	unsigned int key[6];
	int hw_status_cache;
	void *private_data;
	void (*private_free)(struct snd_jack *);
};

struct snd_jack_kctl {
	struct snd_kcontrol *kctl;
	struct list_head list;
	unsigned int mask_bits;
	struct snd_jack *jack;
	bool sw_inject_enable;
};

struct snd_kcontrol_new {
	snd_ctl_elem_iface_t iface;
	unsigned int device;
	unsigned int subdevice;
	const char *name;
	unsigned int index;
	unsigned int access;
	unsigned int count;
	snd_kcontrol_info_t *info;
	snd_kcontrol_get_t *get;
	snd_kcontrol_put_t *put;
	union {
		snd_kcontrol_tlv_rw_t *c;
		const unsigned int *p;
	} tlv;
	long unsigned int private_value;
};

struct snd_kctl_event {
	struct list_head list;
	struct snd_ctl_elem_id id;
	unsigned int mask;
};

typedef int (*snd_kctl_ioctl_func_t)(struct snd_card *, struct snd_ctl_file *, unsigned int, long unsigned int);

struct snd_kctl_ioctl {
	struct list_head list;
	snd_kctl_ioctl_func_t fioctl;
};

struct snd_malloc_ops {
	void * (*alloc)(struct snd_dma_buffer *, size_t);
	void (*free)(struct snd_dma_buffer *);
	dma_addr_t (*get_addr)(struct snd_dma_buffer *, size_t);
	struct page * (*get_page)(struct snd_dma_buffer *, size_t);
	unsigned int (*get_chunk_size)(struct snd_dma_buffer *, unsigned int, unsigned int);
	int (*mmap)(struct snd_dma_buffer *, struct vm_area_struct *);
	void (*sync)(struct snd_dma_buffer *, enum snd_dma_sync_mode);
};

struct snd_mask {
	__u32 bits[8];
};

struct snd_minor {
	int type;
	int card;
	int device;
	const struct file_operations *f_ops;
	void *private_data;
	struct device *dev;
	struct snd_card *card_ptr;
};

struct snd_monitor_file {
	struct file *file;
	const struct file_operations *disconnected_f_op;
	struct list_head shutdown_list;
	struct list_head list;
};

struct snd_pci_quirk {
	short unsigned int subvendor;
	short unsigned int subdevice;
	short unsigned int subdevice_mask;
	int value;
};

struct snd_pcm_str {
	int stream;
	struct snd_pcm *pcm;
	unsigned int substream_count;
	unsigned int substream_opened;
	struct snd_pcm_substream *substream;
	struct snd_info_entry *proc_root;
	struct snd_kcontrol *chmap_kctl;
	struct device *dev;
};

struct snd_pcm {
	struct snd_card *card;
	struct list_head list;
	int device;
	unsigned int info_flags;
	short unsigned int dev_class;
	short unsigned int dev_subclass;
	char id[64];
	char name[80];
	struct snd_pcm_str streams[2];
	struct mutex open_mutex;
	wait_queue_head_t open_wait;
	void *private_data;
	void (*private_free)(struct snd_pcm *);
	bool internal;
	bool nonatomic;
	bool no_device_suspend;
};

struct snd_pcm_audio_tstamp_config {
	u32 type_requested: 4;
	u32 report_delay: 1;
};

struct snd_pcm_audio_tstamp_report {
	u32 valid: 1;
	u32 actual_type: 4;
	u32 accuracy_report: 1;
	u32 accuracy;
};

struct snd_pcm_channel_info {
	unsigned int channel;
	__kernel_off_t offset;
	unsigned int first;
	unsigned int step;
};

struct snd_pcm_channel_info32 {
	u32 channel;
	u32 offset;
	u32 first;
	u32 step;
};

struct snd_pcm_chmap {
	struct snd_pcm *pcm;
	int stream;
	struct snd_kcontrol *kctl;
	const struct snd_pcm_chmap_elem *chmap;
	unsigned int max_channels;
	unsigned int channel_mask;
	void *private_data;
};

struct snd_pcm_chmap_elem {
	unsigned char channels;
	unsigned char map[15];
};

struct snd_pcm_file {
	struct snd_pcm_substream *substream;
	int no_compat_mmap;
	unsigned int user_pversion;
};

struct snd_pcm_group {
	spinlock_t lock;
	struct mutex mutex;
	struct list_head substreams;
	refcount_t refs;
};

struct snd_pcm_hardware {
	unsigned int info;
	u64 formats;
	u32 subformats;
	unsigned int rates;
	unsigned int rate_min;
	unsigned int rate_max;
	unsigned int channels_min;
	unsigned int channels_max;
	size_t buffer_bytes_max;
	size_t period_bytes_min;
	size_t period_bytes_max;
	unsigned int periods_min;
	unsigned int periods_max;
	size_t fifo_size;
};

struct snd_pcm_hw_constraint_list {
	const unsigned int *list;
	unsigned int count;
	unsigned int mask;
};

struct snd_pcm_hw_constraint_ranges {
	unsigned int count;
	const struct snd_interval *ranges;
	unsigned int mask;
};

struct snd_ratden;

struct snd_pcm_hw_constraint_ratdens {
	int nrats;
	const struct snd_ratden *rats;
};

struct snd_ratnum;

struct snd_pcm_hw_constraint_ratnums {
	int nrats;
	const struct snd_ratnum *rats;
};

struct snd_pcm_hw_rule;

struct snd_pcm_hw_constraints {
	struct snd_mask masks[3];
	struct snd_interval intervals[12];
	unsigned int rules_num;
	unsigned int rules_all;
	struct snd_pcm_hw_rule *rules;
};

struct snd_pcm_hw_params {
	unsigned int flags;
	struct snd_mask masks[3];
	struct snd_mask mres[5];
	struct snd_interval intervals[12];
	struct snd_interval ires[9];
	unsigned int rmask;
	unsigned int cmask;
	unsigned int info;
	unsigned int msbits;
	unsigned int rate_num;
	unsigned int rate_den;
	snd_pcm_uframes_t fifo_size;
	unsigned char sync[16];
	unsigned char reserved[48];
};

struct snd_pcm_hw_params32 {
	u32 flags;
	struct snd_mask masks[3];
	struct snd_mask mres[5];
	struct snd_interval intervals[12];
	struct snd_interval ires[9];
	u32 rmask;
	u32 cmask;
	u32 info;
	u32 msbits;
	u32 rate_num;
	u32 rate_den;
	u32 fifo_size;
	unsigned char reserved[64];
};

struct snd_pcm_hw_params_old {
	unsigned int flags;
	unsigned int masks[3];
	struct snd_interval intervals[12];
	unsigned int rmask;
	unsigned int cmask;
	unsigned int info;
	unsigned int msbits;
	unsigned int rate_num;
	unsigned int rate_den;
	snd_pcm_uframes_t fifo_size;
	unsigned char reserved[64];
};

typedef int (*snd_pcm_hw_rule_func_t)(struct snd_pcm_hw_params *, struct snd_pcm_hw_rule *);

struct snd_pcm_hw_rule {
	unsigned int cond;
	int var;
	int deps[5];
	snd_pcm_hw_rule_func_t func;
	void *private;
};

struct snd_pcm_info {
	unsigned int device;
	unsigned int subdevice;
	int stream;
	int card;
	unsigned char id[64];
	unsigned char name[80];
	unsigned char subname[32];
	int dev_class;
	int dev_subclass;
	unsigned int subdevices_count;
	unsigned int subdevices_avail;
	unsigned char pad1[16];
	unsigned char reserved[64];
};

struct snd_pcm_mmap_control {
	__pad_before_uframe __pad1;
	snd_pcm_uframes_t appl_ptr;
	__pad_before_uframe __pad2;
	__pad_before_uframe __pad3;
	snd_pcm_uframes_t avail_min;
	__pad_after_uframe __pad4;
};

struct snd_pcm_mmap_control32 {
	u32 appl_ptr;
	u32 avail_min;
};

struct snd_pcm_mmap_status {
	snd_pcm_state_t state;
	__u32 pad1;
	__pad_before_uframe __pad1;
	snd_pcm_uframes_t hw_ptr;
	__pad_after_uframe __pad2;
	struct __kernel_timespec tstamp;
	snd_pcm_state_t suspended_state;
	__u32 pad3;
	struct __kernel_timespec audio_tstamp;
};

struct snd_pcm_mmap_status32 {
	snd_pcm_state_t state;
	s32 pad1;
	u32 hw_ptr;
	s32 tstamp_sec;
	s32 tstamp_nsec;
	snd_pcm_state_t suspended_state;
	s32 audio_tstamp_sec;
	s32 audio_tstamp_nsec;
};

struct snd_pcm_ops {
	int (*open)(struct snd_pcm_substream *);
	int (*close)(struct snd_pcm_substream *);
	int (*ioctl)(struct snd_pcm_substream *, unsigned int, void *);
	int (*hw_params)(struct snd_pcm_substream *, struct snd_pcm_hw_params *);
	int (*hw_free)(struct snd_pcm_substream *);
	int (*prepare)(struct snd_pcm_substream *);
	int (*trigger)(struct snd_pcm_substream *, int);
	int (*sync_stop)(struct snd_pcm_substream *);
	snd_pcm_uframes_t (*pointer)(struct snd_pcm_substream *);
	int (*get_time_info)(struct snd_pcm_substream *, struct timespec64 *, struct timespec64 *, struct snd_pcm_audio_tstamp_config *, struct snd_pcm_audio_tstamp_report *);
	int (*fill_silence)(struct snd_pcm_substream *, int, long unsigned int, long unsigned int);
	int (*copy)(struct snd_pcm_substream *, int, long unsigned int, struct iov_iter *, long unsigned int);
	struct page * (*page)(struct snd_pcm_substream *, long unsigned int);
	int (*mmap)(struct snd_pcm_substream *, struct vm_area_struct *);
	int (*ack)(struct snd_pcm_substream *);
};

struct snd_pcm_runtime {
	snd_pcm_state_t state;
	snd_pcm_state_t suspended_state;
	struct snd_pcm_substream *trigger_master;
	struct timespec64 trigger_tstamp;
	bool trigger_tstamp_latched;
	int overrange;
	snd_pcm_uframes_t avail_max;
	snd_pcm_uframes_t hw_ptr_base;
	snd_pcm_uframes_t hw_ptr_interrupt;
	long unsigned int hw_ptr_jiffies;
	long unsigned int hw_ptr_buffer_jiffies;
	snd_pcm_sframes_t delay;
	u64 hw_ptr_wrap;
	snd_pcm_access_t access;
	snd_pcm_format_t format;
	snd_pcm_subformat_t subformat;
	unsigned int rate;
	unsigned int channels;
	snd_pcm_uframes_t period_size;
	unsigned int periods;
	snd_pcm_uframes_t buffer_size;
	snd_pcm_uframes_t min_align;
	size_t byte_align;
	unsigned int frame_bits;
	unsigned int sample_bits;
	unsigned int info;
	unsigned int rate_num;
	unsigned int rate_den;
	unsigned int no_period_wakeup: 1;
	int tstamp_mode;
	unsigned int period_step;
	snd_pcm_uframes_t start_threshold;
	snd_pcm_uframes_t stop_threshold;
	snd_pcm_uframes_t silence_threshold;
	snd_pcm_uframes_t silence_size;
	snd_pcm_uframes_t boundary;
	snd_pcm_uframes_t silence_start;
	snd_pcm_uframes_t silence_filled;
	bool std_sync_id;
	struct snd_pcm_mmap_status *status;
	struct snd_pcm_mmap_control *control;
	snd_pcm_uframes_t twake;
	wait_queue_head_t sleep;
	wait_queue_head_t tsleep;
	struct snd_fasync *fasync;
	bool stop_operating;
	struct mutex buffer_mutex;
	atomic_t buffer_accessing;
	void *private_data;
	void (*private_free)(struct snd_pcm_runtime *);
	struct snd_pcm_hardware hw;
	struct snd_pcm_hw_constraints hw_constraints;
	unsigned int timer_resolution;
	int tstamp_type;
	unsigned char *dma_area;
	dma_addr_t dma_addr;
	size_t dma_bytes;
	struct snd_dma_buffer *dma_buffer_p;
	unsigned int buffer_changed: 1;
	struct snd_pcm_audio_tstamp_config audio_tstamp_config;
	struct snd_pcm_audio_tstamp_report audio_tstamp_report;
	struct timespec64 driver_tstamp;
};

struct snd_pcm_status32 {
	snd_pcm_state_t state;
	s32 trigger_tstamp_sec;
	s32 trigger_tstamp_nsec;
	s32 tstamp_sec;
	s32 tstamp_nsec;
	u32 appl_ptr;
	u32 hw_ptr;
	s32 delay;
	u32 avail;
	u32 avail_max;
	u32 overrange;
	snd_pcm_state_t suspended_state;
	u32 audio_tstamp_data;
	s32 audio_tstamp_sec;
	s32 audio_tstamp_nsec;
	s32 driver_tstamp_sec;
	s32 driver_tstamp_nsec;
	u32 audio_tstamp_accuracy;
	unsigned char reserved[36];
};

struct snd_pcm_status64 {
	snd_pcm_state_t state;
	u8 rsvd[4];
	s64 trigger_tstamp_sec;
	s64 trigger_tstamp_nsec;
	s64 tstamp_sec;
	s64 tstamp_nsec;
	snd_pcm_uframes_t appl_ptr;
	snd_pcm_uframes_t hw_ptr;
	snd_pcm_sframes_t delay;
	snd_pcm_uframes_t avail;
	snd_pcm_uframes_t avail_max;
	snd_pcm_uframes_t overrange;
	snd_pcm_state_t suspended_state;
	__u32 audio_tstamp_data;
	s64 audio_tstamp_sec;
	s64 audio_tstamp_nsec;
	s64 driver_tstamp_sec;
	s64 driver_tstamp_nsec;
	__u32 audio_tstamp_accuracy;
	unsigned char reserved[20];
};

struct snd_pcm_substream {
	struct snd_pcm *pcm;
	struct snd_pcm_str *pstr;
	void *private_data;
	int number;
	char name[32];
	int stream;
	struct pm_qos_request latency_pm_qos_req;
	size_t buffer_bytes_max;
	struct snd_dma_buffer dma_buffer;
	size_t dma_max;
	const struct snd_pcm_ops *ops;
	struct snd_pcm_runtime *runtime;
	struct snd_timer *timer;
	unsigned int timer_running: 1;
	long int wait_time;
	struct snd_pcm_substream *next;
	struct list_head link_list;
	struct snd_pcm_group self_group;
	struct snd_pcm_group *group;
	int ref_count;
	atomic_t mmap_count;
	unsigned int f_flags;
	void (*pcm_release)(struct snd_pcm_substream *);
	struct pid *pid;
	struct snd_info_entry *proc_root;
	unsigned int hw_opened: 1;
	unsigned int managed_buffer_alloc: 1;
};

struct snd_pcm_sw_params {
	int tstamp_mode;
	unsigned int period_step;
	unsigned int sleep_min;
	snd_pcm_uframes_t avail_min;
	snd_pcm_uframes_t xfer_align;
	snd_pcm_uframes_t start_threshold;
	snd_pcm_uframes_t stop_threshold;
	snd_pcm_uframes_t silence_threshold;
	snd_pcm_uframes_t silence_size;
	snd_pcm_uframes_t boundary;
	unsigned int proto;
	unsigned int tstamp_type;
	unsigned char reserved[56];
};

struct snd_pcm_sw_params32 {
	s32 tstamp_mode;
	u32 period_step;
	u32 sleep_min;
	u32 avail_min;
	u32 xfer_align;
	u32 start_threshold;
	u32 stop_threshold;
	u32 silence_threshold;
	u32 silence_size;
	u32 boundary;
	u32 proto;
	u32 tstamp_type;
	unsigned char reserved[56];
};

struct snd_pcm_sync_ptr {
	__u32 flags;
	__u32 pad1;
	union {
		struct snd_pcm_mmap_status status;
		unsigned char reserved[64];
	} s;
	union {
		struct snd_pcm_mmap_control control;
		unsigned char reserved[64];
	} c;
};

struct snd_pcm_sync_ptr32 {
	u32 flags;
	union {
		struct snd_pcm_mmap_status32 status;
		unsigned char reserved[64];
	} s;
	union {
		struct snd_pcm_mmap_control32 control;
		unsigned char reserved[64];
	} c;
};

struct snd_ratden {
	unsigned int num_min;
	unsigned int num_max;
	unsigned int num_step;
	unsigned int den;
};

struct snd_ratnum {
	unsigned int num;
	unsigned int den_min;
	unsigned int den_max;
	unsigned int den_step;
};

struct snd_seq_fifo;

struct snd_seq_user_client {
	struct file *file;
	struct pid *owner;
	struct snd_seq_fifo *fifo;
	int fifo_pool_size;
};

struct snd_seq_kernel_client {
	struct snd_card *card;
};

struct snd_seq_pool;

struct snd_seq_client {
	snd_seq_client_type_t type;
	unsigned int accept_input: 1;
	unsigned int accept_output: 1;
	unsigned int midi_version;
	unsigned int user_pversion;
	char name[64];
	int number;
	unsigned int filter;
	long unsigned int event_filter[4];
	short unsigned int group_filter;
	snd_use_lock_t use_lock;
	int event_lost;
	int num_ports;
	struct list_head ports_list_head;
	rwlock_t ports_lock;
	struct mutex ports_mutex;
	struct mutex ioctl_mutex;
	int convert32;
	int ump_endpoint_port;
	struct snd_seq_pool *pool;
	union {
		struct snd_seq_user_client user;
		struct snd_seq_kernel_client kernel;
	} data;
	void **ump_info;
};

struct snd_seq_client_info {
	int client;
	snd_seq_client_type_t type;
	char name[64];
	unsigned int filter;
	unsigned char multicast_filter[8];
	unsigned char event_filter[32];
	int num_ports;
	int event_lost;
	int card;
	int pid;
	unsigned int midi_version;
	unsigned int group_filter;
	char reserved[48];
};

struct snd_seq_client_pool {
	int client;
	int output_pool;
	int input_pool;
	int output_room;
	int output_free;
	int input_free;
	char reserved[64];
};

struct snd_seq_port_subscribe;

struct snd_seq_port_subs_info {
	struct list_head list_head;
	unsigned int count;
	unsigned int exclusive: 1;
	struct rw_semaphore list_mutex;
	rwlock_t list_lock;
	int (*open)(void *, struct snd_seq_port_subscribe *);
	int (*close)(void *, struct snd_seq_port_subscribe *);
};

struct snd_seq_client_port {
	struct snd_seq_addr addr;
	struct module *owner;
	char name[64];
	struct list_head list;
	snd_use_lock_t use_lock;
	struct snd_seq_port_subs_info c_src;
	struct snd_seq_port_subs_info c_dest;
	int (*event_input)(struct snd_seq_event *, int, void *, int, int);
	void (*private_free)(void *);
	void *private_data;
	unsigned int closing: 1;
	unsigned int timestamping: 1;
	unsigned int time_real: 1;
	int time_queue;
	unsigned int capability;
	unsigned int type;
	int midi_channels;
	int midi_voices;
	int synth_voices;
	unsigned char direction;
	unsigned char ump_group;
	bool is_midi1;
};

struct snd_seq_device {
	struct snd_card *card;
	int device;
	const char *id;
	char name[80];
	int argsize;
	void *driver_data;
	void *private_data;
	void (*private_free)(struct snd_seq_device *);
	struct device dev;
};

struct snd_seq_driver {
	struct device_driver driver;
	char *id;
	int argsize;
};

struct snd_seq_dummy_port {
	int client;
	int port;
	int duplex;
	int connect;
};

struct snd_seq_event_cell {
	union {
		struct snd_seq_event event;
		union __snd_seq_event ump;
	};
	struct snd_seq_pool *pool;
	struct snd_seq_event_cell *next;
};

struct snd_seq_fifo {
	struct snd_seq_pool *pool;
	struct snd_seq_event_cell *head;
	struct snd_seq_event_cell *tail;
	int cells;
	spinlock_t lock;
	snd_use_lock_t use_lock;
	wait_queue_head_t input_sleep;
	atomic_t overflow;
};

struct snd_seq_pool {
	struct snd_seq_event_cell *ptr;
	struct snd_seq_event_cell *free;
	int total_elements;
	atomic_t counter;
	int size;
	int room;
	int closing;
	int max_used;
	int event_alloc_nopool;
	int event_alloc_failures;
	int event_alloc_success;
	wait_queue_head_t output_sleep;
	spinlock_t lock;
};

struct snd_seq_port_callback {
	struct module *owner;
	void *private_data;
	int (*subscribe)(void *, struct snd_seq_port_subscribe *);
	int (*unsubscribe)(void *, struct snd_seq_port_subscribe *);
	int (*use)(void *, struct snd_seq_port_subscribe *);
	int (*unuse)(void *, struct snd_seq_port_subscribe *);
	int (*event_input)(struct snd_seq_event *, int, void *, int, int);
	void (*private_free)(void *);
};

struct snd_seq_port_info {
	struct snd_seq_addr addr;
	char name[64];
	unsigned int capability;
	unsigned int type;
	int midi_channels;
	int midi_voices;
	int synth_voices;
	int read_use;
	int write_use;
	void *kernel;
	unsigned int flags;
	unsigned char time_queue;
	unsigned char direction;
	unsigned char ump_group;
	char reserved[57];
};

struct snd_seq_port_info32 {
	struct snd_seq_addr addr;
	char name[64];
	u32 capability;
	u32 type;
	s32 midi_channels;
	s32 midi_voices;
	s32 synth_voices;
	s32 read_use;
	s32 write_use;
	u32 kernel;
	u32 flags;
	unsigned char time_queue;
	char reserved[59];
};

struct snd_seq_port_subscribe {
	struct snd_seq_addr sender;
	struct snd_seq_addr dest;
	unsigned int voices;
	unsigned int flags;
	unsigned char queue;
	unsigned char pad[3];
	char reserved[64];
};

struct snd_seq_prioq {
	struct snd_seq_event_cell *head;
	struct snd_seq_event_cell *tail;
	int cells;
	spinlock_t lock;
};

struct snd_seq_query_subs {
	struct snd_seq_addr root;
	int type;
	int index;
	int num_subs;
	struct snd_seq_addr addr;
	unsigned char queue;
	unsigned int flags;
	char reserved[64];
};

struct snd_seq_timer;

struct snd_seq_queue {
	int queue;
	char name[64];
	struct snd_seq_prioq *tickq;
	struct snd_seq_prioq *timeq;
	struct snd_seq_timer *timer;
	int owner;
	bool locked;
	bool klocked;
	bool check_again;
	bool check_blocked;
	unsigned int flags;
	unsigned int info_flags;
	spinlock_t owner_lock;
	spinlock_t check_lock;
	long unsigned int clients_bitmap[3];
	unsigned int clients;
	struct mutex timer_mutex;
	snd_use_lock_t use_lock;
};

struct snd_seq_queue_client {
	int queue;
	int client;
	int used;
	char reserved[64];
};

struct snd_seq_queue_info {
	int queue;
	int owner;
	unsigned int locked: 1;
	char name[64];
	unsigned int flags;
	char reserved[60];
};

struct snd_seq_queue_status {
	int queue;
	int events;
	snd_seq_tick_time_t tick;
	struct snd_seq_real_time time;
	int running;
	int flags;
	char reserved[64];
};

struct snd_seq_queue_tempo {
	int queue;
	unsigned int tempo;
	int ppq;
	unsigned int skew_value;
	unsigned int skew_base;
	short unsigned int tempo_base;
	char reserved[22];
};

struct snd_timer_id {
	int dev_class;
	int dev_sclass;
	int card;
	int device;
	int subdevice;
};

struct snd_seq_queue_timer {
	int queue;
	int type;
	union {
		struct {
			struct snd_timer_id id;
			unsigned int resolution;
		} alsa;
	} u;
	char reserved[64];
};

typedef struct snd_seq_real_time snd_seq_real_time_t;

struct snd_seq_remove_events {
	unsigned int remove_mode;
	union snd_seq_timestamp time;
	unsigned char queue;
	struct snd_seq_addr dest;
	unsigned char channel;
	int type;
	char tag;
	int reserved[10];
};

struct snd_seq_running_info {
	unsigned char client;
	unsigned char big_endian;
	unsigned char cpu_mode;
	unsigned char pad;
	unsigned char reserved[12];
};

struct snd_seq_subscribers {
	struct snd_seq_port_subscribe info;
	struct list_head src_list;
	struct list_head dest_list;
	atomic_t ref_count;
};

struct snd_seq_system_info {
	int queues;
	int clients;
	int ports;
	int channels;
	int cur_clients;
	int cur_queues;
	char reserved[24];
};

struct snd_seq_timer_tick {
	snd_seq_tick_time_t cur_tick;
	long unsigned int resolution;
	long unsigned int fraction;
};

struct snd_timer_instance;

struct snd_seq_timer {
	unsigned int running: 1;
	unsigned int initialized: 1;
	unsigned int tempo;
	int ppq;
	snd_seq_real_time_t cur_time;
	struct snd_seq_timer_tick tick;
	int tick_updated;
	int type;
	struct snd_timer_id alsa_id;
	struct snd_timer_instance *timeri;
	unsigned int ticks;
	long unsigned int preferred_resolution;
	unsigned int skew;
	unsigned int skew_base;
	unsigned int tempo_base;
	struct timespec64 last_update;
	spinlock_t lock;
};

struct snd_seq_ump_event {
	snd_seq_event_type_t type;
	unsigned char flags;
	char tag;
	unsigned char queue;
	union snd_seq_timestamp time;
	struct snd_seq_addr source;
	struct snd_seq_addr dest;
	union {
		union snd_seq_event_data data;
		unsigned int ump[4];
	};
};

struct snd_seq_usage {
	int cur;
	int peak;
};

struct snd_soc_acpi_codecs {
	int num_codecs;
	u8 codecs[48];
};

struct snd_timer_hardware {
	unsigned int flags;
	long unsigned int resolution;
	long unsigned int resolution_min;
	long unsigned int resolution_max;
	long unsigned int ticks;
	int (*open)(struct snd_timer *);
	int (*close)(struct snd_timer *);
	long unsigned int (*c_resolution)(struct snd_timer *);
	int (*start)(struct snd_timer *);
	int (*stop)(struct snd_timer *);
	int (*set_period)(struct snd_timer *, long unsigned int, long unsigned int);
	int (*precise_resolution)(struct snd_timer *, long unsigned int *, long unsigned int *);
};

struct snd_timer {
	int tmr_class;
	struct snd_card *card;
	struct module *module;
	int tmr_device;
	int tmr_subdevice;
	char id[64];
	char name[80];
	unsigned int flags;
	int running;
	long unsigned int sticks;
	void *private_data;
	void (*private_free)(struct snd_timer *);
	struct snd_timer_hardware hw;
	spinlock_t lock;
	struct list_head device_list;
	struct list_head open_list_head;
	struct list_head active_list_head;
	struct list_head ack_list_head;
	struct list_head sack_list_head;
	struct work_struct task_work;
	int max_instances;
	int num_instances;
};

struct snd_timer_ginfo {
	struct snd_timer_id tid;
	unsigned int flags;
	int card;
	unsigned char id[64];
	unsigned char name[80];
	long unsigned int reserved0;
	long unsigned int resolution;
	long unsigned int resolution_min;
	long unsigned int resolution_max;
	unsigned int clients;
	unsigned char reserved[32];
};

struct snd_timer_gparams {
	struct snd_timer_id tid;
	long unsigned int period_num;
	long unsigned int period_den;
	unsigned char reserved[32];
};

struct snd_timer_gparams32 {
	struct snd_timer_id tid;
	u32 period_num;
	u32 period_den;
	unsigned char reserved[32];
};

struct snd_timer_gstatus {
	struct snd_timer_id tid;
	long unsigned int resolution;
	long unsigned int resolution_num;
	long unsigned int resolution_den;
	unsigned char reserved[32];
};

struct snd_timer_info {
	unsigned int flags;
	int card;
	unsigned char id[64];
	unsigned char name[80];
	long unsigned int reserved0;
	long unsigned int resolution;
	unsigned char reserved[64];
};

struct snd_timer_info32 {
	u32 flags;
	s32 card;
	unsigned char id[64];
	unsigned char name[80];
	u32 reserved0;
	u32 resolution;
	unsigned char reserved[64];
};

struct snd_timer_instance {
	struct snd_timer *timer;
	char *owner;
	unsigned int flags;
	void *private_data;
	void (*private_free)(struct snd_timer_instance *);
	void (*callback)(struct snd_timer_instance *, long unsigned int, long unsigned int);
	void (*ccallback)(struct snd_timer_instance *, int, struct timespec64 *, long unsigned int);
	void (*disconnect)(struct snd_timer_instance *);
	void *callback_data;
	long unsigned int ticks;
	long unsigned int cticks;
	long unsigned int pticks;
	long unsigned int resolution;
	long unsigned int lost;
	int slave_class;
	unsigned int slave_id;
	struct list_head open_list;
	struct list_head active_list;
	struct list_head ack_list;
	struct list_head slave_list_head;
	struct list_head slave_active_head;
	struct snd_timer_instance *master;
};

struct snd_timer_params {
	unsigned int flags;
	unsigned int ticks;
	unsigned int queue_size;
	unsigned int reserved0;
	unsigned int filter;
	unsigned char reserved[60];
};

struct snd_timer_read {
	unsigned int resolution;
	unsigned int ticks;
};

struct snd_timer_select {
	struct snd_timer_id id;
	unsigned char reserved[32];
};

struct snd_timer_status32 {
	s32 tstamp_sec;
	s32 tstamp_nsec;
	unsigned int resolution;
	unsigned int lost;
	unsigned int overrun;
	unsigned int queue;
	unsigned char reserved[64];
};

struct snd_timer_status64 {
	s64 tstamp_sec;
	s64 tstamp_nsec;
	unsigned int resolution;
	unsigned int lost;
	unsigned int overrun;
	unsigned int queue;
	unsigned char reserved[64];
};

struct snd_timer_system_private {
	struct timer_list tlist;
	struct snd_timer *snd_timer;
	long unsigned int last_expires;
	long unsigned int last_jiffies;
	long unsigned int correction;
};

struct snd_timer_tread32 {
	int event;
	s32 tstamp_sec;
	s32 tstamp_nsec;
	unsigned int val;
};

struct snd_timer_tread64 {
	int event;
	u8 pad1[4];
	s64 tstamp_sec;
	s64 tstamp_nsec;
	unsigned int val;
	u8 pad2[4];
};

struct snd_timer_uinfo {
	__u64 resolution;
	int fd;
	unsigned int id;
	unsigned char reserved[16];
};

struct snd_timer_user {
	struct snd_timer_instance *timeri;
	int tread;
	long unsigned int ticks;
	long unsigned int overrun;
	int qhead;
	int qtail;
	int qused;
	int queue_size;
	bool disconnected;
	struct snd_timer_read *queue;
	struct snd_timer_tread64 *tqueue;
	spinlock_t qlock;
	long unsigned int last_resolution;
	unsigned int filter;
	struct timespec64 tstamp;
	wait_queue_head_t qchange_sleep;
	struct snd_fasync *fasync;
	struct mutex ioctl_lock;
};

struct snd_xferi {
	snd_pcm_sframes_t result;
	void *buf;
	snd_pcm_uframes_t frames;
};

struct snd_xferi32 {
	s32 result;
	u32 buf;
	u32 frames;
};

struct snd_xfern {
	snd_pcm_sframes_t result;
	void **bufs;
	snd_pcm_uframes_t frames;
};

struct snd_xfern32 {
	s32 result;
	u32 bufs;
	u32 frames;
};

struct snmp_mib {
	const char *name;
	int entry;
};

struct so_timestamping {
	int flags;
	int bind_phc;
};

struct sock_bh_locked {
	struct sock *sock;
	local_lock_t bh_lock;
};

struct sock_diag_handler {
	struct module *owner;
	__u8 family;
	int (*dump)(struct sk_buff *, struct nlmsghdr *);
	int (*get_info)(struct sk_buff *, struct sock *);
	int (*destroy)(struct sk_buff *, struct nlmsghdr *);
};

struct sock_diag_inet_compat {
	struct module *owner;
	int (*fn)(struct sk_buff *, struct nlmsghdr *);
};

struct sock_diag_req {
	__u8 sdiag_family;
	__u8 sdiag_protocol;
};

struct sock_ee_data_rfc4884 {
	__u16 len;
	__u8 flags;
	__u8 reserved;
};

struct sock_extended_err {
	__u32 ee_errno;
	__u8 ee_origin;
	__u8 ee_type;
	__u8 ee_code;
	__u8 ee_pad;
	__u32 ee_info;
	union {
		__u32 ee_data;
		struct sock_ee_data_rfc4884 ee_rfc4884;
	};
};

struct sock_exterr_skb {
	union {
		struct inet_skb_parm h4;
		struct inet6_skb_parm h6;
	} header;
	struct sock_extended_err ee;
	u16 addr_offset;
	__be16 port;
	u8 opt_stats: 1;
	u8 unused: 7;
};

struct sock_fprog {
	short unsigned int len;
	struct sock_filter *filter;
};

struct sock_fprog_kern {
	u16 len;
	struct sock_filter *filter;
};

struct sock_hash_seq_info {
	struct bpf_map *map;
	struct bpf_shtab *htab;
	u32 bucket_id;
};

struct sock_map_seq_info {
	struct bpf_map *map;
	struct sock *sk;
	u32 index;
};

struct sock_reuseport {
	struct callback_head rcu;
	u16 max_socks;
	u16 num_socks;
	u16 num_closed_socks;
	u16 incoming_cpu;
	unsigned int synq_overflow_ts;
	unsigned int reuseport_id;
	unsigned int bind_inany: 1;
	unsigned int has_conns: 1;
	struct bpf_prog *prog;
	struct sock *socks[0];
};

struct sock_skb_cb {
	u32 dropcount;
};

struct sock_txtime {
	__kernel_clockid_t clockid;
	__u32 flags;
};

struct sock_xprt {
	struct rpc_xprt xprt;
	struct socket *sock;
	struct sock *inet;
	struct file *file;
	struct {
		struct {
			__be32 fraghdr;
			__be32 xid;
			__be32 calldir;
		};
		u32 offset;
		u32 len;
		long unsigned int copied;
	} recv;
	struct {
		u32 offset;
	} xmit;
	long unsigned int sock_state;
	struct delayed_work connect_worker;
	struct work_struct error_worker;
	struct work_struct recv_worker;
	struct mutex recv_mutex;
	struct completion handshake_done;
	struct __kernel_sockaddr_storage srcaddr;
	short unsigned int srcport;
	int xprt_err;
	struct rpc_clnt *clnt;
	size_t rcvsize;
	size_t sndsize;
	struct rpc_timeout tcp_timeout;
	void (*old_data_ready)(struct sock *);
	void (*old_state_change)(struct sock *);
	void (*old_write_space)(struct sock *);
	void (*old_error_report)(struct sock *);
};

struct sockaddr_nl {
	__kernel_sa_family_t nl_family;
	short unsigned int nl_pad;
	__u32 nl_pid;
	__u32 nl_groups;
};

struct sockaddr_un {
	__kernel_sa_family_t sun_family;
	char sun_path[108];
};

struct socket_wq {
	wait_queue_head_t wait;
	struct fasync_struct *fasync_list;
	long unsigned int flags;
	struct callback_head rcu;
	long: 64;
};

struct socket {
	socket_state state;
	short int type;
	long unsigned int flags;
	struct file *file;
	struct sock *sk;
	const struct proto_ops *ops;
	long: 64;
	long: 64;
	long: 64;
	struct socket_wq wq;
};

struct socket__safe_trusted_or_null {
	struct sock *sk;
};

struct socket_alloc {
	struct socket socket;
	struct inode vfs_inode;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct socket_data {
	struct resource_map mem_db;
	struct resource_map mem_db_valid;
	struct resource_map io_db;
};

struct sockmap_link {
	struct bpf_link link;
	struct bpf_map *map;
	enum bpf_attach_type attach_type;
};

struct softirq_action {
	void (*action)(void);
};

struct softnet_data {
	struct list_head poll_list;
	struct sk_buff_head process_queue;
	local_lock_t process_queue_bh_lock;
	unsigned int processed;
	unsigned int time_squeeze;
	struct softnet_data *rps_ipi_list;
	unsigned int received_rps;
	bool in_net_rx_action;
	bool in_napi_threaded_poll;
	struct sd_flow_limit *flow_limit;
	struct Qdisc *output_queue;
	struct Qdisc **output_queue_tailp;
	struct sk_buff *completion_queue;
	struct netdev_xmit xmit;
	long: 64;
	long: 64;
	long: 64;
	unsigned int input_queue_head;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	call_single_data_t csd;
	struct softnet_data *rps_ipi_next;
	unsigned int cpu;
	unsigned int input_queue_tail;
	struct sk_buff_head input_pkt_queue;
	struct napi_struct backlog;
	long: 64;
	atomic_t dropped;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	spinlock_t defer_lock;
	int defer_count;
	int defer_ipi_scheduled;
	struct sk_buff *defer_list;
	long: 64;
	call_single_data_t defer_csd;
};

struct software_node {
	const char *name;
	const struct software_node *parent;
	const struct property_entry *properties;
};

struct sony_sc {
	spinlock_t lock;
	struct list_head list_node;
	struct hid_device *hdev;
	struct input_dev *touchpad;
	struct input_dev *sensor_dev;
	struct led_classdev *leds[4];
	long unsigned int quirks;
	struct work_struct state_worker;
	void (*send_output_report)(struct sony_sc *);
	struct power_supply *battery;
	struct power_supply_desc battery_desc;
	int device_id;
	u8 *output_report_dmabuf;
	u8 mac_address[6];
	u8 state_worker_initialized;
	u8 defer_initialization;
	u8 battery_capacity;
	int battery_status;
	u8 led_state[4];
	u8 led_delay_on[4];
	u8 led_delay_off[4];
	u8 led_count;
	struct urb *ghl_urb;
	struct timer_list ghl_poke_timer;
};

struct sp_node {
	struct rb_node nd;
	long unsigned int start;
	long unsigned int end;
	struct mempolicy *policy;
};

struct space_resv {
	__s16 l_type;
	__s16 l_whence;
	__s64 l_start;
	__s64 l_len;
	__s32 l_sysid;
	__u32 l_pid;
	__s32 l_pad[4];
};

struct space_resv_32 {
	__s16 l_type;
	__s16 l_whence;
	__s64 l_start;
	__s64 l_len;
	__s32 l_sysid;
	__u32 l_pid;
	__s32 l_pad[4];
} __attribute__((packed));

struct speed_down_verdict_arg {
	u64 since;
	int xfer_ok;
	int nr_errors[8];
};

struct spi_function_template {
	void (*get_period)(struct scsi_target *);
	void (*set_period)(struct scsi_target *, int);
	void (*get_offset)(struct scsi_target *);
	void (*set_offset)(struct scsi_target *, int);
	void (*get_width)(struct scsi_target *);
	void (*set_width)(struct scsi_target *, int);
	void (*get_iu)(struct scsi_target *);
	void (*set_iu)(struct scsi_target *, int);
	void (*get_dt)(struct scsi_target *);
	void (*set_dt)(struct scsi_target *, int);
	void (*get_qas)(struct scsi_target *);
	void (*set_qas)(struct scsi_target *, int);
	void (*get_wr_flow)(struct scsi_target *);
	void (*set_wr_flow)(struct scsi_target *, int);
	void (*get_rd_strm)(struct scsi_target *);
	void (*set_rd_strm)(struct scsi_target *, int);
	void (*get_rti)(struct scsi_target *);
	void (*set_rti)(struct scsi_target *, int);
	void (*get_pcomp_en)(struct scsi_target *);
	void (*set_pcomp_en)(struct scsi_target *, int);
	void (*get_hold_mcs)(struct scsi_target *);
	void (*set_hold_mcs)(struct scsi_target *, int);
	void (*get_signalling)(struct Scsi_Host *);
	void (*set_signalling)(struct Scsi_Host *, enum spi_signal_type);
	int (*deny_binding)(struct scsi_target *);
	long unsigned int show_period: 1;
	long unsigned int show_offset: 1;
	long unsigned int show_width: 1;
	long unsigned int show_iu: 1;
	long unsigned int show_dt: 1;
	long unsigned int show_qas: 1;
	long unsigned int show_wr_flow: 1;
	long unsigned int show_rd_strm: 1;
	long unsigned int show_rti: 1;
	long unsigned int show_pcomp_en: 1;
	long unsigned int show_hold_mcs: 1;
};

struct spi_host_attrs {
	enum spi_signal_type signalling;
};

struct spi_internal {
	struct scsi_transport_template t;
	struct spi_function_template *f;
};

struct spi_transport_attrs {
	int period;
	int min_period;
	int offset;
	int max_offset;
	unsigned int width: 1;
	unsigned int max_width: 1;
	unsigned int iu: 1;
	unsigned int max_iu: 1;
	unsigned int dt: 1;
	unsigned int qas: 1;
	unsigned int max_qas: 1;
	unsigned int wr_flow: 1;
	unsigned int rd_strm: 1;
	unsigned int rti: 1;
	unsigned int pcomp_en: 1;
	unsigned int hold_mcs: 1;
	unsigned int initial_dv: 1;
	long unsigned int flags;
	unsigned int support_sync: 1;
	unsigned int support_wide: 1;
	unsigned int support_dt: 1;
	unsigned int support_dt_only;
	unsigned int support_ius;
	unsigned int support_qas;
	unsigned int dv_pending: 1;
	unsigned int dv_in_progress: 1;
	struct mutex dv_mutex;
};

struct splice_desc {
	size_t total_len;
	unsigned int len;
	unsigned int flags;
	union {
		void *userptr;
		struct file *file;
		void *data;
	} u;
	void (*splice_eof)(struct splice_desc *);
	loff_t pos;
	loff_t *opos;
	size_t num_spliced;
	bool need_wakeup;
};

struct splice_pipe_desc {
	struct page **pages;
	struct partial_page *partial;
	int nr_pages;
	unsigned int nr_pages_max;
	const struct pipe_buf_operations *ops;
	void (*spd_release)(struct splice_pipe_desc *, unsigned int);
};

struct sr6_tlv {
	__u8 type;
	__u8 len;
	__u8 data[0];
};

struct srcu_node;

struct srcu_data {
	atomic_long_t srcu_lock_count[2];
	atomic_long_t srcu_unlock_count[2];
	int srcu_reader_flavor;
	long: 64;
	long: 64;
	long: 64;
	spinlock_t lock;
	struct rcu_segcblist srcu_cblist;
	long unsigned int srcu_gp_seq_needed;
	long unsigned int srcu_gp_seq_needed_exp;
	bool srcu_cblist_invoking;
	struct timer_list delay_work;
	struct work_struct work;
	struct callback_head srcu_barrier_head;
	struct srcu_node *mynode;
	long unsigned int grpmask;
	int cpu;
	struct srcu_struct *ssp;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct srcu_node {
	spinlock_t lock;
	long unsigned int srcu_have_cbs[4];
	long unsigned int srcu_data_have_cbs[4];
	long unsigned int srcu_gp_seq_needed_exp;
	struct srcu_node *srcu_parent;
	int grplo;
	int grphi;
};

struct srcu_usage {
	struct srcu_node *node;
	struct srcu_node *level[3];
	int srcu_size_state;
	struct mutex srcu_cb_mutex;
	spinlock_t lock;
	struct mutex srcu_gp_mutex;
	long unsigned int srcu_gp_seq;
	long unsigned int srcu_gp_seq_needed;
	long unsigned int srcu_gp_seq_needed_exp;
	long unsigned int srcu_gp_start;
	long unsigned int srcu_last_gp_end;
	long unsigned int srcu_size_jiffies;
	long unsigned int srcu_n_lock_retries;
	long unsigned int srcu_n_exp_nodelay;
	bool sda_is_static;
	long unsigned int srcu_barrier_seq;
	struct mutex srcu_barrier_mutex;
	struct completion srcu_barrier_completion;
	atomic_t srcu_barrier_cpu_cnt;
	long unsigned int reschedule_jiffies;
	long unsigned int reschedule_count;
	struct delayed_work work;
	struct srcu_struct *srcu_ssp;
};

struct srcu_notifier_head {
	struct mutex mutex;
	struct srcu_usage srcuu;
	struct srcu_struct srcu;
	struct notifier_block *head;
};

struct ssb_state {
	struct ssb_state *shared_state;
	raw_spinlock_t lock;
	unsigned int disable_state;
	long unsigned int local_state;
};

struct tid_ampdu_rx;

struct tid_ampdu_tx;

struct sta_ampdu_mlme {
	struct tid_ampdu_rx *tid_rx[16];
	u8 tid_rx_token[16];
	long unsigned int tid_rx_timer_expired[1];
	long unsigned int tid_rx_stop_requested[1];
	long unsigned int tid_rx_manage_offl[1];
	long unsigned int agg_session_valid[1];
	long unsigned int unexpected_agg[1];
	struct wiphy_work work;
	struct tid_ampdu_tx *tid_tx[16];
	struct tid_ampdu_tx *tid_start_tx[16];
	long unsigned int last_addba_req_time[16];
	u8 addba_req_num[16];
	u8 dialog_token_allocator;
};

struct sta_bss_param_ch_cnt_data {
	struct ieee80211_sub_if_data *sdata;
	u8 reporting_link_id;
	u8 mld_id;
};

struct sta_bss_parameters {
	u8 flags;
	u8 dtim_period;
	u16 beacon_interval;
};

struct sta_csa_rnr_iter_data {
	struct ieee80211_link_data *link;
	struct ieee80211_channel *chan;
	u8 mld_id;
};

struct sta_info {
	struct list_head list;
	struct list_head free_list;
	struct callback_head callback_head;
	struct rhlist_head hash_node;
	u8 addr[6];
	struct ieee80211_local *local;
	struct ieee80211_sub_if_data *sdata;
	struct ieee80211_key *ptk[4];
	u8 ptk_idx;
	struct rate_control_ref *rate_ctrl;
	void *rate_ctrl_priv;
	spinlock_t rate_ctrl_lock;
	spinlock_t lock;
	struct ieee80211_fast_tx *fast_tx;
	struct ieee80211_fast_rx *fast_rx;
	struct work_struct drv_deliver_wk;
	u16 listen_interval;
	bool dead;
	bool removed;
	bool uploaded;
	enum ieee80211_sta_state sta_state;
	long unsigned int _flags;
	spinlock_t ps_lock;
	struct sk_buff_head ps_tx_buf[4];
	struct sk_buff_head tx_filtered[4];
	long unsigned int driver_buffered_tids;
	long unsigned int txq_buffered_tids;
	u64 assoc_at;
	long int last_connected;
	__le16 last_seq_ctrl[17];
	u16 tid_seq[16];
	struct airtime_info airtime[4];
	u16 airtime_weight;
	struct sta_ampdu_mlme ampdu_mlme;
	struct codel_params cparams;
	u8 reserved_tid;
	s8 amsdu_mesh_control;
	struct cfg80211_chan_def tdls_chandef;
	struct ieee80211_fragment_cache frags;
	struct ieee80211_sta_aggregates cur;
	struct link_sta_info deflink;
	struct link_sta_info *link[15];
	struct ieee80211_sta sta;
};

struct sta_link_alloc {
	struct link_sta_info info;
	struct ieee80211_link_sta sta;
	struct callback_head callback_head;
};

struct sta_opmode_info {
	u32 changed;
	enum nl80211_smps_mode smps_mode;
	enum nl80211_chan_width bw;
	u8 rx_nss;
};

struct stack_entry {
	struct trace_entry ent;
	int size;
	long unsigned int caller[0];
};

struct stack_frame {
	struct stack_frame *next_frame;
	long unsigned int return_address;
};

struct stack_frame_ia32 {
	u32 next_frame;
	u32 return_address;
};

struct stack_frame_user {
	const void *next_fp;
	long unsigned int ret_addr;
};

struct stack_info {
	enum stack_type type;
	long unsigned int *begin;
	long unsigned int *end;
	long unsigned int *next_sp;
};

struct stack_map_bucket {
	struct pcpu_freelist_node fnode;
	u32 hash;
	u32 nr;
	u64 data[0];
};

struct stack_record {
	struct list_head hash_list;
	u32 hash;
	u32 size;
	union handle_parts handle;
	refcount_t count;
	union {
		long unsigned int entries[64];
		struct {
			struct list_head free_list;
			long unsigned int rcu_state;
		};
	};
};

struct stacktrace_cookie {
	long unsigned int *store;
	unsigned int size;
	unsigned int skip;
	unsigned int len;
};

struct stashed_operations {
	void (*put_data)(void *);
	int (*init_inode)(struct inode *, void *);
};

struct stat {
	__kernel_ulong_t st_dev;
	__kernel_ulong_t st_ino;
	__kernel_ulong_t st_nlink;
	unsigned int st_mode;
	unsigned int st_uid;
	unsigned int st_gid;
	unsigned int __pad0;
	__kernel_ulong_t st_rdev;
	__kernel_long_t st_size;
	__kernel_long_t st_blksize;
	__kernel_long_t st_blocks;
	__kernel_ulong_t st_atime;
	__kernel_ulong_t st_atime_nsec;
	__kernel_ulong_t st_mtime;
	__kernel_ulong_t st_mtime_nsec;
	__kernel_ulong_t st_ctime;
	__kernel_ulong_t st_ctime_nsec;
	__kernel_long_t __unused[3];
};

struct stat64 {
	long long unsigned int st_dev;
	unsigned char __pad0[4];
	unsigned int __st_ino;
	unsigned int st_mode;
	unsigned int st_nlink;
	unsigned int st_uid;
	unsigned int st_gid;
	long long unsigned int st_rdev;
	unsigned char __pad3[4];
	long long int st_size;
	unsigned int st_blksize;
	long long int st_blocks;
	unsigned int st_atime;
	unsigned int st_atime_nsec;
	unsigned int st_mtime;
	unsigned int st_mtime_nsec;
	unsigned int st_ctime;
	unsigned int st_ctime_nsec;
	long long unsigned int st_ino;
} __attribute__((packed));

struct stat_node {
	struct rb_node node;
	void *stat;
};

struct tracer_stat;

struct stat_session {
	struct list_head session_list;
	struct tracer_stat *ts;
	struct rb_root stat_root;
	struct mutex stat_mutex;
	struct dentry *file;
};

struct statfs {
	__kernel_long_t f_type;
	__kernel_long_t f_bsize;
	__kernel_long_t f_blocks;
	__kernel_long_t f_bfree;
	__kernel_long_t f_bavail;
	__kernel_long_t f_files;
	__kernel_long_t f_ffree;
	__kernel_fsid_t f_fsid;
	__kernel_long_t f_namelen;
	__kernel_long_t f_frsize;
	__kernel_long_t f_flags;
	__kernel_long_t f_spare[4];
};

struct statfs64 {
	__kernel_long_t f_type;
	__kernel_long_t f_bsize;
	__u64 f_blocks;
	__u64 f_bfree;
	__u64 f_bavail;
	__u64 f_files;
	__u64 f_ffree;
	__kernel_fsid_t f_fsid;
	__kernel_long_t f_namelen;
	__kernel_long_t f_frsize;
	__kernel_long_t f_flags;
	__kernel_long_t f_spare[4];
};

struct static_call_mod;

struct static_call_key {
	void *func;
	union {
		long unsigned int type;
		struct static_call_mod *mods;
		struct static_call_site *sites;
	};
};

struct static_call_mod {
	struct static_call_mod *next;
	struct module *mod;
	struct static_call_site *sites;
};

struct static_call_site {
	s32 addr;
	s32 key;
};

struct static_call_tramp_key {
	s32 tramp;
	s32 key;
};

struct static_key_deferred {
	struct static_key key;
	long unsigned int timeout;
	struct delayed_work work;
};

struct static_key_false_deferred {
	struct static_key_false key;
	long unsigned int timeout;
	struct delayed_work work;
};

struct static_key_mod {
	struct static_key_mod *next;
	struct jump_entry *entries;
	struct module *mod;
};

struct static_tree_desc_s {
	const ct_data *static_tree;
	const int *extra_bits;
	int extra_base;
	int elems;
	int max_length;
};

struct station_del_parameters {
	const u8 *mac;
	u8 subtype;
	u16 reason_code;
	int link_id;
};

struct station_info {
	u64 filled;
	u32 connected_time;
	u32 inactive_time;
	u64 assoc_at;
	u64 rx_bytes;
	u64 tx_bytes;
	u16 llid;
	u16 plid;
	u8 plink_state;
	s8 signal;
	s8 signal_avg;
	u8 chains;
	s8 chain_signal[4];
	s8 chain_signal_avg[4];
	struct rate_info txrate;
	struct rate_info rxrate;
	u32 rx_packets;
	u32 tx_packets;
	u32 tx_retries;
	u32 tx_failed;
	u32 rx_dropped_misc;
	struct sta_bss_parameters bss_param;
	struct nl80211_sta_flag_update sta_flags;
	int generation;
	const u8 *assoc_req_ies;
	size_t assoc_req_ies_len;
	u32 beacon_loss_count;
	s64 t_offset;
	enum nl80211_mesh_power_mode local_pm;
	enum nl80211_mesh_power_mode peer_pm;
	enum nl80211_mesh_power_mode nonpeer_pm;
	u32 expected_throughput;
	u64 tx_duration;
	u64 rx_duration;
	u64 rx_beacon;
	u8 rx_beacon_signal_avg;
	u8 connected_to_gate;
	struct cfg80211_tid_stats *pertid;
	s8 ack_signal;
	s8 avg_ack_signal;
	u16 airtime_weight;
	u32 rx_mpdu_count;
	u32 fcs_err_count;
	u32 airtime_link_metric;
	u8 connected_to_as;
	bool mlo_params_valid;
	u8 assoc_link_id;
	int: 0;
	u8 mld_addr[6];
	const u8 *assoc_resp_ies;
	size_t assoc_resp_ies_len;
};

struct station_parameters {
	struct net_device *vlan;
	u32 sta_flags_mask;
	u32 sta_flags_set;
	u32 sta_modify_mask;
	int listen_interval;
	u16 aid;
	u16 vlan_id;
	u16 peer_aid;
	u8 plink_action;
	u8 plink_state;
	u8 uapsd_queues;
	u8 max_sp;
	enum nl80211_mesh_power_mode local_pm;
	u16 capability;
	const u8 *ext_capab;
	u8 ext_capab_len;
	const u8 *supported_channels;
	u8 supported_channels_len;
	const u8 *supported_oper_classes;
	u8 supported_oper_classes_len;
	int support_p2p_ps;
	u16 airtime_weight;
	struct link_station_parameters link_sta_params;
};

struct stats_reply_data {
	struct ethnl_reply_data base;
	union {
		struct {
			struct ethtool_eth_phy_stats phy_stats;
			struct ethtool_eth_mac_stats mac_stats;
			struct ethtool_eth_ctrl_stats ctrl_stats;
			struct ethtool_rmon_stats rmon_stats;
			struct ethtool_phy_stats phydev_stats;
		};
		struct {
			struct ethtool_eth_phy_stats phy_stats;
			struct ethtool_eth_mac_stats mac_stats;
			struct ethtool_eth_ctrl_stats ctrl_stats;
			struct ethtool_rmon_stats rmon_stats;
			struct ethtool_phy_stats phydev_stats;
		} stats;
	};
	const struct ethtool_rmon_hist_range *rmon_ranges;
};

struct stats_req_info {
	struct ethnl_req_info base;
	long unsigned int stat_mask[1];
	enum ethtool_mac_stats_src src;
};

struct statx_timestamp {
	__s64 tv_sec;
	__u32 tv_nsec;
	__s32 __reserved;
};

struct statx {
	__u32 stx_mask;
	__u32 stx_blksize;
	__u64 stx_attributes;
	__u32 stx_nlink;
	__u32 stx_uid;
	__u32 stx_gid;
	__u16 stx_mode;
	__u16 __spare0[1];
	__u64 stx_ino;
	__u64 stx_size;
	__u64 stx_blocks;
	__u64 stx_attributes_mask;
	struct statx_timestamp stx_atime;
	struct statx_timestamp stx_btime;
	struct statx_timestamp stx_ctime;
	struct statx_timestamp stx_mtime;
	__u32 stx_rdev_major;
	__u32 stx_rdev_minor;
	__u32 stx_dev_major;
	__u32 stx_dev_minor;
	__u64 stx_mnt_id;
	__u32 stx_dio_mem_align;
	__u32 stx_dio_offset_align;
	__u64 stx_subvol;
	__u32 stx_atomic_write_unit_min;
	__u32 stx_atomic_write_unit_max;
	__u32 stx_atomic_write_segments_max;
	__u32 stx_dio_read_offset_align;
	__u64 __spare3[9];
};

struct stepping_info {
	char stepping;
	char substepping;
};

struct stereo_mandatory_mode {
	int width;
	int height;
	int vrefresh;
	unsigned int flags;
};

struct stop_event_data {
	struct perf_event *event;
	unsigned int restart;
};

struct strarray {
	char **array;
	size_t n;
};

struct stripe {
	struct dm_dev *dev;
	sector_t physical_start;
	atomic_t error_count;
};

struct stripe_c {
	uint32_t stripes;
	int stripes_shift;
	sector_t stripe_width;
	uint32_t chunk_size;
	int chunk_size_shift;
	struct dm_target *ti;
	struct work_struct trigger_event;
	struct stripe stripe[0];
};

struct strset_info {
	bool per_dev;
	bool free_strings;
	unsigned int count;
	const char (*strings)[32];
};

struct strset_reply_data {
	struct ethnl_reply_data base;
	struct strset_info sets[23];
};

struct strset_req_info {
	struct ethnl_req_info base;
	u32 req_ids;
	bool counts_only;
};

struct subplatform_desc {
	struct intel_display_platforms platforms;
	const char *name;
	const u16 *pciidlist;
	struct stepping_desc step_info;
};

struct subprocess_info {
	struct work_struct work;
	struct completion *complete;
	const char *path;
	char **argv;
	char **envp;
	int wait;
	int retval;
	int (*init)(struct subprocess_info *, struct cred *);
	void (*cleanup)(struct subprocess_info *);
	void *data;
};

struct subsys_dev_iter {
	struct klist_iter ki;
	const struct device_type *type;
};

struct subsys_interface {
	const char *name;
	const struct bus_type *subsys;
	struct list_head node;
	int (*add_dev)(struct device *, struct subsys_interface *);
	void (*remove_dev)(struct device *, struct subsys_interface *);
};

struct subsys_private {
	struct kset subsys;
	struct kset *devices_kset;
	struct list_head interfaces;
	struct mutex mutex;
	struct kset *drivers_kset;
	struct klist klist_devices;
	struct klist klist_drivers;
	struct blocking_notifier_head bus_notifier;
	unsigned int drivers_autoprobe: 1;
	const struct bus_type *bus;
	struct device *dev_root;
	struct kset glue_dirs;
	const struct class *class;
	struct lock_class_key lock_key;
};

struct subsys_tbl_ent {
	u16 subsys_vendor;
	u16 subsys_devid;
	u32 phy_id;
};

struct sugov_policy;

struct sugov_cpu {
	struct update_util_data update_util;
	struct sugov_policy *sg_policy;
	unsigned int cpu;
	bool iowait_boost_pending;
	unsigned int iowait_boost;
	u64 last_update;
	long unsigned int util;
	long unsigned int bw_min;
	long unsigned int saved_idle_calls;
};

struct sugov_tunables;

struct sugov_policy {
	struct cpufreq_policy *policy;
	struct sugov_tunables *tunables;
	struct list_head tunables_hook;
	raw_spinlock_t update_lock;
	u64 last_freq_update_time;
	s64 freq_update_delay_ns;
	unsigned int next_freq;
	unsigned int cached_raw_freq;
	struct irq_work irq_work;
	struct kthread_work work;
	struct mutex work_lock;
	struct kthread_worker worker;
	struct task_struct *thread;
	bool work_in_progress;
	bool limits_changed;
	bool need_freq_update;
};

struct sugov_tunables {
	struct gov_attr_set attr_set;
	unsigned int rate_limit_us;
};

struct sunrpc_net {
	struct proc_dir_entry *proc_net_rpc;
	struct cache_detail *ip_map_cache;
	struct cache_detail *unix_gid_cache;
	struct cache_detail *rsc_cache;
	struct cache_detail *rsi_cache;
	struct super_block *pipefs_sb;
	struct rpc_pipe *gssd_dummy;
	struct mutex pipefs_sb_lock;
	struct list_head all_clients;
	spinlock_t rpc_client_lock;
	struct rpc_clnt *rpcb_local_clnt;
	struct rpc_clnt *rpcb_local_clnt4;
	spinlock_t rpcb_clnt_lock;
	unsigned int rpcb_users;
	unsigned int rpcb_is_af_local: 1;
	struct mutex gssp_lock;
	struct rpc_clnt *gssp_clnt;
	int use_gss_proxy;
	int pipe_version;
	atomic_t pipe_users;
	struct proc_dir_entry *use_gssp_proc;
	struct proc_dir_entry *gss_krb5_enctypes;
};

struct mtd_info;

struct super_block {
	struct list_head s_list;
	dev_t s_dev;
	unsigned char s_blocksize_bits;
	long unsigned int s_blocksize;
	loff_t s_maxbytes;
	struct file_system_type *s_type;
	const struct super_operations *s_op;
	const struct dquot_operations *dq_op;
	const struct quotactl_ops *s_qcop;
	const struct export_operations *s_export_op;
	long unsigned int s_flags;
	long unsigned int s_iflags;
	long unsigned int s_magic;
	struct dentry *s_root;
	struct rw_semaphore s_umount;
	int s_count;
	atomic_t s_active;
	void *s_security;
	const struct xattr_handler * const *s_xattr;
	struct hlist_bl_head s_roots;
	struct list_head s_mounts;
	struct block_device *s_bdev;
	struct file *s_bdev_file;
	struct backing_dev_info *s_bdi;
	struct mtd_info *s_mtd;
	struct hlist_node s_instances;
	unsigned int s_quota_types;
	struct quota_info s_dquot;
	struct sb_writers s_writers;
	void *s_fs_info;
	u32 s_time_gran;
	time64_t s_time_min;
	time64_t s_time_max;
	u32 s_fsnotify_mask;
	struct fsnotify_sb_info *s_fsnotify_info;
	char s_id[32];
	uuid_t s_uuid;
	u8 s_uuid_len;
	char s_sysfs_name[37];
	unsigned int s_max_links;
	struct mutex s_vfs_rename_mutex;
	const char *s_subtype;
	const struct dentry_operations *s_d_op;
	struct shrinker *s_shrink;
	atomic_long_t s_remove_count;
	int s_readonly_remount;
	errseq_t s_wb_err;
	struct workqueue_struct *s_dio_done_wq;
	struct hlist_head s_pins;
	struct user_namespace *s_user_ns;
	struct list_lru s_dentry_lru;
	struct list_lru s_inode_lru;
	struct callback_head rcu;
	struct work_struct destroy_work;
	struct mutex s_sync_lock;
	int s_stack_depth;
	long: 0;
	spinlock_t s_inode_list_lock;
	struct list_head s_inodes;
	spinlock_t s_inode_wblist_lock;
	struct list_head s_inodes_wb;
	long: 64;
	long: 64;
};

struct super_operations {
	struct inode * (*alloc_inode)(struct super_block *);
	void (*destroy_inode)(struct inode *);
	void (*free_inode)(struct inode *);
	void (*dirty_inode)(struct inode *, int);
	int (*write_inode)(struct inode *, struct writeback_control *);
	int (*drop_inode)(struct inode *);
	void (*evict_inode)(struct inode *);
	void (*put_super)(struct super_block *);
	int (*sync_fs)(struct super_block *, int);
	int (*freeze_super)(struct super_block *, enum freeze_holder);
	int (*freeze_fs)(struct super_block *);
	int (*thaw_super)(struct super_block *, enum freeze_holder);
	int (*unfreeze_fs)(struct super_block *);
	int (*statfs)(struct dentry *, struct kstatfs *);
	int (*remount_fs)(struct super_block *, int *, char *);
	void (*umount_begin)(struct super_block *);
	int (*show_options)(struct seq_file *, struct dentry *);
	int (*show_devname)(struct seq_file *, struct dentry *);
	int (*show_path)(struct seq_file *, struct dentry *);
	int (*show_stats)(struct seq_file *, struct dentry *);
	ssize_t (*quota_read)(struct super_block *, int, char *, size_t, loff_t);
	ssize_t (*quota_write)(struct super_block *, int, const char *, size_t, loff_t);
	struct dquot ** (*get_dquots)(struct inode *);
	long int (*nr_cached_objects)(struct super_block *, struct shrink_control *);
	long int (*free_cached_objects)(struct super_block *, struct shrink_control *);
	void (*shutdown)(struct super_block *);
};

struct super_type {
	char *name;
	struct module *owner;
	int (*load_super)(struct md_rdev *, struct md_rdev *, int);
	int (*validate_super)(struct mddev *, struct md_rdev *, struct md_rdev *);
	void (*sync_super)(struct mddev *, struct md_rdev *);
	long long unsigned int (*rdev_size_change)(struct md_rdev *, sector_t);
	int (*allow_new_offset)(struct md_rdev *, long long unsigned int);
};

struct superblock_security_struct {
	u32 sid;
	u32 def_sid;
	u32 mntpoint_sid;
	short unsigned int behavior;
	short unsigned int flags;
	struct mutex lock;
	struct list_head isec_head;
	spinlock_t isec_lock;
};

struct survey_info {
	struct ieee80211_channel *channel;
	u64 time;
	u64 time_busy;
	u64 time_ext_busy;
	u64 time_rx;
	u64 time_tx;
	u64 time_scan;
	u64 time_bss_rx;
	u32 filled;
	s8 noise;
};

struct suspend_stats {
	unsigned int step_failures[8];
	unsigned int success;
	unsigned int fail;
	int last_failed_dev;
	char failed_devs[80];
	int last_failed_errno;
	int errno[2];
	int last_failed_step;
	u64 last_hw_sleep;
	u64 total_hw_sleep;
	u64 max_hw_sleep;
	enum suspend_stat_step failed_steps[2];
};

struct svc_deferred_req {
	u32 prot;
	struct svc_xprt *xprt;
	struct __kernel_sockaddr_storage addr;
	size_t addrlen;
	struct __kernel_sockaddr_storage daddr;
	size_t daddrlen;
	void *xprt_ctxt;
	struct cache_deferred_req handle;
	int argslen;
	__be32 args[0];
};

struct svc_info {
	struct svc_serv *serv;
	struct mutex *mutex;
};

struct svc_pool {
	unsigned int sp_id;
	struct lwq sp_xprts;
	unsigned int sp_nrthreads;
	struct list_head sp_all_threads;
	struct llist_head sp_idle_threads;
	struct percpu_counter sp_messages_arrived;
	struct percpu_counter sp_sockets_queued;
	struct percpu_counter sp_threads_woken;
	long unsigned int sp_flags;
};

struct svc_pool_map {
	int count;
	int mode;
	unsigned int npools;
	unsigned int *pool_to;
	unsigned int *to_pool;
};

struct svc_procedure {
	__be32 (*pc_func)(struct svc_rqst *);
	bool (*pc_decode)(struct svc_rqst *, struct xdr_stream *);
	bool (*pc_encode)(struct svc_rqst *, struct xdr_stream *);
	void (*pc_release)(struct svc_rqst *);
	unsigned int pc_argsize;
	unsigned int pc_argzero;
	unsigned int pc_ressize;
	unsigned int pc_cachetype;
	unsigned int pc_xdrressize;
	const char *pc_name;
};

struct svc_process_info {
	union {
		int (*dispatch)(struct svc_rqst *);
		struct {
			unsigned int lovers;
			unsigned int hivers;
		} mismatch;
	};
};

struct svc_version;

struct svc_program {
	u32 pg_prog;
	unsigned int pg_lovers;
	unsigned int pg_hivers;
	unsigned int pg_nvers;
	const struct svc_version **pg_vers;
	char *pg_name;
	char *pg_class;
	enum svc_auth_status (*pg_authenticate)(struct svc_rqst *);
	__be32 (*pg_init_request)(struct svc_rqst *, const struct svc_program *, struct svc_process_info *);
	int (*pg_rpcbind_set)(struct net *, const struct svc_program *, u32, int, short unsigned int, short unsigned int);
};

struct xdr_stream {
	__be32 *p;
	struct xdr_buf *buf;
	__be32 *end;
	struct kvec *iov;
	struct kvec scratch;
	struct page **page_ptr;
	void *page_kaddr;
	unsigned int nwords;
	struct rpc_rqst *rqst;
};

struct svc_rqst {
	struct list_head rq_all;
	struct llist_node rq_idle;
	struct callback_head rq_rcu_head;
	struct svc_xprt *rq_xprt;
	struct __kernel_sockaddr_storage rq_addr;
	size_t rq_addrlen;
	struct __kernel_sockaddr_storage rq_daddr;
	size_t rq_daddrlen;
	struct svc_serv *rq_server;
	struct svc_pool *rq_pool;
	const struct svc_procedure *rq_procinfo;
	struct auth_ops *rq_authop;
	struct svc_cred rq_cred;
	void *rq_xprt_ctxt;
	struct svc_deferred_req *rq_deferred;
	struct xdr_buf rq_arg;
	struct xdr_stream rq_arg_stream;
	struct xdr_stream rq_res_stream;
	struct page *rq_scratch_page;
	struct xdr_buf rq_res;
	struct page *rq_pages[260];
	struct page **rq_respages;
	struct page **rq_next_page;
	struct page **rq_page_end;
	struct folio_batch rq_fbatch;
	struct kvec rq_vec[259];
	struct bio_vec rq_bvec[259];
	__be32 rq_xid;
	u32 rq_prog;
	u32 rq_vers;
	u32 rq_proc;
	u32 rq_prot;
	int rq_cachetype;
	long unsigned int rq_flags;
	ktime_t rq_qtime;
	void *rq_argp;
	void *rq_resp;
	__be32 *rq_accept_statp;
	void *rq_auth_data;
	__be32 rq_auth_stat;
	int rq_auth_slack;
	int rq_reserved;
	ktime_t rq_stime;
	struct cache_req rq_chandle;
	struct auth_domain *rq_client;
	struct auth_domain *rq_gssclient;
	struct task_struct *rq_task;
	struct net *rq_bc_net;
	int rq_err;
	long unsigned int bc_to_initval;
	unsigned int bc_to_retries;
	void **rq_lease_breaker;
	unsigned int rq_status_counter;
};

struct svc_stat;

struct svc_serv {
	struct svc_program *sv_programs;
	struct svc_stat *sv_stats;
	spinlock_t sv_lock;
	unsigned int sv_nprogs;
	unsigned int sv_nrthreads;
	unsigned int sv_max_payload;
	unsigned int sv_max_mesg;
	unsigned int sv_xdrsize;
	struct list_head sv_permsocks;
	struct list_head sv_tempsocks;
	int sv_tmpcnt;
	struct timer_list sv_temptimer;
	char *sv_name;
	unsigned int sv_nrpools;
	bool sv_is_pooled;
	struct svc_pool *sv_pools;
	int (*sv_threadfn)(void *);
};

struct svc_xprt_class;

struct svc_xprt_ops;

struct svc_xprt {
	struct svc_xprt_class *xpt_class;
	const struct svc_xprt_ops *xpt_ops;
	struct kref xpt_ref;
	struct list_head xpt_list;
	struct lwq_node xpt_ready;
	long unsigned int xpt_flags;
	struct svc_serv *xpt_server;
	atomic_t xpt_reserved;
	atomic_t xpt_nr_rqsts;
	struct mutex xpt_mutex;
	spinlock_t xpt_lock;
	void *xpt_auth_cache;
	struct list_head xpt_deferred;
	struct __kernel_sockaddr_storage xpt_local;
	size_t xpt_locallen;
	struct __kernel_sockaddr_storage xpt_remote;
	size_t xpt_remotelen;
	char xpt_remotebuf[58];
	struct list_head xpt_users;
	struct net *xpt_net;
	netns_tracker ns_tracker;
	const struct cred *xpt_cred;
	struct rpc_xprt *xpt_bc_xprt;
	struct rpc_xprt_switch *xpt_bc_xps;
};

struct svc_sock {
	struct svc_xprt sk_xprt;
	struct socket *sk_sock;
	struct sock *sk_sk;
	void (*sk_ostate)(struct sock *);
	void (*sk_odata)(struct sock *);
	void (*sk_owspace)(struct sock *);
	__be32 sk_marker;
	u32 sk_tcplen;
	u32 sk_datalen;
	struct page_frag_cache sk_frag_cache;
	struct completion sk_handshake_done;
	struct page *sk_pages[259];
};

struct svc_stat {
	struct svc_program *program;
	unsigned int netcnt;
	unsigned int netudpcnt;
	unsigned int nettcpcnt;
	unsigned int nettcpconn;
	unsigned int rpccnt;
	unsigned int rpcbadfmt;
	unsigned int rpcbadauth;
	unsigned int rpcbadclnt;
};

struct svc_version {
	u32 vs_vers;
	u32 vs_nproc;
	const struct svc_procedure *vs_proc;
	long unsigned int *vs_count;
	u32 vs_xdrsize;
	bool vs_hidden;
	bool vs_rpcb_optnl;
	bool vs_need_cong_ctrl;
	int (*vs_dispatch)(struct svc_rqst *);
};

struct svc_xprt_class {
	const char *xcl_name;
	struct module *xcl_owner;
	const struct svc_xprt_ops *xcl_ops;
	struct list_head xcl_list;
	u32 xcl_max_payload;
	int xcl_ident;
};

struct svc_xprt_ops {
	struct svc_xprt * (*xpo_create)(struct svc_serv *, struct net *, struct sockaddr *, int, int);
	struct svc_xprt * (*xpo_accept)(struct svc_xprt *);
	int (*xpo_has_wspace)(struct svc_xprt *);
	int (*xpo_recvfrom)(struct svc_rqst *);
	int (*xpo_sendto)(struct svc_rqst *);
	int (*xpo_result_payload)(struct svc_rqst *, unsigned int, unsigned int);
	void (*xpo_release_ctxt)(struct svc_xprt *, void *);
	void (*xpo_detach)(struct svc_xprt *);
	void (*xpo_free)(struct svc_xprt *);
	void (*xpo_kill_temp_xprt)(struct svc_xprt *);
	void (*xpo_handshake)(struct svc_xprt *);
};

struct svc_xpt_user {
	struct list_head list;
	void (*callback)(struct svc_xpt_user *);
};

struct swait_queue {
	struct task_struct *task;
	struct list_head task_list;
};

struct swap_cluster_info {
	spinlock_t lock;
	u16 count;
	u8 flags;
	u8 order;
	struct list_head list;
};

struct swap_extent {
	struct rb_node rb_node;
	long unsigned int start_page;
	long unsigned int nr_pages;
	sector_t start_block;
};

union swap_header {
	struct {
		char reserved[4086];
		char magic[10];
	} magic;
	struct {
		char bootbits[1024];
		__u32 version;
		__u32 last_page;
		__u32 nr_badpages;
		unsigned char sws_uuid[16];
		unsigned char sws_volume[16];
		__u32 padding[117];
		__u32 badpages[1];
	} info;
};

struct swap_info_struct {
	struct percpu_ref users;
	long unsigned int flags;
	short int prio;
	struct plist_node list;
	signed char type;
	unsigned int max;
	unsigned char *swap_map;
	long unsigned int *zeromap;
	struct swap_cluster_info *cluster_info;
	struct list_head free_clusters;
	struct list_head full_clusters;
	struct list_head nonfull_clusters[1];
	struct list_head frag_clusters[1];
	atomic_long_t frag_cluster_nr[1];
	unsigned int pages;
	atomic_long_t inuse_pages;
	struct percpu_cluster *percpu_cluster;
	struct percpu_cluster *global_cluster;
	spinlock_t global_cluster_lock;
	struct rb_root swap_extent_root;
	struct block_device *bdev;
	struct file *swap_file;
	struct completion comp;
	spinlock_t lock;
	spinlock_t cont_lock;
	struct work_struct discard_work;
	struct work_struct reclaim_work;
	struct list_head discard_clusters;
	struct plist_node avail_lists[0];
};

struct swap_iocb {
	struct kiocb iocb;
	struct bio_vec bvec[32];
	int pages;
	int len;
};

struct swap_map_page;

struct swap_map_page_list;

struct swap_map_handle {
	struct swap_map_page *cur;
	struct swap_map_page_list *maps;
	sector_t cur_swap;
	sector_t first_sector;
	unsigned int k;
	long unsigned int reqd_free_pages;
	u32 crc32;
};

struct swap_map_page {
	sector_t entries[511];
	sector_t next_swap;
};

struct swap_map_page_list {
	struct swap_map_page *map;
	struct swap_map_page_list *next;
};

struct swap_slots_cache {
	bool lock_initialized;
	struct mutex alloc_lock;
	swp_entry_t *slots;
	int nr;
	int cur;
	int n_ret;
};

struct swevent_hlist {
	struct hlist_head heads[256];
	struct callback_head callback_head;
};

struct swevent_htable {
	struct swevent_hlist *swevent_hlist;
	struct mutex hlist_mutex;
	int hlist_refcount;
};

struct swmii_regs {
	u16 bmsr;
	u16 lpa;
	u16 lpagb;
	u16 estat;
};

struct swnode {
	struct kobject kobj;
	struct fwnode_handle fwnode;
	const struct software_node *node;
	int id;
	struct ida child_ids;
	struct list_head entry;
	struct list_head children;
	struct swnode *parent;
	unsigned int allocated: 1;
	unsigned int managed: 1;
};

struct swoc_info {
	__u8 rev;
	__u8 reserved[8];
	__u16 LinuxSKU;
	__u16 LinuxVer;
	__u8 reserved2[47];
} __attribute__((packed));

struct swsusp_extent {
	struct rb_node node;
	long unsigned int start;
	long unsigned int end;
};

struct swsusp_header {
	char reserved[4056];
	u32 hw_sig;
	u32 crc32;
	sector_t image;
	unsigned int flags;
	char orig_sig[10];
	char sig[10];
};

struct swsusp_info {
	struct new_utsname uts;
	u32 version_code;
	long unsigned int num_physpages;
	int cpus;
	long unsigned int image_pages;
	long unsigned int pages;
	long unsigned int size;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct sym_count_ctx {
	unsigned int count;
	const char *name;
};

struct symsearch {
	const struct kernel_symbol *start;
	const struct kernel_symbol *stop;
	const u32 *crcs;
	enum mod_license license;
};

struct synaptics_device_info {
	u32 model_id;
	u32 firmware_id;
	u32 board_id;
	u32 capabilities;
	u32 ext_cap;
	u32 ext_cap_0c;
	u32 ext_cap_10;
	u32 identity;
	u32 x_res;
	u32 y_res;
	u32 x_max;
	u32 y_max;
	u32 x_min;
	u32 y_min;
};

struct synaptics_hw_state {
	int x;
	int y;
	int z;
	int w;
	unsigned int left: 1;
	unsigned int right: 1;
	unsigned int middle: 1;
	unsigned int up: 1;
	unsigned int down: 1;
	u8 ext_buttons;
	s8 scroll;
};

struct synaptics_data {
	struct synaptics_device_info info;
	enum synaptics_pkt_type pkt_type;
	u8 mode;
	int scroll;
	bool absolute_mode;
	bool disable_gesture;
	struct serio *pt_port;
	bool pt_port_open;
	struct synaptics_hw_state agm;
	unsigned int agm_count;
	long unsigned int press_start;
	bool press;
	bool report_press;
	bool is_forcepad;
};

struct sync_fence_info {
	char obj_name[32];
	char driver_name[32];
	__s32 status;
	__u32 flags;
	__u64 timestamp_ns;
};

struct sync_file {
	struct file *file;
	char user_name[32];
	struct list_head sync_file_list;
	wait_queue_head_t wq;
	long unsigned int flags;
	struct dma_fence *fence;
	struct dma_fence_cb cb;
};

struct sync_file_info {
	char name[32];
	__s32 status;
	__u32 flags;
	__u32 num_fences;
	__u32 pad;
	__u64 sync_fence_info;
};

struct sync_io {
	long unsigned int error_bits;
	struct completion wait;
};

struct sync_merge_data {
	char name[32];
	__s32 fd2;
	__s32 fence;
	__u32 flags;
	__u32 pad;
};

struct sync_set_deadline {
	__u64 deadline_ns;
	__u64 pad;
};

struct syncobj_eventfd_entry {
	struct list_head node;
	struct dma_fence *fence;
	struct dma_fence_cb fence_cb;
	struct drm_syncobj *syncobj;
	struct eventfd_ctx *ev_fd_ctx;
	u64 point;
	u32 flags;
};

struct syncobj_wait_entry {
	struct list_head node;
	struct task_struct *task;
	struct dma_fence *fence;
	struct dma_fence_cb fence_cb;
	u64 point;
};

struct sys_off_data {
	int mode;
	void *cb_data;
	const char *cmd;
	struct device *dev;
};

struct sys_off_handler {
	struct notifier_block nb;
	int (*sys_off_cb)(struct sys_off_data *);
	void *cb_data;
	enum sys_off_mode mode;
	bool blocking;
	void *list;
	struct device *dev;
};

struct syscall_info {
	__u64 sp;
	struct seccomp_data data;
};

struct syscall_metadata {
	const char *name;
	int syscall_nr;
	int nb_args;
	const char **types;
	const char **args;
	struct list_head enter_fields;
	struct trace_event_call *enter_event;
	struct trace_event_call *exit_event;
};

struct syscall_tp_t {
	struct trace_entry ent;
	int syscall_nr;
	long unsigned int ret;
};

struct syscall_tp_t___2 {
	struct trace_entry ent;
	int syscall_nr;
	long unsigned int args[6];
};

struct syscall_trace_enter {
	struct trace_entry ent;
	int nr;
	long unsigned int args[0];
};

struct syscall_trace_exit {
	struct trace_entry ent;
	int nr;
	long int ret;
};

struct syscall_user_dispatch {
	char *selector;
	long unsigned int offset;
	long unsigned int len;
	bool on_dispatch;
};

struct syscore_ops {
	struct list_head node;
	int (*suspend)(void);
	void (*resume)(void);
	void (*shutdown)(void);
};

struct sysctl_alias {
	const char *kernel_param;
	const char *sysctl_param;
};

struct sysfs_ops {
	ssize_t (*show)(struct kobject *, struct attribute *, char *);
	ssize_t (*store)(struct kobject *, struct attribute *, const char *, size_t);
};

struct sysinfo {
	__kernel_long_t uptime;
	__kernel_ulong_t loads[3];
	__kernel_ulong_t totalram;
	__kernel_ulong_t freeram;
	__kernel_ulong_t sharedram;
	__kernel_ulong_t bufferram;
	__kernel_ulong_t totalswap;
	__kernel_ulong_t freeswap;
	__u16 procs;
	__u16 pad;
	__kernel_ulong_t totalhigh;
	__kernel_ulong_t freehigh;
	__u32 mem_unit;
	char _f[0];
};

struct sysrq_key_op {
	void (* const handler)(u8);
	const char * const help_msg;
	const char * const action_msg;
	const int enable_mask;
};

struct sysrq_state {
	struct input_handle handle;
	struct work_struct reinject_work;
	long unsigned int key_down[12];
	unsigned int alt;
	unsigned int alt_use;
	unsigned int shift;
	unsigned int shift_use;
	bool active;
	bool need_reinject;
	bool reinjecting;
	bool reset_canceled;
	bool reset_requested;
	long unsigned int reset_keybit[12];
	int reset_seq_len;
	int reset_seq_cnt;
	int reset_seq_version;
	struct timer_list keyreset_timer;
};

struct system_counterval_t {
	u64 cycles;
	enum clocksource_ids cs_id;
	bool use_nsecs;
};

struct system_device_crosststamp {
	ktime_t device;
	ktime_t sys_realtime;
	ktime_t sys_monoraw;
};

struct system_time_snapshot {
	u64 cycles;
	ktime_t real;
	ktime_t boot;
	ktime_t raw;
	enum clocksource_ids cs_id;
	unsigned int clock_was_set_seq;
	u8 cs_was_changed_seq;
};

struct sysv_sem {
	struct sem_undo_list *undo_list;
};

struct sysv_shm {
	struct list_head shm_clist;
};

struct table_device {
	struct list_head list;
	refcount_t count;
	struct dm_dev dm_dev;
};

struct taint_flag {
	char c_true;
	char c_false;
	bool module;
	const char *desc;
};

typedef int (*dm_ctr_fn)(struct dm_target *, unsigned int, char **);

typedef void (*dm_dtr_fn)(struct dm_target *);

typedef int (*dm_map_fn)(struct dm_target *, struct bio *);

typedef int (*dm_clone_and_map_request_fn)(struct dm_target *, struct request *, union map_info *, struct request **);

typedef void (*dm_release_clone_request_fn)(struct request *, union map_info *);

typedef int (*dm_endio_fn)(struct dm_target *, struct bio *, blk_status_t *);

typedef int (*dm_request_endio_fn)(struct dm_target *, struct request *, blk_status_t, union map_info *);

typedef void (*dm_presuspend_fn)(struct dm_target *);

typedef void (*dm_presuspend_undo_fn)(struct dm_target *);

typedef void (*dm_postsuspend_fn)(struct dm_target *);

typedef int (*dm_preresume_fn)(struct dm_target *);

typedef void (*dm_resume_fn)(struct dm_target *);

typedef void (*dm_status_fn)(struct dm_target *, status_type_t, unsigned int, char *, unsigned int);

typedef int (*dm_message_fn)(struct dm_target *, unsigned int, char **, char *, unsigned int);

typedef int (*dm_prepare_ioctl_fn)(struct dm_target *, struct block_device **);

typedef int (*dm_report_zones_fn)(struct dm_target *);

typedef int (*dm_busy_fn)(struct dm_target *);

typedef int (*iterate_devices_callout_fn)(struct dm_target *, struct dm_dev *, sector_t, sector_t, void *);

typedef int (*dm_iterate_devices_fn)(struct dm_target *, iterate_devices_callout_fn, void *);

typedef void (*dm_io_hints_fn)(struct dm_target *, struct queue_limits *);

typedef long int (*dm_dax_direct_access_fn)(struct dm_target *, long unsigned int, long int, enum dax_access_mode, void **, pfn_t *);

typedef int (*dm_dax_zero_page_range_fn)(struct dm_target *, long unsigned int, size_t);

typedef size_t (*dm_dax_recovery_write_fn)(struct dm_target *, long unsigned int, void *, size_t, struct iov_iter *);

struct target_type {
	uint64_t features;
	const char *name;
	struct module *module;
	unsigned int version[3];
	dm_ctr_fn ctr;
	dm_dtr_fn dtr;
	dm_map_fn map;
	dm_clone_and_map_request_fn clone_and_map_rq;
	dm_release_clone_request_fn release_clone_rq;
	dm_endio_fn end_io;
	dm_request_endio_fn rq_end_io;
	dm_presuspend_fn presuspend;
	dm_presuspend_undo_fn presuspend_undo;
	dm_postsuspend_fn postsuspend;
	dm_preresume_fn preresume;
	dm_resume_fn resume;
	dm_status_fn status;
	dm_message_fn message;
	dm_prepare_ioctl_fn prepare_ioctl;
	dm_report_zones_fn report_zones;
	dm_busy_fn busy;
	dm_iterate_devices_fn iterate_devices;
	dm_io_hints_fn io_hints;
	dm_dax_direct_access_fn direct_access;
	dm_dax_zero_page_range_fn dax_zero_page_range;
	dm_dax_recovery_write_fn dax_recovery_write;
	struct list_head list;
};

struct task_delay_info {
	raw_spinlock_t lock;
	u64 blkio_start;
	u64 blkio_delay_max;
	u64 blkio_delay_min;
	u64 blkio_delay;
	u64 swapin_start;
	u64 swapin_delay_max;
	u64 swapin_delay_min;
	u64 swapin_delay;
	u32 blkio_count;
	u32 swapin_count;
	u64 freepages_start;
	u64 freepages_delay_max;
	u64 freepages_delay_min;
	u64 freepages_delay;
	u64 thrashing_start;
	u64 thrashing_delay_max;
	u64 thrashing_delay_min;
	u64 thrashing_delay;
	u64 compact_start;
	u64 compact_delay_max;
	u64 compact_delay_min;
	u64 compact_delay;
	u64 wpcopy_start;
	u64 wpcopy_delay_max;
	u64 wpcopy_delay_min;
	u64 wpcopy_delay;
	u64 irq_delay_max;
	u64 irq_delay_min;
	u64 irq_delay;
	u32 freepages_count;
	u32 thrashing_count;
	u32 compact_count;
	u32 wpcopy_count;
	u32 irq_count;
};

struct task_group {
	struct cgroup_subsys_state css;
	int idle;
	struct sched_entity **se;
	struct cfs_rq **cfs_rq;
	long unsigned int shares;
	long: 64;
	long: 64;
	atomic_long_t load_avg;
	struct callback_head rcu;
	struct list_head list;
	struct task_group *parent;
	struct list_head siblings;
	struct list_head children;
	struct cfs_bandwidth cfs_bandwidth;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct task_security_struct {
	u32 osid;
	u32 sid;
	u32 exec_sid;
	u32 create_sid;
	u32 keycreate_sid;
	u32 sockcreate_sid;
};

typedef struct task_struct *class_find_get_task_t;

typedef struct task_struct *class_task_lock_t;

struct thread_info {
	long unsigned int flags;
	long unsigned int syscall_work;
	u32 status;
	u32 cpu;
};

struct wake_q_node {
	struct wake_q_node *next;
};

struct tlbflush_unmap_batch {
	struct arch_tlbflush_unmap_batch arch;
	bool flush_required;
	bool writable;
};

struct thread_struct {
	struct desc_struct tls_array[3];
	long unsigned int sp;
	short unsigned int es;
	short unsigned int ds;
	short unsigned int fsindex;
	short unsigned int gsindex;
	long unsigned int fsbase;
	long unsigned int gsbase;
	struct perf_event *ptrace_bps[4];
	long unsigned int virtual_dr6;
	long unsigned int ptrace_dr7;
	long unsigned int cr2;
	long unsigned int trap_nr;
	long unsigned int error_code;
	struct io_bitmap *io_bitmap;
	long unsigned int iopl_emul;
	unsigned int iopl_warn: 1;
	u32 pkru;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct fpu fpu;
};

struct uprobe_task;

struct task_struct {
	struct thread_info thread_info;
	unsigned int __state;
	unsigned int saved_state;
	void *stack;
	refcount_t usage;
	unsigned int flags;
	unsigned int ptrace;
	int on_cpu;
	struct __call_single_node wake_entry;
	unsigned int wakee_flips;
	long unsigned int wakee_flip_decay_ts;
	struct task_struct *last_wakee;
	int recent_used_cpu;
	int wake_cpu;
	int on_rq;
	int prio;
	int static_prio;
	int normal_prio;
	unsigned int rt_priority;
	struct sched_entity se;
	struct sched_rt_entity rt;
	struct sched_dl_entity dl;
	struct sched_dl_entity *dl_server;
	const struct sched_class *sched_class;
	struct task_group *sched_task_group;
	struct sched_statistics stats;
	unsigned int btrace_seq;
	unsigned int policy;
	long unsigned int max_allowed_capacity;
	int nr_cpus_allowed;
	const cpumask_t *cpus_ptr;
	cpumask_t *user_cpus_ptr;
	cpumask_t cpus_mask;
	void *migration_pending;
	short unsigned int migration_disabled;
	short unsigned int migration_flags;
	int rcu_read_lock_nesting;
	union rcu_special rcu_read_unlock_special;
	struct list_head rcu_node_entry;
	struct rcu_node *rcu_blocked_node;
	long unsigned int rcu_tasks_nvcsw;
	u8 rcu_tasks_holdout;
	u8 rcu_tasks_idx;
	int rcu_tasks_idle_cpu;
	struct list_head rcu_tasks_holdout_list;
	int rcu_tasks_exit_cpu;
	struct list_head rcu_tasks_exit_list;
	int trc_reader_nesting;
	int trc_ipi_to_cpu;
	union rcu_special trc_reader_special;
	struct list_head trc_holdout_list;
	struct list_head trc_blkd_node;
	int trc_blkd_cpu;
	struct sched_info sched_info;
	struct list_head tasks;
	struct plist_node pushable_tasks;
	struct rb_node pushable_dl_tasks;
	struct mm_struct *mm;
	struct mm_struct *active_mm;
	struct address_space *faults_disabled_mapping;
	int exit_state;
	int exit_code;
	int exit_signal;
	int pdeath_signal;
	long unsigned int jobctl;
	unsigned int personality;
	unsigned int sched_reset_on_fork: 1;
	unsigned int sched_contributes_to_load: 1;
	unsigned int sched_migrated: 1;
	unsigned int sched_task_hot: 1;
	long: 28;
	unsigned int sched_remote_wakeup: 1;
	unsigned int sched_rt_mutex: 1;
	unsigned int in_execve: 1;
	unsigned int in_iowait: 1;
	unsigned int restore_sigmask: 1;
	unsigned int no_cgroup_migration: 1;
	unsigned int frozen: 1;
	unsigned int use_memdelay: 1;
	unsigned int in_eventfd: 1;
	unsigned int pasid_activated: 1;
	unsigned int reported_split_lock: 1;
	unsigned int in_thrashing: 1;
	long unsigned int atomic_flags;
	struct restart_block restart_block;
	pid_t pid;
	pid_t tgid;
	long unsigned int stack_canary;
	struct task_struct *real_parent;
	struct task_struct *parent;
	struct list_head children;
	struct list_head sibling;
	struct task_struct *group_leader;
	struct list_head ptraced;
	struct list_head ptrace_entry;
	struct pid *thread_pid;
	struct hlist_node pid_links[4];
	struct list_head thread_node;
	struct completion *vfork_done;
	int *set_child_tid;
	int *clear_child_tid;
	void *worker_private;
	u64 utime;
	u64 stime;
	u64 gtime;
	struct prev_cputime prev_cputime;
	long unsigned int nvcsw;
	long unsigned int nivcsw;
	u64 start_time;
	u64 start_boottime;
	long unsigned int min_flt;
	long unsigned int maj_flt;
	struct posix_cputimers posix_cputimers;
	struct posix_cputimers_work posix_cputimers_work;
	const struct cred *ptracer_cred;
	const struct cred *real_cred;
	const struct cred *cred;
	struct key *cached_requested_key;
	char comm[16];
	struct nameidata *nameidata;
	struct sysv_sem sysvsem;
	struct sysv_shm sysvshm;
	struct fs_struct *fs;
	struct files_struct *files;
	struct io_uring_task *io_uring;
	struct nsproxy *nsproxy;
	struct signal_struct *signal;
	struct sighand_struct *sighand;
	sigset_t blocked;
	sigset_t real_blocked;
	sigset_t saved_sigmask;
	struct sigpending pending;
	long unsigned int sas_ss_sp;
	size_t sas_ss_size;
	unsigned int sas_ss_flags;
	struct callback_head *task_works;
	struct audit_context *audit_context;
	kuid_t loginuid;
	unsigned int sessionid;
	struct seccomp seccomp;
	struct syscall_user_dispatch syscall_dispatch;
	u64 parent_exec_id;
	u64 self_exec_id;
	spinlock_t alloc_lock;
	raw_spinlock_t pi_lock;
	struct wake_q_node wake_q;
	struct rb_root_cached pi_waiters;
	struct task_struct *pi_top_task;
	struct rt_mutex_waiter *pi_blocked_on;
	void *journal_info;
	struct bio_list *bio_list;
	struct blk_plug *plug;
	struct reclaim_state *reclaim_state;
	struct io_context *io_context;
	struct capture_control *capture_control;
	long unsigned int ptrace_message;
	kernel_siginfo_t *last_siginfo;
	struct task_io_accounting ioac;
	u64 acct_rss_mem1;
	u64 acct_vm_mem1;
	u64 acct_timexpd;
	nodemask_t mems_allowed;
	seqcount_spinlock_t mems_allowed_seq;
	int cpuset_mem_spread_rotor;
	struct css_set *cgroups;
	struct list_head cg_list;
	struct robust_list_head *robust_list;
	struct compat_robust_list_head *compat_robust_list;
	struct list_head pi_state_list;
	struct futex_pi_state *pi_state_cache;
	struct mutex futex_exit_mutex;
	unsigned int futex_state;
	u8 perf_recursion[4];
	struct perf_event_context *perf_event_ctxp;
	struct mutex perf_event_mutex;
	struct list_head perf_event_list;
	struct mempolicy *mempolicy;
	short int il_prev;
	u8 il_weight;
	short int pref_node_fork;
	struct rseq *rseq;
	u32 rseq_len;
	u32 rseq_sig;
	long unsigned int rseq_event_mask;
	int mm_cid;
	int last_mm_cid;
	int migrate_from_cpu;
	int mm_cid_active;
	struct callback_head cid_work;
	struct tlbflush_unmap_batch tlb_ubc;
	struct pipe_inode_info *splice_pipe;
	struct page_frag task_frag;
	struct task_delay_info *delays;
	int nr_dirtied;
	int nr_dirtied_pause;
	long unsigned int dirty_paused_when;
	u64 timer_slack_ns;
	u64 default_timer_slack_ns;
	long unsigned int trace_recursion;
	struct gendisk *throttle_disk;
	struct uprobe_task *utask;
	struct kmap_ctrl kmap_ctrl;
	struct callback_head rcu;
	refcount_t rcu_users;
	int pagefault_disabled;
	struct task_struct *oom_reaper_list;
	struct timer_list oom_reaper_timer;
	struct vm_struct *stack_vm_area;
	refcount_t stack_refcount;
	void *security;
	struct bpf_local_storage *bpf_storage;
	struct bpf_run_ctx *bpf_ctx;
	struct bpf_net_context *bpf_net_context;
	void *mce_vaddr;
	__u64 mce_kflags;
	u64 mce_addr;
	__u64 mce_ripv: 1;
	__u64 mce_whole_page: 1;
	__u64 __mce_reserved: 62;
	struct callback_head mce_kill_me;
	int mce_count;
	struct llist_head kretprobe_instances;
	struct llist_head rethooks;
	struct callback_head l1d_flush_kill;
	long: 64;
	long: 64;
	long: 64;
	struct thread_struct thread;
};

struct task_struct__safe_rcu {
	const cpumask_t *cpus_ptr;
	struct css_set *cgroups;
	struct task_struct *real_parent;
	struct task_struct *group_leader;
};

struct tasklet_head {
	struct tasklet_struct *head;
	struct tasklet_struct **tail;
};

struct taskstats {
	__u16 version;
	__u32 ac_exitcode;
	__u8 ac_flag;
	__u8 ac_nice;
	__u64 cpu_count;
	__u64 cpu_delay_total;
	__u64 cpu_delay_max;
	__u64 cpu_delay_min;
	__u64 blkio_count;
	__u64 blkio_delay_total;
	__u64 blkio_delay_max;
	__u64 blkio_delay_min;
	__u64 swapin_count;
	__u64 swapin_delay_total;
	__u64 swapin_delay_max;
	__u64 swapin_delay_min;
	__u64 cpu_run_real_total;
	__u64 cpu_run_virtual_total;
	char ac_comm[32];
	__u8 ac_sched;
	__u8 ac_pad[3];
	long: 0;
	__u32 ac_uid;
	__u32 ac_gid;
	__u32 ac_pid;
	__u32 ac_ppid;
	__u32 ac_btime;
	__u64 ac_etime;
	__u64 ac_utime;
	__u64 ac_stime;
	__u64 ac_minflt;
	__u64 ac_majflt;
	__u64 coremem;
	__u64 virtmem;
	__u64 hiwater_rss;
	__u64 hiwater_vm;
	__u64 read_char;
	__u64 write_char;
	__u64 read_syscalls;
	__u64 write_syscalls;
	__u64 read_bytes;
	__u64 write_bytes;
	__u64 cancelled_write_bytes;
	__u64 nvcsw;
	__u64 nivcsw;
	__u64 ac_utimescaled;
	__u64 ac_stimescaled;
	__u64 cpu_scaled_run_real_total;
	__u64 freepages_count;
	__u64 freepages_delay_total;
	__u64 freepages_delay_max;
	__u64 freepages_delay_min;
	__u64 thrashing_count;
	__u64 thrashing_delay_total;
	__u64 thrashing_delay_max;
	__u64 thrashing_delay_min;
	__u64 ac_btime64;
	__u64 compact_count;
	__u64 compact_delay_total;
	__u64 compact_delay_max;
	__u64 compact_delay_min;
	__u32 ac_tgid;
	__u64 ac_tgetime;
	__u64 ac_exe_dev;
	__u64 ac_exe_inode;
	__u64 wpcopy_count;
	__u64 wpcopy_delay_total;
	__u64 wpcopy_delay_max;
	__u64 wpcopy_delay_min;
	__u64 irq_count;
	__u64 irq_delay_total;
	__u64 irq_delay_max;
	__u64 irq_delay_min;
};

struct tbtt_info_iter_data {
	const struct ieee80211_neighbor_ap_info *ap_info;
	u8 param_ch_count;
	u32 use_for;
	u8 mld_id;
	u8 link_id;
	bool non_tx;
};

struct tc_act_pernet_id {
	struct list_head list;
	unsigned int id;
};

struct tcf_t {
	__u64 install;
	__u64 lastuse;
	__u64 expires;
	__u64 firstuse;
};

struct tc_action_ops;

struct tcf_idrinfo;

struct tc_cookie;

struct tcf_chain;

struct tc_action {
	const struct tc_action_ops *ops;
	__u32 type;
	struct tcf_idrinfo *idrinfo;
	u32 tcfa_index;
	refcount_t tcfa_refcnt;
	atomic_t tcfa_bindcnt;
	int tcfa_action;
	struct tcf_t tcfa_tm;
	long: 64;
	struct gnet_stats_basic_sync tcfa_bstats;
	struct gnet_stats_basic_sync tcfa_bstats_hw;
	struct gnet_stats_queue tcfa_qstats;
	struct net_rate_estimator *tcfa_rate_est;
	spinlock_t tcfa_lock;
	struct gnet_stats_basic_sync *cpu_bstats;
	struct gnet_stats_basic_sync *cpu_bstats_hw;
	struct gnet_stats_queue *cpu_qstats;
	struct tc_cookie *user_cookie;
	struct tcf_chain *goto_chain;
	u32 tcfa_flags;
	u8 hw_stats;
	u8 used_hw_stats;
	bool used_hw_stats_valid;
	u32 in_hw_count;
};

struct tc_action_net {
	struct tcf_idrinfo *idrinfo;
	const struct tc_action_ops *ops;
};

typedef void (*tc_action_priv_destructor)(void *);

struct tcf_result;

struct tc_action_ops {
	struct list_head head;
	char kind[16];
	enum tca_id id;
	unsigned int net_id;
	size_t size;
	struct module *owner;
	int (*act)(struct sk_buff *, const struct tc_action *, struct tcf_result *);
	int (*dump)(struct sk_buff *, struct tc_action *, int, int);
	void (*cleanup)(struct tc_action *);
	int (*lookup)(struct net *, struct tc_action **, u32);
	int (*init)(struct net *, struct nlattr *, struct nlattr *, struct tc_action **, struct tcf_proto *, u32, struct netlink_ext_ack *);
	int (*walk)(struct net *, struct sk_buff *, struct netlink_callback *, int, const struct tc_action_ops *, struct netlink_ext_ack *);
	void (*stats_update)(struct tc_action *, u64, u64, u64, u64, bool);
	size_t (*get_fill_size)(const struct tc_action *);
	struct net_device * (*get_dev)(const struct tc_action *, tc_action_priv_destructor *);
	struct psample_group * (*get_psample_group)(const struct tc_action *, tc_action_priv_destructor *);
	int (*offload_act_setup)(struct tc_action *, void *, u32 *, bool, struct netlink_ext_ack *);
};

struct tc_bind_class_args {
	struct qdisc_walker w;
	long unsigned int new_cl;
	u32 portid;
	u32 clid;
};

struct tc_cookie {
	u8 *data;
	u32 len;
	struct callback_head rcu;
};

struct tc_fifo_qopt {
	__u32 limit;
};

struct tc_qopt_offload_stats {
	struct gnet_stats_basic_sync *bstats;
	struct gnet_stats_queue *qstats;
};

struct tc_fifo_qopt_offload {
	enum tc_fifo_command command;
	u32 handle;
	u32 parent;
	union {
		struct tc_qopt_offload_stats stats;
	};
};

struct tc_mq_opt_offload_graft_params {
	long unsigned int queue;
	u32 child_handle;
};

struct tc_mq_qopt_offload {
	enum tc_mq_command command;
	u32 handle;
	union {
		struct tc_qopt_offload_stats stats;
		struct tc_mq_opt_offload_graft_params graft_params;
	};
};

struct tc_pedit_key {
	__u32 mask;
	__u32 val;
	__u32 off;
	__u32 at;
	__u32 offmask;
	__u32 shift;
};

struct tc_prio_qopt {
	int bands;
	__u8 priomap[16];
};

struct tc_query_caps_base {
	enum tc_setup_type type;
	void *caps;
};

struct tc_root_qopt_offload {
	enum tc_root_command command;
	u32 handle;
	bool ingress;
};

struct tc_skb_cb {
	struct qdisc_skb_cb qdisc_cb;
	u32 drop_reason;
	u16 zone;
	u16 mru;
	u8 post_ct: 1;
	u8 post_ct_snat: 1;
	u8 post_ct_dnat: 1;
};

struct tcamsg {
	unsigned char tca_family;
	unsigned char tca__pad1;
	short unsigned int tca__pad2;
};

struct tcf_walker {
	int stop;
	int skip;
	int count;
	bool nonempty;
	long unsigned int cookie;
	int (*fn)(struct tcf_proto *, void *, struct tcf_walker *);
};

struct tcf_bind_args {
	struct tcf_walker w;
	long unsigned int base;
	long unsigned int cl;
	u32 classid;
};

struct tcf_block {
	struct xarray ports;
	struct mutex lock;
	struct list_head chain_list;
	u32 index;
	u32 classid;
	refcount_t refcnt;
	struct net *net;
	struct Qdisc *q;
	struct rw_semaphore cb_lock;
	struct flow_block flow_block;
	struct list_head owner_list;
	bool keep_dst;
	atomic_t useswcnt;
	atomic_t offloadcnt;
	unsigned int nooffloaddevcnt;
	unsigned int lockeddevcnt;
	struct {
		struct tcf_chain *chain;
		struct list_head filter_chain_list;
	} chain0;
	struct callback_head rcu;
	struct hlist_head proto_destroy_ht[128];
	struct mutex proto_destroy_lock;
};

typedef void tcf_chain_head_change_t(struct tcf_proto *, void *);

struct tcf_block_ext_info {
	enum flow_block_binder_type binder_type;
	tcf_chain_head_change_t *chain_head_change;
	void *chain_head_change_priv;
	u32 block_index;
};

struct tcf_block_owner_item {
	struct list_head list;
	struct Qdisc *q;
	enum flow_block_binder_type binder_type;
};

struct tcf_proto_ops;

struct tcf_chain {
	struct mutex filter_chain_lock;
	struct tcf_proto *filter_chain;
	struct list_head list;
	struct tcf_block *block;
	u32 index;
	unsigned int refcnt;
	unsigned int action_refcnt;
	bool explicitly_created;
	bool flushing;
	const struct tcf_proto_ops *tmplt_ops;
	void *tmplt_priv;
	struct callback_head rcu;
};

struct tcf_chain_info {
	struct tcf_proto **pprev;
	struct tcf_proto *next;
};

struct tcf_dump_args {
	struct tcf_walker w;
	struct sk_buff *skb;
	struct netlink_callback *cb;
	struct tcf_block *block;
	struct Qdisc *q;
	u32 parent;
	bool terse_dump;
};

struct tcf_ematch_ops;

struct tcf_ematch {
	struct tcf_ematch_ops *ops;
	long unsigned int data;
	unsigned int datalen;
	u16 matchid;
	u16 flags;
	struct net *net;
};

struct tcf_ematch_hdr {
	__u16 matchid;
	__u16 kind;
	__u16 flags;
	__u16 pad;
};

struct tcf_pkt_info;

struct tcf_ematch_ops {
	int kind;
	int datalen;
	int (*change)(struct net *, void *, int, struct tcf_ematch *);
	int (*match)(struct sk_buff *, struct tcf_ematch *, struct tcf_pkt_info *);
	void (*destroy)(struct tcf_ematch *);
	int (*dump)(struct sk_buff *, struct tcf_ematch *);
	struct module *owner;
	struct list_head link;
};

union tcf_exts_miss_cookie {
	struct {
		u32 miss_cookie_base;
		u32 act_index;
	};
	u64 miss_cookie;
};

struct tcf_exts_miss_cookie_node {
	const struct tcf_chain *chain;
	const struct tcf_proto *tp;
	const struct tcf_exts *exts;
	u32 chain_index;
	u32 tp_prio;
	u32 handle;
	u32 miss_cookie_base;
	struct callback_head rcu;
};

struct tcf_filter_chain_list_item {
	struct list_head list;
	tcf_chain_head_change_t *chain_head_change;
	void *chain_head_change_priv;
};

struct tcf_idrinfo {
	struct mutex lock;
	struct idr action_idr;
	struct net *net;
};

struct tcf_net {
	spinlock_t idr_lock;
	struct idr idr;
};

struct tcf_pedit_parms;

struct tcf_pedit {
	struct tc_action common;
	struct tcf_pedit_parms *parms;
	long: 64;
};

struct tcf_pedit_key_ex {
	enum pedit_header_type htype;
	enum pedit_cmd cmd;
};

struct tcf_pedit_parms {
	struct tc_pedit_key *tcfp_keys;
	struct tcf_pedit_key_ex *tcfp_keys_ex;
	u32 tcfp_off_max_hint;
	unsigned char tcfp_nkeys;
	unsigned char tcfp_flags;
	struct callback_head rcu;
};

struct tcf_pkt_info {
	unsigned char *ptr;
	int nexthdr;
};

struct tcf_proto {
	struct tcf_proto *next;
	void *root;
	int (*classify)(struct sk_buff *, const struct tcf_proto *, struct tcf_result *);
	__be16 protocol;
	u32 prio;
	void *data;
	const struct tcf_proto_ops *ops;
	struct tcf_chain *chain;
	spinlock_t lock;
	bool deleting;
	bool counted;
	bool usesw;
	refcount_t refcnt;
	struct callback_head rcu;
	struct hlist_node destroy_ht_node;
};

struct tcf_proto_ops {
	struct list_head head;
	char kind[16];
	int (*classify)(struct sk_buff *, const struct tcf_proto *, struct tcf_result *);
	int (*init)(struct tcf_proto *);
	void (*destroy)(struct tcf_proto *, bool, struct netlink_ext_ack *);
	void * (*get)(struct tcf_proto *, u32);
	void (*put)(struct tcf_proto *, void *);
	int (*change)(struct net *, struct sk_buff *, struct tcf_proto *, long unsigned int, u32, struct nlattr **, void **, u32, struct netlink_ext_ack *);
	int (*delete)(struct tcf_proto *, void *, bool *, bool, struct netlink_ext_ack *);
	bool (*delete_empty)(struct tcf_proto *);
	void (*walk)(struct tcf_proto *, struct tcf_walker *, bool);
	int (*reoffload)(struct tcf_proto *, bool, flow_setup_cb_t *, void *, struct netlink_ext_ack *);
	void (*hw_add)(struct tcf_proto *, void *);
	void (*hw_del)(struct tcf_proto *, void *);
	void (*bind_class)(void *, u32, long unsigned int, void *, long unsigned int);
	void * (*tmplt_create)(struct net *, struct tcf_chain *, struct nlattr **, struct netlink_ext_ack *);
	void (*tmplt_destroy)(void *);
	void (*tmplt_reoffload)(struct tcf_chain *, bool, flow_setup_cb_t *, void *);
	struct tcf_exts * (*get_exts)(const struct tcf_proto *, u32);
	int (*dump)(struct net *, struct tcf_proto *, void *, struct sk_buff *, struct tcmsg *, bool);
	int (*terse_dump)(struct net *, struct tcf_proto *, void *, struct sk_buff *, struct tcmsg *, bool);
	int (*tmplt_dump)(struct sk_buff *, struct net *, void *);
	struct module *owner;
	int flags;
};

struct tcf_qevent {
	struct tcf_block *block;
	struct tcf_block_ext_info info;
	struct tcf_proto *filter_chain;
};

struct tcf_result {
	union {
		struct {
			long unsigned int class;
			u32 classid;
		};
		const struct tcf_proto *goto_tp;
	};
};

struct tcg_efi_specid_event_algs {
	u16 alg_id;
	u16 digest_size;
};

struct tcg_efi_specid_event_head {
	u8 signature[16];
	u32 platform_class;
	u8 spec_version_minor;
	u8 spec_version_major;
	u8 spec_errata;
	u8 uintnsize;
	u32 num_algs;
	struct tcg_efi_specid_event_algs digest_sizes[0];
};

struct tcg_event_field {
	u32 event_size;
	u8 event[0];
};

struct tcg_pcr_event {
	u32 pcr_idx;
	u32 event_type;
	u8 digest[20];
	u32 event_size;
	u8 event[0];
};

struct tpm_digest {
	u16 alg_id;
	u8 digest[64];
};

struct tcg_pcr_event2_head {
	u32 pcr_idx;
	u32 event_type;
	u32 count;
	struct tpm_digest digests[0];
};

struct tcmsg {
	unsigned char tcm_family;
	unsigned char tcm__pad1;
	short unsigned int tcm__pad2;
	int tcm_ifindex;
	__u32 tcm_handle;
	__u32 tcm_parent;
	__u32 tcm_info;
};

struct tcp4_pseudohdr {
	__be32 saddr;
	__be32 daddr;
	__u8 pad;
	__u8 protocol;
	__be16 len;
};

struct tcp6_pseudohdr {
	struct in6_addr saddr;
	struct in6_addr daddr;
	__be32 len;
	__be32 protocol;
};

struct tcp_options_received {
	int ts_recent_stamp;
	u32 ts_recent;
	u32 rcv_tsval;
	u32 rcv_tsecr;
	u16 saw_tstamp: 1;
	u16 tstamp_ok: 1;
	u16 dsack: 1;
	u16 wscale_ok: 1;
	u16 sack_ok: 3;
	u16 smc_ok: 1;
	u16 snd_wscale: 4;
	u16 rcv_wscale: 4;
	u8 saw_unknown: 1;
	u8 unused: 7;
	u8 num_sacks;
	u16 user_mss;
	u16 mss_clamp;
};

struct tcp_rack {
	u64 mstamp;
	u32 rtt_us;
	u32 end_seq;
	u32 last_delivered;
	u8 reo_wnd_steps;
	u8 reo_wnd_persist: 5;
	u8 dsack_seen: 1;
	u8 advanced: 1;
};

struct tcp_sack_block {
	u32 start_seq;
	u32 end_seq;
};

struct tcp_sock_af_ops;

struct tcp_md5sig_info;

struct tcp_fastopen_request;

struct tcp_sock {
	struct inet_connection_sock inet_conn;
	__u8 __cacheline_group_begin__tcp_sock_read_tx[0];
	u32 max_window;
	u32 rcv_ssthresh;
	u32 reordering;
	u32 notsent_lowat;
	u16 gso_segs;
	struct sk_buff *lost_skb_hint;
	struct sk_buff *retransmit_skb_hint;
	__u8 __cacheline_group_end__tcp_sock_read_tx[0];
	__u8 __cacheline_group_begin__tcp_sock_read_txrx[0];
	u32 tsoffset;
	u32 snd_wnd;
	u32 mss_cache;
	u32 snd_cwnd;
	u32 prr_out;
	u32 lost_out;
	u32 sacked_out;
	u16 tcp_header_len;
	u8 scaling_ratio;
	u8 chrono_type: 2;
	u8 repair: 1;
	u8 tcp_usec_ts: 1;
	u8 is_sack_reneg: 1;
	u8 is_cwnd_limited: 1;
	__u8 __cacheline_group_end__tcp_sock_read_txrx[0];
	__u8 __cacheline_group_begin__tcp_sock_read_rx[0];
	u32 copied_seq;
	u32 rcv_tstamp;
	u32 snd_wl1;
	u32 tlp_high_seq;
	u32 rttvar_us;
	u32 retrans_out;
	u16 advmss;
	u16 urg_data;
	u32 lost;
	struct minmax rtt_min;
	struct rb_root out_of_order_queue;
	u32 snd_ssthresh;
	u8 recvmsg_inq: 1;
	__u8 __cacheline_group_end__tcp_sock_read_rx[0];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	__u8 __cacheline_group_begin__tcp_sock_write_tx[0];
	u32 segs_out;
	u32 data_segs_out;
	u64 bytes_sent;
	u32 snd_sml;
	u32 chrono_start;
	u32 chrono_stat[3];
	u32 write_seq;
	u32 pushed_seq;
	u32 lsndtime;
	u32 mdev_us;
	u32 rtt_seq;
	u64 tcp_wstamp_ns;
	struct list_head tsorted_sent_queue;
	struct sk_buff *highest_sack;
	u8 ecn_flags;
	__u8 __cacheline_group_end__tcp_sock_write_tx[0];
	__u8 __cacheline_group_begin__tcp_sock_write_txrx[0];
	__be32 pred_flags;
	u64 tcp_clock_cache;
	u64 tcp_mstamp;
	u32 rcv_nxt;
	u32 snd_nxt;
	u32 snd_una;
	u32 window_clamp;
	u32 srtt_us;
	u32 packets_out;
	u32 snd_up;
	u32 delivered;
	u32 delivered_ce;
	u32 app_limited;
	u32 rcv_wnd;
	struct tcp_options_received rx_opt;
	u8 nonagle: 4;
	u8 rate_app_limited: 1;
	__u8 __cacheline_group_end__tcp_sock_write_txrx[0];
	long: 0;
	__u8 __cacheline_group_begin__tcp_sock_write_rx[0];
	u64 bytes_received;
	u32 segs_in;
	u32 data_segs_in;
	u32 rcv_wup;
	u32 max_packets_out;
	u32 cwnd_usage_seq;
	u32 rate_delivered;
	u32 rate_interval_us;
	u32 rcv_rtt_last_tsecr;
	u64 first_tx_mstamp;
	u64 delivered_mstamp;
	u64 bytes_acked;
	struct {
		u32 rtt_us;
		u32 seq;
		u64 time;
	} rcv_rtt_est;
	struct {
		u32 space;
		u32 seq;
		u64 time;
	} rcvq_space;
	__u8 __cacheline_group_end__tcp_sock_write_rx[0];
	u32 dsack_dups;
	u32 compressed_ack_rcv_nxt;
	struct list_head tsq_node;
	struct tcp_rack rack;
	u8 compressed_ack;
	u8 dup_ack_counter: 2;
	u8 tlp_retrans: 1;
	u8 unused: 5;
	u8 thin_lto: 1;
	u8 fastopen_connect: 1;
	u8 fastopen_no_cookie: 1;
	u8 fastopen_client_fail: 2;
	u8 frto: 1;
	u8 repair_queue;
	u8 save_syn: 2;
	u8 syn_data: 1;
	u8 syn_fastopen: 1;
	u8 syn_fastopen_exp: 1;
	u8 syn_fastopen_ch: 1;
	u8 syn_data_acked: 1;
	u8 keepalive_probes;
	u32 tcp_tx_delay;
	u32 mdev_max_us;
	u32 reord_seen;
	u32 snd_cwnd_cnt;
	u32 snd_cwnd_clamp;
	u32 snd_cwnd_used;
	u32 snd_cwnd_stamp;
	u32 prior_cwnd;
	u32 prr_delivered;
	u32 last_oow_ack_time;
	struct hrtimer pacing_timer;
	struct hrtimer compressed_ack_timer;
	struct sk_buff *ooo_last_skb;
	struct tcp_sack_block duplicate_sack[1];
	struct tcp_sack_block selective_acks[4];
	struct tcp_sack_block recv_sack_cache[4];
	int lost_cnt_hint;
	u32 prior_ssthresh;
	u32 high_seq;
	u32 retrans_stamp;
	u32 undo_marker;
	int undo_retrans;
	u64 bytes_retrans;
	u32 total_retrans;
	u32 rto_stamp;
	u16 total_rto;
	u16 total_rto_recoveries;
	u32 total_rto_time;
	u32 urg_seq;
	unsigned int keepalive_time;
	unsigned int keepalive_intvl;
	int linger2;
	u8 bpf_sock_ops_cb_flags;
	u8 bpf_chg_cc_inprogress: 1;
	u16 timeout_rehash;
	u32 rcv_ooopack;
	struct {
		u32 probe_seq_start;
		u32 probe_seq_end;
	} mtu_probe;
	u32 plb_rehash;
	u32 mtu_info;
	const struct tcp_sock_af_ops *af_specific;
	struct tcp_md5sig_info *md5sig_info;
	struct tcp_fastopen_request *fastopen_req;
	struct request_sock *fastopen_rsk;
	struct saved_syn *saved_syn;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct tcp6_sock {
	struct tcp_sock tcp;
	struct ipv6_pinfo inet6;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

union tcp_ao_addr {
	struct in_addr a4;
	struct in6_addr a6;
};

struct tcp_ao_hdr {
	u8 kind;
	u8 length;
	u8 keyid;
	u8 rnext_keyid;
};

struct tcp_ao_key {
	struct hlist_node node;
	union tcp_ao_addr addr;
	u8 key[80];
	unsigned int tcp_sigpool_id;
	unsigned int digest_size;
	int l3index;
	u8 prefixlen;
	u8 family;
	u8 keylen;
	u8 keyflags;
	u8 sndid;
	u8 rcvid;
	u8 maclen;
	struct callback_head rcu;
	atomic64_t pkt_good;
	atomic64_t pkt_bad;
	u8 traffic_keys[0];
};

struct tcp_bbr_info {
	__u32 bbr_bw_lo;
	__u32 bbr_bw_hi;
	__u32 bbr_min_rtt;
	__u32 bbr_pacing_gain;
	__u32 bbr_cwnd_gain;
};

struct tcpvegas_info {
	__u32 tcpv_enabled;
	__u32 tcpv_rttcnt;
	__u32 tcpv_rtt;
	__u32 tcpv_minrtt;
};

struct tcp_dctcp_info {
	__u16 dctcp_enabled;
	__u16 dctcp_ce_state;
	__u32 dctcp_alpha;
	__u32 dctcp_ab_ecn;
	__u32 dctcp_ab_tot;
};

union tcp_cc_info {
	struct tcpvegas_info vegas;
	struct tcp_dctcp_info dctcp;
	struct tcp_bbr_info bbr;
};

struct tcp_congestion_ops {
	u32 (*ssthresh)(struct sock *);
	void (*cong_avoid)(struct sock *, u32, u32);
	void (*set_state)(struct sock *, u8);
	void (*cwnd_event)(struct sock *, enum tcp_ca_event);
	void (*in_ack_event)(struct sock *, u32);
	void (*pkts_acked)(struct sock *, const struct ack_sample *);
	u32 (*min_tso_segs)(struct sock *);
	void (*cong_control)(struct sock *, u32, int, const struct rate_sample *);
	u32 (*undo_cwnd)(struct sock *);
	u32 (*sndbuf_expand)(struct sock *);
	size_t (*get_info)(struct sock *, u32, int *, union tcp_cc_info *);
	char name[16];
	struct module *owner;
	struct list_head list;
	u32 key;
	u32 flags;
	void (*init)(struct sock *);
	void (*release)(struct sock *);
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct tcp_fastopen_context {
	siphash_key_t key[2];
	int num;
	struct callback_head rcu;
};

struct tcp_fastopen_cookie {
	__le64 val[2];
	s8 len;
	bool exp;
};

struct tcp_fastopen_metrics {
	u16 mss;
	u16 syn_loss: 10;
	u16 try_exp: 2;
	long unsigned int last_syn_loss;
	struct tcp_fastopen_cookie cookie;
};

struct tcp_fastopen_request {
	struct tcp_fastopen_cookie cookie;
	struct msghdr *data;
	size_t size;
	int copied;
	struct ubuf_info *uarg;
};

struct tcp_info {
	__u8 tcpi_state;
	__u8 tcpi_ca_state;
	__u8 tcpi_retransmits;
	__u8 tcpi_probes;
	__u8 tcpi_backoff;
	__u8 tcpi_options;
	__u8 tcpi_snd_wscale: 4;
	__u8 tcpi_rcv_wscale: 4;
	__u8 tcpi_delivery_rate_app_limited: 1;
	__u8 tcpi_fastopen_client_fail: 2;
	__u32 tcpi_rto;
	__u32 tcpi_ato;
	__u32 tcpi_snd_mss;
	__u32 tcpi_rcv_mss;
	__u32 tcpi_unacked;
	__u32 tcpi_sacked;
	__u32 tcpi_lost;
	__u32 tcpi_retrans;
	__u32 tcpi_fackets;
	__u32 tcpi_last_data_sent;
	__u32 tcpi_last_ack_sent;
	__u32 tcpi_last_data_recv;
	__u32 tcpi_last_ack_recv;
	__u32 tcpi_pmtu;
	__u32 tcpi_rcv_ssthresh;
	__u32 tcpi_rtt;
	__u32 tcpi_rttvar;
	__u32 tcpi_snd_ssthresh;
	__u32 tcpi_snd_cwnd;
	__u32 tcpi_advmss;
	__u32 tcpi_reordering;
	__u32 tcpi_rcv_rtt;
	__u32 tcpi_rcv_space;
	__u32 tcpi_total_retrans;
	__u64 tcpi_pacing_rate;
	__u64 tcpi_max_pacing_rate;
	__u64 tcpi_bytes_acked;
	__u64 tcpi_bytes_received;
	__u32 tcpi_segs_out;
	__u32 tcpi_segs_in;
	__u32 tcpi_notsent_bytes;
	__u32 tcpi_min_rtt;
	__u32 tcpi_data_segs_in;
	__u32 tcpi_data_segs_out;
	__u64 tcpi_delivery_rate;
	__u64 tcpi_busy_time;
	__u64 tcpi_rwnd_limited;
	__u64 tcpi_sndbuf_limited;
	__u32 tcpi_delivered;
	__u32 tcpi_delivered_ce;
	__u64 tcpi_bytes_sent;
	__u64 tcpi_bytes_retrans;
	__u32 tcpi_dsack_dups;
	__u32 tcpi_reord_seen;
	__u32 tcpi_rcv_ooopack;
	__u32 tcpi_snd_wnd;
	__u32 tcpi_rcv_wnd;
	__u32 tcpi_rehash;
	__u16 tcpi_total_rto;
	__u16 tcpi_total_rto_recoveries;
	__u32 tcpi_total_rto_time;
};

struct tcp_md5sig_key;

struct tcp_key {
	union {
		struct {
			struct tcp_ao_key *ao_key;
			char *traffic_key;
			u32 sne;
			u8 rcv_next;
		};
		struct tcp_md5sig_key *md5_key;
	};
	enum {
		TCP_KEY_NONE = 0,
		TCP_KEY_MD5 = 1,
		TCP_KEY_AO = 2,
	} type;
};

struct tcp_md5sig {
	struct __kernel_sockaddr_storage tcpm_addr;
	__u8 tcpm_flags;
	__u8 tcpm_prefixlen;
	__u16 tcpm_keylen;
	int tcpm_ifindex;
	__u8 tcpm_key[80];
};

struct tcp_md5sig_info {
	struct hlist_head head;
	struct callback_head rcu;
};

struct tcp_md5sig_key {
	struct hlist_node node;
	u8 keylen;
	u8 family;
	u8 prefixlen;
	u8 flags;
	union tcp_ao_addr addr;
	int l3index;
	u8 key[80];
	struct callback_head rcu;
};

struct tcp_metrics_block {
	struct tcp_metrics_block *tcpm_next;
	struct net *tcpm_net;
	struct inetpeer_addr tcpm_saddr;
	struct inetpeer_addr tcpm_daddr;
	long unsigned int tcpm_stamp;
	u32 tcpm_lock;
	u32 tcpm_vals[5];
	struct tcp_fastopen_metrics tcpm_fastopen;
	struct callback_head callback_head;
};

struct tcp_mib {
	long unsigned int mibs[16];
};

struct tcp_out_options {
	u16 options;
	u16 mss;
	u8 ws;
	u8 num_sack_blocks;
	u8 hash_size;
	u8 bpf_opt_len;
	__u8 *hash_location;
	__u32 tsval;
	__u32 tsecr;
	struct tcp_fastopen_cookie *fastopen_cookie;
	struct mptcp_out_options mptcp;
};

struct tcp_plb_state {
	u8 consec_cong_rounds: 5;
	u8 unused: 3;
	u32 pause_until;
};

struct tcp_repair_opt {
	__u32 opt_code;
	__u32 opt_val;
};

struct tcp_repair_window {
	__u32 snd_wl1;
	__u32 snd_wnd;
	__u32 max_window;
	__u32 rcv_wnd;
	__u32 rcv_wup;
};

struct tcp_request_sock_ops;

struct tcp_request_sock {
	struct inet_request_sock req;
	const struct tcp_request_sock_ops *af_specific;
	u64 snt_synack;
	bool tfo_listener;
	bool is_mptcp;
	bool req_usec_ts;
	u32 txhash;
	u32 rcv_isn;
	u32 snt_isn;
	u32 ts_off;
	u32 last_oow_ack_time;
	u32 rcv_nxt;
	u8 syn_tos;
};

struct tcp_request_sock_ops {
	u16 mss_clamp;
	struct tcp_md5sig_key * (*req_md5_lookup)(const struct sock *, const struct sock *);
	int (*calc_md5_hash)(char *, const struct tcp_md5sig_key *, const struct sock *, const struct sk_buff *);
	__u32 (*cookie_init_seq)(const struct sk_buff *, __u16 *);
	struct dst_entry * (*route_req)(const struct sock *, struct sk_buff *, struct flowi *, struct request_sock *, u32);
	u32 (*init_seq)(const struct sk_buff *);
	u32 (*init_ts_off)(const struct net *, const struct sk_buff *);
	int (*send_synack)(const struct sock *, struct dst_entry *, struct flowi *, struct request_sock *, struct tcp_fastopen_cookie *, enum tcp_synack_type, struct sk_buff *);
};

struct tcp_sack_block_wire {
	__be32 start_seq;
	__be32 end_seq;
};

struct tcp_sacktag_state {
	u64 first_sackt;
	u64 last_sackt;
	u32 reord;
	u32 sack_delivered;
	int flag;
	unsigned int mss_now;
	struct rate_sample *rate;
};

struct tcp_seq_afinfo {
	sa_family_t family;
};

struct tcp_sigpool {
	void *scratch;
	struct ahash_request *req;
};

struct tcp_skb_cb {
	__u32 seq;
	__u32 end_seq;
	union {
		struct {
			u16 tcp_gso_segs;
			u16 tcp_gso_size;
		};
	};
	__u8 tcp_flags;
	__u8 sacked;
	__u8 ip_dsfield;
	__u8 txstamp_ack: 1;
	__u8 eor: 1;
	__u8 has_rxtstamp: 1;
	__u8 unused: 5;
	__u32 ack_seq;
	union {
		struct {
			__u32 is_app_limited: 1;
			__u32 delivered_ce: 20;
			__u32 unused: 11;
			__u32 delivered;
			u64 first_tx_mstamp;
			u64 delivered_mstamp;
		} tx;
		union {
			struct inet_skb_parm h4;
			struct inet6_skb_parm h6;
		} header;
	};
};

struct tcp_sock_af_ops {
	struct tcp_md5sig_key * (*md5_lookup)(const struct sock *, const struct sock *);
	int (*calc_md5_hash)(char *, const struct tcp_md5sig_key *, const struct sock *, const struct sk_buff *);
	int (*md5_parse)(struct sock *, int, sockptr_t, int);
};

struct tcp_splice_state {
	struct pipe_inode_info *pipe;
	size_t len;
	unsigned int flags;
};

struct tcp_timewait_sock {
	struct inet_timewait_sock tw_sk;
	u32 tw_rcv_wnd;
	u32 tw_ts_offset;
	u32 tw_ts_recent;
	u32 tw_last_oow_ack_time;
	int tw_ts_recent_stamp;
	u32 tw_tx_delay;
	struct tcp_md5sig_key *tw_md5_key;
};

struct tcp_ulp_ops {
	struct list_head list;
	int (*init)(struct sock *);
	void (*update)(struct sock *, struct proto *, void (*)(struct sock *));
	void (*release)(struct sock *);
	int (*get_info)(struct sock *, struct sk_buff *);
	size_t (*get_info_size)(const struct sock *);
	void (*clone)(const struct request_sock *, struct sock *, const gfp_t);
	char name[16];
	struct module *owner;
};

struct tcphdr {
	__be16 source;
	__be16 dest;
	__be32 seq;
	__be32 ack_seq;
	__u16 res1: 4;
	__u16 doff: 4;
	__u16 fin: 1;
	__u16 syn: 1;
	__u16 rst: 1;
	__u16 psh: 1;
	__u16 ack: 1;
	__u16 urg: 1;
	__u16 ece: 1;
	__u16 cwr: 1;
	__be16 window;
	__sum16 check;
	__be16 urg_ptr;
};

union tcp_word_hdr {
	struct tcphdr hdr;
	__be32 words[5];
};

struct tcp_xa_pool {
	u8 max;
	u8 idx;
	__u32 tokens[17];
	netmem_ref netmems[17];
};

struct tcp_zerocopy_receive {
	__u64 address;
	__u32 length;
	__u32 recv_skip_hint;
	__u32 inq;
	__s32 err;
	__u64 copybuf_address;
	__s32 copybuf_len;
	__u32 flags;
	__u64 msg_control;
	__u64 msg_controllen;
	__u32 msg_flags;
	__u32 reserved;
};

struct tcpm_hash_bucket {
	struct tcp_metrics_block *chain;
};

struct tcx_entry {
	struct mini_Qdisc *miniq;
	struct bpf_mprog_bundle bundle;
	u32 miniq_active;
	struct callback_head rcu;
};

struct tcx_link {
	struct bpf_link link;
	struct net_device *dev;
	u32 location;
};

struct td {
	__hc32 hwINFO;
	__hc32 hwCBP;
	__hc32 hwNextTD;
	__hc32 hwBE;
	__hc16 hwPSW[2];
	__u8 index;
	struct ed *ed;
	struct td *td_hash;
	struct td *next_dl_td;
	struct urb *urb;
	dma_addr_t td_dma;
	dma_addr_t data_dma;
	struct list_head td_list;
	long: 64;
};

struct temp_masks {
	u32 tcc_offset;
	u32 digital_readout;
	u32 pkg_digital_readout;
};

struct temp_regset {
	struct guc_mmio_reg *registers;
	struct guc_mmio_reg *storage;
	u32 storage_used;
	u32 storage_max;
};

struct termio {
	short unsigned int c_iflag;
	short unsigned int c_oflag;
	short unsigned int c_cflag;
	short unsigned int c_lflag;
	unsigned char c_line;
	unsigned char c_cc[8];
};

struct termios {
	tcflag_t c_iflag;
	tcflag_t c_oflag;
	tcflag_t c_cflag;
	tcflag_t c_lflag;
	cc_t c_line;
	cc_t c_cc[19];
};

struct termios2 {
	tcflag_t c_iflag;
	tcflag_t c_oflag;
	tcflag_t c_cflag;
	tcflag_t c_lflag;
	cc_t c_line;
	cc_t c_cc[19];
	speed_t c_ispeed;
	speed_t c_ospeed;
};

union text_poke_insn {
	u8 text[5];
	struct {
		u8 opcode;
		s32 disp;
	} __attribute__((packed));
};

struct text_poke_loc {
	s32 rel_addr;
	s32 disp;
	u8 len;
	u8 opcode;
	const u8 text[5];
	u8 old;
};

struct tfp410_priv {
	bool quiet;
};

struct tg3_rx_buffer_desc;

struct tg3_ext_rx_buffer_desc;

struct tg3_rx_prodring_set {
	u32 rx_std_prod_idx;
	u32 rx_std_cons_idx;
	u32 rx_jmb_prod_idx;
	u32 rx_jmb_cons_idx;
	struct tg3_rx_buffer_desc *rx_std;
	struct tg3_ext_rx_buffer_desc *rx_jmb;
	struct ring_info___2 *rx_std_buffers;
	struct ring_info___2 *rx_jmb_buffers;
	dma_addr_t rx_std_mapping;
	dma_addr_t rx_jmb_mapping;
};

struct tg3;

struct tg3_hw_status;

struct tg3_tx_buffer_desc;

struct tg3_tx_ring_info;

struct tg3_napi {
	struct napi_struct napi;
	struct tg3 *tp;
	struct tg3_hw_status *hw_status;
	u32 chk_msi_cnt;
	u32 last_tag;
	u32 last_irq_tag;
	u32 int_mbox;
	u32 coal_now;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	u32 consmbox;
	u32 rx_rcb_ptr;
	u32 last_rx_cons;
	u16 *rx_rcb_prod_idx;
	struct tg3_rx_prodring_set prodring;
	struct tg3_rx_buffer_desc *rx_rcb;
	long unsigned int rx_dropped;
	long: 64;
	long: 64;
	long: 64;
	u32 tx_prod;
	u32 tx_cons;
	u32 tx_pending;
	u32 last_tx_cons;
	u32 prodmbox;
	struct tg3_tx_buffer_desc *tx_ring;
	struct tg3_tx_ring_info *tx_buffers;
	long unsigned int tx_dropped;
	dma_addr_t status_mapping;
	dma_addr_t rx_rcb_mapping;
	dma_addr_t tx_desc_mapping;
	char irq_lbl[32];
	unsigned int irq_vec;
	long: 64;
	long: 64;
};

struct tg3_ethtool_stats {
	u64 rx_octets;
	u64 rx_fragments;
	u64 rx_ucast_packets;
	u64 rx_mcast_packets;
	u64 rx_bcast_packets;
	u64 rx_fcs_errors;
	u64 rx_align_errors;
	u64 rx_xon_pause_rcvd;
	u64 rx_xoff_pause_rcvd;
	u64 rx_mac_ctrl_rcvd;
	u64 rx_xoff_entered;
	u64 rx_frame_too_long_errors;
	u64 rx_jabbers;
	u64 rx_undersize_packets;
	u64 rx_in_length_errors;
	u64 rx_out_length_errors;
	u64 rx_64_or_less_octet_packets;
	u64 rx_65_to_127_octet_packets;
	u64 rx_128_to_255_octet_packets;
	u64 rx_256_to_511_octet_packets;
	u64 rx_512_to_1023_octet_packets;
	u64 rx_1024_to_1522_octet_packets;
	u64 rx_1523_to_2047_octet_packets;
	u64 rx_2048_to_4095_octet_packets;
	u64 rx_4096_to_8191_octet_packets;
	u64 rx_8192_to_9022_octet_packets;
	u64 tx_octets;
	u64 tx_collisions;
	u64 tx_xon_sent;
	u64 tx_xoff_sent;
	u64 tx_flow_control;
	u64 tx_mac_errors;
	u64 tx_single_collisions;
	u64 tx_mult_collisions;
	u64 tx_deferred;
	u64 tx_excessive_collisions;
	u64 tx_late_collisions;
	u64 tx_collide_2times;
	u64 tx_collide_3times;
	u64 tx_collide_4times;
	u64 tx_collide_5times;
	u64 tx_collide_6times;
	u64 tx_collide_7times;
	u64 tx_collide_8times;
	u64 tx_collide_9times;
	u64 tx_collide_10times;
	u64 tx_collide_11times;
	u64 tx_collide_12times;
	u64 tx_collide_13times;
	u64 tx_collide_14times;
	u64 tx_collide_15times;
	u64 tx_ucast_packets;
	u64 tx_mcast_packets;
	u64 tx_bcast_packets;
	u64 tx_carrier_sense_errors;
	u64 tx_discards;
	u64 tx_errors;
	u64 dma_writeq_full;
	u64 dma_write_prioq_full;
	u64 rxbds_empty;
	u64 rx_discards;
	u64 rx_errors;
	u64 rx_threshold_hit;
	u64 dma_readq_full;
	u64 dma_read_prioq_full;
	u64 tx_comp_queue_full;
	u64 ring_set_send_prod_index;
	u64 ring_status_update;
	u64 nic_irqs;
	u64 nic_avoided_irqs;
	u64 nic_tx_threshold_hit;
	u64 mbuf_lwm_thresh_hit;
};

struct tg3_link_config {
	u32 advertising;
	u32 speed;
	u8 duplex;
	u8 autoneg;
	u8 flowctrl;
	u8 active_flowctrl;
	u8 active_duplex;
	u32 active_speed;
	u32 rmt_adv;
};

struct tg3_bufmgr_config {
	u32 mbuf_read_dma_low_water;
	u32 mbuf_mac_rx_low_water;
	u32 mbuf_high_water;
	u32 mbuf_read_dma_low_water_jumbo;
	u32 mbuf_mac_rx_low_water_jumbo;
	u32 mbuf_high_water_jumbo;
	u32 dma_low_water;
	u32 dma_high_water;
};

struct tg3_hw_stats;

struct tg3 {
	unsigned int irq_sync;
	spinlock_t lock;
	spinlock_t indirect_lock;
	u32 (*read32)(struct tg3 *, u32);
	void (*write32)(struct tg3 *, u32, u32);
	u32 (*read32_mbox)(struct tg3 *, u32);
	void (*write32_mbox)(struct tg3 *, u32, u32);
	void *regs;
	void *aperegs;
	struct net_device *dev;
	struct pci_dev *pdev;
	u32 coal_now;
	u32 msg_enable;
	struct ptp_clock_info ptp_info;
	struct ptp_clock *ptp_clock;
	s64 ptp_adjust;
	u8 ptp_txts_retrycnt;
	void (*write32_tx_mbox)(struct tg3 *, u32, u32);
	u32 dma_limit;
	u32 txq_req;
	u32 txq_cnt;
	u32 txq_max;
	struct tg3_napi napi[5];
	void (*write32_rx_mbox)(struct tg3 *, u32, u32);
	u32 rx_copy_thresh;
	u32 rx_std_ring_mask;
	u32 rx_jmb_ring_mask;
	u32 rx_ret_ring_mask;
	u32 rx_pending;
	u32 rx_jumbo_pending;
	u32 rx_std_max_post;
	u32 rx_offset;
	u32 rx_pkt_map_sz;
	u32 rxq_req;
	u32 rxq_cnt;
	u32 rxq_max;
	bool rx_refill;
	struct rtnl_link_stats64 net_stats_prev;
	struct tg3_ethtool_stats estats_prev;
	long unsigned int tg3_flags[2];
	union {
		long unsigned int phy_crc_errors;
		long unsigned int last_event_jiffies;
	};
	struct timer_list timer;
	u16 timer_counter;
	u16 timer_multiplier;
	u32 timer_offset;
	u16 asf_counter;
	u16 asf_multiplier;
	u32 serdes_counter;
	struct tg3_link_config link_config;
	struct tg3_bufmgr_config bufmgr_config;
	u32 rx_mode;
	u32 tx_mode;
	u32 mac_mode;
	u32 mi_mode;
	u32 misc_host_ctrl;
	u32 grc_mode;
	u32 grc_local_ctrl;
	u32 dma_rwctrl;
	u32 coalesce_mode;
	u32 pwrmgmt_thresh;
	u32 rxptpctl;
	u32 pci_chip_rev_id;
	u16 pci_cmd;
	u8 pci_cacheline_sz;
	u8 pci_lat_timer;
	int pci_fn;
	int msi_cap;
	int pcix_cap;
	int pcie_readrq;
	struct mii_bus *mdio_bus;
	int old_link;
	u8 phy_addr;
	u8 phy_ape_lock;
	u32 phy_id;
	u32 phy_flags;
	u32 led_ctrl;
	u32 phy_otp;
	u32 setlpicnt;
	u8 rss_ind_tbl[128];
	char board_part_number[24];
	char fw_ver[32];
	u32 nic_sram_data_cfg;
	u32 pci_clock_ctrl;
	struct pci_dev *pdev_peer;
	struct tg3_hw_stats *hw_stats;
	dma_addr_t stats_mapping;
	struct work_struct reset_task;
	struct sk_buff *tx_tstamp_skb;
	u64 pre_tx_ts;
	int nvram_lock_cnt;
	u32 nvram_size;
	u32 nvram_pagesize;
	u32 nvram_jedecnum;
	unsigned int irq_max;
	unsigned int irq_cnt;
	struct ethtool_coalesce coal;
	struct ethtool_keee eee;
	const char *fw_needed;
	const struct firmware *fw;
	u32 fw_len;
	struct device *hwmon_dev;
	bool link_up;
	bool pcierr_recovery;
	u32 ape_hb;
	long unsigned int ape_hb_interval;
	long unsigned int ape_hb_jiffies;
	long: 64;
	long: 64;
};

struct tg3_dev_id {
	u32 vendor;
	u32 device;
	u32 rev;
};

struct tg3_dev_id___2 {
	u32 vendor;
	u32 device;
};

struct tg3_rx_buffer_desc {
	u32 addr_hi;
	u32 addr_lo;
	u32 idx_len;
	u32 type_flags;
	u32 ip_tcp_csum;
	u32 err_vlan;
	u32 reserved;
	u32 opaque;
};

struct tg3_ext_rx_buffer_desc {
	struct {
		u32 addr_hi;
		u32 addr_lo;
	} addrlist[3];
	u32 len2_len1;
	u32 resv_len3;
	struct tg3_rx_buffer_desc std;
};

struct tg3_fiber_aneginfo {
	int state;
	u32 flags;
	long unsigned int link_time;
	long unsigned int cur_time;
	u32 ability_match_cfg;
	int ability_match_count;
	char ability_match;
	char idle_match;
	char ack_match;
	u32 txconfig;
	u32 rxconfig;
};

struct tg3_firmware_hdr {
	__be32 version;
	__be32 base_addr;
	__be32 len;
};

struct tg3_hw_stats {
	u8 __reserved0[256];
	tg3_stat64_t rx_octets;
	u64 __reserved1;
	tg3_stat64_t rx_fragments;
	tg3_stat64_t rx_ucast_packets;
	tg3_stat64_t rx_mcast_packets;
	tg3_stat64_t rx_bcast_packets;
	tg3_stat64_t rx_fcs_errors;
	tg3_stat64_t rx_align_errors;
	tg3_stat64_t rx_xon_pause_rcvd;
	tg3_stat64_t rx_xoff_pause_rcvd;
	tg3_stat64_t rx_mac_ctrl_rcvd;
	tg3_stat64_t rx_xoff_entered;
	tg3_stat64_t rx_frame_too_long_errors;
	tg3_stat64_t rx_jabbers;
	tg3_stat64_t rx_undersize_packets;
	tg3_stat64_t rx_in_length_errors;
	tg3_stat64_t rx_out_length_errors;
	tg3_stat64_t rx_64_or_less_octet_packets;
	tg3_stat64_t rx_65_to_127_octet_packets;
	tg3_stat64_t rx_128_to_255_octet_packets;
	tg3_stat64_t rx_256_to_511_octet_packets;
	tg3_stat64_t rx_512_to_1023_octet_packets;
	tg3_stat64_t rx_1024_to_1522_octet_packets;
	tg3_stat64_t rx_1523_to_2047_octet_packets;
	tg3_stat64_t rx_2048_to_4095_octet_packets;
	tg3_stat64_t rx_4096_to_8191_octet_packets;
	tg3_stat64_t rx_8192_to_9022_octet_packets;
	u64 __unused0[37];
	tg3_stat64_t tx_octets;
	u64 __reserved2;
	tg3_stat64_t tx_collisions;
	tg3_stat64_t tx_xon_sent;
	tg3_stat64_t tx_xoff_sent;
	tg3_stat64_t tx_flow_control;
	tg3_stat64_t tx_mac_errors;
	tg3_stat64_t tx_single_collisions;
	tg3_stat64_t tx_mult_collisions;
	tg3_stat64_t tx_deferred;
	u64 __reserved3;
	tg3_stat64_t tx_excessive_collisions;
	tg3_stat64_t tx_late_collisions;
	tg3_stat64_t tx_collide_2times;
	tg3_stat64_t tx_collide_3times;
	tg3_stat64_t tx_collide_4times;
	tg3_stat64_t tx_collide_5times;
	tg3_stat64_t tx_collide_6times;
	tg3_stat64_t tx_collide_7times;
	tg3_stat64_t tx_collide_8times;
	tg3_stat64_t tx_collide_9times;
	tg3_stat64_t tx_collide_10times;
	tg3_stat64_t tx_collide_11times;
	tg3_stat64_t tx_collide_12times;
	tg3_stat64_t tx_collide_13times;
	tg3_stat64_t tx_collide_14times;
	tg3_stat64_t tx_collide_15times;
	tg3_stat64_t tx_ucast_packets;
	tg3_stat64_t tx_mcast_packets;
	tg3_stat64_t tx_bcast_packets;
	tg3_stat64_t tx_carrier_sense_errors;
	tg3_stat64_t tx_discards;
	tg3_stat64_t tx_errors;
	u64 __unused1[31];
	tg3_stat64_t COS_rx_packets[16];
	tg3_stat64_t COS_rx_filter_dropped;
	tg3_stat64_t dma_writeq_full;
	tg3_stat64_t dma_write_prioq_full;
	tg3_stat64_t rxbds_empty;
	tg3_stat64_t rx_discards;
	tg3_stat64_t rx_errors;
	tg3_stat64_t rx_threshold_hit;
	u64 __unused2[9];
	tg3_stat64_t COS_out_packets[16];
	tg3_stat64_t dma_readq_full;
	tg3_stat64_t dma_read_prioq_full;
	tg3_stat64_t tx_comp_queue_full;
	tg3_stat64_t ring_set_send_prod_index;
	tg3_stat64_t ring_status_update;
	tg3_stat64_t nic_irqs;
	tg3_stat64_t nic_avoided_irqs;
	tg3_stat64_t nic_tx_threshold_hit;
	tg3_stat64_t mbuf_lwm_thresh_hit;
	u8 __reserved4[312];
};

struct tg3_hw_status {
	u32 status;
	u32 status_tag;
	u16 rx_jumbo_consumer;
	u16 rx_consumer;
	u16 rx_mini_consumer;
	u16 reserved;
	struct {
		u16 rx_producer;
		u16 tx_consumer;
	} idx[16];
};

struct tg3_internal_buffer_desc {
	u32 addr_hi;
	u32 addr_lo;
	u32 nic_mbuf;
	u16 len;
	u16 cqid_sqid;
	u32 flags;
	u32 __cookie1;
	u32 __cookie2;
	u32 __cookie3;
};

struct tg3_ocir {
	u32 signature;
	u16 version_flags;
	u16 refresh_int;
	u32 refresh_tmr;
	u32 update_tmr;
	u32 dst_base_addr;
	u16 src_hdr_offset;
	u16 src_hdr_length;
	u16 src_data_offset;
	u16 src_data_length;
	u16 dst_hdr_offset;
	u16 dst_data_offset;
	u16 dst_reg_upd_offset;
	u16 dst_sem_offset;
	u32 reserved1[2];
	u32 port0_flags;
	u32 port1_flags;
	u32 port2_flags;
	u32 port3_flags;
	u32 reserved2;
};

struct tg3_tx_buffer_desc {
	u32 addr_hi;
	u32 addr_lo;
	u32 len_flags;
	u32 vlan_tag;
};

struct tg3_tx_ring_info {
	struct sk_buff *skb;
	dma_addr_t mapping;
	bool fragmented;
};

struct tgid_iter {
	unsigned int tgid;
	struct task_struct *task;
};

struct thermal_attr {
	struct device_attribute attr;
	char name[20];
};

typedef struct thermal_cooling_device *class_cooling_dev_t;

struct thermal_cooling_device_ops;

struct thermal_cooling_device {
	int id;
	const char *type;
	long unsigned int max_state;
	struct device device;
	struct device_node *np;
	void *devdata;
	void *stats;
	const struct thermal_cooling_device_ops *ops;
	bool updated;
	struct mutex lock;
	struct list_head thermal_instances;
	struct list_head node;
};

struct thermal_cooling_device_ops {
	int (*get_max_state)(struct thermal_cooling_device *, long unsigned int *);
	int (*get_cur_state)(struct thermal_cooling_device *, long unsigned int *);
	int (*set_cur_state)(struct thermal_cooling_device *, long unsigned int);
	int (*get_requested_power)(struct thermal_cooling_device *, u32 *);
	int (*state2power)(struct thermal_cooling_device *, long unsigned int, u32 *);
	int (*power2state)(struct thermal_cooling_device *, u32, long unsigned int *);
};

struct thermal_genl_cpu_caps {
	int cpu;
	int performance;
	int efficiency;
};

struct thermal_genl_notify {
	int mcgrp;
};

struct thermal_trip;

struct thermal_governor {
	const char *name;
	int (*bind_to_tz)(struct thermal_zone_device *);
	void (*unbind_from_tz)(struct thermal_zone_device *);
	void (*trip_crossed)(struct thermal_zone_device *, const struct thermal_trip *, bool);
	void (*manage)(struct thermal_zone_device *);
	void (*update_tz)(struct thermal_zone_device *, enum thermal_notify_event);
	struct list_head governor_list;
};

struct thermal_hwmon_attr {
	struct device_attribute attr;
	char name[16];
};

struct thermal_hwmon_device {
	char type[20];
	struct device *device;
	int count;
	struct list_head tz_list;
	struct list_head node;
};

struct thermal_hwmon_temp {
	struct list_head hwmon_node;
	struct thermal_zone_device *tz;
	struct thermal_hwmon_attr temp_input;
	struct thermal_hwmon_attr temp_crit;
};

struct thermal_instance {
	int id;
	char name[20];
	struct thermal_cooling_device *cdev;
	const struct thermal_trip *trip;
	bool initialized;
	long unsigned int upper;
	long unsigned int lower;
	long unsigned int target;
	char attr_name[20];
	struct device_attribute attr;
	char weight_attr_name[20];
	struct device_attribute weight_attr;
	struct list_head trip_node;
	struct list_head cdev_node;
	unsigned int weight;
	bool upper_no_limit;
};

struct thermal_state {
	struct _thermal_state core_throttle;
	struct _thermal_state core_power_limit;
	struct _thermal_state package_throttle;
	struct _thermal_state package_power_limit;
	struct _thermal_state core_thresh0;
	struct _thermal_state core_thresh1;
	struct _thermal_state pkg_thresh0;
	struct _thermal_state pkg_thresh1;
};

struct thermal_trip {
	int temperature;
	int hysteresis;
	enum thermal_trip_type type;
	u8 flags;
	void *priv;
};

struct thermal_trip_attrs {
	struct thermal_attr type;
	struct thermal_attr temp;
	struct thermal_attr hyst;
};

struct thermal_trip_desc {
	struct thermal_trip trip;
	struct thermal_trip_attrs trip_attrs;
	struct list_head list_node;
	struct list_head thermal_instances;
	int threshold;
};

typedef struct thermal_zone_device *class_thermal_zone_get_by_id_t;

typedef struct thermal_zone_device *class_thermal_zone_reverse_t;

typedef struct thermal_zone_device *class_thermal_zone_t;

struct thermal_zone_device_ops {
	bool (*should_bind)(struct thermal_zone_device *, const struct thermal_trip *, struct thermal_cooling_device *, struct cooling_spec *);
	int (*get_temp)(struct thermal_zone_device *, int *);
	int (*set_trips)(struct thermal_zone_device *, int, int);
	int (*change_mode)(struct thermal_zone_device *, enum thermal_device_mode);
	int (*set_trip_temp)(struct thermal_zone_device *, const struct thermal_trip *, int);
	int (*get_crit_temp)(struct thermal_zone_device *, int *);
	int (*set_emul_temp)(struct thermal_zone_device *, int);
	int (*get_trend)(struct thermal_zone_device *, const struct thermal_trip *, enum thermal_trend *);
	void (*hot)(struct thermal_zone_device *);
	void (*critical)(struct thermal_zone_device *);
};

struct thermal_zone_params;

struct thermal_zone_device {
	int id;
	char type[20];
	struct device device;
	struct completion removal;
	struct completion resume;
	struct attribute_group trips_attribute_group;
	struct list_head trips_high;
	struct list_head trips_reached;
	struct list_head trips_invalid;
	enum thermal_device_mode mode;
	void *devdata;
	int num_trips;
	long unsigned int passive_delay_jiffies;
	long unsigned int polling_delay_jiffies;
	long unsigned int recheck_delay_jiffies;
	int temperature;
	int last_temperature;
	int emul_temperature;
	int passive;
	int prev_low_trip;
	int prev_high_trip;
	struct thermal_zone_device_ops ops;
	struct thermal_zone_params *tzp;
	struct thermal_governor *governor;
	void *governor_data;
	struct ida ida;
	struct mutex lock;
	struct list_head node;
	struct delayed_work poll_queue;
	enum thermal_notify_event notify_event;
	u8 state;
	struct list_head user_thresholds;
	struct thermal_trip_desc trips[0];
};

struct thermal_zone_params {
	const char *governor_name;
	bool no_hwmon;
	u32 sustainable_power;
	s32 k_po;
	s32 k_pu;
	s32 k_i;
	s32 k_d;
	s32 integral_cutoff;
	int slope;
	int offset;
};

struct thread_deferred_req {
	struct cache_deferred_req handle;
	struct completion completion;
};

struct threshold_block;

struct thresh_restart {
	struct threshold_block *b;
	int reset;
	int set_lvt_off;
	int lvt_off;
	u16 old_limit;
};

struct threshold_attr {
	struct attribute attr;
	ssize_t (*show)(struct threshold_block *, char *);
	ssize_t (*store)(struct threshold_block *, const char *, size_t);
};

struct threshold_bank {
	struct kobject *kobj;
	struct threshold_block *blocks;
};

struct threshold_block {
	unsigned int block;
	unsigned int bank;
	unsigned int cpu;
	u32 address;
	bool interrupt_enable;
	bool interrupt_capable;
	u16 threshold_limit;
	struct kobject kobj;
	struct list_head miscj;
};

struct throttling_tstate {
	unsigned int cpu;
	int target_state;
};

struct tick_device {
	struct clock_event_device *evtdev;
	enum tick_device_mode mode;
};

struct tick_sched {
	long unsigned int flags;
	unsigned int stalled_jiffies;
	long unsigned int last_tick_jiffies;
	struct hrtimer sched_timer;
	ktime_t last_tick;
	ktime_t next_tick;
	long unsigned int idle_jiffies;
	ktime_t idle_waketime;
	unsigned int got_idle_tick;
	seqcount_t idle_sleeptime_seq;
	ktime_t idle_entrytime;
	long unsigned int last_jiffies;
	u64 timer_expires_base;
	u64 timer_expires;
	u64 next_timer;
	ktime_t idle_expires;
	long unsigned int idle_calls;
	long unsigned int idle_sleeps;
	ktime_t idle_exittime;
	ktime_t idle_sleeptime;
	ktime_t iowait_sleeptime;
	atomic_t tick_dep_mask;
	long unsigned int check_clocks;
};

struct tid_ampdu_rx {
	struct callback_head callback_head;
	spinlock_t reorder_lock;
	u64 reorder_buf_filtered;
	struct sk_buff_head *reorder_buf;
	long unsigned int *reorder_time;
	struct sta_info *sta;
	struct timer_list session_timer;
	struct timer_list reorder_timer;
	long unsigned int last_rx;
	u16 head_seq_num;
	u16 stored_mpdu_num;
	u16 ssn;
	u16 buf_size;
	u16 timeout;
	u8 tid;
	u8 auto_seq: 1;
	u8 removed: 1;
	u8 started: 1;
};

struct tid_ampdu_tx {
	struct callback_head callback_head;
	struct timer_list session_timer;
	struct timer_list addba_resp_timer;
	struct sk_buff_head pending;
	struct sta_info *sta;
	long unsigned int state;
	long unsigned int last_tx;
	u16 timeout;
	u8 dialog_token;
	u8 stop_initiator;
	bool tx_stop;
	u16 buf_size;
	u16 ssn;
	u16 failed_bar_ssn;
	bool bar_pending;
	bool amsdu;
	u8 tid;
};

struct timens_offsets {
	struct timespec64 monotonic;
	struct timespec64 boottime;
};

struct time_namespace {
	struct user_namespace *user_ns;
	struct ucounts *ucounts;
	struct ns_common ns;
	struct timens_offsets offsets;
	struct page *vvar_page;
	bool frozen_offsets;
};

struct timedia_struct {
	int num;
	const short unsigned int *ids;
};

struct tk_read_base {
	struct clocksource *clock;
	u64 mask;
	u64 cycle_last;
	u32 mult;
	u32 shift;
	u64 xtime_nsec;
	ktime_t base;
	u64 base_real;
};

struct timekeeper {
	struct tk_read_base tkr_mono;
	u64 xtime_sec;
	long unsigned int ktime_sec;
	struct timespec64 wall_to_monotonic;
	ktime_t offs_real;
	ktime_t offs_boot;
	ktime_t offs_tai;
	s32 tai_offset;
	struct tk_read_base tkr_raw;
	u64 raw_sec;
	unsigned int clock_was_set_seq;
	u8 cs_was_changed_seq;
	struct timespec64 monotonic_to_boot;
	u64 cycle_interval;
	u64 xtime_interval;
	s64 xtime_remainder;
	u64 raw_interval;
	ktime_t next_leap_ktime;
	u64 ntp_tick;
	s64 ntp_error;
	u32 ntp_error_shift;
	u32 ntp_err_mult;
	u32 skip_second_overflow;
};

struct timens_offset {
	s64 sec;
	u64 nsec;
};

struct timer_base {
	raw_spinlock_t lock;
	struct timer_list *running_timer;
	long unsigned int clk;
	long unsigned int next_expiry;
	unsigned int cpu;
	bool next_expiry_recalc;
	bool is_idle;
	bool timers_pending;
	long unsigned int pending_map[9];
	struct hlist_head vectors[576];
	long: 64;
	long: 64;
};

struct timer_events {
	u64 local;
	u64 global;
};

struct timer_list_iter {
	int cpu;
	bool second_pass;
	u64 now;
};

struct timer_rand_state {
	long unsigned int last_time;
	long int last_delta;
	long int last_delta2;
};

struct timerfd_ctx {
	union {
		struct hrtimer tmr;
		struct alarm alarm;
	} t;
	ktime_t tintv;
	ktime_t moffs;
	wait_queue_head_t wqh;
	u64 ticks;
	int clockid;
	short unsigned int expired;
	short unsigned int settime_flags;
	struct callback_head rcu;
	struct list_head clist;
	spinlock_t cancel_lock;
	bool might_cancel;
};

struct timerlat_entry {
	struct trace_entry ent;
	unsigned int seqnum;
	int context;
	u64 timer_latency;
};

struct timestamp_event_queue {
	struct ptp_extts_event buf[128];
	int head;
	int tail;
	spinlock_t lock;
	struct list_head qlist;
	long unsigned int *mask;
	struct dentry *debugfs_instance;
	struct debugfs_u32_array dfs_bitmap;
};

struct timewait_sock_ops {
	struct kmem_cache *twsk_slab;
	char *twsk_slab_name;
	unsigned int twsk_obj_size;
	void (*twsk_destructor)(struct sock *);
};

struct timezone {
	int tz_minuteswest;
	int tz_dsttime;
};

struct tiocl_selection {
	short unsigned int xs;
	short unsigned int ys;
	short unsigned int xe;
	short unsigned int ye;
	short unsigned int sel_mode;
};

struct tipc_basic_hdr {
	__be32 w[4];
};

struct tk_data {
	seqcount_raw_spinlock_t seq;
	struct timekeeper timekeeper;
	struct timekeeper shadow_timekeeper;
	raw_spinlock_t lock;
};

struct tk_fast {
	seqcount_latch_t seq;
	struct tk_read_base base[2];
};

struct tlb_context {
	u64 ctx_id;
	u64 tlb_gen;
};

struct tlb_state {
	struct mm_struct *loaded_mm;
	union {
		struct mm_struct *last_user_mm;
		long unsigned int last_user_mm_spec;
	};
	u16 loaded_mm_asid;
	u16 next_asid;
	bool invalidate_other;
	short unsigned int user_pcid_flush_mask;
	long unsigned int cr4;
	struct tlb_context ctxs[6];
};

struct tlb_state_shared {
	bool is_lazy;
};

struct tls_crypto_info {
	__u16 version;
	__u16 cipher_type;
};

struct tls12_crypto_info_aes_gcm_128 {
	struct tls_crypto_info info;
	unsigned char iv[8];
	unsigned char key[16];
	unsigned char salt[4];
	unsigned char rec_seq[8];
};

struct tls12_crypto_info_aes_gcm_256 {
	struct tls_crypto_info info;
	unsigned char iv[8];
	unsigned char key[32];
	unsigned char salt[4];
	unsigned char rec_seq[8];
};

struct tls12_crypto_info_chacha20_poly1305 {
	struct tls_crypto_info info;
	unsigned char iv[12];
	unsigned char key[32];
	unsigned char salt[0];
	unsigned char rec_seq[8];
};

struct tls12_crypto_info_sm4_ccm {
	struct tls_crypto_info info;
	unsigned char iv[8];
	unsigned char key[16];
	unsigned char salt[4];
	unsigned char rec_seq[8];
};

struct tls12_crypto_info_sm4_gcm {
	struct tls_crypto_info info;
	unsigned char iv[8];
	unsigned char key[16];
	unsigned char salt[4];
	unsigned char rec_seq[8];
};

struct tls_prot_info {
	u16 version;
	u16 cipher_type;
	u16 prepend_size;
	u16 tag_size;
	u16 overhead_size;
	u16 iv_size;
	u16 salt_size;
	u16 rec_seq_size;
	u16 aad_size;
	u16 tail_size;
};

union tls_crypto_context {
	struct tls_crypto_info info;
	union {
		struct tls12_crypto_info_aes_gcm_128 aes_gcm_128;
		struct tls12_crypto_info_aes_gcm_256 aes_gcm_256;
		struct tls12_crypto_info_chacha20_poly1305 chacha20_poly1305;
		struct tls12_crypto_info_sm4_gcm sm4_gcm;
		struct tls12_crypto_info_sm4_ccm sm4_ccm;
	};
};

struct tls_context {
	struct tls_prot_info prot_info;
	u8 tx_conf: 3;
	u8 rx_conf: 3;
	u8 zerocopy_sendfile: 1;
	u8 rx_no_pad: 1;
	int (*push_pending_record)(struct sock *, int);
	void (*sk_write_space)(struct sock *);
	void *priv_ctx_tx;
	void *priv_ctx_rx;
	struct net_device *netdev;
	struct cipher_context tx;
	struct cipher_context rx;
	struct scatterlist *partially_sent_record;
	u16 partially_sent_offset;
	bool splicing_pages;
	bool pending_open_record_frags;
	struct mutex tx_lock;
	long unsigned int flags;
	struct proto *sk_proto;
	struct sock *sk;
	void (*sk_destruct)(struct sock *);
	union tls_crypto_context crypto_send;
	union tls_crypto_context crypto_recv;
	struct list_head list;
	refcount_t refcount;
	struct callback_head rcu;
};

typedef void (*tls_done_func_t)(void *, int, key_serial_t);

struct tls_handshake_args {
	struct socket *ta_sock;
	tls_done_func_t ta_done;
	void *ta_data;
	const char *ta_peername;
	unsigned int ta_timeout_ms;
	key_serial_t ta_keyring;
	key_serial_t ta_my_cert;
	key_serial_t ta_my_privkey;
	unsigned int ta_num_peerids;
	key_serial_t ta_my_peerids[5];
};

struct tls_handshake_req {
	void (*th_consumer_done)(void *, int, key_serial_t);
	void *th_consumer_data;
	int th_type;
	unsigned int th_timeout_ms;
	int th_auth_mode;
	const char *th_peername;
	key_serial_t th_keyring;
	key_serial_t th_certificate;
	key_serial_t th_privkey;
	unsigned int th_num_peerids;
	key_serial_t th_peerid[5];
};

struct tls_strparser {
	struct sock *sk;
	u32 mark: 8;
	u32 stopped: 1;
	u32 copy_mode: 1;
	u32 mixed_decrypted: 1;
	bool msg_ready;
	struct strp_msg stm;
	struct sk_buff *anchor;
	struct work_struct work;
};

struct tls_sw_context_rx {
	struct crypto_aead *aead_recv;
	struct crypto_wait async_wait;
	struct sk_buff_head rx_list;
	void (*saved_data_ready)(struct sock *);
	u8 reader_present;
	u8 async_capable: 1;
	u8 zc_capable: 1;
	u8 reader_contended: 1;
	bool key_update_pending;
	struct tls_strparser strp;
	atomic_t decrypt_pending;
	struct sk_buff_head async_hold;
	struct wait_queue_head wq;
};

struct tx_work {
	struct delayed_work work;
	struct sock *sk;
};

struct tls_rec;

struct tls_sw_context_tx {
	struct crypto_aead *aead_send;
	struct crypto_wait async_wait;
	struct tx_work tx_work;
	struct tls_rec *open_rec;
	struct list_head tx_list;
	atomic_t encrypt_pending;
	u8 async_capable: 1;
	long unsigned int tx_bitmask;
};

struct tm {
	int tm_sec;
	int tm_min;
	int tm_hour;
	int tm_mday;
	int tm_mon;
	long int tm_year;
	int tm_wday;
	int tm_yday;
};

struct tmigr_event {
	struct timerqueue_node nextevt;
	unsigned int cpu;
	bool ignore;
};

struct tmigr_group;

struct tmigr_cpu {
	raw_spinlock_t lock;
	bool online;
	bool idle;
	bool remote;
	struct tmigr_group *tmgroup;
	u8 groupmask;
	u64 wakeup;
	struct tmigr_event cpuevt;
};

struct tmigr_group {
	raw_spinlock_t lock;
	struct tmigr_group *parent;
	struct tmigr_event groupevt;
	u64 next_expiry;
	struct timerqueue_head events;
	atomic_t migr_state;
	unsigned int level;
	int numa_node;
	unsigned int num_children;
	u8 groupmask;
	struct list_head list;
};

union tmigr_state {
	u32 state;
	struct {
		u8 active;
		u8 migrator;
		u16 seq;
	};
};

struct tmigr_walk {
	u64 nextexp;
	u64 firstexp;
	struct tmigr_event *evt;
	u8 childmask;
	bool remote;
	long unsigned int basej;
	u64 now;
	bool check;
	bool tmc_active;
};

struct tmp_ext {
	struct in6_addr daddr;
	char hdrs[0];
};

struct tmpmasks {
	cpumask_var_t addmask;
	cpumask_var_t delmask;
	cpumask_var_t new_cpus;
};

struct tms {
	__kernel_clock_t tms_utime;
	__kernel_clock_t tms_stime;
	__kernel_clock_t tms_cutime;
	__kernel_clock_t tms_cstime;
};

struct tnl_ptk_info {
	long unsigned int flags[1];
	__be16 proto;
	__be32 key;
	__be32 seq;
	int hdr_len;
};

struct tnode {
	struct callback_head rcu;
	t_key empty_children;
	t_key full_children;
	struct key_vector *parent;
	struct key_vector kv[1];
};

struct topa {
	struct list_head list;
	u64 offset;
	size_t size;
	int last;
	unsigned int z_count;
};

struct topa_entry {
	u64 end: 1;
	u64 rsvd0: 1;
	u64 intr: 1;
	u64 rsvd1: 1;
	u64 stop: 1;
	u64 rsvd2: 1;
	u64 size: 4;
	u64 rsvd3: 2;
	u64 base: 40;
	u64 rsvd4: 12;
};

struct topa_page {
	struct topa_entry table[507];
	struct topa topa;
};

struct topo_scan {
	struct cpuinfo_x86 *c;
	unsigned int dom_shifts[7];
	unsigned int dom_ncpus[7];
	unsigned int ebx1_nproc_shift;
	u16 amd_nodes_per_pkg;
	u16 amd_node_id;
};

struct touchscreen_properties {
	unsigned int max_x;
	unsigned int max_y;
	bool invert_x;
	bool invert_y;
	bool swap_x_y;
};

struct tp_module {
	struct list_head list;
	struct module *mod;
};

struct tracepoint_func {
	void *func;
	void *data;
	int prio;
};

struct tp_probes {
	struct callback_head rcu;
	struct tracepoint_func probes[0];
};

struct tp_transition_snapshot {
	long unsigned int rcu;
	bool ongoing;
};

struct tpacket2_hdr {
	__u32 tp_status;
	__u32 tp_len;
	__u32 tp_snaplen;
	__u16 tp_mac;
	__u16 tp_net;
	__u32 tp_sec;
	__u32 tp_nsec;
	__u16 tp_vlan_tci;
	__u16 tp_vlan_tpid;
	__u8 tp_padding[4];
};

struct tpacket_hdr_variant1 {
	__u32 tp_rxhash;
	__u32 tp_vlan_tci;
	__u16 tp_vlan_tpid;
	__u16 tp_padding;
};

struct tpacket3_hdr {
	__u32 tp_next_offset;
	__u32 tp_sec;
	__u32 tp_nsec;
	__u32 tp_snaplen;
	__u32 tp_len;
	__u32 tp_status;
	__u16 tp_mac;
	__u16 tp_net;
	union {
		struct tpacket_hdr_variant1 hv1;
	};
	__u8 tp_padding[8];
};

struct tpacket_auxdata {
	__u32 tp_status;
	__u32 tp_len;
	__u32 tp_snaplen;
	__u16 tp_mac;
	__u16 tp_net;
	__u16 tp_vlan_tci;
	__u16 tp_vlan_tpid;
};

struct tpacket_bd_ts {
	unsigned int ts_sec;
	union {
		unsigned int ts_usec;
		unsigned int ts_nsec;
	};
};

struct tpacket_hdr_v1 {
	__u32 block_status;
	__u32 num_pkts;
	__u32 offset_to_first_pkt;
	__u32 blk_len;
	__u64 seq_num;
	struct tpacket_bd_ts ts_first_pkt;
	struct tpacket_bd_ts ts_last_pkt;
};

union tpacket_bd_header_u {
	struct tpacket_hdr_v1 bh1;
};

struct tpacket_block_desc {
	__u32 version;
	__u32 offset_to_priv;
	union tpacket_bd_header_u hdr;
};

struct tpacket_hdr {
	long unsigned int tp_status;
	unsigned int tp_len;
	unsigned int tp_snaplen;
	short unsigned int tp_mac;
	short unsigned int tp_net;
	unsigned int tp_sec;
	unsigned int tp_usec;
};

struct tpacket_req {
	unsigned int tp_block_size;
	unsigned int tp_block_nr;
	unsigned int tp_frame_size;
	unsigned int tp_frame_nr;
};

struct tpacket_req3 {
	unsigned int tp_block_size;
	unsigned int tp_block_nr;
	unsigned int tp_frame_size;
	unsigned int tp_frame_nr;
	unsigned int tp_retire_blk_tov;
	unsigned int tp_sizeof_priv;
	unsigned int tp_feature_req_word;
};

union tpacket_req_u {
	struct tpacket_req req;
	struct tpacket_req3 req3;
};

struct tpacket_rollover_stats {
	__u64 tp_all;
	__u64 tp_huge;
	__u64 tp_failed;
};

union tpacket_uhdr {
	struct tpacket_hdr *h1;
	struct tpacket2_hdr *h2;
	struct tpacket3_hdr *h3;
	void *raw;
};

struct tpt_led_trigger {
	char name[32];
	const struct ieee80211_tpt_blink *blink_table;
	unsigned int blink_table_len;
	struct timer_list timer;
	struct ieee80211_local *local;
	long unsigned int prev_traffic;
	long unsigned int tx_bytes;
	long unsigned int rx_bytes;
	unsigned int active;
	unsigned int want;
	bool running;
};

struct trace_pid_list;

struct trace_options;

struct trace_func_repeats;

struct trace_array {
	struct list_head list;
	char *name;
	struct array_buffer array_buffer;
	unsigned int mapped;
	long unsigned int range_addr_start;
	long unsigned int range_addr_size;
	long int text_delta;
	long int data_delta;
	struct trace_pid_list *filtered_pids;
	struct trace_pid_list *filtered_no_pids;
	arch_spinlock_t max_lock;
	int buffer_disabled;
	int sys_refcount_enter;
	int sys_refcount_exit;
	struct trace_event_file *enter_syscall_files[467];
	struct trace_event_file *exit_syscall_files[467];
	int stop_count;
	int clock_id;
	int nr_topts;
	bool clear_trace;
	int buffer_percent;
	unsigned int n_err_log_entries;
	struct tracer *current_trace;
	unsigned int trace_flags;
	unsigned char trace_flags_index[32];
	unsigned int flags;
	raw_spinlock_t start_lock;
	const char *system_names;
	struct list_head err_log;
	struct dentry *dir;
	struct dentry *options;
	struct dentry *percpu_dir;
	struct eventfs_inode *event_dir;
	struct trace_options *topts;
	struct list_head systems;
	struct list_head events;
	struct trace_event_file *trace_marker_file;
	cpumask_var_t tracing_cpumask;
	cpumask_var_t pipe_cpumask;
	int ref;
	int trace_ref;
	struct list_head mod_events;
	int no_filter_buffering_ref;
	struct list_head hist_vars;
	struct trace_func_repeats *last_func_repeats;
	bool ring_buffer_expanded;
};

struct trace_array_cpu {
	atomic_t disabled;
	void *buffer_page;
	long unsigned int entries;
	long unsigned int saved_latency;
	long unsigned int critical_start;
	long unsigned int critical_end;
	long unsigned int critical_sequence;
	long unsigned int nice;
	long unsigned int policy;
	long unsigned int rt_priority;
	long unsigned int skipped_entries;
	u64 preempt_timestamp;
	pid_t pid;
	kuid_t uid;
	char comm[16];
	bool ignore_pid;
};

struct trace_bprintk_fmt {
	struct list_head list;
	const char *fmt;
};

struct trace_buffer {
	unsigned int flags;
	int cpus;
	atomic_t record_disabled;
	atomic_t resizing;
	cpumask_var_t cpumask;
	struct lock_class_key *reader_lock_key;
	struct mutex mutex;
	struct ring_buffer_per_cpu **buffers;
	struct hlist_node node;
	u64 (*clock)(void);
	struct rb_irq_work irq_work;
	bool time_stamp_abs;
	long unsigned int range_addr_start;
	long unsigned int range_addr_end;
	long int last_text_delta;
	long int last_data_delta;
	unsigned int subbuf_size;
	unsigned int subbuf_order;
	unsigned int max_data_size;
};

struct trace_buffer_meta {
	__u32 meta_page_size;
	__u32 meta_struct_len;
	__u32 subbuf_size;
	__u32 nr_subbufs;
	struct {
		__u64 lost_events;
		__u32 id;
		__u32 read;
	} reader;
	__u64 flags;
	__u64 entries;
	__u64 overrun;
	__u64 read;
	__u64 Reserved1;
	__u64 Reserved2;
};

struct trace_buffer_struct {
	int nesting;
	char buffer[4096];
};

struct trace_chandef_entry {
	u32 control_freq;
	u32 freq_offset;
	u32 chan_width;
	u32 center_freq1;
	u32 freq1_offset;
	u32 center_freq2;
};

struct trace_probe_event;

struct trace_probe {
	struct list_head list;
	struct trace_probe_event *event;
	ssize_t size;
	unsigned int nr_args;
	struct probe_entry_arg *entry_arg;
	struct probe_arg args[0];
};

struct trace_eprobe {
	const char *event_system;
	const char *event_name;
	char *filter_str;
	struct trace_event_call *event;
	struct dyn_event devent;
	struct trace_probe tp;
};

struct trace_eval_map {
	const char *system;
	const char *eval_string;
	long unsigned int eval_value;
};

struct trace_event_functions;

struct trace_event {
	struct hlist_node node;
	int type;
	struct trace_event_functions *funcs;
};

struct trace_event_buffer {
	struct trace_buffer *buffer;
	struct ring_buffer_event *event;
	struct trace_event_file *trace_file;
	void *entry;
	unsigned int trace_ctx;
	struct pt_regs *regs;
};

struct trace_event_class;

struct trace_event_call {
	struct list_head list;
	struct trace_event_class *class;
	union {
		const char *name;
		struct tracepoint *tp;
	};
	struct trace_event event;
	char *print_fmt;
	union {
		void *module;
		atomic_t refcnt;
	};
	void *data;
	int flags;
	int perf_refcount;
	struct hlist_head *perf_events;
	struct bpf_prog_array *prog_array;
	int (*perf_perm)(struct trace_event_call *, struct perf_event *);
};

struct trace_event_fields;

struct trace_event_class {
	const char *system;
	void *probe;
	void *perf_probe;
	int (*reg)(struct trace_event_call *, enum trace_reg, void *);
	struct trace_event_fields *fields_array;
	struct list_head * (*get_fields)(struct trace_event_call *);
	struct list_head fields;
	int (*raw_init)(struct trace_event_call *);
};

struct trace_event_data_offsets_9p_client_req {};

struct trace_event_data_offsets_9p_client_res {};

struct trace_event_data_offsets_9p_fid_ref {};

struct trace_event_data_offsets_9p_protocol_dump {
	u32 line;
	const void *line_ptr_;
};

struct trace_event_data_offsets_alarm_class {};

struct trace_event_data_offsets_alarmtimer_suspend {};

struct trace_event_data_offsets_alloc_vmap_area {};

struct trace_event_data_offsets_amd_pstate_epp_perf {};

struct trace_event_data_offsets_amd_pstate_perf {};

struct trace_event_data_offsets_api_beacon_loss {
	u32 vif_name;
	const void *vif_name_ptr_;
};

struct trace_event_data_offsets_api_chswitch_done {
	u32 vif_name;
	const void *vif_name_ptr_;
};

struct trace_event_data_offsets_api_connection_loss {
	u32 vif_name;
	const void *vif_name_ptr_;
};

struct trace_event_data_offsets_api_cqm_rssi_notify {
	u32 vif_name;
	const void *vif_name_ptr_;
};

struct trace_event_data_offsets_api_disconnect {
	u32 vif_name;
	const void *vif_name_ptr_;
};

struct trace_event_data_offsets_api_enable_rssi_reports {
	u32 vif_name;
	const void *vif_name_ptr_;
};

struct trace_event_data_offsets_api_eosp {};

struct trace_event_data_offsets_api_finalize_rx_omi_bw {
	u32 vif_name;
	const void *vif_name_ptr_;
};

struct trace_event_data_offsets_api_gtk_rekey_notify {
	u32 vif_name;
	const void *vif_name_ptr_;
};

struct trace_event_data_offsets_api_prepare_rx_omi_bw {
	u32 vif_name;
	const void *vif_name_ptr_;
};

struct trace_event_data_offsets_api_radar_detected {};

struct trace_event_data_offsets_api_request_smps {
	u32 vif_name;
	const void *vif_name_ptr_;
};

struct trace_event_data_offsets_api_return_bool {};

struct trace_event_data_offsets_api_return_void {};

struct trace_event_data_offsets_api_scan_completed {};

struct trace_event_data_offsets_api_sched_scan_results {};

struct trace_event_data_offsets_api_sched_scan_stopped {};

struct trace_event_data_offsets_api_send_eosp_nullfunc {};

struct trace_event_data_offsets_api_sta_block_awake {};

struct trace_event_data_offsets_api_sta_set_buffered {};

struct trace_event_data_offsets_api_start_tx_ba_cb {
	u32 vif_name;
	const void *vif_name_ptr_;
};

struct trace_event_data_offsets_api_start_tx_ba_session {};

struct trace_event_data_offsets_api_stop_tx_ba_cb {
	u32 vif_name;
	const void *vif_name_ptr_;
};

struct trace_event_data_offsets_api_stop_tx_ba_session {};

struct trace_event_data_offsets_ata_bmdma_status {};

struct trace_event_data_offsets_ata_eh_action_template {};

struct trace_event_data_offsets_ata_eh_link_autopsy {};

struct trace_event_data_offsets_ata_eh_link_autopsy_qc {};

struct trace_event_data_offsets_ata_exec_command_template {};

struct trace_event_data_offsets_ata_link_reset_begin_template {};

struct trace_event_data_offsets_ata_link_reset_end_template {};

struct trace_event_data_offsets_ata_port_eh_begin_template {};

struct trace_event_data_offsets_ata_qc_complete_template {};

struct trace_event_data_offsets_ata_qc_issue_template {};

struct trace_event_data_offsets_ata_sff_hsm_template {};

struct trace_event_data_offsets_ata_sff_template {};

struct trace_event_data_offsets_ata_tf_load {};

struct trace_event_data_offsets_ata_transfer_data_template {};

struct trace_event_data_offsets_azx_get_position {};

struct trace_event_data_offsets_azx_pcm {};

struct trace_event_data_offsets_azx_pcm_trigger {};

struct trace_event_data_offsets_balance_dirty_pages {};

struct trace_event_data_offsets_bdi_dirty_ratelimit {};

struct trace_event_data_offsets_block_bio {};

struct trace_event_data_offsets_block_bio_complete {};

struct trace_event_data_offsets_block_bio_remap {};

struct trace_event_data_offsets_block_buffer {};

struct trace_event_data_offsets_block_plug {};

struct trace_event_data_offsets_block_rq {
	u32 cmd;
	const void *cmd_ptr_;
};

struct trace_event_data_offsets_block_rq_completion {
	u32 cmd;
	const void *cmd_ptr_;
};

struct trace_event_data_offsets_block_rq_remap {};

struct trace_event_data_offsets_block_rq_requeue {
	u32 cmd;
	const void *cmd_ptr_;
};

struct trace_event_data_offsets_block_split {};

struct trace_event_data_offsets_block_unplug {};

struct trace_event_data_offsets_bpf_test_finish {};

struct trace_event_data_offsets_bpf_trace_printk {
	u32 bpf_string;
	const void *bpf_string_ptr_;
};

struct trace_event_data_offsets_bpf_trigger_tp {};

struct trace_event_data_offsets_bpf_xdp_link_attach_failed {
	u32 msg;
	const void *msg_ptr_;
};

struct trace_event_data_offsets_cache_event {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_cache_tag_flush {
	u32 iommu;
	const void *iommu_ptr_;
	u32 dev;
	const void *dev_ptr_;
};

struct trace_event_data_offsets_cache_tag_log {
	u32 iommu;
	const void *iommu_ptr_;
	u32 dev;
	const void *dev_ptr_;
};

struct trace_event_data_offsets_cap_capable {};

struct trace_event_data_offsets_cdev_update {
	u32 type;
	const void *type_ptr_;
};

struct trace_event_data_offsets_cfg80211_assoc_comeback {};

struct trace_event_data_offsets_cfg80211_bss_color_notify {};

struct trace_event_data_offsets_cfg80211_bss_evt {};

struct trace_event_data_offsets_cfg80211_cac_event {};

struct trace_event_data_offsets_cfg80211_ch_switch_notify {};

struct trace_event_data_offsets_cfg80211_ch_switch_started_notify {};

struct trace_event_data_offsets_cfg80211_chandef_dfs_required {};

struct trace_event_data_offsets_cfg80211_control_port_tx_status {};

struct trace_event_data_offsets_cfg80211_cqm_pktloss_notify {};

struct trace_event_data_offsets_cfg80211_cqm_rssi_notify {};

struct trace_event_data_offsets_cfg80211_epcs_changed {};

struct trace_event_data_offsets_cfg80211_ft_event {
	u32 ies;
	const void *ies_ptr_;
	u32 ric_ies;
	const void *ric_ies_ptr_;
};

struct trace_event_data_offsets_cfg80211_get_bss {
	u32 ssid;
	const void *ssid_ptr_;
};

struct trace_event_data_offsets_cfg80211_ibss_joined {};

struct trace_event_data_offsets_cfg80211_inform_bss_frame {
	u32 mgmt;
	const void *mgmt_ptr_;
};

struct trace_event_data_offsets_cfg80211_links_removed {};

struct trace_event_data_offsets_cfg80211_mgmt_tx_status {};

struct trace_event_data_offsets_cfg80211_michael_mic_failure {};

struct trace_event_data_offsets_cfg80211_mlo_reconf_add_done {
	u32 buf;
	const void *buf_ptr_;
};

struct trace_event_data_offsets_cfg80211_netdev_mac_evt {};

struct trace_event_data_offsets_cfg80211_new_sta {};

struct trace_event_data_offsets_cfg80211_pmksa_candidate_notify {};

struct trace_event_data_offsets_cfg80211_pmsr_complete {};

struct trace_event_data_offsets_cfg80211_pmsr_report {};

struct trace_event_data_offsets_cfg80211_probe_status {};

struct trace_event_data_offsets_cfg80211_radar_event {};

struct trace_event_data_offsets_cfg80211_ready_on_channel {};

struct trace_event_data_offsets_cfg80211_ready_on_channel_expired {};

struct trace_event_data_offsets_cfg80211_reg_can_beacon {};

struct trace_event_data_offsets_cfg80211_report_obss_beacon {};

struct trace_event_data_offsets_cfg80211_report_wowlan_wakeup {
	u32 packet;
	const void *packet_ptr_;
};

struct trace_event_data_offsets_cfg80211_return_bool {};

struct trace_event_data_offsets_cfg80211_return_u32 {};

struct trace_event_data_offsets_cfg80211_return_uint {};

struct trace_event_data_offsets_cfg80211_rx_control_port {};

struct trace_event_data_offsets_cfg80211_rx_evt {};

struct trace_event_data_offsets_cfg80211_rx_mgmt {};

struct trace_event_data_offsets_cfg80211_scan_done {
	u32 ie;
	const void *ie_ptr_;
};

struct trace_event_data_offsets_cfg80211_send_assoc_failure {};

struct trace_event_data_offsets_cfg80211_send_rx_assoc {};

struct trace_event_data_offsets_cfg80211_stop_iface {};

struct trace_event_data_offsets_cfg80211_tdls_oper_request {};

struct trace_event_data_offsets_cfg80211_tx_mgmt_expired {};

struct trace_event_data_offsets_cfg80211_tx_mlme_mgmt {
	u32 frame;
	const void *frame_ptr_;
};

struct trace_event_data_offsets_cfg80211_update_owe_info_event {
	u32 ie;
	const void *ie_ptr_;
};

struct trace_event_data_offsets_cgroup {
	u32 path;
	const void *path_ptr_;
};

struct trace_event_data_offsets_cgroup_event {
	u32 path;
	const void *path_ptr_;
};

struct trace_event_data_offsets_cgroup_migrate {
	u32 dst_path;
	const void *dst_path_ptr_;
	u32 comm;
	const void *comm_ptr_;
};

struct trace_event_data_offsets_cgroup_root {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_cgroup_rstat {};

struct trace_event_data_offsets_chanswitch_evt {
	u32 vif_name;
	const void *vif_name_ptr_;
};

struct trace_event_data_offsets_clock {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_compact_retry {};

struct trace_event_data_offsets_console {
	u32 msg;
	const void *msg_ptr_;
};

struct trace_event_data_offsets_consume_skb {};

struct trace_event_data_offsets_contention_begin {};

struct trace_event_data_offsets_contention_end {};

struct trace_event_data_offsets_cpu {};

struct trace_event_data_offsets_cpu_frequency_limits {};

struct trace_event_data_offsets_cpu_idle_miss {};

struct trace_event_data_offsets_cpu_latency_qos_request {};

struct trace_event_data_offsets_cpuhp_enter {};

struct trace_event_data_offsets_cpuhp_exit {};

struct trace_event_data_offsets_cpuhp_multi_enter {};

struct trace_event_data_offsets_csd_function {};

struct trace_event_data_offsets_csd_queue_cpu {};

struct trace_event_data_offsets_ctime {};

struct trace_event_data_offsets_ctime_ns_xchg {};

struct trace_event_data_offsets_dev_pm_qos_request {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_device_pm_callback_end {
	u32 device;
	const void *device_ptr_;
	u32 driver;
	const void *driver_ptr_;
};

struct trace_event_data_offsets_device_pm_callback_start {
	u32 device;
	const void *device_ptr_;
	u32 driver;
	const void *driver_ptr_;
	u32 parent;
	const void *parent_ptr_;
	u32 pm_ops;
	const void *pm_ops_ptr_;
};

struct trace_event_data_offsets_devres {
	u32 devname;
	const void *devname_ptr_;
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_dma_alloc_class {
	u32 device;
	const void *device_ptr_;
};

struct trace_event_data_offsets_dma_alloc_sgt {
	u32 device;
	const void *device_ptr_;
	u32 phys_addrs;
	const void *phys_addrs_ptr_;
};

struct trace_event_data_offsets_dma_fence {
	u32 driver;
	const void *driver_ptr_;
	u32 timeline;
	const void *timeline_ptr_;
};

struct trace_event_data_offsets_dma_free_class {
	u32 device;
	const void *device_ptr_;
};

struct trace_event_data_offsets_dma_free_sgt {
	u32 device;
	const void *device_ptr_;
	u32 phys_addrs;
	const void *phys_addrs_ptr_;
};

struct trace_event_data_offsets_dma_map {
	u32 device;
	const void *device_ptr_;
};

struct trace_event_data_offsets_dma_map_sg {
	u32 device;
	const void *device_ptr_;
	u32 phys_addrs;
	const void *phys_addrs_ptr_;
	u32 dma_addrs;
	const void *dma_addrs_ptr_;
	u32 lengths;
	const void *lengths_ptr_;
};

struct trace_event_data_offsets_dma_map_sg_err {
	u32 device;
	const void *device_ptr_;
	u32 phys_addrs;
	const void *phys_addrs_ptr_;
};

struct trace_event_data_offsets_dma_sync_sg {
	u32 device;
	const void *device_ptr_;
	u32 dma_addrs;
	const void *dma_addrs_ptr_;
	u32 lengths;
	const void *lengths_ptr_;
};

struct trace_event_data_offsets_dma_sync_single {
	u32 device;
	const void *device_ptr_;
};

struct trace_event_data_offsets_dma_unmap {
	u32 device;
	const void *device_ptr_;
};

struct trace_event_data_offsets_dma_unmap_sg {
	u32 device;
	const void *device_ptr_;
	u32 addrs;
	const void *addrs_ptr_;
};

struct trace_event_data_offsets_dql_stall_detected {};

struct trace_event_data_offsets_drm_vblank_event {};

struct trace_event_data_offsets_drm_vblank_event_delivered {};

struct trace_event_data_offsets_drm_vblank_event_queued {};

struct trace_event_data_offsets_drv_add_nan_func {
	u32 vif_name;
	const void *vif_name_ptr_;
};

struct trace_event_data_offsets_drv_add_twt_setup {};

struct trace_event_data_offsets_drv_ampdu_action {
	u32 vif_name;
	const void *vif_name_ptr_;
};

struct trace_event_data_offsets_drv_can_activate_links {
	u32 vif_name;
	const void *vif_name_ptr_;
};

struct trace_event_data_offsets_drv_can_neg_ttlm {
	u32 vif_name;
	const void *vif_name_ptr_;
};

struct trace_event_data_offsets_drv_change_chanctx {};

struct trace_event_data_offsets_drv_change_interface {
	u32 vif_name;
	const void *vif_name_ptr_;
};

struct trace_event_data_offsets_drv_change_sta_links {
	u32 vif_name;
	const void *vif_name_ptr_;
};

struct trace_event_data_offsets_drv_change_vif_links {
	u32 vif_name;
	const void *vif_name_ptr_;
};

struct trace_event_data_offsets_drv_channel_switch_beacon {
	u32 vif_name;
	const void *vif_name_ptr_;
};

struct trace_event_data_offsets_drv_conf_tx {
	u32 vif_name;
	const void *vif_name_ptr_;
};

struct trace_event_data_offsets_drv_config {};

struct trace_event_data_offsets_drv_config_iface_filter {
	u32 vif_name;
	const void *vif_name_ptr_;
};

struct trace_event_data_offsets_drv_configure_filter {};

struct trace_event_data_offsets_drv_del_nan_func {
	u32 vif_name;
	const void *vif_name_ptr_;
};

struct trace_event_data_offsets_drv_event_callback {
	u32 vif_name;
	const void *vif_name_ptr_;
};

struct trace_event_data_offsets_drv_flush {};

struct trace_event_data_offsets_drv_get_antenna {};

struct trace_event_data_offsets_drv_get_expected_throughput {};

struct trace_event_data_offsets_drv_get_ftm_responder_stats {
	u32 vif_name;
	const void *vif_name_ptr_;
};

struct trace_event_data_offsets_drv_get_key_seq {};

struct trace_event_data_offsets_drv_get_ringparam {};

struct trace_event_data_offsets_drv_get_stats {};

struct trace_event_data_offsets_drv_get_survey {};

struct trace_event_data_offsets_drv_get_txpower {
	u32 vif_name;
	const void *vif_name_ptr_;
};

struct trace_event_data_offsets_drv_join_ibss {
	u32 vif_name;
	const void *vif_name_ptr_;
	u32 ssid;
	const void *ssid_ptr_;
};

struct trace_event_data_offsets_drv_link_info_changed {
	u32 vif_name;
	const void *vif_name_ptr_;
};

struct trace_event_data_offsets_drv_link_sta_rc_update {
	u32 vif_name;
	const void *vif_name_ptr_;
};

struct trace_event_data_offsets_drv_nan_change_conf {
	u32 vif_name;
	const void *vif_name_ptr_;
};

struct trace_event_data_offsets_drv_neg_ttlm_res {
	u32 vif_name;
	const void *vif_name_ptr_;
};

struct trace_event_data_offsets_drv_net_setup_tc {
	u32 vif_name;
	const void *vif_name_ptr_;
};

struct trace_event_data_offsets_drv_offset_tsf {
	u32 vif_name;
	const void *vif_name_ptr_;
};

struct trace_event_data_offsets_drv_prep_add_interface {};

struct trace_event_data_offsets_drv_prepare_multicast {};

struct trace_event_data_offsets_drv_reconfig_complete {};

struct trace_event_data_offsets_drv_remain_on_channel {
	u32 vif_name;
	const void *vif_name_ptr_;
};

struct trace_event_data_offsets_drv_return_bool {};

struct trace_event_data_offsets_drv_return_int {};

struct trace_event_data_offsets_drv_return_u32 {};

struct trace_event_data_offsets_drv_return_u64 {};

struct trace_event_data_offsets_drv_set_antenna {};

struct trace_event_data_offsets_drv_set_bitrate_mask {
	u32 vif_name;
	const void *vif_name_ptr_;
};

struct trace_event_data_offsets_drv_set_coverage_class {};

struct trace_event_data_offsets_drv_set_default_unicast_key {
	u32 vif_name;
	const void *vif_name_ptr_;
};

struct trace_event_data_offsets_drv_set_key {
	u32 vif_name;
	const void *vif_name_ptr_;
};

struct trace_event_data_offsets_drv_set_rekey_data {
	u32 vif_name;
	const void *vif_name_ptr_;
};

struct trace_event_data_offsets_drv_set_ringparam {};

struct trace_event_data_offsets_drv_set_tim {};

struct trace_event_data_offsets_drv_set_tsf {
	u32 vif_name;
	const void *vif_name_ptr_;
};

struct trace_event_data_offsets_drv_set_wakeup {};

struct trace_event_data_offsets_drv_sta_notify {
	u32 vif_name;
	const void *vif_name_ptr_;
};

struct trace_event_data_offsets_drv_sta_set_txpwr {
	u32 vif_name;
	const void *vif_name_ptr_;
};

struct trace_event_data_offsets_drv_sta_state {
	u32 vif_name;
	const void *vif_name_ptr_;
};

struct trace_event_data_offsets_drv_start_ap {
	u32 vif_name;
	const void *vif_name_ptr_;
	u32 ssid;
	const void *ssid_ptr_;
};

struct trace_event_data_offsets_drv_start_nan {
	u32 vif_name;
	const void *vif_name_ptr_;
};

struct trace_event_data_offsets_drv_stop {};

struct trace_event_data_offsets_drv_stop_ap {
	u32 vif_name;
	const void *vif_name_ptr_;
};

struct trace_event_data_offsets_drv_stop_nan {
	u32 vif_name;
	const void *vif_name_ptr_;
};

struct trace_event_data_offsets_drv_sw_scan_start {
	u32 vif_name;
	const void *vif_name_ptr_;
};

struct trace_event_data_offsets_drv_switch_vif_chanctx {
	u32 vifs;
	const void *vifs_ptr_;
};

struct trace_event_data_offsets_drv_tdls_cancel_channel_switch {
	u32 vif_name;
	const void *vif_name_ptr_;
};

struct trace_event_data_offsets_drv_tdls_channel_switch {
	u32 vif_name;
	const void *vif_name_ptr_;
};

struct trace_event_data_offsets_drv_tdls_recv_channel_switch {
	u32 vif_name;
	const void *vif_name_ptr_;
};

struct trace_event_data_offsets_drv_twt_teardown_request {};

struct trace_event_data_offsets_drv_update_tkip_key {
	u32 vif_name;
	const void *vif_name_ptr_;
};

struct trace_event_data_offsets_drv_vif_cfg_changed {
	u32 vif_name;
	const void *vif_name_ptr_;
	u32 arp_addr_list;
	const void *arp_addr_list_ptr_;
	u32 ssid;
	const void *ssid_ptr_;
};

struct trace_event_data_offsets_drv_wake_tx_queue {
	u32 vif_name;
	const void *vif_name_ptr_;
};

struct trace_event_data_offsets_e1000e_trace_mac_register {};

struct trace_event_data_offsets_emulate_vsyscall {};

struct trace_event_data_offsets_error_report_template {};

struct trace_event_data_offsets_exit_mmap {};

struct trace_event_data_offsets_ext4__bitmap_load {};

struct trace_event_data_offsets_ext4__es_extent {};

struct trace_event_data_offsets_ext4__es_shrink_enter {};

struct trace_event_data_offsets_ext4__fallocate_mode {};

struct trace_event_data_offsets_ext4__folio_op {};

struct trace_event_data_offsets_ext4__map_blocks_enter {};

struct trace_event_data_offsets_ext4__map_blocks_exit {};

struct trace_event_data_offsets_ext4__mb_new_pa {};

struct trace_event_data_offsets_ext4__mballoc {};

struct trace_event_data_offsets_ext4__trim {};

struct trace_event_data_offsets_ext4__truncate {};

struct trace_event_data_offsets_ext4__write_begin {};

struct trace_event_data_offsets_ext4__write_end {};

struct trace_event_data_offsets_ext4_alloc_da_blocks {};

struct trace_event_data_offsets_ext4_allocate_blocks {};

struct trace_event_data_offsets_ext4_allocate_inode {};

struct trace_event_data_offsets_ext4_begin_ordered_truncate {};

struct trace_event_data_offsets_ext4_collapse_range {};

struct trace_event_data_offsets_ext4_da_release_space {};

struct trace_event_data_offsets_ext4_da_reserve_space {};

struct trace_event_data_offsets_ext4_da_update_reserve_space {};

struct trace_event_data_offsets_ext4_da_write_pages {};

struct trace_event_data_offsets_ext4_da_write_pages_extent {};

struct trace_event_data_offsets_ext4_discard_blocks {};

struct trace_event_data_offsets_ext4_discard_preallocations {};

struct trace_event_data_offsets_ext4_drop_inode {};

struct trace_event_data_offsets_ext4_error {};

struct trace_event_data_offsets_ext4_es_find_extent_range_enter {};

struct trace_event_data_offsets_ext4_es_find_extent_range_exit {};

struct trace_event_data_offsets_ext4_es_insert_delayed_extent {};

struct trace_event_data_offsets_ext4_es_lookup_extent_enter {};

struct trace_event_data_offsets_ext4_es_lookup_extent_exit {};

struct trace_event_data_offsets_ext4_es_remove_extent {};

struct trace_event_data_offsets_ext4_es_shrink {};

struct trace_event_data_offsets_ext4_es_shrink_scan_exit {};

struct trace_event_data_offsets_ext4_evict_inode {};

struct trace_event_data_offsets_ext4_ext_convert_to_initialized_enter {};

struct trace_event_data_offsets_ext4_ext_convert_to_initialized_fastpath {};

struct trace_event_data_offsets_ext4_ext_handle_unwritten_extents {};

struct trace_event_data_offsets_ext4_ext_load_extent {};

struct trace_event_data_offsets_ext4_ext_remove_space {};

struct trace_event_data_offsets_ext4_ext_remove_space_done {};

struct trace_event_data_offsets_ext4_ext_rm_idx {};

struct trace_event_data_offsets_ext4_ext_rm_leaf {};

struct trace_event_data_offsets_ext4_ext_show_extent {};

struct trace_event_data_offsets_ext4_fallocate_exit {};

struct trace_event_data_offsets_ext4_fc_cleanup {};

struct trace_event_data_offsets_ext4_fc_commit_start {};

struct trace_event_data_offsets_ext4_fc_commit_stop {};

struct trace_event_data_offsets_ext4_fc_replay {};

struct trace_event_data_offsets_ext4_fc_replay_scan {};

struct trace_event_data_offsets_ext4_fc_stats {};

struct trace_event_data_offsets_ext4_fc_track_dentry {};

struct trace_event_data_offsets_ext4_fc_track_inode {};

struct trace_event_data_offsets_ext4_fc_track_range {};

struct trace_event_data_offsets_ext4_forget {};

struct trace_event_data_offsets_ext4_free_blocks {};

struct trace_event_data_offsets_ext4_free_inode {};

struct trace_event_data_offsets_ext4_fsmap_class {};

struct trace_event_data_offsets_ext4_get_implied_cluster_alloc_exit {};

struct trace_event_data_offsets_ext4_getfsmap_class {};

struct trace_event_data_offsets_ext4_insert_range {};

struct trace_event_data_offsets_ext4_invalidate_folio_op {};

struct trace_event_data_offsets_ext4_journal_start_inode {};

struct trace_event_data_offsets_ext4_journal_start_reserved {};

struct trace_event_data_offsets_ext4_journal_start_sb {};

struct trace_event_data_offsets_ext4_lazy_itable_init {};

struct trace_event_data_offsets_ext4_load_inode {};

struct trace_event_data_offsets_ext4_mark_inode_dirty {};

struct trace_event_data_offsets_ext4_mb_discard_preallocations {};

struct trace_event_data_offsets_ext4_mb_release_group_pa {};

struct trace_event_data_offsets_ext4_mb_release_inode_pa {};

struct trace_event_data_offsets_ext4_mballoc_alloc {};

struct trace_event_data_offsets_ext4_mballoc_prealloc {};

struct trace_event_data_offsets_ext4_nfs_commit_metadata {};

struct trace_event_data_offsets_ext4_other_inode_update_time {};

struct trace_event_data_offsets_ext4_prefetch_bitmaps {};

struct trace_event_data_offsets_ext4_read_block_bitmap_load {};

struct trace_event_data_offsets_ext4_remove_blocks {};

struct trace_event_data_offsets_ext4_request_blocks {};

struct trace_event_data_offsets_ext4_request_inode {};

struct trace_event_data_offsets_ext4_shutdown {};

struct trace_event_data_offsets_ext4_sync_file_enter {};

struct trace_event_data_offsets_ext4_sync_file_exit {};

struct trace_event_data_offsets_ext4_sync_fs {};

struct trace_event_data_offsets_ext4_unlink_enter {};

struct trace_event_data_offsets_ext4_unlink_exit {};

struct trace_event_data_offsets_ext4_update_sb {};

struct trace_event_data_offsets_ext4_writepages {};

struct trace_event_data_offsets_ext4_writepages_result {};

struct trace_event_data_offsets_fib6_table_lookup {};

struct trace_event_data_offsets_fib_table_lookup {};

struct trace_event_data_offsets_file_check_and_advance_wb_err {};

struct trace_event_data_offsets_filelock_lease {};

struct trace_event_data_offsets_filelock_lock {};

struct trace_event_data_offsets_filemap_set_wb_err {};

struct trace_event_data_offsets_fill_mg_cmtime {};

struct trace_event_data_offsets_finish_task_reaping {};

struct trace_event_data_offsets_free_vmap_area_noflush {};

struct trace_event_data_offsets_g4x_wm {
	u32 dev;
	const void *dev_ptr_;
};

struct trace_event_data_offsets_generic_add_lease {};

struct trace_event_data_offsets_global_dirty_state {};

struct trace_event_data_offsets_guest_halt_poll_ns {};

struct trace_event_data_offsets_handshake_alert_class {};

struct trace_event_data_offsets_handshake_complete {};

struct trace_event_data_offsets_handshake_error_class {};

struct trace_event_data_offsets_handshake_event_class {};

struct trace_event_data_offsets_handshake_fd_class {};

struct trace_event_data_offsets_hda_get_response {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_hda_pm {};

struct trace_event_data_offsets_hda_send_cmd {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_hda_unsol_event {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_hdac_stream {};

struct trace_event_data_offsets_hrtimer_class {};

struct trace_event_data_offsets_hrtimer_expire_entry {};

struct trace_event_data_offsets_hrtimer_init {};

struct trace_event_data_offsets_hrtimer_start {};

struct trace_event_data_offsets_hugetlbfs__inode {};

struct trace_event_data_offsets_hugetlbfs_alloc_inode {};

struct trace_event_data_offsets_hugetlbfs_fallocate {};

struct trace_event_data_offsets_hugetlbfs_setattr {
	u32 d_name;
	const void *d_name_ptr_;
};

struct trace_event_data_offsets_hwmon_attr_class {
	u32 attr_name;
	const void *attr_name_ptr_;
};

struct trace_event_data_offsets_hwmon_attr_show_string {
	u32 attr_name;
	const void *attr_name_ptr_;
	u32 label;
	const void *label_ptr_;
};

struct trace_event_data_offsets_i2c_read {};

struct trace_event_data_offsets_i2c_reply {
	u32 buf;
	const void *buf_ptr_;
};

struct trace_event_data_offsets_i2c_result {};

struct trace_event_data_offsets_i2c_write {
	u32 buf;
	const void *buf_ptr_;
};

struct trace_event_data_offsets_i915_context {};

struct trace_event_data_offsets_i915_gem_evict {};

struct trace_event_data_offsets_i915_gem_evict_node {};

struct trace_event_data_offsets_i915_gem_evict_vm {};

struct trace_event_data_offsets_i915_gem_object {};

struct trace_event_data_offsets_i915_gem_object_create {};

struct trace_event_data_offsets_i915_gem_object_fault {};

struct trace_event_data_offsets_i915_gem_object_pread {};

struct trace_event_data_offsets_i915_gem_object_pwrite {};

struct trace_event_data_offsets_i915_gem_shrink {};

struct trace_event_data_offsets_i915_ppgtt {};

struct trace_event_data_offsets_i915_reg_rw {};

struct trace_event_data_offsets_i915_request {};

struct trace_event_data_offsets_i915_request_queue {};

struct trace_event_data_offsets_i915_request_wait_begin {};

struct trace_event_data_offsets_i915_vma_bind {};

struct trace_event_data_offsets_i915_vma_unbind {};

struct trace_event_data_offsets_icmp_send {};

struct trace_event_data_offsets_inet_sk_error_report {};

struct trace_event_data_offsets_inet_sock_set_state {};

struct trace_event_data_offsets_initcall_finish {};

struct trace_event_data_offsets_initcall_level {
	u32 level;
	const void *level_ptr_;
};

struct trace_event_data_offsets_initcall_start {};

struct trace_event_data_offsets_intel_cpu_fifo_underrun {
	u32 dev;
	const void *dev_ptr_;
};

struct trace_event_data_offsets_intel_crtc_flip_done {
	u32 dev;
	const void *dev_ptr_;
};

struct trace_event_data_offsets_intel_crtc_vblank_work_end {
	u32 dev;
	const void *dev_ptr_;
};

struct trace_event_data_offsets_intel_crtc_vblank_work_start {
	u32 dev;
	const void *dev_ptr_;
};

struct trace_event_data_offsets_intel_fbc_activate {
	u32 dev;
	const void *dev_ptr_;
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_intel_fbc_deactivate {
	u32 dev;
	const void *dev_ptr_;
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_intel_fbc_nuke {
	u32 dev;
	const void *dev_ptr_;
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_intel_frontbuffer_flush {
	u32 dev;
	const void *dev_ptr_;
};

struct trace_event_data_offsets_intel_frontbuffer_invalidate {
	u32 dev;
	const void *dev_ptr_;
};

struct trace_event_data_offsets_intel_memory_cxsr {
	u32 dev;
	const void *dev_ptr_;
};

struct trace_event_data_offsets_intel_pch_fifo_underrun {
	u32 dev;
	const void *dev_ptr_;
};

struct trace_event_data_offsets_intel_pipe_crc {
	u32 dev;
	const void *dev_ptr_;
};

struct trace_event_data_offsets_intel_pipe_disable {
	u32 dev;
	const void *dev_ptr_;
};

struct trace_event_data_offsets_intel_pipe_enable {
	u32 dev;
	const void *dev_ptr_;
};

struct trace_event_data_offsets_intel_pipe_update_end {
	u32 dev;
	const void *dev_ptr_;
};

struct trace_event_data_offsets_intel_pipe_update_start {
	u32 dev;
	const void *dev_ptr_;
};

struct trace_event_data_offsets_intel_pipe_update_vblank_evaded {
	u32 dev;
	const void *dev_ptr_;
};

struct trace_event_data_offsets_intel_plane_async_flip {
	u32 dev;
	const void *dev_ptr_;
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_intel_plane_disable_arm {
	u32 dev;
	const void *dev_ptr_;
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_intel_plane_update_arm {
	u32 dev;
	const void *dev_ptr_;
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_intel_plane_update_noarm {
	u32 dev;
	const void *dev_ptr_;
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_io_uring_complete {};

struct trace_event_data_offsets_io_uring_cqe_overflow {};

struct trace_event_data_offsets_io_uring_cqring_wait {};

struct trace_event_data_offsets_io_uring_create {};

struct trace_event_data_offsets_io_uring_defer {
	u32 op_str;
	const void *op_str_ptr_;
};

struct trace_event_data_offsets_io_uring_fail_link {
	u32 op_str;
	const void *op_str_ptr_;
};

struct trace_event_data_offsets_io_uring_file_get {};

struct trace_event_data_offsets_io_uring_link {};

struct trace_event_data_offsets_io_uring_local_work_run {};

struct trace_event_data_offsets_io_uring_poll_arm {
	u32 op_str;
	const void *op_str_ptr_;
};

struct trace_event_data_offsets_io_uring_queue_async_work {
	u32 op_str;
	const void *op_str_ptr_;
};

struct trace_event_data_offsets_io_uring_register {};

struct trace_event_data_offsets_io_uring_req_failed {
	u32 op_str;
	const void *op_str_ptr_;
};

struct trace_event_data_offsets_io_uring_short_write {};

struct trace_event_data_offsets_io_uring_submit_req {
	u32 op_str;
	const void *op_str_ptr_;
};

struct trace_event_data_offsets_io_uring_task_add {
	u32 op_str;
	const void *op_str_ptr_;
};

struct trace_event_data_offsets_io_uring_task_work_run {};

struct trace_event_data_offsets_iocg_inuse_update {
	u32 devname;
	const void *devname_ptr_;
	u32 cgroup;
	const void *cgroup_ptr_;
};

struct trace_event_data_offsets_iocost_ioc_vrate_adj {
	u32 devname;
	const void *devname_ptr_;
};

struct trace_event_data_offsets_iocost_iocg_forgive_debt {
	u32 devname;
	const void *devname_ptr_;
	u32 cgroup;
	const void *cgroup_ptr_;
};

struct trace_event_data_offsets_iocost_iocg_state {
	u32 devname;
	const void *devname_ptr_;
	u32 cgroup;
	const void *cgroup_ptr_;
};

struct trace_event_data_offsets_iomap_class {};

struct trace_event_data_offsets_iomap_dio_complete {};

struct trace_event_data_offsets_iomap_dio_rw_begin {};

struct trace_event_data_offsets_iomap_iter {};

struct trace_event_data_offsets_iomap_range_class {};

struct trace_event_data_offsets_iomap_readpage_class {};

struct trace_event_data_offsets_iomap_writepage_map {};

struct trace_event_data_offsets_iommu_device_event {
	u32 device;
	const void *device_ptr_;
};

struct trace_event_data_offsets_iommu_error {
	u32 device;
	const void *device_ptr_;
	u32 driver;
	const void *driver_ptr_;
};

struct trace_event_data_offsets_iommu_group_event {
	u32 device;
	const void *device_ptr_;
};

struct trace_event_data_offsets_ipi_handler {};

struct trace_event_data_offsets_ipi_raise {
	u32 target_cpus;
	const void *target_cpus_ptr_;
};

struct trace_event_data_offsets_ipi_send_cpu {};

struct trace_event_data_offsets_ipi_send_cpumask {
	u32 cpumask;
	const void *cpumask_ptr_;
};

struct trace_event_data_offsets_irq_handler_entry {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_irq_handler_exit {};

struct trace_event_data_offsets_irq_matrix_cpu {};

struct trace_event_data_offsets_irq_matrix_global {};

struct trace_event_data_offsets_irq_matrix_global_update {};

struct trace_event_data_offsets_itimer_expire {};

struct trace_event_data_offsets_itimer_state {};

struct trace_event_data_offsets_jbd2_checkpoint {};

struct trace_event_data_offsets_jbd2_checkpoint_stats {};

struct trace_event_data_offsets_jbd2_commit {};

struct trace_event_data_offsets_jbd2_end_commit {};

struct trace_event_data_offsets_jbd2_handle_extend {};

struct trace_event_data_offsets_jbd2_handle_start_class {};

struct trace_event_data_offsets_jbd2_handle_stats {};

struct trace_event_data_offsets_jbd2_journal_shrink {};

struct trace_event_data_offsets_jbd2_lock_buffer_stall {};

struct trace_event_data_offsets_jbd2_run_stats {};

struct trace_event_data_offsets_jbd2_shrink_checkpoint_list {};

struct trace_event_data_offsets_jbd2_shrink_scan_exit {};

struct trace_event_data_offsets_jbd2_submit_inode_data {};

struct trace_event_data_offsets_jbd2_update_log_tail {};

struct trace_event_data_offsets_jbd2_write_superblock {};

struct trace_event_data_offsets_kcompactd_wake_template {};

struct trace_event_data_offsets_key_handle {};

struct trace_event_data_offsets_kfree {};

struct trace_event_data_offsets_kfree_skb {};

struct trace_event_data_offsets_kmalloc {};

struct trace_event_data_offsets_kmem_cache_alloc {};

struct trace_event_data_offsets_kmem_cache_free {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_kyber_adjust {};

struct trace_event_data_offsets_kyber_latency {};

struct trace_event_data_offsets_kyber_throttled {};

struct trace_event_data_offsets_leases_conflict {};

struct trace_event_data_offsets_link_station_add_mod {
	u32 supported_rates;
	const void *supported_rates_ptr_;
	u32 he_capa;
	const void *he_capa_ptr_;
	u32 eht_capa;
	const void *eht_capa_ptr_;
};

struct trace_event_data_offsets_local_chanctx {};

struct trace_event_data_offsets_local_only_evt {};

struct trace_event_data_offsets_local_sdata_addr_evt {
	u32 vif_name;
	const void *vif_name_ptr_;
};

struct trace_event_data_offsets_local_sdata_chanctx {
	u32 vif_name;
	const void *vif_name_ptr_;
};

struct trace_event_data_offsets_local_sdata_evt {
	u32 vif_name;
	const void *vif_name_ptr_;
};

struct trace_event_data_offsets_local_u32_evt {};

struct trace_event_data_offsets_locks_get_lock_context {};

struct trace_event_data_offsets_ma_op {};

struct trace_event_data_offsets_ma_read {};

struct trace_event_data_offsets_ma_write {};

struct trace_event_data_offsets_map {};

struct trace_event_data_offsets_mark_victim {
	u32 comm;
	const void *comm_ptr_;
};

struct trace_event_data_offsets_mce_record {
	u32 v_data;
	const void *v_data_ptr_;
};

struct trace_event_data_offsets_mdio_access {};

struct trace_event_data_offsets_mei_pci_cfg_read {
	u32 dev;
	const void *dev_ptr_;
};

struct trace_event_data_offsets_mei_reg_read {
	u32 dev;
	const void *dev_ptr_;
};

struct trace_event_data_offsets_mei_reg_write {
	u32 dev;
	const void *dev_ptr_;
};

struct trace_event_data_offsets_mem_connect {};

struct trace_event_data_offsets_mem_disconnect {};

struct trace_event_data_offsets_mem_return_failed {};

struct trace_event_data_offsets_mgd_prepare_complete_tx_evt {
	u32 vif_name;
	const void *vif_name_ptr_;
};

struct trace_event_data_offsets_migration_pte {};

struct trace_event_data_offsets_mm_alloc_contig_migrate_range_info {};

struct trace_event_data_offsets_mm_compaction_begin {};

struct trace_event_data_offsets_mm_compaction_defer_template {};

struct trace_event_data_offsets_mm_compaction_end {};

struct trace_event_data_offsets_mm_compaction_isolate_template {};

struct trace_event_data_offsets_mm_compaction_kcompactd_sleep {};

struct trace_event_data_offsets_mm_compaction_migratepages {};

struct trace_event_data_offsets_mm_compaction_suitable_template {};

struct trace_event_data_offsets_mm_compaction_try_to_compact_pages {};

struct trace_event_data_offsets_mm_filemap_fault {};

struct trace_event_data_offsets_mm_filemap_op_page_cache {};

struct trace_event_data_offsets_mm_filemap_op_page_cache_range {};

struct trace_event_data_offsets_mm_lru_activate {};

struct trace_event_data_offsets_mm_lru_insertion {};

struct trace_event_data_offsets_mm_migrate_pages {};

struct trace_event_data_offsets_mm_migrate_pages_start {};

struct trace_event_data_offsets_mm_page {};

struct trace_event_data_offsets_mm_page_alloc {};

struct trace_event_data_offsets_mm_page_alloc_extfrag {};

struct trace_event_data_offsets_mm_page_free {};

struct trace_event_data_offsets_mm_page_free_batched {};

struct trace_event_data_offsets_mm_page_pcpu_drain {};

struct trace_event_data_offsets_mm_shrink_slab_end {};

struct trace_event_data_offsets_mm_shrink_slab_start {};

struct trace_event_data_offsets_mm_vmscan_direct_reclaim_begin_template {};

struct trace_event_data_offsets_mm_vmscan_direct_reclaim_end_template {};

struct trace_event_data_offsets_mm_vmscan_kswapd_sleep {};

struct trace_event_data_offsets_mm_vmscan_kswapd_wake {};

struct trace_event_data_offsets_mm_vmscan_lru_isolate {};

struct trace_event_data_offsets_mm_vmscan_lru_shrink_active {};

struct trace_event_data_offsets_mm_vmscan_lru_shrink_inactive {};

struct trace_event_data_offsets_mm_vmscan_node_reclaim_begin {};

struct trace_event_data_offsets_mm_vmscan_reclaim_pages {};

struct trace_event_data_offsets_mm_vmscan_throttled {};

struct trace_event_data_offsets_mm_vmscan_wakeup_kswapd {};

struct trace_event_data_offsets_mm_vmscan_write_folio {};

struct trace_event_data_offsets_mmap_lock {};

struct trace_event_data_offsets_mmap_lock_acquire_returned {};

struct trace_event_data_offsets_module_free {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_module_load {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_module_refcnt {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_module_request {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_mpath_evt {};

struct trace_event_data_offsets_msr_trace_class {};

struct trace_event_data_offsets_napi_poll {
	u32 dev_name;
	const void *dev_name_ptr_;
};

struct trace_event_data_offsets_neigh__update {
	u32 dev;
	const void *dev_ptr_;
};

struct trace_event_data_offsets_neigh_create {
	u32 dev;
	const void *dev_ptr_;
};

struct trace_event_data_offsets_neigh_update {
	u32 dev;
	const void *dev_ptr_;
};

struct trace_event_data_offsets_net_dev_rx_exit_template {};

struct trace_event_data_offsets_net_dev_rx_verbose_template {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_net_dev_start_xmit {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_net_dev_template {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_net_dev_xmit {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_net_dev_xmit_timeout {
	u32 name;
	const void *name_ptr_;
	u32 driver;
	const void *driver_ptr_;
};

struct trace_event_data_offsets_netdev_evt_only {};

struct trace_event_data_offsets_netdev_frame_event {
	u32 frame;
	const void *frame_ptr_;
};

struct trace_event_data_offsets_netdev_mac_evt {};

struct trace_event_data_offsets_netfs_collect {};

struct trace_event_data_offsets_netfs_collect_folio {};

struct trace_event_data_offsets_netfs_collect_gap {};

struct trace_event_data_offsets_netfs_collect_sreq {};

struct trace_event_data_offsets_netfs_collect_state {};

struct trace_event_data_offsets_netfs_collect_stream {};

struct trace_event_data_offsets_netfs_failure {};

struct trace_event_data_offsets_netfs_folio {};

struct trace_event_data_offsets_netfs_folioq {};

struct trace_event_data_offsets_netfs_read {};

struct trace_event_data_offsets_netfs_rreq {};

struct trace_event_data_offsets_netfs_rreq_ref {};

struct trace_event_data_offsets_netfs_sreq {};

struct trace_event_data_offsets_netfs_sreq_ref {};

struct trace_event_data_offsets_netfs_write {};

struct trace_event_data_offsets_netfs_write_iter {};

struct trace_event_data_offsets_netlink_extack {
	u32 msg;
	const void *msg_ptr_;
};

struct trace_event_data_offsets_nfs4_cached_open {};

struct trace_event_data_offsets_nfs4_cb_error_class {};

struct trace_event_data_offsets_nfs4_clientid_event {
	u32 dstaddr;
	const void *dstaddr_ptr_;
};

struct trace_event_data_offsets_nfs4_close {};

struct trace_event_data_offsets_nfs4_commit_event {};

struct trace_event_data_offsets_nfs4_delegreturn_exit {};

struct trace_event_data_offsets_nfs4_getattr_event {};

struct trace_event_data_offsets_nfs4_idmap_event {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_nfs4_inode_callback_event {
	u32 dstaddr;
	const void *dstaddr_ptr_;
};

struct trace_event_data_offsets_nfs4_inode_event {};

struct trace_event_data_offsets_nfs4_inode_stateid_callback_event {
	u32 dstaddr;
	const void *dstaddr_ptr_;
};

struct trace_event_data_offsets_nfs4_inode_stateid_event {};

struct trace_event_data_offsets_nfs4_lock_event {};

struct trace_event_data_offsets_nfs4_lookup_event {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_nfs4_lookupp {};

struct trace_event_data_offsets_nfs4_open_event {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_nfs4_read_event {};

struct trace_event_data_offsets_nfs4_rename {
	u32 oldname;
	const void *oldname_ptr_;
	u32 newname;
	const void *newname_ptr_;
};

struct trace_event_data_offsets_nfs4_set_delegation_event {};

struct trace_event_data_offsets_nfs4_set_lock {};

struct trace_event_data_offsets_nfs4_setup_sequence {};

struct trace_event_data_offsets_nfs4_state_lock_reclaim {};

struct trace_event_data_offsets_nfs4_state_mgr {
	u32 hostname;
	const void *hostname_ptr_;
};

struct trace_event_data_offsets_nfs4_state_mgr_failed {
	u32 hostname;
	const void *hostname_ptr_;
	u32 section;
	const void *section_ptr_;
};

struct trace_event_data_offsets_nfs4_write_event {};

struct trace_event_data_offsets_nfs4_xdr_bad_operation {};

struct trace_event_data_offsets_nfs4_xdr_event {};

struct trace_event_data_offsets_nfs_access_exit {};

struct trace_event_data_offsets_nfs_aop_readahead {};

struct trace_event_data_offsets_nfs_aop_readahead_done {};

struct trace_event_data_offsets_nfs_atomic_open_enter {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_nfs_atomic_open_exit {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_nfs_commit_done {};

struct trace_event_data_offsets_nfs_create_enter {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_nfs_create_exit {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_nfs_direct_req_class {};

struct trace_event_data_offsets_nfs_directory_event {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_nfs_directory_event_done {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_nfs_fh_to_dentry {};

struct trace_event_data_offsets_nfs_folio_event {};

struct trace_event_data_offsets_nfs_folio_event_done {};

struct trace_event_data_offsets_nfs_initiate_commit {};

struct trace_event_data_offsets_nfs_initiate_read {};

struct trace_event_data_offsets_nfs_initiate_write {};

struct trace_event_data_offsets_nfs_inode_event {};

struct trace_event_data_offsets_nfs_inode_event_done {};

struct trace_event_data_offsets_nfs_inode_range_event {};

struct trace_event_data_offsets_nfs_link_enter {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_nfs_link_exit {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_nfs_local_open_fh {};

struct trace_event_data_offsets_nfs_lookup_event {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_nfs_lookup_event_done {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_nfs_mount_assign {
	u32 option;
	const void *option_ptr_;
	u32 value;
	const void *value_ptr_;
};

struct trace_event_data_offsets_nfs_mount_option {
	u32 option;
	const void *option_ptr_;
};

struct trace_event_data_offsets_nfs_mount_path {
	u32 path;
	const void *path_ptr_;
};

struct trace_event_data_offsets_nfs_page_error_class {};

struct trace_event_data_offsets_nfs_pgio_error {};

struct trace_event_data_offsets_nfs_readdir_event {};

struct trace_event_data_offsets_nfs_readpage_done {};

struct trace_event_data_offsets_nfs_readpage_short {};

struct trace_event_data_offsets_nfs_rename_event {
	u32 old_name;
	const void *old_name_ptr_;
	u32 new_name;
	const void *new_name_ptr_;
};

struct trace_event_data_offsets_nfs_rename_event_done {
	u32 old_name;
	const void *old_name_ptr_;
	u32 new_name;
	const void *new_name_ptr_;
};

struct trace_event_data_offsets_nfs_sillyrename_unlink {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_nfs_update_size_class {};

struct trace_event_data_offsets_nfs_writeback_done {};

struct trace_event_data_offsets_nfs_xdr_event {
	u32 program;
	const void *program_ptr_;
	u32 procedure;
	const void *procedure_ptr_;
};

struct trace_event_data_offsets_nlmclnt_lock_event {
	u32 addr;
	const void *addr_ptr_;
};

struct trace_event_data_offsets_nmi_handler {};

struct trace_event_data_offsets_notifier_info {};

struct trace_event_data_offsets_oom_score_adj_update {};

struct trace_event_data_offsets_page_pool_release {};

struct trace_event_data_offsets_page_pool_state_hold {};

struct trace_event_data_offsets_page_pool_state_release {};

struct trace_event_data_offsets_page_pool_update_nid {};

struct trace_event_data_offsets_percpu_alloc_percpu {};

struct trace_event_data_offsets_percpu_alloc_percpu_fail {};

struct trace_event_data_offsets_percpu_create_chunk {};

struct trace_event_data_offsets_percpu_destroy_chunk {};

struct trace_event_data_offsets_percpu_free_percpu {};

struct trace_event_data_offsets_pm_qos_update {};

struct trace_event_data_offsets_pmap_register {};

struct trace_event_data_offsets_power_domain {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_powernv_throttle {
	u32 reason;
	const void *reason_ptr_;
};

struct trace_event_data_offsets_prq_report {
	u32 iommu;
	const void *iommu_ptr_;
	u32 dev;
	const void *dev_ptr_;
	u32 buff;
	const void *buff_ptr_;
};

struct trace_event_data_offsets_pstate_sample {};

struct trace_event_data_offsets_purge_vmap_area_lazy {};

struct trace_event_data_offsets_qdisc_create {
	u32 dev;
	const void *dev_ptr_;
	u32 kind;
	const void *kind_ptr_;
};

struct trace_event_data_offsets_qdisc_dequeue {};

struct trace_event_data_offsets_qdisc_destroy {
	u32 dev;
	const void *dev_ptr_;
	u32 kind;
	const void *kind_ptr_;
};

struct trace_event_data_offsets_qdisc_enqueue {};

struct trace_event_data_offsets_qdisc_reset {
	u32 dev;
	const void *dev_ptr_;
	u32 kind;
	const void *kind_ptr_;
};

struct trace_event_data_offsets_qi_submit {
	u32 iommu;
	const void *iommu_ptr_;
};

struct trace_event_data_offsets_rcu_barrier {};

struct trace_event_data_offsets_rcu_batch_end {};

struct trace_event_data_offsets_rcu_batch_start {};

struct trace_event_data_offsets_rcu_callback {};

struct trace_event_data_offsets_rcu_exp_funnel_lock {};

struct trace_event_data_offsets_rcu_exp_grace_period {};

struct trace_event_data_offsets_rcu_fqs {};

struct trace_event_data_offsets_rcu_future_grace_period {};

struct trace_event_data_offsets_rcu_grace_period {};

struct trace_event_data_offsets_rcu_grace_period_init {};

struct trace_event_data_offsets_rcu_invoke_callback {};

struct trace_event_data_offsets_rcu_invoke_kfree_bulk_callback {};

struct trace_event_data_offsets_rcu_invoke_kvfree_callback {};

struct trace_event_data_offsets_rcu_kvfree_callback {};

struct trace_event_data_offsets_rcu_preempt_task {};

struct trace_event_data_offsets_rcu_quiescent_state_report {};

struct trace_event_data_offsets_rcu_segcb_stats {};

struct trace_event_data_offsets_rcu_sr_normal {};

struct trace_event_data_offsets_rcu_stall_warning {};

struct trace_event_data_offsets_rcu_torture_read {};

struct trace_event_data_offsets_rcu_unlock_preempted_task {};

struct trace_event_data_offsets_rcu_utilization {};

struct trace_event_data_offsets_rcu_watching {};

struct trace_event_data_offsets_rdev_add_key {};

struct trace_event_data_offsets_rdev_add_nan_func {};

struct trace_event_data_offsets_rdev_add_tx_ts {};

struct trace_event_data_offsets_rdev_add_virtual_intf {
	u32 vir_intf_name;
	const void *vir_intf_name_ptr_;
};

struct trace_event_data_offsets_rdev_assoc {
	u32 elements;
	const void *elements_ptr_;
	u32 fils_kek;
	const void *fils_kek_ptr_;
	u32 fils_nonces;
	const void *fils_nonces_ptr_;
};

struct trace_event_data_offsets_rdev_assoc_ml_reconf {};

struct trace_event_data_offsets_rdev_auth {};

struct trace_event_data_offsets_rdev_cancel_remain_on_channel {};

struct trace_event_data_offsets_rdev_change_beacon {
	u32 head;
	const void *head_ptr_;
	u32 tail;
	const void *tail_ptr_;
	u32 beacon_ies;
	const void *beacon_ies_ptr_;
	u32 proberesp_ies;
	const void *proberesp_ies_ptr_;
	u32 assocresp_ies;
	const void *assocresp_ies_ptr_;
	u32 probe_resp;
	const void *probe_resp_ptr_;
};

struct trace_event_data_offsets_rdev_change_bss {};

struct trace_event_data_offsets_rdev_change_virtual_intf {};

struct trace_event_data_offsets_rdev_channel_switch {
	u32 bcn_ofs;
	const void *bcn_ofs_ptr_;
	u32 pres_ofs;
	const void *pres_ofs_ptr_;
};

struct trace_event_data_offsets_rdev_color_change {};

struct trace_event_data_offsets_rdev_connect {};

struct trace_event_data_offsets_rdev_crit_proto_start {};

struct trace_event_data_offsets_rdev_crit_proto_stop {};

struct trace_event_data_offsets_rdev_deauth {};

struct trace_event_data_offsets_rdev_del_link_station {};

struct trace_event_data_offsets_rdev_del_nan_func {};

struct trace_event_data_offsets_rdev_del_pmk {};

struct trace_event_data_offsets_rdev_del_tx_ts {};

struct trace_event_data_offsets_rdev_disassoc {};

struct trace_event_data_offsets_rdev_disconnect {};

struct trace_event_data_offsets_rdev_dump_mpath {};

struct trace_event_data_offsets_rdev_dump_mpp {};

struct trace_event_data_offsets_rdev_dump_station {};

struct trace_event_data_offsets_rdev_dump_survey {};

struct trace_event_data_offsets_rdev_end_cac {};

struct trace_event_data_offsets_rdev_external_auth {};

struct trace_event_data_offsets_rdev_get_ftm_responder_stats {};

struct trace_event_data_offsets_rdev_get_mpp {};

struct trace_event_data_offsets_rdev_inform_bss {};

struct trace_event_data_offsets_rdev_join_ibss {};

struct trace_event_data_offsets_rdev_join_mesh {};

struct trace_event_data_offsets_rdev_join_ocb {};

struct trace_event_data_offsets_rdev_libertas_set_mesh_channel {};

struct trace_event_data_offsets_rdev_mgmt_tx {};

struct trace_event_data_offsets_rdev_mgmt_tx_cancel_wait {};

struct trace_event_data_offsets_rdev_nan_change_conf {};

struct trace_event_data_offsets_rdev_pmksa {};

struct trace_event_data_offsets_rdev_probe_client {};

struct trace_event_data_offsets_rdev_probe_mesh_link {};

struct trace_event_data_offsets_rdev_remain_on_channel {};

struct trace_event_data_offsets_rdev_reset_tid_config {};

struct trace_event_data_offsets_rdev_return_chandef {};

struct trace_event_data_offsets_rdev_return_int {};

struct trace_event_data_offsets_rdev_return_int_cookie {};

struct trace_event_data_offsets_rdev_return_int_int {};

struct trace_event_data_offsets_rdev_return_int_mesh_config {};

struct trace_event_data_offsets_rdev_return_int_mpath_info {};

struct trace_event_data_offsets_rdev_return_int_station_info {};

struct trace_event_data_offsets_rdev_return_int_survey_info {};

struct trace_event_data_offsets_rdev_return_int_tx_rx {};

struct trace_event_data_offsets_rdev_return_void_tx_rx {};

struct trace_event_data_offsets_rdev_scan {};

struct trace_event_data_offsets_rdev_set_ap_chanwidth {};

struct trace_event_data_offsets_rdev_set_bitrate_mask {};

struct trace_event_data_offsets_rdev_set_coalesce {};

struct trace_event_data_offsets_rdev_set_cqm_rssi_config {};

struct trace_event_data_offsets_rdev_set_cqm_rssi_range_config {};

struct trace_event_data_offsets_rdev_set_cqm_txe_config {};

struct trace_event_data_offsets_rdev_set_default_beacon_key {};

struct trace_event_data_offsets_rdev_set_default_key {};

struct trace_event_data_offsets_rdev_set_default_mgmt_key {};

struct trace_event_data_offsets_rdev_set_epcs {};

struct trace_event_data_offsets_rdev_set_fils_aad {};

struct trace_event_data_offsets_rdev_set_hw_timestamp {};

struct trace_event_data_offsets_rdev_set_mac_acl {};

struct trace_event_data_offsets_rdev_set_mcast_rate {};

struct trace_event_data_offsets_rdev_set_monitor_channel {};

struct trace_event_data_offsets_rdev_set_multicast_to_unicast {};

struct trace_event_data_offsets_rdev_set_noack_map {};

struct trace_event_data_offsets_rdev_set_pmk {
	u32 pmk;
	const void *pmk_ptr_;
	u32 pmk_r0_name;
	const void *pmk_r0_name_ptr_;
};

struct trace_event_data_offsets_rdev_set_power_mgmt {};

struct trace_event_data_offsets_rdev_set_qos_map {};

struct trace_event_data_offsets_rdev_set_radar_background {};

struct trace_event_data_offsets_rdev_set_sar_specs {};

struct trace_event_data_offsets_rdev_set_tid_config {};

struct trace_event_data_offsets_rdev_set_ttlm {};

struct trace_event_data_offsets_rdev_set_tx_power {};

struct trace_event_data_offsets_rdev_set_txq_params {};

struct trace_event_data_offsets_rdev_set_wiphy_params {};

struct trace_event_data_offsets_rdev_start_ap {};

struct trace_event_data_offsets_rdev_start_nan {};

struct trace_event_data_offsets_rdev_start_radar_detection {};

struct trace_event_data_offsets_rdev_stop_ap {};

struct trace_event_data_offsets_rdev_suspend {};

struct trace_event_data_offsets_rdev_tdls_cancel_channel_switch {};

struct trace_event_data_offsets_rdev_tdls_channel_switch {};

struct trace_event_data_offsets_rdev_tdls_mgmt {
	u32 buf;
	const void *buf_ptr_;
};

struct trace_event_data_offsets_rdev_tdls_oper {};

struct trace_event_data_offsets_rdev_tx_control_port {};

struct trace_event_data_offsets_rdev_update_connect_params {};

struct trace_event_data_offsets_rdev_update_ft_ies {
	u32 ie;
	const void *ie_ptr_;
};

struct trace_event_data_offsets_rdev_update_mesh_config {};

struct trace_event_data_offsets_rdev_update_mgmt_frame_registrations {};

struct trace_event_data_offsets_rdev_update_owe_info {
	u32 ie;
	const void *ie_ptr_;
};

struct trace_event_data_offsets_reclaim_retry_zone {};

struct trace_event_data_offsets_regcache_drop_region {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_regcache_sync {
	u32 name;
	const void *name_ptr_;
	u32 status;
	const void *status_ptr_;
	u32 type;
	const void *type_ptr_;
};

struct trace_event_data_offsets_register_class {
	u32 program;
	const void *program_ptr_;
};

struct trace_event_data_offsets_regmap_async {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_regmap_block {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_regmap_bool {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_regmap_bulk {
	u32 name;
	const void *name_ptr_;
	u32 buf;
	const void *buf_ptr_;
};

struct trace_event_data_offsets_regmap_reg {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_release_evt {};

struct trace_event_data_offsets_rpc_buf_alloc {};

struct trace_event_data_offsets_rpc_call_rpcerror {};

struct trace_event_data_offsets_rpc_clnt_class {};

struct trace_event_data_offsets_rpc_clnt_clone_err {};

struct trace_event_data_offsets_rpc_clnt_new {
	u32 program;
	const void *program_ptr_;
	u32 server;
	const void *server_ptr_;
	u32 addr;
	const void *addr_ptr_;
	u32 port;
	const void *port_ptr_;
};

struct trace_event_data_offsets_rpc_clnt_new_err {
	u32 program;
	const void *program_ptr_;
	u32 server;
	const void *server_ptr_;
};

struct trace_event_data_offsets_rpc_failure {};

struct trace_event_data_offsets_rpc_reply_event {
	u32 progname;
	const void *progname_ptr_;
	u32 procname;
	const void *procname_ptr_;
	u32 servername;
	const void *servername_ptr_;
};

struct trace_event_data_offsets_rpc_request {
	u32 progname;
	const void *progname_ptr_;
	u32 procname;
	const void *procname_ptr_;
};

struct trace_event_data_offsets_rpc_socket_nospace {};

struct trace_event_data_offsets_rpc_stats_latency {
	u32 progname;
	const void *progname_ptr_;
	u32 procname;
	const void *procname_ptr_;
};

struct trace_event_data_offsets_rpc_task_queued {
	u32 q_name;
	const void *q_name_ptr_;
};

struct trace_event_data_offsets_rpc_task_running {};

struct trace_event_data_offsets_rpc_task_status {};

struct trace_event_data_offsets_rpc_tls_class {
	u32 servername;
	const void *servername_ptr_;
	u32 progname;
	const void *progname_ptr_;
};

struct trace_event_data_offsets_rpc_xdr_alignment {
	u32 progname;
	const void *progname_ptr_;
	u32 procedure;
	const void *procedure_ptr_;
};

struct trace_event_data_offsets_rpc_xdr_buf_class {};

struct trace_event_data_offsets_rpc_xdr_overflow {
	u32 progname;
	const void *progname_ptr_;
	u32 procedure;
	const void *procedure_ptr_;
};

struct trace_event_data_offsets_rpc_xprt_event {
	u32 addr;
	const void *addr_ptr_;
	u32 port;
	const void *port_ptr_;
};

struct trace_event_data_offsets_rpc_xprt_lifetime_class {
	u32 addr;
	const void *addr_ptr_;
	u32 port;
	const void *port_ptr_;
};

struct trace_event_data_offsets_rpcb_getport {
	u32 servername;
	const void *servername_ptr_;
};

struct trace_event_data_offsets_rpcb_register {
	u32 addr;
	const void *addr_ptr_;
	u32 netid;
	const void *netid_ptr_;
};

struct trace_event_data_offsets_rpcb_setport {};

struct trace_event_data_offsets_rpcb_unregister {
	u32 netid;
	const void *netid_ptr_;
};

struct trace_event_data_offsets_rpcgss_bad_seqno {};

struct trace_event_data_offsets_rpcgss_context {
	u32 acceptor;
	const void *acceptor_ptr_;
};

struct trace_event_data_offsets_rpcgss_createauth {};

struct trace_event_data_offsets_rpcgss_ctx_class {
	u32 principal;
	const void *principal_ptr_;
};

struct trace_event_data_offsets_rpcgss_gssapi_event {};

struct trace_event_data_offsets_rpcgss_import_ctx {};

struct trace_event_data_offsets_rpcgss_need_reencode {};

struct trace_event_data_offsets_rpcgss_oid_to_mech {
	u32 oid;
	const void *oid_ptr_;
};

struct trace_event_data_offsets_rpcgss_seqno {};

struct trace_event_data_offsets_rpcgss_svc_accept_upcall {
	u32 addr;
	const void *addr_ptr_;
};

struct trace_event_data_offsets_rpcgss_svc_authenticate {
	u32 addr;
	const void *addr_ptr_;
};

struct trace_event_data_offsets_rpcgss_svc_gssapi_class {
	u32 addr;
	const void *addr_ptr_;
};

struct trace_event_data_offsets_rpcgss_svc_seqno_bad {
	u32 addr;
	const void *addr_ptr_;
};

struct trace_event_data_offsets_rpcgss_svc_seqno_class {};

struct trace_event_data_offsets_rpcgss_svc_seqno_low {};

struct trace_event_data_offsets_rpcgss_svc_unwrap_failed {
	u32 addr;
	const void *addr_ptr_;
};

struct trace_event_data_offsets_rpcgss_svc_wrap_failed {
	u32 addr;
	const void *addr_ptr_;
};

struct trace_event_data_offsets_rpcgss_unwrap_failed {};

struct trace_event_data_offsets_rpcgss_upcall_msg {
	u32 msg;
	const void *msg_ptr_;
};

struct trace_event_data_offsets_rpcgss_upcall_result {};

struct trace_event_data_offsets_rpcgss_update_slack {};

struct trace_event_data_offsets_rpm_internal {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_rpm_return_int {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_rpm_status {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_rseq_ip_fixup {};

struct trace_event_data_offsets_rseq_update {};

struct trace_event_data_offsets_rss_stat {};

struct trace_event_data_offsets_rtc_alarm_irq_enable {};

struct trace_event_data_offsets_rtc_irq_set_freq {};

struct trace_event_data_offsets_rtc_irq_set_state {};

struct trace_event_data_offsets_rtc_offset_class {};

struct trace_event_data_offsets_rtc_time_alarm_class {};

struct trace_event_data_offsets_rtc_timer_class {};

struct trace_event_data_offsets_sched_kthread_stop {};

struct trace_event_data_offsets_sched_kthread_stop_ret {};

struct trace_event_data_offsets_sched_kthread_work_execute_end {};

struct trace_event_data_offsets_sched_kthread_work_execute_start {};

struct trace_event_data_offsets_sched_kthread_work_queue_work {};

struct trace_event_data_offsets_sched_migrate_task {};

struct trace_event_data_offsets_sched_move_numa {};

struct trace_event_data_offsets_sched_numa_pair_template {};

struct trace_event_data_offsets_sched_pi_setprio {};

struct trace_event_data_offsets_sched_prepare_exec {
	u32 interp;
	const void *interp_ptr_;
	u32 filename;
	const void *filename_ptr_;
	u32 comm;
	const void *comm_ptr_;
};

struct trace_event_data_offsets_sched_process_exec {
	u32 filename;
	const void *filename_ptr_;
};

struct trace_event_data_offsets_sched_process_fork {};

struct trace_event_data_offsets_sched_process_template {};

struct trace_event_data_offsets_sched_process_wait {};

struct trace_event_data_offsets_sched_stat_runtime {};

struct trace_event_data_offsets_sched_stat_template {};

struct trace_event_data_offsets_sched_switch {};

struct trace_event_data_offsets_sched_wake_idle_without_ipi {};

struct trace_event_data_offsets_sched_wakeup_template {};

struct trace_event_data_offsets_scsi_cmd_done_timeout_template {
	u32 cmnd;
	const void *cmnd_ptr_;
};

struct trace_event_data_offsets_scsi_dispatch_cmd_error {
	u32 cmnd;
	const void *cmnd_ptr_;
};

struct trace_event_data_offsets_scsi_dispatch_cmd_start {
	u32 cmnd;
	const void *cmnd_ptr_;
};

struct trace_event_data_offsets_scsi_eh_wakeup {};

struct trace_event_data_offsets_selinux_audited {
	u32 scontext;
	const void *scontext_ptr_;
	u32 tcontext;
	const void *tcontext_ptr_;
	u32 tclass;
	const void *tclass_ptr_;
};

struct trace_event_data_offsets_signal_deliver {};

struct trace_event_data_offsets_signal_generate {};

struct trace_event_data_offsets_sk_data_ready {};

struct trace_event_data_offsets_skb_copy_datagram_iovec {};

struct trace_event_data_offsets_skip_task_reaping {};

struct trace_event_data_offsets_smbus_read {};

struct trace_event_data_offsets_smbus_reply {};

struct trace_event_data_offsets_smbus_result {};

struct trace_event_data_offsets_smbus_write {};

struct trace_event_data_offsets_sock_exceed_buf_limit {};

struct trace_event_data_offsets_sock_msg_length {};

struct trace_event_data_offsets_sock_rcvqueue_full {};

struct trace_event_data_offsets_softirq {};

struct trace_event_data_offsets_sta_event {
	u32 vif_name;
	const void *vif_name_ptr_;
};

struct trace_event_data_offsets_sta_flag_evt {
	u32 vif_name;
	const void *vif_name_ptr_;
};

struct trace_event_data_offsets_start_task_reaping {};

struct trace_event_data_offsets_station_add_change {
	u32 supported_rates;
	const void *supported_rates_ptr_;
	u32 ext_capab;
	const void *ext_capab_ptr_;
	u32 supported_channels;
	const void *supported_channels_ptr_;
	u32 supported_oper_classes;
	const void *supported_oper_classes_ptr_;
};

struct trace_event_data_offsets_station_del {};

struct trace_event_data_offsets_stop_queue {};

struct trace_event_data_offsets_suspend_resume {};

struct trace_event_data_offsets_svc_alloc_arg_err {};

struct trace_event_data_offsets_svc_authenticate {
	u32 server;
	const void *server_ptr_;
	u32 client;
	const void *client_ptr_;
};

struct trace_event_data_offsets_svc_deferred_event {
	u32 addr;
	const void *addr_ptr_;
};

struct trace_event_data_offsets_svc_process {
	u32 service;
	const void *service_ptr_;
	u32 procedure;
	const void *procedure_ptr_;
	u32 addr;
	const void *addr_ptr_;
};

struct trace_event_data_offsets_svc_replace_page_err {
	u32 server;
	const void *server_ptr_;
	u32 client;
	const void *client_ptr_;
};

struct trace_event_data_offsets_svc_rqst_event {
	u32 server;
	const void *server_ptr_;
	u32 client;
	const void *client_ptr_;
};

struct trace_event_data_offsets_svc_rqst_status {
	u32 server;
	const void *server_ptr_;
	u32 client;
	const void *client_ptr_;
};

struct trace_event_data_offsets_svc_stats_latency {
	u32 server;
	const void *server_ptr_;
	u32 client;
	const void *client_ptr_;
	u32 procedure;
	const void *procedure_ptr_;
};

struct trace_event_data_offsets_svc_unregister {
	u32 program;
	const void *program_ptr_;
};

struct trace_event_data_offsets_svc_wake_up {};

struct trace_event_data_offsets_svc_xdr_buf_class {};

struct trace_event_data_offsets_svc_xdr_msg_class {};

struct trace_event_data_offsets_svc_xprt_accept {
	u32 server;
	const void *server_ptr_;
	u32 client;
	const void *client_ptr_;
	u32 protocol;
	const void *protocol_ptr_;
	u32 service;
	const void *service_ptr_;
};

struct trace_event_data_offsets_svc_xprt_create_err {
	u32 program;
	const void *program_ptr_;
	u32 protocol;
	const void *protocol_ptr_;
	u32 addr;
	const void *addr_ptr_;
};

struct trace_event_data_offsets_svc_xprt_dequeue {
	u32 server;
	const void *server_ptr_;
	u32 client;
	const void *client_ptr_;
};

struct trace_event_data_offsets_svc_xprt_enqueue {
	u32 server;
	const void *server_ptr_;
	u32 client;
	const void *client_ptr_;
};

struct trace_event_data_offsets_svc_xprt_event {
	u32 server;
	const void *server_ptr_;
	u32 client;
	const void *client_ptr_;
};

struct trace_event_data_offsets_svcsock_accept_class {
	u32 service;
	const void *service_ptr_;
};

struct trace_event_data_offsets_svcsock_class {
	u32 addr;
	const void *addr_ptr_;
};

struct trace_event_data_offsets_svcsock_lifetime_class {};

struct trace_event_data_offsets_svcsock_marker {
	u32 addr;
	const void *addr_ptr_;
};

struct trace_event_data_offsets_svcsock_tcp_recv_short {
	u32 addr;
	const void *addr_ptr_;
};

struct trace_event_data_offsets_svcsock_tcp_state {
	u32 addr;
	const void *addr_ptr_;
};

struct trace_event_data_offsets_swiotlb_bounced {
	u32 dev_name;
	const void *dev_name_ptr_;
};

struct trace_event_data_offsets_sys_enter {};

struct trace_event_data_offsets_sys_exit {};

struct trace_event_data_offsets_task_newtask {};

struct trace_event_data_offsets_task_prctl_unknown {};

struct trace_event_data_offsets_task_rename {};

struct trace_event_data_offsets_tasklet {};

struct trace_event_data_offsets_tcp_ao_event {};

struct trace_event_data_offsets_tcp_ao_event_sk {};

struct trace_event_data_offsets_tcp_ao_event_sne {};

struct trace_event_data_offsets_tcp_cong_state_set {};

struct trace_event_data_offsets_tcp_event_sk {};

struct trace_event_data_offsets_tcp_event_sk_skb {};

struct trace_event_data_offsets_tcp_event_skb {};

struct trace_event_data_offsets_tcp_hash_event {};

struct trace_event_data_offsets_tcp_probe {};

struct trace_event_data_offsets_tcp_retransmit_synack {};

struct trace_event_data_offsets_tcp_send_reset {};

struct trace_event_data_offsets_thermal_temperature {
	u32 thermal_zone;
	const void *thermal_zone_ptr_;
};

struct trace_event_data_offsets_thermal_zone_trip {
	u32 thermal_zone;
	const void *thermal_zone_ptr_;
};

struct trace_event_data_offsets_tick_stop {};

struct trace_event_data_offsets_timer_base_idle {};

struct trace_event_data_offsets_timer_class {};

struct trace_event_data_offsets_timer_expire_entry {};

struct trace_event_data_offsets_timer_start {};

struct trace_event_data_offsets_tlb_flush {};

struct trace_event_data_offsets_tls_contenttype {};

struct trace_event_data_offsets_tmigr_connect_child_parent {};

struct trace_event_data_offsets_tmigr_connect_cpu_parent {};

struct trace_event_data_offsets_tmigr_cpugroup {};

struct trace_event_data_offsets_tmigr_group_and_cpu {};

struct trace_event_data_offsets_tmigr_group_set {};

struct trace_event_data_offsets_tmigr_handle_remote {};

struct trace_event_data_offsets_tmigr_idle {};

struct trace_event_data_offsets_tmigr_update_events {};

struct trace_event_data_offsets_tx_rx_evt {};

struct trace_event_data_offsets_udp_fail_queue_rcv_skb {};

struct trace_event_data_offsets_unmap {};

struct trace_event_data_offsets_vector_activate {};

struct trace_event_data_offsets_vector_alloc {};

struct trace_event_data_offsets_vector_alloc_managed {};

struct trace_event_data_offsets_vector_config {};

struct trace_event_data_offsets_vector_free_moved {};

struct trace_event_data_offsets_vector_mod {};

struct trace_event_data_offsets_vector_reserve {};

struct trace_event_data_offsets_vector_setup {};

struct trace_event_data_offsets_vector_teardown {};

struct trace_event_data_offsets_virtio_gpu_cmd {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_vlv_fifo_size {
	u32 dev;
	const void *dev_ptr_;
};

struct trace_event_data_offsets_vlv_wm {
	u32 dev;
	const void *dev_ptr_;
};

struct trace_event_data_offsets_vm_unmapped_area {};

struct trace_event_data_offsets_vma_mas_szero {};

struct trace_event_data_offsets_vma_store {};

struct trace_event_data_offsets_wake_queue {};

struct trace_event_data_offsets_wake_reaper {};

struct trace_event_data_offsets_wakeup_source {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_wbc_class {};

struct trace_event_data_offsets_wiphy_delayed_work_queue {};

struct trace_event_data_offsets_wiphy_enabled_evt {};

struct trace_event_data_offsets_wiphy_id_evt {};

struct trace_event_data_offsets_wiphy_netdev_evt {};

struct trace_event_data_offsets_wiphy_netdev_id_evt {};

struct trace_event_data_offsets_wiphy_netdev_mac_evt {};

struct trace_event_data_offsets_wiphy_only_evt {};

struct trace_event_data_offsets_wiphy_wdev_cookie_evt {};

struct trace_event_data_offsets_wiphy_wdev_evt {};

struct trace_event_data_offsets_wiphy_wdev_link_evt {};

struct trace_event_data_offsets_wiphy_work_event {};

struct trace_event_data_offsets_wiphy_work_worker_start {};

struct trace_event_data_offsets_workqueue_activate_work {};

struct trace_event_data_offsets_workqueue_execute_end {};

struct trace_event_data_offsets_workqueue_execute_start {};

struct trace_event_data_offsets_workqueue_queue_work {
	u32 workqueue;
	const void *workqueue_ptr_;
};

struct trace_event_data_offsets_writeback_bdi_register {};

struct trace_event_data_offsets_writeback_class {};

struct trace_event_data_offsets_writeback_dirty_inode_template {};

struct trace_event_data_offsets_writeback_folio_template {};

struct trace_event_data_offsets_writeback_inode_template {};

struct trace_event_data_offsets_writeback_pages_written {};

struct trace_event_data_offsets_writeback_queue_io {};

struct trace_event_data_offsets_writeback_sb_inodes_requeue {};

struct trace_event_data_offsets_writeback_single_inode_template {};

struct trace_event_data_offsets_writeback_work_class {};

struct trace_event_data_offsets_writeback_write_inode_template {};

struct trace_event_data_offsets_x86_exceptions {};

struct trace_event_data_offsets_x86_fpu {};

struct trace_event_data_offsets_x86_irq_vector {};

struct trace_event_data_offsets_xdp_bulk_tx {};

struct trace_event_data_offsets_xdp_cpumap_enqueue {};

struct trace_event_data_offsets_xdp_cpumap_kthread {};

struct trace_event_data_offsets_xdp_devmap_xmit {};

struct trace_event_data_offsets_xdp_exception {};

struct trace_event_data_offsets_xdp_redirect_template {};

struct trace_event_data_offsets_xhci_dbc_log_request {};

struct trace_event_data_offsets_xhci_log_ctrl_ctx {};

struct trace_event_data_offsets_xhci_log_ctx {
	u32 ctx_data;
	const void *ctx_data_ptr_;
};

struct trace_event_data_offsets_xhci_log_doorbell {};

struct trace_event_data_offsets_xhci_log_ep_ctx {};

struct trace_event_data_offsets_xhci_log_free_virt_dev {};

struct trace_event_data_offsets_xhci_log_msg {
	u32 msg;
	const void *msg_ptr_;
};

struct trace_event_data_offsets_xhci_log_portsc {};

struct trace_event_data_offsets_xhci_log_ring {};

struct trace_event_data_offsets_xhci_log_slot_ctx {};

struct trace_event_data_offsets_xhci_log_stream_ctx {};

struct trace_event_data_offsets_xhci_log_trb {};

struct trace_event_data_offsets_xhci_log_urb {
	u32 devname;
	const void *devname_ptr_;
};

struct trace_event_data_offsets_xhci_log_virt_dev {};

struct trace_event_data_offsets_xprt_cong_event {};

struct trace_event_data_offsets_xprt_ping {
	u32 addr;
	const void *addr_ptr_;
	u32 port;
	const void *port_ptr_;
};

struct trace_event_data_offsets_xprt_reserve {};

struct trace_event_data_offsets_xprt_retransmit {
	u32 progname;
	const void *progname_ptr_;
	u32 procname;
	const void *procname_ptr_;
};

struct trace_event_data_offsets_xprt_transmit {};

struct trace_event_data_offsets_xprt_writelock_event {};

struct trace_event_data_offsets_xs_data_ready {
	u32 addr;
	const void *addr_ptr_;
	u32 port;
	const void *port_ptr_;
};

struct trace_event_data_offsets_xs_socket_event {};

struct trace_event_data_offsets_xs_socket_event_done {};

struct trace_event_data_offsets_xs_stream_read_data {
	u32 addr;
	const void *addr_ptr_;
	u32 port;
	const void *port_ptr_;
};

struct trace_event_data_offsets_xs_stream_read_request {
	u32 addr;
	const void *addr_ptr_;
	u32 port;
	const void *port_ptr_;
};

struct trace_event_fields {
	const char *type;
	union {
		struct {
			const char *name;
			const int size;
			const int align;
			const unsigned int is_signed: 1;
			unsigned int needs_test: 1;
			const int filter_type;
			const int len;
		};
		int (*define_fields)(struct trace_event_call *);
	};
};

struct trace_subsystem_dir;

struct trace_event_file {
	struct list_head list;
	struct trace_event_call *event_call;
	struct event_filter *filter;
	struct eventfs_inode *ei;
	struct trace_array *tr;
	struct trace_subsystem_dir *system;
	struct list_head triggers;
	long unsigned int flags;
	refcount_t ref;
	atomic_t sm_ref;
	atomic_t tm_ref;
};

typedef enum print_line_t (*trace_print_func)(struct trace_iterator *, int, struct trace_event *);

struct trace_event_functions {
	trace_print_func trace;
	trace_print_func raw;
	trace_print_func hex;
	trace_print_func binary;
};

struct trace_event_raw_9p_client_req {
	struct trace_entry ent;
	void *clnt;
	__u8 type;
	__u32 tag;
	char __data[0];
};

struct trace_event_raw_9p_client_res {
	struct trace_entry ent;
	void *clnt;
	__u8 type;
	__u32 tag;
	__u32 err;
	char __data[0];
};

struct trace_event_raw_9p_fid_ref {
	struct trace_entry ent;
	int fid;
	int refcount;
	__u8 type;
	char __data[0];
};

struct trace_event_raw_9p_protocol_dump {
	struct trace_entry ent;
	void *clnt;
	__u8 type;
	__u16 tag;
	u32 __data_loc_line;
	char __data[0];
};

struct trace_event_raw_alarm_class {
	struct trace_entry ent;
	void *alarm;
	unsigned char alarm_type;
	s64 expires;
	s64 now;
	char __data[0];
};

struct trace_event_raw_alarmtimer_suspend {
	struct trace_entry ent;
	s64 expires;
	unsigned char alarm_type;
	char __data[0];
};

struct trace_event_raw_alloc_vmap_area {
	struct trace_entry ent;
	long unsigned int addr;
	long unsigned int size;
	long unsigned int align;
	long unsigned int vstart;
	long unsigned int vend;
	int failed;
	char __data[0];
};

struct trace_event_raw_amd_pstate_epp_perf {
	struct trace_entry ent;
	unsigned int cpu_id;
	unsigned int highest_perf;
	unsigned int epp;
	unsigned int min_perf;
	unsigned int max_perf;
	bool boost;
	char __data[0];
};

struct trace_event_raw_amd_pstate_perf {
	struct trace_entry ent;
	long unsigned int min_perf;
	long unsigned int target_perf;
	long unsigned int capacity;
	long long unsigned int freq;
	long long unsigned int mperf;
	long long unsigned int aperf;
	long long unsigned int tsc;
	unsigned int cpu_id;
	bool fast_switch;
	char __data[0];
};

struct trace_event_raw_api_beacon_loss {
	struct trace_entry ent;
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	char __data[0];
};

struct trace_event_raw_api_chswitch_done {
	struct trace_entry ent;
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	bool success;
	unsigned int link_id;
	char __data[0];
};

struct trace_event_raw_api_connection_loss {
	struct trace_entry ent;
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	char __data[0];
};

struct trace_event_raw_api_cqm_rssi_notify {
	struct trace_entry ent;
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	u32 rssi_event;
	s32 rssi_level;
	char __data[0];
};

struct trace_event_raw_api_disconnect {
	struct trace_entry ent;
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	int reconnect;
	char __data[0];
};

struct trace_event_raw_api_enable_rssi_reports {
	struct trace_entry ent;
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	int rssi_min_thold;
	int rssi_max_thold;
	char __data[0];
};

struct trace_event_raw_api_eosp {
	struct trace_entry ent;
	char wiphy_name[32];
	char sta_addr[6];
	char __data[0];
};

struct trace_event_raw_api_finalize_rx_omi_bw {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	char sta_addr[6];
	int link_id;
	char __data[0];
};

struct trace_event_raw_api_gtk_rekey_notify {
	struct trace_entry ent;
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	u8 bssid[6];
	u8 replay_ctr[8];
	char __data[0];
};

struct trace_event_raw_api_prepare_rx_omi_bw {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	char sta_addr[6];
	int link_id;
	u32 bw;
	bool result;
	char __data[0];
};

struct trace_event_raw_api_radar_detected {
	struct trace_entry ent;
	char wiphy_name[32];
	char __data[0];
};

struct trace_event_raw_api_request_smps {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	int link_id;
	u32 smps_mode;
	char __data[0];
};

struct trace_event_raw_api_return_bool {
	struct trace_entry ent;
	char wiphy_name[32];
	bool result;
	char __data[0];
};

struct trace_event_raw_api_return_void {
	struct trace_entry ent;
	char wiphy_name[32];
	char __data[0];
};

struct trace_event_raw_api_scan_completed {
	struct trace_entry ent;
	char wiphy_name[32];
	bool aborted;
	char __data[0];
};

struct trace_event_raw_api_sched_scan_results {
	struct trace_entry ent;
	char wiphy_name[32];
	char __data[0];
};

struct trace_event_raw_api_sched_scan_stopped {
	struct trace_entry ent;
	char wiphy_name[32];
	char __data[0];
};

struct trace_event_raw_api_send_eosp_nullfunc {
	struct trace_entry ent;
	char wiphy_name[32];
	char sta_addr[6];
	u8 tid;
	char __data[0];
};

struct trace_event_raw_api_sta_block_awake {
	struct trace_entry ent;
	char wiphy_name[32];
	char sta_addr[6];
	bool block;
	char __data[0];
};

struct trace_event_raw_api_sta_set_buffered {
	struct trace_entry ent;
	char wiphy_name[32];
	char sta_addr[6];
	u8 tid;
	bool buffered;
	char __data[0];
};

struct trace_event_raw_api_start_tx_ba_cb {
	struct trace_entry ent;
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	u8 ra[6];
	u16 tid;
	char __data[0];
};

struct trace_event_raw_api_start_tx_ba_session {
	struct trace_entry ent;
	char sta_addr[6];
	u16 tid;
	char __data[0];
};

struct trace_event_raw_api_stop_tx_ba_cb {
	struct trace_entry ent;
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	u8 ra[6];
	u16 tid;
	char __data[0];
};

struct trace_event_raw_api_stop_tx_ba_session {
	struct trace_entry ent;
	char sta_addr[6];
	u16 tid;
	char __data[0];
};

struct trace_event_raw_ata_bmdma_status {
	struct trace_entry ent;
	unsigned int ata_port;
	unsigned int tag;
	unsigned char host_stat;
	char __data[0];
};

struct trace_event_raw_ata_eh_action_template {
	struct trace_entry ent;
	unsigned int ata_port;
	unsigned int ata_dev;
	unsigned int eh_action;
	char __data[0];
};

struct trace_event_raw_ata_eh_link_autopsy {
	struct trace_entry ent;
	unsigned int ata_port;
	unsigned int ata_dev;
	unsigned int eh_action;
	unsigned int eh_err_mask;
	char __data[0];
};

struct trace_event_raw_ata_eh_link_autopsy_qc {
	struct trace_entry ent;
	unsigned int ata_port;
	unsigned int ata_dev;
	unsigned int tag;
	unsigned int qc_flags;
	unsigned int eh_err_mask;
	char __data[0];
};

struct trace_event_raw_ata_exec_command_template {
	struct trace_entry ent;
	unsigned int ata_port;
	unsigned int tag;
	unsigned char cmd;
	unsigned char feature;
	unsigned char hob_nsect;
	unsigned char proto;
	char __data[0];
};

struct trace_event_raw_ata_link_reset_begin_template {
	struct trace_entry ent;
	unsigned int ata_port;
	unsigned int class[2];
	long unsigned int deadline;
	char __data[0];
};

struct trace_event_raw_ata_link_reset_end_template {
	struct trace_entry ent;
	unsigned int ata_port;
	unsigned int class[2];
	int rc;
	char __data[0];
};

struct trace_event_raw_ata_port_eh_begin_template {
	struct trace_entry ent;
	unsigned int ata_port;
	char __data[0];
};

struct trace_event_raw_ata_qc_complete_template {
	struct trace_entry ent;
	unsigned int ata_port;
	unsigned int ata_dev;
	unsigned int tag;
	unsigned char status;
	unsigned char dev;
	unsigned char lbal;
	unsigned char lbam;
	unsigned char lbah;
	unsigned char nsect;
	unsigned char error;
	unsigned char hob_lbal;
	unsigned char hob_lbam;
	unsigned char hob_lbah;
	unsigned char hob_nsect;
	unsigned char hob_feature;
	unsigned char ctl;
	long unsigned int flags;
	char __data[0];
};

struct trace_event_raw_ata_qc_issue_template {
	struct trace_entry ent;
	unsigned int ata_port;
	unsigned int ata_dev;
	unsigned int tag;
	unsigned char cmd;
	unsigned char dev;
	unsigned char lbal;
	unsigned char lbam;
	unsigned char lbah;
	unsigned char nsect;
	unsigned char feature;
	unsigned char hob_lbal;
	unsigned char hob_lbam;
	unsigned char hob_lbah;
	unsigned char hob_nsect;
	unsigned char hob_feature;
	unsigned char ctl;
	unsigned char proto;
	long unsigned int flags;
	char __data[0];
};

struct trace_event_raw_ata_sff_hsm_template {
	struct trace_entry ent;
	unsigned int ata_port;
	unsigned int ata_dev;
	unsigned int tag;
	unsigned int qc_flags;
	unsigned int protocol;
	unsigned int hsm_state;
	unsigned char dev_state;
	char __data[0];
};

struct trace_event_raw_ata_sff_template {
	struct trace_entry ent;
	unsigned int ata_port;
	unsigned char hsm_state;
	char __data[0];
};

struct trace_event_raw_ata_tf_load {
	struct trace_entry ent;
	unsigned int ata_port;
	unsigned char cmd;
	unsigned char dev;
	unsigned char lbal;
	unsigned char lbam;
	unsigned char lbah;
	unsigned char nsect;
	unsigned char feature;
	unsigned char hob_lbal;
	unsigned char hob_lbam;
	unsigned char hob_lbah;
	unsigned char hob_nsect;
	unsigned char hob_feature;
	unsigned char proto;
	char __data[0];
};

struct trace_event_raw_ata_transfer_data_template {
	struct trace_entry ent;
	unsigned int ata_port;
	unsigned int ata_dev;
	unsigned int tag;
	unsigned int flags;
	unsigned int offset;
	unsigned int bytes;
	char __data[0];
};

struct trace_event_raw_azx_get_position {
	struct trace_entry ent;
	int card;
	int idx;
	unsigned int pos;
	unsigned int delay;
	char __data[0];
};

struct trace_event_raw_azx_pcm {
	struct trace_entry ent;
	unsigned char stream_tag;
	char __data[0];
};

struct trace_event_raw_azx_pcm_trigger {
	struct trace_entry ent;
	int card;
	int idx;
	int cmd;
	char __data[0];
};

struct trace_event_raw_balance_dirty_pages {
	struct trace_entry ent;
	char bdi[32];
	long unsigned int limit;
	long unsigned int setpoint;
	long unsigned int dirty;
	long unsigned int bdi_setpoint;
	long unsigned int bdi_dirty;
	long unsigned int dirty_ratelimit;
	long unsigned int task_ratelimit;
	unsigned int dirtied;
	unsigned int dirtied_pause;
	long unsigned int paused;
	long int pause;
	long unsigned int period;
	long int think;
	ino_t cgroup_ino;
	char __data[0];
};

struct trace_event_raw_bdi_dirty_ratelimit {
	struct trace_entry ent;
	char bdi[32];
	long unsigned int write_bw;
	long unsigned int avg_write_bw;
	long unsigned int dirty_rate;
	long unsigned int dirty_ratelimit;
	long unsigned int task_ratelimit;
	long unsigned int balanced_dirty_ratelimit;
	ino_t cgroup_ino;
	char __data[0];
};

struct trace_event_raw_block_bio {
	struct trace_entry ent;
	dev_t dev;
	sector_t sector;
	unsigned int nr_sector;
	char rwbs[8];
	char comm[16];
	char __data[0];
};

struct trace_event_raw_block_bio_complete {
	struct trace_entry ent;
	dev_t dev;
	sector_t sector;
	unsigned int nr_sector;
	int error;
	char rwbs[8];
	char __data[0];
};

struct trace_event_raw_block_bio_remap {
	struct trace_entry ent;
	dev_t dev;
	sector_t sector;
	unsigned int nr_sector;
	dev_t old_dev;
	sector_t old_sector;
	char rwbs[8];
	char __data[0];
};

struct trace_event_raw_block_buffer {
	struct trace_entry ent;
	dev_t dev;
	sector_t sector;
	size_t size;
	char __data[0];
};

struct trace_event_raw_block_plug {
	struct trace_entry ent;
	char comm[16];
	char __data[0];
};

struct trace_event_raw_block_rq {
	struct trace_entry ent;
	dev_t dev;
	sector_t sector;
	unsigned int nr_sector;
	unsigned int bytes;
	short unsigned int ioprio;
	char rwbs[8];
	char comm[16];
	u32 __data_loc_cmd;
	char __data[0];
};

struct trace_event_raw_block_rq_completion {
	struct trace_entry ent;
	dev_t dev;
	sector_t sector;
	unsigned int nr_sector;
	int error;
	short unsigned int ioprio;
	char rwbs[8];
	u32 __data_loc_cmd;
	char __data[0];
};

struct trace_event_raw_block_rq_remap {
	struct trace_entry ent;
	dev_t dev;
	sector_t sector;
	unsigned int nr_sector;
	dev_t old_dev;
	sector_t old_sector;
	unsigned int nr_bios;
	char rwbs[8];
	char __data[0];
};

struct trace_event_raw_block_rq_requeue {
	struct trace_entry ent;
	dev_t dev;
	sector_t sector;
	unsigned int nr_sector;
	short unsigned int ioprio;
	char rwbs[8];
	u32 __data_loc_cmd;
	char __data[0];
};

struct trace_event_raw_block_split {
	struct trace_entry ent;
	dev_t dev;
	sector_t sector;
	sector_t new_sector;
	char rwbs[8];
	char comm[16];
	char __data[0];
};

struct trace_event_raw_block_unplug {
	struct trace_entry ent;
	int nr_rq;
	char comm[16];
	char __data[0];
};

struct trace_event_raw_bpf_test_finish {
	struct trace_entry ent;
	int err;
	char __data[0];
};

struct trace_event_raw_bpf_trace_printk {
	struct trace_entry ent;
	u32 __data_loc_bpf_string;
	char __data[0];
};

struct trace_event_raw_bpf_trigger_tp {
	struct trace_entry ent;
	int nonce;
	char __data[0];
};

struct trace_event_raw_bpf_xdp_link_attach_failed {
	struct trace_entry ent;
	u32 __data_loc_msg;
	char __data[0];
};

struct trace_event_raw_cache_event {
	struct trace_entry ent;
	const struct cache_head *h;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_cache_tag_flush {
	struct trace_entry ent;
	u32 __data_loc_iommu;
	u32 __data_loc_dev;
	u16 type;
	u16 domain_id;
	u32 pasid;
	long unsigned int start;
	long unsigned int end;
	long unsigned int addr;
	long unsigned int pages;
	long unsigned int mask;
	char __data[0];
};

struct trace_event_raw_cache_tag_log {
	struct trace_entry ent;
	u32 __data_loc_iommu;
	u32 __data_loc_dev;
	u16 type;
	u16 domain_id;
	u32 pasid;
	u32 users;
	char __data[0];
};

struct trace_event_raw_cap_capable {
	struct trace_entry ent;
	const struct cred *cred;
	struct user_namespace *target_ns;
	const struct user_namespace *capable_ns;
	int cap;
	int ret;
	char __data[0];
};

struct trace_event_raw_cdev_update {
	struct trace_entry ent;
	u32 __data_loc_type;
	long unsigned int target;
	char __data[0];
};

struct trace_event_raw_cfg80211_assoc_comeback {
	struct trace_entry ent;
	u32 id;
	u8 ap_addr[6];
	u32 timeout;
	char __data[0];
};

struct trace_event_raw_cfg80211_bss_color_notify {
	struct trace_entry ent;
	char name[16];
	int ifindex;
	u32 cmd;
	u8 count;
	u64 color_bitmap;
	char __data[0];
};

struct trace_event_raw_cfg80211_bss_evt {
	struct trace_entry ent;
	u8 bssid[6];
	enum nl80211_band band;
	u32 center_freq;
	u16 freq_offset;
	char __data[0];
};

struct trace_event_raw_cfg80211_cac_event {
	struct trace_entry ent;
	char name[16];
	int ifindex;
	enum nl80211_radar_event evt;
	unsigned int link_id;
	char __data[0];
};

struct trace_event_raw_cfg80211_ch_switch_notify {
	struct trace_entry ent;
	char name[16];
	int ifindex;
	enum nl80211_band band;
	u32 control_freq;
	u32 freq_offset;
	u32 width;
	u32 center_freq1;
	u32 freq1_offset;
	u32 center_freq2;
	u16 punctured;
	unsigned int link_id;
	char __data[0];
};

struct trace_event_raw_cfg80211_ch_switch_started_notify {
	struct trace_entry ent;
	char name[16];
	int ifindex;
	enum nl80211_band band;
	u32 control_freq;
	u32 freq_offset;
	u32 width;
	u32 center_freq1;
	u32 freq1_offset;
	u32 center_freq2;
	u16 punctured;
	unsigned int link_id;
	char __data[0];
};

struct trace_event_raw_cfg80211_chandef_dfs_required {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_band band;
	u32 control_freq;
	u32 freq_offset;
	u32 width;
	u32 center_freq1;
	u32 freq1_offset;
	u32 center_freq2;
	u16 punctured;
	char __data[0];
};

struct trace_event_raw_cfg80211_control_port_tx_status {
	struct trace_entry ent;
	u32 id;
	u64 cookie;
	bool ack;
	char __data[0];
};

struct trace_event_raw_cfg80211_cqm_pktloss_notify {
	struct trace_entry ent;
	char name[16];
	int ifindex;
	u8 peer[6];
	u32 num_packets;
	char __data[0];
};

struct trace_event_raw_cfg80211_cqm_rssi_notify {
	struct trace_entry ent;
	char name[16];
	int ifindex;
	enum nl80211_cqm_rssi_threshold_event rssi_event;
	s32 rssi_level;
	char __data[0];
};

struct trace_event_raw_cfg80211_epcs_changed {
	struct trace_entry ent;
	u32 id;
	u32 enabled;
	char __data[0];
};

struct trace_event_raw_cfg80211_ft_event {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u32 __data_loc_ies;
	u8 target_ap[6];
	u32 __data_loc_ric_ies;
	char __data[0];
};

struct trace_event_raw_cfg80211_get_bss {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_band band;
	u32 center_freq;
	u16 freq_offset;
	u8 bssid[6];
	u32 __data_loc_ssid;
	enum ieee80211_bss_type bss_type;
	enum ieee80211_privacy privacy;
	char __data[0];
};

struct trace_event_raw_cfg80211_ibss_joined {
	struct trace_entry ent;
	char name[16];
	int ifindex;
	u8 bssid[6];
	enum nl80211_band band;
	u32 center_freq;
	u16 freq_offset;
	char __data[0];
};

struct trace_event_raw_cfg80211_inform_bss_frame {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_band band;
	u32 center_freq;
	u16 freq_offset;
	u32 __data_loc_mgmt;
	s32 signal;
	u64 ts_boottime;
	u64 parent_tsf;
	u8 parent_bssid[6];
	char __data[0];
};

struct trace_event_raw_cfg80211_links_removed {
	struct trace_entry ent;
	char name[16];
	int ifindex;
	u16 link_mask;
	char __data[0];
};

struct trace_event_raw_cfg80211_mgmt_tx_status {
	struct trace_entry ent;
	u32 id;
	u64 cookie;
	bool ack;
	char __data[0];
};

struct trace_event_raw_cfg80211_michael_mic_failure {
	struct trace_entry ent;
	char name[16];
	int ifindex;
	u8 addr[6];
	enum nl80211_key_type key_type;
	int key_id;
	u8 tsc[6];
	char __data[0];
};

struct trace_event_raw_cfg80211_mlo_reconf_add_done {
	struct trace_entry ent;
	char name[16];
	int ifindex;
	u16 link_mask;
	u32 __data_loc_buf;
	char __data[0];
};

struct trace_event_raw_cfg80211_netdev_mac_evt {
	struct trace_entry ent;
	char name[16];
	int ifindex;
	u8 macaddr[6];
	char __data[0];
};

struct trace_event_raw_cfg80211_new_sta {
	struct trace_entry ent;
	char name[16];
	int ifindex;
	u8 mac_addr[6];
	int generation;
	u32 connected_time;
	u32 inactive_time;
	u32 rx_bytes;
	u32 tx_bytes;
	u32 rx_packets;
	u32 tx_packets;
	u32 tx_retries;
	u32 tx_failed;
	u32 rx_dropped_misc;
	u32 beacon_loss_count;
	u16 llid;
	u16 plid;
	u8 plink_state;
	char __data[0];
};

struct trace_event_raw_cfg80211_pmksa_candidate_notify {
	struct trace_entry ent;
	char name[16];
	int ifindex;
	int index;
	u8 bssid[6];
	bool preauth;
	char __data[0];
};

struct trace_event_raw_cfg80211_pmsr_complete {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 id;
	u64 cookie;
	char __data[0];
};

struct trace_event_raw_cfg80211_pmsr_report {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 id;
	u64 cookie;
	u8 addr[6];
	char __data[0];
};

struct trace_event_raw_cfg80211_probe_status {
	struct trace_entry ent;
	char name[16];
	int ifindex;
	u8 addr[6];
	u64 cookie;
	bool acked;
	char __data[0];
};

struct trace_event_raw_cfg80211_radar_event {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_band band;
	u32 control_freq;
	u32 freq_offset;
	u32 width;
	u32 center_freq1;
	u32 freq1_offset;
	u32 center_freq2;
	u16 punctured;
	bool offchan;
	char __data[0];
};

struct trace_event_raw_cfg80211_ready_on_channel {
	struct trace_entry ent;
	u32 id;
	u64 cookie;
	enum nl80211_band band;
	u32 center_freq;
	u16 freq_offset;
	unsigned int duration;
	char __data[0];
};

struct trace_event_raw_cfg80211_ready_on_channel_expired {
	struct trace_entry ent;
	u32 id;
	u64 cookie;
	enum nl80211_band band;
	u32 center_freq;
	u16 freq_offset;
	char __data[0];
};

struct trace_event_raw_cfg80211_reg_can_beacon {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_band band;
	u32 control_freq;
	u32 freq_offset;
	u32 width;
	u32 center_freq1;
	u32 freq1_offset;
	u32 center_freq2;
	u16 punctured;
	enum nl80211_iftype iftype;
	u32 prohibited_flags;
	u32 permitting_flags;
	char __data[0];
};

struct trace_event_raw_cfg80211_report_obss_beacon {
	struct trace_entry ent;
	char wiphy_name[32];
	int freq;
	int sig_dbm;
	char __data[0];
};

struct trace_event_raw_cfg80211_report_wowlan_wakeup {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 id;
	bool non_wireless;
	bool disconnect;
	bool magic_pkt;
	bool gtk_rekey_failure;
	bool eap_identity_req;
	bool four_way_handshake;
	bool rfkill_release;
	s32 pattern_idx;
	u32 packet_len;
	u32 __data_loc_packet;
	char __data[0];
};

struct trace_event_raw_cfg80211_return_bool {
	struct trace_entry ent;
	bool ret;
	char __data[0];
};

struct trace_event_raw_cfg80211_return_u32 {
	struct trace_entry ent;
	u32 ret;
	char __data[0];
};

struct trace_event_raw_cfg80211_return_uint {
	struct trace_entry ent;
	unsigned int ret;
	char __data[0];
};

struct trace_event_raw_cfg80211_rx_control_port {
	struct trace_entry ent;
	char name[16];
	int ifindex;
	int len;
	u8 from[6];
	u16 proto;
	bool unencrypted;
	int link_id;
	char __data[0];
};

struct trace_event_raw_cfg80211_rx_evt {
	struct trace_entry ent;
	char name[16];
	int ifindex;
	u8 addr[6];
	char __data[0];
};

struct trace_event_raw_cfg80211_rx_mgmt {
	struct trace_entry ent;
	u32 id;
	int freq;
	int sig_dbm;
	char __data[0];
};

struct trace_event_raw_cfg80211_scan_done {
	struct trace_entry ent;
	u32 n_channels;
	u32 __data_loc_ie;
	u32 rates[6];
	u32 wdev_id;
	u8 wiphy_mac[6];
	bool no_cck;
	bool aborted;
	u64 scan_start_tsf;
	u8 tsf_bssid[6];
	char __data[0];
};

struct trace_event_raw_cfg80211_send_assoc_failure {
	struct trace_entry ent;
	char name[16];
	int ifindex;
	u8 ap_addr[6];
	bool timeout;
	char __data[0];
};

struct trace_event_raw_cfg80211_send_rx_assoc {
	struct trace_entry ent;
	char name[16];
	int ifindex;
	u8 ap_addr[6];
	char __data[0];
};

struct trace_event_raw_cfg80211_stop_iface {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 id;
	char __data[0];
};

struct trace_event_raw_cfg80211_tdls_oper_request {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 peer[6];
	enum nl80211_tdls_operation oper;
	u16 reason_code;
	char __data[0];
};

struct trace_event_raw_cfg80211_tx_mgmt_expired {
	struct trace_entry ent;
	u32 id;
	u64 cookie;
	enum nl80211_band band;
	u32 center_freq;
	u16 freq_offset;
	char __data[0];
};

struct trace_event_raw_cfg80211_tx_mlme_mgmt {
	struct trace_entry ent;
	char name[16];
	int ifindex;
	u32 __data_loc_frame;
	int reconnect;
	char __data[0];
};

struct trace_event_raw_cfg80211_update_owe_info_event {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 peer[6];
	u32 __data_loc_ie;
	int assoc_link_id;
	u8 peer_mld_addr[6];
	char __data[0];
};

struct trace_event_raw_cgroup {
	struct trace_entry ent;
	int root;
	int level;
	u64 id;
	u32 __data_loc_path;
	char __data[0];
};

struct trace_event_raw_cgroup_event {
	struct trace_entry ent;
	int root;
	int level;
	u64 id;
	u32 __data_loc_path;
	int val;
	char __data[0];
};

struct trace_event_raw_cgroup_migrate {
	struct trace_entry ent;
	int dst_root;
	int dst_level;
	u64 dst_id;
	int pid;
	u32 __data_loc_dst_path;
	u32 __data_loc_comm;
	char __data[0];
};

struct trace_event_raw_cgroup_root {
	struct trace_entry ent;
	int root;
	u16 ss_mask;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_cgroup_rstat {
	struct trace_entry ent;
	int root;
	int level;
	u64 id;
	int cpu;
	bool contended;
	char __data[0];
};

struct trace_event_raw_chanswitch_evt {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	u32 control_freq;
	u32 freq_offset;
	u32 chan_width;
	u32 center_freq1;
	u32 freq1_offset;
	u32 center_freq2;
	u64 timestamp;
	u32 device_timestamp;
	bool block_tx;
	u8 count;
	u8 link_id;
	char __data[0];
};

struct trace_event_raw_clock {
	struct trace_entry ent;
	u32 __data_loc_name;
	u64 state;
	u64 cpu_id;
	char __data[0];
};

struct trace_event_raw_compact_retry {
	struct trace_entry ent;
	int order;
	int priority;
	int result;
	int retries;
	int max_retries;
	bool ret;
	char __data[0];
};

struct trace_event_raw_console {
	struct trace_entry ent;
	u32 __data_loc_msg;
	char __data[0];
};

struct trace_event_raw_consume_skb {
	struct trace_entry ent;
	void *skbaddr;
	void *location;
	char __data[0];
};

struct trace_event_raw_contention_begin {
	struct trace_entry ent;
	void *lock_addr;
	unsigned int flags;
	char __data[0];
};

struct trace_event_raw_contention_end {
	struct trace_entry ent;
	void *lock_addr;
	int ret;
	char __data[0];
};

struct trace_event_raw_cpu {
	struct trace_entry ent;
	u32 state;
	u32 cpu_id;
	char __data[0];
};

struct trace_event_raw_cpu_frequency_limits {
	struct trace_entry ent;
	u32 min_freq;
	u32 max_freq;
	u32 cpu_id;
	char __data[0];
};

struct trace_event_raw_cpu_idle_miss {
	struct trace_entry ent;
	u32 cpu_id;
	u32 state;
	bool below;
	char __data[0];
};

struct trace_event_raw_cpu_latency_qos_request {
	struct trace_entry ent;
	s32 value;
	char __data[0];
};

struct trace_event_raw_cpuhp_enter {
	struct trace_entry ent;
	unsigned int cpu;
	int target;
	int idx;
	void *fun;
	char __data[0];
};

struct trace_event_raw_cpuhp_exit {
	struct trace_entry ent;
	unsigned int cpu;
	int state;
	int idx;
	int ret;
	char __data[0];
};

struct trace_event_raw_cpuhp_multi_enter {
	struct trace_entry ent;
	unsigned int cpu;
	int target;
	int idx;
	void *fun;
	char __data[0];
};

struct trace_event_raw_csd_function {
	struct trace_entry ent;
	void *func;
	void *csd;
	char __data[0];
};

struct trace_event_raw_csd_queue_cpu {
	struct trace_entry ent;
	unsigned int cpu;
	void *callsite;
	void *func;
	void *csd;
	char __data[0];
};

struct trace_event_raw_ctime {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	time64_t ctime_s;
	u32 ctime_ns;
	u32 gen;
	char __data[0];
};

struct trace_event_raw_ctime_ns_xchg {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	u32 gen;
	u32 old;
	u32 new;
	u32 cur;
	char __data[0];
};

struct trace_event_raw_dev_pm_qos_request {
	struct trace_entry ent;
	u32 __data_loc_name;
	enum dev_pm_qos_req_type type;
	s32 new_value;
	char __data[0];
};

struct trace_event_raw_device_pm_callback_end {
	struct trace_entry ent;
	u32 __data_loc_device;
	u32 __data_loc_driver;
	int error;
	char __data[0];
};

struct trace_event_raw_device_pm_callback_start {
	struct trace_entry ent;
	u32 __data_loc_device;
	u32 __data_loc_driver;
	u32 __data_loc_parent;
	u32 __data_loc_pm_ops;
	int event;
	char __data[0];
};

struct trace_event_raw_devres {
	struct trace_entry ent;
	u32 __data_loc_devname;
	struct device *dev;
	const char *op;
	void *node;
	u32 __data_loc_name;
	size_t size;
	char __data[0];
};

struct trace_event_raw_dma_alloc_class {
	struct trace_entry ent;
	u32 __data_loc_device;
	void *virt_addr;
	u64 dma_addr;
	size_t size;
	gfp_t flags;
	enum dma_data_direction dir;
	long unsigned int attrs;
	char __data[0];
};

struct trace_event_raw_dma_alloc_sgt {
	struct trace_entry ent;
	u32 __data_loc_device;
	u32 __data_loc_phys_addrs;
	u64 dma_addr;
	size_t size;
	enum dma_data_direction dir;
	gfp_t flags;
	long unsigned int attrs;
	char __data[0];
};

struct trace_event_raw_dma_fence {
	struct trace_entry ent;
	u32 __data_loc_driver;
	u32 __data_loc_timeline;
	unsigned int context;
	unsigned int seqno;
	char __data[0];
};

struct trace_event_raw_dma_free_class {
	struct trace_entry ent;
	u32 __data_loc_device;
	void *virt_addr;
	u64 dma_addr;
	size_t size;
	enum dma_data_direction dir;
	long unsigned int attrs;
	char __data[0];
};

struct trace_event_raw_dma_free_sgt {
	struct trace_entry ent;
	u32 __data_loc_device;
	u32 __data_loc_phys_addrs;
	u64 dma_addr;
	size_t size;
	enum dma_data_direction dir;
	char __data[0];
};

struct trace_event_raw_dma_map {
	struct trace_entry ent;
	u32 __data_loc_device;
	u64 phys_addr;
	u64 dma_addr;
	size_t size;
	enum dma_data_direction dir;
	long unsigned int attrs;
	char __data[0];
};

struct trace_event_raw_dma_map_sg {
	struct trace_entry ent;
	u32 __data_loc_device;
	u32 __data_loc_phys_addrs;
	u32 __data_loc_dma_addrs;
	u32 __data_loc_lengths;
	enum dma_data_direction dir;
	long unsigned int attrs;
	char __data[0];
};

struct trace_event_raw_dma_map_sg_err {
	struct trace_entry ent;
	u32 __data_loc_device;
	u32 __data_loc_phys_addrs;
	int err;
	enum dma_data_direction dir;
	long unsigned int attrs;
	char __data[0];
};

struct trace_event_raw_dma_sync_sg {
	struct trace_entry ent;
	u32 __data_loc_device;
	u32 __data_loc_dma_addrs;
	u32 __data_loc_lengths;
	enum dma_data_direction dir;
	char __data[0];
};

struct trace_event_raw_dma_sync_single {
	struct trace_entry ent;
	u32 __data_loc_device;
	u64 dma_addr;
	size_t size;
	enum dma_data_direction dir;
	char __data[0];
};

struct trace_event_raw_dma_unmap {
	struct trace_entry ent;
	u32 __data_loc_device;
	u64 addr;
	size_t size;
	enum dma_data_direction dir;
	long unsigned int attrs;
	char __data[0];
};

struct trace_event_raw_dma_unmap_sg {
	struct trace_entry ent;
	u32 __data_loc_device;
	u32 __data_loc_addrs;
	enum dma_data_direction dir;
	long unsigned int attrs;
	char __data[0];
};

struct trace_event_raw_dql_stall_detected {
	struct trace_entry ent;
	short unsigned int thrs;
	unsigned int len;
	long unsigned int last_reap;
	long unsigned int hist_head;
	long unsigned int now;
	long unsigned int hist[4];
	char __data[0];
};

struct trace_event_raw_drm_vblank_event {
	struct trace_entry ent;
	int crtc;
	unsigned int seq;
	ktime_t time;
	bool high_prec;
	char __data[0];
};

struct trace_event_raw_drm_vblank_event_delivered {
	struct trace_entry ent;
	struct drm_file *file;
	int crtc;
	unsigned int seq;
	char __data[0];
};

struct trace_event_raw_drm_vblank_event_queued {
	struct trace_entry ent;
	struct drm_file *file;
	int crtc;
	unsigned int seq;
	char __data[0];
};

struct trace_event_raw_drv_add_nan_func {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	u8 type;
	u8 inst_id;
	char __data[0];
};

struct trace_event_raw_drv_add_twt_setup {
	struct trace_entry ent;
	char wiphy_name[32];
	char sta_addr[6];
	u8 dialog_token;
	u8 control;
	__le16 req_type;
	__le64 twt;
	u8 duration;
	__le16 mantissa;
	u8 channel;
	char __data[0];
};

struct trace_event_raw_drv_ampdu_action {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	enum ieee80211_ampdu_mlme_action ieee80211_ampdu_mlme_action;
	char sta_addr[6];
	u16 tid;
	u16 ssn;
	u16 buf_size;
	bool amsdu;
	u16 timeout;
	u16 action;
	char __data[0];
};

struct trace_event_raw_drv_can_activate_links {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	u16 active_links;
	char __data[0];
};

struct trace_event_raw_drv_can_neg_ttlm {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	u16 downlink[16];
	u16 uplink[16];
	char __data[0];
};

struct trace_event_raw_drv_change_chanctx {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 control_freq;
	u32 freq_offset;
	u32 chan_width;
	u32 center_freq1;
	u32 freq1_offset;
	u32 center_freq2;
	u32 min_control_freq;
	u32 min_freq_offset;
	u32 min_chan_width;
	u32 min_center_freq1;
	u32 min_freq1_offset;
	u32 min_center_freq2;
	u32 ap_control_freq;
	u32 ap_freq_offset;
	u32 ap_chan_width;
	u32 ap_center_freq1;
	u32 ap_freq1_offset;
	u32 ap_center_freq2;
	u8 rx_chains_static;
	u8 rx_chains_dynamic;
	u32 changed;
	char __data[0];
};

struct trace_event_raw_drv_change_interface {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	u32 new_type;
	bool new_p2p;
	char __data[0];
};

struct trace_event_raw_drv_change_sta_links {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	char sta_addr[6];
	u16 old_links;
	u16 new_links;
	char __data[0];
};

struct trace_event_raw_drv_change_vif_links {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	u16 old_links;
	u16 new_links;
	char __data[0];
};

struct trace_event_raw_drv_channel_switch_beacon {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	u32 control_freq;
	u32 freq_offset;
	u32 chan_width;
	u32 center_freq1;
	u32 freq1_offset;
	u32 center_freq2;
	char __data[0];
};

struct trace_event_raw_drv_conf_tx {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	unsigned int link_id;
	u16 ac;
	u16 txop;
	u16 cw_min;
	u16 cw_max;
	u8 aifs;
	bool uapsd;
	char __data[0];
};

struct trace_event_raw_drv_config {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 changed;
	u32 flags;
	int power_level;
	int dynamic_ps_timeout;
	u16 listen_interval;
	u8 long_frame_max_tx_count;
	u8 short_frame_max_tx_count;
	u32 control_freq;
	u32 freq_offset;
	u32 chan_width;
	u32 center_freq1;
	u32 freq1_offset;
	u32 center_freq2;
	int smps;
	char __data[0];
};

struct trace_event_raw_drv_config_iface_filter {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	unsigned int filter_flags;
	unsigned int changed_flags;
	char __data[0];
};

struct trace_event_raw_drv_configure_filter {
	struct trace_entry ent;
	char wiphy_name[32];
	unsigned int changed;
	unsigned int total;
	u64 multicast;
	char __data[0];
};

struct trace_event_raw_drv_del_nan_func {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	u8 instance_id;
	char __data[0];
};

struct trace_event_raw_drv_event_callback {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	u32 type;
	char __data[0];
};

struct trace_event_raw_drv_flush {
	struct trace_entry ent;
	char wiphy_name[32];
	bool drop;
	u32 queues;
	char __data[0];
};

struct trace_event_raw_drv_get_antenna {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 tx_ant;
	u32 rx_ant;
	int ret;
	char __data[0];
};

struct trace_event_raw_drv_get_expected_throughput {
	struct trace_entry ent;
	char sta_addr[6];
	char __data[0];
};

struct trace_event_raw_drv_get_ftm_responder_stats {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	char __data[0];
};

struct trace_event_raw_drv_get_key_seq {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 cipher;
	u8 hw_key_idx;
	u8 flags;
	s8 keyidx;
	char __data[0];
};

struct trace_event_raw_drv_get_ringparam {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 tx;
	u32 tx_max;
	u32 rx;
	u32 rx_max;
	char __data[0];
};

struct trace_event_raw_drv_get_stats {
	struct trace_entry ent;
	char wiphy_name[32];
	int ret;
	unsigned int ackfail;
	unsigned int rtsfail;
	unsigned int fcserr;
	unsigned int rtssucc;
	char __data[0];
};

struct trace_event_raw_drv_get_survey {
	struct trace_entry ent;
	char wiphy_name[32];
	int idx;
	char __data[0];
};

struct trace_event_raw_drv_get_txpower {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	unsigned int link_id;
	int dbm;
	int ret;
	char __data[0];
};

struct trace_event_raw_drv_join_ibss {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	u8 dtimper;
	u16 bcnint;
	u32 __data_loc_ssid;
	char __data[0];
};

struct trace_event_raw_drv_link_info_changed {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	u64 changed;
	int link_id;
	bool cts;
	bool shortpre;
	bool shortslot;
	bool enable_beacon;
	u8 dtimper;
	u16 bcnint;
	u16 assoc_cap;
	u64 sync_tsf;
	u32 sync_device_ts;
	u8 sync_dtim_count;
	u32 basic_rates;
	int mcast_rate[6];
	u16 ht_operation_mode;
	s32 cqm_rssi_thold;
	s32 cqm_rssi_hyst;
	u32 channel_width;
	u32 channel_cfreq1;
	u32 channel_cfreq1_offset;
	bool qos;
	bool hidden_ssid;
	int txpower;
	u8 p2p_oppps_ctwindow;
	char __data[0];
};

struct trace_event_raw_drv_link_sta_rc_update {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	char sta_addr[6];
	u32 changed;
	u32 link_id;
	char __data[0];
};

struct trace_event_raw_drv_nan_change_conf {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	u8 master_pref;
	u8 bands;
	u32 changes;
	char __data[0];
};

struct trace_event_raw_drv_neg_ttlm_res {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	u32 res;
	u16 downlink[16];
	u16 uplink[16];
	char __data[0];
};

struct trace_event_raw_drv_net_setup_tc {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	u8 type;
	char __data[0];
};

struct trace_event_raw_drv_offset_tsf {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	s64 tsf_offset;
	char __data[0];
};

struct trace_event_raw_drv_prep_add_interface {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 type;
	char __data[0];
};

struct trace_event_raw_drv_prepare_multicast {
	struct trace_entry ent;
	char wiphy_name[32];
	int mc_count;
	char __data[0];
};

struct trace_event_raw_drv_reconfig_complete {
	struct trace_entry ent;
	char wiphy_name[32];
	u8 reconfig_type;
	char __data[0];
};

struct trace_event_raw_drv_remain_on_channel {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	int center_freq;
	int freq_offset;
	unsigned int duration;
	u32 type;
	char __data[0];
};

struct trace_event_raw_drv_return_bool {
	struct trace_entry ent;
	char wiphy_name[32];
	bool ret;
	char __data[0];
};

struct trace_event_raw_drv_return_int {
	struct trace_entry ent;
	char wiphy_name[32];
	int ret;
	char __data[0];
};

struct trace_event_raw_drv_return_u32 {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 ret;
	char __data[0];
};

struct trace_event_raw_drv_return_u64 {
	struct trace_entry ent;
	char wiphy_name[32];
	u64 ret;
	char __data[0];
};

struct trace_event_raw_drv_set_antenna {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 tx_ant;
	u32 rx_ant;
	int ret;
	char __data[0];
};

struct trace_event_raw_drv_set_bitrate_mask {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	u32 legacy_2g;
	u32 legacy_5g;
	char __data[0];
};

struct trace_event_raw_drv_set_coverage_class {
	struct trace_entry ent;
	char wiphy_name[32];
	s16 value;
	char __data[0];
};

struct trace_event_raw_drv_set_default_unicast_key {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	int key_idx;
	char __data[0];
};

struct trace_event_raw_drv_set_key {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	char sta_addr[6];
	u32 cmd;
	u32 cipher;
	u8 hw_key_idx;
	u8 flags;
	s8 keyidx;
	char __data[0];
};

struct trace_event_raw_drv_set_rekey_data {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	u8 kek[16];
	u8 kck[16];
	u8 replay_ctr[8];
	char __data[0];
};

struct trace_event_raw_drv_set_ringparam {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 tx;
	u32 rx;
	char __data[0];
};

struct trace_event_raw_drv_set_tim {
	struct trace_entry ent;
	char wiphy_name[32];
	char sta_addr[6];
	bool set;
	char __data[0];
};

struct trace_event_raw_drv_set_tsf {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	u64 tsf;
	char __data[0];
};

struct trace_event_raw_drv_set_wakeup {
	struct trace_entry ent;
	char wiphy_name[32];
	bool enabled;
	char __data[0];
};

struct trace_event_raw_drv_sta_notify {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	char sta_addr[6];
	u32 cmd;
	char __data[0];
};

struct trace_event_raw_drv_sta_set_txpwr {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	char sta_addr[6];
	s16 txpwr;
	u8 type;
	char __data[0];
};

struct trace_event_raw_drv_sta_state {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	char sta_addr[6];
	u32 old_state;
	u32 new_state;
	char __data[0];
};

struct trace_event_raw_drv_start_ap {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	u32 link_id;
	u8 dtimper;
	u16 bcnint;
	u32 __data_loc_ssid;
	bool hidden_ssid;
	char __data[0];
};

struct trace_event_raw_drv_start_nan {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	u8 master_pref;
	u8 bands;
	char __data[0];
};

struct trace_event_raw_drv_stop {
	struct trace_entry ent;
	char wiphy_name[32];
	bool suspend;
	char __data[0];
};

struct trace_event_raw_drv_stop_ap {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	u32 link_id;
	char __data[0];
};

struct trace_event_raw_drv_stop_nan {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	char __data[0];
};

struct trace_event_raw_drv_sw_scan_start {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	char mac_addr[6];
	char __data[0];
};

struct trace_event_raw_drv_switch_vif_chanctx {
	struct trace_entry ent;
	char wiphy_name[32];
	int n_vifs;
	u32 mode;
	u32 __data_loc_vifs;
	char __data[0];
};

struct trace_event_raw_drv_tdls_cancel_channel_switch {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	char sta_addr[6];
	char __data[0];
};

struct trace_event_raw_drv_tdls_channel_switch {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	char sta_addr[6];
	u8 oper_class;
	u32 control_freq;
	u32 freq_offset;
	u32 chan_width;
	u32 center_freq1;
	u32 freq1_offset;
	u32 center_freq2;
	char __data[0];
};

struct trace_event_raw_drv_tdls_recv_channel_switch {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	u8 action_code;
	char sta_addr[6];
	u32 control_freq;
	u32 freq_offset;
	u32 chan_width;
	u32 center_freq1;
	u32 freq1_offset;
	u32 center_freq2;
	u32 status;
	bool peer_initiator;
	u32 timestamp;
	u16 switch_time;
	u16 switch_timeout;
	char __data[0];
};

struct trace_event_raw_drv_twt_teardown_request {
	struct trace_entry ent;
	char wiphy_name[32];
	char sta_addr[6];
	u8 flowid;
	char __data[0];
};

struct trace_event_raw_drv_update_tkip_key {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	char sta_addr[6];
	u32 iv32;
	char __data[0];
};

struct trace_event_raw_drv_vif_cfg_changed {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	u64 changed;
	bool assoc;
	bool ibss_joined;
	bool ibss_creator;
	u16 aid;
	u32 __data_loc_arp_addr_list;
	int arp_addr_cnt;
	u32 __data_loc_ssid;
	int s1g;
	bool idle;
	bool ps;
	char __data[0];
};

struct trace_event_raw_drv_wake_tx_queue {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	char sta_addr[6];
	u8 ac;
	u8 tid;
	char __data[0];
};

struct trace_event_raw_e1000e_trace_mac_register {
	struct trace_entry ent;
	uint32_t reg;
	char __data[0];
};

struct trace_event_raw_emulate_vsyscall {
	struct trace_entry ent;
	int nr;
	char __data[0];
};

struct trace_event_raw_error_report_template {
	struct trace_entry ent;
	enum error_detector error_detector;
	long unsigned int id;
	char __data[0];
};

struct trace_event_raw_exit_mmap {
	struct trace_entry ent;
	struct mm_struct *mm;
	struct maple_tree *mt;
	char __data[0];
};

struct trace_event_raw_ext4__bitmap_load {
	struct trace_entry ent;
	dev_t dev;
	__u32 group;
	char __data[0];
};

struct trace_event_raw_ext4__es_extent {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t lblk;
	ext4_lblk_t len;
	ext4_fsblk_t pblk;
	char status;
	char __data[0];
};

struct trace_event_raw_ext4__es_shrink_enter {
	struct trace_entry ent;
	dev_t dev;
	int nr_to_scan;
	int cache_cnt;
	char __data[0];
};

struct trace_event_raw_ext4__fallocate_mode {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t offset;
	loff_t len;
	int mode;
	char __data[0];
};

struct trace_event_raw_ext4__folio_op {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	long unsigned int index;
	char __data[0];
};

struct trace_event_raw_ext4__map_blocks_enter {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t lblk;
	unsigned int len;
	unsigned int flags;
	char __data[0];
};

struct trace_event_raw_ext4__map_blocks_exit {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	unsigned int flags;
	ext4_fsblk_t pblk;
	ext4_lblk_t lblk;
	unsigned int len;
	unsigned int mflags;
	int ret;
	char __data[0];
};

struct trace_event_raw_ext4__mb_new_pa {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 pa_pstart;
	__u64 pa_lstart;
	__u32 pa_len;
	char __data[0];
};

struct trace_event_raw_ext4__mballoc {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	int result_start;
	__u32 result_group;
	int result_len;
	char __data[0];
};

struct trace_event_raw_ext4__trim {
	struct trace_entry ent;
	int dev_major;
	int dev_minor;
	__u32 group;
	int start;
	int len;
	char __data[0];
};

struct trace_event_raw_ext4__truncate {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 blocks;
	char __data[0];
};

struct trace_event_raw_ext4__write_begin {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t pos;
	unsigned int len;
	char __data[0];
};

struct trace_event_raw_ext4__write_end {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t pos;
	unsigned int len;
	unsigned int copied;
	char __data[0];
};

struct trace_event_raw_ext4_alloc_da_blocks {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	unsigned int data_blocks;
	char __data[0];
};

struct trace_event_raw_ext4_allocate_blocks {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 block;
	unsigned int len;
	__u32 logical;
	__u32 lleft;
	__u32 lright;
	__u64 goal;
	__u64 pleft;
	__u64 pright;
	unsigned int flags;
	char __data[0];
};

struct trace_event_raw_ext4_allocate_inode {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ino_t dir;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_ext4_begin_ordered_truncate {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t new_size;
	char __data[0];
};

struct trace_event_raw_ext4_collapse_range {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t offset;
	loff_t len;
	char __data[0];
};

struct trace_event_raw_ext4_da_release_space {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 i_blocks;
	int freed_blocks;
	int reserved_data_blocks;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_ext4_da_reserve_space {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 i_blocks;
	int reserve_blocks;
	int reserved_data_blocks;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_ext4_da_update_reserve_space {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 i_blocks;
	int used_blocks;
	int reserved_data_blocks;
	int quota_claim;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_ext4_da_write_pages {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	long unsigned int first_page;
	long int nr_to_write;
	int sync_mode;
	char __data[0];
};

struct trace_event_raw_ext4_da_write_pages_extent {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 lblk;
	__u32 len;
	__u32 flags;
	char __data[0];
};

struct trace_event_raw_ext4_discard_blocks {
	struct trace_entry ent;
	dev_t dev;
	__u64 blk;
	__u64 count;
	char __data[0];
};

struct trace_event_raw_ext4_discard_preallocations {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	unsigned int len;
	char __data[0];
};

struct trace_event_raw_ext4_drop_inode {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	int drop;
	char __data[0];
};

struct trace_event_raw_ext4_error {
	struct trace_entry ent;
	dev_t dev;
	const char *function;
	unsigned int line;
	char __data[0];
};

struct trace_event_raw_ext4_es_find_extent_range_enter {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t lblk;
	char __data[0];
};

struct trace_event_raw_ext4_es_find_extent_range_exit {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t lblk;
	ext4_lblk_t len;
	ext4_fsblk_t pblk;
	char status;
	char __data[0];
};

struct trace_event_raw_ext4_es_insert_delayed_extent {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t lblk;
	ext4_lblk_t len;
	ext4_fsblk_t pblk;
	char status;
	bool lclu_allocated;
	bool end_allocated;
	char __data[0];
};

struct trace_event_raw_ext4_es_lookup_extent_enter {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t lblk;
	char __data[0];
};

struct trace_event_raw_ext4_es_lookup_extent_exit {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t lblk;
	ext4_lblk_t len;
	ext4_fsblk_t pblk;
	char status;
	int found;
	char __data[0];
};

struct trace_event_raw_ext4_es_remove_extent {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t lblk;
	loff_t len;
	char __data[0];
};

struct trace_event_raw_ext4_es_shrink {
	struct trace_entry ent;
	dev_t dev;
	int nr_shrunk;
	long long unsigned int scan_time;
	int nr_skipped;
	int retried;
	char __data[0];
};

struct trace_event_raw_ext4_es_shrink_scan_exit {
	struct trace_entry ent;
	dev_t dev;
	int nr_shrunk;
	int cache_cnt;
	char __data[0];
};

struct trace_event_raw_ext4_evict_inode {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	int nlink;
	char __data[0];
};

struct trace_event_raw_ext4_ext_convert_to_initialized_enter {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t m_lblk;
	unsigned int m_len;
	ext4_lblk_t u_lblk;
	unsigned int u_len;
	ext4_fsblk_t u_pblk;
	char __data[0];
};

struct trace_event_raw_ext4_ext_convert_to_initialized_fastpath {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t m_lblk;
	unsigned int m_len;
	ext4_lblk_t u_lblk;
	unsigned int u_len;
	ext4_fsblk_t u_pblk;
	ext4_lblk_t i_lblk;
	unsigned int i_len;
	ext4_fsblk_t i_pblk;
	char __data[0];
};

struct trace_event_raw_ext4_ext_handle_unwritten_extents {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	int flags;
	ext4_lblk_t lblk;
	ext4_fsblk_t pblk;
	unsigned int len;
	unsigned int allocated;
	ext4_fsblk_t newblk;
	char __data[0];
};

struct trace_event_raw_ext4_ext_load_extent {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_fsblk_t pblk;
	ext4_lblk_t lblk;
	char __data[0];
};

struct trace_event_raw_ext4_ext_remove_space {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t start;
	ext4_lblk_t end;
	int depth;
	char __data[0];
};

struct trace_event_raw_ext4_ext_remove_space_done {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t start;
	ext4_lblk_t end;
	int depth;
	ext4_fsblk_t pc_pclu;
	ext4_lblk_t pc_lblk;
	int pc_state;
	short unsigned int eh_entries;
	char __data[0];
};

struct trace_event_raw_ext4_ext_rm_idx {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_fsblk_t pblk;
	char __data[0];
};

struct trace_event_raw_ext4_ext_rm_leaf {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t start;
	ext4_lblk_t ee_lblk;
	ext4_fsblk_t ee_pblk;
	short int ee_len;
	ext4_fsblk_t pc_pclu;
	ext4_lblk_t pc_lblk;
	int pc_state;
	char __data[0];
};

struct trace_event_raw_ext4_ext_show_extent {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_fsblk_t pblk;
	ext4_lblk_t lblk;
	short unsigned int len;
	char __data[0];
};

struct trace_event_raw_ext4_fallocate_exit {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t pos;
	unsigned int blocks;
	int ret;
	char __data[0];
};

struct trace_event_raw_ext4_fc_cleanup {
	struct trace_entry ent;
	dev_t dev;
	int j_fc_off;
	int full;
	tid_t tid;
	char __data[0];
};

struct trace_event_raw_ext4_fc_commit_start {
	struct trace_entry ent;
	dev_t dev;
	tid_t tid;
	char __data[0];
};

struct trace_event_raw_ext4_fc_commit_stop {
	struct trace_entry ent;
	dev_t dev;
	int nblks;
	int reason;
	int num_fc;
	int num_fc_ineligible;
	int nblks_agg;
	tid_t tid;
	char __data[0];
};

struct trace_event_raw_ext4_fc_replay {
	struct trace_entry ent;
	dev_t dev;
	int tag;
	int ino;
	int priv1;
	int priv2;
	char __data[0];
};

struct trace_event_raw_ext4_fc_replay_scan {
	struct trace_entry ent;
	dev_t dev;
	int error;
	int off;
	char __data[0];
};

struct trace_event_raw_ext4_fc_stats {
	struct trace_entry ent;
	dev_t dev;
	unsigned int fc_ineligible_rc[10];
	long unsigned int fc_commits;
	long unsigned int fc_ineligible_commits;
	long unsigned int fc_numblks;
	char __data[0];
};

struct trace_event_raw_ext4_fc_track_dentry {
	struct trace_entry ent;
	dev_t dev;
	tid_t t_tid;
	ino_t i_ino;
	tid_t i_sync_tid;
	int error;
	char __data[0];
};

struct trace_event_raw_ext4_fc_track_inode {
	struct trace_entry ent;
	dev_t dev;
	tid_t t_tid;
	ino_t i_ino;
	tid_t i_sync_tid;
	int error;
	char __data[0];
};

struct trace_event_raw_ext4_fc_track_range {
	struct trace_entry ent;
	dev_t dev;
	tid_t t_tid;
	ino_t i_ino;
	tid_t i_sync_tid;
	long int start;
	long int end;
	int error;
	char __data[0];
};

struct trace_event_raw_ext4_forget {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 block;
	int is_metadata;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_ext4_free_blocks {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 block;
	long unsigned int count;
	int flags;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_ext4_free_inode {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	uid_t uid;
	gid_t gid;
	__u64 blocks;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_ext4_fsmap_class {
	struct trace_entry ent;
	dev_t dev;
	dev_t keydev;
	u32 agno;
	u64 bno;
	u64 len;
	u64 owner;
	char __data[0];
};

struct trace_event_raw_ext4_get_implied_cluster_alloc_exit {
	struct trace_entry ent;
	dev_t dev;
	unsigned int flags;
	ext4_lblk_t lblk;
	ext4_fsblk_t pblk;
	unsigned int len;
	int ret;
	char __data[0];
};

struct trace_event_raw_ext4_getfsmap_class {
	struct trace_entry ent;
	dev_t dev;
	dev_t keydev;
	u64 block;
	u64 len;
	u64 owner;
	u64 flags;
	char __data[0];
};

struct trace_event_raw_ext4_insert_range {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t offset;
	loff_t len;
	char __data[0];
};

struct trace_event_raw_ext4_invalidate_folio_op {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	long unsigned int index;
	size_t offset;
	size_t length;
	char __data[0];
};

struct trace_event_raw_ext4_journal_start_inode {
	struct trace_entry ent;
	long unsigned int ino;
	dev_t dev;
	long unsigned int ip;
	int blocks;
	int rsv_blocks;
	int revoke_creds;
	int type;
	char __data[0];
};

struct trace_event_raw_ext4_journal_start_reserved {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int ip;
	int blocks;
	char __data[0];
};

struct trace_event_raw_ext4_journal_start_sb {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int ip;
	int blocks;
	int rsv_blocks;
	int revoke_creds;
	int type;
	char __data[0];
};

struct trace_event_raw_ext4_lazy_itable_init {
	struct trace_entry ent;
	dev_t dev;
	__u32 group;
	char __data[0];
};

struct trace_event_raw_ext4_load_inode {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	char __data[0];
};

struct trace_event_raw_ext4_mark_inode_dirty {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	long unsigned int ip;
	char __data[0];
};

struct trace_event_raw_ext4_mb_discard_preallocations {
	struct trace_entry ent;
	dev_t dev;
	int needed;
	char __data[0];
};

struct trace_event_raw_ext4_mb_release_group_pa {
	struct trace_entry ent;
	dev_t dev;
	__u64 pa_pstart;
	__u32 pa_len;
	char __data[0];
};

struct trace_event_raw_ext4_mb_release_inode_pa {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 block;
	__u32 count;
	char __data[0];
};

struct trace_event_raw_ext4_mballoc_alloc {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u32 orig_logical;
	int orig_start;
	__u32 orig_group;
	int orig_len;
	__u32 goal_logical;
	int goal_start;
	__u32 goal_group;
	int goal_len;
	__u32 result_logical;
	int result_start;
	__u32 result_group;
	int result_len;
	__u16 found;
	__u16 groups;
	__u16 buddy;
	__u16 flags;
	__u16 tail;
	__u8 cr;
	char __data[0];
};

struct trace_event_raw_ext4_mballoc_prealloc {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u32 orig_logical;
	int orig_start;
	__u32 orig_group;
	int orig_len;
	__u32 result_logical;
	int result_start;
	__u32 result_group;
	int result_len;
	char __data[0];
};

struct trace_event_raw_ext4_nfs_commit_metadata {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	char __data[0];
};

struct trace_event_raw_ext4_other_inode_update_time {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ino_t orig_ino;
	uid_t uid;
	gid_t gid;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_ext4_prefetch_bitmaps {
	struct trace_entry ent;
	dev_t dev;
	__u32 group;
	__u32 next;
	__u32 ios;
	char __data[0];
};

struct trace_event_raw_ext4_read_block_bitmap_load {
	struct trace_entry ent;
	dev_t dev;
	__u32 group;
	bool prefetch;
	char __data[0];
};

struct trace_event_raw_ext4_remove_blocks {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t from;
	ext4_lblk_t to;
	ext4_fsblk_t ee_pblk;
	ext4_lblk_t ee_lblk;
	short unsigned int ee_len;
	ext4_fsblk_t pc_pclu;
	ext4_lblk_t pc_lblk;
	int pc_state;
	char __data[0];
};

struct trace_event_raw_ext4_request_blocks {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	unsigned int len;
	__u32 logical;
	__u32 lleft;
	__u32 lright;
	__u64 goal;
	__u64 pleft;
	__u64 pright;
	unsigned int flags;
	char __data[0];
};

struct trace_event_raw_ext4_request_inode {
	struct trace_entry ent;
	dev_t dev;
	ino_t dir;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_ext4_shutdown {
	struct trace_entry ent;
	dev_t dev;
	unsigned int flags;
	char __data[0];
};

struct trace_event_raw_ext4_sync_file_enter {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ino_t parent;
	int datasync;
	char __data[0];
};

struct trace_event_raw_ext4_sync_file_exit {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	int ret;
	char __data[0];
};

struct trace_event_raw_ext4_sync_fs {
	struct trace_entry ent;
	dev_t dev;
	int wait;
	char __data[0];
};

struct trace_event_raw_ext4_unlink_enter {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ino_t parent;
	loff_t size;
	char __data[0];
};

struct trace_event_raw_ext4_unlink_exit {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	int ret;
	char __data[0];
};

struct trace_event_raw_ext4_update_sb {
	struct trace_entry ent;
	dev_t dev;
	ext4_fsblk_t fsblk;
	unsigned int flags;
	char __data[0];
};

struct trace_event_raw_ext4_writepages {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	long int nr_to_write;
	long int pages_skipped;
	loff_t range_start;
	loff_t range_end;
	long unsigned int writeback_index;
	int sync_mode;
	char for_kupdate;
	char range_cyclic;
	char __data[0];
};

struct trace_event_raw_ext4_writepages_result {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	int ret;
	int pages_written;
	long int pages_skipped;
	long unsigned int writeback_index;
	int sync_mode;
	char __data[0];
};

struct trace_event_raw_fib6_table_lookup {
	struct trace_entry ent;
	u32 tb_id;
	int err;
	int oif;
	int iif;
	u32 flowlabel;
	__u8 tos;
	__u8 scope;
	__u8 flags;
	__u8 src[16];
	__u8 dst[16];
	u16 sport;
	u16 dport;
	u8 proto;
	u8 rt_type;
	char name[16];
	__u8 gw[16];
	char __data[0];
};

struct trace_event_raw_fib_table_lookup {
	struct trace_entry ent;
	u32 tb_id;
	int err;
	int oif;
	int iif;
	u8 proto;
	__u8 tos;
	__u8 scope;
	__u8 flags;
	__u8 src[4];
	__u8 dst[4];
	__u8 gw4[4];
	__u8 gw6[16];
	u16 sport;
	u16 dport;
	char name[16];
	char __data[0];
};

struct trace_event_raw_file_check_and_advance_wb_err {
	struct trace_entry ent;
	struct file *file;
	long unsigned int i_ino;
	dev_t s_dev;
	errseq_t old;
	errseq_t new;
	char __data[0];
};

struct trace_event_raw_filelock_lease {
	struct trace_entry ent;
	struct file_lease *fl;
	long unsigned int i_ino;
	dev_t s_dev;
	struct file_lock_core *blocker;
	fl_owner_t owner;
	unsigned int flags;
	unsigned char type;
	long unsigned int break_time;
	long unsigned int downgrade_time;
	char __data[0];
};

struct trace_event_raw_filelock_lock {
	struct trace_entry ent;
	struct file_lock *fl;
	long unsigned int i_ino;
	dev_t s_dev;
	struct file_lock_core *blocker;
	fl_owner_t owner;
	unsigned int pid;
	unsigned int flags;
	unsigned char type;
	loff_t fl_start;
	loff_t fl_end;
	int ret;
	char __data[0];
};

struct trace_event_raw_filemap_set_wb_err {
	struct trace_entry ent;
	long unsigned int i_ino;
	dev_t s_dev;
	errseq_t errseq;
	char __data[0];
};

struct trace_event_raw_fill_mg_cmtime {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	time64_t ctime_s;
	time64_t mtime_s;
	u32 ctime_ns;
	u32 mtime_ns;
	u32 gen;
	char __data[0];
};

struct trace_event_raw_finish_task_reaping {
	struct trace_entry ent;
	int pid;
	char __data[0];
};

struct trace_event_raw_free_vmap_area_noflush {
	struct trace_entry ent;
	long unsigned int va_start;
	long unsigned int nr_lazy;
	long unsigned int nr_lazy_max;
	char __data[0];
};

struct trace_event_raw_g4x_wm {
	struct trace_entry ent;
	u32 __data_loc_dev;
	char pipe_name;
	u32 frame;
	u32 scanline;
	u16 primary;
	u16 sprite;
	u16 cursor;
	u16 sr_plane;
	u16 sr_cursor;
	u16 sr_fbc;
	u16 hpll_plane;
	u16 hpll_cursor;
	u16 hpll_fbc;
	bool cxsr;
	bool hpll;
	bool fbc;
	char __data[0];
};

struct trace_event_raw_generic_add_lease {
	struct trace_entry ent;
	long unsigned int i_ino;
	int wcount;
	int rcount;
	int icount;
	dev_t s_dev;
	fl_owner_t owner;
	unsigned int flags;
	unsigned char type;
	char __data[0];
};

struct trace_event_raw_global_dirty_state {
	struct trace_entry ent;
	long unsigned int nr_dirty;
	long unsigned int nr_writeback;
	long unsigned int background_thresh;
	long unsigned int dirty_thresh;
	long unsigned int dirty_limit;
	long unsigned int nr_dirtied;
	long unsigned int nr_written;
	char __data[0];
};

struct trace_event_raw_guest_halt_poll_ns {
	struct trace_entry ent;
	bool grow;
	unsigned int new;
	unsigned int old;
	char __data[0];
};

struct trace_event_raw_handshake_alert_class {
	struct trace_entry ent;
	__u8 saddr[28];
	__u8 daddr[28];
	unsigned int netns_ino;
	long unsigned int level;
	long unsigned int description;
	char __data[0];
};

struct trace_event_raw_handshake_complete {
	struct trace_entry ent;
	const void *req;
	const void *sk;
	int status;
	unsigned int netns_ino;
	char __data[0];
};

struct trace_event_raw_handshake_error_class {
	struct trace_entry ent;
	const void *req;
	const void *sk;
	int err;
	unsigned int netns_ino;
	char __data[0];
};

struct trace_event_raw_handshake_event_class {
	struct trace_entry ent;
	const void *req;
	const void *sk;
	unsigned int netns_ino;
	char __data[0];
};

struct trace_event_raw_handshake_fd_class {
	struct trace_entry ent;
	const void *req;
	const void *sk;
	int fd;
	unsigned int netns_ino;
	char __data[0];
};

struct trace_event_raw_hda_get_response {
	struct trace_entry ent;
	u32 __data_loc_name;
	u32 addr;
	u32 res;
	char __data[0];
};

struct trace_event_raw_hda_pm {
	struct trace_entry ent;
	int dev_index;
	char __data[0];
};

struct trace_event_raw_hda_send_cmd {
	struct trace_entry ent;
	u32 __data_loc_name;
	u32 cmd;
	char __data[0];
};

struct trace_event_raw_hda_unsol_event {
	struct trace_entry ent;
	u32 __data_loc_name;
	u32 res;
	u32 res_ex;
	char __data[0];
};

struct trace_event_raw_hdac_stream {
	struct trace_entry ent;
	unsigned char stream_tag;
	char __data[0];
};

struct trace_event_raw_hrtimer_class {
	struct trace_entry ent;
	void *hrtimer;
	char __data[0];
};

struct trace_event_raw_hrtimer_expire_entry {
	struct trace_entry ent;
	void *hrtimer;
	s64 now;
	void *function;
	char __data[0];
};

struct trace_event_raw_hrtimer_init {
	struct trace_entry ent;
	void *hrtimer;
	clockid_t clockid;
	enum hrtimer_mode mode;
	char __data[0];
};

struct trace_event_raw_hrtimer_start {
	struct trace_entry ent;
	void *hrtimer;
	void *function;
	s64 expires;
	s64 softexpires;
	enum hrtimer_mode mode;
	char __data[0];
};

struct trace_event_raw_hugetlbfs__inode {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u16 mode;
	loff_t size;
	unsigned int nlink;
	unsigned int seals;
	blkcnt_t blocks;
	char __data[0];
};

struct trace_event_raw_hugetlbfs_alloc_inode {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ino_t dir;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_hugetlbfs_fallocate {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	int mode;
	loff_t offset;
	loff_t len;
	loff_t size;
	int ret;
	char __data[0];
};

struct trace_event_raw_hugetlbfs_setattr {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	unsigned int d_len;
	u32 __data_loc_d_name;
	unsigned int ia_valid;
	unsigned int ia_mode;
	loff_t old_size;
	loff_t ia_size;
	char __data[0];
};

struct trace_event_raw_hwmon_attr_class {
	struct trace_entry ent;
	int index;
	u32 __data_loc_attr_name;
	long int val;
	char __data[0];
};

struct trace_event_raw_hwmon_attr_show_string {
	struct trace_entry ent;
	int index;
	u32 __data_loc_attr_name;
	u32 __data_loc_label;
	char __data[0];
};

struct trace_event_raw_i2c_read {
	struct trace_entry ent;
	int adapter_nr;
	__u16 msg_nr;
	__u16 addr;
	__u16 flags;
	__u16 len;
	char __data[0];
};

struct trace_event_raw_i2c_reply {
	struct trace_entry ent;
	int adapter_nr;
	__u16 msg_nr;
	__u16 addr;
	__u16 flags;
	__u16 len;
	u32 __data_loc_buf;
	char __data[0];
};

struct trace_event_raw_i2c_result {
	struct trace_entry ent;
	int adapter_nr;
	__u16 nr_msgs;
	__s16 ret;
	char __data[0];
};

struct trace_event_raw_i2c_write {
	struct trace_entry ent;
	int adapter_nr;
	__u16 msg_nr;
	__u16 addr;
	__u16 flags;
	__u16 len;
	u32 __data_loc_buf;
	char __data[0];
};

struct trace_event_raw_i915_context {
	struct trace_entry ent;
	u32 dev;
	struct i915_gem_context *ctx;
	struct i915_address_space *vm;
	char __data[0];
};

struct trace_event_raw_i915_gem_evict {
	struct trace_entry ent;
	u32 dev;
	struct i915_address_space *vm;
	u64 size;
	u64 align;
	unsigned int flags;
	char __data[0];
};

struct trace_event_raw_i915_gem_evict_node {
	struct trace_entry ent;
	u32 dev;
	struct i915_address_space *vm;
	u64 start;
	u64 size;
	long unsigned int color;
	unsigned int flags;
	char __data[0];
};

struct trace_event_raw_i915_gem_evict_vm {
	struct trace_entry ent;
	u32 dev;
	struct i915_address_space *vm;
	char __data[0];
};

struct trace_event_raw_i915_gem_object {
	struct trace_entry ent;
	struct drm_i915_gem_object *obj;
	char __data[0];
};

struct trace_event_raw_i915_gem_object_create {
	struct trace_entry ent;
	struct drm_i915_gem_object *obj;
	u64 size;
	char __data[0];
};

struct trace_event_raw_i915_gem_object_fault {
	struct trace_entry ent;
	struct drm_i915_gem_object *obj;
	u64 index;
	bool gtt;
	bool write;
	char __data[0];
};

struct trace_event_raw_i915_gem_object_pread {
	struct trace_entry ent;
	struct drm_i915_gem_object *obj;
	u64 offset;
	u64 len;
	char __data[0];
};

struct trace_event_raw_i915_gem_object_pwrite {
	struct trace_entry ent;
	struct drm_i915_gem_object *obj;
	u64 offset;
	u64 len;
	char __data[0];
};

struct trace_event_raw_i915_gem_shrink {
	struct trace_entry ent;
	int dev;
	long unsigned int target;
	unsigned int flags;
	char __data[0];
};

struct trace_event_raw_i915_ppgtt {
	struct trace_entry ent;
	struct i915_address_space *vm;
	u32 dev;
	char __data[0];
};

struct trace_event_raw_i915_reg_rw {
	struct trace_entry ent;
	u64 val;
	u32 reg;
	u16 write;
	u16 len;
	char __data[0];
};

struct trace_event_raw_i915_request {
	struct trace_entry ent;
	u32 dev;
	u64 ctx;
	u16 class;
	u16 instance;
	u32 seqno;
	u32 tail;
	char __data[0];
};

struct trace_event_raw_i915_request_queue {
	struct trace_entry ent;
	u32 dev;
	u64 ctx;
	u16 class;
	u16 instance;
	u32 seqno;
	u32 flags;
	char __data[0];
};

struct trace_event_raw_i915_request_wait_begin {
	struct trace_entry ent;
	u32 dev;
	u64 ctx;
	u16 class;
	u16 instance;
	u32 seqno;
	unsigned int flags;
	char __data[0];
};

struct trace_event_raw_i915_vma_bind {
	struct trace_entry ent;
	struct drm_i915_gem_object *obj;
	struct i915_address_space *vm;
	u64 offset;
	u64 size;
	unsigned int flags;
	char __data[0];
};

struct trace_event_raw_i915_vma_unbind {
	struct trace_entry ent;
	struct drm_i915_gem_object *obj;
	struct i915_address_space *vm;
	u64 offset;
	u64 size;
	char __data[0];
};

struct trace_event_raw_icmp_send {
	struct trace_entry ent;
	const void *skbaddr;
	int type;
	int code;
	__u8 saddr[4];
	__u8 daddr[4];
	__u16 sport;
	__u16 dport;
	short unsigned int ulen;
	char __data[0];
};

struct trace_event_raw_inet_sk_error_report {
	struct trace_entry ent;
	int error;
	__u16 sport;
	__u16 dport;
	__u16 family;
	__u16 protocol;
	__u8 saddr[4];
	__u8 daddr[4];
	__u8 saddr_v6[16];
	__u8 daddr_v6[16];
	char __data[0];
};

struct trace_event_raw_inet_sock_set_state {
	struct trace_entry ent;
	const void *skaddr;
	int oldstate;
	int newstate;
	__u16 sport;
	__u16 dport;
	__u16 family;
	__u16 protocol;
	__u8 saddr[4];
	__u8 daddr[4];
	__u8 saddr_v6[16];
	__u8 daddr_v6[16];
	char __data[0];
};

typedef int (*initcall_t)(void);

struct trace_event_raw_initcall_finish {
	struct trace_entry ent;
	initcall_t func;
	int ret;
	char __data[0];
};

struct trace_event_raw_initcall_level {
	struct trace_entry ent;
	u32 __data_loc_level;
	char __data[0];
};

struct trace_event_raw_initcall_start {
	struct trace_entry ent;
	initcall_t func;
	char __data[0];
};

struct trace_event_raw_intel_cpu_fifo_underrun {
	struct trace_entry ent;
	u32 __data_loc_dev;
	char pipe_name;
	u32 frame;
	u32 scanline;
	char __data[0];
};

struct trace_event_raw_intel_crtc_flip_done {
	struct trace_entry ent;
	u32 __data_loc_dev;
	char pipe_name;
	u32 frame;
	u32 scanline;
	char __data[0];
};

struct trace_event_raw_intel_crtc_vblank_work_end {
	struct trace_entry ent;
	u32 __data_loc_dev;
	char pipe_name;
	u32 frame;
	u32 scanline;
	char __data[0];
};

struct trace_event_raw_intel_crtc_vblank_work_start {
	struct trace_entry ent;
	u32 __data_loc_dev;
	char pipe_name;
	u32 frame;
	u32 scanline;
	char __data[0];
};

struct trace_event_raw_intel_fbc_activate {
	struct trace_entry ent;
	u32 __data_loc_dev;
	u32 __data_loc_name;
	char pipe_name;
	u32 frame;
	u32 scanline;
	char __data[0];
};

struct trace_event_raw_intel_fbc_deactivate {
	struct trace_entry ent;
	u32 __data_loc_dev;
	u32 __data_loc_name;
	char pipe_name;
	u32 frame;
	u32 scanline;
	char __data[0];
};

struct trace_event_raw_intel_fbc_nuke {
	struct trace_entry ent;
	u32 __data_loc_dev;
	u32 __data_loc_name;
	char pipe_name;
	u32 frame;
	u32 scanline;
	char __data[0];
};

struct trace_event_raw_intel_frontbuffer_flush {
	struct trace_entry ent;
	u32 __data_loc_dev;
	unsigned int frontbuffer_bits;
	unsigned int origin;
	char __data[0];
};

struct trace_event_raw_intel_frontbuffer_invalidate {
	struct trace_entry ent;
	u32 __data_loc_dev;
	unsigned int frontbuffer_bits;
	unsigned int origin;
	char __data[0];
};

struct trace_event_raw_intel_memory_cxsr {
	struct trace_entry ent;
	u32 __data_loc_dev;
	u32 frame[4];
	u32 scanline[4];
	bool old;
	bool new;
	char __data[0];
};

struct trace_event_raw_intel_pch_fifo_underrun {
	struct trace_entry ent;
	u32 __data_loc_dev;
	char pipe_name;
	u32 frame;
	u32 scanline;
	char __data[0];
};

struct trace_event_raw_intel_pipe_crc {
	struct trace_entry ent;
	u32 __data_loc_dev;
	char pipe_name;
	u32 frame;
	u32 scanline;
	u32 crcs[5];
	char __data[0];
};

struct trace_event_raw_intel_pipe_disable {
	struct trace_entry ent;
	u32 __data_loc_dev;
	u32 frame[4];
	u32 scanline[4];
	char pipe_name;
	char __data[0];
};

struct trace_event_raw_intel_pipe_enable {
	struct trace_entry ent;
	u32 __data_loc_dev;
	u32 frame[4];
	u32 scanline[4];
	char pipe_name;
	char __data[0];
};

struct trace_event_raw_intel_pipe_update_end {
	struct trace_entry ent;
	u32 __data_loc_dev;
	char pipe_name;
	u32 frame;
	u32 scanline;
	char __data[0];
};

struct trace_event_raw_intel_pipe_update_start {
	struct trace_entry ent;
	u32 __data_loc_dev;
	char pipe_name;
	u32 frame;
	u32 scanline;
	u32 min;
	u32 max;
	char __data[0];
};

struct trace_event_raw_intel_pipe_update_vblank_evaded {
	struct trace_entry ent;
	u32 __data_loc_dev;
	char pipe_name;
	u32 frame;
	u32 scanline;
	u32 min;
	u32 max;
	char __data[0];
};

struct trace_event_raw_intel_plane_async_flip {
	struct trace_entry ent;
	u32 __data_loc_dev;
	char pipe_name;
	u32 frame;
	u32 scanline;
	bool async_flip;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_intel_plane_disable_arm {
	struct trace_entry ent;
	u32 __data_loc_dev;
	char pipe_name;
	u32 frame;
	u32 scanline;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_intel_plane_update_arm {
	struct trace_entry ent;
	u32 __data_loc_dev;
	char pipe_name;
	u32 frame;
	u32 scanline;
	int src[4];
	int dst[4];
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_intel_plane_update_noarm {
	struct trace_entry ent;
	u32 __data_loc_dev;
	char pipe_name;
	u32 frame;
	u32 scanline;
	int src[4];
	int dst[4];
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_io_uring_complete {
	struct trace_entry ent;
	void *ctx;
	void *req;
	u64 user_data;
	int res;
	unsigned int cflags;
	u64 extra1;
	u64 extra2;
	char __data[0];
};

struct trace_event_raw_io_uring_cqe_overflow {
	struct trace_entry ent;
	void *ctx;
	long long unsigned int user_data;
	s32 res;
	u32 cflags;
	void *ocqe;
	char __data[0];
};

struct trace_event_raw_io_uring_cqring_wait {
	struct trace_entry ent;
	void *ctx;
	int min_events;
	char __data[0];
};

struct trace_event_raw_io_uring_create {
	struct trace_entry ent;
	int fd;
	void *ctx;
	u32 sq_entries;
	u32 cq_entries;
	u32 flags;
	char __data[0];
};

struct trace_event_raw_io_uring_defer {
	struct trace_entry ent;
	void *ctx;
	void *req;
	long long unsigned int data;
	u8 opcode;
	u32 __data_loc_op_str;
	char __data[0];
};

struct trace_event_raw_io_uring_fail_link {
	struct trace_entry ent;
	void *ctx;
	void *req;
	long long unsigned int user_data;
	u8 opcode;
	void *link;
	u32 __data_loc_op_str;
	char __data[0];
};

struct trace_event_raw_io_uring_file_get {
	struct trace_entry ent;
	void *ctx;
	void *req;
	u64 user_data;
	int fd;
	char __data[0];
};

struct trace_event_raw_io_uring_link {
	struct trace_entry ent;
	void *ctx;
	void *req;
	void *target_req;
	char __data[0];
};

struct trace_event_raw_io_uring_local_work_run {
	struct trace_entry ent;
	void *ctx;
	int count;
	unsigned int loops;
	char __data[0];
};

struct trace_event_raw_io_uring_poll_arm {
	struct trace_entry ent;
	void *ctx;
	void *req;
	long long unsigned int user_data;
	u8 opcode;
	int mask;
	int events;
	u32 __data_loc_op_str;
	char __data[0];
};

struct trace_event_raw_io_uring_queue_async_work {
	struct trace_entry ent;
	void *ctx;
	void *req;
	u64 user_data;
	u8 opcode;
	long long unsigned int flags;
	struct io_wq_work *work;
	int rw;
	u32 __data_loc_op_str;
	char __data[0];
};

struct trace_event_raw_io_uring_register {
	struct trace_entry ent;
	void *ctx;
	unsigned int opcode;
	unsigned int nr_files;
	unsigned int nr_bufs;
	long int ret;
	char __data[0];
};

struct trace_event_raw_io_uring_req_failed {
	struct trace_entry ent;
	void *ctx;
	void *req;
	long long unsigned int user_data;
	u8 opcode;
	u8 flags;
	u8 ioprio;
	u64 off;
	u64 addr;
	u32 len;
	u32 op_flags;
	u16 buf_index;
	u16 personality;
	u32 file_index;
	u64 pad1;
	u64 addr3;
	int error;
	u32 __data_loc_op_str;
	char __data[0];
};

struct trace_event_raw_io_uring_short_write {
	struct trace_entry ent;
	void *ctx;
	u64 fpos;
	u64 wanted;
	u64 got;
	char __data[0];
};

struct trace_event_raw_io_uring_submit_req {
	struct trace_entry ent;
	void *ctx;
	void *req;
	long long unsigned int user_data;
	u8 opcode;
	long long unsigned int flags;
	bool sq_thread;
	u32 __data_loc_op_str;
	char __data[0];
};

struct trace_event_raw_io_uring_task_add {
	struct trace_entry ent;
	void *ctx;
	void *req;
	long long unsigned int user_data;
	u8 opcode;
	int mask;
	u32 __data_loc_op_str;
	char __data[0];
};

struct trace_event_raw_io_uring_task_work_run {
	struct trace_entry ent;
	void *tctx;
	unsigned int count;
	char __data[0];
};

struct trace_event_raw_iocg_inuse_update {
	struct trace_entry ent;
	u32 __data_loc_devname;
	u32 __data_loc_cgroup;
	u64 now;
	u32 old_inuse;
	u32 new_inuse;
	u64 old_hweight_inuse;
	u64 new_hweight_inuse;
	char __data[0];
};

struct trace_event_raw_iocost_ioc_vrate_adj {
	struct trace_entry ent;
	u32 __data_loc_devname;
	u64 old_vrate;
	u64 new_vrate;
	int busy_level;
	u32 read_missed_ppm;
	u32 write_missed_ppm;
	u32 rq_wait_pct;
	int nr_lagging;
	int nr_shortages;
	char __data[0];
};

struct trace_event_raw_iocost_iocg_forgive_debt {
	struct trace_entry ent;
	u32 __data_loc_devname;
	u32 __data_loc_cgroup;
	u64 now;
	u64 vnow;
	u32 usage_pct;
	u64 old_debt;
	u64 new_debt;
	u64 old_delay;
	u64 new_delay;
	char __data[0];
};

struct trace_event_raw_iocost_iocg_state {
	struct trace_entry ent;
	u32 __data_loc_devname;
	u32 __data_loc_cgroup;
	u64 now;
	u64 vnow;
	u64 vrate;
	u64 last_period;
	u64 cur_period;
	u64 vtime;
	u32 weight;
	u32 inuse;
	u64 hweight_active;
	u64 hweight_inuse;
	char __data[0];
};

struct trace_event_raw_iomap_class {
	struct trace_entry ent;
	dev_t dev;
	u64 ino;
	u64 addr;
	loff_t offset;
	u64 length;
	u16 type;
	u16 flags;
	dev_t bdev;
	char __data[0];
};

struct trace_event_raw_iomap_dio_complete {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t isize;
	loff_t pos;
	int ki_flags;
	bool aio;
	int error;
	ssize_t ret;
	char __data[0];
};

struct trace_event_raw_iomap_dio_rw_begin {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t isize;
	loff_t pos;
	size_t count;
	size_t done_before;
	int ki_flags;
	unsigned int dio_flags;
	bool aio;
	char __data[0];
};

struct trace_event_raw_iomap_iter {
	struct trace_entry ent;
	dev_t dev;
	u64 ino;
	loff_t pos;
	u64 length;
	s64 processed;
	unsigned int flags;
	const void *ops;
	long unsigned int caller;
	char __data[0];
};

struct trace_event_raw_iomap_range_class {
	struct trace_entry ent;
	dev_t dev;
	u64 ino;
	loff_t size;
	loff_t offset;
	u64 length;
	char __data[0];
};

struct trace_event_raw_iomap_readpage_class {
	struct trace_entry ent;
	dev_t dev;
	u64 ino;
	int nr_pages;
	char __data[0];
};

struct trace_event_raw_iomap_writepage_map {
	struct trace_entry ent;
	dev_t dev;
	u64 ino;
	u64 pos;
	u64 dirty_len;
	u64 addr;
	loff_t offset;
	u64 length;
	u16 type;
	u16 flags;
	dev_t bdev;
	char __data[0];
};

struct trace_event_raw_iommu_device_event {
	struct trace_entry ent;
	u32 __data_loc_device;
	char __data[0];
};

struct trace_event_raw_iommu_error {
	struct trace_entry ent;
	u32 __data_loc_device;
	u32 __data_loc_driver;
	u64 iova;
	int flags;
	char __data[0];
};

struct trace_event_raw_iommu_group_event {
	struct trace_entry ent;
	int gid;
	u32 __data_loc_device;
	char __data[0];
};

struct trace_event_raw_ipi_handler {
	struct trace_entry ent;
	const char *reason;
	char __data[0];
};

struct trace_event_raw_ipi_raise {
	struct trace_entry ent;
	u32 __data_loc_target_cpus;
	const char *reason;
	char __data[0];
};

struct trace_event_raw_ipi_send_cpu {
	struct trace_entry ent;
	unsigned int cpu;
	void *callsite;
	void *callback;
	char __data[0];
};

struct trace_event_raw_ipi_send_cpumask {
	struct trace_entry ent;
	u32 __data_loc_cpumask;
	void *callsite;
	void *callback;
	char __data[0];
};

struct trace_event_raw_irq_handler_entry {
	struct trace_entry ent;
	int irq;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_irq_handler_exit {
	struct trace_entry ent;
	int irq;
	int ret;
	char __data[0];
};

struct trace_event_raw_irq_matrix_cpu {
	struct trace_entry ent;
	int bit;
	unsigned int cpu;
	bool online;
	unsigned int available;
	unsigned int allocated;
	unsigned int managed;
	unsigned int online_maps;
	unsigned int global_available;
	unsigned int global_reserved;
	unsigned int total_allocated;
	char __data[0];
};

struct trace_event_raw_irq_matrix_global {
	struct trace_entry ent;
	unsigned int online_maps;
	unsigned int global_available;
	unsigned int global_reserved;
	unsigned int total_allocated;
	char __data[0];
};

struct trace_event_raw_irq_matrix_global_update {
	struct trace_entry ent;
	int bit;
	unsigned int online_maps;
	unsigned int global_available;
	unsigned int global_reserved;
	unsigned int total_allocated;
	char __data[0];
};

struct trace_event_raw_itimer_expire {
	struct trace_entry ent;
	int which;
	pid_t pid;
	long long unsigned int now;
	char __data[0];
};

struct trace_event_raw_itimer_state {
	struct trace_entry ent;
	int which;
	long long unsigned int expires;
	long int value_sec;
	long int value_nsec;
	long int interval_sec;
	long int interval_nsec;
	char __data[0];
};

struct trace_event_raw_jbd2_checkpoint {
	struct trace_entry ent;
	dev_t dev;
	int result;
	char __data[0];
};

struct trace_event_raw_jbd2_checkpoint_stats {
	struct trace_entry ent;
	dev_t dev;
	tid_t tid;
	long unsigned int chp_time;
	__u32 forced_to_close;
	__u32 written;
	__u32 dropped;
	char __data[0];
};

struct trace_event_raw_jbd2_commit {
	struct trace_entry ent;
	dev_t dev;
	char sync_commit;
	tid_t transaction;
	char __data[0];
};

struct trace_event_raw_jbd2_end_commit {
	struct trace_entry ent;
	dev_t dev;
	char sync_commit;
	tid_t transaction;
	tid_t head;
	char __data[0];
};

struct trace_event_raw_jbd2_handle_extend {
	struct trace_entry ent;
	dev_t dev;
	tid_t tid;
	unsigned int type;
	unsigned int line_no;
	int buffer_credits;
	int requested_blocks;
	char __data[0];
};

struct trace_event_raw_jbd2_handle_start_class {
	struct trace_entry ent;
	dev_t dev;
	tid_t tid;
	unsigned int type;
	unsigned int line_no;
	int requested_blocks;
	char __data[0];
};

struct trace_event_raw_jbd2_handle_stats {
	struct trace_entry ent;
	dev_t dev;
	tid_t tid;
	unsigned int type;
	unsigned int line_no;
	int interval;
	int sync;
	int requested_blocks;
	int dirtied_blocks;
	char __data[0];
};

struct trace_event_raw_jbd2_journal_shrink {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int nr_to_scan;
	long unsigned int count;
	char __data[0];
};

struct trace_event_raw_jbd2_lock_buffer_stall {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int stall_ms;
	char __data[0];
};

struct trace_event_raw_jbd2_run_stats {
	struct trace_entry ent;
	dev_t dev;
	tid_t tid;
	long unsigned int wait;
	long unsigned int request_delay;
	long unsigned int running;
	long unsigned int locked;
	long unsigned int flushing;
	long unsigned int logging;
	__u32 handle_count;
	__u32 blocks;
	__u32 blocks_logged;
	char __data[0];
};

struct trace_event_raw_jbd2_shrink_checkpoint_list {
	struct trace_entry ent;
	dev_t dev;
	tid_t first_tid;
	tid_t tid;
	tid_t last_tid;
	long unsigned int nr_freed;
	tid_t next_tid;
	char __data[0];
};

struct trace_event_raw_jbd2_shrink_scan_exit {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int nr_to_scan;
	long unsigned int nr_shrunk;
	long unsigned int count;
	char __data[0];
};

struct trace_event_raw_jbd2_submit_inode_data {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	char __data[0];
};

struct trace_event_raw_jbd2_update_log_tail {
	struct trace_entry ent;
	dev_t dev;
	tid_t tail_sequence;
	tid_t first_tid;
	long unsigned int block_nr;
	long unsigned int freed;
	char __data[0];
};

struct trace_event_raw_jbd2_write_superblock {
	struct trace_entry ent;
	dev_t dev;
	blk_opf_t write_flags;
	char __data[0];
};

struct trace_event_raw_kcompactd_wake_template {
	struct trace_entry ent;
	int nid;
	int order;
	enum zone_type highest_zoneidx;
	char __data[0];
};

struct trace_event_raw_key_handle {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 mac_addr[6];
	int link_id;
	u8 key_index;
	bool pairwise;
	char __data[0];
};

struct trace_event_raw_kfree {
	struct trace_entry ent;
	long unsigned int call_site;
	const void *ptr;
	char __data[0];
};

struct trace_event_raw_kfree_skb {
	struct trace_entry ent;
	void *skbaddr;
	void *location;
	void *rx_sk;
	short unsigned int protocol;
	enum skb_drop_reason reason;
	char __data[0];
};

struct trace_event_raw_kmalloc {
	struct trace_entry ent;
	long unsigned int call_site;
	const void *ptr;
	size_t bytes_req;
	size_t bytes_alloc;
	long unsigned int gfp_flags;
	int node;
	char __data[0];
};

struct trace_event_raw_kmem_cache_alloc {
	struct trace_entry ent;
	long unsigned int call_site;
	const void *ptr;
	size_t bytes_req;
	size_t bytes_alloc;
	long unsigned int gfp_flags;
	int node;
	bool accounted;
	char __data[0];
};

struct trace_event_raw_kmem_cache_free {
	struct trace_entry ent;
	long unsigned int call_site;
	const void *ptr;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_kyber_adjust {
	struct trace_entry ent;
	dev_t dev;
	char domain[16];
	unsigned int depth;
	char __data[0];
};

struct trace_event_raw_kyber_latency {
	struct trace_entry ent;
	dev_t dev;
	char domain[16];
	char type[8];
	u8 percentile;
	u8 numerator;
	u8 denominator;
	unsigned int samples;
	char __data[0];
};

struct trace_event_raw_kyber_throttled {
	struct trace_entry ent;
	dev_t dev;
	char domain[16];
	char __data[0];
};

struct trace_event_raw_leases_conflict {
	struct trace_entry ent;
	void *lease;
	void *breaker;
	unsigned int l_fl_flags;
	unsigned int b_fl_flags;
	unsigned char l_fl_type;
	unsigned char b_fl_type;
	bool conflict;
	char __data[0];
};

struct trace_event_raw_link_station_add_mod {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 mld_mac[6];
	u8 link_mac[6];
	u32 link_id;
	u32 __data_loc_supported_rates;
	u8 ht_capa[26];
	u8 vht_capa[12];
	u8 opmode_notif;
	bool opmode_notif_used;
	u32 __data_loc_he_capa;
	u8 he_6ghz_capa[2];
	u32 __data_loc_eht_capa;
	char __data[0];
};

struct trace_event_raw_local_chanctx {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 control_freq;
	u32 freq_offset;
	u32 chan_width;
	u32 center_freq1;
	u32 freq1_offset;
	u32 center_freq2;
	u32 min_control_freq;
	u32 min_freq_offset;
	u32 min_chan_width;
	u32 min_center_freq1;
	u32 min_freq1_offset;
	u32 min_center_freq2;
	u32 ap_control_freq;
	u32 ap_freq_offset;
	u32 ap_chan_width;
	u32 ap_center_freq1;
	u32 ap_freq1_offset;
	u32 ap_center_freq2;
	u8 rx_chains_static;
	u8 rx_chains_dynamic;
	char __data[0];
};

struct trace_event_raw_local_only_evt {
	struct trace_entry ent;
	char wiphy_name[32];
	char __data[0];
};

struct trace_event_raw_local_sdata_addr_evt {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	char addr[6];
	char __data[0];
};

struct trace_event_raw_local_sdata_chanctx {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	u32 control_freq;
	u32 freq_offset;
	u32 chan_width;
	u32 center_freq1;
	u32 freq1_offset;
	u32 center_freq2;
	u32 min_control_freq;
	u32 min_freq_offset;
	u32 min_chan_width;
	u32 min_center_freq1;
	u32 min_freq1_offset;
	u32 min_center_freq2;
	u32 ap_control_freq;
	u32 ap_freq_offset;
	u32 ap_chan_width;
	u32 ap_center_freq1;
	u32 ap_freq1_offset;
	u32 ap_center_freq2;
	u8 rx_chains_static;
	u8 rx_chains_dynamic;
	unsigned int link_id;
	char __data[0];
};

struct trace_event_raw_local_sdata_evt {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	char __data[0];
};

struct trace_event_raw_local_u32_evt {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 value;
	char __data[0];
};

struct trace_event_raw_locks_get_lock_context {
	struct trace_entry ent;
	long unsigned int i_ino;
	dev_t s_dev;
	unsigned char type;
	struct file_lock_context *ctx;
	char __data[0];
};

struct trace_event_raw_ma_op {
	struct trace_entry ent;
	const char *fn;
	long unsigned int min;
	long unsigned int max;
	long unsigned int index;
	long unsigned int last;
	void *node;
	char __data[0];
};

struct trace_event_raw_ma_read {
	struct trace_entry ent;
	const char *fn;
	long unsigned int min;
	long unsigned int max;
	long unsigned int index;
	long unsigned int last;
	void *node;
	char __data[0];
};

struct trace_event_raw_ma_write {
	struct trace_entry ent;
	const char *fn;
	long unsigned int min;
	long unsigned int max;
	long unsigned int index;
	long unsigned int last;
	long unsigned int piv;
	void *val;
	void *node;
	char __data[0];
};

struct trace_event_raw_map {
	struct trace_entry ent;
	u64 iova;
	u64 paddr;
	size_t size;
	char __data[0];
};

struct trace_event_raw_mark_victim {
	struct trace_entry ent;
	int pid;
	u32 __data_loc_comm;
	long unsigned int total_vm;
	long unsigned int anon_rss;
	long unsigned int file_rss;
	long unsigned int shmem_rss;
	uid_t uid;
	long unsigned int pgtables;
	short int oom_score_adj;
	char __data[0];
};

struct trace_event_raw_mce_record {
	struct trace_entry ent;
	u64 mcgcap;
	u64 mcgstatus;
	u64 status;
	u64 addr;
	u64 misc;
	u64 synd;
	u64 ipid;
	u64 ip;
	u64 tsc;
	u64 ppin;
	u64 walltime;
	u32 cpu;
	u32 cpuid;
	u32 apicid;
	u32 socketid;
	u8 cs;
	u8 bank;
	u8 cpuvendor;
	u32 microcode;
	u32 __data_loc_v_data;
	char __data[0];
};

struct trace_event_raw_mdio_access {
	struct trace_entry ent;
	char busid[61];
	char read;
	u8 addr;
	u16 val;
	unsigned int regnum;
	char __data[0];
};

struct trace_event_raw_mei_pci_cfg_read {
	struct trace_entry ent;
	u32 __data_loc_dev;
	const char *reg;
	u32 offs;
	u32 val;
	char __data[0];
};

struct trace_event_raw_mei_reg_read {
	struct trace_entry ent;
	u32 __data_loc_dev;
	const char *reg;
	u32 offs;
	u32 val;
	char __data[0];
};

struct trace_event_raw_mei_reg_write {
	struct trace_entry ent;
	u32 __data_loc_dev;
	const char *reg;
	u32 offs;
	u32 val;
	char __data[0];
};

struct xdp_mem_allocator;

struct trace_event_raw_mem_connect {
	struct trace_entry ent;
	const struct xdp_mem_allocator *xa;
	u32 mem_id;
	u32 mem_type;
	const void *allocator;
	const struct xdp_rxq_info *rxq;
	int ifindex;
	char __data[0];
};

struct trace_event_raw_mem_disconnect {
	struct trace_entry ent;
	const struct xdp_mem_allocator *xa;
	u32 mem_id;
	u32 mem_type;
	const void *allocator;
	char __data[0];
};

struct trace_event_raw_mem_return_failed {
	struct trace_entry ent;
	const struct page *page;
	u32 mem_id;
	u32 mem_type;
	char __data[0];
};

struct trace_event_raw_mgd_prepare_complete_tx_evt {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	u32 duration;
	u16 subtype;
	u8 success;
	char __data[0];
};

struct trace_event_raw_migration_pte {
	struct trace_entry ent;
	long unsigned int addr;
	long unsigned int pte;
	int order;
	char __data[0];
};

struct trace_event_raw_mm_alloc_contig_migrate_range_info {
	struct trace_entry ent;
	long unsigned int start;
	long unsigned int end;
	long unsigned int nr_migrated;
	long unsigned int nr_reclaimed;
	long unsigned int nr_mapped;
	int migratetype;
	char __data[0];
};

struct trace_event_raw_mm_compaction_begin {
	struct trace_entry ent;
	long unsigned int zone_start;
	long unsigned int migrate_pfn;
	long unsigned int free_pfn;
	long unsigned int zone_end;
	bool sync;
	char __data[0];
};

struct trace_event_raw_mm_compaction_defer_template {
	struct trace_entry ent;
	int nid;
	enum zone_type idx;
	int order;
	unsigned int considered;
	unsigned int defer_shift;
	int order_failed;
	char __data[0];
};

struct trace_event_raw_mm_compaction_end {
	struct trace_entry ent;
	long unsigned int zone_start;
	long unsigned int migrate_pfn;
	long unsigned int free_pfn;
	long unsigned int zone_end;
	bool sync;
	int status;
	char __data[0];
};

struct trace_event_raw_mm_compaction_isolate_template {
	struct trace_entry ent;
	long unsigned int start_pfn;
	long unsigned int end_pfn;
	long unsigned int nr_scanned;
	long unsigned int nr_taken;
	char __data[0];
};

struct trace_event_raw_mm_compaction_kcompactd_sleep {
	struct trace_entry ent;
	int nid;
	char __data[0];
};

struct trace_event_raw_mm_compaction_migratepages {
	struct trace_entry ent;
	long unsigned int nr_migrated;
	long unsigned int nr_failed;
	char __data[0];
};

struct trace_event_raw_mm_compaction_suitable_template {
	struct trace_entry ent;
	int nid;
	enum zone_type idx;
	int order;
	int ret;
	char __data[0];
};

struct trace_event_raw_mm_compaction_try_to_compact_pages {
	struct trace_entry ent;
	int order;
	long unsigned int gfp_mask;
	int prio;
	char __data[0];
};

struct trace_event_raw_mm_filemap_fault {
	struct trace_entry ent;
	long unsigned int i_ino;
	dev_t s_dev;
	long unsigned int index;
	char __data[0];
};

struct trace_event_raw_mm_filemap_op_page_cache {
	struct trace_entry ent;
	long unsigned int pfn;
	long unsigned int i_ino;
	long unsigned int index;
	dev_t s_dev;
	unsigned char order;
	char __data[0];
};

struct trace_event_raw_mm_filemap_op_page_cache_range {
	struct trace_entry ent;
	long unsigned int i_ino;
	dev_t s_dev;
	long unsigned int index;
	long unsigned int last_index;
	char __data[0];
};

struct trace_event_raw_mm_lru_activate {
	struct trace_entry ent;
	struct folio *folio;
	long unsigned int pfn;
	char __data[0];
};

struct trace_event_raw_mm_lru_insertion {
	struct trace_entry ent;
	struct folio *folio;
	long unsigned int pfn;
	enum lru_list lru;
	long unsigned int flags;
	char __data[0];
};

struct trace_event_raw_mm_migrate_pages {
	struct trace_entry ent;
	long unsigned int succeeded;
	long unsigned int failed;
	long unsigned int thp_succeeded;
	long unsigned int thp_failed;
	long unsigned int thp_split;
	long unsigned int large_folio_split;
	enum migrate_mode mode;
	int reason;
	char __data[0];
};

struct trace_event_raw_mm_migrate_pages_start {
	struct trace_entry ent;
	enum migrate_mode mode;
	int reason;
	char __data[0];
};

struct trace_event_raw_mm_page {
	struct trace_entry ent;
	long unsigned int pfn;
	unsigned int order;
	int migratetype;
	int percpu_refill;
	char __data[0];
};

struct trace_event_raw_mm_page_alloc {
	struct trace_entry ent;
	long unsigned int pfn;
	unsigned int order;
	long unsigned int gfp_flags;
	int migratetype;
	char __data[0];
};

struct trace_event_raw_mm_page_alloc_extfrag {
	struct trace_entry ent;
	long unsigned int pfn;
	int alloc_order;
	int fallback_order;
	int alloc_migratetype;
	int fallback_migratetype;
	int change_ownership;
	char __data[0];
};

struct trace_event_raw_mm_page_free {
	struct trace_entry ent;
	long unsigned int pfn;
	unsigned int order;
	char __data[0];
};

struct trace_event_raw_mm_page_free_batched {
	struct trace_entry ent;
	long unsigned int pfn;
	char __data[0];
};

struct trace_event_raw_mm_page_pcpu_drain {
	struct trace_entry ent;
	long unsigned int pfn;
	unsigned int order;
	int migratetype;
	char __data[0];
};

struct trace_event_raw_mm_shrink_slab_end {
	struct trace_entry ent;
	struct shrinker *shr;
	int nid;
	void *shrink;
	long int unused_scan;
	long int new_scan;
	int retval;
	long int total_scan;
	char __data[0];
};

struct trace_event_raw_mm_shrink_slab_start {
	struct trace_entry ent;
	struct shrinker *shr;
	void *shrink;
	int nid;
	long int nr_objects_to_shrink;
	long unsigned int gfp_flags;
	long unsigned int cache_items;
	long long unsigned int delta;
	long unsigned int total_scan;
	int priority;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_direct_reclaim_begin_template {
	struct trace_entry ent;
	int order;
	long unsigned int gfp_flags;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_direct_reclaim_end_template {
	struct trace_entry ent;
	long unsigned int nr_reclaimed;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_kswapd_sleep {
	struct trace_entry ent;
	int nid;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_kswapd_wake {
	struct trace_entry ent;
	int nid;
	int zid;
	int order;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_lru_isolate {
	struct trace_entry ent;
	int highest_zoneidx;
	int order;
	long unsigned int nr_requested;
	long unsigned int nr_scanned;
	long unsigned int nr_skipped;
	long unsigned int nr_taken;
	int lru;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_lru_shrink_active {
	struct trace_entry ent;
	int nid;
	long unsigned int nr_taken;
	long unsigned int nr_active;
	long unsigned int nr_deactivated;
	long unsigned int nr_referenced;
	int priority;
	int reclaim_flags;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_lru_shrink_inactive {
	struct trace_entry ent;
	int nid;
	long unsigned int nr_scanned;
	long unsigned int nr_reclaimed;
	long unsigned int nr_dirty;
	long unsigned int nr_writeback;
	long unsigned int nr_congested;
	long unsigned int nr_immediate;
	unsigned int nr_activate0;
	unsigned int nr_activate1;
	long unsigned int nr_ref_keep;
	long unsigned int nr_unmap_fail;
	int priority;
	int reclaim_flags;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_node_reclaim_begin {
	struct trace_entry ent;
	int nid;
	int order;
	long unsigned int gfp_flags;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_reclaim_pages {
	struct trace_entry ent;
	int nid;
	long unsigned int nr_scanned;
	long unsigned int nr_reclaimed;
	long unsigned int nr_dirty;
	long unsigned int nr_writeback;
	long unsigned int nr_congested;
	long unsigned int nr_immediate;
	unsigned int nr_activate0;
	unsigned int nr_activate1;
	long unsigned int nr_ref_keep;
	long unsigned int nr_unmap_fail;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_throttled {
	struct trace_entry ent;
	int nid;
	int usec_timeout;
	int usec_delayed;
	int reason;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_wakeup_kswapd {
	struct trace_entry ent;
	int nid;
	int zid;
	int order;
	long unsigned int gfp_flags;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_write_folio {
	struct trace_entry ent;
	long unsigned int pfn;
	int reclaim_flags;
	char __data[0];
};

struct trace_event_raw_mmap_lock {
	struct trace_entry ent;
	struct mm_struct *mm;
	u64 memcg_id;
	bool write;
	char __data[0];
};

struct trace_event_raw_mmap_lock_acquire_returned {
	struct trace_entry ent;
	struct mm_struct *mm;
	u64 memcg_id;
	bool write;
	bool success;
	char __data[0];
};

struct trace_event_raw_module_free {
	struct trace_entry ent;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_module_load {
	struct trace_entry ent;
	unsigned int taints;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_module_refcnt {
	struct trace_entry ent;
	long unsigned int ip;
	int refcnt;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_module_request {
	struct trace_entry ent;
	long unsigned int ip;
	bool wait;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_mpath_evt {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 dst[6];
	u8 next_hop[6];
	char __data[0];
};

struct trace_event_raw_msr_trace_class {
	struct trace_entry ent;
	unsigned int msr;
	u64 val;
	int failed;
	char __data[0];
};

struct trace_event_raw_napi_poll {
	struct trace_entry ent;
	struct napi_struct *napi;
	u32 __data_loc_dev_name;
	int work;
	int budget;
	char __data[0];
};

struct trace_event_raw_neigh__update {
	struct trace_entry ent;
	u32 family;
	u32 __data_loc_dev;
	u8 lladdr[32];
	u8 lladdr_len;
	u8 flags;
	u8 nud_state;
	u8 type;
	u8 dead;
	int refcnt;
	__u8 primary_key4[4];
	__u8 primary_key6[16];
	long unsigned int confirmed;
	long unsigned int updated;
	long unsigned int used;
	u32 err;
	char __data[0];
};

struct trace_event_raw_neigh_create {
	struct trace_entry ent;
	u32 family;
	u32 __data_loc_dev;
	int entries;
	u8 created;
	u8 gc_exempt;
	u8 primary_key4[4];
	u8 primary_key6[16];
	char __data[0];
};

struct trace_event_raw_neigh_update {
	struct trace_entry ent;
	u32 family;
	u32 __data_loc_dev;
	u8 lladdr[32];
	u8 lladdr_len;
	u8 flags;
	u8 nud_state;
	u8 type;
	u8 dead;
	int refcnt;
	__u8 primary_key4[4];
	__u8 primary_key6[16];
	long unsigned int confirmed;
	long unsigned int updated;
	long unsigned int used;
	u8 new_lladdr[32];
	u8 new_state;
	u32 update_flags;
	u32 pid;
	char __data[0];
};

struct trace_event_raw_net_dev_rx_exit_template {
	struct trace_entry ent;
	int ret;
	char __data[0];
};

struct trace_event_raw_net_dev_rx_verbose_template {
	struct trace_entry ent;
	u32 __data_loc_name;
	unsigned int napi_id;
	u16 queue_mapping;
	const void *skbaddr;
	bool vlan_tagged;
	u16 vlan_proto;
	u16 vlan_tci;
	u16 protocol;
	u8 ip_summed;
	u32 hash;
	bool l4_hash;
	unsigned int len;
	unsigned int data_len;
	unsigned int truesize;
	bool mac_header_valid;
	int mac_header;
	unsigned char nr_frags;
	u16 gso_size;
	u16 gso_type;
	char __data[0];
};

struct trace_event_raw_net_dev_start_xmit {
	struct trace_entry ent;
	u32 __data_loc_name;
	u16 queue_mapping;
	const void *skbaddr;
	bool vlan_tagged;
	u16 vlan_proto;
	u16 vlan_tci;
	u16 protocol;
	u8 ip_summed;
	unsigned int len;
	unsigned int data_len;
	int network_offset;
	bool transport_offset_valid;
	int transport_offset;
	u8 tx_flags;
	u16 gso_size;
	u16 gso_segs;
	u16 gso_type;
	char __data[0];
};

struct trace_event_raw_net_dev_template {
	struct trace_entry ent;
	void *skbaddr;
	unsigned int len;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_net_dev_xmit {
	struct trace_entry ent;
	void *skbaddr;
	unsigned int len;
	int rc;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_net_dev_xmit_timeout {
	struct trace_entry ent;
	u32 __data_loc_name;
	u32 __data_loc_driver;
	int queue_index;
	char __data[0];
};

struct trace_event_raw_netdev_evt_only {
	struct trace_entry ent;
	char name[16];
	int ifindex;
	char __data[0];
};

struct trace_event_raw_netdev_frame_event {
	struct trace_entry ent;
	char name[16];
	int ifindex;
	u32 __data_loc_frame;
	char __data[0];
};

struct trace_event_raw_netdev_mac_evt {
	struct trace_entry ent;
	char name[16];
	int ifindex;
	u8 mac[6];
	char __data[0];
};

struct trace_event_raw_netfs_collect {
	struct trace_entry ent;
	unsigned int wreq;
	unsigned int len;
	long long unsigned int transferred;
	long long unsigned int start;
	char __data[0];
};

struct trace_event_raw_netfs_collect_folio {
	struct trace_entry ent;
	unsigned int wreq;
	long unsigned int index;
	long long unsigned int fend;
	long long unsigned int cleaned_to;
	long long unsigned int collected_to;
	char __data[0];
};

struct trace_event_raw_netfs_collect_gap {
	struct trace_entry ent;
	unsigned int wreq;
	unsigned char stream;
	unsigned char type;
	long long unsigned int from;
	long long unsigned int to;
	char __data[0];
};

struct trace_event_raw_netfs_collect_sreq {
	struct trace_entry ent;
	unsigned int wreq;
	unsigned int subreq;
	unsigned int stream;
	unsigned int len;
	unsigned int transferred;
	long long unsigned int start;
	char __data[0];
};

struct trace_event_raw_netfs_collect_state {
	struct trace_entry ent;
	unsigned int wreq;
	unsigned int notes;
	long long unsigned int collected_to;
	long long unsigned int cleaned_to;
	char __data[0];
};

struct trace_event_raw_netfs_collect_stream {
	struct trace_entry ent;
	unsigned int wreq;
	unsigned char stream;
	long long unsigned int collected_to;
	long long unsigned int front;
	char __data[0];
};

struct trace_event_raw_netfs_failure {
	struct trace_entry ent;
	unsigned int rreq;
	short int index;
	short int error;
	short unsigned int flags;
	enum netfs_io_source source;
	enum netfs_failure what;
	size_t len;
	size_t transferred;
	loff_t start;
	char __data[0];
};

struct trace_event_raw_netfs_folio {
	struct trace_entry ent;
	ino_t ino;
	long unsigned int index;
	unsigned int nr;
	enum netfs_folio_trace why;
	char __data[0];
};

struct trace_event_raw_netfs_folioq {
	struct trace_entry ent;
	unsigned int rreq;
	unsigned int id;
	enum netfs_folioq_trace trace;
	char __data[0];
};

struct trace_event_raw_netfs_read {
	struct trace_entry ent;
	unsigned int rreq;
	unsigned int cookie;
	loff_t i_size;
	loff_t start;
	size_t len;
	enum netfs_read_trace what;
	unsigned int netfs_inode;
	char __data[0];
};

struct trace_event_raw_netfs_rreq {
	struct trace_entry ent;
	unsigned int rreq;
	unsigned int flags;
	enum netfs_io_origin origin;
	enum netfs_rreq_trace what;
	char __data[0];
};

struct trace_event_raw_netfs_rreq_ref {
	struct trace_entry ent;
	unsigned int rreq;
	int ref;
	enum netfs_rreq_ref_trace what;
	char __data[0];
};

struct trace_event_raw_netfs_sreq {
	struct trace_entry ent;
	unsigned int rreq;
	short unsigned int index;
	short int error;
	short unsigned int flags;
	enum netfs_io_source source;
	enum netfs_sreq_trace what;
	u8 slot;
	size_t len;
	size_t transferred;
	loff_t start;
	char __data[0];
};

struct trace_event_raw_netfs_sreq_ref {
	struct trace_entry ent;
	unsigned int rreq;
	unsigned int subreq;
	int ref;
	enum netfs_sreq_ref_trace what;
	char __data[0];
};

struct trace_event_raw_netfs_write {
	struct trace_entry ent;
	unsigned int wreq;
	unsigned int cookie;
	unsigned int ino;
	enum netfs_write_trace what;
	long long unsigned int start;
	long long unsigned int len;
	char __data[0];
};

struct trace_event_raw_netfs_write_iter {
	struct trace_entry ent;
	long long unsigned int start;
	size_t len;
	unsigned int flags;
	unsigned int ino;
	char __data[0];
};

struct trace_event_raw_netlink_extack {
	struct trace_entry ent;
	u32 __data_loc_msg;
	char __data[0];
};

struct trace_event_raw_nfs4_cached_open {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	unsigned int fmode;
	int stateid_seq;
	u32 stateid_hash;
	char __data[0];
};

struct trace_event_raw_nfs4_cb_error_class {
	struct trace_entry ent;
	u32 xid;
	u32 cbident;
	char __data[0];
};

struct trace_event_raw_nfs4_clientid_event {
	struct trace_entry ent;
	u32 __data_loc_dstaddr;
	long unsigned int error;
	char __data[0];
};

struct trace_event_raw_nfs4_close {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	unsigned int fmode;
	long unsigned int error;
	int stateid_seq;
	u32 stateid_hash;
	char __data[0];
};

struct trace_event_raw_nfs4_commit_event {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	long unsigned int error;
	loff_t offset;
	u32 count;
	int layoutstateid_seq;
	u32 layoutstateid_hash;
	char __data[0];
};

struct trace_event_raw_nfs4_delegreturn_exit {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	long unsigned int error;
	int stateid_seq;
	u32 stateid_hash;
	char __data[0];
};

struct trace_event_raw_nfs4_getattr_event {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	unsigned int valid;
	long unsigned int error;
	char __data[0];
};

struct trace_event_raw_nfs4_idmap_event {
	struct trace_entry ent;
	long unsigned int error;
	u32 id;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_nfs4_inode_callback_event {
	struct trace_entry ent;
	long unsigned int error;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	u32 __data_loc_dstaddr;
	char __data[0];
};

struct trace_event_raw_nfs4_inode_event {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	long unsigned int error;
	char __data[0];
};

struct trace_event_raw_nfs4_inode_stateid_callback_event {
	struct trace_entry ent;
	long unsigned int error;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	u32 __data_loc_dstaddr;
	int stateid_seq;
	u32 stateid_hash;
	char __data[0];
};

struct trace_event_raw_nfs4_inode_stateid_event {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	long unsigned int error;
	int stateid_seq;
	u32 stateid_hash;
	char __data[0];
};

struct trace_event_raw_nfs4_lock_event {
	struct trace_entry ent;
	long unsigned int error;
	long unsigned int cmd;
	long unsigned int type;
	loff_t start;
	loff_t end;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	int stateid_seq;
	u32 stateid_hash;
	char __data[0];
};

struct trace_event_raw_nfs4_lookup_event {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int error;
	u64 dir;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_nfs4_lookupp {
	struct trace_entry ent;
	dev_t dev;
	u64 ino;
	long unsigned int error;
	char __data[0];
};

struct trace_event_raw_nfs4_open_event {
	struct trace_entry ent;
	long unsigned int error;
	long unsigned int flags;
	long unsigned int fmode;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	u64 dir;
	u32 __data_loc_name;
	int stateid_seq;
	u32 stateid_hash;
	int openstateid_seq;
	u32 openstateid_hash;
	char __data[0];
};

struct trace_event_raw_nfs4_read_event {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	loff_t offset;
	u32 arg_count;
	u32 res_count;
	long unsigned int error;
	int stateid_seq;
	u32 stateid_hash;
	int layoutstateid_seq;
	u32 layoutstateid_hash;
	char __data[0];
};

struct trace_event_raw_nfs4_rename {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int error;
	u64 olddir;
	u32 __data_loc_oldname;
	u64 newdir;
	u32 __data_loc_newname;
	char __data[0];
};

struct trace_event_raw_nfs4_set_delegation_event {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	unsigned int fmode;
	char __data[0];
};

struct trace_event_raw_nfs4_set_lock {
	struct trace_entry ent;
	long unsigned int error;
	long unsigned int cmd;
	long unsigned int type;
	loff_t start;
	loff_t end;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	int stateid_seq;
	u32 stateid_hash;
	int lockstateid_seq;
	u32 lockstateid_hash;
	char __data[0];
};

struct trace_event_raw_nfs4_setup_sequence {
	struct trace_entry ent;
	unsigned int session;
	unsigned int slot_nr;
	unsigned int seq_nr;
	unsigned int highest_used_slotid;
	char __data[0];
};

struct trace_event_raw_nfs4_state_lock_reclaim {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	long unsigned int state_flags;
	long unsigned int lock_flags;
	int stateid_seq;
	u32 stateid_hash;
	char __data[0];
};

struct trace_event_raw_nfs4_state_mgr {
	struct trace_entry ent;
	long unsigned int state;
	u32 __data_loc_hostname;
	char __data[0];
};

struct trace_event_raw_nfs4_state_mgr_failed {
	struct trace_entry ent;
	long unsigned int error;
	long unsigned int state;
	u32 __data_loc_hostname;
	u32 __data_loc_section;
	char __data[0];
};

struct trace_event_raw_nfs4_write_event {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	loff_t offset;
	u32 arg_count;
	u32 res_count;
	long unsigned int error;
	int stateid_seq;
	u32 stateid_hash;
	int layoutstateid_seq;
	u32 layoutstateid_hash;
	char __data[0];
};

struct trace_event_raw_nfs4_xdr_bad_operation {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	u32 xid;
	u32 op;
	u32 expected;
	char __data[0];
};

struct trace_event_raw_nfs4_xdr_event {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	u32 xid;
	u32 op;
	long unsigned int error;
	char __data[0];
};

struct trace_event_raw_nfs_access_exit {
	struct trace_entry ent;
	long unsigned int error;
	dev_t dev;
	u32 fhandle;
	unsigned char type;
	u64 fileid;
	u64 version;
	loff_t size;
	long unsigned int nfsi_flags;
	long unsigned int cache_validity;
	unsigned int mask;
	unsigned int permitted;
	char __data[0];
};

struct trace_event_raw_nfs_aop_readahead {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	u64 version;
	loff_t offset;
	unsigned int nr_pages;
	char __data[0];
};

struct trace_event_raw_nfs_aop_readahead_done {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	int ret;
	u64 fileid;
	u64 version;
	loff_t offset;
	unsigned int nr_pages;
	char __data[0];
};

struct trace_event_raw_nfs_atomic_open_enter {
	struct trace_entry ent;
	long unsigned int flags;
	long unsigned int fmode;
	dev_t dev;
	u64 dir;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_nfs_atomic_open_exit {
	struct trace_entry ent;
	long unsigned int error;
	long unsigned int flags;
	long unsigned int fmode;
	dev_t dev;
	u64 dir;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_nfs_commit_done {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	loff_t offset;
	int error;
	long unsigned int stable;
	char verifier[8];
	char __data[0];
};

struct trace_event_raw_nfs_create_enter {
	struct trace_entry ent;
	long unsigned int flags;
	dev_t dev;
	u64 dir;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_nfs_create_exit {
	struct trace_entry ent;
	long unsigned int error;
	long unsigned int flags;
	dev_t dev;
	u64 dir;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_nfs_direct_req_class {
	struct trace_entry ent;
	dev_t dev;
	u64 fileid;
	u32 fhandle;
	loff_t offset;
	ssize_t count;
	ssize_t error;
	int flags;
	char __data[0];
};

struct trace_event_raw_nfs_directory_event {
	struct trace_entry ent;
	dev_t dev;
	u64 dir;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_nfs_directory_event_done {
	struct trace_entry ent;
	long unsigned int error;
	dev_t dev;
	u64 dir;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_nfs_fh_to_dentry {
	struct trace_entry ent;
	int error;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	char __data[0];
};

struct trace_event_raw_nfs_folio_event {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	u64 version;
	loff_t offset;
	size_t count;
	char __data[0];
};

struct trace_event_raw_nfs_folio_event_done {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	int ret;
	u64 fileid;
	u64 version;
	loff_t offset;
	size_t count;
	char __data[0];
};

struct trace_event_raw_nfs_initiate_commit {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	loff_t offset;
	u32 count;
	char __data[0];
};

struct trace_event_raw_nfs_initiate_read {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	loff_t offset;
	u32 count;
	char __data[0];
};

struct trace_event_raw_nfs_initiate_write {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	loff_t offset;
	u32 count;
	long unsigned int stable;
	char __data[0];
};

struct trace_event_raw_nfs_inode_event {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	u64 version;
	char __data[0];
};

struct trace_event_raw_nfs_inode_event_done {
	struct trace_entry ent;
	long unsigned int error;
	dev_t dev;
	u32 fhandle;
	unsigned char type;
	u64 fileid;
	u64 version;
	loff_t size;
	long unsigned int nfsi_flags;
	long unsigned int cache_validity;
	char __data[0];
};

struct trace_event_raw_nfs_inode_range_event {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	u64 version;
	loff_t range_start;
	loff_t range_end;
	char __data[0];
};

struct trace_event_raw_nfs_link_enter {
	struct trace_entry ent;
	dev_t dev;
	u64 fileid;
	u64 dir;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_nfs_link_exit {
	struct trace_entry ent;
	long unsigned int error;
	dev_t dev;
	u64 fileid;
	u64 dir;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_nfs_local_open_fh {
	struct trace_entry ent;
	int error;
	u32 fhandle;
	unsigned int fmode;
	char __data[0];
};

struct trace_event_raw_nfs_lookup_event {
	struct trace_entry ent;
	long unsigned int flags;
	dev_t dev;
	u64 dir;
	u64 fileid;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_nfs_lookup_event_done {
	struct trace_entry ent;
	long unsigned int error;
	long unsigned int flags;
	dev_t dev;
	u64 dir;
	u64 fileid;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_nfs_mount_assign {
	struct trace_entry ent;
	u32 __data_loc_option;
	u32 __data_loc_value;
	char __data[0];
};

struct trace_event_raw_nfs_mount_option {
	struct trace_entry ent;
	u32 __data_loc_option;
	char __data[0];
};

struct trace_event_raw_nfs_mount_path {
	struct trace_entry ent;
	u32 __data_loc_path;
	char __data[0];
};

struct trace_event_raw_nfs_page_error_class {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	loff_t offset;
	unsigned int count;
	int error;
	char __data[0];
};

struct trace_event_raw_nfs_pgio_error {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	loff_t offset;
	u32 arg_count;
	u32 res_count;
	loff_t pos;
	int error;
	char __data[0];
};

struct trace_event_raw_nfs_readdir_event {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	u64 version;
	char verifier[8];
	u64 cookie;
	long unsigned int index;
	unsigned int dtsize;
	char __data[0];
};

struct trace_event_raw_nfs_readpage_done {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	loff_t offset;
	u32 arg_count;
	u32 res_count;
	bool eof;
	int error;
	char __data[0];
};

struct trace_event_raw_nfs_readpage_short {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	loff_t offset;
	u32 arg_count;
	u32 res_count;
	bool eof;
	int error;
	char __data[0];
};

struct trace_event_raw_nfs_rename_event {
	struct trace_entry ent;
	dev_t dev;
	u64 old_dir;
	u64 new_dir;
	u32 __data_loc_old_name;
	u32 __data_loc_new_name;
	char __data[0];
};

struct trace_event_raw_nfs_rename_event_done {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int error;
	u64 old_dir;
	u32 __data_loc_old_name;
	u64 new_dir;
	u32 __data_loc_new_name;
	char __data[0];
};

struct trace_event_raw_nfs_sillyrename_unlink {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int error;
	u64 dir;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_nfs_update_size_class {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	u64 version;
	loff_t cur_size;
	loff_t new_size;
	char __data[0];
};

struct trace_event_raw_nfs_writeback_done {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	loff_t offset;
	u32 arg_count;
	u32 res_count;
	int error;
	long unsigned int stable;
	char verifier[8];
	char __data[0];
};

struct trace_event_raw_nfs_xdr_event {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	u32 xid;
	int version;
	long unsigned int error;
	u32 __data_loc_program;
	u32 __data_loc_procedure;
	char __data[0];
};

struct trace_event_raw_nlmclnt_lock_event {
	struct trace_entry ent;
	u32 oh;
	u32 svid;
	u32 fh;
	long unsigned int status;
	u64 start;
	u64 len;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_nmi_handler {
	struct trace_entry ent;
	void *handler;
	s64 delta_ns;
	int handled;
	char __data[0];
};

struct trace_event_raw_notifier_info {
	struct trace_entry ent;
	void *cb;
	char __data[0];
};

struct trace_event_raw_oom_score_adj_update {
	struct trace_entry ent;
	pid_t pid;
	char comm[16];
	short int oom_score_adj;
	char __data[0];
};

struct trace_event_raw_page_pool_release {
	struct trace_entry ent;
	const struct page_pool *pool;
	s32 inflight;
	u32 hold;
	u32 release;
	u64 cnt;
	char __data[0];
};

struct trace_event_raw_page_pool_state_hold {
	struct trace_entry ent;
	const struct page_pool *pool;
	long unsigned int netmem;
	u32 hold;
	long unsigned int pfn;
	char __data[0];
};

struct trace_event_raw_page_pool_state_release {
	struct trace_entry ent;
	const struct page_pool *pool;
	long unsigned int netmem;
	u32 release;
	long unsigned int pfn;
	char __data[0];
};

struct trace_event_raw_page_pool_update_nid {
	struct trace_entry ent;
	const struct page_pool *pool;
	int pool_nid;
	int new_nid;
	char __data[0];
};

struct trace_event_raw_percpu_alloc_percpu {
	struct trace_entry ent;
	long unsigned int call_site;
	bool reserved;
	bool is_atomic;
	size_t size;
	size_t align;
	void *base_addr;
	int off;
	void *ptr;
	size_t bytes_alloc;
	long unsigned int gfp_flags;
	char __data[0];
};

struct trace_event_raw_percpu_alloc_percpu_fail {
	struct trace_entry ent;
	bool reserved;
	bool is_atomic;
	size_t size;
	size_t align;
	char __data[0];
};

struct trace_event_raw_percpu_create_chunk {
	struct trace_entry ent;
	void *base_addr;
	char __data[0];
};

struct trace_event_raw_percpu_destroy_chunk {
	struct trace_entry ent;
	void *base_addr;
	char __data[0];
};

struct trace_event_raw_percpu_free_percpu {
	struct trace_entry ent;
	void *base_addr;
	int off;
	void *ptr;
	char __data[0];
};

struct trace_event_raw_pm_qos_update {
	struct trace_entry ent;
	enum pm_qos_req_action action;
	int prev_value;
	int curr_value;
	char __data[0];
};

struct trace_event_raw_pmap_register {
	struct trace_entry ent;
	unsigned int program;
	unsigned int version;
	int protocol;
	unsigned int port;
	char __data[0];
};

struct trace_event_raw_power_domain {
	struct trace_entry ent;
	u32 __data_loc_name;
	u64 state;
	u64 cpu_id;
	char __data[0];
};

struct trace_event_raw_powernv_throttle {
	struct trace_entry ent;
	int chip_id;
	u32 __data_loc_reason;
	int pmax;
	char __data[0];
};

struct trace_event_raw_prq_report {
	struct trace_entry ent;
	u64 dw0;
	u64 dw1;
	u64 dw2;
	u64 dw3;
	long unsigned int seq;
	u32 __data_loc_iommu;
	u32 __data_loc_dev;
	u32 __data_loc_buff;
	char __data[0];
};

struct trace_event_raw_pstate_sample {
	struct trace_entry ent;
	u32 core_busy;
	u32 scaled_busy;
	u32 from;
	u32 to;
	u64 mperf;
	u64 aperf;
	u64 tsc;
	u32 freq;
	u32 io_boost;
	char __data[0];
};

struct trace_event_raw_purge_vmap_area_lazy {
	struct trace_entry ent;
	long unsigned int start;
	long unsigned int end;
	unsigned int npurged;
	char __data[0];
};

struct trace_event_raw_qdisc_create {
	struct trace_entry ent;
	u32 __data_loc_dev;
	u32 __data_loc_kind;
	u32 parent;
	char __data[0];
};

struct trace_event_raw_qdisc_dequeue {
	struct trace_entry ent;
	struct Qdisc *qdisc;
	const struct netdev_queue *txq;
	int packets;
	void *skbaddr;
	int ifindex;
	u32 handle;
	u32 parent;
	long unsigned int txq_state;
	char __data[0];
};

struct trace_event_raw_qdisc_destroy {
	struct trace_entry ent;
	u32 __data_loc_dev;
	u32 __data_loc_kind;
	u32 parent;
	u32 handle;
	char __data[0];
};

struct trace_event_raw_qdisc_enqueue {
	struct trace_entry ent;
	struct Qdisc *qdisc;
	const struct netdev_queue *txq;
	void *skbaddr;
	int ifindex;
	u32 handle;
	u32 parent;
	char __data[0];
};

struct trace_event_raw_qdisc_reset {
	struct trace_entry ent;
	u32 __data_loc_dev;
	u32 __data_loc_kind;
	u32 parent;
	u32 handle;
	char __data[0];
};

struct trace_event_raw_qi_submit {
	struct trace_entry ent;
	u64 qw0;
	u64 qw1;
	u64 qw2;
	u64 qw3;
	u32 __data_loc_iommu;
	char __data[0];
};

struct trace_event_raw_rcu_barrier {
	struct trace_entry ent;
	const char *rcuname;
	const char *s;
	int cpu;
	int cnt;
	long unsigned int done;
	char __data[0];
};

struct trace_event_raw_rcu_batch_end {
	struct trace_entry ent;
	const char *rcuname;
	int callbacks_invoked;
	char cb;
	char nr;
	char iit;
	char risk;
	char __data[0];
};

struct trace_event_raw_rcu_batch_start {
	struct trace_entry ent;
	const char *rcuname;
	long int qlen;
	long int blimit;
	char __data[0];
};

struct trace_event_raw_rcu_callback {
	struct trace_entry ent;
	const char *rcuname;
	void *rhp;
	void *func;
	long int qlen;
	char __data[0];
};

struct trace_event_raw_rcu_exp_funnel_lock {
	struct trace_entry ent;
	const char *rcuname;
	u8 level;
	int grplo;
	int grphi;
	const char *gpevent;
	char __data[0];
};

struct trace_event_raw_rcu_exp_grace_period {
	struct trace_entry ent;
	const char *rcuname;
	long int gpseq;
	const char *gpevent;
	char __data[0];
};

struct trace_event_raw_rcu_fqs {
	struct trace_entry ent;
	const char *rcuname;
	long int gp_seq;
	int cpu;
	const char *qsevent;
	char __data[0];
};

struct trace_event_raw_rcu_future_grace_period {
	struct trace_entry ent;
	const char *rcuname;
	long int gp_seq;
	long int gp_seq_req;
	u8 level;
	int grplo;
	int grphi;
	const char *gpevent;
	char __data[0];
};

struct trace_event_raw_rcu_grace_period {
	struct trace_entry ent;
	const char *rcuname;
	long int gp_seq;
	const char *gpevent;
	char __data[0];
};

struct trace_event_raw_rcu_grace_period_init {
	struct trace_entry ent;
	const char *rcuname;
	long int gp_seq;
	u8 level;
	int grplo;
	int grphi;
	long unsigned int qsmask;
	char __data[0];
};

struct trace_event_raw_rcu_invoke_callback {
	struct trace_entry ent;
	const char *rcuname;
	void *rhp;
	void *func;
	char __data[0];
};

struct trace_event_raw_rcu_invoke_kfree_bulk_callback {
	struct trace_entry ent;
	const char *rcuname;
	long unsigned int nr_records;
	void **p;
	char __data[0];
};

struct trace_event_raw_rcu_invoke_kvfree_callback {
	struct trace_entry ent;
	const char *rcuname;
	void *rhp;
	long unsigned int offset;
	char __data[0];
};

struct trace_event_raw_rcu_kvfree_callback {
	struct trace_entry ent;
	const char *rcuname;
	void *rhp;
	long unsigned int offset;
	long int qlen;
	char __data[0];
};

struct trace_event_raw_rcu_preempt_task {
	struct trace_entry ent;
	const char *rcuname;
	long int gp_seq;
	int pid;
	char __data[0];
};

struct trace_event_raw_rcu_quiescent_state_report {
	struct trace_entry ent;
	const char *rcuname;
	long int gp_seq;
	long unsigned int mask;
	long unsigned int qsmask;
	u8 level;
	int grplo;
	int grphi;
	u8 gp_tasks;
	char __data[0];
};

struct trace_event_raw_rcu_segcb_stats {
	struct trace_entry ent;
	const char *ctx;
	long unsigned int gp_seq[4];
	long int seglen[4];
	char __data[0];
};

struct trace_event_raw_rcu_sr_normal {
	struct trace_entry ent;
	const char *rcuname;
	void *rhp;
	const char *srevent;
	char __data[0];
};

struct trace_event_raw_rcu_stall_warning {
	struct trace_entry ent;
	const char *rcuname;
	const char *msg;
	char __data[0];
};

struct trace_event_raw_rcu_torture_read {
	struct trace_entry ent;
	char rcutorturename[8];
	struct callback_head *rhp;
	long unsigned int secs;
	long unsigned int c_old;
	long unsigned int c;
	char __data[0];
};

struct trace_event_raw_rcu_unlock_preempted_task {
	struct trace_entry ent;
	const char *rcuname;
	long int gp_seq;
	int pid;
	char __data[0];
};

struct trace_event_raw_rcu_utilization {
	struct trace_entry ent;
	const char *s;
	char __data[0];
};

struct trace_event_raw_rcu_watching {
	struct trace_entry ent;
	const char *polarity;
	long int oldnesting;
	long int newnesting;
	int counter;
	char __data[0];
};

struct trace_event_raw_rdev_add_key {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 mac_addr[6];
	int link_id;
	u8 key_index;
	bool pairwise;
	u8 mode;
	char __data[0];
};

struct trace_event_raw_rdev_add_nan_func {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 id;
	u8 func_type;
	u64 cookie;
	char __data[0];
};

struct trace_event_raw_rdev_add_tx_ts {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 peer[6];
	u8 tsid;
	u8 user_prio;
	u16 admitted_time;
	char __data[0];
};

struct trace_event_raw_rdev_add_virtual_intf {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 __data_loc_vir_intf_name;
	enum nl80211_iftype type;
	char __data[0];
};

struct trace_event_raw_rdev_assoc {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 bssid[6];
	u8 prev_bssid[6];
	bool use_mfp;
	u32 flags;
	u32 __data_loc_elements;
	u8 ht_capa[26];
	u8 ht_capa_mask[26];
	u8 vht_capa[12];
	u8 vht_capa_mask[12];
	u32 __data_loc_fils_kek;
	u32 __data_loc_fils_nonces;
	char __data[0];
};

struct trace_event_raw_rdev_assoc_ml_reconf {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u16 add_links;
	u16 rem_links;
	char __data[0];
};

struct trace_event_raw_rdev_auth {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 bssid[6];
	enum nl80211_auth_type auth_type;
	char __data[0];
};

struct trace_event_raw_rdev_cancel_remain_on_channel {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 id;
	u64 cookie;
	char __data[0];
};

struct trace_event_raw_rdev_change_beacon {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	int link_id;
	u32 __data_loc_head;
	u32 __data_loc_tail;
	u32 __data_loc_beacon_ies;
	u32 __data_loc_proberesp_ies;
	u32 __data_loc_assocresp_ies;
	u32 __data_loc_probe_resp;
	char __data[0];
};

struct trace_event_raw_rdev_change_bss {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	int use_cts_prot;
	int use_short_preamble;
	int use_short_slot_time;
	int ap_isolate;
	int ht_opmode;
	char __data[0];
};

struct trace_event_raw_rdev_change_virtual_intf {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	enum nl80211_iftype type;
	char __data[0];
};

struct trace_event_raw_rdev_channel_switch {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	enum nl80211_band band;
	u32 control_freq;
	u32 freq_offset;
	u32 width;
	u32 center_freq1;
	u32 freq1_offset;
	u32 center_freq2;
	u16 punctured;
	bool radar_required;
	bool block_tx;
	u8 count;
	u32 __data_loc_bcn_ofs;
	u32 __data_loc_pres_ofs;
	u8 link_id;
	char __data[0];
};

struct trace_event_raw_rdev_color_change {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 count;
	u16 bcn_ofs;
	u16 pres_ofs;
	u8 link_id;
	char __data[0];
};

struct trace_event_raw_rdev_connect {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 bssid[6];
	char ssid[33];
	enum nl80211_auth_type auth_type;
	bool privacy;
	u32 wpa_versions;
	u32 flags;
	u8 prev_bssid[6];
	char __data[0];
};

struct trace_event_raw_rdev_crit_proto_start {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 id;
	u16 proto;
	u16 duration;
	char __data[0];
};

struct trace_event_raw_rdev_crit_proto_stop {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 id;
	char __data[0];
};

struct trace_event_raw_rdev_deauth {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 bssid[6];
	u16 reason_code;
	bool local_state_change;
	char __data[0];
};

struct trace_event_raw_rdev_del_link_station {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 mld_mac[6];
	u32 link_id;
	char __data[0];
};

struct trace_event_raw_rdev_del_nan_func {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 id;
	u64 cookie;
	char __data[0];
};

struct trace_event_raw_rdev_del_pmk {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 aa[6];
	char __data[0];
};

struct trace_event_raw_rdev_del_tx_ts {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 peer[6];
	u8 tsid;
	char __data[0];
};

struct trace_event_raw_rdev_disassoc {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 bssid[6];
	u16 reason_code;
	bool local_state_change;
	char __data[0];
};

struct trace_event_raw_rdev_disconnect {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u16 reason_code;
	char __data[0];
};

struct trace_event_raw_rdev_dump_mpath {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 dst[6];
	u8 next_hop[6];
	int idx;
	char __data[0];
};

struct trace_event_raw_rdev_dump_mpp {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 dst[6];
	u8 mpp[6];
	int idx;
	char __data[0];
};

struct trace_event_raw_rdev_dump_station {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 sta_mac[6];
	int idx;
	char __data[0];
};

struct trace_event_raw_rdev_dump_survey {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	int idx;
	char __data[0];
};

struct trace_event_raw_rdev_end_cac {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	unsigned int link_id;
	char __data[0];
};

struct trace_event_raw_rdev_external_auth {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 bssid[6];
	u8 ssid[33];
	u16 status;
	u8 mld_addr[6];
	char __data[0];
};

struct trace_event_raw_rdev_get_ftm_responder_stats {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u64 timestamp;
	u32 success_num;
	u32 partial_num;
	u32 failed_num;
	u32 asap_num;
	u32 non_asap_num;
	u64 duration;
	u32 unknown_triggers;
	u32 reschedule;
	u32 out_of_window;
	char __data[0];
};

struct trace_event_raw_rdev_get_mpp {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 dst[6];
	u8 mpp[6];
	char __data[0];
};

struct trace_event_raw_rdev_inform_bss {
	struct trace_entry ent;
	char wiphy_name[32];
	u8 bssid[6];
	enum nl80211_band band;
	u32 center_freq;
	u16 freq_offset;
	char __data[0];
};

struct trace_event_raw_rdev_join_ibss {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 bssid[6];
	char ssid[33];
	char __data[0];
};

struct trace_event_raw_rdev_join_mesh {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u16 dot11MeshRetryTimeout;
	u16 dot11MeshConfirmTimeout;
	u16 dot11MeshHoldingTimeout;
	u16 dot11MeshMaxPeerLinks;
	u8 dot11MeshMaxRetries;
	u8 dot11MeshTTL;
	u8 element_ttl;
	bool auto_open_plinks;
	u32 dot11MeshNbrOffsetMaxNeighbor;
	u8 dot11MeshHWMPmaxPREQretries;
	u32 path_refresh_time;
	u32 dot11MeshHWMPactivePathTimeout;
	u16 min_discovery_timeout;
	u16 dot11MeshHWMPpreqMinInterval;
	u16 dot11MeshHWMPperrMinInterval;
	u16 dot11MeshHWMPnetDiameterTraversalTime;
	u8 dot11MeshHWMPRootMode;
	u16 dot11MeshHWMPRannInterval;
	bool dot11MeshGateAnnouncementProtocol;
	bool dot11MeshForwarding;
	s32 rssi_threshold;
	u16 ht_opmode;
	u32 dot11MeshHWMPactivePathToRootTimeout;
	u16 dot11MeshHWMProotInterval;
	u16 dot11MeshHWMPconfirmationInterval;
	bool dot11MeshNolearn;
	char __data[0];
};

struct trace_event_raw_rdev_join_ocb {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	char __data[0];
};

struct trace_event_raw_rdev_libertas_set_mesh_channel {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	enum nl80211_band band;
	u32 center_freq;
	u16 freq_offset;
	char __data[0];
};

struct trace_event_raw_rdev_mgmt_tx {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 id;
	enum nl80211_band band;
	u32 center_freq;
	u16 freq_offset;
	bool offchan;
	unsigned int wait;
	bool no_cck;
	bool dont_wait_for_ack;
	char __data[0];
};

struct trace_event_raw_rdev_mgmt_tx_cancel_wait {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 id;
	u64 cookie;
	char __data[0];
};

struct trace_event_raw_rdev_nan_change_conf {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 id;
	u8 master_pref;
	u8 bands;
	u32 changes;
	char __data[0];
};

struct trace_event_raw_rdev_pmksa {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 bssid[6];
	char __data[0];
};

struct trace_event_raw_rdev_probe_client {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 peer[6];
	char __data[0];
};

struct trace_event_raw_rdev_probe_mesh_link {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 dest[6];
	char __data[0];
};

struct trace_event_raw_rdev_remain_on_channel {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 id;
	enum nl80211_band band;
	u32 center_freq;
	u16 freq_offset;
	unsigned int duration;
	char __data[0];
};

struct trace_event_raw_rdev_reset_tid_config {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 peer[6];
	u8 tids;
	char __data[0];
};

struct trace_event_raw_rdev_return_chandef {
	struct trace_entry ent;
	char wiphy_name[32];
	int ret;
	enum nl80211_band band;
	u32 control_freq;
	u32 freq_offset;
	u32 width;
	u32 center_freq1;
	u32 freq1_offset;
	u32 center_freq2;
	u16 punctured;
	char __data[0];
};

struct trace_event_raw_rdev_return_int {
	struct trace_entry ent;
	char wiphy_name[32];
	int ret;
	char __data[0];
};

struct trace_event_raw_rdev_return_int_cookie {
	struct trace_entry ent;
	char wiphy_name[32];
	int ret;
	u64 cookie;
	char __data[0];
};

struct trace_event_raw_rdev_return_int_int {
	struct trace_entry ent;
	char wiphy_name[32];
	int func_ret;
	int func_fill;
	char __data[0];
};

struct trace_event_raw_rdev_return_int_mesh_config {
	struct trace_entry ent;
	char wiphy_name[32];
	u16 dot11MeshRetryTimeout;
	u16 dot11MeshConfirmTimeout;
	u16 dot11MeshHoldingTimeout;
	u16 dot11MeshMaxPeerLinks;
	u8 dot11MeshMaxRetries;
	u8 dot11MeshTTL;
	u8 element_ttl;
	bool auto_open_plinks;
	u32 dot11MeshNbrOffsetMaxNeighbor;
	u8 dot11MeshHWMPmaxPREQretries;
	u32 path_refresh_time;
	u32 dot11MeshHWMPactivePathTimeout;
	u16 min_discovery_timeout;
	u16 dot11MeshHWMPpreqMinInterval;
	u16 dot11MeshHWMPperrMinInterval;
	u16 dot11MeshHWMPnetDiameterTraversalTime;
	u8 dot11MeshHWMPRootMode;
	u16 dot11MeshHWMPRannInterval;
	bool dot11MeshGateAnnouncementProtocol;
	bool dot11MeshForwarding;
	s32 rssi_threshold;
	u16 ht_opmode;
	u32 dot11MeshHWMPactivePathToRootTimeout;
	u16 dot11MeshHWMProotInterval;
	u16 dot11MeshHWMPconfirmationInterval;
	bool dot11MeshNolearn;
	int ret;
	char __data[0];
};

struct trace_event_raw_rdev_return_int_mpath_info {
	struct trace_entry ent;
	char wiphy_name[32];
	int ret;
	int generation;
	u32 filled;
	u32 frame_qlen;
	u32 sn;
	u32 metric;
	u32 exptime;
	u32 discovery_timeout;
	u8 discovery_retries;
	u8 flags;
	char __data[0];
};

struct trace_event_raw_rdev_return_int_station_info {
	struct trace_entry ent;
	char wiphy_name[32];
	int ret;
	int generation;
	u32 connected_time;
	u32 inactive_time;
	u32 rx_bytes;
	u32 tx_bytes;
	u32 rx_packets;
	u32 tx_packets;
	u32 tx_retries;
	u32 tx_failed;
	u32 rx_dropped_misc;
	u32 beacon_loss_count;
	u16 llid;
	u16 plid;
	u8 plink_state;
	char __data[0];
};

struct trace_event_raw_rdev_return_int_survey_info {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_band band;
	u32 center_freq;
	u16 freq_offset;
	int ret;
	u64 time;
	u64 time_busy;
	u64 time_ext_busy;
	u64 time_rx;
	u64 time_tx;
	u64 time_scan;
	u32 filled;
	s8 noise;
	char __data[0];
};

struct trace_event_raw_rdev_return_int_tx_rx {
	struct trace_entry ent;
	char wiphy_name[32];
	int ret;
	u32 tx;
	u32 rx;
	char __data[0];
};

struct trace_event_raw_rdev_return_void_tx_rx {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 tx;
	u32 tx_max;
	u32 rx;
	u32 rx_max;
	char __data[0];
};

struct trace_event_raw_rdev_scan {
	struct trace_entry ent;
	char wiphy_name[32];
	char __data[0];
};

struct trace_event_raw_rdev_set_ap_chanwidth {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	enum nl80211_band band;
	u32 control_freq;
	u32 freq_offset;
	u32 width;
	u32 center_freq1;
	u32 freq1_offset;
	u32 center_freq2;
	u16 punctured;
	unsigned int link_id;
	char __data[0];
};

struct trace_event_raw_rdev_set_bitrate_mask {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	unsigned int link_id;
	u8 peer[6];
	char __data[0];
};

struct trace_event_raw_rdev_set_coalesce {
	struct trace_entry ent;
	char wiphy_name[32];
	int n_rules;
	char __data[0];
};

struct trace_event_raw_rdev_set_cqm_rssi_config {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	s32 rssi_thold;
	u32 rssi_hyst;
	char __data[0];
};

struct trace_event_raw_rdev_set_cqm_rssi_range_config {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	s32 rssi_low;
	s32 rssi_high;
	char __data[0];
};

struct trace_event_raw_rdev_set_cqm_txe_config {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u32 rate;
	u32 pkts;
	u32 intvl;
	char __data[0];
};

struct trace_event_raw_rdev_set_default_beacon_key {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	int link_id;
	u8 key_index;
	char __data[0];
};

struct trace_event_raw_rdev_set_default_key {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	int link_id;
	u8 key_index;
	bool unicast;
	bool multicast;
	char __data[0];
};

struct trace_event_raw_rdev_set_default_mgmt_key {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	int link_id;
	u8 key_index;
	char __data[0];
};

struct trace_event_raw_rdev_set_epcs {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	bool val;
	char __data[0];
};

struct trace_event_raw_rdev_set_fils_aad {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 macaddr[6];
	u8 kek_len;
	char __data[0];
};

struct trace_event_raw_rdev_set_hw_timestamp {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 macaddr[6];
	bool enable;
	char __data[0];
};

struct trace_event_raw_rdev_set_mac_acl {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u32 acl_policy;
	char __data[0];
};

struct trace_event_raw_rdev_set_mcast_rate {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	int mcast_rate[6];
	char __data[0];
};

struct trace_event_raw_rdev_set_monitor_channel {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	enum nl80211_band band;
	u32 control_freq;
	u32 freq_offset;
	u32 width;
	u32 center_freq1;
	u32 freq1_offset;
	u32 center_freq2;
	u16 punctured;
	char __data[0];
};

struct trace_event_raw_rdev_set_multicast_to_unicast {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	bool enabled;
	char __data[0];
};

struct trace_event_raw_rdev_set_noack_map {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u16 noack_map;
	char __data[0];
};

struct trace_event_raw_rdev_set_pmk {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 aa[6];
	u8 pmk_len;
	u8 pmk_r0_name_len;
	u32 __data_loc_pmk;
	u32 __data_loc_pmk_r0_name;
	char __data[0];
};

struct trace_event_raw_rdev_set_power_mgmt {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	bool enabled;
	int timeout;
	char __data[0];
};

struct trace_event_raw_rdev_set_qos_map {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 num_des;
	u8 dscp_exception[42];
	u8 up[16];
	char __data[0];
};

struct trace_event_raw_rdev_set_radar_background {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_band band;
	u32 control_freq;
	u32 freq_offset;
	u32 width;
	u32 center_freq1;
	u32 freq1_offset;
	u32 center_freq2;
	u16 punctured;
	char __data[0];
};

struct trace_event_raw_rdev_set_sar_specs {
	struct trace_entry ent;
	char wiphy_name[32];
	u16 type;
	u16 num;
	char __data[0];
};

struct trace_event_raw_rdev_set_tid_config {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 peer[6];
	char __data[0];
};

struct trace_event_raw_rdev_set_ttlm {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 dlink[16];
	u8 ulink[16];
	char __data[0];
};

struct trace_event_raw_rdev_set_tx_power {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 id;
	enum nl80211_tx_power_setting type;
	int mbm;
	char __data[0];
};

struct trace_event_raw_rdev_set_txq_params {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	enum nl80211_ac ac;
	u16 txop;
	u16 cwmin;
	u16 cwmax;
	u8 aifs;
	char __data[0];
};

struct trace_event_raw_rdev_set_wiphy_params {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 changed;
	char __data[0];
};

struct trace_event_raw_rdev_start_ap {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	enum nl80211_band band;
	u32 control_freq;
	u32 freq_offset;
	u32 width;
	u32 center_freq1;
	u32 freq1_offset;
	u32 center_freq2;
	u16 punctured;
	int beacon_interval;
	int dtim_period;
	char ssid[33];
	enum nl80211_hidden_ssid hidden_ssid;
	u32 wpa_ver;
	bool privacy;
	enum nl80211_auth_type auth_type;
	int inactivity_timeout;
	unsigned int link_id;
	char __data[0];
};

struct trace_event_raw_rdev_start_nan {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 id;
	u8 master_pref;
	u8 bands;
	char __data[0];
};

struct trace_event_raw_rdev_start_radar_detection {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	enum nl80211_band band;
	u32 control_freq;
	u32 freq_offset;
	u32 width;
	u32 center_freq1;
	u32 freq1_offset;
	u32 center_freq2;
	u16 punctured;
	u32 cac_time_ms;
	int link_id;
	char __data[0];
};

struct trace_event_raw_rdev_stop_ap {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	unsigned int link_id;
	char __data[0];
};

struct trace_event_raw_rdev_suspend {
	struct trace_entry ent;
	char wiphy_name[32];
	bool any;
	bool disconnect;
	bool magic_pkt;
	bool gtk_rekey_failure;
	bool eap_identity_req;
	bool four_way_handshake;
	bool rfkill_release;
	bool valid_wow;
	char __data[0];
};

struct trace_event_raw_rdev_tdls_cancel_channel_switch {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 addr[6];
	char __data[0];
};

struct trace_event_raw_rdev_tdls_channel_switch {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 addr[6];
	u8 oper_class;
	enum nl80211_band band;
	u32 control_freq;
	u32 freq_offset;
	u32 width;
	u32 center_freq1;
	u32 freq1_offset;
	u32 center_freq2;
	u16 punctured;
	char __data[0];
};

struct trace_event_raw_rdev_tdls_mgmt {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 peer[6];
	int link_id;
	u8 action_code;
	u8 dialog_token;
	u16 status_code;
	u32 peer_capability;
	bool initiator;
	u32 __data_loc_buf;
	char __data[0];
};

struct trace_event_raw_rdev_tdls_oper {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 peer[6];
	enum nl80211_tdls_operation oper;
	char __data[0];
};

struct trace_event_raw_rdev_tx_control_port {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 dest[6];
	__be16 proto;
	bool unencrypted;
	int link_id;
	char __data[0];
};

struct trace_event_raw_rdev_update_connect_params {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u32 changed;
	char __data[0];
};

struct trace_event_raw_rdev_update_ft_ies {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u16 md;
	u32 __data_loc_ie;
	char __data[0];
};

struct trace_event_raw_rdev_update_mesh_config {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u16 dot11MeshRetryTimeout;
	u16 dot11MeshConfirmTimeout;
	u16 dot11MeshHoldingTimeout;
	u16 dot11MeshMaxPeerLinks;
	u8 dot11MeshMaxRetries;
	u8 dot11MeshTTL;
	u8 element_ttl;
	bool auto_open_plinks;
	u32 dot11MeshNbrOffsetMaxNeighbor;
	u8 dot11MeshHWMPmaxPREQretries;
	u32 path_refresh_time;
	u32 dot11MeshHWMPactivePathTimeout;
	u16 min_discovery_timeout;
	u16 dot11MeshHWMPpreqMinInterval;
	u16 dot11MeshHWMPperrMinInterval;
	u16 dot11MeshHWMPnetDiameterTraversalTime;
	u8 dot11MeshHWMPRootMode;
	u16 dot11MeshHWMPRannInterval;
	bool dot11MeshGateAnnouncementProtocol;
	bool dot11MeshForwarding;
	s32 rssi_threshold;
	u16 ht_opmode;
	u32 dot11MeshHWMPactivePathToRootTimeout;
	u16 dot11MeshHWMProotInterval;
	u16 dot11MeshHWMPconfirmationInterval;
	bool dot11MeshNolearn;
	u32 mask;
	char __data[0];
};

struct trace_event_raw_rdev_update_mgmt_frame_registrations {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 id;
	u16 global_stypes;
	u16 interface_stypes;
	char __data[0];
};

struct trace_event_raw_rdev_update_owe_info {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 peer[6];
	u16 status;
	u32 __data_loc_ie;
	char __data[0];
};

struct trace_event_raw_reclaim_retry_zone {
	struct trace_entry ent;
	int node;
	int zone_idx;
	int order;
	long unsigned int reclaimable;
	long unsigned int available;
	long unsigned int min_wmark;
	int no_progress_loops;
	bool wmark_check;
	char __data[0];
};

struct trace_event_raw_regcache_drop_region {
	struct trace_entry ent;
	u32 __data_loc_name;
	unsigned int from;
	unsigned int to;
	char __data[0];
};

struct trace_event_raw_regcache_sync {
	struct trace_entry ent;
	u32 __data_loc_name;
	u32 __data_loc_status;
	u32 __data_loc_type;
	char __data[0];
};

struct trace_event_raw_register_class {
	struct trace_entry ent;
	u32 version;
	long unsigned int family;
	short unsigned int protocol;
	short unsigned int port;
	int error;
	u32 __data_loc_program;
	char __data[0];
};

struct trace_event_raw_regmap_async {
	struct trace_entry ent;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_regmap_block {
	struct trace_entry ent;
	u32 __data_loc_name;
	unsigned int reg;
	int count;
	char __data[0];
};

struct trace_event_raw_regmap_bool {
	struct trace_entry ent;
	u32 __data_loc_name;
	int flag;
	char __data[0];
};

struct trace_event_raw_regmap_bulk {
	struct trace_entry ent;
	u32 __data_loc_name;
	unsigned int reg;
	u32 __data_loc_buf;
	int val_len;
	char __data[0];
};

struct trace_event_raw_regmap_reg {
	struct trace_entry ent;
	u32 __data_loc_name;
	unsigned int reg;
	unsigned int val;
	char __data[0];
};

struct trace_event_raw_release_evt {
	struct trace_entry ent;
	char wiphy_name[32];
	char sta_addr[6];
	u16 tids;
	int num_frames;
	int reason;
	bool more_data;
	char __data[0];
};

struct trace_event_raw_rpc_buf_alloc {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	size_t callsize;
	size_t recvsize;
	int status;
	char __data[0];
};

struct trace_event_raw_rpc_call_rpcerror {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	int tk_status;
	int rpc_status;
	char __data[0];
};

struct trace_event_raw_rpc_clnt_class {
	struct trace_entry ent;
	unsigned int client_id;
	char __data[0];
};

struct trace_event_raw_rpc_clnt_clone_err {
	struct trace_entry ent;
	unsigned int client_id;
	int error;
	char __data[0];
};

struct trace_event_raw_rpc_clnt_new {
	struct trace_entry ent;
	unsigned int client_id;
	long unsigned int xprtsec;
	long unsigned int flags;
	u32 __data_loc_program;
	u32 __data_loc_server;
	u32 __data_loc_addr;
	u32 __data_loc_port;
	char __data[0];
};

struct trace_event_raw_rpc_clnt_new_err {
	struct trace_entry ent;
	int error;
	u32 __data_loc_program;
	u32 __data_loc_server;
	char __data[0];
};

struct trace_event_raw_rpc_failure {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	char __data[0];
};

struct trace_event_raw_rpc_reply_event {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	u32 xid;
	u32 __data_loc_progname;
	u32 version;
	u32 __data_loc_procname;
	u32 __data_loc_servername;
	char __data[0];
};

struct trace_event_raw_rpc_request {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	int version;
	bool async;
	u32 __data_loc_progname;
	u32 __data_loc_procname;
	char __data[0];
};

struct trace_event_raw_rpc_socket_nospace {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	unsigned int total;
	unsigned int remaining;
	char __data[0];
};

struct trace_event_raw_rpc_stats_latency {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	u32 xid;
	int version;
	u32 __data_loc_progname;
	u32 __data_loc_procname;
	long unsigned int backlog;
	long unsigned int rtt;
	long unsigned int execute;
	u32 xprt_id;
	char __data[0];
};

struct trace_event_raw_rpc_task_queued {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	long unsigned int timeout;
	long unsigned int runstate;
	int status;
	short unsigned int flags;
	u32 __data_loc_q_name;
	char __data[0];
};

struct trace_event_raw_rpc_task_running {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	const void *action;
	long unsigned int runstate;
	int status;
	short unsigned int flags;
	char __data[0];
};

struct trace_event_raw_rpc_task_status {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	int status;
	char __data[0];
};

struct trace_event_raw_rpc_tls_class {
	struct trace_entry ent;
	long unsigned int requested_policy;
	u32 version;
	u32 __data_loc_servername;
	u32 __data_loc_progname;
	char __data[0];
};

struct trace_event_raw_rpc_xdr_alignment {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	int version;
	size_t offset;
	unsigned int copied;
	const void *head_base;
	size_t head_len;
	const void *tail_base;
	size_t tail_len;
	unsigned int page_len;
	unsigned int len;
	u32 __data_loc_progname;
	u32 __data_loc_procedure;
	char __data[0];
};

struct trace_event_raw_rpc_xdr_buf_class {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	const void *head_base;
	size_t head_len;
	const void *tail_base;
	size_t tail_len;
	unsigned int page_base;
	unsigned int page_len;
	unsigned int msg_len;
	char __data[0];
};

struct trace_event_raw_rpc_xdr_overflow {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	int version;
	size_t requested;
	const void *end;
	const void *p;
	const void *head_base;
	size_t head_len;
	const void *tail_base;
	size_t tail_len;
	unsigned int page_len;
	unsigned int len;
	u32 __data_loc_progname;
	u32 __data_loc_procedure;
	char __data[0];
};

struct trace_event_raw_rpc_xprt_event {
	struct trace_entry ent;
	u32 xid;
	int status;
	u32 __data_loc_addr;
	u32 __data_loc_port;
	char __data[0];
};

struct trace_event_raw_rpc_xprt_lifetime_class {
	struct trace_entry ent;
	long unsigned int state;
	u32 __data_loc_addr;
	u32 __data_loc_port;
	char __data[0];
};

struct trace_event_raw_rpcb_getport {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	unsigned int program;
	unsigned int version;
	int protocol;
	unsigned int bind_version;
	u32 __data_loc_servername;
	char __data[0];
};

struct trace_event_raw_rpcb_register {
	struct trace_entry ent;
	unsigned int program;
	unsigned int version;
	u32 __data_loc_addr;
	u32 __data_loc_netid;
	char __data[0];
};

struct trace_event_raw_rpcb_setport {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	int status;
	short unsigned int port;
	char __data[0];
};

struct trace_event_raw_rpcb_unregister {
	struct trace_entry ent;
	unsigned int program;
	unsigned int version;
	u32 __data_loc_netid;
	char __data[0];
};

struct trace_event_raw_rpcgss_bad_seqno {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	u32 expected;
	u32 received;
	char __data[0];
};

struct trace_event_raw_rpcgss_context {
	struct trace_entry ent;
	long unsigned int expiry;
	long unsigned int now;
	unsigned int timeout;
	u32 window_size;
	int len;
	u32 __data_loc_acceptor;
	char __data[0];
};

struct trace_event_raw_rpcgss_createauth {
	struct trace_entry ent;
	unsigned int flavor;
	int error;
	char __data[0];
};

struct trace_event_raw_rpcgss_ctx_class {
	struct trace_entry ent;
	const void *cred;
	long unsigned int service;
	u32 __data_loc_principal;
	char __data[0];
};

struct trace_event_raw_rpcgss_gssapi_event {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	u32 maj_stat;
	char __data[0];
};

struct trace_event_raw_rpcgss_import_ctx {
	struct trace_entry ent;
	int status;
	char __data[0];
};

struct trace_event_raw_rpcgss_need_reencode {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	u32 xid;
	u32 seq_xmit;
	u32 seqno;
	bool ret;
	char __data[0];
};

struct trace_event_raw_rpcgss_oid_to_mech {
	struct trace_entry ent;
	u32 __data_loc_oid;
	char __data[0];
};

struct trace_event_raw_rpcgss_seqno {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	u32 xid;
	u32 seqno;
	char __data[0];
};

struct trace_event_raw_rpcgss_svc_accept_upcall {
	struct trace_entry ent;
	u32 minor_status;
	long unsigned int major_status;
	u32 xid;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_rpcgss_svc_authenticate {
	struct trace_entry ent;
	u32 seqno;
	u32 xid;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_rpcgss_svc_gssapi_class {
	struct trace_entry ent;
	u32 xid;
	u32 maj_stat;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_rpcgss_svc_seqno_bad {
	struct trace_entry ent;
	u32 expected;
	u32 received;
	u32 xid;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_rpcgss_svc_seqno_class {
	struct trace_entry ent;
	u32 xid;
	u32 seqno;
	char __data[0];
};

struct trace_event_raw_rpcgss_svc_seqno_low {
	struct trace_entry ent;
	u32 xid;
	u32 seqno;
	u32 min;
	u32 max;
	char __data[0];
};

struct trace_event_raw_rpcgss_svc_unwrap_failed {
	struct trace_entry ent;
	u32 xid;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_rpcgss_svc_wrap_failed {
	struct trace_entry ent;
	u32 xid;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_rpcgss_unwrap_failed {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	char __data[0];
};

struct trace_event_raw_rpcgss_upcall_msg {
	struct trace_entry ent;
	u32 __data_loc_msg;
	char __data[0];
};

struct trace_event_raw_rpcgss_upcall_result {
	struct trace_entry ent;
	u32 uid;
	int result;
	char __data[0];
};

struct trace_event_raw_rpcgss_update_slack {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	u32 xid;
	const void *auth;
	unsigned int rslack;
	unsigned int ralign;
	unsigned int verfsize;
	char __data[0];
};

struct trace_event_raw_rpm_internal {
	struct trace_entry ent;
	u32 __data_loc_name;
	int flags;
	int usage_count;
	int disable_depth;
	int runtime_auto;
	int request_pending;
	int irq_safe;
	int child_count;
	char __data[0];
};

struct trace_event_raw_rpm_return_int {
	struct trace_entry ent;
	u32 __data_loc_name;
	long unsigned int ip;
	int ret;
	char __data[0];
};

struct trace_event_raw_rpm_status {
	struct trace_entry ent;
	u32 __data_loc_name;
	int status;
	char __data[0];
};

struct trace_event_raw_rseq_ip_fixup {
	struct trace_entry ent;
	long unsigned int regs_ip;
	long unsigned int start_ip;
	long unsigned int post_commit_offset;
	long unsigned int abort_ip;
	char __data[0];
};

struct trace_event_raw_rseq_update {
	struct trace_entry ent;
	s32 cpu_id;
	s32 node_id;
	s32 mm_cid;
	char __data[0];
};

struct trace_event_raw_rss_stat {
	struct trace_entry ent;
	unsigned int mm_id;
	unsigned int curr;
	int member;
	long int size;
	char __data[0];
};

struct trace_event_raw_rtc_alarm_irq_enable {
	struct trace_entry ent;
	unsigned int enabled;
	int err;
	char __data[0];
};

struct trace_event_raw_rtc_irq_set_freq {
	struct trace_entry ent;
	int freq;
	int err;
	char __data[0];
};

struct trace_event_raw_rtc_irq_set_state {
	struct trace_entry ent;
	int enabled;
	int err;
	char __data[0];
};

struct trace_event_raw_rtc_offset_class {
	struct trace_entry ent;
	long int offset;
	int err;
	char __data[0];
};

struct trace_event_raw_rtc_time_alarm_class {
	struct trace_entry ent;
	time64_t secs;
	int err;
	char __data[0];
};

struct trace_event_raw_rtc_timer_class {
	struct trace_entry ent;
	struct rtc_timer *timer;
	ktime_t expires;
	ktime_t period;
	char __data[0];
};

struct trace_event_raw_sched_kthread_stop {
	struct trace_entry ent;
	char comm[16];
	pid_t pid;
	char __data[0];
};

struct trace_event_raw_sched_kthread_stop_ret {
	struct trace_entry ent;
	int ret;
	char __data[0];
};

struct trace_event_raw_sched_kthread_work_execute_end {
	struct trace_entry ent;
	void *work;
	void *function;
	char __data[0];
};

struct trace_event_raw_sched_kthread_work_execute_start {
	struct trace_entry ent;
	void *work;
	void *function;
	char __data[0];
};

struct trace_event_raw_sched_kthread_work_queue_work {
	struct trace_entry ent;
	void *work;
	void *function;
	void *worker;
	char __data[0];
};

struct trace_event_raw_sched_migrate_task {
	struct trace_entry ent;
	char comm[16];
	pid_t pid;
	int prio;
	int orig_cpu;
	int dest_cpu;
	char __data[0];
};

struct trace_event_raw_sched_move_numa {
	struct trace_entry ent;
	pid_t pid;
	pid_t tgid;
	pid_t ngid;
	int src_cpu;
	int src_nid;
	int dst_cpu;
	int dst_nid;
	char __data[0];
};

struct trace_event_raw_sched_numa_pair_template {
	struct trace_entry ent;
	pid_t src_pid;
	pid_t src_tgid;
	pid_t src_ngid;
	int src_cpu;
	int src_nid;
	pid_t dst_pid;
	pid_t dst_tgid;
	pid_t dst_ngid;
	int dst_cpu;
	int dst_nid;
	char __data[0];
};

struct trace_event_raw_sched_pi_setprio {
	struct trace_entry ent;
	char comm[16];
	pid_t pid;
	int oldprio;
	int newprio;
	char __data[0];
};

struct trace_event_raw_sched_prepare_exec {
	struct trace_entry ent;
	u32 __data_loc_interp;
	u32 __data_loc_filename;
	pid_t pid;
	u32 __data_loc_comm;
	char __data[0];
};

struct trace_event_raw_sched_process_exec {
	struct trace_entry ent;
	u32 __data_loc_filename;
	pid_t pid;
	pid_t old_pid;
	char __data[0];
};

struct trace_event_raw_sched_process_fork {
	struct trace_entry ent;
	char parent_comm[16];
	pid_t parent_pid;
	char child_comm[16];
	pid_t child_pid;
	char __data[0];
};

struct trace_event_raw_sched_process_template {
	struct trace_entry ent;
	char comm[16];
	pid_t pid;
	int prio;
	char __data[0];
};

struct trace_event_raw_sched_process_wait {
	struct trace_entry ent;
	char comm[16];
	pid_t pid;
	int prio;
	char __data[0];
};

struct trace_event_raw_sched_stat_runtime {
	struct trace_entry ent;
	char comm[16];
	pid_t pid;
	u64 runtime;
	char __data[0];
};

struct trace_event_raw_sched_stat_template {
	struct trace_entry ent;
	char comm[16];
	pid_t pid;
	u64 delay;
	char __data[0];
};

struct trace_event_raw_sched_switch {
	struct trace_entry ent;
	char prev_comm[16];
	pid_t prev_pid;
	int prev_prio;
	long int prev_state;
	char next_comm[16];
	pid_t next_pid;
	int next_prio;
	char __data[0];
};

struct trace_event_raw_sched_wake_idle_without_ipi {
	struct trace_entry ent;
	int cpu;
	char __data[0];
};

struct trace_event_raw_sched_wakeup_template {
	struct trace_entry ent;
	char comm[16];
	pid_t pid;
	int prio;
	int target_cpu;
	char __data[0];
};

struct trace_event_raw_scsi_cmd_done_timeout_template {
	struct trace_entry ent;
	unsigned int host_no;
	unsigned int channel;
	unsigned int id;
	unsigned int lun;
	int result;
	unsigned int opcode;
	unsigned int cmd_len;
	int driver_tag;
	int scheduler_tag;
	unsigned int data_sglen;
	unsigned int prot_sglen;
	unsigned char prot_op;
	u32 __data_loc_cmnd;
	u8 sense_key;
	u8 asc;
	u8 ascq;
	char __data[0];
};

struct trace_event_raw_scsi_dispatch_cmd_error {
	struct trace_entry ent;
	unsigned int host_no;
	unsigned int channel;
	unsigned int id;
	unsigned int lun;
	int rtn;
	unsigned int opcode;
	unsigned int cmd_len;
	int driver_tag;
	int scheduler_tag;
	unsigned int data_sglen;
	unsigned int prot_sglen;
	unsigned char prot_op;
	u32 __data_loc_cmnd;
	char __data[0];
};

struct trace_event_raw_scsi_dispatch_cmd_start {
	struct trace_entry ent;
	unsigned int host_no;
	unsigned int channel;
	unsigned int id;
	unsigned int lun;
	unsigned int opcode;
	unsigned int cmd_len;
	int driver_tag;
	int scheduler_tag;
	unsigned int data_sglen;
	unsigned int prot_sglen;
	unsigned char prot_op;
	u32 __data_loc_cmnd;
	char __data[0];
};

struct trace_event_raw_scsi_eh_wakeup {
	struct trace_entry ent;
	unsigned int host_no;
	char __data[0];
};

struct trace_event_raw_selinux_audited {
	struct trace_entry ent;
	u32 requested;
	u32 denied;
	u32 audited;
	int result;
	u32 __data_loc_scontext;
	u32 __data_loc_tcontext;
	u32 __data_loc_tclass;
	char __data[0];
};

struct trace_event_raw_signal_deliver {
	struct trace_entry ent;
	int sig;
	int errno;
	int code;
	long unsigned int sa_handler;
	long unsigned int sa_flags;
	char __data[0];
};

struct trace_event_raw_signal_generate {
	struct trace_entry ent;
	int sig;
	int errno;
	int code;
	char comm[16];
	pid_t pid;
	int group;
	int result;
	char __data[0];
};

struct trace_event_raw_sk_data_ready {
	struct trace_entry ent;
	const void *skaddr;
	__u16 family;
	__u16 protocol;
	long unsigned int ip;
	char __data[0];
};

struct trace_event_raw_skb_copy_datagram_iovec {
	struct trace_entry ent;
	const void *skbaddr;
	int len;
	char __data[0];
};

struct trace_event_raw_skip_task_reaping {
	struct trace_entry ent;
	int pid;
	char __data[0];
};

struct trace_event_raw_smbus_read {
	struct trace_entry ent;
	int adapter_nr;
	__u16 flags;
	__u16 addr;
	__u8 command;
	__u32 protocol;
	__u8 buf[34];
	char __data[0];
};

struct trace_event_raw_smbus_reply {
	struct trace_entry ent;
	int adapter_nr;
	__u16 addr;
	__u16 flags;
	__u8 command;
	__u8 len;
	__u32 protocol;
	__u8 buf[34];
	char __data[0];
};

struct trace_event_raw_smbus_result {
	struct trace_entry ent;
	int adapter_nr;
	__u16 addr;
	__u16 flags;
	__u8 read_write;
	__u8 command;
	__s16 res;
	__u32 protocol;
	char __data[0];
};

struct trace_event_raw_smbus_write {
	struct trace_entry ent;
	int adapter_nr;
	__u16 addr;
	__u16 flags;
	__u8 command;
	__u8 len;
	__u32 protocol;
	__u8 buf[34];
	char __data[0];
};

struct trace_event_raw_sock_exceed_buf_limit {
	struct trace_entry ent;
	char name[32];
	long int sysctl_mem[3];
	long int allocated;
	int sysctl_rmem;
	int rmem_alloc;
	int sysctl_wmem;
	int wmem_alloc;
	int wmem_queued;
	int kind;
	char __data[0];
};

struct trace_event_raw_sock_msg_length {
	struct trace_entry ent;
	void *sk;
	__u16 family;
	__u16 protocol;
	int ret;
	int flags;
	char __data[0];
};

struct trace_event_raw_sock_rcvqueue_full {
	struct trace_entry ent;
	int rmem_alloc;
	unsigned int truesize;
	int sk_rcvbuf;
	char __data[0];
};

struct trace_event_raw_softirq {
	struct trace_entry ent;
	unsigned int vec;
	char __data[0];
};

struct trace_event_raw_sta_event {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	char sta_addr[6];
	char __data[0];
};

struct trace_event_raw_sta_flag_evt {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	char sta_addr[6];
	bool enabled;
	char __data[0];
};

struct trace_event_raw_start_task_reaping {
	struct trace_entry ent;
	int pid;
	char __data[0];
};

struct trace_event_raw_station_add_change {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 sta_mac[6];
	u32 sta_flags_mask;
	u32 sta_flags_set;
	u32 sta_modify_mask;
	int listen_interval;
	u16 capability;
	u16 aid;
	u8 plink_action;
	u8 plink_state;
	u8 uapsd_queues;
	u8 max_sp;
	u8 opmode_notif;
	bool opmode_notif_used;
	u8 ht_capa[26];
	u8 vht_capa[12];
	char vlan[16];
	u32 __data_loc_supported_rates;
	u32 __data_loc_ext_capab;
	u32 __data_loc_supported_channels;
	u32 __data_loc_supported_oper_classes;
	char __data[0];
};

struct trace_event_raw_station_del {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 sta_mac[6];
	u8 subtype;
	u16 reason_code;
	int link_id;
	char __data[0];
};

struct trace_event_raw_stop_queue {
	struct trace_entry ent;
	char wiphy_name[32];
	u16 queue;
	u32 reason;
	int refcount;
	char __data[0];
};

struct trace_event_raw_suspend_resume {
	struct trace_entry ent;
	const char *action;
	int val;
	bool start;
	char __data[0];
};

struct trace_event_raw_svc_alloc_arg_err {
	struct trace_entry ent;
	unsigned int requested;
	unsigned int allocated;
	char __data[0];
};

struct trace_event_raw_svc_authenticate {
	struct trace_entry ent;
	u32 __data_loc_server;
	u32 __data_loc_client;
	unsigned int netns_ino;
	u32 xid;
	long unsigned int svc_status;
	long unsigned int auth_stat;
	char __data[0];
};

struct trace_event_raw_svc_deferred_event {
	struct trace_entry ent;
	const void *dr;
	u32 xid;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_svc_process {
	struct trace_entry ent;
	u32 xid;
	u32 vers;
	u32 proc;
	u32 __data_loc_service;
	u32 __data_loc_procedure;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_svc_replace_page_err {
	struct trace_entry ent;
	u32 __data_loc_server;
	u32 __data_loc_client;
	unsigned int netns_ino;
	u32 xid;
	const void *begin;
	const void *respages;
	const void *nextpage;
	char __data[0];
};

struct trace_event_raw_svc_rqst_event {
	struct trace_entry ent;
	u32 __data_loc_server;
	u32 __data_loc_client;
	unsigned int netns_ino;
	u32 xid;
	long unsigned int flags;
	char __data[0];
};

struct trace_event_raw_svc_rqst_status {
	struct trace_entry ent;
	u32 __data_loc_server;
	u32 __data_loc_client;
	unsigned int netns_ino;
	u32 xid;
	int status;
	long unsigned int flags;
	char __data[0];
};

struct trace_event_raw_svc_stats_latency {
	struct trace_entry ent;
	u32 __data_loc_server;
	u32 __data_loc_client;
	unsigned int netns_ino;
	u32 xid;
	long unsigned int execute;
	u32 __data_loc_procedure;
	char __data[0];
};

struct trace_event_raw_svc_unregister {
	struct trace_entry ent;
	u32 version;
	int error;
	u32 __data_loc_program;
	char __data[0];
};

struct trace_event_raw_svc_wake_up {
	struct trace_entry ent;
	int pid;
	char __data[0];
};

struct trace_event_raw_svc_xdr_buf_class {
	struct trace_entry ent;
	u32 xid;
	const void *head_base;
	size_t head_len;
	const void *tail_base;
	size_t tail_len;
	unsigned int page_base;
	unsigned int page_len;
	unsigned int msg_len;
	char __data[0];
};

struct trace_event_raw_svc_xdr_msg_class {
	struct trace_entry ent;
	u32 xid;
	const void *head_base;
	size_t head_len;
	const void *tail_base;
	size_t tail_len;
	unsigned int page_len;
	unsigned int msg_len;
	char __data[0];
};

struct trace_event_raw_svc_xprt_accept {
	struct trace_entry ent;
	u32 __data_loc_server;
	u32 __data_loc_client;
	long unsigned int flags;
	unsigned int netns_ino;
	u32 __data_loc_protocol;
	u32 __data_loc_service;
	char __data[0];
};

struct trace_event_raw_svc_xprt_create_err {
	struct trace_entry ent;
	long int error;
	u32 __data_loc_program;
	u32 __data_loc_protocol;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_svc_xprt_dequeue {
	struct trace_entry ent;
	u32 __data_loc_server;
	u32 __data_loc_client;
	long unsigned int flags;
	unsigned int netns_ino;
	long unsigned int wakeup;
	char __data[0];
};

struct trace_event_raw_svc_xprt_enqueue {
	struct trace_entry ent;
	u32 __data_loc_server;
	u32 __data_loc_client;
	long unsigned int flags;
	unsigned int netns_ino;
	char __data[0];
};

struct trace_event_raw_svc_xprt_event {
	struct trace_entry ent;
	u32 __data_loc_server;
	u32 __data_loc_client;
	long unsigned int flags;
	unsigned int netns_ino;
	char __data[0];
};

struct trace_event_raw_svcsock_accept_class {
	struct trace_entry ent;
	long int status;
	u32 __data_loc_service;
	unsigned int netns_ino;
	char __data[0];
};

struct trace_event_raw_svcsock_class {
	struct trace_entry ent;
	ssize_t result;
	long unsigned int flags;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_svcsock_lifetime_class {
	struct trace_entry ent;
	unsigned int netns_ino;
	const void *svsk;
	const void *sk;
	long unsigned int type;
	long unsigned int family;
	long unsigned int state;
	char __data[0];
};

struct trace_event_raw_svcsock_marker {
	struct trace_entry ent;
	unsigned int length;
	bool last;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_svcsock_tcp_recv_short {
	struct trace_entry ent;
	u32 expected;
	u32 received;
	long unsigned int flags;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_svcsock_tcp_state {
	struct trace_entry ent;
	long unsigned int socket_state;
	long unsigned int sock_state;
	long unsigned int flags;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_swiotlb_bounced {
	struct trace_entry ent;
	u32 __data_loc_dev_name;
	u64 dma_mask;
	dma_addr_t dev_addr;
	size_t size;
	bool force;
	char __data[0];
};

struct trace_event_raw_sys_enter {
	struct trace_entry ent;
	long int id;
	long unsigned int args[6];
	char __data[0];
};

struct trace_event_raw_sys_exit {
	struct trace_entry ent;
	long int id;
	long int ret;
	char __data[0];
};

struct trace_event_raw_task_newtask {
	struct trace_entry ent;
	pid_t pid;
	char comm[16];
	long unsigned int clone_flags;
	short int oom_score_adj;
	char __data[0];
};

struct trace_event_raw_task_prctl_unknown {
	struct trace_entry ent;
	int option;
	long unsigned int arg2;
	long unsigned int arg3;
	long unsigned int arg4;
	long unsigned int arg5;
	char __data[0];
};

struct trace_event_raw_task_rename {
	struct trace_entry ent;
	char oldcomm[16];
	char newcomm[16];
	short int oom_score_adj;
	char __data[0];
};

struct trace_event_raw_tasklet {
	struct trace_entry ent;
	void *tasklet;
	void *func;
	char __data[0];
};

struct trace_event_raw_tcp_ao_event {
	struct trace_entry ent;
	__u64 net_cookie;
	const void *skbaddr;
	const void *skaddr;
	int state;
	__u8 saddr[28];
	__u8 daddr[28];
	int l3index;
	__u16 sport;
	__u16 dport;
	__u16 family;
	bool fin;
	bool syn;
	bool rst;
	bool psh;
	bool ack;
	__u8 keyid;
	__u8 rnext;
	__u8 maclen;
	char __data[0];
};

struct trace_event_raw_tcp_ao_event_sk {
	struct trace_entry ent;
	__u64 net_cookie;
	const void *skaddr;
	int state;
	__u8 saddr[28];
	__u8 daddr[28];
	__u16 sport;
	__u16 dport;
	__u16 family;
	__u8 keyid;
	__u8 rnext;
	char __data[0];
};

struct trace_event_raw_tcp_ao_event_sne {
	struct trace_entry ent;
	__u64 net_cookie;
	const void *skaddr;
	int state;
	__u8 saddr[28];
	__u8 daddr[28];
	__u16 sport;
	__u16 dport;
	__u16 family;
	__u32 new_sne;
	char __data[0];
};

struct trace_event_raw_tcp_cong_state_set {
	struct trace_entry ent;
	const void *skaddr;
	__u16 sport;
	__u16 dport;
	__u16 family;
	__u8 saddr[4];
	__u8 daddr[4];
	__u8 saddr_v6[16];
	__u8 daddr_v6[16];
	__u8 cong_state;
	char __data[0];
};

struct trace_event_raw_tcp_event_sk {
	struct trace_entry ent;
	const void *skaddr;
	__u16 sport;
	__u16 dport;
	__u16 family;
	__u8 saddr[4];
	__u8 daddr[4];
	__u8 saddr_v6[16];
	__u8 daddr_v6[16];
	__u64 sock_cookie;
	char __data[0];
};

struct trace_event_raw_tcp_event_sk_skb {
	struct trace_entry ent;
	const void *skbaddr;
	const void *skaddr;
	int state;
	__u16 sport;
	__u16 dport;
	__u16 family;
	__u8 saddr[4];
	__u8 daddr[4];
	__u8 saddr_v6[16];
	__u8 daddr_v6[16];
	char __data[0];
};

struct trace_event_raw_tcp_event_skb {
	struct trace_entry ent;
	const void *skbaddr;
	__u8 saddr[28];
	__u8 daddr[28];
	char __data[0];
};

struct trace_event_raw_tcp_hash_event {
	struct trace_entry ent;
	__u64 net_cookie;
	const void *skbaddr;
	const void *skaddr;
	int state;
	__u8 saddr[28];
	__u8 daddr[28];
	int l3index;
	__u16 sport;
	__u16 dport;
	__u16 family;
	bool fin;
	bool syn;
	bool rst;
	bool psh;
	bool ack;
	char __data[0];
};

struct trace_event_raw_tcp_probe {
	struct trace_entry ent;
	__u8 saddr[28];
	__u8 daddr[28];
	__u16 sport;
	__u16 dport;
	__u16 family;
	__u32 mark;
	__u16 data_len;
	__u32 snd_nxt;
	__u32 snd_una;
	__u32 snd_cwnd;
	__u32 ssthresh;
	__u32 snd_wnd;
	__u32 srtt;
	__u32 rcv_wnd;
	__u64 sock_cookie;
	const void *skbaddr;
	const void *skaddr;
	char __data[0];
};

struct trace_event_raw_tcp_retransmit_synack {
	struct trace_entry ent;
	const void *skaddr;
	const void *req;
	__u16 sport;
	__u16 dport;
	__u16 family;
	__u8 saddr[4];
	__u8 daddr[4];
	__u8 saddr_v6[16];
	__u8 daddr_v6[16];
	char __data[0];
};

struct trace_event_raw_tcp_send_reset {
	struct trace_entry ent;
	const void *skbaddr;
	const void *skaddr;
	int state;
	enum sk_rst_reason reason;
	__u8 saddr[28];
	__u8 daddr[28];
	char __data[0];
};

struct trace_event_raw_thermal_temperature {
	struct trace_entry ent;
	u32 __data_loc_thermal_zone;
	int id;
	int temp_prev;
	int temp;
	char __data[0];
};

struct trace_event_raw_thermal_zone_trip {
	struct trace_entry ent;
	u32 __data_loc_thermal_zone;
	int id;
	int trip;
	enum thermal_trip_type trip_type;
	char __data[0];
};

struct trace_event_raw_tick_stop {
	struct trace_entry ent;
	int success;
	int dependency;
	char __data[0];
};

struct trace_event_raw_timer_base_idle {
	struct trace_entry ent;
	bool is_idle;
	unsigned int cpu;
	char __data[0];
};

struct trace_event_raw_timer_class {
	struct trace_entry ent;
	void *timer;
	char __data[0];
};

struct trace_event_raw_timer_expire_entry {
	struct trace_entry ent;
	void *timer;
	long unsigned int now;
	void *function;
	long unsigned int baseclk;
	char __data[0];
};

struct trace_event_raw_timer_start {
	struct trace_entry ent;
	void *timer;
	void *function;
	long unsigned int expires;
	long unsigned int bucket_expiry;
	long unsigned int now;
	unsigned int flags;
	char __data[0];
};

struct trace_event_raw_tlb_flush {
	struct trace_entry ent;
	int reason;
	long unsigned int pages;
	char __data[0];
};

struct trace_event_raw_tls_contenttype {
	struct trace_entry ent;
	__u8 saddr[28];
	__u8 daddr[28];
	unsigned int netns_ino;
	long unsigned int type;
	char __data[0];
};

struct trace_event_raw_tmigr_connect_child_parent {
	struct trace_entry ent;
	void *child;
	void *parent;
	unsigned int lvl;
	unsigned int numa_node;
	unsigned int num_children;
	u32 groupmask;
	char __data[0];
};

struct trace_event_raw_tmigr_connect_cpu_parent {
	struct trace_entry ent;
	void *parent;
	unsigned int cpu;
	unsigned int lvl;
	unsigned int numa_node;
	unsigned int num_children;
	u32 groupmask;
	char __data[0];
};

struct trace_event_raw_tmigr_cpugroup {
	struct trace_entry ent;
	u64 wakeup;
	void *parent;
	unsigned int cpu;
	char __data[0];
};

struct trace_event_raw_tmigr_group_and_cpu {
	struct trace_entry ent;
	void *group;
	void *parent;
	unsigned int lvl;
	unsigned int numa_node;
	u32 childmask;
	u8 active;
	u8 migrator;
	char __data[0];
};

struct trace_event_raw_tmigr_group_set {
	struct trace_entry ent;
	void *group;
	unsigned int lvl;
	unsigned int numa_node;
	char __data[0];
};

struct trace_event_raw_tmigr_handle_remote {
	struct trace_entry ent;
	void *group;
	unsigned int lvl;
	char __data[0];
};

struct trace_event_raw_tmigr_idle {
	struct trace_entry ent;
	u64 nextevt;
	u64 wakeup;
	void *parent;
	unsigned int cpu;
	char __data[0];
};

struct trace_event_raw_tmigr_update_events {
	struct trace_entry ent;
	void *child;
	void *group;
	u64 nextevt;
	u64 group_next_expiry;
	u64 child_evt_expiry;
	unsigned int group_lvl;
	unsigned int child_evtcpu;
	u8 child_active;
	u8 group_active;
	char __data[0];
};

struct trace_event_raw_tx_rx_evt {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 tx;
	u32 rx;
	char __data[0];
};

struct trace_event_raw_udp_fail_queue_rcv_skb {
	struct trace_entry ent;
	int rc;
	__u16 sport;
	__u16 dport;
	__u16 family;
	__u8 saddr[28];
	__u8 daddr[28];
	char __data[0];
};

struct trace_event_raw_unmap {
	struct trace_entry ent;
	u64 iova;
	size_t size;
	size_t unmapped_size;
	char __data[0];
};

struct trace_event_raw_vector_activate {
	struct trace_entry ent;
	unsigned int irq;
	bool is_managed;
	bool can_reserve;
	bool reserve;
	char __data[0];
};

struct trace_event_raw_vector_alloc {
	struct trace_entry ent;
	unsigned int irq;
	unsigned int vector;
	bool reserved;
	int ret;
	char __data[0];
};

struct trace_event_raw_vector_alloc_managed {
	struct trace_entry ent;
	unsigned int irq;
	unsigned int vector;
	int ret;
	char __data[0];
};

struct trace_event_raw_vector_config {
	struct trace_entry ent;
	unsigned int irq;
	unsigned int vector;
	unsigned int cpu;
	unsigned int apicdest;
	char __data[0];
};

struct trace_event_raw_vector_free_moved {
	struct trace_entry ent;
	unsigned int irq;
	unsigned int cpu;
	unsigned int vector;
	bool is_managed;
	char __data[0];
};

struct trace_event_raw_vector_mod {
	struct trace_entry ent;
	unsigned int irq;
	unsigned int vector;
	unsigned int cpu;
	unsigned int prev_vector;
	unsigned int prev_cpu;
	char __data[0];
};

struct trace_event_raw_vector_reserve {
	struct trace_entry ent;
	unsigned int irq;
	int ret;
	char __data[0];
};

struct trace_event_raw_vector_setup {
	struct trace_entry ent;
	unsigned int irq;
	bool is_legacy;
	int ret;
	char __data[0];
};

struct trace_event_raw_vector_teardown {
	struct trace_entry ent;
	unsigned int irq;
	bool is_managed;
	bool has_reserved;
	char __data[0];
};

struct trace_event_raw_virtio_gpu_cmd {
	struct trace_entry ent;
	int dev;
	unsigned int vq;
	u32 __data_loc_name;
	u32 type;
	u32 flags;
	u64 fence_id;
	u32 ctx_id;
	u32 num_free;
	u32 seqno;
	char __data[0];
};

struct trace_event_raw_vlv_fifo_size {
	struct trace_entry ent;
	u32 __data_loc_dev;
	char pipe_name;
	u32 frame;
	u32 scanline;
	u32 sprite0_start;
	u32 sprite1_start;
	u32 fifo_size;
	char __data[0];
};

struct trace_event_raw_vlv_wm {
	struct trace_entry ent;
	u32 __data_loc_dev;
	char pipe_name;
	u32 frame;
	u32 scanline;
	u32 level;
	u32 cxsr;
	u32 primary;
	u32 sprite0;
	u32 sprite1;
	u32 cursor;
	u32 sr_plane;
	u32 sr_cursor;
	char __data[0];
};

struct trace_event_raw_vm_unmapped_area {
	struct trace_entry ent;
	long unsigned int addr;
	long unsigned int total_vm;
	long unsigned int flags;
	long unsigned int length;
	long unsigned int low_limit;
	long unsigned int high_limit;
	long unsigned int align_mask;
	long unsigned int align_offset;
	char __data[0];
};

struct trace_event_raw_vma_mas_szero {
	struct trace_entry ent;
	struct maple_tree *mt;
	long unsigned int start;
	long unsigned int end;
	char __data[0];
};

struct trace_event_raw_vma_store {
	struct trace_entry ent;
	struct maple_tree *mt;
	struct vm_area_struct *vma;
	long unsigned int vm_start;
	long unsigned int vm_end;
	char __data[0];
};

struct trace_event_raw_wake_queue {
	struct trace_entry ent;
	char wiphy_name[32];
	u16 queue;
	u32 reason;
	int refcount;
	char __data[0];
};

struct trace_event_raw_wake_reaper {
	struct trace_entry ent;
	int pid;
	char __data[0];
};

struct trace_event_raw_wakeup_source {
	struct trace_entry ent;
	u32 __data_loc_name;
	u64 state;
	char __data[0];
};

struct trace_event_raw_wbc_class {
	struct trace_entry ent;
	char name[32];
	long int nr_to_write;
	long int pages_skipped;
	int sync_mode;
	int for_kupdate;
	int for_background;
	int for_reclaim;
	int range_cyclic;
	long int range_start;
	long int range_end;
	ino_t cgroup_ino;
	char __data[0];
};

struct trace_event_raw_wiphy_delayed_work_queue {
	struct trace_entry ent;
	char wiphy_name[32];
	void *instance;
	void *func;
	long unsigned int delay;
	char __data[0];
};

struct trace_event_raw_wiphy_enabled_evt {
	struct trace_entry ent;
	char wiphy_name[32];
	bool enabled;
	char __data[0];
};

struct trace_event_raw_wiphy_id_evt {
	struct trace_entry ent;
	char wiphy_name[32];
	u64 id;
	char __data[0];
};

struct trace_event_raw_wiphy_netdev_evt {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	char __data[0];
};

struct trace_event_raw_wiphy_netdev_id_evt {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u64 id;
	char __data[0];
};

struct trace_event_raw_wiphy_netdev_mac_evt {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 sta_mac[6];
	char __data[0];
};

struct trace_event_raw_wiphy_only_evt {
	struct trace_entry ent;
	char wiphy_name[32];
	char __data[0];
};

struct trace_event_raw_wiphy_wdev_cookie_evt {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 id;
	u64 cookie;
	char __data[0];
};

struct trace_event_raw_wiphy_wdev_evt {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 id;
	char __data[0];
};

struct trace_event_raw_wiphy_wdev_link_evt {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 id;
	unsigned int link_id;
	char __data[0];
};

struct trace_event_raw_wiphy_work_event {
	struct trace_entry ent;
	char wiphy_name[32];
	void *instance;
	void *func;
	char __data[0];
};

struct trace_event_raw_wiphy_work_worker_start {
	struct trace_entry ent;
	char wiphy_name[32];
	char __data[0];
};

struct trace_event_raw_workqueue_activate_work {
	struct trace_entry ent;
	void *work;
	void *function;
	char __data[0];
};

struct trace_event_raw_workqueue_execute_end {
	struct trace_entry ent;
	void *work;
	void *function;
	char __data[0];
};

struct trace_event_raw_workqueue_execute_start {
	struct trace_entry ent;
	void *work;
	void *function;
	char __data[0];
};

struct trace_event_raw_workqueue_queue_work {
	struct trace_entry ent;
	void *work;
	void *function;
	u32 __data_loc_workqueue;
	int req_cpu;
	int cpu;
	char __data[0];
};

struct trace_event_raw_writeback_bdi_register {
	struct trace_entry ent;
	char name[32];
	char __data[0];
};

struct trace_event_raw_writeback_class {
	struct trace_entry ent;
	char name[32];
	ino_t cgroup_ino;
	char __data[0];
};

struct trace_event_raw_writeback_dirty_inode_template {
	struct trace_entry ent;
	char name[32];
	ino_t ino;
	long unsigned int state;
	long unsigned int flags;
	char __data[0];
};

struct trace_event_raw_writeback_folio_template {
	struct trace_entry ent;
	char name[32];
	ino_t ino;
	long unsigned int index;
	char __data[0];
};

struct trace_event_raw_writeback_inode_template {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	long unsigned int state;
	__u16 mode;
	long unsigned int dirtied_when;
	char __data[0];
};

struct trace_event_raw_writeback_pages_written {
	struct trace_entry ent;
	long int pages;
	char __data[0];
};

struct trace_event_raw_writeback_queue_io {
	struct trace_entry ent;
	char name[32];
	long unsigned int older;
	long int age;
	int moved;
	int reason;
	ino_t cgroup_ino;
	char __data[0];
};

struct trace_event_raw_writeback_sb_inodes_requeue {
	struct trace_entry ent;
	char name[32];
	ino_t ino;
	long unsigned int state;
	long unsigned int dirtied_when;
	ino_t cgroup_ino;
	char __data[0];
};

struct trace_event_raw_writeback_single_inode_template {
	struct trace_entry ent;
	char name[32];
	ino_t ino;
	long unsigned int state;
	long unsigned int dirtied_when;
	long unsigned int writeback_index;
	long int nr_to_write;
	long unsigned int wrote;
	ino_t cgroup_ino;
	char __data[0];
};

struct trace_event_raw_writeback_work_class {
	struct trace_entry ent;
	char name[32];
	long int nr_pages;
	dev_t sb_dev;
	int sync_mode;
	int for_kupdate;
	int range_cyclic;
	int for_background;
	int reason;
	ino_t cgroup_ino;
	char __data[0];
};

struct trace_event_raw_writeback_write_inode_template {
	struct trace_entry ent;
	char name[32];
	ino_t ino;
	int sync_mode;
	ino_t cgroup_ino;
	char __data[0];
};

struct trace_event_raw_x86_exceptions {
	struct trace_entry ent;
	long unsigned int address;
	long unsigned int ip;
	long unsigned int error_code;
	char __data[0];
};

struct trace_event_raw_x86_fpu {
	struct trace_entry ent;
	struct fpu *fpu;
	bool load_fpu;
	u64 xfeatures;
	u64 xcomp_bv;
	char __data[0];
};

struct trace_event_raw_x86_irq_vector {
	struct trace_entry ent;
	int vector;
	char __data[0];
};

struct trace_event_raw_xdp_bulk_tx {
	struct trace_entry ent;
	int ifindex;
	u32 act;
	int drops;
	int sent;
	int err;
	char __data[0];
};

struct trace_event_raw_xdp_cpumap_enqueue {
	struct trace_entry ent;
	int map_id;
	u32 act;
	int cpu;
	unsigned int drops;
	unsigned int processed;
	int to_cpu;
	char __data[0];
};

struct trace_event_raw_xdp_cpumap_kthread {
	struct trace_entry ent;
	int map_id;
	u32 act;
	int cpu;
	unsigned int drops;
	unsigned int processed;
	int sched;
	unsigned int xdp_pass;
	unsigned int xdp_drop;
	unsigned int xdp_redirect;
	char __data[0];
};

struct trace_event_raw_xdp_devmap_xmit {
	struct trace_entry ent;
	int from_ifindex;
	u32 act;
	int to_ifindex;
	int drops;
	int sent;
	int err;
	char __data[0];
};

struct trace_event_raw_xdp_exception {
	struct trace_entry ent;
	int prog_id;
	u32 act;
	int ifindex;
	char __data[0];
};

struct trace_event_raw_xdp_redirect_template {
	struct trace_entry ent;
	int prog_id;
	u32 act;
	int ifindex;
	int err;
	int to_ifindex;
	u32 map_id;
	int map_index;
	char __data[0];
};

struct trace_event_raw_xhci_dbc_log_request {
	struct trace_entry ent;
	struct dbc_request *req;
	bool dir;
	unsigned int actual;
	unsigned int length;
	int status;
	char __data[0];
};

struct trace_event_raw_xhci_log_ctrl_ctx {
	struct trace_entry ent;
	u32 drop;
	u32 add;
	char __data[0];
};

struct trace_event_raw_xhci_log_ctx {
	struct trace_entry ent;
	int ctx_64;
	unsigned int ctx_type;
	dma_addr_t ctx_dma;
	u8 *ctx_va;
	unsigned int ctx_ep_num;
	u32 __data_loc_ctx_data;
	char __data[0];
};

struct trace_event_raw_xhci_log_doorbell {
	struct trace_entry ent;
	u32 slot;
	u32 doorbell;
	char __data[0];
};

struct trace_event_raw_xhci_log_ep_ctx {
	struct trace_entry ent;
	u32 info;
	u32 info2;
	u64 deq;
	u32 tx_info;
	char __data[0];
};

struct trace_event_raw_xhci_log_free_virt_dev {
	struct trace_entry ent;
	void *vdev;
	long long unsigned int out_ctx;
	long long unsigned int in_ctx;
	int slot_id;
	u16 current_mel;
	char __data[0];
};

struct trace_event_raw_xhci_log_msg {
	struct trace_entry ent;
	u32 __data_loc_msg;
	char __data[0];
};

struct trace_event_raw_xhci_log_portsc {
	struct trace_entry ent;
	u32 busnum;
	u32 portnum;
	u32 portsc;
	char __data[0];
};

struct trace_event_raw_xhci_log_ring {
	struct trace_entry ent;
	u32 type;
	void *ring;
	dma_addr_t enq;
	dma_addr_t deq;
	unsigned int num_segs;
	unsigned int stream_id;
	unsigned int cycle_state;
	unsigned int bounce_buf_len;
	char __data[0];
};

struct trace_event_raw_xhci_log_slot_ctx {
	struct trace_entry ent;
	u32 info;
	u32 info2;
	u32 tt_info;
	u32 state;
	char __data[0];
};

struct trace_event_raw_xhci_log_stream_ctx {
	struct trace_entry ent;
	unsigned int stream_id;
	u64 stream_ring;
	dma_addr_t ctx_array_dma;
	char __data[0];
};

struct trace_event_raw_xhci_log_trb {
	struct trace_entry ent;
	dma_addr_t dma;
	u32 type;
	u32 field0;
	u32 field1;
	u32 field2;
	u32 field3;
	char __data[0];
};

struct trace_event_raw_xhci_log_urb {
	struct trace_entry ent;
	u32 __data_loc_devname;
	void *urb;
	unsigned int pipe;
	unsigned int stream;
	int status;
	unsigned int flags;
	int num_mapped_sgs;
	int num_sgs;
	int length;
	int actual;
	int epnum;
	int dir_in;
	int type;
	int slot_id;
	char __data[0];
};

struct trace_event_raw_xhci_log_virt_dev {
	struct trace_entry ent;
	void *vdev;
	long long unsigned int out_ctx;
	long long unsigned int in_ctx;
	int devnum;
	int state;
	int speed;
	u8 portnum;
	u8 level;
	int slot_id;
	char __data[0];
};

struct trace_event_raw_xprt_cong_event {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	unsigned int snd_task_id;
	long unsigned int cong;
	long unsigned int cwnd;
	bool wait;
	char __data[0];
};

struct trace_event_raw_xprt_ping {
	struct trace_entry ent;
	int status;
	u32 __data_loc_addr;
	u32 __data_loc_port;
	char __data[0];
};

struct trace_event_raw_xprt_reserve {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	u32 xid;
	char __data[0];
};

struct trace_event_raw_xprt_retransmit {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	u32 xid;
	int ntrans;
	int version;
	long unsigned int timeout;
	u32 __data_loc_progname;
	u32 __data_loc_procname;
	char __data[0];
};

struct trace_event_raw_xprt_transmit {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	u32 xid;
	u32 seqno;
	int status;
	char __data[0];
};

struct trace_event_raw_xprt_writelock_event {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	unsigned int snd_task_id;
	char __data[0];
};

struct trace_event_raw_xs_data_ready {
	struct trace_entry ent;
	u32 __data_loc_addr;
	u32 __data_loc_port;
	char __data[0];
};

struct trace_event_raw_xs_socket_event {
	struct trace_entry ent;
	unsigned int socket_state;
	unsigned int sock_state;
	long long unsigned int ino;
	__u8 saddr[28];
	__u8 daddr[28];
	char __data[0];
};

struct trace_event_raw_xs_socket_event_done {
	struct trace_entry ent;
	int error;
	unsigned int socket_state;
	unsigned int sock_state;
	long long unsigned int ino;
	__u8 saddr[28];
	__u8 daddr[28];
	char __data[0];
};

struct trace_event_raw_xs_stream_read_data {
	struct trace_entry ent;
	ssize_t err;
	size_t total;
	u32 __data_loc_addr;
	u32 __data_loc_port;
	char __data[0];
};

struct trace_event_raw_xs_stream_read_request {
	struct trace_entry ent;
	u32 __data_loc_addr;
	u32 __data_loc_port;
	u32 xid;
	long unsigned int copied;
	unsigned int reclen;
	unsigned int offset;
	char __data[0];
};

struct trace_export {
	struct trace_export *next;
	void (*write)(struct trace_export *, const void *, unsigned int);
	int flags;
};

struct trace_func_repeats {
	long unsigned int ip;
	long unsigned int parent_ip;
	long unsigned int count;
	u64 ts_last_call;
};

struct trace_kprobe {
	struct dyn_event devent;
	struct kretprobe rp;
	long unsigned int *nhit;
	const char *symbol;
	struct trace_probe tp;
};

struct trace_mark {
	long long unsigned int val;
	char sym;
};

struct trace_min_max_param {
	struct mutex *lock;
	u64 *val;
	u64 *min;
	u64 *max;
};

struct tracer_opt;

struct tracer_flags;

struct trace_option_dentry {
	struct tracer_opt *opt;
	struct tracer_flags *flags;
	struct trace_array *tr;
	struct dentry *entry;
};

struct trace_options {
	struct tracer *tracer;
	struct trace_option_dentry *topts;
};

struct trace_parser {
	bool cont;
	char *buffer;
	unsigned int idx;
	unsigned int size;
};

union upper_chunk;

struct trace_pid_list {
	raw_spinlock_t lock;
	struct irq_work refill_irqwork;
	union upper_chunk *upper[256];
	union upper_chunk *upper_list;
	union lower_chunk *lower_list;
	int free_upper_chunks;
	int free_lower_chunks;
};

struct trace_print_flags {
	long unsigned int mask;
	const char *name;
};

struct trace_uprobe_filter {
	rwlock_t rwlock;
	int nr_systemwide;
	struct list_head perf_events;
};

struct trace_probe_event {
	unsigned int flags;
	struct trace_event_class class;
	struct trace_event_call call;
	struct list_head files;
	struct list_head probes;
	struct trace_uprobe_filter filter[0];
};

struct trace_probe_log {
	const char *subsystem;
	const char **argv;
	int argc;
	int index;
};

struct trace_subsystem_dir {
	struct list_head list;
	struct event_subsystem *subsystem;
	struct trace_array *tr;
	struct eventfs_inode *ei;
	int ref_count;
	int nr_events;
};

struct trace_vif_entry {
	enum nl80211_iftype vif_type;
	bool p2p;
	char vif_name[16];
} __attribute__((packed));

struct trace_switch_entry {
	struct trace_vif_entry vif;
	unsigned int link_id;
	struct trace_chandef_entry old_chandef;
	struct trace_chandef_entry new_chandef;
} __attribute__((packed));

struct trace_uprobe {
	struct dyn_event devent;
	struct uprobe_consumer consumer;
	struct path path;
	char *filename;
	struct uprobe *uprobe;
	long unsigned int offset;
	long unsigned int ref_ctr_offset;
	long unsigned int *nhits;
	struct trace_probe tp;
};

struct tracefs_dir_ops {
	int (*mkdir)(const char *);
	int (*rmdir)(const char *);
};

struct tracefs_fs_info {
	kuid_t uid;
	kgid_t gid;
	umode_t mode;
	unsigned int opts;
};

struct tracefs_inode {
	struct inode vfs_inode;
	struct list_head list;
	long unsigned int flags;
	void *private;
};

struct tracepoint_ext;

struct tracepoint {
	const char *name;
	struct static_key_false key;
	struct static_call_key *static_call_key;
	void *static_call_tramp;
	void *iterator;
	void *probestub;
	struct tracepoint_func *funcs;
	struct tracepoint_ext *ext;
};

struct tracepoint_ext {
	int (*regfunc)(void);
	void (*unregfunc)(void);
	unsigned int faultable: 1;
};

struct traceprobe_parse_context {
	struct trace_event_call *event;
	const char *funcname;
	const struct btf_type *proto;
	const struct btf_param *params;
	s32 nr_params;
	struct btf *btf;
	const struct btf_type *last_type;
	u32 last_bitoffs;
	u32 last_bitsize;
	struct trace_probe *tp;
	unsigned int flags;
	int offset;
};

struct tracer {
	const char *name;
	int (*init)(struct trace_array *);
	void (*reset)(struct trace_array *);
	void (*start)(struct trace_array *);
	void (*stop)(struct trace_array *);
	int (*update_thresh)(struct trace_array *);
	void (*open)(struct trace_iterator *);
	void (*pipe_open)(struct trace_iterator *);
	void (*close)(struct trace_iterator *);
	void (*pipe_close)(struct trace_iterator *);
	ssize_t (*read)(struct trace_iterator *, struct file *, char *, size_t, loff_t *);
	ssize_t (*splice_read)(struct trace_iterator *, struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);
	void (*print_header)(struct seq_file *);
	enum print_line_t (*print_line)(struct trace_iterator *);
	int (*set_flag)(struct trace_array *, u32, u32, int);
	int (*flag_changed)(struct trace_array *, u32, int);
	struct tracer *next;
	struct tracer_flags *flags;
	int enabled;
	bool print_max;
	bool allow_instances;
	bool noboot;
};

struct tracer_flags {
	u32 val;
	struct tracer_opt *opts;
	struct tracer *trace;
};

struct tracer_opt {
	const char *name;
	u32 bit;
};

typedef int (*cmp_func_t)(const void *, const void *);

struct tracer_stat {
	const char *name;
	void * (*stat_start)(struct tracer_stat *);
	void * (*stat_next)(void *, int);
	cmp_func_t stat_cmp;
	int (*stat_show)(struct seq_file *, void *);
	void (*stat_release)(void *);
	int (*stat_headers)(struct seq_file *);
};

struct tracing_log_err {
	struct list_head list;
	struct err_info info;
	char loc[128];
	char *cmd;
};

struct track {
	long unsigned int addr;
	depot_stack_handle_t handle;
	int cpu;
	int pid;
	long unsigned int when;
};

struct trackpoint_attr_data {
	size_t field_offset;
	u8 command;
	u8 mask;
	bool inverted;
	u8 power_on_default;
};

struct trackpoint_data {
	u8 variant_id;
	u8 firmware_id;
	u8 sensitivity;
	u8 speed;
	u8 inertia;
	u8 reach;
	u8 draghys;
	u8 mindrag;
	u8 thresh;
	u8 upthresh;
	u8 ztime;
	u8 jenks;
	u8 drift_time;
	bool press_to_select;
	bool skipback;
	bool ext_dev;
};

struct trampoline_header {
	u64 start;
	u64 efer;
	u32 cr4;
	u32 flags;
	u32 lock;
};

struct transaction_chp_stats_s {
	long unsigned int cs_chp_time;
	__u32 cs_forced_to_close;
	__u32 cs_written;
	__u32 cs_dropped;
};

struct transaction_s {
	journal_t *t_journal;
	tid_t t_tid;
	enum {
		T_RUNNING = 0,
		T_LOCKED = 1,
		T_SWITCH = 2,
		T_FLUSH = 3,
		T_COMMIT = 4,
		T_COMMIT_DFLUSH = 5,
		T_COMMIT_JFLUSH = 6,
		T_COMMIT_CALLBACK = 7,
		T_FINISHED = 8,
	} t_state;
	long unsigned int t_log_start;
	int t_nr_buffers;
	struct journal_head *t_reserved_list;
	struct journal_head *t_buffers;
	struct journal_head *t_forget;
	struct journal_head *t_checkpoint_list;
	struct journal_head *t_shadow_list;
	struct list_head t_inode_list;
	long unsigned int t_max_wait;
	long unsigned int t_start;
	long unsigned int t_requested;
	struct transaction_chp_stats_s t_chp_stats;
	atomic_t t_updates;
	atomic_t t_outstanding_credits;
	atomic_t t_outstanding_revokes;
	atomic_t t_handle_count;
	transaction_t *t_cpnext;
	transaction_t *t_cpprev;
	long unsigned int t_expires;
	ktime_t t_start_time;
	unsigned int t_synchronous_commit: 1;
	int t_need_data_flush;
	struct list_head t_private_list;
};

struct trc_stall_chk_rdr {
	int nesting;
	int ipi_to_cpu;
	u8 needqs;
};

typedef struct tree_desc_s tree_desc;

struct tree_descr {
	const char *name;
	const struct file_operations *ops;
	int mode;
};

struct trie {
	struct key_vector kv[1];
};

struct trie_stat {
	unsigned int totdepth;
	unsigned int maxdepth;
	unsigned int tnodes;
	unsigned int leaves;
	unsigned int nullpointers;
	unsigned int prefixes;
	unsigned int nodesizes[32];
};

struct ts_ops;

struct ts_state;

struct ts_config {
	struct ts_ops *ops;
	int flags;
	unsigned int (*get_next_block)(unsigned int, const u8 **, struct ts_config *, struct ts_state *);
	void (*finish)(struct ts_config *, struct ts_state *);
};

struct ts_ops {
	const char *name;
	struct ts_config * (*init)(const void *, unsigned int, gfp_t, int);
	unsigned int (*find)(struct ts_config *, struct ts_state *);
	void (*destroy)(struct ts_config *);
	void * (*get_pattern)(struct ts_config *);
	unsigned int (*get_pattern_len)(struct ts_config *);
	struct module *owner;
	struct list_head list;
};

struct ts_state {
	unsigned int offset;
	char cb[48];
};

struct tsc_adjust {
	s64 bootval;
	s64 adjusted;
	long unsigned int nextcheck;
	bool warned;
};

struct tsconfig_reply_data {
	struct ethnl_reply_data base;
	struct hwtstamp_provider_desc hwprov_desc;
	struct {
		u32 tx_type;
		u32 rx_filter;
		u32 flags;
	} hwtst_config;
};

struct tsconfig_req_info {
	struct ethnl_req_info base;
};

struct tsinfo_reply_data {
	struct ethnl_reply_data base;
	struct kernel_ethtool_ts_info ts_info;
	struct ethtool_ts_stats stats;
};

struct tsinfo_req_info {
	struct ethnl_req_info base;
	struct hwtstamp_provider_desc hwprov_desc;
};

struct tso_t {
	int next_frag_idx;
	int size;
	void *data;
	u16 ip_id;
	u8 tlen;
	bool ipv6;
	u32 tcp_seq;
};

struct tsq_tasklet {
	struct tasklet_struct tasklet;
	struct list_head head;
};

struct ttm_agp_backend {
	struct ttm_tt ttm;
	struct agp_memory *mem;
	struct agp_bridge_data *bridge;
};

struct ttm_lru_walk_ops;

struct ttm_operation_ctx;

struct ttm_lru_walk {
	const struct ttm_lru_walk_ops *ops;
	struct ttm_operation_ctx *ctx;
	struct ww_acquire_ctx *ticket;
	bool trylock_only;
};

struct ttm_place;

struct ttm_bo_evict_walk {
	struct ttm_lru_walk walk;
	const struct ttm_place *place;
	struct ttm_buffer_object *evictor;
	struct ttm_resource **res;
	long unsigned int evicted;
	struct dmem_cgroup_pool_state *limit_pool;
	bool try_low;
	bool hit_low;
};

struct ttm_bo_kmap_obj {
	void *virtual;
	struct page *page;
	enum {
		ttm_bo_map_iomap = 129,
		ttm_bo_map_vmap = 2,
		ttm_bo_map_kmap = 3,
		ttm_bo_map_premapped = 132,
	} bo_kmap_type;
	struct ttm_buffer_object *bo;
};

struct ttm_bo_swapout_walk {
	struct ttm_lru_walk walk;
	gfp_t gfp_flags;
	bool hit_low;
	bool evict_low;
};

struct ttm_placement;

struct ttm_device_funcs {
	struct ttm_tt * (*ttm_tt_create)(struct ttm_buffer_object *, uint32_t);
	int (*ttm_tt_populate)(struct ttm_device *, struct ttm_tt *, struct ttm_operation_ctx *);
	void (*ttm_tt_unpopulate)(struct ttm_device *, struct ttm_tt *);
	void (*ttm_tt_destroy)(struct ttm_device *, struct ttm_tt *);
	bool (*eviction_valuable)(struct ttm_buffer_object *, const struct ttm_place *);
	void (*evict_flags)(struct ttm_buffer_object *, struct ttm_placement *);
	int (*move)(struct ttm_buffer_object *, bool, struct ttm_operation_ctx *, struct ttm_resource *, struct ttm_place *);
	void (*delete_mem_notify)(struct ttm_buffer_object *);
	void (*swap_notify)(struct ttm_buffer_object *);
	int (*io_mem_reserve)(struct ttm_device *, struct ttm_resource *);
	void (*io_mem_free)(struct ttm_device *, struct ttm_resource *);
	long unsigned int (*io_mem_pfn)(struct ttm_buffer_object *, long unsigned int);
	int (*access_memory)(struct ttm_buffer_object *, long unsigned int, void *, int, int);
	void (*release_notify)(struct ttm_buffer_object *);
};

struct ttm_global {
	struct page *dummy_read_page;
	struct list_head device_list;
	atomic_t bo_count;
};

struct ttm_kmap_iter_linear_io {
	struct ttm_kmap_iter base;
	struct iosys_map dmap;
	bool needs_unmap;
};

struct ttm_kmap_iter_ops {
	void (*map_local)(struct ttm_kmap_iter *, struct iosys_map *, long unsigned int);
	void (*unmap_local)(struct ttm_kmap_iter *, struct iosys_map *);
	bool maps_tt;
};

struct ttm_lru_bulk_move_pos {
	struct ttm_resource *first;
	struct ttm_resource *last;
};

struct ttm_lru_bulk_move {
	struct ttm_lru_bulk_move_pos pos[32];
	struct list_head cursor_list;
};

struct ttm_lru_walk_ops {
	s64 (*process_bo)(struct ttm_lru_walk *, struct ttm_buffer_object *);
};

struct ttm_operation_ctx {
	bool interruptible;
	bool no_wait_gpu;
	bool gfp_retry_mayfail;
	bool allow_res_evict;
	bool force_alloc;
	struct dma_resv *resv;
	uint64_t bytes_moved;
};

struct ttm_place {
	unsigned int fpfn;
	unsigned int lpfn;
	uint32_t mem_type;
	uint32_t flags;
};

struct ttm_placement {
	unsigned int num_placement;
	const struct ttm_place *placement;
};

struct ttm_pool_dma {
	dma_addr_t addr;
	long unsigned int vaddr;
};

struct ttm_range_manager {
	struct ttm_resource_manager manager;
	struct drm_mm mm;
	spinlock_t lock;
};

struct ttm_range_mgr_node {
	struct ttm_resource base;
	struct drm_mm_node mm_nodes[0];
};

struct ttm_resource_cursor {
	struct ttm_resource_manager *man;
	struct ttm_lru_item hitch;
	struct list_head bulk_link;
	struct ttm_lru_bulk_move *bulk;
	unsigned int mem_type;
	unsigned int priority;
};

struct ttm_resource_manager_func {
	int (*alloc)(struct ttm_resource_manager *, struct ttm_buffer_object *, const struct ttm_place *, struct ttm_resource **);
	void (*free)(struct ttm_resource_manager *, struct ttm_resource *);
	bool (*intersects)(struct ttm_resource_manager *, struct ttm_resource *, const struct ttm_place *, size_t);
	bool (*compatible)(struct ttm_resource_manager *, struct ttm_resource *, const struct ttm_place *, size_t);
	void (*debug)(struct ttm_resource_manager *, struct drm_printer *);
};

struct ttm_transfer_obj {
	struct ttm_buffer_object base;
	struct ttm_buffer_object *bo;
};

struct ttm_validate_buffer {
	struct list_head head;
	struct ttm_buffer_object *bo;
	unsigned int num_shared;
};

struct tty_audit_buf {
	struct mutex mutex;
	dev_t dev;
	bool icanon;
	size_t valid;
	u8 *data;
};

struct tty_operations;

struct tty_driver {
	struct kref kref;
	struct cdev **cdevs;
	struct module *owner;
	const char *driver_name;
	const char *name;
	int name_base;
	int major;
	int minor_start;
	unsigned int num;
	short int type;
	short int subtype;
	struct ktermios init_termios;
	long unsigned int flags;
	struct proc_dir_entry *proc_entry;
	struct tty_driver *other;
	struct tty_struct **ttys;
	struct tty_port **ports;
	struct ktermios **termios;
	void *driver_state;
	const struct tty_operations *ops;
	struct list_head tty_drivers;
};

struct tty_file_private {
	struct tty_struct *tty;
	struct file *file;
	struct list_head list;
};

struct tty_ldisc_ops;

struct tty_ldisc {
	struct tty_ldisc_ops *ops;
	struct tty_struct *tty;
};

struct tty_ldisc_ops {
	char *name;
	int num;
	int (*open)(struct tty_struct *);
	void (*close)(struct tty_struct *);
	void (*flush_buffer)(struct tty_struct *);
	ssize_t (*read)(struct tty_struct *, struct file *, u8 *, size_t, void **, long unsigned int);
	ssize_t (*write)(struct tty_struct *, struct file *, const u8 *, size_t);
	int (*ioctl)(struct tty_struct *, unsigned int, long unsigned int);
	int (*compat_ioctl)(struct tty_struct *, unsigned int, long unsigned int);
	void (*set_termios)(struct tty_struct *, const struct ktermios *);
	__poll_t (*poll)(struct tty_struct *, struct file *, struct poll_table_struct *);
	void (*hangup)(struct tty_struct *);
	void (*receive_buf)(struct tty_struct *, const u8 *, const u8 *, size_t);
	void (*write_wakeup)(struct tty_struct *);
	void (*dcd_change)(struct tty_struct *, bool);
	size_t (*receive_buf2)(struct tty_struct *, const u8 *, const u8 *, size_t);
	void (*lookahead_buf)(struct tty_struct *, const u8 *, const u8 *, size_t);
	struct module *owner;
};

struct tty_operations {
	struct tty_struct * (*lookup)(struct tty_driver *, struct file *, int);
	int (*install)(struct tty_driver *, struct tty_struct *);
	void (*remove)(struct tty_driver *, struct tty_struct *);
	int (*open)(struct tty_struct *, struct file *);
	void (*close)(struct tty_struct *, struct file *);
	void (*shutdown)(struct tty_struct *);
	void (*cleanup)(struct tty_struct *);
	ssize_t (*write)(struct tty_struct *, const u8 *, size_t);
	int (*put_char)(struct tty_struct *, u8);
	void (*flush_chars)(struct tty_struct *);
	unsigned int (*write_room)(struct tty_struct *);
	unsigned int (*chars_in_buffer)(struct tty_struct *);
	int (*ioctl)(struct tty_struct *, unsigned int, long unsigned int);
	long int (*compat_ioctl)(struct tty_struct *, unsigned int, long unsigned int);
	void (*set_termios)(struct tty_struct *, const struct ktermios *);
	void (*throttle)(struct tty_struct *);
	void (*unthrottle)(struct tty_struct *);
	void (*stop)(struct tty_struct *);
	void (*start)(struct tty_struct *);
	void (*hangup)(struct tty_struct *);
	int (*break_ctl)(struct tty_struct *, int);
	void (*flush_buffer)(struct tty_struct *);
	int (*ldisc_ok)(struct tty_struct *, int);
	void (*set_ldisc)(struct tty_struct *);
	void (*wait_until_sent)(struct tty_struct *, int);
	void (*send_xchar)(struct tty_struct *, u8);
	int (*tiocmget)(struct tty_struct *);
	int (*tiocmset)(struct tty_struct *, unsigned int, unsigned int);
	int (*resize)(struct tty_struct *, struct winsize *);
	int (*get_icount)(struct tty_struct *, struct serial_icounter_struct *);
	int (*get_serial)(struct tty_struct *, struct serial_struct *);
	int (*set_serial)(struct tty_struct *, struct serial_struct *);
	void (*show_fdinfo)(struct tty_struct *, struct seq_file *);
	int (*proc_show)(struct seq_file *, void *);
};

struct tty_port_client_operations {
	size_t (*receive_buf)(struct tty_port *, const u8 *, const u8 *, size_t);
	void (*lookahead_buf)(struct tty_port *, const u8 *, const u8 *, size_t);
	void (*write_wakeup)(struct tty_port *);
};

struct tty_port_operations {
	bool (*carrier_raised)(struct tty_port *);
	void (*dtr_rts)(struct tty_port *, bool);
	void (*shutdown)(struct tty_port *);
	int (*activate)(struct tty_port *, struct tty_struct *);
	void (*destruct)(struct tty_port *);
};

struct tty_struct {
	struct kref kref;
	int index;
	struct device *dev;
	struct tty_driver *driver;
	struct tty_port *port;
	const struct tty_operations *ops;
	struct tty_ldisc *ldisc;
	struct ld_semaphore ldisc_sem;
	struct mutex atomic_write_lock;
	struct mutex legacy_mutex;
	struct mutex throttle_mutex;
	struct rw_semaphore termios_rwsem;
	struct mutex winsize_mutex;
	struct ktermios termios;
	struct ktermios termios_locked;
	char name[64];
	long unsigned int flags;
	int count;
	unsigned int receive_room;
	struct winsize winsize;
	struct {
		spinlock_t lock;
		bool stopped;
		bool tco_stopped;
	} flow;
	struct {
		struct pid *pgrp;
		struct pid *session;
		spinlock_t lock;
		unsigned char pktstatus;
		bool packet;
	} ctrl;
	bool hw_stopped;
	bool closing;
	int flow_change;
	struct tty_struct *link;
	struct fasync_struct *fasync;
	wait_queue_head_t write_wait;
	wait_queue_head_t read_wait;
	struct work_struct hangup_work;
	void *disc_data;
	void *driver_data;
	spinlock_t files_lock;
	int write_cnt;
	u8 *write_buf;
	struct list_head tty_files;
	struct work_struct SAK_work;
};

struct tun_security_struct {
	u32 sid;
};

struct tuple_flags {
	u_int link_space: 4;
	u_int has_link: 1;
	u_int mfc_fn: 3;
	u_int space: 4;
};

struct tuple_t {
	u_int Attributes;
	cisdata_t DesiredTuple;
	u_int Flags;
	u_int LinkOffset;
	u_int CISOffset;
	cisdata_t TupleCode;
	cisdata_t TupleLink;
	cisdata_t TupleOffset;
	cisdata_t TupleDataMax;
	cisdata_t TupleDataLen;
	cisdata_t *TupleData;
};

struct video_levels;

struct tv_mode {
	const char *name;
	u32 clock;
	u16 refresh;
	u8 oversample;
	u8 hsync_end;
	u16 hblank_start;
	u16 hblank_end;
	u16 htotal;
	bool progressive: 1;
	bool trilevel_sync: 1;
	bool component_only: 1;
	u8 vsync_start_f1;
	u8 vsync_start_f2;
	u8 vsync_len;
	bool veq_ena: 1;
	u8 veq_start_f1;
	u8 veq_start_f2;
	u8 veq_len;
	u8 vi_end_f1;
	u8 vi_end_f2;
	u16 nbr_end;
	bool burst_ena: 1;
	u8 hburst_start;
	u8 hburst_len;
	u8 vburst_start_f1;
	u16 vburst_end_f1;
	u8 vburst_start_f2;
	u16 vburst_end_f2;
	u8 vburst_start_f3;
	u16 vburst_end_f3;
	u8 vburst_start_f4;
	u16 vburst_end_f4;
	u16 dda2_size;
	u16 dda3_size;
	u8 dda1_inc;
	u16 dda2_inc;
	u16 dda3_inc;
	u32 sc_reset;
	bool pal_burst: 1;
	const struct video_levels *composite_levels;
	const struct video_levels *svideo_levels;
	const struct color_conversion *composite_color;
	const struct color_conversion *svideo_color;
	const u32 *filter_table;
};

struct tx_ring_info {
	struct sk_buff *skb;
	long unsigned int flags;
	dma_addr_t mapaddr;
	__u32 maplen;
};

struct txq_info {
	struct fq_tin tin;
	struct codel_vars def_cvars;
	struct codel_stats cstats;
	u16 schedule_round;
	struct list_head schedule_order;
	struct sk_buff_head frags;
	long unsigned int flags;
	struct ieee80211_txq txq;
};

struct type_datum {
	u32 value;
	u32 bounds;
	unsigned char primary;
	unsigned char attribute;
};

struct type_set {
	struct ebitmap types;
	struct ebitmap negset;
	u32 flags;
};

struct typec_connector {
	void (*attach)(struct typec_connector *, struct device *);
	void (*deattach)(struct typec_connector *, struct device *);
};

struct uart_8250_em485 {
	struct hrtimer start_tx_timer;
	struct hrtimer stop_tx_timer;
	struct hrtimer *active_timer;
	struct uart_8250_port *port;
	unsigned int tx_stopped: 1;
};

struct uart_8250_ops {
	int (*setup_irq)(struct uart_8250_port *);
	void (*release_irq)(struct uart_8250_port *);
	void (*setup_timer)(struct uart_8250_port *);
};

struct mctrl_gpios;

struct uart_8250_port {
	struct uart_port port;
	struct timer_list timer;
	struct list_head list;
	u32 capabilities;
	u16 bugs;
	unsigned int tx_loadsz;
	unsigned char acr;
	unsigned char fcr;
	unsigned char ier;
	unsigned char lcr;
	unsigned char mcr;
	unsigned char cur_iotype;
	unsigned int rpm_tx_active;
	unsigned char canary;
	unsigned char probe;
	struct mctrl_gpios *gpios;
	u16 lsr_saved_flags;
	u16 lsr_save_mask;
	unsigned char msr_saved_flags;
	struct uart_8250_dma *dma;
	const struct uart_8250_ops *ops;
	u32 (*dl_read)(struct uart_8250_port *);
	void (*dl_write)(struct uart_8250_port *, u32);
	struct uart_8250_em485 *em485;
	void (*rs485_start_tx)(struct uart_8250_port *, bool);
	void (*rs485_stop_tx)(struct uart_8250_port *, bool);
	struct delayed_work overrun_backoff;
	u32 overrun_backoff_time_ms;
};

struct uart_driver {
	struct module *owner;
	const char *driver_name;
	const char *dev_name;
	int major;
	int minor;
	int nr;
	struct console *cons;
	struct uart_state *state;
	struct tty_driver *tty_driver;
};

struct uart_match {
	struct uart_port *port;
	struct uart_driver *driver;
};

struct uart_ops {
	unsigned int (*tx_empty)(struct uart_port *);
	void (*set_mctrl)(struct uart_port *, unsigned int);
	unsigned int (*get_mctrl)(struct uart_port *);
	void (*stop_tx)(struct uart_port *);
	void (*start_tx)(struct uart_port *);
	void (*throttle)(struct uart_port *);
	void (*unthrottle)(struct uart_port *);
	void (*send_xchar)(struct uart_port *, char);
	void (*stop_rx)(struct uart_port *);
	void (*start_rx)(struct uart_port *);
	void (*enable_ms)(struct uart_port *);
	void (*break_ctl)(struct uart_port *, int);
	int (*startup)(struct uart_port *);
	void (*shutdown)(struct uart_port *);
	void (*flush_buffer)(struct uart_port *);
	void (*set_termios)(struct uart_port *, struct ktermios *, const struct ktermios *);
	void (*set_ldisc)(struct uart_port *, struct ktermios *);
	void (*pm)(struct uart_port *, unsigned int, unsigned int);
	const char * (*type)(struct uart_port *);
	void (*release_port)(struct uart_port *);
	int (*request_port)(struct uart_port *);
	void (*config_port)(struct uart_port *, int);
	int (*verify_port)(struct uart_port *, struct serial_struct *);
	int (*ioctl)(struct uart_port *, unsigned int, long unsigned int);
};

struct uart_state {
	struct tty_port port;
	enum uart_pm_state pm_state;
	atomic_t refcount;
	wait_queue_head_t remove_wait;
	struct uart_port *uart_port;
};

struct ubuf_info_msgzc {
	struct ubuf_info ubuf;
	union {
		struct {
			long unsigned int desc;
			void *ctx;
		};
		struct {
			u32 id;
			u16 len;
			u16 zerocopy: 1;
			u32 bytelen;
		};
	};
	struct mmpin mmp;
};

struct ubuf_info_ops {
	void (*complete)(struct sk_buff *, struct ubuf_info *, bool);
	int (*link_skb)(struct sk_buff *, struct ubuf_info *);
};

struct uc_css_header {
	u32 module_type;
	u32 header_size_dw;
	u32 header_version;
	u32 module_id;
	u32 module_vendor;
	u32 date;
	u32 size_dw;
	u32 key_size_dw;
	u32 modulus_size_dw;
	u32 exponent_size_dw;
	u32 time;
	char username[8];
	char buildnumber[12];
	u32 sw_version;
	u32 vf_version;
	u32 reserved0[12];
	union {
		u32 private_data_size;
		u32 reserved1;
	};
	u32 header_info;
};

struct uc_fw_blob {
	const char *path;
	bool legacy;
	u8 major;
	u8 minor;
	u8 patch;
	bool has_gsc_headers;
} __attribute__((packed));

struct uc_fw_platform_requirement {
	enum intel_platform p;
	u8 rev;
	const struct uc_fw_blob blob;
} __attribute__((packed));

struct ucode_cpu_info {
	struct cpu_signature cpu_sig;
	void *mc;
};

struct ucode_patch {
	struct list_head plist;
	void *data;
	unsigned int size;
	u32 patch_id;
	u16 equiv_cpu;
};

struct ucounts {
	struct hlist_node node;
	struct user_namespace *ns;
	kuid_t uid;
	atomic_t count;
	atomic_long_t ucount[10];
	atomic_long_t rlimit[4];
};

struct ucred {
	__u32 pid;
	__u32 uid;
	__u32 gid;
};

struct udp_sock {
	struct inet_sock inet;
	long unsigned int udp_flags;
	int pending;
	__u8 encap_type;
	__u16 udp_lrpa_hash;
	struct hlist_nulls_node udp_lrpa_node;
	__u16 len;
	__u16 gso_size;
	__u16 pcslen;
	__u16 pcrlen;
	int (*encap_rcv)(struct sock *, struct sk_buff *);
	void (*encap_err_rcv)(struct sock *, struct sk_buff *, int, __be16, u32, u8 *);
	int (*encap_err_lookup)(struct sock *, struct sk_buff *);
	void (*encap_destroy)(struct sock *);
	struct sk_buff * (*gro_receive)(struct sock *, struct list_head *, struct sk_buff *);
	int (*gro_complete)(struct sock *, struct sk_buff *, int);
	long: 64;
	struct sk_buff_head reader_queue;
	int forward_deficit;
	int forward_threshold;
	bool peeking_with_offset;
	long: 64;
	long: 64;
	long: 64;
};

struct udp6_sock {
	struct udp_sock udp;
	struct ipv6_pinfo inet6;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct udp_dev_scratch {
	u32 _tsize_state;
	u16 len;
	bool is_linear;
	bool csum_unnecessary;
};

struct udp_hslot {
	union {
		struct hlist_head head;
		struct hlist_nulls_head nulls_head;
	};
	int count;
	spinlock_t lock;
};

struct udp_hslot_main {
	struct udp_hslot hslot;
	u32 hash4_cnt;
	long: 64;
};

struct udp_mib {
	long unsigned int mibs[10];
};

struct udp_seq_afinfo {
	sa_family_t family;
	struct udp_table *udp_table;
};

struct udp_skb_cb {
	union {
		struct inet_skb_parm h4;
		struct inet6_skb_parm h6;
	} header;
	__u16 cscov;
	__u8 partial_cov;
};

struct udp_table {
	struct udp_hslot *hash;
	struct udp_hslot_main *hash2;
	struct udp_hslot *hash4;
	unsigned int mask;
	unsigned int log;
};

struct udp_tunnel_info {
	short unsigned int type;
	sa_family_t sa_family;
	__be16 port;
	u8 hw_priv;
};

struct udp_tunnel_nic_table_info {
	unsigned int n_entries;
	unsigned int tunnel_types;
};

struct udp_tunnel_nic_shared;

struct udp_tunnel_nic_info {
	int (*set_port)(struct net_device *, unsigned int, unsigned int, struct udp_tunnel_info *);
	int (*unset_port)(struct net_device *, unsigned int, unsigned int, struct udp_tunnel_info *);
	int (*sync_table)(struct net_device *, unsigned int);
	struct udp_tunnel_nic_shared *shared;
	unsigned int flags;
	struct udp_tunnel_nic_table_info tables[4];
};

struct udp_tunnel_nic_ops {
	void (*get_port)(struct net_device *, unsigned int, unsigned int, struct udp_tunnel_info *);
	void (*set_port_priv)(struct net_device *, unsigned int, unsigned int, u8);
	void (*add_port)(struct net_device *, struct udp_tunnel_info *);
	void (*del_port)(struct net_device *, struct udp_tunnel_info *);
	void (*reset_ntf)(struct net_device *);
	size_t (*dump_size)(struct net_device *, unsigned int);
	int (*dump_write)(struct net_device *, unsigned int, struct sk_buff *);
};

struct udp_tunnel_nic_shared {
	struct udp_tunnel_nic *udp_tunnel_nic_info;
	struct list_head devices;
};

struct uevent_sock {
	struct list_head list;
	struct sock *sk;
};

struct uhci_td;

struct uhci_qh;

struct uhci_hcd {
	long unsigned int io_addr;
	void *regs;
	struct dma_pool *qh_pool;
	struct dma_pool *td_pool;
	struct uhci_td *term_td;
	struct uhci_qh *skelqh[11];
	struct uhci_qh *next_qh;
	spinlock_t lock;
	dma_addr_t frame_dma_handle;
	__le32 *frame;
	void **frame_cpu;
	enum uhci_rh_state rh_state;
	long unsigned int auto_stop_time;
	unsigned int frame_number;
	unsigned int is_stopped;
	unsigned int last_iso_frame;
	unsigned int cur_iso_frame;
	unsigned int scan_in_progress: 1;
	unsigned int need_rescan: 1;
	unsigned int dead: 1;
	unsigned int RD_enable: 1;
	unsigned int is_initialized: 1;
	unsigned int fsbr_is_on: 1;
	unsigned int fsbr_is_wanted: 1;
	unsigned int fsbr_expiring: 1;
	struct timer_list fsbr_timer;
	unsigned int oc_low: 1;
	unsigned int wait_for_hp: 1;
	unsigned int big_endian_mmio: 1;
	unsigned int big_endian_desc: 1;
	unsigned int is_aspeed: 1;
	long unsigned int port_c_suspend;
	long unsigned int resuming_ports;
	long unsigned int ports_timeout;
	struct list_head idle_qh_list;
	int rh_numports;
	wait_queue_head_t waitqh;
	int num_waiting;
	int total_load;
	short int load[32];
	struct clk *clk;
	void (*reset_hc)(struct uhci_hcd *);
	int (*check_and_reset_hc)(struct uhci_hcd *);
	void (*configure_hc)(struct uhci_hcd *);
	int (*resume_detect_interrupts_are_broken)(struct uhci_hcd *);
	int (*global_suspend_mode_is_broken)(struct uhci_hcd *);
};

struct usb_iso_packet_descriptor;

struct uhci_qh {
	__le32 link;
	__le32 element;
	dma_addr_t dma_handle;
	struct list_head node;
	struct usb_host_endpoint *hep;
	struct usb_device *udev;
	struct list_head queue;
	struct uhci_td *dummy_td;
	struct uhci_td *post_td;
	struct usb_iso_packet_descriptor *iso_packet_desc;
	long unsigned int advance_jiffies;
	unsigned int unlink_frame;
	unsigned int period;
	short int phase;
	short int load;
	unsigned int iso_frame;
	int state;
	int type;
	int skel;
	unsigned int initial_toggle: 1;
	unsigned int needs_fixup: 1;
	unsigned int is_stopped: 1;
	unsigned int wait_expired: 1;
	unsigned int bandwidth_reserved: 1;
};

struct uhci_td {
	__le32 link;
	__le32 status;
	__le32 token;
	__le32 buffer;
	dma_addr_t dma_handle;
	struct list_head list;
	int frame;
	struct list_head fl_list;
};

struct uncached_list {
	spinlock_t lock;
	struct list_head head;
};

struct uncore_event_desc {
	struct device_attribute attr;
	const char *config;
};

struct uncore_global_discovery {
	union {
		u64 table1;
		struct {
			u64 type: 8;
			u64 stride: 8;
			u64 max_units: 10;
			u64 __reserved_1: 36;
			u64 access_type: 2;
		};
	};
	u64 ctl;
	union {
		u64 table3;
		struct {
			u64 status_offset: 8;
			u64 num_status: 16;
			u64 __reserved_2: 40;
		};
	};
};

struct uncore_iio_topology {
	int pci_bus_no;
	int segment;
};

struct uncore_unit_discovery {
	union {
		u64 table1;
		struct {
			u64 num_regs: 8;
			u64 ctl_offset: 8;
			u64 bit_width: 8;
			u64 ctr_offset: 8;
			u64 status_offset: 8;
			u64 __reserved_1: 22;
			u64 access_type: 2;
		};
	};
	u64 ctl;
	union {
		u64 table3;
		struct {
			u64 box_type: 16;
			u64 box_id: 16;
			u64 __reserved_2: 32;
		};
	};
};

struct uncore_upi_topology {
	int die_to;
	int pmu_idx_to;
	int enabled;
};

struct uni_pagedict {
	u16 **uni_pgdir[32];
	long unsigned int refcount;
	long unsigned int sum;
	unsigned char *inverse_translations[4];
	u16 *inverse_trans_unicode;
};

struct unipair;

struct unimapdesc {
	short unsigned int entry_ct;
	struct unipair *entries;
};

struct unipair {
	short unsigned int unicode;
	short unsigned int fontpos;
};

struct unity_map_entry {
	struct list_head list;
	u16 devid_start;
	u16 devid_end;
	u64 address_start;
	u64 address_end;
	int prot;
};

struct unix_address {
	refcount_t refcnt;
	int len;
	struct sockaddr_un name[0];
};

struct unix_domain {
	struct auth_domain h;
};

struct unix_edge {
	struct unix_sock *predecessor;
	struct unix_sock *successor;
	struct list_head vertex_entry;
	struct list_head stack_entry;
};

struct unix_gid {
	struct cache_head h;
	kuid_t uid;
	struct group_info *gi;
	struct callback_head rcu;
};

struct unix_skb_parms {
	struct pid *pid;
	kuid_t uid;
	kgid_t gid;
	struct scm_fp_list *fp;
	u32 secid;
	u32 consumed;
};

struct unix_vertex;

struct unix_sock {
	struct sock sk;
	struct unix_address *addr;
	struct path path;
	struct mutex iolock;
	struct mutex bindlock;
	struct sock *peer;
	struct sock *listener;
	struct unix_vertex *vertex;
	spinlock_t lock;
	long: 64;
	struct socket_wq peer_wq;
	wait_queue_entry_t peer_wake;
	struct scm_stat scm_stat;
	struct sk_buff *oob_skb;
};

struct unix_stream_read_state {
	int (*recv_actor)(struct sk_buff *, int, int, struct unix_stream_read_state *);
	struct socket *socket;
	struct msghdr *msg;
	struct pipe_inode_info *pipe;
	size_t size;
	int flags;
	unsigned int splice_flags;
};

struct unix_vertex {
	struct list_head edges;
	struct list_head entry;
	struct list_head scc_entry;
	long unsigned int out_degree;
	long unsigned int index;
	long unsigned int scc_index;
};

struct unlink_vma_file_batch {
	int count;
	struct vm_area_struct *vmas[8];
};

struct unsol_bcast_probe_resp_data {
	struct callback_head callback_head;
	int len;
	u8 data[0];
};

struct unwind_state {
	struct stack_info stack_info;
	long unsigned int stack_mask;
	struct task_struct *task;
	int graph_idx;
	struct llist_node *kr_cur;
	bool error;
	bool signal;
	bool full_regs;
	long unsigned int sp;
	long unsigned int bp;
	long unsigned int ip;
	struct pt_regs *regs;
	struct pt_regs *prev_regs;
};

struct update_classid_context {
	u32 classid;
	unsigned int batch;
};

union upper_chunk {
	union upper_chunk *next;
	union lower_chunk *data[256];
};

struct uprobe {
	struct rb_node rb_node;
	refcount_t ref;
	struct rw_semaphore register_rwsem;
	struct rw_semaphore consumer_rwsem;
	struct list_head pending_list;
	struct list_head consumers;
	struct inode *inode;
	union {
		struct callback_head rcu;
		struct work_struct work;
	};
	loff_t offset;
	loff_t ref_ctr_offset;
	long unsigned int flags;
	struct arch_uprobe arch;
};

struct uprobe_cpu_buffer {
	struct mutex mutex;
	void *buf;
	int dsize;
};

struct uprobe_dispatch_data {
	struct trace_uprobe *tu;
	long unsigned int bp_addr;
};

struct uprobe_task {
	enum uprobe_task_state state;
	unsigned int depth;
	struct return_instance *return_instances;
	struct return_instance *ri_pool;
	struct timer_list ri_timer;
	seqcount_t ri_seqcount;
	union {
		struct {
			struct arch_uprobe_task autask;
			long unsigned int vaddr;
		};
		struct {
			struct callback_head dup_xol_work;
			long unsigned int dup_xol_addr;
		};
	};
	struct uprobe *active_uprobe;
	long unsigned int xol_vaddr;
	struct arch_uprobe *auprobe;
};

struct uprobe_trace_entry_head {
	struct trace_entry ent;
	long unsigned int vaddr[0];
};

struct uprobe_xol_ops {
	bool (*emulate)(struct arch_uprobe *, struct pt_regs *);
	int (*pre_xol)(struct arch_uprobe *, struct pt_regs *);
	int (*post_xol)(struct arch_uprobe *, struct pt_regs *);
	void (*abort)(struct arch_uprobe *, struct pt_regs *);
};

typedef void (*usb_complete_t)(struct urb *);

struct usb_iso_packet_descriptor {
	unsigned int offset;
	unsigned int length;
	unsigned int actual_length;
	int status;
};

struct usb_anchor;

struct urb {
	struct kref kref;
	int unlinked;
	void *hcpriv;
	atomic_t use_count;
	atomic_t reject;
	struct list_head urb_list;
	struct list_head anchor_list;
	struct usb_anchor *anchor;
	struct usb_device *dev;
	struct usb_host_endpoint *ep;
	unsigned int pipe;
	unsigned int stream_id;
	int status;
	unsigned int transfer_flags;
	void *transfer_buffer;
	dma_addr_t transfer_dma;
	struct scatterlist *sg;
	int num_mapped_sgs;
	int num_sgs;
	u32 transfer_buffer_length;
	u32 actual_length;
	unsigned char *setup_packet;
	dma_addr_t setup_dma;
	int start_frame;
	int number_of_packets;
	int interval;
	int error_count;
	void *context;
	usb_complete_t complete;
	struct usb_iso_packet_descriptor iso_frame_desc[0];
};

struct urb_priv {
	struct ed *ed;
	u16 length;
	u16 td_cnt;
	struct list_head pending;
	struct td *td[0];
};

struct urb_priv___2 {
	struct list_head node;
	struct urb *urb;
	struct uhci_qh *qh;
	struct list_head td_list;
	unsigned int fsbr: 1;
};

struct xhci_segment;

struct xhci_td {
	struct list_head td_list;
	struct list_head cancelled_td_list;
	int status;
	enum xhci_cancelled_td_status cancel_status;
	struct urb *urb;
	struct xhci_segment *start_seg;
	union xhci_trb *start_trb;
	struct xhci_segment *end_seg;
	union xhci_trb *end_trb;
	struct xhci_segment *bounce_seg;
	bool urb_length_set;
	bool error_mid_td;
};

struct urb_priv___3 {
	int num_tds;
	int num_tds_done;
	struct xhci_td td[0];
};

typedef struct urb_priv urb_priv_t;

struct us_data;

typedef int (*trans_cmnd)(struct scsi_cmnd *, struct us_data *);

typedef int (*trans_reset)(struct us_data *);

typedef void (*proto_cmnd)(struct scsi_cmnd *, struct us_data *);

struct usb_sg_request {
	int status;
	size_t bytes;
	spinlock_t lock;
	struct usb_device *dev;
	int pipe;
	int entries;
	struct urb **urbs;
	int count;
	struct completion complete;
};

typedef void (*extra_data_destructor)(void *);

typedef void (*pm_hook)(struct us_data *, int);

struct usb_interface;

struct us_unusual_dev;

struct usb_ctrlrequest;

struct us_data {
	struct mutex dev_mutex;
	struct usb_device *pusb_dev;
	struct usb_interface *pusb_intf;
	const struct us_unusual_dev *unusual_dev;
	u64 fflags;
	long unsigned int dflags;
	unsigned int send_bulk_pipe;
	unsigned int recv_bulk_pipe;
	unsigned int send_ctrl_pipe;
	unsigned int recv_ctrl_pipe;
	unsigned int recv_intr_pipe;
	char *transport_name;
	char *protocol_name;
	__le32 bcs_signature;
	u8 subclass;
	u8 protocol;
	u8 max_lun;
	u8 ifnum;
	u8 ep_bInterval;
	trans_cmnd transport;
	trans_reset transport_reset;
	proto_cmnd proto_handler;
	struct scsi_cmnd *srb;
	unsigned int tag;
	char scsi_name[32];
	struct urb *current_urb;
	struct usb_ctrlrequest *cr;
	struct usb_sg_request current_sg;
	unsigned char *iobuf;
	dma_addr_t iobuf_dma;
	struct task_struct *ctl_thread;
	struct completion cmnd_ready;
	struct completion notify;
	wait_queue_head_t delay_wait;
	struct delayed_work scan_dwork;
	void *extra;
	extra_data_destructor extra_destructor;
	pm_hook suspend_resume_hook;
	int use_last_sector_hacks;
	int last_sector_retries;
};

struct us_unusual_dev {
	const char *vendorName;
	const char *productName;
	__u8 useProtocol;
	__u8 useTransport;
	int (*initFunction)(struct us_data *);
};

struct usage_priority {
	__u32 usage;
	bool global;
	unsigned int slot_overwrite;
};

struct usb2_lpm_parameters {
	unsigned int besl;
	int timeout;
};

struct usb3_lpm_parameters {
	unsigned int mel;
	unsigned int pel;
	unsigned int sel;
	int timeout;
};

struct usb_anchor {
	struct list_head urb_list;
	wait_queue_head_t wait;
	spinlock_t lock;
	atomic_t suspend_wakeups;
	unsigned int poisoned: 1;
};

struct usb_bos_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__le16 wTotalLength;
	__u8 bNumDeviceCaps;
} __attribute__((packed));

struct usb_bus {
	struct device *controller;
	struct device *sysdev;
	int busnum;
	const char *bus_name;
	u8 uses_pio_for_control;
	u8 otg_port;
	unsigned int is_b_host: 1;
	unsigned int b_hnp_enable: 1;
	unsigned int no_stop_on_short: 1;
	unsigned int no_sg_constraint: 1;
	unsigned int sg_tablesize;
	int devnum_next;
	struct mutex devnum_next_mutex;
	long unsigned int devmap[2];
	struct usb_device *root_hub;
	struct usb_bus *hs_companion;
	int bandwidth_allocated;
	int bandwidth_int_reqs;
	int bandwidth_isoc_reqs;
	unsigned int resuming_ports;
	struct mon_bus *mon_bus;
	int monitored;
};

struct usb_cdc_acm_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__u8 bmCapabilities;
};

struct usb_cdc_call_mgmt_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__u8 bmCapabilities;
	__u8 bDataInterface;
};

struct usb_cdc_country_functional_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__u8 iCountryCodeRelDate;
	__le16 wCountyCode0;
};

struct usb_cdc_dmm_desc {
	__u8 bFunctionLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubtype;
	__u16 bcdVersion;
	__le16 wMaxCommand;
} __attribute__((packed));

struct usb_cdc_ether_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__u8 iMACAddress;
	__le32 bmEthernetStatistics;
	__le16 wMaxSegmentSize;
	__le16 wNumberMCFilters;
	__u8 bNumberPowerFilters;
} __attribute__((packed));

struct usb_cdc_header_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__le16 bcdCDC;
} __attribute__((packed));

struct usb_cdc_mbim_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__le16 bcdMBIMVersion;
	__le16 wMaxControlMessage;
	__u8 bNumberFilters;
	__u8 bMaxFilterSize;
	__le16 wMaxSegmentSize;
	__u8 bmNetworkCapabilities;
} __attribute__((packed));

struct usb_cdc_mbim_extended_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__le16 bcdMBIMExtendedVersion;
	__u8 bMaxOutstandingCommandMessages;
	__le16 wMTU;
} __attribute__((packed));

struct usb_cdc_mdlm_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__le16 bcdVersion;
	__u8 bGUID[16];
} __attribute__((packed));

struct usb_cdc_mdlm_detail_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__u8 bGuidDescriptorType;
	__u8 bDetailData[0];
};

struct usb_cdc_ncm_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__le16 bcdNcmVersion;
	__u8 bmNetworkCapabilities;
} __attribute__((packed));

struct usb_cdc_network_terminal_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__u8 bEntityId;
	__u8 iName;
	__u8 bChannelIndex;
	__u8 bPhysicalInterface;
};

struct usb_cdc_obex_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__le16 bcdVersion;
} __attribute__((packed));

struct usb_cdc_union_desc;

struct usb_cdc_parsed_header {
	struct usb_cdc_union_desc *usb_cdc_union_desc;
	struct usb_cdc_header_desc *usb_cdc_header_desc;
	struct usb_cdc_call_mgmt_descriptor *usb_cdc_call_mgmt_descriptor;
	struct usb_cdc_acm_descriptor *usb_cdc_acm_descriptor;
	struct usb_cdc_country_functional_desc *usb_cdc_country_functional_desc;
	struct usb_cdc_network_terminal_desc *usb_cdc_network_terminal_desc;
	struct usb_cdc_ether_desc *usb_cdc_ether_desc;
	struct usb_cdc_dmm_desc *usb_cdc_dmm_desc;
	struct usb_cdc_mdlm_desc *usb_cdc_mdlm_desc;
	struct usb_cdc_mdlm_detail_desc *usb_cdc_mdlm_detail_desc;
	struct usb_cdc_obex_desc *usb_cdc_obex_desc;
	struct usb_cdc_ncm_desc *usb_cdc_ncm_desc;
	struct usb_cdc_mbim_desc *usb_cdc_mbim_desc;
	struct usb_cdc_mbim_extended_desc *usb_cdc_mbim_extended_desc;
	bool phonet_magic_present;
};

struct usb_cdc_union_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__u8 bMasterInterface0;
	__u8 bSlaveInterface0;
};

struct usb_charger_current {
	unsigned int sdp_min;
	unsigned int sdp_max;
	unsigned int dcp_min;
	unsigned int dcp_max;
	unsigned int cdp_min;
	unsigned int cdp_max;
	unsigned int aca_min;
	unsigned int aca_max;
};

struct usb_class_driver {
	char *name;
	char * (*devnode)(const struct device *, umode_t *);
	const struct file_operations *fops;
	int minor_base;
};

struct usb_config_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__le16 wTotalLength;
	__u8 bNumInterfaces;
	__u8 bConfigurationValue;
	__u8 iConfiguration;
	__u8 bmAttributes;
	__u8 bMaxPower;
} __attribute__((packed));

struct usb_ctrlrequest {
	__u8 bRequestType;
	__u8 bRequest;
	__le16 wValue;
	__le16 wIndex;
	__le16 wLength;
};

struct usb_debug_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDebugInEndpoint;
	__u8 bDebugOutEndpoint;
};

struct usb_descriptor_header {
	__u8 bLength;
	__u8 bDescriptorType;
};

struct usb_dev_cap_header {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDevCapabilityType;
};

struct usb_dev_state {
	struct list_head list;
	struct usb_device *dev;
	struct file *file;
	spinlock_t lock;
	struct list_head async_pending;
	struct list_head async_completed;
	struct list_head memory_list;
	wait_queue_head_t wait;
	wait_queue_head_t wait_for_resume;
	unsigned int discsignr;
	struct pid *disc_pid;
	const struct cred *cred;
	sigval_t disccontext;
	long unsigned int ifclaimed;
	u32 disabled_bulk_eps;
	long unsigned int interface_allowed_mask;
	int not_yet_resumed;
	bool suspend_allowed;
	bool privileges_dropped;
};

struct usb_endpoint_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bEndpointAddress;
	__u8 bmAttributes;
	__le16 wMaxPacketSize;
	__u8 bInterval;
	__u8 bRefresh;
	__u8 bSynchAddress;
} __attribute__((packed));

struct usb_ss_ep_comp_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bMaxBurst;
	__u8 bmAttributes;
	__le16 wBytesPerInterval;
};

struct usb_ssp_isoc_ep_comp_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__le16 wReseved;
	__le32 dwBytesPerInterval;
};

struct usb_host_endpoint {
	struct usb_endpoint_descriptor desc;
	struct usb_ss_ep_comp_descriptor ss_ep_comp;
	struct usb_ssp_isoc_ep_comp_descriptor ssp_isoc_ep_comp;
	long: 0;
	struct list_head urb_list;
	void *hcpriv;
	struct ep_device *ep_dev;
	unsigned char *extra;
	int extralen;
	int enabled;
	int streams;
	long: 0;
} __attribute__((packed));

struct usb_device_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__le16 bcdUSB;
	__u8 bDeviceClass;
	__u8 bDeviceSubClass;
	__u8 bDeviceProtocol;
	__u8 bMaxPacketSize0;
	__le16 idVendor;
	__le16 idProduct;
	__le16 bcdDevice;
	__u8 iManufacturer;
	__u8 iProduct;
	__u8 iSerialNumber;
	__u8 bNumConfigurations;
};

struct usb_host_bos;

struct usb_host_config;

struct usb_device {
	int devnum;
	char devpath[16];
	u32 route;
	enum usb_device_state state;
	enum usb_device_speed speed;
	unsigned int rx_lanes;
	unsigned int tx_lanes;
	enum usb_ssp_rate ssp_rate;
	struct usb_tt *tt;
	int ttport;
	unsigned int toggle[2];
	struct usb_device *parent;
	struct usb_bus *bus;
	struct usb_host_endpoint ep0;
	struct device dev;
	struct usb_device_descriptor descriptor;
	struct usb_host_bos *bos;
	struct usb_host_config *config;
	struct usb_host_config *actconfig;
	struct usb_host_endpoint *ep_in[16];
	struct usb_host_endpoint *ep_out[16];
	char **rawdescriptors;
	short unsigned int bus_mA;
	u8 portnum;
	u8 level;
	u8 devaddr;
	unsigned int can_submit: 1;
	unsigned int persist_enabled: 1;
	unsigned int reset_in_progress: 1;
	unsigned int have_langid: 1;
	unsigned int authorized: 1;
	unsigned int authenticated: 1;
	unsigned int lpm_capable: 1;
	unsigned int lpm_devinit_allow: 1;
	unsigned int usb2_hw_lpm_capable: 1;
	unsigned int usb2_hw_lpm_besl_capable: 1;
	unsigned int usb2_hw_lpm_enabled: 1;
	unsigned int usb2_hw_lpm_allowed: 1;
	unsigned int usb3_lpm_u1_enabled: 1;
	unsigned int usb3_lpm_u2_enabled: 1;
	int string_langid;
	char *product;
	char *manufacturer;
	char *serial;
	struct list_head filelist;
	int maxchild;
	u32 quirks;
	atomic_t urbnum;
	long unsigned int active_duration;
	long unsigned int connect_time;
	unsigned int do_remote_wakeup: 1;
	unsigned int reset_resume: 1;
	unsigned int port_is_suspended: 1;
	enum usb_link_tunnel_mode tunnel_mode;
	int slot_id;
	struct usb2_lpm_parameters l1_params;
	struct usb3_lpm_parameters u1_params;
	struct usb3_lpm_parameters u2_params;
	unsigned int lpm_disable_count;
	u16 hub_delay;
	unsigned int use_generic_driver: 1;
};

struct usb_device_id;

struct usb_device_driver {
	const char *name;
	bool (*match)(struct usb_device *);
	int (*probe)(struct usb_device *);
	void (*disconnect)(struct usb_device *);
	int (*suspend)(struct usb_device *, pm_message_t);
	int (*resume)(struct usb_device *, pm_message_t);
	int (*choose_configuration)(struct usb_device *);
	const struct attribute_group **dev_groups;
	struct device_driver driver;
	const struct usb_device_id *id_table;
	unsigned int supports_autosuspend: 1;
	unsigned int generic_subclass: 1;
};

struct usb_device_id {
	__u16 match_flags;
	__u16 idVendor;
	__u16 idProduct;
	__u16 bcdDevice_lo;
	__u16 bcdDevice_hi;
	__u8 bDeviceClass;
	__u8 bDeviceSubClass;
	__u8 bDeviceProtocol;
	__u8 bInterfaceClass;
	__u8 bInterfaceSubClass;
	__u8 bInterfaceProtocol;
	__u8 bInterfaceNumber;
	kernel_ulong_t driver_info;
};

struct usb_dynids {
	struct list_head list;
};

struct usb_driver {
	const char *name;
	int (*probe)(struct usb_interface *, const struct usb_device_id *);
	void (*disconnect)(struct usb_interface *);
	int (*unlocked_ioctl)(struct usb_interface *, unsigned int, void *);
	int (*suspend)(struct usb_interface *, pm_message_t);
	int (*resume)(struct usb_interface *);
	int (*reset_resume)(struct usb_interface *);
	int (*pre_reset)(struct usb_interface *);
	int (*post_reset)(struct usb_interface *);
	void (*shutdown)(struct usb_interface *);
	const struct usb_device_id *id_table;
	const struct attribute_group **dev_groups;
	struct usb_dynids dynids;
	struct device_driver driver;
	unsigned int no_dynamic_id: 1;
	unsigned int supports_autosuspend: 1;
	unsigned int disable_hub_initiated_lpm: 1;
	unsigned int soft_unbind: 1;
};

struct usb_dynid {
	struct list_head node;
	struct usb_device_id id;
};

struct usb_ext_cap_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDevCapabilityType;
	__le32 bmAttributes;
} __attribute__((packed));

struct usb_phy;

struct usb_phy_roothub;

struct usb_hcd {
	struct usb_bus self;
	struct kref kref;
	const char *product_desc;
	int speed;
	char irq_descr[24];
	struct timer_list rh_timer;
	struct urb *status_urb;
	struct work_struct wakeup_work;
	struct work_struct died_work;
	const struct hc_driver *driver;
	struct usb_phy *usb_phy;
	struct usb_phy_roothub *phy_roothub;
	long unsigned int flags;
	enum usb_dev_authorize_policy dev_policy;
	unsigned int rh_registered: 1;
	unsigned int rh_pollable: 1;
	unsigned int msix_enabled: 1;
	unsigned int msi_enabled: 1;
	unsigned int skip_phy_initialization: 1;
	unsigned int uses_new_polling: 1;
	unsigned int has_tt: 1;
	unsigned int amd_resume_bug: 1;
	unsigned int can_do_streams: 1;
	unsigned int tpl_support: 1;
	unsigned int cant_recv_wakeups: 1;
	unsigned int irq;
	void *regs;
	resource_size_t rsrc_start;
	resource_size_t rsrc_len;
	unsigned int power_budget;
	struct giveback_urb_bh high_prio_bh;
	struct giveback_urb_bh low_prio_bh;
	struct mutex *address0_mutex;
	struct mutex *bandwidth_mutex;
	struct usb_hcd *shared_hcd;
	struct usb_hcd *primary_hcd;
	struct dma_pool *pool[4];
	int state;
	struct gen_pool *localmem_pool;
	long unsigned int hcd_priv[0];
};

struct usb_ss_cap_descriptor;

struct usb_ssp_cap_descriptor;

struct usb_ss_container_id_descriptor;

struct usb_ptm_cap_descriptor;

struct usb_host_bos {
	struct usb_bos_descriptor *desc;
	struct usb_ext_cap_descriptor *ext_cap;
	struct usb_ss_cap_descriptor *ss_cap;
	struct usb_ssp_cap_descriptor *ssp_cap;
	struct usb_ss_container_id_descriptor *ss_id;
	struct usb_ptm_cap_descriptor *ptm_cap;
};

struct usb_interface_assoc_descriptor;

struct usb_interface_cache;

struct usb_host_config {
	struct usb_config_descriptor desc;
	char *string;
	struct usb_interface_assoc_descriptor *intf_assoc[16];
	struct usb_interface *interface[32];
	struct usb_interface_cache *intf_cache[32];
	unsigned char *extra;
	int extralen;
};

struct usb_interface_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bInterfaceNumber;
	__u8 bAlternateSetting;
	__u8 bNumEndpoints;
	__u8 bInterfaceClass;
	__u8 bInterfaceSubClass;
	__u8 bInterfaceProtocol;
	__u8 iInterface;
};

struct usb_host_interface {
	struct usb_interface_descriptor desc;
	int extralen;
	unsigned char *extra;
	struct usb_host_endpoint *endpoint;
	char *string;
};

struct usb_hub_status {
	__le16 wHubStatus;
	__le16 wHubChange;
};

struct usb_port_status {
	__le16 wPortStatus;
	__le16 wPortChange;
	__le32 dwExtPortStatus;
};

struct usb_tt {
	struct usb_device *hub;
	int multi;
	unsigned int think_time;
	void *hcpriv;
	spinlock_t lock;
	struct list_head clear_list;
	struct work_struct clear_work;
};

struct usb_hub_descriptor;

struct usb_port;

struct usb_hub {
	struct device *intfdev;
	struct usb_device *hdev;
	struct kref kref;
	struct urb *urb;
	u8 (*buffer)[8];
	union {
		struct usb_hub_status hub;
		struct usb_port_status port;
	} *status;
	struct mutex status_mutex;
	int error;
	int nerrors;
	long unsigned int event_bits[1];
	long unsigned int change_bits[1];
	long unsigned int removed_bits[1];
	long unsigned int wakeup_bits[1];
	long unsigned int power_bits[1];
	long unsigned int child_usage_bits[1];
	long unsigned int warm_reset_bits[1];
	struct usb_hub_descriptor *descriptor;
	struct usb_tt tt;
	unsigned int mA_per_port;
	unsigned int wakeup_enabled_descendants;
	unsigned int limited_power: 1;
	unsigned int quiescing: 1;
	unsigned int disconnected: 1;
	unsigned int in_reset: 1;
	unsigned int quirk_disable_autosuspend: 1;
	unsigned int quirk_check_port_auto_suspend: 1;
	unsigned int has_indicators: 1;
	u8 indicator[31];
	struct delayed_work leds;
	struct delayed_work init_work;
	struct work_struct events;
	spinlock_t irq_urb_lock;
	struct timer_list irq_urb_retry;
	struct usb_port **ports;
	struct list_head onboard_devs;
};

struct usb_hub_descriptor {
	__u8 bDescLength;
	__u8 bDescriptorType;
	__u8 bNbrPorts;
	__le16 wHubCharacteristics;
	__u8 bPwrOn2PwrGood;
	__u8 bHubContrCurrent;
	union {
		struct {
			__u8 DeviceRemovable[4];
			__u8 PortPwrCtrlMask[4];
		} hs;
		struct {
			__u8 bHubHdrDecLat;
			__le16 wHubDelay;
			__le16 DeviceRemovable;
		} __attribute__((packed)) ss;
	} u;
} __attribute__((packed));

struct usb_interface {
	struct usb_host_interface *altsetting;
	struct usb_host_interface *cur_altsetting;
	unsigned int num_altsetting;
	struct usb_interface_assoc_descriptor *intf_assoc;
	int minor;
	enum usb_interface_condition condition;
	unsigned int sysfs_files_created: 1;
	unsigned int ep_devs_created: 1;
	unsigned int unregistering: 1;
	unsigned int needs_remote_wakeup: 1;
	unsigned int needs_altsetting0: 1;
	unsigned int needs_binding: 1;
	unsigned int resetting_device: 1;
	unsigned int authorized: 1;
	enum usb_wireless_status wireless_status;
	struct work_struct wireless_status_work;
	struct device dev;
	struct device *usb_dev;
	struct work_struct reset_ws;
};

struct usb_interface_assoc_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bFirstInterface;
	__u8 bInterfaceCount;
	__u8 bFunctionClass;
	__u8 bFunctionSubClass;
	__u8 bFunctionProtocol;
	__u8 iFunction;
};

struct usb_interface_cache {
	unsigned int num_altsetting;
	struct kref ref;
	struct usb_host_interface altsetting[0];
};

struct usb_memory {
	struct list_head memlist;
	int vma_use_count;
	int urb_use_count;
	u32 size;
	void *mem;
	dma_addr_t dma_handle;
	long unsigned int vm_start;
	struct usb_dev_state *ps;
};

struct usb_mon_operations {
	void (*urb_submit)(struct usb_bus *, struct urb *);
	void (*urb_submit_error)(struct usb_bus *, struct urb *, int);
	void (*urb_complete)(struct usb_bus *, struct urb *, int);
};

struct usb_gadget;

struct usb_otg {
	u8 default_a;
	struct phy___3 *phy;
	struct usb_phy *usb_phy;
	struct usb_bus *host;
	struct usb_gadget *gadget;
	enum usb_otg_state state;
	int (*set_host)(struct usb_otg *, struct usb_bus *);
	int (*set_peripheral)(struct usb_otg *, struct usb_gadget *);
	int (*set_vbus)(struct usb_otg *, bool);
	int (*start_srp)(struct usb_otg *);
	int (*start_hnp)(struct usb_otg *);
};

struct extcon_dev;

struct usb_phy_io_ops;

struct usb_phy {
	struct device *dev;
	const char *label;
	unsigned int flags;
	enum usb_phy_type type;
	enum usb_phy_events last_event;
	struct usb_otg *otg;
	struct device *io_dev;
	struct usb_phy_io_ops *io_ops;
	void *io_priv;
	struct extcon_dev *edev;
	struct extcon_dev *id_edev;
	struct notifier_block vbus_nb;
	struct notifier_block id_nb;
	struct notifier_block type_nb;
	enum usb_charger_type chg_type;
	enum usb_charger_state chg_state;
	struct usb_charger_current chg_cur;
	struct work_struct chg_work;
	struct atomic_notifier_head notifier;
	u16 port_status;
	u16 port_change;
	struct list_head head;
	int (*init)(struct usb_phy *);
	void (*shutdown)(struct usb_phy *);
	int (*set_vbus)(struct usb_phy *, int);
	int (*set_power)(struct usb_phy *, unsigned int);
	int (*set_suspend)(struct usb_phy *, int);
	int (*set_wakeup)(struct usb_phy *, bool);
	int (*notify_connect)(struct usb_phy *, enum usb_device_speed);
	int (*notify_disconnect)(struct usb_phy *, enum usb_device_speed);
	enum usb_charger_type (*charger_detect)(struct usb_phy *);
};

struct usb_phy_io_ops {
	int (*read)(struct usb_phy *, u32);
	int (*write)(struct usb_phy *, u32, u32);
};

struct usb_phy_roothub {
	struct phy___3 *phy;
	struct list_head list;
};

struct usb_port {
	struct usb_device *child;
	struct device dev;
	struct usb_dev_state *port_owner;
	struct usb_port *peer;
	struct typec_connector *connector;
	struct dev_pm_qos_request *req;
	enum usb_port_connect_type connect_type;
	enum usb_device_state state;
	struct kernfs_node *state_kn;
	usb_port_location_t location;
	struct mutex status_lock;
	u32 over_current_count;
	u8 portnum;
	u32 quirks;
	unsigned int early_stop: 1;
	unsigned int ignore_event: 1;
	unsigned int is_superspeed: 1;
	unsigned int usb3_lpm_u1_permit: 1;
	unsigned int usb3_lpm_u2_permit: 1;
};

struct usb_ptm_cap_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDevCapabilityType;
};

struct usb_qualifier_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__le16 bcdUSB;
	__u8 bDeviceClass;
	__u8 bDeviceSubClass;
	__u8 bDeviceProtocol;
	__u8 bMaxPacketSize0;
	__u8 bNumConfigurations;
	__u8 bRESERVED;
};

struct usb_set_sel_req {
	__u8 u1_sel;
	__u8 u1_pel;
	__le16 u2_sel;
	__le16 u2_pel;
};

struct usb_ss_cap_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDevCapabilityType;
	__u8 bmAttributes;
	__le16 wSpeedSupported;
	__u8 bFunctionalitySupport;
	__u8 bU1devExitLat;
	__le16 bU2DevExitLat;
};

struct usb_ss_container_id_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDevCapabilityType;
	__u8 bReserved;
	__u8 ContainerID[16];
};

struct usb_ssp_cap_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDevCapabilityType;
	__u8 bReserved;
	__le32 bmAttributes;
	__le16 wFunctionalitySupport;
	__le16 wReserved;
	union {
		__le32 legacy_padding;
		struct {
			struct {} __empty_bmSublinkSpeedAttr;
			__le32 bmSublinkSpeedAttr[0];
		};
	};
};

struct usb_tt_clear {
	struct list_head clear_list;
	unsigned int tt;
	u16 devinfo;
	struct usb_hcd *hcd;
	struct usb_host_endpoint *ep;
};

struct usbdevfs_bulktransfer {
	unsigned int ep;
	unsigned int len;
	unsigned int timeout;
	void *data;
};

struct usbdevfs_bulktransfer32 {
	compat_uint_t ep;
	compat_uint_t len;
	compat_uint_t timeout;
	compat_caddr_t data;
};

struct usbdevfs_connectinfo {
	unsigned int devnum;
	unsigned char slow;
};

struct usbdevfs_conninfo_ex {
	__u32 size;
	__u32 busnum;
	__u32 devnum;
	__u32 speed;
	__u8 num_ports;
	__u8 ports[7];
};

struct usbdevfs_ctrltransfer {
	__u8 bRequestType;
	__u8 bRequest;
	__u16 wValue;
	__u16 wIndex;
	__u16 wLength;
	__u32 timeout;
	void *data;
};

struct usbdevfs_ctrltransfer32 {
	u8 bRequestType;
	u8 bRequest;
	u16 wValue;
	u16 wIndex;
	u16 wLength;
	u32 timeout;
	compat_caddr_t data;
};

struct usbdevfs_disconnect_claim {
	unsigned int interface;
	unsigned int flags;
	char driver[256];
};

struct usbdevfs_disconnectsignal {
	unsigned int signr;
	void *context;
};

struct usbdevfs_disconnectsignal32 {
	compat_int_t signr;
	compat_caddr_t context;
};

struct usbdevfs_getdriver {
	unsigned int interface;
	char driver[256];
};

struct usbdevfs_hub_portinfo {
	char nports;
	char port[127];
};

struct usbdevfs_ioctl {
	int ifno;
	int ioctl_code;
	void *data;
};

struct usbdevfs_ioctl32 {
	s32 ifno;
	s32 ioctl_code;
	compat_caddr_t data;
};

struct usbdevfs_iso_packet_desc {
	unsigned int length;
	unsigned int actual_length;
	unsigned int status;
};

struct usbdevfs_setinterface {
	unsigned int interface;
	unsigned int altsetting;
};

struct usbdevfs_streams {
	unsigned int num_streams;
	unsigned int num_eps;
	unsigned char eps[0];
};

struct usbdevfs_urb {
	unsigned char type;
	unsigned char endpoint;
	int status;
	unsigned int flags;
	void *buffer;
	int buffer_length;
	int actual_length;
	int start_frame;
	union {
		int number_of_packets;
		unsigned int stream_id;
	};
	int error_count;
	unsigned int signr;
	void *usercontext;
	struct usbdevfs_iso_packet_desc iso_frame_desc[0];
};

struct usbdevfs_urb32 {
	unsigned char type;
	unsigned char endpoint;
	compat_int_t status;
	compat_uint_t flags;
	compat_caddr_t buffer;
	compat_int_t buffer_length;
	compat_int_t actual_length;
	compat_int_t start_frame;
	compat_int_t number_of_packets;
	compat_int_t error_count;
	compat_uint_t signr;
	compat_caddr_t usercontext;
	struct usbdevfs_iso_packet_desc iso_frame_desc[0];
};

struct usbhid_device {
	struct hid_device *hid;
	struct usb_interface *intf;
	int ifnum;
	unsigned int bufsize;
	struct urb *urbin;
	char *inbuf;
	dma_addr_t inbuf_dma;
	struct urb *urbctrl;
	struct usb_ctrlrequest *cr;
	struct hid_control_fifo ctrl[256];
	unsigned char ctrlhead;
	unsigned char ctrltail;
	char *ctrlbuf;
	dma_addr_t ctrlbuf_dma;
	long unsigned int last_ctrl;
	struct urb *urbout;
	struct hid_output_fifo out[256];
	unsigned char outhead;
	unsigned char outtail;
	char *outbuf;
	dma_addr_t outbuf_dma;
	long unsigned int last_out;
	struct mutex mutex;
	spinlock_t lock;
	long unsigned int iofl;
	struct timer_list io_retry;
	long unsigned int stop_retry;
	unsigned int retry_delay;
	struct work_struct reset_work;
	wait_queue_head_t wait;
};

struct usblp {
	struct usb_device *dev;
	struct mutex wmut;
	struct mutex mut;
	spinlock_t lock;
	char *readbuf;
	char *statusbuf;
	struct usb_anchor urbs;
	wait_queue_head_t rwait;
	wait_queue_head_t wwait;
	int readcount;
	int ifnum;
	struct usb_interface *intf;
	struct {
		int alt_setting;
		struct usb_endpoint_descriptor *epwrite;
		struct usb_endpoint_descriptor *epread;
	} protocol[4];
	int current_protocol;
	int minor;
	int wcomplete;
	int rcomplete;
	int wstatus;
	int rstatus;
	unsigned int quirks;
	unsigned int flags;
	unsigned char used;
	unsigned char present;
	unsigned char bidir;
	unsigned char no_paper;
	unsigned char *device_id_string;
};

struct used_address {
	struct __kernel_sockaddr_storage name;
	unsigned int name_len;
};

struct user_arg_ptr {
	bool is_compat;
	union {
		const char * const *native;
		const compat_uptr_t *compat;
	} ptr;
};

struct user_datum {
	u32 value;
	u32 bounds;
	struct ebitmap roles;
	struct mls_range range;
	struct mls_level dfltlevel;
};

struct user_desc {
	unsigned int entry_number;
	unsigned int base_addr;
	unsigned int limit;
	unsigned int seg_32bit: 1;
	unsigned int contents: 2;
	unsigned int read_exec_only: 1;
	unsigned int limit_in_pages: 1;
	unsigned int seg_not_present: 1;
	unsigned int useable: 1;
	unsigned int lm: 1;
};

struct user_element {
	struct snd_ctl_elem_info info;
	struct snd_card *card;
	char *elem_data;
	long unsigned int elem_data_size;
	void *tlv_data;
	long unsigned int tlv_data_size;
	void *priv_data;
};

struct user_i387_ia32_struct {
	u32 cwd;
	u32 swd;
	u32 twd;
	u32 fip;
	u32 fcs;
	u32 foo;
	u32 fos;
	u32 st_space[20];
};

struct user_key_payload {
	struct callback_head rcu;
	short unsigned int datalen;
	long: 0;
	char data[0];
};

struct user_namespace {
	struct uid_gid_map uid_map;
	struct uid_gid_map gid_map;
	struct uid_gid_map projid_map;
	struct user_namespace *parent;
	int level;
	kuid_t owner;
	kgid_t group;
	struct ns_common ns;
	long unsigned int flags;
	bool parent_could_setfcap;
	struct list_head keyring_name_list;
	struct key *user_keyring_register;
	struct rw_semaphore keyring_sem;
	struct work_struct work;
	struct ctl_table_set set;
	struct ctl_table_header *sysctls;
	struct ucounts *ucounts;
	long int ucount_max[10];
	long int rlimit_max[4];
	struct binfmt_misc *binfmt_misc;
};

struct user_regset;

typedef int user_regset_get2_fn(struct task_struct *, const struct user_regset *, struct membuf);

typedef int user_regset_set_fn(struct task_struct *, const struct user_regset *, unsigned int, unsigned int, const void *, const void *);

typedef int user_regset_active_fn(struct task_struct *, const struct user_regset *);

typedef int user_regset_writeback_fn(struct task_struct *, const struct user_regset *, int);

struct user_regset {
	user_regset_get2_fn *regset_get;
	user_regset_set_fn *set;
	user_regset_active_fn *active;
	user_regset_writeback_fn *writeback;
	unsigned int n;
	unsigned int size;
	unsigned int align;
	unsigned int bias;
	unsigned int core_note_type;
};

struct user_regset_view {
	const char *name;
	const struct user_regset *regsets;
	unsigned int n;
	u32 e_flags;
	u16 e_machine;
	u8 ei_osabi;
};

struct user_struct {
	refcount_t __count;
	struct percpu_counter epoll_watches;
	long unsigned int unix_inflight;
	atomic_long_t pipe_bufs;
	struct hlist_node uidhash_node;
	kuid_t uid;
	atomic_long_t locked_vm;
	struct ratelimit_state ratelimit;
};

struct user_threshold {
	struct list_head list_node;
	int temperature;
	int direction;
};

struct userspace_policy {
	unsigned int is_managed;
	unsigned int setspeed;
	struct mutex mutex;
};

struct userstack_entry {
	struct trace_entry ent;
	unsigned int tgid;
	long unsigned int caller[8];
};

struct ustat {
	__kernel_daddr_t f_tfree;
	long unsigned int f_tinode;
	char f_fname[6];
	char f_fpack[6];
};

struct ustring_buffer {
	char buffer[1024];
};

struct utf8_table {
	int cmask;
	int cval;
	int shift;
	long int lmask;
	long int lval;
};

struct utimbuf {
	__kernel_old_time_t actime;
	__kernel_old_time_t modtime;
};

struct uts_namespace {
	struct new_utsname name;
	struct user_namespace *user_ns;
	struct ucounts *ucounts;
	struct ns_common ns;
};

union uu {
	short unsigned int us;
	unsigned char b[2];
};

struct uuidcmp {
	const char *uuid;
	int len;
};

struct v2_disk_dqheader {
	__le32 dqh_magic;
	__le32 dqh_version;
};

struct v2_disk_dqinfo {
	__le32 dqi_bgrace;
	__le32 dqi_igrace;
	__le32 dqi_flags;
	__le32 dqi_blocks;
	__le32 dqi_free_blk;
	__le32 dqi_free_entry;
};

struct v2r0_disk_dqblk {
	__le32 dqb_id;
	__le32 dqb_ihardlimit;
	__le32 dqb_isoftlimit;
	__le32 dqb_curinodes;
	__le32 dqb_bhardlimit;
	__le32 dqb_bsoftlimit;
	__le64 dqb_curspace;
	__le64 dqb_btime;
	__le64 dqb_itime;
};

struct v2r1_disk_dqblk {
	__le32 dqb_id;
	__le32 dqb_pad;
	__le64 dqb_ihardlimit;
	__le64 dqb_isoftlimit;
	__le64 dqb_curinodes;
	__le64 dqb_bhardlimit;
	__le64 dqb_bsoftlimit;
	__le64 dqb_curspace;
	__le64 dqb_btime;
	__le64 dqb_itime;
};

struct v9fs_inode {
	struct netfs_inode netfs;
	struct p9_qid qid;
	unsigned int cache_validity;
	struct mutex v_mutex;
};

struct v9fs_session_info {
	unsigned int flags;
	unsigned char nodev;
	short unsigned int debug;
	unsigned int afid;
	unsigned int cache;
	char *uname;
	char *aname;
	unsigned int maxdata;
	kuid_t dfltuid;
	kgid_t dfltgid;
	kuid_t uid;
	struct p9_client *clnt;
	struct list_head slist;
	struct rw_semaphore rename_sem;
	long int session_lock_timeout;
};

struct va_alignment {
	int flags;
	long unsigned int mask;
	long unsigned int bits;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct va_format {
	const char *fmt;
	va_list *va;
};

struct value_name_pair {
	int value;
	const char *name;
};

struct var_mtrr_range_state {
	long unsigned int base_pfn;
	long unsigned int size_pfn;
	mtrr_type type;
};

struct vbt_header {
	u8 signature[20];
	u16 version;
	u16 header_size;
	u16 vbt_size;
	u8 vbt_checksum;
	u8 reserved0;
	u32 bdb_offset;
	u32 aim_offset[4];
};

struct vc {
	struct vc_data *d;
	struct work_struct SAK_work;
};

struct vc_state {
	unsigned int x;
	unsigned int y;
	unsigned char color;
	unsigned char Gx_charset[2];
	unsigned int charset: 1;
	enum vc_intensity intensity;
	bool italic;
	bool underline;
	bool blink;
	bool reverse;
};

struct vt_mode {
	char mode;
	char waitv;
	short int relsig;
	short int acqsig;
	short int frsig;
};

struct vc_data {
	struct tty_port port;
	struct vc_state state;
	struct vc_state saved_state;
	short unsigned int vc_num;
	unsigned int vc_cols;
	unsigned int vc_rows;
	unsigned int vc_size_row;
	unsigned int vc_scan_lines;
	unsigned int vc_cell_height;
	long unsigned int vc_origin;
	long unsigned int vc_scr_end;
	long unsigned int vc_visible_origin;
	unsigned int vc_top;
	unsigned int vc_bottom;
	const struct consw *vc_sw;
	short unsigned int *vc_screenbuf;
	unsigned int vc_screenbuf_size;
	unsigned char vc_mode;
	unsigned char vc_attr;
	unsigned char vc_def_color;
	unsigned char vc_ulcolor;
	unsigned char vc_itcolor;
	unsigned char vc_halfcolor;
	unsigned int vc_cursor_type;
	short unsigned int vc_complement_mask;
	short unsigned int vc_s_complement_mask;
	long unsigned int vc_pos;
	short unsigned int vc_hi_font_mask;
	struct console_font vc_font;
	short unsigned int vc_video_erase_char;
	unsigned int vc_state;
	unsigned int vc_npar;
	unsigned int vc_par[16];
	struct vt_mode vt_mode;
	struct pid *vt_pid;
	int vt_newvt;
	wait_queue_head_t paste_wait;
	unsigned int vc_disp_ctrl: 1;
	unsigned int vc_toggle_meta: 1;
	unsigned int vc_decscnm: 1;
	unsigned int vc_decom: 1;
	unsigned int vc_decawm: 1;
	unsigned int vc_deccm: 1;
	unsigned int vc_decim: 1;
	unsigned int vc_priv: 3;
	unsigned int vc_need_wrap: 1;
	unsigned int vc_can_do_color: 1;
	unsigned int vc_report_mouse: 2;
	unsigned char vc_utf: 1;
	unsigned char vc_utf_count;
	int vc_utf_char;
	long unsigned int vc_tab_stop[4];
	unsigned char vc_palette[48];
	short unsigned int *vc_translate;
	unsigned int vc_bell_pitch;
	unsigned int vc_bell_duration;
	short unsigned int vc_cur_blink_ms;
	struct vc_data **vc_display_fg;
	struct uni_pagedict *uni_pagedict;
	struct uni_pagedict **uni_pagedict_loc;
	u32 **vc_uni_lines;
};

struct vc_draw_region {
	long unsigned int from;
	long unsigned int to;
	int x;
};

struct vc_selection {
	struct mutex lock;
	struct vc_data *cons;
	char *buffer;
	unsigned int buf_len;
	volatile int start;
	int end;
};

struct vcs_poll_data {
	struct notifier_block notifier;
	unsigned int cons_num;
	int event;
	wait_queue_head_t waitq;
	struct fasync_struct *fasync;
};

struct vdso_timestamp {
	u64 sec;
	u64 nsec;
};

struct vdso_data {
	u32 seq;
	s32 clock_mode;
	u64 cycle_last;
	u64 max_cycles;
	u64 mask;
	u32 mult;
	u32 shift;
	union {
		struct vdso_timestamp basetime[12];
		struct timens_offset offset[12];
	};
	s32 tz_minuteswest;
	s32 tz_dsttime;
	u32 hrtimer_res;
	u32 __unused;
	struct arch_vdso_time_data arch_data;
};

union vdso_data_store {
	struct vdso_data data[2];
	u8 page[4096];
};

struct vdso_exception_table_entry {
	int insn;
	int fixup;
};

struct vdso_image {
	void *data;
	long unsigned int size;
	long unsigned int alt;
	long unsigned int alt_len;
	long unsigned int extable_base;
	long unsigned int extable_len;
	const void *extable;
	long int sym_vvar_start;
	long int sym_vvar_page;
	long int sym_pvclock_page;
	long int sym_hvclock_page;
	long int sym_timens_page;
	long int sym_VDSO32_NOTE_MASK;
	long int sym___kernel_sigreturn;
	long int sym___kernel_rt_sigreturn;
	long int sym___kernel_vsyscall;
	long int sym_int80_landing_pad;
	long int sym_vdso32_sigreturn_landing_pad;
	long int sym_vdso32_rt_sigreturn_landing_pad;
};

struct vdso_rng_data {
	u64 generation;
	u8 is_ready;
};

struct ve_node {
	struct rb_node rb;
	int prio;
};

struct vector_cleanup {
	struct hlist_head head;
	struct timer_list timer;
};

struct vers_iter {
	size_t param_size;
	struct dm_target_versions *vers;
	struct dm_target_versions *old_vers;
	char *end;
	uint32_t flags;
};

struct vfree_deferred {
	struct llist_head list;
	struct work_struct wq;
};

struct vfs_cap_data {
	__le32 magic_etc;
	struct {
		__le32 permitted;
		__le32 inheritable;
	} data[2];
};

struct vfs_ns_cap_data {
	__le32 magic_etc;
	struct {
		__le32 permitted;
		__le32 inheritable;
	} data[2];
	__le32 rootid;
};

struct vga_arb_user_card {
	struct pci_dev *pdev;
	unsigned int mem_cnt;
	unsigned int io_cnt;
};

struct vga_arb_private {
	struct list_head list;
	struct pci_dev *target;
	struct vga_arb_user_card cards[16];
	spinlock_t lock;
};

struct vga_device {
	struct list_head list;
	struct pci_dev *pdev;
	unsigned int decodes;
	unsigned int owns;
	unsigned int locks;
	unsigned int io_lock_cnt;
	unsigned int mem_lock_cnt;
	unsigned int io_norm_cnt;
	unsigned int mem_norm_cnt;
	bool bridge_has_one_vga;
	bool is_firmware_default;
	unsigned int (*set_decode)(struct pci_dev *, bool);
};

struct vga_switcheroo_client_ops {
	void (*set_gpu_state)(struct pci_dev *, enum vga_switcheroo_state);
	void (*reprobe)(struct pci_dev *);
	bool (*can_switch)(struct pci_dev *);
	void (*gpu_bound)(struct pci_dev *, enum vga_switcheroo_client_id);
};

struct vgastate {
	void *vgabase;
	long unsigned int membase;
	__u32 memsize;
	__u32 flags;
	__u32 depth;
	__u32 num_attr;
	__u32 num_crtc;
	__u32 num_gfx;
	__u32 num_seq;
	void *vidstate;
};

struct video_levels {
	u16 blank;
	u16 black;
	u8 burst;
};

struct vif_entry_notifier_info {
	struct fib_notifier_info info;
	struct net_device *dev;
	short unsigned int vif_index;
	short unsigned int vif_flags;
	u32 tb_id;
};

struct vif_params {
	u32 flags;
	int use_4addr;
	u8 macaddr[6];
	const u8 *vht_mumimo_groups;
	const u8 *vht_mumimo_follow_addr;
};

struct vifctl {
	vifi_t vifc_vifi;
	unsigned char vifc_flags;
	unsigned char vifc_threshold;
	unsigned int vifc_rate_limit;
	union {
		struct in_addr vifc_lcl_addr;
		int vifc_lcl_ifindex;
	};
	struct in_addr vifc_rmt_addr;
};

struct virtio_blk_outhdr {
	__virtio32 type;
	__virtio32 ioprio;
	__virtio64 sector;
};

struct virtblk_req {
	struct virtio_blk_outhdr out_hdr;
	union {
		u8 status;
		struct {
			__virtio64 sector;
			u8 status;
		} zone_append;
	} in_hdr;
	size_t in_hdr_len;
	struct sg_table sg_table;
	struct scatterlist sg[0];
};

struct virtio_9p_config {
	__virtio16 tag_len;
	__u8 tag[0];
};

struct virtio_admin_cmd {
	__le16 opcode;
	__le16 group_type;
	__le64 group_member_id;
	struct scatterlist *data_sg;
	struct scatterlist *result_sg;
	struct completion completion;
	u32 result_sg_size;
	int ret;
};

struct virtio_admin_cmd_cap_get_data {
	__le16 id;
	__u8 reserved[6];
};

struct virtio_admin_cmd_cap_set_data {
	__le16 id;
	__u8 reserved[6];
	__u8 cap_specific_data[0];
};

struct virtio_admin_cmd_dev_mode_set_data {
	__u8 flags;
};

struct virtio_admin_cmd_resource_obj_cmd_hdr {
	__le16 type;
	__u8 reserved[2];
	__le32 id;
};

struct virtio_dev_part_hdr {
	__le16 part_type;
	__u8 flags;
	__u8 reserved;
	union {
		struct {
			__le32 offset;
			__le32 reserved;
		} pci_common_cfg;
		struct {
			__le16 index;
			__u8 reserved[6];
		} vq_index;
	} selector;
	__le32 length;
};

struct virtio_admin_cmd_dev_parts_get_data {
	struct virtio_admin_cmd_resource_obj_cmd_hdr hdr;
	__u8 type;
	__u8 reserved[7];
	struct virtio_dev_part_hdr hdr_list[0];
};

struct virtio_admin_cmd_dev_parts_metadata_data {
	struct virtio_admin_cmd_resource_obj_cmd_hdr hdr;
	__u8 type;
	__u8 reserved[7];
};

struct virtio_admin_cmd_dev_parts_metadata_result {
	union {
		struct {
			__le32 size;
			__le32 reserved;
		} parts_size;
		struct {
			__le32 count;
			__le32 reserved;
		} hdr_list_count;
		struct {
			__le32 count;
			__le32 reserved;
			struct virtio_dev_part_hdr hdrs[0];
		} hdr_list;
	};
};

struct virtio_admin_cmd_hdr {
	__le16 opcode;
	__le16 group_type;
	__u8 reserved1[12];
	__le64 group_member_id;
};

struct virtio_admin_cmd_legacy_rd_data {
	__u8 offset;
};

struct virtio_admin_cmd_legacy_wr_data {
	__u8 offset;
	__u8 reserved[7];
	__u8 registers[0];
};

struct virtio_admin_cmd_notify_info_data {
	__u8 flags;
	__u8 bar;
	__u8 padding[6];
	__le64 offset;
};

struct virtio_admin_cmd_notify_info_result {
	struct virtio_admin_cmd_notify_info_data entries[4];
};

struct virtio_admin_cmd_query_cap_id_result {
	__le64 supported_caps[1];
};

struct virtio_admin_cmd_resource_obj_create_data {
	struct virtio_admin_cmd_resource_obj_cmd_hdr hdr;
	__le64 flags;
	__u8 resource_obj_specific_data[0];
};

struct virtio_admin_cmd_status {
	__le16 status;
	__le16 status_qualifier;
	__u8 reserved2[4];
};

struct virtio_blk_vq;

struct virtio_blk {
	struct mutex vdev_mutex;
	struct virtio_device *vdev;
	struct gendisk *disk;
	struct blk_mq_tag_set tag_set;
	struct work_struct config_work;
	int index;
	int num_vqs;
	int io_queues[3];
	struct virtio_blk_vq *vqs;
	unsigned int zone_sectors;
};

struct virtio_blk_geometry {
	__virtio16 cylinders;
	__u8 heads;
	__u8 sectors;
};

struct virtio_blk_zoned_characteristics {
	__virtio32 zone_sectors;
	__virtio32 max_open_zones;
	__virtio32 max_active_zones;
	__virtio32 max_append_sectors;
	__virtio32 write_granularity;
	__u8 model;
	__u8 unused2[3];
};

struct virtio_blk_config {
	__virtio64 capacity;
	__virtio32 size_max;
	__virtio32 seg_max;
	struct virtio_blk_geometry geometry;
	__virtio32 blk_size;
	__u8 physical_block_exp;
	__u8 alignment_offset;
	__virtio16 min_io_size;
	__virtio32 opt_io_size;
	__u8 wce;
	__u8 unused;
	__virtio16 num_queues;
	__virtio32 max_discard_sectors;
	__virtio32 max_discard_seg;
	__virtio32 discard_sector_alignment;
	__virtio32 max_write_zeroes_sectors;
	__virtio32 max_write_zeroes_seg;
	__u8 write_zeroes_may_unmap;
	__u8 unused1[3];
	__virtio32 max_secure_erase_sectors;
	__virtio32 max_secure_erase_seg;
	__virtio32 secure_erase_sector_alignment;
	struct virtio_blk_zoned_characteristics zoned;
};

struct virtio_blk_discard_write_zeroes {
	__le64 sector;
	__le32 num_sectors;
	__le32 flags;
};

struct virtio_blk_vq {
	struct virtqueue *vq;
	spinlock_t lock;
	char name[16];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct virtio_chan {
	bool inuse;
	spinlock_t lock;
	struct p9_client *client;
	struct virtio_device *vdev;
	struct virtqueue *vq;
	int ring_bufs_avail;
	wait_queue_head_t *vc_wq;
	long unsigned int p9_max_pages;
	struct scatterlist sg[128];
	char *tag;
	struct list_head chan_list;
};

struct virtqueue_info;

struct virtio_shm_region;

struct virtio_config_ops {
	void (*get)(struct virtio_device *, unsigned int, void *, unsigned int);
	void (*set)(struct virtio_device *, unsigned int, const void *, unsigned int);
	u32 (*generation)(struct virtio_device *);
	u8 (*get_status)(struct virtio_device *);
	void (*set_status)(struct virtio_device *, u8);
	void (*reset)(struct virtio_device *);
	int (*find_vqs)(struct virtio_device *, unsigned int, struct virtqueue **, struct virtqueue_info *, struct irq_affinity *);
	void (*del_vqs)(struct virtio_device *);
	void (*synchronize_cbs)(struct virtio_device *);
	u64 (*get_features)(struct virtio_device *);
	int (*finalize_features)(struct virtio_device *);
	const char * (*bus_name)(struct virtio_device *);
	int (*set_vq_affinity)(struct virtqueue *, const struct cpumask *);
	const struct cpumask * (*get_vq_affinity)(struct virtio_device *, int);
	bool (*get_shm_region)(struct virtio_device *, struct virtio_shm_region *, u8);
	int (*disable_vq_and_reset)(struct virtqueue *);
	int (*enable_vq_after_reset)(struct virtqueue *);
};

struct virtio_console_config {
	__virtio16 cols;
	__virtio16 rows;
	__virtio32 max_nr_ports;
	__virtio32 emerg_wr;
};

struct virtio_dev_parts_cap {
	__u8 get_parts_resource_objects_limit;
	__u8 set_parts_resource_objects_limit;
};

struct virtio_device_id {
	__u32 device;
	__u32 vendor;
};

struct vringh_config_ops;

struct virtio_device {
	int index;
	bool failed;
	bool config_core_enabled;
	bool config_driver_disabled;
	bool config_change_pending;
	spinlock_t config_lock;
	spinlock_t vqs_list_lock;
	struct device dev;
	struct virtio_device_id id;
	const struct virtio_config_ops *config;
	const struct vringh_config_ops *vringh_config;
	struct list_head vqs;
	u64 features;
	void *priv;
};

struct virtio_dma_buf_ops {
	struct dma_buf_ops ops;
	int (*device_attach)(struct dma_buf *, struct dma_buf_attachment *);
	int (*get_uuid)(struct dma_buf *, uuid_t *);
};

struct virtio_driver {
	struct device_driver driver;
	const struct virtio_device_id *id_table;
	const unsigned int *feature_table;
	unsigned int feature_table_size;
	const unsigned int *feature_table_legacy;
	unsigned int feature_table_size_legacy;
	int (*validate)(struct virtio_device *);
	int (*probe)(struct virtio_device *);
	void (*scan)(struct virtio_device *);
	void (*remove)(struct virtio_device *);
	void (*config_changed)(struct virtio_device *);
	int (*freeze)(struct virtio_device *);
	int (*restore)(struct virtio_device *);
	int (*reset_prepare)(struct virtio_device *);
	int (*reset_done)(struct virtio_device *);
};

struct virtio_gpu_box {
	__le32 x;
	__le32 y;
	__le32 z;
	__le32 w;
	__le32 h;
	__le32 d;
};

struct virtio_gpu_ctrl_hdr {
	__le32 type;
	__le32 flags;
	__le64 fence_id;
	__le32 ctx_id;
	__u8 ring_idx;
	__u8 padding[3];
};

struct virtio_gpu_cmd_get_edid {
	struct virtio_gpu_ctrl_hdr hdr;
	__le32 scanout;
	__le32 padding;
};

struct virtio_gpu_cmd_submit {
	struct virtio_gpu_ctrl_hdr hdr;
	__le32 size;
	__le32 padding;
};

struct virtio_gpu_config {
	__le32 events_read;
	__le32 events_clear;
	__le32 num_scanouts;
	__le32 num_capsets;
};

struct virtio_gpu_ctx_create {
	struct virtio_gpu_ctrl_hdr hdr;
	__le32 nlen;
	__le32 context_init;
	char debug_name[64];
};

struct virtio_gpu_ctx_destroy {
	struct virtio_gpu_ctrl_hdr hdr;
};

struct virtio_gpu_ctx_resource {
	struct virtio_gpu_ctrl_hdr hdr;
	__le32 resource_id;
	__le32 padding;
};

struct virtio_gpu_cursor_pos {
	__le32 scanout_id;
	__le32 x;
	__le32 y;
	__le32 padding;
};

struct virtio_gpu_rect {
	__le32 x;
	__le32 y;
	__le32 width;
	__le32 height;
};

struct virtio_gpu_display_one {
	struct virtio_gpu_rect r;
	__le32 enabled;
	__le32 flags;
};

struct virtio_gpu_update_cursor {
	struct virtio_gpu_ctrl_hdr hdr;
	struct virtio_gpu_cursor_pos pos;
	__le32 resource_id;
	__le32 hot_x;
	__le32 hot_y;
	__le32 padding;
};

struct virtio_gpu_output {
	int index;
	struct drm_crtc crtc;
	struct drm_connector conn;
	struct drm_encoder enc;
	struct virtio_gpu_display_one info;
	struct virtio_gpu_update_cursor cursor;
	const struct drm_edid *drm_edid;
	int cur_x;
	int cur_y;
	bool needs_modeset;
};

struct virtio_gpu_queue {
	struct virtqueue *vq;
	spinlock_t qlock;
	wait_queue_head_t ack_queue;
	struct work_struct dequeue_work;
	uint32_t seqno;
};

struct virtio_gpu_fence_driver {
	atomic64_t last_fence_id;
	uint64_t current_fence_id;
	uint64_t context;
	struct list_head fences;
	spinlock_t lock;
};

struct virtio_shm_region {
	u64 addr;
	u64 len;
};

struct virtio_gpu_drv_capset;

struct virtio_gpu_device {
	struct drm_device *ddev;
	struct virtio_device *vdev;
	struct virtio_gpu_output outputs[16];
	uint32_t num_scanouts;
	struct virtio_gpu_queue ctrlq;
	struct virtio_gpu_queue cursorq;
	struct kmem_cache *vbufs;
	atomic_t pending_commands;
	struct ida resource_ida;
	wait_queue_head_t resp_wq;
	spinlock_t display_info_lock;
	bool display_info_pending;
	struct virtio_gpu_fence_driver fence_drv;
	struct ida ctx_id_ida;
	bool has_virgl_3d;
	bool has_edid;
	bool has_indirect;
	bool has_resource_assign_uuid;
	bool has_resource_blob;
	bool has_host_visible;
	bool has_context_init;
	struct virtio_shm_region host_visible_region;
	struct drm_mm host_visible_mm;
	struct work_struct config_changed_work;
	struct work_struct obj_free_work;
	spinlock_t obj_free_lock;
	struct list_head obj_free_list;
	struct virtio_gpu_drv_capset *capsets;
	uint32_t num_capsets;
	uint64_t capset_id_mask;
	struct list_head cap_cache;
	spinlock_t resource_export_lock;
	spinlock_t host_visible_lock;
};

struct virtio_gpu_drv_cap_cache {
	struct list_head head;
	void *caps_cache;
	uint32_t id;
	uint32_t version;
	uint32_t size;
	atomic_t is_valid;
};

struct virtio_gpu_drv_capset {
	uint32_t id;
	uint32_t max_version;
	uint32_t max_size;
};

struct virtio_gpu_fence_event;

struct virtio_gpu_fence {
	struct dma_fence f;
	uint32_t ring_idx;
	uint64_t fence_id;
	bool emit_fence_info;
	struct virtio_gpu_fence_event *e;
	struct virtio_gpu_fence_driver *drv;
	struct list_head node;
};

struct virtio_gpu_fence_event {
	struct drm_pending_event base;
	struct drm_event event;
};

struct virtio_gpu_fpriv {
	uint32_t ctx_id;
	uint32_t context_init;
	bool context_created;
	uint32_t num_rings;
	uint64_t base_fence_ctx;
	uint64_t ring_idx_mask;
	struct mutex context_lock;
	char debug_name[65];
	bool explicit_debug_name;
};

struct virtio_gpu_framebuffer {
	struct drm_framebuffer base;
	struct virtio_gpu_fence *fence;
};

struct virtio_gpu_get_capset {
	struct virtio_gpu_ctrl_hdr hdr;
	__le32 capset_id;
	__le32 capset_version;
};

struct virtio_gpu_get_capset_info {
	struct virtio_gpu_ctrl_hdr hdr;
	__le32 capset_index;
	__le32 padding;
};

struct virtio_gpu_mem_entry {
	__le64 addr;
	__le32 length;
	__le32 padding;
};

struct virtio_gpu_object {
	struct drm_gem_shmem_object base;
	struct sg_table *sgt;
	uint32_t hw_res_handle;
	bool dumb;
	bool created;
	bool attached;
	bool host3d_blob;
	bool guest_blob;
	uint32_t blob_mem;
	uint32_t blob_flags;
	int uuid_state;
	uuid_t uuid;
};

struct virtio_gpu_object_array {
	struct ww_acquire_ctx ticket;
	struct list_head next;
	u32 nents;
	u32 total;
	struct drm_gem_object *objs[0];
};

struct virtio_gpu_object_params {
	long unsigned int size;
	bool dumb;
	bool virgl;
	bool blob;
	uint32_t format;
	uint32_t width;
	uint32_t height;
	uint32_t target;
	uint32_t bind;
	uint32_t depth;
	uint32_t array_size;
	uint32_t last_level;
	uint32_t nr_samples;
	uint32_t flags;
	uint32_t ctx_id;
	uint32_t blob_mem;
	uint32_t blob_flags;
	uint64_t blob_id;
};

struct virtio_gpu_object_shmem {
	struct virtio_gpu_object base;
};

struct virtio_gpu_object_vram {
	struct virtio_gpu_object base;
	uint32_t map_state;
	uint32_t map_info;
	struct drm_mm_node vram_node;
};

struct virtio_gpu_plane_state {
	struct drm_plane_state base;
	struct virtio_gpu_fence *fence;
};

struct virtio_gpu_resource_assign_uuid {
	struct virtio_gpu_ctrl_hdr hdr;
	__le32 resource_id;
	__le32 padding;
};

struct virtio_gpu_resource_attach_backing {
	struct virtio_gpu_ctrl_hdr hdr;
	__le32 resource_id;
	__le32 nr_entries;
};

struct virtio_gpu_resource_create_2d {
	struct virtio_gpu_ctrl_hdr hdr;
	__le32 resource_id;
	__le32 format;
	__le32 width;
	__le32 height;
};

struct virtio_gpu_resource_create_3d {
	struct virtio_gpu_ctrl_hdr hdr;
	__le32 resource_id;
	__le32 target;
	__le32 format;
	__le32 bind;
	__le32 width;
	__le32 height;
	__le32 depth;
	__le32 array_size;
	__le32 last_level;
	__le32 nr_samples;
	__le32 flags;
	__le32 padding;
};

struct virtio_gpu_resource_create_blob {
	struct virtio_gpu_ctrl_hdr hdr;
	__le32 resource_id;
	__le32 blob_mem;
	__le32 blob_flags;
	__le32 nr_entries;
	__le64 blob_id;
	__le64 size;
};

struct virtio_gpu_resource_detach_backing {
	struct virtio_gpu_ctrl_hdr hdr;
	__le32 resource_id;
	__le32 padding;
};

struct virtio_gpu_resource_flush {
	struct virtio_gpu_ctrl_hdr hdr;
	struct virtio_gpu_rect r;
	__le32 resource_id;
	__le32 padding;
};

struct virtio_gpu_resource_map_blob {
	struct virtio_gpu_ctrl_hdr hdr;
	__le32 resource_id;
	__le32 padding;
	__le64 offset;
};

struct virtio_gpu_resource_unmap_blob {
	struct virtio_gpu_ctrl_hdr hdr;
	__le32 resource_id;
	__le32 padding;
};

struct virtio_gpu_resource_unref {
	struct virtio_gpu_ctrl_hdr hdr;
	__le32 resource_id;
	__le32 padding;
};

struct virtio_gpu_resp_capset {
	struct virtio_gpu_ctrl_hdr hdr;
	__u8 capset_data[0];
};

struct virtio_gpu_resp_capset_info {
	struct virtio_gpu_ctrl_hdr hdr;
	__le32 capset_id;
	__le32 capset_max_version;
	__le32 capset_max_size;
	__le32 padding;
};

struct virtio_gpu_resp_display_info {
	struct virtio_gpu_ctrl_hdr hdr;
	struct virtio_gpu_display_one pmodes[16];
};

struct virtio_gpu_resp_edid {
	struct virtio_gpu_ctrl_hdr hdr;
	__le32 size;
	__le32 padding;
	__u8 edid[1024];
};

struct virtio_gpu_resp_map_info {
	struct virtio_gpu_ctrl_hdr hdr;
	__u32 map_info;
	__u32 padding;
};

struct virtio_gpu_resp_resource_uuid {
	struct virtio_gpu_ctrl_hdr hdr;
	__u8 uuid[16];
};

struct virtio_gpu_set_scanout {
	struct virtio_gpu_ctrl_hdr hdr;
	struct virtio_gpu_rect r;
	__le32 scanout_id;
	__le32 resource_id;
};

struct virtio_gpu_set_scanout_blob {
	struct virtio_gpu_ctrl_hdr hdr;
	struct virtio_gpu_rect r;
	__le32 scanout_id;
	__le32 resource_id;
	__le32 width;
	__le32 height;
	__le32 format;
	__le32 padding;
	__le32 strides[4];
	__le32 offsets[4];
};

struct virtio_gpu_submit_post_dep;

struct virtio_gpu_submit {
	struct virtio_gpu_submit_post_dep *post_deps;
	unsigned int num_out_syncobjs;
	struct drm_syncobj **in_syncobjs;
	unsigned int num_in_syncobjs;
	struct virtio_gpu_object_array *buflist;
	struct drm_virtgpu_execbuffer *exbuf;
	struct virtio_gpu_fence *out_fence;
	struct virtio_gpu_fpriv *vfpriv;
	struct virtio_gpu_device *vgdev;
	struct sync_file *sync_file;
	struct drm_file *file;
	int out_fence_fd;
	u64 fence_ctx;
	u32 ring_idx;
	void *buf;
};

struct virtio_gpu_submit_post_dep {
	struct drm_syncobj *syncobj;
	struct dma_fence_chain *chain;
	u64 point;
};

struct virtio_gpu_transfer_host_3d {
	struct virtio_gpu_ctrl_hdr hdr;
	struct virtio_gpu_box box;
	__le64 offset;
	__le32 resource_id;
	__le32 level;
	__le32 stride;
	__le32 layer_stride;
};

struct virtio_gpu_transfer_to_host_2d {
	struct virtio_gpu_ctrl_hdr hdr;
	struct virtio_gpu_rect r;
	__le64 offset;
	__le32 resource_id;
	__le32 padding;
};

struct virtio_gpu_vbuffer;

typedef void (*virtio_gpu_resp_cb)(struct virtio_gpu_device *, struct virtio_gpu_vbuffer *);

struct virtio_gpu_vbuffer {
	char *buf;
	int size;
	void *data_buf;
	uint32_t data_size;
	char *resp_buf;
	int resp_size;
	virtio_gpu_resp_cb resp_cb;
	void *resp_cb_data;
	struct virtio_gpu_object_array *objs;
	struct list_head list;
	uint32_t seqno;
};

struct virtio_input_event {
	__le16 type;
	__le16 code;
	__le32 value;
};

struct virtio_input {
	struct virtio_device *vdev;
	struct input_dev *idev;
	char name[64];
	char serial[64];
	char phys[64];
	struct virtqueue *evt;
	struct virtqueue *sts;
	struct virtio_input_event evts[64];
	spinlock_t lock;
	bool ready;
};

struct virtio_input_absinfo {
	__le32 min;
	__le32 max;
	__le32 fuzz;
	__le32 flat;
	__le32 res;
};

struct virtio_input_devids {
	__le16 bustype;
	__le16 vendor;
	__le16 product;
	__le16 version;
};

struct virtio_input_config {
	__u8 select;
	__u8 subsel;
	__u8 size;
	__u8 reserved[5];
	union {
		char string[128];
		__u8 bitmap[128];
		struct virtio_input_absinfo abs;
		struct virtio_input_devids ids;
	} u;
};

struct virtio_net_hdr {
	__u8 flags;
	__u8 gso_type;
	__virtio16 hdr_len;
	__virtio16 gso_size;
	__virtio16 csum_start;
	__virtio16 csum_offset;
};

struct virtio_net_hdr_mrg_rxbuf {
	struct virtio_net_hdr hdr;
	__virtio16 num_buffers;
};

struct virtio_net_hdr_v1 {
	__u8 flags;
	__u8 gso_type;
	__virtio16 hdr_len;
	__virtio16 gso_size;
	union {
		struct {
			__virtio16 csum_start;
			__virtio16 csum_offset;
		};
		struct {
			__virtio16 start;
			__virtio16 offset;
		} csum;
		struct {
			__le16 segments;
			__le16 dup_acks;
		} rsc;
	};
	__virtio16 num_buffers;
};

struct virtio_net_hdr_v1_hash {
	struct virtio_net_hdr_v1 hdr;
	__le32 hash_value;
	__le16 hash_report;
	__le16 padding;
};

struct virtio_net_common_hdr {
	union {
		struct virtio_net_hdr hdr;
		struct virtio_net_hdr_mrg_rxbuf mrg_hdr;
		struct virtio_net_hdr_v1_hash hash_v1_hdr;
	};
};

struct virtio_net_config {
	__u8 mac[6];
	__virtio16 status;
	__virtio16 max_virtqueue_pairs;
	__virtio16 mtu;
	__le32 speed;
	__u8 duplex;
	__u8 rss_max_key_size;
	__le16 rss_max_indirection_table_length;
	__le32 supported_hash_types;
};

struct virtio_net_ctrl_coal {
	__le32 max_packets;
	__le32 max_usecs;
};

struct virtio_net_ctrl_coal_rx {
	__le32 rx_max_packets;
	__le32 rx_usecs;
};

struct virtio_net_ctrl_coal_tx {
	__le32 tx_max_packets;
	__le32 tx_usecs;
};

struct virtio_net_ctrl_coal_vq {
	__le16 vqn;
	__le16 reserved;
	struct virtio_net_ctrl_coal coal;
};

struct virtio_net_ctrl_mac {
	__virtio32 entries;
	__u8 macs[0];
};

struct virtio_net_ctrl_mq {
	__virtio16 virtqueue_pairs;
};

struct virtio_net_ctrl_queue_stats {
	struct {
		__le16 vq_index;
		__le16 reserved[3];
		__le64 types_bitmap[1];
	} stats[1];
};

struct virtio_net_ctrl_rss {
	u32 hash_types;
	u16 indirection_table_mask;
	u16 unclassified_queue;
	u16 hash_cfg_reserved;
	u16 max_tx_vq;
	u8 hash_key_length;
	u8 key[40];
	u16 *indirection_table;
};

struct virtio_net_stats_capabilities {
	__le64 supported_stats_types[1];
};

struct virtio_net_stats_reply_hdr {
	__u8 type;
	__u8 reserved;
	__le16 vq_index;
	__le16 reserved1;
	__le16 size;
};

struct virtio_pci_vq_info;

struct virtio_pci_admin_vq {
	struct virtio_pci_vq_info *info;
	spinlock_t lock;
	u64 supported_cmds;
	u64 supported_caps;
	u8 max_dev_parts_objects;
	struct ida dev_parts_ida;
	char name[10];
	u16 vq_index;
};

struct virtio_pci_common_cfg {
	__le32 device_feature_select;
	__le32 device_feature;
	__le32 guest_feature_select;
	__le32 guest_feature;
	__le16 msix_config;
	__le16 num_queues;
	__u8 device_status;
	__u8 config_generation;
	__le16 queue_select;
	__le16 queue_size;
	__le16 queue_msix_vector;
	__le16 queue_enable;
	__le16 queue_notify_off;
	__le32 queue_desc_lo;
	__le32 queue_desc_hi;
	__le32 queue_avail_lo;
	__le32 queue_avail_hi;
	__le32 queue_used_lo;
	__le32 queue_used_hi;
};

struct virtio_pci_legacy_device {
	struct pci_dev *pci_dev;
	u8 *isr;
	void *ioaddr;
	struct virtio_device_id id;
};

struct virtio_pci_modern_device {
	struct pci_dev *pci_dev;
	struct virtio_pci_common_cfg *common;
	void *device;
	void *notify_base;
	resource_size_t notify_pa;
	u8 *isr;
	size_t notify_len;
	size_t device_len;
	size_t common_len;
	int notify_map_cap;
	u32 notify_offset_multiplier;
	int modern_bars;
	struct virtio_device_id id;
	int (*device_id_check)(struct pci_dev *);
	u64 dma_mask;
};

struct virtio_pci_device {
	struct virtio_device vdev;
	struct pci_dev *pci_dev;
	union {
		struct virtio_pci_legacy_device ldev;
		struct virtio_pci_modern_device mdev;
	};
	bool is_legacy;
	u8 *isr;
	spinlock_t lock;
	struct list_head virtqueues;
	struct list_head slow_virtqueues;
	struct virtio_pci_vq_info **vqs;
	struct virtio_pci_admin_vq admin_vq;
	int msix_enabled;
	int intx_enabled;
	cpumask_var_t *msix_affinity_masks;
	char (*msix_names)[256];
	unsigned int msix_vectors;
	unsigned int msix_used_vectors;
	bool per_vq_vectors;
	struct virtqueue * (*setup_vq)(struct virtio_pci_device *, struct virtio_pci_vq_info *, unsigned int, void (*)(struct virtqueue *), const char *, bool, u16);
	void (*del_vq)(struct virtio_pci_vq_info *);
	u16 (*config_vector)(struct virtio_pci_device *, u16);
	int (*avq_index)(struct virtio_device *, u16 *, u16 *);
};

struct virtio_pci_modern_common_cfg {
	struct virtio_pci_common_cfg cfg;
	__le16 queue_notify_data;
	__le16 queue_reset;
	__le16 admin_queue_index;
	__le16 admin_queue_num;
};

struct virtio_pci_vq_info {
	struct virtqueue *vq;
	struct list_head node;
	unsigned int msix_vector;
};

struct virtio_resource_obj_dev_parts {
	__u8 type;
	__u8 reserved[7];
};

struct virtio_scsi_event {
	__virtio32 event;
	__u8 lun[8];
	__virtio32 reason;
};

struct virtio_scsi;

struct virtio_scsi_event_node {
	struct virtio_scsi *vscsi;
	struct virtio_scsi_event event;
	struct work_struct work;
};

struct virtio_scsi_vq {
	spinlock_t vq_lock;
	struct virtqueue *vq;
};

struct virtio_scsi {
	struct virtio_device *vdev;
	struct virtio_scsi_event_node event_list[8];
	u32 num_queues;
	int io_queues[3];
	struct hlist_node node;
	bool stop_events;
	struct virtio_scsi_vq ctrl_vq;
	struct virtio_scsi_vq event_vq;
	struct virtio_scsi_vq req_vqs[0];
};

struct virtio_scsi_cmd_req {
	__u8 lun[8];
	__virtio64 tag;
	__u8 task_attr;
	__u8 prio;
	__u8 crn;
	__u8 cdb[32];
} __attribute__((packed));

struct virtio_scsi_cmd_req_pi {
	__u8 lun[8];
	__virtio64 tag;
	__u8 task_attr;
	__u8 prio;
	__u8 crn;
	__virtio32 pi_bytesout;
	__virtio32 pi_bytesin;
	__u8 cdb[32];
} __attribute__((packed));

struct virtio_scsi_ctrl_tmf_req {
	__virtio32 type;
	__virtio32 subtype;
	__u8 lun[8];
	__virtio64 tag;
};

struct virtio_scsi_ctrl_an_req {
	__virtio32 type;
	__u8 lun[8];
	__virtio32 event_requested;
};

struct virtio_scsi_cmd_resp {
	__virtio32 sense_len;
	__virtio32 resid;
	__virtio16 status_qualifier;
	__u8 status;
	__u8 response;
	__u8 sense[96];
};

struct virtio_scsi_ctrl_tmf_resp {
	__u8 response;
};

struct virtio_scsi_ctrl_an_resp {
	__virtio32 event_actual;
	__u8 response;
} __attribute__((packed));

struct virtio_scsi_cmd {
	struct scsi_cmnd *sc;
	struct completion *comp;
	union {
		struct virtio_scsi_cmd_req cmd;
		struct virtio_scsi_cmd_req_pi cmd_pi;
		struct virtio_scsi_ctrl_tmf_req tmf;
		struct virtio_scsi_ctrl_an_req an;
	} req;
	union {
		struct virtio_scsi_cmd_resp cmd;
		struct virtio_scsi_ctrl_tmf_resp tmf;
		struct virtio_scsi_ctrl_an_resp an;
		struct virtio_scsi_event evt;
	} resp;
	long: 64;
} __attribute__((packed));

struct virtio_scsi_config {
	__virtio32 num_queues;
	__virtio32 seg_max;
	__virtio32 max_sectors;
	__virtio32 cmd_per_lun;
	__virtio32 event_info_size;
	__virtio32 sense_size;
	__virtio32 cdb_size;
	__virtio16 max_channel;
	__virtio16 max_target;
	__virtio32 max_lun;
};

struct virtnet_info {
	struct virtio_device *vdev;
	struct virtqueue *cvq;
	struct net_device *dev;
	struct send_queue *sq;
	struct receive_queue *rq;
	unsigned int status;
	u16 max_queue_pairs;
	u16 curr_queue_pairs;
	u16 xdp_queue_pairs;
	bool xdp_enabled;
	bool big_packets;
	unsigned int big_packets_num_skbfrags;
	bool mergeable_rx_bufs;
	bool has_rss;
	bool has_rss_hash_report;
	u8 rss_key_size;
	u16 rss_indir_table_size;
	u32 rss_hash_types_supported;
	u32 rss_hash_types_saved;
	struct virtio_net_ctrl_rss rss;
	bool has_cvq;
	struct mutex cvq_lock;
	bool any_header_sg;
	u8 hdr_len;
	struct delayed_work refill;
	bool refill_enabled;
	spinlock_t refill_lock;
	struct work_struct config_work;
	struct work_struct rx_mode_work;
	bool rx_mode_work_enabled;
	bool affinity_hint_set;
	struct hlist_node node;
	struct hlist_node node_dead;
	struct control_buf *ctrl;
	u8 duplex;
	u32 speed;
	bool rx_dim_enabled;
	struct virtnet_interrupt_coalesce intr_coal_tx;
	struct virtnet_interrupt_coalesce intr_coal_rx;
	long unsigned int guest_offloads;
	long unsigned int guest_offloads_capable;
	struct failover *failover;
	u64 device_stats_cap;
};

struct virtnet_rq_dma {
	dma_addr_t addr;
	u32 ref;
	u16 len;
	u16 need_sync;
};

struct virtnet_sq_free_stats {
	u64 packets;
	u64 bytes;
	u64 napi_packets;
	u64 napi_bytes;
	u64 xsk;
};

struct virtnet_stat_desc {
	char desc[32];
	size_t offset;
	size_t qstat_offset;
};

struct virtnet_stats_ctx {
	bool to_qstat;
	u32 desc_num[3];
	u64 bitmap[3];
	u32 size[3];
	u64 *data;
};

struct virtqueue {
	struct list_head list;
	void (*callback)(struct virtqueue *);
	const char *name;
	struct virtio_device *vdev;
	unsigned int index;
	unsigned int num_free;
	unsigned int num_max;
	bool reset;
	void *priv;
};

typedef void vq_callback_t(struct virtqueue *);

struct virtqueue_info {
	const char *name;
	vq_callback_t *callback;
	bool ctx;
};

struct virtual_engine {
	struct intel_engine_cs base;
	struct intel_context context;
	struct rcu_work rcu;
	struct i915_request *request;
	struct ve_node nodes[27];
	unsigned int num_siblings;
	struct intel_engine_cs *siblings[0];
};

struct vlan_ethhdr {
	union {
		struct {
			unsigned char h_dest[6];
			unsigned char h_source[6];
		};
		struct {
			unsigned char h_dest[6];
			unsigned char h_source[6];
		} addrs;
	};
	__be16 h_vlan_proto;
	__be16 h_vlan_TCI;
	__be16 h_vlan_encapsulated_proto;
};

struct vlan_hdr {
	__be16 h_vlan_TCI;
	__be16 h_vlan_encapsulated_proto;
};

struct vlv_s0ix_state {
	u32 wr_watermark;
	u32 gfx_prio_ctrl;
	u32 arb_mode;
	u32 gfx_pend_tlb0;
	u32 gfx_pend_tlb1;
	u32 lra_limits[13];
	u32 media_max_req_count;
	u32 gfx_max_req_count;
	u32 render_hwsp;
	u32 ecochk;
	u32 bsd_hwsp;
	u32 blt_hwsp;
	u32 tlb_rd_addr;
	u32 g3dctl;
	u32 gsckgctl;
	u32 mbctl;
	u32 ucgctl1;
	u32 ucgctl3;
	u32 rcgctl1;
	u32 rcgctl2;
	u32 rstctl;
	u32 misccpctl;
	u32 gfxpause;
	u32 rpdeuhwtc;
	u32 rpdeuc;
	u32 ecobus;
	u32 pwrdwnupctl;
	u32 rp_down_timeout;
	u32 rp_deucsw;
	u32 rcubmabdtmr;
	u32 rcedata;
	u32 spare2gh;
	u32 gt_imr;
	u32 gt_ier;
	u32 pm_imr;
	u32 pm_ier;
	u32 gt_scratch[8];
	u32 tilectl;
	u32 gt_fifoctl;
	u32 gtlc_wake_ctrl;
	u32 gtlc_survive;
	u32 pmwgicz;
	u32 gu_ctl0;
	u32 gu_ctl1;
	u32 pcbr;
	u32 clock_gate_dis2;
};

struct vm_userfaultfd_ctx {};

struct vma_lock;

struct vm_area_struct {
	union {
		struct {
			long unsigned int vm_start;
			long unsigned int vm_end;
		};
		struct callback_head vm_rcu;
	};
	struct mm_struct *vm_mm;
	pgprot_t vm_page_prot;
	union {
		const vm_flags_t vm_flags;
		vm_flags_t __vm_flags;
	};
	bool detached;
	unsigned int vm_lock_seq;
	struct vma_lock *vm_lock;
	struct {
		struct rb_node rb;
		long unsigned int rb_subtree_last;
	} shared;
	struct list_head anon_vma_chain;
	struct anon_vma *anon_vma;
	const struct vm_operations_struct *vm_ops;
	long unsigned int vm_pgoff;
	struct file *vm_file;
	void *vm_private_data;
	atomic_long_t swap_readahead_info;
	struct mempolicy *vm_policy;
	struct vm_userfaultfd_ctx vm_userfaultfd_ctx;
};

struct vm_event_state {
	long unsigned int event[82];
};

struct vm_fault {
	const struct {
		struct vm_area_struct *vma;
		gfp_t gfp_mask;
		long unsigned int pgoff;
		long unsigned int address;
		long unsigned int real_address;
	};
	enum fault_flag flags;
	pmd_t *pmd;
	pud_t *pud;
	union {
		pte_t orig_pte;
		pmd_t orig_pmd;
	};
	struct page *cow_page;
	struct page *page;
	pte_t *pte;
	spinlock_t *ptl;
	pgtable_t prealloc_pte;
};

struct vm_operations_struct {
	void (*open)(struct vm_area_struct *);
	void (*close)(struct vm_area_struct *);
	int (*may_split)(struct vm_area_struct *, long unsigned int);
	int (*mremap)(struct vm_area_struct *);
	int (*mprotect)(struct vm_area_struct *, long unsigned int, long unsigned int, long unsigned int);
	vm_fault_t (*fault)(struct vm_fault *);
	vm_fault_t (*huge_fault)(struct vm_fault *, unsigned int);
	vm_fault_t (*map_pages)(struct vm_fault *, long unsigned int, long unsigned int);
	long unsigned int (*pagesize)(struct vm_area_struct *);
	vm_fault_t (*page_mkwrite)(struct vm_fault *);
	vm_fault_t (*pfn_mkwrite)(struct vm_fault *);
	int (*access)(struct vm_area_struct *, long unsigned int, void *, int, int);
	const char * (*name)(struct vm_area_struct *);
	int (*set_policy)(struct vm_area_struct *, struct mempolicy *);
	struct mempolicy * (*get_policy)(struct vm_area_struct *, long unsigned int, long unsigned int *);
	struct page * (*find_special_page)(struct vm_area_struct *, long unsigned int);
};

struct vm_special_mapping {
	const char *name;
	struct page **pages;
	vm_fault_t (*fault)(const struct vm_special_mapping *, struct vm_area_struct *, struct vm_fault *);
	int (*mremap)(const struct vm_special_mapping *, struct vm_area_struct *);
	void (*close)(const struct vm_special_mapping *, struct vm_area_struct *);
};

struct vm_stack {
	struct callback_head rcu;
	struct vm_struct *stack_vm_area;
};

struct vm_struct {
	struct vm_struct *next;
	void *addr;
	long unsigned int size;
	long unsigned int flags;
	struct page **pages;
	unsigned int page_order;
	unsigned int nr_pages;
	phys_addr_t phys_addr;
	const void *caller;
};

struct vm_unmapped_area_info {
	long unsigned int flags;
	long unsigned int length;
	long unsigned int low_limit;
	long unsigned int high_limit;
	long unsigned int align_mask;
	long unsigned int align_offset;
	long unsigned int start_gap;
};

struct vma_list {
	struct vm_area_struct *vma;
	struct list_head head;
	refcount_t mmap_count;
};

struct vma_lock {
	struct rw_semaphore lock;
};

struct vma_merge_struct {
	struct mm_struct *mm;
	struct vma_iterator *vmi;
	long unsigned int pgoff;
	struct vm_area_struct *prev;
	struct vm_area_struct *next;
	struct vm_area_struct *vma;
	long unsigned int start;
	long unsigned int end;
	long unsigned int flags;
	struct file *file;
	struct anon_vma *anon_vma;
	struct mempolicy *policy;
	struct vm_userfaultfd_ctx uffd_ctx;
	struct anon_vma_name *anon_name;
	enum vma_merge_flags merge_flags;
	enum vma_merge_state state;
};

struct vma_prepare {
	struct vm_area_struct *vma;
	struct vm_area_struct *adj_next;
	struct file *file;
	struct address_space *mapping;
	struct anon_vma *anon_vma;
	struct vm_area_struct *insert;
	struct vm_area_struct *remove;
	struct vm_area_struct *remove2;
};

struct vmap_area {
	long unsigned int va_start;
	long unsigned int va_end;
	struct rb_node rb_node;
	struct list_head list;
	union {
		long unsigned int subtree_max_size;
		struct vm_struct *vm;
	};
	long unsigned int flags;
};

struct vmap_block {
	spinlock_t lock;
	struct vmap_area *va;
	long unsigned int free;
	long unsigned int dirty;
	long unsigned int used_map[16];
	long unsigned int dirty_min;
	long unsigned int dirty_max;
	struct list_head free_list;
	struct callback_head callback_head;
	struct list_head purge;
	unsigned int cpu;
};

struct vmap_block_queue {
	spinlock_t lock;
	struct list_head free;
	struct xarray vmap_blocks;
};

struct vmap_pool {
	struct list_head head;
	long unsigned int len;
};

struct vmap_node {
	struct vmap_pool pool[256];
	spinlock_t pool_lock;
	bool skip_populate;
	struct rb_list busy;
	struct rb_list lazy;
	struct list_head purge_list;
	struct work_struct purge_work;
	long unsigned int nr_purged;
};

struct vmap_pfn_data {
	long unsigned int *pfns;
	pgprot_t prot;
	unsigned int idx;
};

struct vmclock_abi {
	__le32 magic;
	__le32 size;
	__le16 version;
	__u8 counter_id;
	__u8 time_type;
	__le32 seq_count;
	__le64 disruption_marker;
	__le64 flags;
	__u8 pad[2];
	__u8 clock_status;
	__u8 leap_second_smearing_hint;
	__le16 tai_offset_sec;
	__u8 leap_indicator;
	__u8 counter_period_shift;
	__le64 counter_value;
	__le64 counter_period_frac_sec;
	__le64 counter_period_esterror_rate_frac_sec;
	__le64 counter_period_maxerror_rate_frac_sec;
	__le64 time_sec;
	__le64 time_frac_sec;
	__le64 time_esterror_nanosec;
	__le64 time_maxerror_nanosec;
};

struct vmclock_state {
	struct resource res;
	struct vmclock_abi *clk;
	struct miscdevice miscdev;
	struct ptp_clock_info ptp_clock_info;
	struct ptp_clock *ptp_clock;
	enum clocksource_ids cs_id;
	enum clocksource_ids sys_cs_id;
	int index;
	char *name;
};

struct vmcore_cb {
	bool (*pfn_is_ram)(struct vmcore_cb *, long unsigned int);
	int (*get_device_ram)(struct vmcore_cb *, struct list_head *);
	struct list_head next;
};

struct vmcore_range {
	struct list_head list;
	long long unsigned int paddr;
	long long unsigned int size;
	loff_t offset;
};

struct vmemmap_remap_walk {
	void (*remap_pte)(pte_t *, long unsigned int, struct vmemmap_remap_walk *);
	long unsigned int nr_walked;
	struct page *reuse_page;
	long unsigned int reuse_addr;
	struct list_head *vmemmap_pages;
	long unsigned int flags;
};

struct vmware_steal_time {
	union {
		u64 clock;
		struct {
			u32 clock_low;
			u32 clock_high;
		};
	};
	u64 reserved[7];
};

struct vring_desc;

typedef struct vring_desc vring_desc_t;

struct vring_avail;

typedef struct vring_avail vring_avail_t;

struct vring_used;

typedef struct vring_used vring_used_t;

struct vring {
	unsigned int num;
	vring_desc_t *desc;
	vring_avail_t *avail;
	vring_used_t *used;
};

struct vring_avail {
	__virtio16 flags;
	__virtio16 idx;
	__virtio16 ring[0];
};

struct vring_desc {
	__virtio64 addr;
	__virtio32 len;
	__virtio16 flags;
	__virtio16 next;
};

struct vring_desc_extra {
	dma_addr_t addr;
	u32 len;
	u16 flags;
	u16 next;
};

struct vring_packed_desc;

struct vring_desc_state_packed {
	void *data;
	struct vring_packed_desc *indir_desc;
	u16 num;
	u16 last;
};

struct vring_desc_state_split {
	void *data;
	struct vring_desc *indir_desc;
};

struct vring_packed_desc {
	__le64 addr;
	__le32 len;
	__le16 id;
	__le16 flags;
};

struct vring_packed_desc_event {
	__le16 off_wrap;
	__le16 flags;
};

struct vring_used_elem {
	__virtio32 id;
	__virtio32 len;
};

typedef struct vring_used_elem vring_used_elem_t;

struct vring_used {
	__virtio16 flags;
	__virtio16 idx;
	vring_used_elem_t ring[0];
};

struct vring_virtqueue_split {
	struct vring vring;
	u16 avail_flags_shadow;
	u16 avail_idx_shadow;
	struct vring_desc_state_split *desc_state;
	struct vring_desc_extra *desc_extra;
	dma_addr_t queue_dma_addr;
	size_t queue_size_in_bytes;
	u32 vring_align;
	bool may_reduce_num;
};

struct vring_virtqueue_packed {
	struct {
		unsigned int num;
		struct vring_packed_desc *desc;
		struct vring_packed_desc_event *driver;
		struct vring_packed_desc_event *device;
	} vring;
	bool avail_wrap_counter;
	u16 avail_used_flags;
	u16 next_avail_idx;
	u16 event_flags_shadow;
	struct vring_desc_state_packed *desc_state;
	struct vring_desc_extra *desc_extra;
	dma_addr_t ring_dma_addr;
	dma_addr_t driver_event_dma_addr;
	dma_addr_t device_event_dma_addr;
	size_t ring_size_in_bytes;
	size_t event_size_in_bytes;
};

struct vring_virtqueue {
	struct virtqueue vq;
	bool packed_ring;
	bool use_dma_api;
	bool weak_barriers;
	bool broken;
	bool indirect;
	bool event;
	unsigned int free_head;
	unsigned int num_added;
	u16 last_used_idx;
	bool event_triggered;
	union {
		struct vring_virtqueue_split split;
		struct vring_virtqueue_packed packed;
	};
	bool (*notify)(struct virtqueue *);
	bool we_own_ring;
	struct device *dma_dev;
};

struct vt_consize {
	short unsigned int v_rows;
	short unsigned int v_cols;
	short unsigned int v_vlin;
	short unsigned int v_clin;
	short unsigned int v_vcol;
	short unsigned int v_ccol;
};

struct vt_event {
	unsigned int event;
	unsigned int oldev;
	unsigned int newev;
	unsigned int pad[4];
};

struct vt_event_wait {
	struct list_head list;
	struct vt_event event;
	int done;
};

struct vt_notifier_param {
	struct vc_data *vc;
	unsigned int c;
};

struct vt_setactivate {
	unsigned int console;
	struct vt_mode mode;
};

struct vt_sizes {
	short unsigned int v_rows;
	short unsigned int v_cols;
	short unsigned int v_scrollsize;
};

struct vt_spawn_console {
	spinlock_t lock;
	struct pid *pid;
	int sig;
};

struct vt_stat {
	short unsigned int v_active;
	short unsigned int v_signal;
	short unsigned int v_state;
};

struct vxlan_metadata {
	u32 gbp;
};

struct wait_barrier {
	struct wait_queue_entry base;
	struct i915_active *ref;
};

struct wait_bit_key {
	long unsigned int *flags;
	int bit_nr;
	long unsigned int timeout;
};

struct wait_bit_queue_entry {
	struct wait_bit_key key;
	struct wait_queue_entry wq_entry;
};

struct wait_page_key {
	struct folio *folio;
	int bit_nr;
	int page_match;
};

struct wait_rps_boost {
	struct wait_queue_entry wait;
	struct drm_crtc *crtc;
	struct i915_request *request;
};

struct wake_irq {
	struct device *dev;
	unsigned int status;
	int irq;
	const char *name;
};

struct wakeup_header {
	u16 video_mode;
	u32 pmode_entry;
	u16 pmode_cs;
	u32 pmode_cr0;
	u32 pmode_cr3;
	u32 pmode_cr4;
	u32 pmode_efer_low;
	u32 pmode_efer_high;
	u64 pmode_gdt;
	u32 pmode_misc_en_low;
	u32 pmode_misc_en_high;
	u32 pmode_behavior;
	u32 realmode_flags;
	u32 real_magic;
	u32 signature;
} __attribute__((packed));

struct wakeup_source {
	const char *name;
	int id;
	struct list_head entry;
	spinlock_t lock;
	struct wake_irq *wakeirq;
	struct timer_list timer;
	long unsigned int timer_expires;
	ktime_t total_time;
	ktime_t max_time;
	ktime_t last_time;
	ktime_t start_prevent_time;
	ktime_t prevent_sleep_time;
	long unsigned int event_count;
	long unsigned int active_count;
	long unsigned int relax_count;
	long unsigned int expire_count;
	long unsigned int wakeup_count;
	struct device *dev;
	bool active: 1;
	bool autosleep_enabled: 1;
};

struct walk_rcec_data {
	struct pci_dev *rcec;
	int (*user_callback)(struct pci_dev *, void *);
	void *user_data;
};

struct warn_args {
	const char *fmt;
	va_list args;
};

struct wb_completion {
	atomic_t cnt;
	wait_queue_head_t *waitq;
};

struct wb_domain {
	spinlock_t lock;
	struct fprop_global completions;
	struct timer_list period_timer;
	long unsigned int period_time;
	long unsigned int dirty_limit_tstamp;
	long unsigned int dirty_limit;
};

struct wb_lock_cookie {
	bool locked;
	long unsigned int flags;
};

struct wb_stats {
	long unsigned int nr_dirty;
	long unsigned int nr_io;
	long unsigned int nr_more_io;
	long unsigned int nr_dirty_time;
	long unsigned int nr_writeback;
	long unsigned int nr_reclaimable;
	long unsigned int nr_dirtied;
	long unsigned int nr_written;
	long unsigned int dirty_thresh;
	long unsigned int wb_thresh;
};

struct wb_writeback_work {
	long int nr_pages;
	struct super_block *sb;
	enum writeback_sync_modes sync_mode;
	unsigned int tagged_writepages: 1;
	unsigned int for_kupdate: 1;
	unsigned int range_cyclic: 1;
	unsigned int for_background: 1;
	unsigned int for_sync: 1;
	unsigned int auto_free: 1;
	enum wb_reason reason;
	struct list_head list;
	struct wb_completion *done;
};

struct wbrf_ranges_in_out {
	u64 num_of_ranges;
	struct freq_band_range band_list[11];
};

struct widget_attribute {
	struct attribute attr;
	ssize_t (*show)(struct hdac_device *, hda_nid_t, struct widget_attribute *, char *);
	ssize_t (*store)(struct hdac_device *, hda_nid_t, struct widget_attribute *, const char *, size_t);
};

typedef struct wiphy *class_wiphy_t;

struct wiphy_coalesce_support {
	int n_rules;
	int max_delay;
	int n_patterns;
	int pattern_max_len;
	int pattern_min_len;
	int max_pkt_offset;
};

struct wiphy_iftype_akm_suites {
	u16 iftypes_mask;
	const u32 *akm_suites;
	int n_akm_suites;
};

struct wiphy_iftype_ext_capab {
	enum nl80211_iftype iftype;
	const u8 *extended_capabilities;
	const u8 *extended_capabilities_mask;
	u8 extended_capabilities_len;
	u16 eml_capabilities;
	u16 mld_capa_and_ops;
};

struct wiphy_radio_freq_range;

struct wiphy_radio {
	const struct wiphy_radio_freq_range *freq_range;
	int n_freq_range;
	const struct ieee80211_iface_combination *iface_combinations;
	int n_iface_combinations;
	u32 antenna_mask;
};

struct wiphy_radio_freq_range {
	u32 start_freq;
	u32 end_freq;
};

struct wiphy_vendor_command {
	struct nl80211_vendor_cmd_info info;
	u32 flags;
	int (*doit)(struct wiphy *, struct wireless_dev *, const void *, int);
	int (*dumpit)(struct wiphy *, struct wireless_dev *, struct sk_buff *, const void *, int, long unsigned int *);
	const struct nla_policy *policy;
	unsigned int maxattr;
};

struct wiphy_wowlan_tcp_support;

struct wiphy_wowlan_support {
	u32 flags;
	int n_patterns;
	int pattern_max_len;
	int pattern_min_len;
	int max_pkt_offset;
	int max_nd_match_sets;
	const struct wiphy_wowlan_tcp_support *tcp;
};

struct wiphy_wowlan_tcp_support {
	const struct nl80211_wowlan_tcp_data_token_feature *tok;
	u32 data_payload_max;
	u32 data_interval_max;
	u32 wake_payload_max;
	bool seq;
};

struct wired_cmd_ake_send_hprime_in {
	struct hdcp_cmd_header header;
	struct hdcp_port_id port;
	u8 h_prime[32];
};

struct wired_cmd_ake_send_hprime_out {
	struct hdcp_cmd_header header;
	struct hdcp_port_id port;
};

struct wired_cmd_ake_send_pairing_info_in {
	struct hdcp_cmd_header header;
	struct hdcp_port_id port;
	u8 e_kh_km[16];
};

struct wired_cmd_ake_send_pairing_info_out {
	struct hdcp_cmd_header header;
	struct hdcp_port_id port;
};

struct wired_cmd_close_session_in {
	struct hdcp_cmd_header header;
	struct hdcp_port_id port;
};

struct wired_cmd_close_session_out {
	struct hdcp_cmd_header header;
	struct hdcp_port_id port;
};

struct wired_cmd_enable_auth_in {
	struct hdcp_cmd_header header;
	struct hdcp_port_id port;
	u8 stream_type;
} __attribute__((packed));

struct wired_cmd_enable_auth_out {
	struct hdcp_cmd_header header;
	struct hdcp_port_id port;
};

struct wired_cmd_get_session_key_in {
	struct hdcp_cmd_header header;
	struct hdcp_port_id port;
};

struct wired_cmd_get_session_key_out {
	struct hdcp_cmd_header header;
	struct hdcp_port_id port;
	u8 e_dkey_ks[16];
	u8 r_iv[8];
};

struct wired_cmd_init_locality_check_in {
	struct hdcp_cmd_header header;
	struct hdcp_port_id port;
};

struct wired_cmd_init_locality_check_out {
	struct hdcp_cmd_header header;
	struct hdcp_port_id port;
	u8 r_n[8];
};

struct wired_cmd_initiate_hdcp2_session_in {
	struct hdcp_cmd_header header;
	struct hdcp_port_id port;
	u8 protocol;
} __attribute__((packed));

struct wired_cmd_initiate_hdcp2_session_out {
	struct hdcp_cmd_header header;
	struct hdcp_port_id port;
	u8 r_tx[8];
	struct hdcp2_tx_caps tx_caps;
} __attribute__((packed));

struct wired_cmd_repeater_auth_stream_req_in {
	struct hdcp_cmd_header header;
	struct hdcp_port_id port;
	u8 seq_num_m[3];
	u8 m_prime[32];
	__be16 k;
	struct hdcp2_streamid_type streams[0];
} __attribute__((packed));

struct wired_cmd_repeater_auth_stream_req_out {
	struct hdcp_cmd_header header;
	struct hdcp_port_id port;
};

struct wired_cmd_validate_locality_in {
	struct hdcp_cmd_header header;
	struct hdcp_port_id port;
	u8 l_prime[32];
};

struct wired_cmd_validate_locality_out {
	struct hdcp_cmd_header header;
	struct hdcp_port_id port;
};

struct wired_cmd_verify_receiver_cert_in {
	struct hdcp_cmd_header header;
	struct hdcp_port_id port;
	struct hdcp2_cert_rx cert_rx;
	u8 r_rx[8];
	u8 rx_caps[3];
} __attribute__((packed));

struct wired_cmd_verify_receiver_cert_out {
	struct hdcp_cmd_header header;
	struct hdcp_port_id port;
	u8 km_stored;
	u8 reserved[3];
	union encrypted_buff ekm_buff;
};

struct wired_cmd_verify_repeater_in {
	struct hdcp_cmd_header header;
	struct hdcp_port_id port;
	u8 rx_info[2];
	u8 seq_num_v[3];
	u8 v_prime[16];
	u8 receiver_ids[155];
};

struct wired_cmd_verify_repeater_out {
	struct hdcp_cmd_header header;
	struct hdcp_port_id port;
	u8 content_type_supported;
	u8 v[16];
} __attribute__((packed));

struct wmi_device {
	struct device dev;
	bool setable;
	const char *driver_override;
};

typedef void (*wmi_notify_handler)(union acpi_object *, void *);

struct wmi_block {
	struct wmi_device dev;
	struct guid_block gblock;
	struct acpi_device *acpi_device;
	struct rw_semaphore notify_lock;
	wmi_notify_handler handler;
	void *handler_data;
	bool driver_ready;
	long unsigned int flags;
};

struct wmi_brightness_args {
	u32 mode;
	u32 val;
	u32 ret;
	u32 ignored[3];
};

struct wmi_device_id {
	const char guid_string[37];
	const void *context;
};

struct wmi_driver {
	struct device_driver driver;
	const struct wmi_device_id *id_table;
	bool no_notify_data;
	bool no_singleton;
	int (*probe)(struct wmi_device *, const void *);
	void (*remove)(struct wmi_device *);
	void (*shutdown)(struct wmi_device *);
	void (*notify)(struct wmi_device *, union acpi_object *);
};

struct wmi_guid_count_context {
	const guid_t *guid;
	int count;
};

struct wol_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_wolinfo wol;
	bool show_sopass;
};

struct word_at_a_time {
	const long unsigned int one_bits;
	const long unsigned int high_bits;
};

struct work_for_cpu {
	struct work_struct work;
	long int (*fn)(void *);
	void *arg;
	long int ret;
};

struct work_offq_data {
	u32 pool_id;
	u32 disable;
	u32 flags;
};

struct work_queue_wrapper {
	struct work_struct work;
	struct scsi_device *sdev;
};

struct worker {
	union {
		struct list_head entry;
		struct hlist_node hentry;
	};
	struct work_struct *current_work;
	work_func_t current_func;
	struct pool_workqueue *current_pwq;
	u64 current_at;
	unsigned int current_color;
	int sleeping;
	work_func_t last_func;
	struct list_head scheduled;
	struct task_struct *task;
	struct worker_pool *pool;
	struct list_head node;
	long unsigned int last_active;
	unsigned int flags;
	int id;
	char desc[32];
	struct workqueue_struct *rescue_wq;
};

struct worker_pool {
	raw_spinlock_t lock;
	int cpu;
	int node;
	int id;
	unsigned int flags;
	long unsigned int watchdog_ts;
	bool cpu_stall;
	int nr_running;
	struct list_head worklist;
	int nr_workers;
	int nr_idle;
	struct list_head idle_list;
	struct timer_list idle_timer;
	struct work_struct idle_cull_work;
	struct timer_list mayday_timer;
	struct hlist_head busy_hash[64];
	struct worker *manager;
	struct list_head workers;
	struct ida worker_ida;
	struct workqueue_attrs *attrs;
	struct hlist_node hash_node;
	int refcnt;
	struct callback_head rcu;
};

struct workqueue_attrs {
	int nice;
	cpumask_var_t cpumask;
	cpumask_var_t __pod_cpumask;
	bool affn_strict;
	enum wq_affn_scope affn_scope;
	bool ordered;
};

struct wq_flusher;

struct wq_device;

struct wq_node_nr_active;

struct workqueue_struct {
	struct list_head pwqs;
	struct list_head list;
	struct mutex mutex;
	int work_color;
	int flush_color;
	atomic_t nr_pwqs_to_flush;
	struct wq_flusher *first_flusher;
	struct list_head flusher_queue;
	struct list_head flusher_overflow;
	struct list_head maydays;
	struct worker *rescuer;
	int nr_drainers;
	int max_active;
	int min_active;
	int saved_max_active;
	int saved_min_active;
	struct workqueue_attrs *unbound_attrs;
	struct pool_workqueue *dfl_pwq;
	struct wq_device *wq_dev;
	char name[32];
	struct callback_head rcu;
	long: 64;
	long: 64;
	unsigned int flags;
	struct pool_workqueue **cpu_pwq;
	struct wq_node_nr_active *node_nr_active[0];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct wq_barrier {
	struct work_struct work;
	struct completion done;
	struct task_struct *task;
};

struct wq_device {
	struct workqueue_struct *wq;
	struct device dev;
};

struct wq_drain_dead_softirq_work {
	struct work_struct work;
	struct worker_pool *pool;
	struct completion done;
};

struct wq_flusher {
	struct list_head list;
	int flush_color;
	struct completion done;
};

struct wq_node_nr_active {
	int max;
	atomic_t nr;
	raw_spinlock_t lock;
	struct list_head pending_pwqs;
};

struct wq_pod_type {
	int nr_pods;
	cpumask_var_t *pod_cpus;
	int *pod_node;
	int *cpu_pod;
};

typedef void (*swap_func_t)(void *, void *, int);

struct wrapper {
	cmp_func_t cmp;
	swap_func_t swap;
};

struct writeback_control {
	long int nr_to_write;
	long int pages_skipped;
	loff_t range_start;
	loff_t range_end;
	enum writeback_sync_modes sync_mode;
	unsigned int for_kupdate: 1;
	unsigned int for_background: 1;
	unsigned int tagged_writepages: 1;
	unsigned int for_reclaim: 1;
	unsigned int range_cyclic: 1;
	unsigned int for_sync: 1;
	unsigned int unpinned_netfs_wb: 1;
	unsigned int no_cgroup_owner: 1;
	struct swap_iocb **swap_plug;
	struct list_head *list;
	struct folio_batch fbatch;
	long unsigned int index;
	int saved_err;
};

struct writer {
	uint8_t *buffer;
	uint8_t previous_byte;
	size_t buffer_pos;
	int bufsize;
	size_t global_pos;
	long int (*flush)(void *, long unsigned int);
	struct lzma_header *header;
};

struct ww_class {
	atomic_long_t stamp;
	struct lock_class_key acquire_key;
	struct lock_class_key mutex_key;
	const char *acquire_name;
	const char *mutex_name;
	unsigned int is_wait_die;
};

struct x509_certificate {
	struct x509_certificate *next;
	struct x509_certificate *signer;
	struct public_key *pub;
	struct public_key_signature *sig;
	char *issuer;
	char *subject;
	struct asymmetric_key_id *id;
	struct asymmetric_key_id *skid;
	time64_t valid_from;
	time64_t valid_to;
	const void *tbs;
	unsigned int tbs_size;
	unsigned int raw_sig_size;
	const void *raw_sig;
	const void *raw_serial;
	unsigned int raw_serial_size;
	unsigned int raw_issuer_size;
	const void *raw_issuer;
	const void *raw_subject;
	unsigned int raw_subject_size;
	unsigned int raw_skid_size;
	const void *raw_skid;
	unsigned int index;
	bool seen;
	bool verified;
	bool self_signed;
	bool unsupported_sig;
	bool blacklisted;
};

struct x509_parse_context {
	struct x509_certificate *cert;
	long unsigned int data;
	const void *key;
	size_t key_size;
	const void *params;
	size_t params_size;
	enum OID key_algo;
	enum OID last_oid;
	enum OID sig_algo;
	u8 o_size;
	u8 cn_size;
	u8 email_size;
	u16 o_offset;
	u16 cn_offset;
	u16 email_offset;
	unsigned int raw_akid_size;
	const void *raw_akid;
	const void *akid_raw_issuer;
	unsigned int akid_raw_issuer_size;
};

struct x86_apic_ops {
	unsigned int (*io_apic_read)(unsigned int, unsigned int);
	void (*restore)(void);
};

struct x86_cpuinit_ops {
	void (*setup_percpu_clockev)(void);
	void (*early_percpu_clock_init)(void);
	void (*fixup_cpu_id)(struct cpuinfo_x86 *, int);
	bool parallel_bringup;
};

struct x86_guest {
	int (*enc_status_change_prepare)(long unsigned int, int, bool);
	int (*enc_status_change_finish)(long unsigned int, int, bool);
	bool (*enc_tlb_flush_required)(bool);
	bool (*enc_cache_flush_required)(void);
	void (*enc_kexec_begin)(void);
	void (*enc_kexec_finish)(void);
};

struct x86_hybrid_pmu {
	struct pmu pmu;
	const char *name;
	enum hybrid_pmu_type pmu_type;
	cpumask_t supported_cpus;
	union perf_capabilities intel_cap;
	u64 intel_ctrl;
	u64 pebs_events_mask;
	u64 config_mask;
	union {
		u64 cntr_mask64;
		long unsigned int cntr_mask[1];
	};
	union {
		u64 fixed_cntr_mask64;
		long unsigned int fixed_cntr_mask[1];
	};
	struct event_constraint unconstrained;
	u64 hw_cache_event_ids[42];
	u64 hw_cache_extra_regs[42];
	struct event_constraint *event_constraints;
	struct event_constraint *pebs_constraints;
	struct extra_reg *extra_regs;
	unsigned int late_ack: 1;
	unsigned int mid_ack: 1;
	unsigned int enabled_ack: 1;
	u64 pebs_data_source[256];
};

struct x86_init_acpi {
	void (*set_root_pointer)(u64);
	u64 (*get_root_pointer)(void);
	void (*reduced_hw_early_init)(void);
};

struct x86_init_iommu {
	int (*iommu_init)(void);
};

struct x86_init_irqs {
	void (*pre_vector_init)(void);
	void (*intr_init)(void);
	void (*intr_mode_select)(void);
	void (*intr_mode_init)(void);
	struct irq_domain * (*create_pci_msi_domain)(void);
};

struct x86_init_mpparse {
	void (*setup_ioapic_ids)(void);
	void (*find_mptable)(void);
	void (*early_parse_smp_cfg)(void);
	void (*parse_smp_cfg)(void);
};

struct x86_init_oem {
	void (*arch_setup)(void);
	void (*banner)(void);
};

struct x86_init_resources {
	void (*probe_roms)(void);
	void (*reserve_resources)(void);
	char * (*memory_setup)(void);
	void (*dmi_setup)(void);
};

struct x86_init_paging {
	void (*pagetable_init)(void);
};

struct x86_init_timers {
	void (*setup_percpu_clockev)(void);
	void (*timer_init)(void);
	void (*wallclock_init)(void);
};

struct x86_init_pci {
	int (*arch_init)(void);
	int (*init)(void);
	void (*init_irq)(void);
	void (*fixup_irqs)(void);
};

struct x86_init_ops {
	struct x86_init_resources resources;
	struct x86_init_mpparse mpparse;
	struct x86_init_irqs irqs;
	struct x86_init_oem oem;
	struct x86_init_paging paging;
	struct x86_init_timers timers;
	struct x86_init_iommu iommu;
	struct x86_init_pci pci;
	struct x86_hyper_init hyper;
	struct x86_init_acpi acpi;
};

struct x86_legacy_devices {
	int pnpbios;
};

struct x86_legacy_features {
	enum x86_legacy_i8042_state i8042;
	int rtc;
	int warm_reset;
	int no_vga;
	int reserve_bios_regions;
	struct x86_legacy_devices devices;
};

struct x86_mapping_info {
	void * (*alloc_pgt_page)(void *);
	void (*free_pgt_page)(void *, void *);
	void *context;
	long unsigned int page_flag;
	long unsigned int offset;
	bool direct_gbpages;
	long unsigned int kernpg_flag;
};

struct x86_perf_regs {
	struct pt_regs regs;
	u64 *xmm_regs;
};

struct x86_perf_task_context_opt {
	int lbr_callstack_users;
	int lbr_stack_state;
	int log_id;
};

struct x86_perf_task_context {
	u64 lbr_sel;
	int tos;
	int valid_lbrs;
	struct x86_perf_task_context_opt opt;
	struct lbr_entry lbr[32];
};

struct x86_perf_task_context_arch_lbr {
	struct x86_perf_task_context_opt opt;
	struct lbr_entry entries[0];
};

struct x86_perf_task_context_arch_lbr_xsave {
	struct x86_perf_task_context_opt opt;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	union {
		struct xregs_state xsave;
		struct {
			struct fxregs_state i387;
			struct xstate_header header;
			struct arch_lbr_state lbr;
			long: 64;
			long: 64;
			long: 64;
		};
	};
};

struct x86_platform_ops {
	long unsigned int (*calibrate_cpu)(void);
	long unsigned int (*calibrate_tsc)(void);
	void (*get_wallclock)(struct timespec64 *);
	int (*set_wallclock)(const struct timespec64 *);
	void (*iommu_shutdown)(void);
	bool (*is_untracked_pat_range)(u64, u64);
	void (*nmi_init)(void);
	unsigned char (*get_nmi_reason)(void);
	void (*save_sched_clock_state)(void);
	void (*restore_sched_clock_state)(void);
	void (*apic_post_init)(void);
	struct x86_legacy_features legacy;
	void (*set_legacy_features)(void);
	void (*realmode_reserve)(void);
	void (*realmode_init)(void);
	struct x86_hyper_runtime hyper;
	struct x86_guest guest;
};

struct x86_pmu_quirk;

struct x86_pmu {
	const char *name;
	int version;
	int (*handle_irq)(struct pt_regs *);
	void (*disable_all)(void);
	void (*enable_all)(int);
	void (*enable)(struct perf_event *);
	void (*disable)(struct perf_event *);
	void (*assign)(struct perf_event *, int);
	void (*add)(struct perf_event *);
	void (*del)(struct perf_event *);
	void (*read)(struct perf_event *);
	int (*set_period)(struct perf_event *);
	u64 (*update)(struct perf_event *);
	int (*hw_config)(struct perf_event *);
	int (*schedule_events)(struct cpu_hw_events *, int, int *);
	unsigned int eventsel;
	unsigned int perfctr;
	unsigned int fixedctr;
	int (*addr_offset)(int, bool);
	int (*rdpmc_index)(int);
	u64 (*event_map)(int);
	int max_events;
	u64 config_mask;
	union {
		u64 cntr_mask64;
		long unsigned int cntr_mask[1];
	};
	union {
		u64 fixed_cntr_mask64;
		long unsigned int fixed_cntr_mask[1];
	};
	int cntval_bits;
	u64 cntval_mask;
	union {
		long unsigned int events_maskl;
		long unsigned int events_mask[1];
	};
	int events_mask_len;
	int apic;
	u64 max_period;
	struct event_constraint * (*get_event_constraints)(struct cpu_hw_events *, int, struct perf_event *);
	void (*put_event_constraints)(struct cpu_hw_events *, struct perf_event *);
	void (*start_scheduling)(struct cpu_hw_events *);
	void (*commit_scheduling)(struct cpu_hw_events *, int, int);
	void (*stop_scheduling)(struct cpu_hw_events *);
	struct event_constraint *event_constraints;
	struct x86_pmu_quirk *quirks;
	void (*limit_period)(struct perf_event *, s64 *);
	unsigned int late_ack: 1;
	unsigned int mid_ack: 1;
	unsigned int enabled_ack: 1;
	int attr_rdpmc_broken;
	int attr_rdpmc;
	struct attribute **format_attrs;
	ssize_t (*events_sysfs_show)(char *, u64);
	const struct attribute_group **attr_update;
	long unsigned int attr_freeze_on_smi;
	int (*cpu_prepare)(int);
	void (*cpu_starting)(int);
	void (*cpu_dying)(int);
	void (*cpu_dead)(int);
	void (*check_microcode)(void);
	void (*sched_task)(struct perf_event_pmu_context *, bool);
	u64 intel_ctrl;
	union perf_capabilities intel_cap;
	unsigned int bts: 1;
	unsigned int bts_active: 1;
	unsigned int pebs: 1;
	unsigned int pebs_active: 1;
	unsigned int pebs_broken: 1;
	unsigned int pebs_prec_dist: 1;
	unsigned int pebs_no_tlb: 1;
	unsigned int pebs_no_isolation: 1;
	unsigned int pebs_block: 1;
	unsigned int pebs_ept: 1;
	int pebs_record_size;
	int pebs_buffer_size;
	u64 pebs_events_mask;
	void (*drain_pebs)(struct pt_regs *, struct perf_sample_data *);
	struct event_constraint *pebs_constraints;
	void (*pebs_aliases)(struct perf_event *);
	u64 (*pebs_latency_data)(struct perf_event *, u64);
	long unsigned int large_pebs_flags;
	u64 rtm_abort_event;
	u64 pebs_capable;
	unsigned int lbr_tos;
	unsigned int lbr_from;
	unsigned int lbr_to;
	unsigned int lbr_info;
	unsigned int lbr_nr;
	union {
		u64 lbr_sel_mask;
		u64 lbr_ctl_mask;
	};
	union {
		const int *lbr_sel_map;
		int *lbr_ctl_map;
	};
	bool lbr_double_abort;
	bool lbr_pt_coexist;
	unsigned int lbr_has_info: 1;
	unsigned int lbr_has_tsx: 1;
	unsigned int lbr_from_flags: 1;
	unsigned int lbr_to_cycles: 1;
	unsigned int lbr_depth_mask: 8;
	unsigned int lbr_deep_c_reset: 1;
	unsigned int lbr_lip: 1;
	unsigned int lbr_cpl: 1;
	unsigned int lbr_filter: 1;
	unsigned int lbr_call_stack: 1;
	unsigned int lbr_mispred: 1;
	unsigned int lbr_timed_lbr: 1;
	unsigned int lbr_br_type: 1;
	unsigned int lbr_counters: 4;
	void (*lbr_reset)(void);
	void (*lbr_read)(struct cpu_hw_events *);
	void (*lbr_save)(void *);
	void (*lbr_restore)(void *);
	atomic_t lbr_exclusive[3];
	int num_topdown_events;
	void (*swap_task_ctx)(struct perf_event_pmu_context *, struct perf_event_pmu_context *);
	unsigned int amd_nb_constraints: 1;
	u64 perf_ctr_pair_en;
	struct extra_reg *extra_regs;
	unsigned int flags;
	struct perf_guest_switch_msr * (*guest_get_msrs)(int *, void *);
	int (*check_period)(struct perf_event *, u64);
	int (*aux_output_match)(struct perf_event *);
	void (*filter)(struct pmu *, int, bool *);
	int num_hybrid_pmus;
	struct x86_hybrid_pmu *hybrid_pmu;
	enum hybrid_cpu_type (*get_hybrid_cpu_type)(void);
};

struct x86_pmu_capability {
	int version;
	int num_counters_gp;
	int num_counters_fixed;
	int bit_width_gp;
	int bit_width_fixed;
	unsigned int events_mask;
	int events_mask_len;
	unsigned int pebs_ept: 1;
};

union x86_pmu_config {
	struct {
		u64 event: 8;
		u64 umask: 8;
		u64 usr: 1;
		u64 os: 1;
		u64 edge: 1;
		u64 pc: 1;
		u64 interrupt: 1;
		u64 __reserved1: 1;
		u64 en: 1;
		u64 inv: 1;
		u64 cmask: 8;
		u64 event2: 4;
		u64 __reserved2: 4;
		u64 go: 1;
		u64 ho: 1;
	} bits;
	u64 value;
};

struct x86_pmu_lbr {
	unsigned int nr;
	unsigned int from;
	unsigned int to;
	unsigned int info;
	bool has_callstack;
};

struct x86_pmu_quirk {
	struct x86_pmu_quirk *next;
	void (*func)(void);
};

struct x86_topology_system {
	unsigned int dom_shifts[7];
	unsigned int dom_size[7];
};

struct x86_xfeat_component {
	__u32 type;
	__u32 size;
	__u32 offset;
	__u32 flags;
};

struct xa_limit {
	u32 max;
	u32 min;
};

struct xa_node {
	unsigned char shift;
	unsigned char offset;
	unsigned char count;
	unsigned char nr_values;
	struct xa_node *parent;
	struct xarray *array;
	union {
		struct list_head private_list;
		struct callback_head callback_head;
	};
	void *slots[64];
	union {
		long unsigned int tags[3];
		long unsigned int marks[3];
	};
};

typedef void (*xa_update_node_t)(struct xa_node *);

struct xa_state {
	struct xarray *xa;
	long unsigned int xa_index;
	unsigned char xa_shift;
	unsigned char xa_sibs;
	unsigned char xa_offset;
	unsigned char xa_pad;
	struct xa_node *xa_node;
	struct xa_node *xa_alloc;
	xa_update_node_t xa_update;
	struct list_lru *xa_lru;
};

struct xattr {
	const char *name;
	void *value;
	size_t value_len;
};

struct xattr_args {
	__u64 value;
	__u32 size;
	__u32 flags;
};

struct xattr_handler {
	const char *name;
	const char *prefix;
	int flags;
	bool (*list)(struct dentry *);
	int (*get)(const struct xattr_handler *, struct dentry *, struct inode *, const char *, void *, size_t);
	int (*set)(const struct xattr_handler *, struct mnt_idmap *, struct dentry *, struct inode *, const char *, const void *, size_t, int);
};

struct xattr_name {
	char name[256];
};

struct xb1s_ff_report {
	__u8 report_id;
	__u8 enable;
	__u8 magnitude[4];
	__u8 duration_10ms;
	__u8 start_delay_10ms;
	__u8 loop_count;
};

struct xdp_attachment_info {
	struct bpf_prog *prog;
	u32 flags;
};

struct xdp_buff_xsk {
	struct xdp_buff xdp;
	u8 cb[24];
	dma_addr_t dma;
	dma_addr_t frame_dma;
	struct xsk_buff_pool *pool;
	struct list_head list_node;
	long: 64;
};

struct xdp_bulk_queue {
	void *q[8];
	struct list_head flush_node;
	struct bpf_cpu_map_entry *obj;
	unsigned int count;
};

struct xdp_cpumap_stats {
	unsigned int redirect;
	unsigned int pass;
	unsigned int drop;
};

struct xdp_desc {
	__u64 addr;
	__u32 len;
	__u32 options;
};

struct xdp_dev_bulk_queue {
	struct xdp_frame *q[16];
	struct list_head flush_node;
	struct net_device *dev;
	struct net_device *dev_rx;
	struct bpf_prog *xdp_prog;
	unsigned int count;
};

struct xdp_frame {
	void *data;
	u32 len;
	u32 headroom;
	u32 metasize;
	enum xdp_mem_type mem_type: 32;
	struct net_device *dev_rx;
	u32 frame_sz;
	u32 flags;
};

struct xdp_frame_bulk {
	int count;
	netmem_ref q[16];
};

struct xdp_mem_allocator {
	struct xdp_mem_info mem;
	union {
		void *allocator;
		struct page_pool *page_pool;
	};
	struct rhash_head node;
	struct callback_head rcu;
};

struct xdp_metadata_ops {
	int (*xmo_rx_timestamp)(const struct xdp_md *, u64 *);
	int (*xmo_rx_hash)(const struct xdp_md *, u32 *, enum xdp_rss_hash_type *);
	int (*xmo_rx_vlan_tag)(const struct xdp_md *, __be16 *, u16 *);
};

struct xdp_page_head {
	struct xdp_buff orig_ctx;
	struct xdp_buff ctx;
	union {
		struct {
			struct {} __empty_frame;
			struct xdp_frame frame[0];
		};
		struct {
			struct {} __empty_data;
			u8 data[0];
		};
	};
};

struct xsk_queue;

struct xdp_umem;

struct xdp_sock {
	struct sock sk;
	struct xsk_queue *rx;
	struct net_device *dev;
	struct xdp_umem *umem;
	struct list_head flush_node;
	struct xsk_buff_pool *pool;
	u16 queue_id;
	bool zc;
	bool sg;
	enum {
		XSK_READY = 0,
		XSK_BOUND = 1,
		XSK_UNBOUND = 2,
	} state;
	long: 64;
	struct xsk_queue *tx;
	struct list_head tx_list;
	u32 tx_budget_spent;
	spinlock_t rx_lock;
	u64 rx_dropped;
	u64 rx_queue_full;
	struct sk_buff *skb;
	struct list_head map_list;
	spinlock_t map_list_lock;
	struct mutex mutex;
	struct xsk_queue *fq_tmp;
	struct xsk_queue *cq_tmp;
};

struct xdp_test_data {
	struct xdp_buff *orig_ctx;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct xdp_rxq_info rxq;
	struct net_device *dev;
	struct page_pool *pp;
	struct xdp_frame **frames;
	struct sk_buff **skbs;
	struct xdp_mem_info mem;
	u32 batch_size;
	u32 frame_cnt;
	long: 64;
	long: 64;
};

struct xdp_txq_info {
	struct net_device *dev;
};

struct xdp_umem {
	void *addrs;
	u64 size;
	u32 headroom;
	u32 chunk_size;
	u32 chunks;
	u32 npgs;
	struct user_struct *user;
	refcount_t users;
	u8 flags;
	u8 tx_metadata_len;
	bool zc;
	struct page **pgs;
	int id;
	struct list_head xsk_dma_list;
	struct work_struct work;
};

struct xdr_skb_reader {
	struct sk_buff *skb;
	unsigned int offset;
	size_t count;
	__wsum csum;
};

struct xfrm4_protocol {
	int (*handler)(struct sk_buff *);
	int (*input_handler)(struct sk_buff *, int, __be32, int);
	int (*cb_handler)(struct sk_buff *, int);
	int (*err_handler)(struct sk_buff *, u32);
	struct xfrm4_protocol *next;
	int priority;
};

struct xfrm6_protocol {
	int (*handler)(struct sk_buff *);
	int (*input_handler)(struct sk_buff *, int, __be32, int);
	int (*cb_handler)(struct sk_buff *, int);
	int (*err_handler)(struct sk_buff *, struct inet6_skb_parm *, u8, u8, int, __be32);
	struct xfrm6_protocol *next;
	int priority;
};

struct xfrm_address_filter {
	xfrm_address_t saddr;
	xfrm_address_t daddr;
	__u16 family;
	__u8 splen;
	__u8 dplen;
};

struct xfrm_aead_name {
	const char *name;
	int icvbits;
};

struct xfrm_usersa_id {
	xfrm_address_t daddr;
	__be32 spi;
	__u16 family;
	__u8 proto;
};

struct xfrm_aevent_id {
	struct xfrm_usersa_id sa_id;
	xfrm_address_t saddr;
	__u32 flags;
	__u32 reqid;
};

struct xfrm_algo {
	char alg_name[64];
	unsigned int alg_key_len;
	char alg_key[0];
};

struct xfrm_algo_aead {
	char alg_name[64];
	unsigned int alg_key_len;
	unsigned int alg_icv_len;
	char alg_key[0];
};

struct xfrm_algo_aead_info {
	char *geniv;
	u16 icv_truncbits;
};

struct xfrm_algo_auth {
	char alg_name[64];
	unsigned int alg_key_len;
	unsigned int alg_trunc_len;
	char alg_key[0];
};

struct xfrm_algo_auth_info {
	u16 icv_truncbits;
	u16 icv_fullbits;
};

struct xfrm_algo_comp_info {
	u16 threshold;
};

struct xfrm_algo_encr_info {
	char *geniv;
	u16 blockbits;
	u16 defkeybits;
};

struct xfrm_algo_desc {
	char *name;
	char *compat;
	u8 available: 1;
	u8 pfkey_supported: 1;
	union {
		struct xfrm_algo_aead_info aead;
		struct xfrm_algo_auth_info auth;
		struct xfrm_algo_encr_info encr;
		struct xfrm_algo_comp_info comp;
	} uinfo;
	struct sadb_alg desc;
};

struct xfrm_algo_list {
	int (*find)(const char *, u32, u32);
	struct xfrm_algo_desc *algs;
	int entries;
};

struct xfrm_dev_offload {
	struct net_device *dev;
	netdevice_tracker dev_tracker;
	struct net_device *real_dev;
	long unsigned int offload_handle;
	u8 dir: 2;
	u8 type: 2;
	u8 flags: 2;
};

struct xfrm_dst {
	union {
		struct dst_entry dst;
		struct rtable rt;
		struct rt6_info rt6;
	} u;
	struct dst_entry *route;
	struct dst_entry *child;
	struct dst_entry *path;
	struct xfrm_policy *pols[2];
	int num_pols;
	int num_xfrms;
	u32 xfrm_genid;
	u32 policy_genid;
	u32 route_mtu_cached;
	u32 child_mtu_cached;
	u32 route_cookie;
	u32 path_cookie;
};

struct xfrm_dst_lookup_params {
	struct net *net;
	dscp_t dscp;
	int oif;
	xfrm_address_t *saddr;
	xfrm_address_t *daddr;
	u32 mark;
	__u8 ipproto;
	union flowi_uli uli;
};

struct xfrm_dump_info {
	struct sk_buff *in_skb;
	struct sk_buff *out_skb;
	u32 nlmsg_seq;
	u16 nlmsg_flags;
};

struct xfrm_encap_tmpl {
	__u16 encap_type;
	__be16 encap_sport;
	__be16 encap_dport;
	xfrm_address_t encap_oa;
};

struct xfrm_flo {
	struct dst_entry *dst_orig;
	u8 flags;
};

struct xfrm_flow_keys {
	struct flow_dissector_key_basic basic;
	struct flow_dissector_key_control control;
	union {
		struct flow_dissector_key_ipv4_addrs ipv4;
		struct flow_dissector_key_ipv6_addrs ipv6;
	} addrs;
	struct flow_dissector_key_ip ip;
	struct flow_dissector_key_icmp icmp;
	struct flow_dissector_key_ports ports;
	struct flow_dissector_key_keyid gre;
};

struct xfrm_hash_state_ptrs {
	const struct hlist_head *bydst;
	const struct hlist_head *bysrc;
	const struct hlist_head *byspi;
	unsigned int hmask;
};

struct xfrm_id {
	xfrm_address_t daddr;
	__be32 spi;
	__u8 proto;
};

struct xfrm_if_decode_session_result;

struct xfrm_if_cb {
	bool (*decode_session)(struct sk_buff *, short unsigned int, struct xfrm_if_decode_session_result *);
};

struct xfrm_if_decode_session_result {
	struct net *net;
	u32 if_id;
};

struct xfrm_input_afinfo {
	u8 family;
	bool is_ipip;
	int (*callback)(struct sk_buff *, u8, int);
};

struct xfrm_kmaddress {
	xfrm_address_t local;
	xfrm_address_t remote;
	u32 reserved;
	u16 family;
};

struct xfrm_lifetime_cfg {
	__u64 soft_byte_limit;
	__u64 hard_byte_limit;
	__u64 soft_packet_limit;
	__u64 hard_packet_limit;
	__u64 soft_add_expires_seconds;
	__u64 hard_add_expires_seconds;
	__u64 soft_use_expires_seconds;
	__u64 hard_use_expires_seconds;
};

struct xfrm_lifetime_cur {
	__u64 bytes;
	__u64 packets;
	__u64 add_time;
	__u64 use_time;
};

struct xfrm_link {
	int (*doit)(struct sk_buff *, struct nlmsghdr *, struct nlattr **, struct netlink_ext_ack *);
	int (*start)(struct netlink_callback *);
	int (*dump)(struct sk_buff *, struct netlink_callback *);
	int (*done)(struct netlink_callback *);
	const struct nla_policy *nla_pol;
	int nla_max;
};

struct xfrm_mark {
	__u32 v;
	__u32 m;
};

struct xfrm_tmpl;

struct xfrm_selector;

struct xfrm_migrate;

struct xfrm_mgr {
	struct list_head list;
	int (*notify)(struct xfrm_state *, const struct km_event *);
	int (*acquire)(struct xfrm_state *, struct xfrm_tmpl *, struct xfrm_policy *);
	struct xfrm_policy * (*compile_policy)(struct sock *, int, u8 *, int, int *);
	int (*new_mapping)(struct xfrm_state *, xfrm_address_t *, __be16);
	int (*notify_policy)(struct xfrm_policy *, int, const struct km_event *);
	int (*report)(struct net *, u8, struct xfrm_selector *, xfrm_address_t *);
	int (*migrate)(const struct xfrm_selector *, u8, u8, const struct xfrm_migrate *, int, const struct xfrm_kmaddress *, const struct xfrm_encap_tmpl *);
	bool (*is_alive)(const struct km_event *);
};

struct xfrm_migrate {
	xfrm_address_t old_daddr;
	xfrm_address_t old_saddr;
	xfrm_address_t new_daddr;
	xfrm_address_t new_saddr;
	u8 proto;
	u8 mode;
	u16 reserved;
	u32 reqid;
	u16 old_family;
	u16 new_family;
};

struct xfrm_mode {
	u8 encap;
	u8 family;
	u8 flags;
};

struct xfrm_mode_cbs {
	struct module *owner;
	int (*init_state)(struct xfrm_state *);
	int (*clone_state)(struct xfrm_state *, struct xfrm_state *);
	void (*destroy_state)(struct xfrm_state *);
	int (*user_init)(struct net *, struct xfrm_state *, struct nlattr **, struct netlink_ext_ack *);
	int (*copy_to_user)(struct xfrm_state *, struct sk_buff *);
	unsigned int (*sa_len)(const struct xfrm_state *);
	u32 (*get_inner_mtu)(struct xfrm_state *, int);
	int (*input)(struct xfrm_state *, struct sk_buff *);
	int (*output)(struct net *, struct sock *, struct sk_buff *);
	int (*prepare_output)(struct xfrm_state *, struct sk_buff *);
};

struct xfrm_mode_skb_cb {
	struct xfrm_tunnel_skb_cb header;
	__be16 id;
	__be16 frag_off;
	u8 ihl;
	u8 tos;
	u8 ttl;
	u8 protocol;
	u8 optlen;
	u8 flow_lbl[3];
};

struct xfrm_pol_inexact_key {
	possible_net_t net;
	u32 if_id;
	u16 family;
	u8 dir;
	u8 type;
};

struct xfrm_pol_inexact_bin {
	struct xfrm_pol_inexact_key k;
	struct rhash_head head;
	struct hlist_head hhead;
	seqcount_spinlock_t count;
	struct rb_root root_d;
	struct rb_root root_s;
	struct list_head inexact_bins;
	struct callback_head rcu;
};

struct xfrm_pol_inexact_candidates {
	struct hlist_head *res[4];
};

struct xfrm_pol_inexact_node {
	struct rb_node node;
	union {
		xfrm_address_t addr;
		struct callback_head rcu;
	};
	u8 prefixlen;
	struct rb_root root;
	struct hlist_head hhead;
};

struct xfrm_selector {
	xfrm_address_t daddr;
	xfrm_address_t saddr;
	__be16 dport;
	__be16 dport_mask;
	__be16 sport;
	__be16 sport_mask;
	__u16 family;
	__u8 prefixlen_d;
	__u8 prefixlen_s;
	__u8 proto;
	int ifindex;
	__kernel_uid32_t user;
};

struct xfrm_policy_walk_entry {
	struct list_head all;
	u8 dead;
};

struct xfrm_policy_queue {
	struct sk_buff_head hold_queue;
	struct timer_list hold_timer;
	long unsigned int timeout;
};

struct xfrm_tmpl {
	struct xfrm_id id;
	xfrm_address_t saddr;
	short unsigned int encap_family;
	u32 reqid;
	u8 mode;
	u8 share;
	u8 optional;
	u8 allalgs;
	u32 aalgos;
	u32 ealgos;
	u32 calgos;
};

struct xfrm_sec_ctx;

struct xfrm_policy {
	possible_net_t xp_net;
	struct hlist_node bydst;
	struct hlist_node byidx;
	struct hlist_head state_cache_list;
	rwlock_t lock;
	refcount_t refcnt;
	u32 pos;
	struct timer_list timer;
	atomic_t genid;
	u32 priority;
	u32 index;
	u32 if_id;
	struct xfrm_mark mark;
	struct xfrm_selector selector;
	struct xfrm_lifetime_cfg lft;
	struct xfrm_lifetime_cur curlft;
	struct xfrm_policy_walk_entry walk;
	struct xfrm_policy_queue polq;
	bool bydst_reinsert;
	u8 type;
	u8 action;
	u8 flags;
	u8 xfrm_nr;
	u16 family;
	struct xfrm_sec_ctx *security;
	struct xfrm_tmpl xfrm_vec[6];
	struct callback_head rcu;
	struct xfrm_dev_offload xdo;
};

struct xfrm_policy_afinfo {
	struct dst_ops *dst_ops;
	struct dst_entry * (*dst_lookup)(const struct xfrm_dst_lookup_params *);
	int (*get_saddr)(xfrm_address_t *, const struct xfrm_dst_lookup_params *);
	int (*fill_dst)(struct xfrm_dst *, struct net_device *, const struct flowi *);
	struct dst_entry * (*blackhole_route)(struct net *, struct dst_entry *);
};

struct xfrm_policy_walk {
	struct xfrm_policy_walk_entry walk;
	u8 type;
	u32 seq;
};

struct xfrm_replay_state {
	__u32 oseq;
	__u32 seq;
	__u32 bitmap;
};

struct xfrm_replay_state_esn {
	unsigned int bmp_len;
	__u32 oseq;
	__u32 seq;
	__u32 oseq_hi;
	__u32 seq_hi;
	__u32 replay_window;
	__u32 bmp[0];
};

struct xfrm_sec_ctx {
	__u8 ctx_doi;
	__u8 ctx_alg;
	__u16 ctx_len;
	__u32 ctx_sid;
	char ctx_str[0];
};

struct xfrm_spi_skb_cb {
	struct xfrm_tunnel_skb_cb header;
	unsigned int daddroff;
	unsigned int family;
	__be32 seq;
};

struct xfrm_state_walk {
	struct list_head all;
	u8 state;
	u8 dying;
	u8 proto;
	u32 seq;
	struct xfrm_address_filter *filter;
};

struct xfrm_stats {
	__u32 replay_window;
	__u32 replay;
	__u32 integrity_failed;
};

struct xfrm_type;

struct xfrm_type_offload;

struct xfrm_state {
	possible_net_t xs_net;
	union {
		struct hlist_node gclist;
		struct hlist_node bydst;
	};
	union {
		struct hlist_node dev_gclist;
		struct hlist_node bysrc;
	};
	struct hlist_node byspi;
	struct hlist_node byseq;
	struct hlist_node state_cache;
	struct hlist_node state_cache_input;
	refcount_t refcnt;
	spinlock_t lock;
	u32 pcpu_num;
	struct xfrm_id id;
	struct xfrm_selector sel;
	struct xfrm_mark mark;
	u32 if_id;
	u32 tfcpad;
	u32 genid;
	struct xfrm_state_walk km;
	struct {
		u32 reqid;
		u8 mode;
		u8 replay_window;
		u8 aalgo;
		u8 ealgo;
		u8 calgo;
		u8 flags;
		u16 family;
		xfrm_address_t saddr;
		int header_len;
		int enc_hdr_len;
		int trailer_len;
		u32 extra_flags;
		struct xfrm_mark smark;
	} props;
	struct xfrm_lifetime_cfg lft;
	struct xfrm_algo_auth *aalg;
	struct xfrm_algo *ealg;
	struct xfrm_algo *calg;
	struct xfrm_algo_aead *aead;
	const char *geniv;
	__be16 new_mapping_sport;
	u32 new_mapping;
	u32 mapping_maxage;
	struct xfrm_encap_tmpl *encap;
	struct sock *encap_sk;
	u32 nat_keepalive_interval;
	time64_t nat_keepalive_expiration;
	xfrm_address_t *coaddr;
	struct xfrm_state *tunnel;
	atomic_t tunnel_users;
	struct xfrm_replay_state replay;
	struct xfrm_replay_state_esn *replay_esn;
	struct xfrm_replay_state preplay;
	struct xfrm_replay_state_esn *preplay_esn;
	enum xfrm_replay_mode repl_mode;
	u32 xflags;
	u32 replay_maxage;
	u32 replay_maxdiff;
	struct timer_list rtimer;
	struct xfrm_stats stats;
	struct xfrm_lifetime_cur curlft;
	struct hrtimer mtimer;
	struct xfrm_dev_offload xso;
	long int saved_tmo;
	time64_t lastused;
	struct page_frag xfrag;
	const struct xfrm_type *type;
	struct xfrm_mode inner_mode;
	struct xfrm_mode inner_mode_iaf;
	struct xfrm_mode outer_mode;
	const struct xfrm_type_offload *type_offload;
	struct xfrm_sec_ctx *security;
	void *data;
	u8 dir;
	const struct xfrm_mode_cbs *mode_cbs;
	void *mode_data;
};

struct xfrm_state_afinfo {
	u8 family;
	u8 proto;
	const struct xfrm_type_offload *type_offload_esp;
	const struct xfrm_type *type_esp;
	const struct xfrm_type *type_ipip;
	const struct xfrm_type *type_ipip6;
	const struct xfrm_type *type_comp;
	const struct xfrm_type *type_ah;
	const struct xfrm_type *type_routing;
	const struct xfrm_type *type_dstopts;
	int (*output)(struct net *, struct sock *, struct sk_buff *);
	int (*transport_finish)(struct sk_buff *, int);
	void (*local_error)(struct sk_buff *, u32);
};

struct xfrm_trans_cb {
	union {
		struct inet_skb_parm h4;
		struct inet6_skb_parm h6;
	} header;
	int (*finish)(struct net *, struct sock *, struct sk_buff *);
	struct net *net;
};

struct xfrm_trans_tasklet {
	struct work_struct work;
	spinlock_t queue_lock;
	struct sk_buff_head queue;
};

struct xfrm_translator {
	int (*alloc_compat)(struct sk_buff *, const struct nlmsghdr *);
	struct nlmsghdr * (*rcv_msg_compat)(const struct nlmsghdr *, int, const struct nla_policy *, struct netlink_ext_ack *);
	int (*xlate_user_policy_sockptr)(u8 **, int);
	struct module *owner;
};

struct xfrm_tunnel {
	int (*handler)(struct sk_buff *);
	int (*cb_handler)(struct sk_buff *, int);
	int (*err_handler)(struct sk_buff *, u32);
	struct xfrm_tunnel *next;
	int priority;
};

struct xfrm_type {
	struct module *owner;
	u8 proto;
	u8 flags;
	int (*init_state)(struct xfrm_state *, struct netlink_ext_ack *);
	void (*destructor)(struct xfrm_state *);
	int (*input)(struct xfrm_state *, struct sk_buff *);
	int (*output)(struct xfrm_state *, struct sk_buff *);
	int (*reject)(struct xfrm_state *, struct sk_buff *, const struct flowi *);
};

struct xfrm_type_offload {
	struct module *owner;
	u8 proto;
	void (*encap)(struct xfrm_state *, struct sk_buff *);
	int (*input_tail)(struct xfrm_state *, struct sk_buff *);
	int (*xmit)(struct xfrm_state *, struct sk_buff *, netdev_features_t);
};

struct xfrm_userpolicy_info {
	struct xfrm_selector sel;
	struct xfrm_lifetime_cfg lft;
	struct xfrm_lifetime_cur curlft;
	__u32 priority;
	__u32 index;
	__u8 dir;
	__u8 action;
	__u8 flags;
	__u8 share;
};

struct xfrm_user_acquire {
	struct xfrm_id id;
	xfrm_address_t saddr;
	struct xfrm_selector sel;
	struct xfrm_userpolicy_info policy;
	__u32 aalgos;
	__u32 ealgos;
	__u32 calgos;
	__u32 seq;
};

struct xfrm_usersa_info {
	struct xfrm_selector sel;
	struct xfrm_id id;
	xfrm_address_t saddr;
	struct xfrm_lifetime_cfg lft;
	struct xfrm_lifetime_cur curlft;
	struct xfrm_stats stats;
	__u32 seq;
	__u32 reqid;
	__u16 family;
	__u8 mode;
	__u8 replay_window;
	__u8 flags;
};

struct xfrm_user_expire {
	struct xfrm_usersa_info state;
	__u8 hard;
};

struct xfrm_user_mapping {
	struct xfrm_usersa_id id;
	__u32 reqid;
	xfrm_address_t old_saddr;
	xfrm_address_t new_saddr;
	__be16 old_sport;
	__be16 new_sport;
};

struct xfrm_user_offload {
	int ifindex;
	__u8 flags;
};

struct xfrm_user_polexpire {
	struct xfrm_userpolicy_info pol;
	__u8 hard;
};

struct xfrm_user_report {
	__u8 proto;
	struct xfrm_selector sel;
};

struct xfrm_user_sec_ctx {
	__u16 len;
	__u16 exttype;
	__u8 ctx_alg;
	__u8 ctx_doi;
	__u16 ctx_len;
};

struct xfrm_user_tmpl {
	struct xfrm_id id;
	__u16 family;
	xfrm_address_t saddr;
	__u32 reqid;
	__u8 mode;
	__u8 share;
	__u8 optional;
	__u32 aalgos;
	__u32 ealgos;
	__u32 calgos;
};

struct xfrm_userpolicy_default {
	__u8 in;
	__u8 fwd;
	__u8 out;
};

struct xfrm_userpolicy_id {
	struct xfrm_selector sel;
	__u32 index;
	__u8 dir;
};

struct xfrm_userpolicy_type {
	__u8 type;
	__u16 reserved1;
	__u8 reserved2;
};

struct xfrm_usersa_flush {
	__u8 proto;
};

struct xfrm_userspi_info {
	struct xfrm_usersa_info info;
	__u32 min;
	__u32 max;
};

struct xfrmk_sadinfo {
	u32 sadhcnt;
	u32 sadhmcnt;
	u32 sadcnt;
};

struct xfrmk_spdinfo {
	u32 incnt;
	u32 outcnt;
	u32 fwdcnt;
	u32 inscnt;
	u32 outscnt;
	u32 fwdscnt;
	u32 spdhcnt;
	u32 spdhmcnt;
};

struct xfrmu_sadhinfo {
	__u32 sadhcnt;
	__u32 sadhmcnt;
};

struct xfrmu_spdhinfo {
	__u32 spdhcnt;
	__u32 spdhmcnt;
};

struct xfrmu_spdhthresh {
	__u8 lbits;
	__u8 rbits;
};

struct xfrmu_spdinfo {
	__u32 incnt;
	__u32 outcnt;
	__u32 fwdcnt;
	__u32 inscnt;
	__u32 outscnt;
	__u32 fwdscnt;
};

struct xhci_bus_state {
	long unsigned int bus_suspended;
	long unsigned int next_statechange;
	u32 port_c_suspend;
	u32 suspended_ports;
	u32 port_remote_wakeup;
	long unsigned int resuming_ports;
};

struct xhci_bw_info {
	unsigned int ep_interval;
	unsigned int mult;
	unsigned int num_packets;
	unsigned int max_packet_size;
	unsigned int max_esit_payload;
	unsigned int type;
};

struct xhci_cap_regs {
	__le32 hc_capbase;
	__le32 hcs_params1;
	__le32 hcs_params2;
	__le32 hcs_params3;
	__le32 hcc_params;
	__le32 db_off;
	__le32 run_regs_off;
	__le32 hcc_params2;
};

struct xhci_container_ctx;

struct xhci_command {
	struct xhci_container_ctx *in_ctx;
	u32 status;
	u32 comp_param;
	int slot_id;
	struct completion *completion;
	union xhci_trb *command_trb;
	struct list_head cmd_list;
	unsigned int timeout_ms;
};

struct xhci_container_ctx {
	unsigned int type;
	int size;
	u8 *bytes;
	dma_addr_t dma;
};

struct xhci_erst_entry;

struct xhci_erst {
	struct xhci_erst_entry *entries;
	unsigned int num_entries;
	dma_addr_t erst_dma_addr;
};

struct xhci_hcd;

struct xhci_dbc {
	spinlock_t lock;
	struct device *dev;
	struct xhci_hcd *xhci;
	struct dbc_regs *regs;
	struct xhci_ring *ring_evt;
	struct xhci_ring *ring_in;
	struct xhci_ring *ring_out;
	struct xhci_erst erst;
	struct xhci_container_ctx *ctx;
	struct dbc_str_descs *string;
	dma_addr_t string_dma;
	size_t string_size;
	u16 idVendor;
	u16 idProduct;
	u16 bcdDevice;
	u8 bInterfaceProtocol;
	enum dbc_state state;
	struct delayed_work event_work;
	unsigned int poll_interval;
	unsigned int resume_required: 1;
	struct dbc_ep eps[2];
	const struct dbc_driver *driver;
	void *priv;
};

struct xhci_device_context_array {
	__le64 dev_context_ptrs[256];
	dma_addr_t dma;
};

struct xhci_doorbell_array {
	__le32 doorbell[256];
};

struct xhci_driver_overrides {
	size_t extra_priv_size;
	int (*reset)(struct usb_hcd *);
	int (*start)(struct usb_hcd *);
	int (*add_endpoint)(struct usb_hcd *, struct usb_device *, struct usb_host_endpoint *);
	int (*drop_endpoint)(struct usb_hcd *, struct usb_device *, struct usb_host_endpoint *);
	int (*check_bandwidth)(struct usb_hcd *, struct usb_device *);
	void (*reset_bandwidth)(struct usb_hcd *, struct usb_device *);
	int (*update_hub_device)(struct usb_hcd *, struct usb_device *, struct usb_tt *, gfp_t);
	int (*hub_control)(struct usb_hcd *, u16, u16, u16, char *, u16);
};

struct xhci_ep_ctx {
	__le32 ep_info;
	__le32 ep_info2;
	__le64 deq;
	__le32 tx_info;
	__le32 reserved[3];
};

struct xhci_stream_info;

struct xhci_ep_priv {
	char name[32];
	struct dentry *root;
	struct xhci_stream_info *stream_info;
	struct xhci_ring *show_ring;
	unsigned int stream_id;
};

struct xhci_erst_entry {
	__le64 seg_addr;
	__le32 seg_size;
	__le32 rsvd;
};

struct xhci_event_cmd {
	__le64 cmd_trb;
	__le32 status;
	__le32 flags;
};

struct xhci_file_map {
	const char *name;
	int (*show)(struct seq_file *, void *);
};

struct xhci_generic_trb {
	__le32 field[4];
};

struct xhci_port;

struct xhci_hub {
	struct xhci_port **ports;
	unsigned int num_ports;
	struct usb_hcd *hcd;
	struct xhci_bus_state bus_state;
	u8 maj_rev;
	u8 min_rev;
};

struct xhci_op_regs;

struct xhci_run_regs;

struct xhci_interrupter;

struct xhci_scratchpad;

struct xhci_virt_device;

struct xhci_root_port_bw_info;

struct xhci_port_cap;

struct xhci_hcd {
	struct usb_hcd *main_hcd;
	struct usb_hcd *shared_hcd;
	struct xhci_cap_regs *cap_regs;
	struct xhci_op_regs *op_regs;
	struct xhci_run_regs *run_regs;
	struct xhci_doorbell_array *dba;
	__u32 hcs_params1;
	__u32 hcs_params2;
	__u32 hcs_params3;
	__u32 hcc_params;
	__u32 hcc_params2;
	spinlock_t lock;
	u16 hci_version;
	u16 max_interrupters;
	u32 imod_interval;
	int page_size;
	int page_shift;
	int nvecs;
	struct clk *clk;
	struct clk *reg_clk;
	struct reset_control *reset;
	struct xhci_device_context_array *dcbaa;
	struct xhci_interrupter **interrupters;
	struct xhci_ring *cmd_ring;
	unsigned int cmd_ring_state;
	struct list_head cmd_list;
	unsigned int cmd_ring_reserved_trbs;
	struct delayed_work cmd_timer;
	struct completion cmd_ring_stop_completion;
	struct xhci_command *current_cmd;
	struct xhci_scratchpad *scratchpad;
	struct mutex mutex;
	struct xhci_virt_device *devs[256];
	struct xhci_root_port_bw_info *rh_bw;
	struct dma_pool *device_pool;
	struct dma_pool *segment_pool;
	struct dma_pool *small_streams_pool;
	struct dma_pool *medium_streams_pool;
	unsigned int xhc_state;
	long unsigned int run_graceperiod;
	struct s3_save s3;
	long long unsigned int quirks;
	unsigned int num_active_eps;
	unsigned int limit_active_eps;
	struct xhci_port *hw_ports;
	struct xhci_hub usb2_rhub;
	struct xhci_hub usb3_rhub;
	unsigned int hw_lpm_support: 1;
	unsigned int broken_suspend: 1;
	unsigned int allow_single_roothub: 1;
	struct xhci_port_cap *port_caps;
	unsigned int num_port_caps;
	struct timer_list comp_mode_recovery_timer;
	u32 port_status_u0;
	u16 test_mode;
	struct dentry *debugfs_root;
	struct dentry *debugfs_slots;
	struct list_head regset_list;
	void *dbc;
	long unsigned int priv[0];
};

struct xhci_input_control_ctx {
	__le32 drop_flags;
	__le32 add_flags;
	__le32 rsvd2[6];
};

struct xhci_intr_reg;

struct xhci_interrupter {
	struct xhci_ring *event_ring;
	struct xhci_erst erst;
	struct xhci_intr_reg *ir_set;
	unsigned int intr_num;
	bool ip_autoclear;
	u32 isoc_bei_interval;
	u32 s3_irq_pending;
	u32 s3_irq_control;
	u32 s3_erst_size;
	u64 s3_erst_base;
	u64 s3_erst_dequeue;
};

struct xhci_interval_bw {
	unsigned int num_packets;
	struct list_head endpoints;
	unsigned int overhead[3];
};

struct xhci_interval_bw_table {
	unsigned int interval0_esit_payload;
	struct xhci_interval_bw interval_bw[16];
	unsigned int bw_used;
	unsigned int ss_bw_in;
	unsigned int ss_bw_out;
};

struct xhci_intr_reg {
	__le32 irq_pending;
	__le32 irq_control;
	__le32 erst_size;
	__le32 rsvd;
	__le64 erst_base;
	__le64 erst_dequeue;
};

struct xhci_link_trb {
	__le64 segment_ptr;
	__le32 intr_target;
	__le32 control;
};

struct xhci_op_regs {
	__le32 command;
	__le32 status;
	__le32 page_size;
	__le32 reserved1;
	__le32 reserved2;
	__le32 dev_notification;
	__le64 cmd_ring;
	__le32 reserved3[4];
	__le64 dcbaa_ptr;
	__le32 config_reg;
	__le32 reserved4[241];
	__le32 port_status_base;
	__le32 port_power_base;
	__le32 port_link_base;
	__le32 reserved5;
	__le32 reserved6[1016];
};

struct xhci_port {
	__le32 *addr;
	int hw_portnum;
	int hcd_portnum;
	struct xhci_hub *rhub;
	struct xhci_port_cap *port_cap;
	unsigned int lpm_incapable: 1;
	long unsigned int resume_timestamp;
	bool rexit_active;
	int slot_id;
	struct completion rexit_done;
	struct completion u3exit_done;
};

struct xhci_port_cap {
	u32 *psi;
	u8 psi_count;
	u8 psi_uid_count;
	u8 maj_rev;
	u8 min_rev;
	u32 protocol_caps;
};

struct xhci_regset {
	char name[32];
	struct debugfs_regset32 regset;
	size_t nregs;
	struct list_head list;
};

struct xhci_ring {
	struct xhci_segment *first_seg;
	struct xhci_segment *last_seg;
	union xhci_trb *enqueue;
	struct xhci_segment *enq_seg;
	union xhci_trb *dequeue;
	struct xhci_segment *deq_seg;
	struct list_head td_list;
	u32 cycle_state;
	unsigned int stream_id;
	unsigned int num_segs;
	unsigned int num_trbs_free;
	unsigned int bounce_buf_len;
	enum xhci_ring_type type;
	bool last_td_was_short;
	struct xarray *trb_address_map;
};

struct xhci_root_port_bw_info {
	struct list_head tts;
	unsigned int num_active_tts;
	struct xhci_interval_bw_table bw_table;
};

struct xhci_run_regs {
	__le32 microframe_index;
	__le32 rsvd[7];
	struct xhci_intr_reg ir_set[128];
};

struct xhci_scratchpad {
	u64 *sp_array;
	dma_addr_t sp_dma;
	void **sp_buffers;
};

struct xhci_segment {
	union xhci_trb *trbs;
	struct xhci_segment *next;
	unsigned int num;
	dma_addr_t dma;
	dma_addr_t bounce_dma;
	void *bounce_buf;
	unsigned int bounce_offs;
	unsigned int bounce_len;
};

struct xhci_slot_ctx {
	__le32 dev_info;
	__le32 dev_info2;
	__le32 tt_info;
	__le32 dev_state;
	__le32 reserved[4];
};

struct xhci_slot_priv {
	char name[32];
	struct dentry *root;
	struct xhci_ep_priv *eps[31];
	struct xhci_virt_device *dev;
};

struct xhci_stream_ctx {
	__le64 stream_ring;
	__le32 reserved[2];
};

struct xhci_stream_info {
	struct xhci_ring **stream_rings;
	unsigned int num_streams;
	struct xhci_stream_ctx *stream_ctx_array;
	unsigned int num_stream_ctxs;
	dma_addr_t ctx_array_dma;
	struct xarray trb_address_map;
	struct xhci_command *free_streams_command;
};

struct xhci_transfer_event {
	__le64 buffer;
	__le32 transfer_len;
	__le32 flags;
};

union xhci_trb {
	struct xhci_link_trb link;
	struct xhci_transfer_event trans_event;
	struct xhci_event_cmd event_cmd;
	struct xhci_generic_trb generic;
};

struct xhci_tt_bw_info {
	struct list_head tt_list;
	int slot_id;
	int ttport;
	struct xhci_interval_bw_table bw_table;
	int active_eps;
};

struct xhci_virt_ep {
	struct xhci_virt_device *vdev;
	unsigned int ep_index;
	struct xhci_ring *ring;
	struct xhci_stream_info *stream_info;
	struct xhci_ring *new_ring;
	unsigned int err_count;
	unsigned int ep_state;
	struct list_head cancelled_td_list;
	struct xhci_hcd *xhci;
	struct xhci_segment *queued_deq_seg;
	union xhci_trb *queued_deq_ptr;
	bool skip;
	struct xhci_bw_info bw_info;
	struct list_head bw_endpoint_list;
	long unsigned int stop_time;
	int next_frame_id;
	bool use_extended_tbc;
};

struct xhci_virt_device {
	int slot_id;
	struct usb_device *udev;
	struct xhci_container_ctx *out_ctx;
	struct xhci_container_ctx *in_ctx;
	struct xhci_virt_ep eps[31];
	struct xhci_port *rhub_port;
	struct xhci_interval_bw_table *bw_table;
	struct xhci_tt_bw_info *tt_info;
	long unsigned int flags;
	u16 current_mel;
	void *debugfs_private;
};

struct xol_area {
	wait_queue_head_t wq;
	long unsigned int *bitmap;
	struct page *page;
	long unsigned int vaddr;
};

struct xprt_addr {
	const char *addr;
	struct callback_head rcu;
};

struct xprt_create;

struct xprt_class {
	struct list_head list;
	int ident;
	struct rpc_xprt * (*setup)(struct xprt_create *);
	struct module *owner;
	char name[32];
	const char *netid[0];
};

struct xprt_create {
	int ident;
	struct net *net;
	struct sockaddr *srcaddr;
	struct sockaddr *dstaddr;
	size_t addrlen;
	const char *servername;
	struct svc_xprt *bc_xprt;
	struct rpc_xprt_switch *bc_xps;
	unsigned int flags;
	struct xprtsec_parms xprtsec;
	long unsigned int connect_timeout;
	long unsigned int reconnect_timeout;
};

struct xps_map;

struct xps_dev_maps {
	struct callback_head rcu;
	unsigned int nr_ids;
	s16 num_tc;
	struct xps_map *attr_map[0];
};

struct xps_map {
	unsigned int len;
	unsigned int alloc_len;
	struct callback_head rcu;
	u16 queues[0];
};

struct xsk_buff_pool {
	struct device *dev;
	struct net_device *netdev;
	struct list_head xsk_tx_list;
	spinlock_t xsk_tx_list_lock;
	refcount_t users;
	struct xdp_umem *umem;
	struct work_struct work;
	struct list_head free_list;
	struct list_head xskb_list;
	u32 heads_cnt;
	u16 queue_id;
	long: 64;
	struct xsk_queue *fq;
	struct xsk_queue *cq;
	dma_addr_t *dma_pages;
	struct xdp_buff_xsk *heads;
	struct xdp_desc *tx_descs;
	u64 chunk_mask;
	u64 addrs_cnt;
	u32 free_list_cnt;
	u32 dma_pages_cnt;
	u32 free_heads_cnt;
	u32 headroom;
	u32 chunk_size;
	u32 chunk_shift;
	u32 frame_len;
	u32 xdp_zc_max_segs;
	u8 tx_metadata_len;
	u8 cached_need_wakeup;
	bool uses_need_wakeup;
	bool unaligned;
	bool tx_sw_csum;
	void *addrs;
	spinlock_t cq_lock;
	struct xdp_buff_xsk *free_heads[0];
	long: 64;
	long: 64;
};

struct xsk_tx_metadata_ops {
	void (*tmo_request_timestamp)(void *);
	u64 (*tmo_fill_timestamp)(void *);
	void (*tmo_request_checksum)(u16, u16, void *);
};

struct xt_match;

struct xt_action_param {
	union {
		const struct xt_match *match;
		const struct xt_target *target;
	};
	union {
		const void *matchinfo;
		const void *targinfo;
	};
	const struct nf_hook_state *state;
	unsigned int thoff;
	u16 fragoff;
	bool hotdrop;
};

struct xt_af {
	struct mutex mutex;
	struct list_head match;
	struct list_head target;
};

struct xt_connsecmark_target_info {
	__u8 mode;
};

struct xt_conntrack_mtinfo1 {
	union nf_inet_addr origsrc_addr;
	union nf_inet_addr origsrc_mask;
	union nf_inet_addr origdst_addr;
	union nf_inet_addr origdst_mask;
	union nf_inet_addr replsrc_addr;
	union nf_inet_addr replsrc_mask;
	union nf_inet_addr repldst_addr;
	union nf_inet_addr repldst_mask;
	__u32 expires_min;
	__u32 expires_max;
	__u16 l4proto;
	__be16 origsrc_port;
	__be16 origdst_port;
	__be16 replsrc_port;
	__be16 repldst_port;
	__u16 match_flags;
	__u16 invert_flags;
	__u8 state_mask;
	__u8 status_mask;
};

struct xt_conntrack_mtinfo2 {
	union nf_inet_addr origsrc_addr;
	union nf_inet_addr origsrc_mask;
	union nf_inet_addr origdst_addr;
	union nf_inet_addr origdst_mask;
	union nf_inet_addr replsrc_addr;
	union nf_inet_addr replsrc_mask;
	union nf_inet_addr repldst_addr;
	union nf_inet_addr repldst_mask;
	__u32 expires_min;
	__u32 expires_max;
	__u16 l4proto;
	__be16 origsrc_port;
	__be16 origdst_port;
	__be16 replsrc_port;
	__be16 repldst_port;
	__u16 match_flags;
	__u16 invert_flags;
	__u16 state_mask;
	__u16 status_mask;
};

struct xt_conntrack_mtinfo3 {
	union nf_inet_addr origsrc_addr;
	union nf_inet_addr origsrc_mask;
	union nf_inet_addr origdst_addr;
	union nf_inet_addr origdst_mask;
	union nf_inet_addr replsrc_addr;
	union nf_inet_addr replsrc_mask;
	union nf_inet_addr repldst_addr;
	union nf_inet_addr repldst_mask;
	__u32 expires_min;
	__u32 expires_max;
	__u16 l4proto;
	__u16 origsrc_port;
	__u16 origdst_port;
	__u16 replsrc_port;
	__u16 repldst_port;
	__u16 match_flags;
	__u16 invert_flags;
	__u16 state_mask;
	__u16 status_mask;
	__u16 origsrc_port_high;
	__u16 origdst_port_high;
	__u16 replsrc_port_high;
	__u16 repldst_port_high;
};

struct xt_counters_info {
	char name[32];
	unsigned int num_counters;
	struct xt_counters counters[0];
};

struct xt_entry_match {
	union {
		struct {
			__u16 match_size;
			char name[29];
			__u8 revision;
		} user;
		struct {
			__u16 match_size;
			struct xt_match *match;
		} kernel;
		__u16 match_size;
	} u;
	unsigned char data[0];
};

struct xt_get_revision {
	char name[29];
	__u8 revision;
};

struct xt_mtchk_param;

struct xt_mtdtor_param;

struct xt_match {
	struct list_head list;
	const char name[29];
	u_int8_t revision;
	bool (*match)(const struct sk_buff *, struct xt_action_param *);
	int (*checkentry)(const struct xt_mtchk_param *);
	void (*destroy)(const struct xt_mtdtor_param *);
	struct module *me;
	const char *table;
	unsigned int matchsize;
	unsigned int usersize;
	unsigned int hooks;
	short unsigned int proto;
	short unsigned int family;
};

struct xt_mtchk_param {
	struct net *net;
	const char *table;
	const void *entryinfo;
	const struct xt_match *match;
	void *matchinfo;
	unsigned int hook_mask;
	u_int8_t family;
	bool nft_compat;
};

struct xt_mtdtor_param {
	struct net *net;
	const struct xt_match *match;
	void *matchinfo;
	u_int8_t family;
};

struct xt_nflog_info {
	__u32 len;
	__u16 group;
	__u16 threshold;
	__u16 flags;
	__u16 pad;
	char prefix[64];
};

struct xt_percpu_counter_alloc_state {
	unsigned int off;
	const char *mem;
};

struct xt_pernet {
	struct list_head tables[11];
};

struct xt_policy_spec {
	__u8 saddr: 1;
	__u8 daddr: 1;
	__u8 proto: 1;
	__u8 mode: 1;
	__u8 spi: 1;
	__u8 reqid: 1;
};

struct xt_policy_elem {
	union {
		struct {
			union nf_inet_addr saddr;
			union nf_inet_addr smask;
			union nf_inet_addr daddr;
			union nf_inet_addr dmask;
		};
	};
	__be32 spi;
	__u32 reqid;
	__u8 proto;
	__u8 mode;
	struct xt_policy_spec match;
	struct xt_policy_spec invert;
};

struct xt_policy_info {
	struct xt_policy_elem pol[4];
	__u16 flags;
	__u16 len;
};

struct xt_secmark_target_info {
	__u8 mode;
	__u32 secid;
	char secctx[256];
};

struct xt_secmark_target_info_v1 {
	__u8 mode;
	char secctx[256];
	__u32 secid;
};

struct xt_state_info {
	unsigned int statemask;
};

struct xt_table_info;

struct xt_table {
	struct list_head list;
	unsigned int valid_hooks;
	struct xt_table_info *private;
	struct nf_hook_ops *ops;
	struct module *me;
	u_int8_t af;
	int priority;
	const char name[32];
};

struct xt_table_info {
	unsigned int size;
	unsigned int number;
	unsigned int initial_entries;
	unsigned int hook_entry[5];
	unsigned int underflow[5];
	unsigned int stacksize;
	void ***jumpstack;
	unsigned char entries[0];
};

struct xt_tgchk_param;

struct xt_tgdtor_param;

struct xt_target {
	struct list_head list;
	const char name[29];
	u_int8_t revision;
	unsigned int (*target)(struct sk_buff *, const struct xt_action_param *);
	int (*checkentry)(const struct xt_tgchk_param *);
	void (*destroy)(const struct xt_tgdtor_param *);
	struct module *me;
	const char *table;
	unsigned int targetsize;
	unsigned int usersize;
	unsigned int hooks;
	short unsigned int proto;
	short unsigned int family;
};

struct xt_tcp {
	__u16 spts[2];
	__u16 dpts[2];
	__u8 option;
	__u8 flg_mask;
	__u8 flg_cmp;
	__u8 invflags;
};

struct xt_tcpmss_info {
	__u16 mss;
};

struct xt_template {
	struct list_head list;
	int (*table_init)(struct net *);
	struct module *me;
	char name[32];
};

struct xt_tgchk_param {
	struct net *net;
	const char *table;
	const void *entryinfo;
	const struct xt_target *target;
	void *targinfo;
	unsigned int hook_mask;
	u_int8_t family;
	bool nft_compat;
};

struct xt_tgdtor_param {
	struct net *net;
	const struct xt_target *target;
	void *targinfo;
	u_int8_t family;
};

struct xt_udp {
	__u16 spts[2];
	__u16 dpts[2];
	__u8 invflags;
};

struct xxh32_state {
	uint32_t total_len_32;
	uint32_t large_len;
	uint32_t v1;
	uint32_t v2;
	uint32_t v3;
	uint32_t v4;
	uint32_t mem32[4];
	uint32_t memsize;
};

struct xz_buf {
	const uint8_t *in;
	size_t in_pos;
	size_t in_size;
	uint8_t *out;
	size_t out_pos;
	size_t out_size;
};

struct xz_dec_hash {
	vli_type unpadded;
	vli_type uncompressed;
	uint32_t crc32;
};

struct xz_dec_lzma2;

struct xz_dec_bcj;

struct xz_dec {
	enum {
		SEQ_STREAM_HEADER = 0,
		SEQ_BLOCK_START = 1,
		SEQ_BLOCK_HEADER = 2,
		SEQ_BLOCK_UNCOMPRESS = 3,
		SEQ_BLOCK_PADDING = 4,
		SEQ_BLOCK_CHECK = 5,
		SEQ_INDEX = 6,
		SEQ_INDEX_PADDING = 7,
		SEQ_INDEX_CRC32 = 8,
		SEQ_STREAM_FOOTER = 9,
	} sequence;
	uint32_t pos;
	vli_type vli;
	size_t in_start;
	size_t out_start;
	uint32_t crc32;
	enum xz_check check_type;
	enum xz_mode mode;
	bool allow_buf_error;
	struct {
		vli_type compressed;
		vli_type uncompressed;
		uint32_t size;
	} block_header;
	struct {
		vli_type compressed;
		vli_type uncompressed;
		vli_type count;
		struct xz_dec_hash hash;
	} block;
	struct {
		enum {
			SEQ_INDEX_COUNT = 0,
			SEQ_INDEX_UNPADDED = 1,
			SEQ_INDEX_UNCOMPRESSED = 2,
		} sequence;
		vli_type size;
		vli_type count;
		struct xz_dec_hash hash;
	} index;
	struct {
		size_t pos;
		size_t size;
		uint8_t buf[1024];
	} temp;
	struct xz_dec_lzma2 *lzma2;
	struct xz_dec_bcj *bcj;
	bool bcj_active;
};

struct xz_dec_bcj {
	enum {
		BCJ_X86 = 4,
		BCJ_POWERPC = 5,
		BCJ_IA64 = 6,
		BCJ_ARM = 7,
		BCJ_ARMTHUMB = 8,
		BCJ_SPARC = 9,
		BCJ_ARM64 = 10,
		BCJ_RISCV = 11,
	} type;
	enum xz_ret ret;
	bool single_call;
	uint32_t pos;
	uint32_t x86_prev_mask;
	uint8_t *out;
	size_t out_pos;
	size_t out_size;
	struct {
		size_t filtered;
		size_t size;
		uint8_t buf[16];
	} temp;
};

struct xz_dec_lzma2 {
	struct rc_dec rc;
	struct dictionary dict;
	struct lzma2_dec lzma2;
	struct lzma_dec lzma;
	struct {
		uint32_t size;
		uint8_t buf[63];
	} temp;
};

struct yenta_socket {
	struct pci_dev *dev;
	int cb_irq;
	int io_irq;
	void *base;
	struct timer_list poll_timer;
	struct pcmcia_socket socket;
	struct cardbus_type *type;
	u32 flags;
	unsigned int probe_status;
	unsigned int private[8];
	u32 saved_state[2];
};

struct zap_details {
	struct folio *single_folio;
	bool even_cows;
	bool reclaim_pt;
	zap_flags_t zap_flags;
};

union zen_patch_rev {
	struct {
		__u32 rev: 8;
		__u32 stepping: 4;
		__u32 model: 4;
		__u32 __reserved: 4;
		__u32 ext_model: 4;
		__u32 ext_fam: 8;
	};
	__u32 ucode_rev;
};

typedef acpi_status (*acpi_exception_handler)(acpi_status, acpi_name, u16, u32, void *);

typedef acpi_status (*acpi_execute_op)(struct acpi_walk_state *);

typedef void (*acpi_gbl_event_handler)(u32, acpi_handle, u32, void *);

typedef acpi_status (*acpi_gpe_callback)(struct acpi_gpe_xrupt_info *, struct acpi_gpe_block_info *, void *);

typedef acpi_status (*acpi_init_handler)(acpi_handle, u32);

typedef u32 (*acpi_interface_handler)(acpi_string, u32);

typedef u32 (*acpi_osd_handler)(void *);

typedef acpi_status (*acpi_pkg_callback)(u8, union acpi_operand_object *, union acpi_generic_state *, void *);

typedef acpi_status (*acpi_table_handler)(u32, void *, void *);

typedef acpi_status (*acpi_walk_aml_callback)(u8 *, u32, u32, u8, void **);

typedef acpi_status (*acpi_walk_resource_callback)(struct acpi_resource *, void *);

typedef void amd_pmu_branch_reset_t(void);

typedef int (*arch_set_vga_state_t)(struct pci_dev *, bool, unsigned int, u32);

typedef unsigned int (*ata_xlat_func_t)(struct ata_queued_cmd *);

typedef void blk_log_action_t(struct trace_iterator *, const char *, bool);

typedef int (*bpf_aux_classic_check_t)(struct sock_filter *, unsigned int);

typedef u32 (*bpf_convert_ctx_access_t)(enum bpf_access_type, const struct bpf_insn *, struct bpf_insn *, struct bpf_prog *, u32 *);

typedef long unsigned int (*bpf_ctx_copy_t)(void *, const void *, long unsigned int, long unsigned int);

typedef unsigned int (*bpf_dispatcher_fn)(const void *, const struct bpf_insn *, unsigned int (*)(const void *, const struct bpf_insn *));

typedef unsigned int (*bpf_func_t)(const void *, const struct bpf_insn *);

typedef int (*bpf_op_t)(struct net_device *, struct netdev_bpf *);

typedef u32 (*bpf_prog_run_fn)(const struct bpf_prog *, const void *);

typedef u64 (*btf_bpf_bind)(struct bpf_sock_addr_kern *, struct sockaddr *, int);

typedef u64 (*btf_bpf_btf_find_by_name_kind)(char *, int, u32, int);

typedef u64 (*btf_bpf_cgrp_storage_delete)(struct bpf_map *, struct cgroup *);

typedef u64 (*btf_bpf_cgrp_storage_get)(struct bpf_map *, struct cgroup *, void *, u64, gfp_t);

typedef u64 (*btf_bpf_clone_redirect)(struct sk_buff *, u32, u64);

typedef u64 (*btf_bpf_copy_from_user)(void *, u32, const void *);

typedef u64 (*btf_bpf_copy_from_user_task)(void *, u32, const void *, struct task_struct *, u64);

typedef u64 (*btf_bpf_csum_diff)(__be32 *, u32, __be32 *, u32, __wsum);

typedef u64 (*btf_bpf_csum_level)(struct sk_buff *, u64);

typedef u64 (*btf_bpf_csum_update)(struct sk_buff *, __wsum);

typedef u64 (*btf_bpf_current_task_under_cgroup)(struct bpf_map *, u32);

typedef u64 (*btf_bpf_d_path)(struct path *, char *, u32);

typedef u64 (*btf_bpf_dynptr_data)(const struct bpf_dynptr_kern *, u32, u32);

typedef u64 (*btf_bpf_dynptr_from_mem)(void *, u32, u64, struct bpf_dynptr_kern *);

typedef u64 (*btf_bpf_dynptr_read)(void *, u32, const struct bpf_dynptr_kern *, u32, u64);

typedef u64 (*btf_bpf_dynptr_write)(const struct bpf_dynptr_kern *, u32, void *, u32, u64);

typedef u64 (*btf_bpf_event_output_data)(void *, struct bpf_map *, u64, void *, u64);

typedef u64 (*btf_bpf_find_vma)(struct task_struct *, u64, bpf_callback_t, void *, u64);

typedef u64 (*btf_bpf_flow_dissector_load_bytes)(const struct bpf_flow_dissector *, u32, void *, u32);

typedef u64 (*btf_bpf_for_each_map_elem)(struct bpf_map *, void *, void *, u64);

typedef u64 (*btf_bpf_get_attach_cookie_kprobe_multi)(struct pt_regs *);

typedef u64 (*btf_bpf_get_attach_cookie_pe)(struct bpf_perf_event_data_kern *);

typedef u64 (*btf_bpf_get_attach_cookie_trace)(void *);

typedef u64 (*btf_bpf_get_attach_cookie_tracing)(void *);

typedef u64 (*btf_bpf_get_attach_cookie_uprobe_multi)(struct pt_regs *);

typedef u64 (*btf_bpf_get_branch_snapshot)(void *, u32, u64);

typedef u64 (*btf_bpf_get_cgroup_classid)(const struct sk_buff *);

typedef u64 (*btf_bpf_get_cgroup_classid_curr)(void);

typedef u64 (*btf_bpf_get_current_ancestor_cgroup_id)(int);

typedef u64 (*btf_bpf_get_current_cgroup_id)(void);

typedef u64 (*btf_bpf_get_current_comm)(char *, u32);

typedef u64 (*btf_bpf_get_current_pid_tgid)(void);

typedef u64 (*btf_bpf_get_current_task)(void);

typedef u64 (*btf_bpf_get_current_task_btf)(void);

typedef u64 (*btf_bpf_get_current_uid_gid)(void);

typedef u64 (*btf_bpf_get_func_ip_kprobe)(struct pt_regs *);

typedef u64 (*btf_bpf_get_func_ip_kprobe_multi)(struct pt_regs *);

typedef u64 (*btf_bpf_get_func_ip_tracing)(void *);

typedef u64 (*btf_bpf_get_func_ip_uprobe_multi)(struct pt_regs *);

typedef u64 (*btf_bpf_get_hash_recalc)(struct sk_buff *);

typedef u64 (*btf_bpf_get_listener_sock)(struct sock *);

typedef u64 (*btf_bpf_get_netns_cookie)(struct sk_buff *);

typedef u64 (*btf_bpf_get_netns_cookie_sk_msg)(struct sk_msg *);

typedef u64 (*btf_bpf_get_netns_cookie_sock)(struct sock *);

typedef u64 (*btf_bpf_get_netns_cookie_sock_addr)(struct bpf_sock_addr_kern *);

typedef u64 (*btf_bpf_get_netns_cookie_sock_ops)(struct bpf_sock_ops_kern *);

typedef u64 (*btf_bpf_get_ns_current_pid_tgid)(u64, u64, struct bpf_pidns_info *, u32);

typedef u64 (*btf_bpf_get_numa_node_id)(void);

typedef u64 (*btf_bpf_get_raw_cpu_id)(void);

typedef u64 (*btf_bpf_get_route_realm)(const struct sk_buff *);

typedef u64 (*btf_bpf_get_smp_processor_id)(void);

typedef u64 (*btf_bpf_get_socket_cookie)(struct sk_buff *);

typedef u64 (*btf_bpf_get_socket_cookie_sock)(struct sock *);

typedef u64 (*btf_bpf_get_socket_cookie_sock_addr)(struct bpf_sock_addr_kern *);

typedef u64 (*btf_bpf_get_socket_cookie_sock_ops)(struct bpf_sock_ops_kern *);

typedef u64 (*btf_bpf_get_socket_ptr_cookie)(struct sock *);

typedef u64 (*btf_bpf_get_socket_uid)(struct sk_buff *);

typedef u64 (*btf_bpf_get_stack)(struct pt_regs *, void *, u32, u64);

typedef u64 (*btf_bpf_get_stack_pe)(struct bpf_perf_event_data_kern *, void *, u32, u64);

typedef u64 (*btf_bpf_get_stack_raw_tp)(struct bpf_raw_tracepoint_args *, void *, u32, u64);

typedef u64 (*btf_bpf_get_stack_sleepable)(struct pt_regs *, void *, u32, u64);

typedef u64 (*btf_bpf_get_stack_tp)(void *, void *, u32, u64);

typedef u64 (*btf_bpf_get_stackid)(struct pt_regs *, struct bpf_map *, u64);

typedef u64 (*btf_bpf_get_stackid_pe)(struct bpf_perf_event_data_kern *, struct bpf_map *, u64);

typedef u64 (*btf_bpf_get_stackid_raw_tp)(struct bpf_raw_tracepoint_args *, struct bpf_map *, u64);

typedef u64 (*btf_bpf_get_stackid_tp)(void *, struct bpf_map *, u64);

typedef u64 (*btf_bpf_get_task_stack)(struct task_struct *, void *, u32, u64);

typedef u64 (*btf_bpf_get_task_stack_sleepable)(struct task_struct *, void *, u32, u64);

typedef u64 (*btf_bpf_jiffies64)(void);

typedef u64 (*btf_bpf_kallsyms_lookup_name)(const char *, int, int, u64 *);

typedef u64 (*btf_bpf_kptr_xchg)(void *, void *);

typedef u64 (*btf_bpf_ktime_get_boot_ns)(void);

typedef u64 (*btf_bpf_ktime_get_coarse_ns)(void);

typedef u64 (*btf_bpf_ktime_get_ns)(void);

typedef u64 (*btf_bpf_ktime_get_tai_ns)(void);

typedef u64 (*btf_bpf_l3_csum_replace)(struct sk_buff *, u32, u64, u64, u64);

typedef u64 (*btf_bpf_l4_csum_replace)(struct sk_buff *, u32, u64, u64, u64);

typedef u64 (*btf_bpf_loop)(u32, void *, void *, u64);

typedef u64 (*btf_bpf_lwt_in_push_encap)(struct sk_buff *, u32, void *, u32);

typedef u64 (*btf_bpf_lwt_xmit_push_encap)(struct sk_buff *, u32, void *, u32);

typedef u64 (*btf_bpf_map_delete_elem)(struct bpf_map *, void *);

typedef u64 (*btf_bpf_map_lookup_elem)(struct bpf_map *, void *);

typedef u64 (*btf_bpf_map_lookup_percpu_elem)(struct bpf_map *, void *, u32);

typedef u64 (*btf_bpf_map_peek_elem)(struct bpf_map *, void *);

typedef u64 (*btf_bpf_map_pop_elem)(struct bpf_map *, void *);

typedef u64 (*btf_bpf_map_push_elem)(struct bpf_map *, void *, u64);

typedef u64 (*btf_bpf_map_update_elem)(struct bpf_map *, void *, void *, u64);

typedef u64 (*btf_bpf_msg_apply_bytes)(struct sk_msg *, u32);

typedef u64 (*btf_bpf_msg_cork_bytes)(struct sk_msg *, u32);

typedef u64 (*btf_bpf_msg_pop_data)(struct sk_msg *, u32, u32, u64);

typedef u64 (*btf_bpf_msg_pull_data)(struct sk_msg *, u32, u32, u64);

typedef u64 (*btf_bpf_msg_push_data)(struct sk_msg *, u32, u32, u64);

typedef u64 (*btf_bpf_msg_redirect_hash)(struct sk_msg *, struct bpf_map *, void *, u64);

typedef u64 (*btf_bpf_msg_redirect_map)(struct sk_msg *, struct bpf_map *, u32, u64);

typedef u64 (*btf_bpf_per_cpu_ptr)(const void *, u32);

typedef u64 (*btf_bpf_perf_event_output)(struct pt_regs *, struct bpf_map *, u64, void *, u64);

typedef u64 (*btf_bpf_perf_event_output_raw_tp)(struct bpf_raw_tracepoint_args *, struct bpf_map *, u64, void *, u64);

typedef u64 (*btf_bpf_perf_event_output_tp)(void *, struct bpf_map *, u64, void *, u64);

typedef u64 (*btf_bpf_perf_event_read)(struct bpf_map *, u64);

typedef u64 (*btf_bpf_perf_event_read_value)(struct bpf_map *, u64, struct bpf_perf_event_value *, u32);

typedef u64 (*btf_bpf_perf_prog_read_value)(struct bpf_perf_event_data_kern *, struct bpf_perf_event_value *, u32);

typedef u64 (*btf_bpf_probe_read_compat)(void *, u32, const void *);

typedef u64 (*btf_bpf_probe_read_compat_str)(void *, u32, const void *);

typedef u64 (*btf_bpf_probe_read_kernel)(void *, u32, const void *);

typedef u64 (*btf_bpf_probe_read_kernel_str)(void *, u32, const void *);

typedef u64 (*btf_bpf_probe_read_user)(void *, u32, const void *);

typedef u64 (*btf_bpf_probe_read_user_str)(void *, u32, const void *);

typedef u64 (*btf_bpf_probe_write_user)(void *, const void *, u32);

typedef u64 (*btf_bpf_read_branch_records)(struct bpf_perf_event_data_kern *, void *, u32, u64);

typedef u64 (*btf_bpf_redirect)(u32, u64);

typedef u64 (*btf_bpf_redirect_neigh)(u32, struct bpf_redir_neigh *, int, u64);

typedef u64 (*btf_bpf_redirect_peer)(u32, u64);

typedef u64 (*btf_bpf_ringbuf_discard)(void *, u64);

typedef u64 (*btf_bpf_ringbuf_discard_dynptr)(struct bpf_dynptr_kern *, u64);

typedef u64 (*btf_bpf_ringbuf_output)(struct bpf_map *, void *, u64, u64);

typedef u64 (*btf_bpf_ringbuf_query)(struct bpf_map *, u64);

typedef u64 (*btf_bpf_ringbuf_reserve)(struct bpf_map *, u64, u64);

typedef u64 (*btf_bpf_ringbuf_reserve_dynptr)(struct bpf_map *, u32, u64, struct bpf_dynptr_kern *);

typedef u64 (*btf_bpf_ringbuf_submit)(void *, u64);

typedef u64 (*btf_bpf_ringbuf_submit_dynptr)(struct bpf_dynptr_kern *, u64);

typedef u64 (*btf_bpf_send_signal)(u32);

typedef u64 (*btf_bpf_send_signal_thread)(u32);

typedef u64 (*btf_bpf_seq_printf)(struct seq_file *, char *, u32, const void *, u32);

typedef u64 (*btf_bpf_seq_printf_btf)(struct seq_file *, struct btf_ptr *, u32, u64);

typedef u64 (*btf_bpf_seq_write)(struct seq_file *, const void *, u32);

typedef u64 (*btf_bpf_set_hash)(struct sk_buff *, u32);

typedef u64 (*btf_bpf_set_hash_invalid)(struct sk_buff *);

typedef u64 (*btf_bpf_sk_ancestor_cgroup_id)(struct sock *, int);

typedef u64 (*btf_bpf_sk_assign)(struct sk_buff *, struct sock *, u64);

typedef u64 (*btf_bpf_sk_cgroup_id)(struct sock *);

typedef u64 (*btf_bpf_sk_fullsock)(struct sock *);

typedef u64 (*btf_bpf_sk_getsockopt)(struct sock *, int, int, char *, int);

typedef u64 (*btf_bpf_sk_lookup_assign)(struct bpf_sk_lookup_kern *, struct sock *, u64);

typedef u64 (*btf_bpf_sk_lookup_tcp)(struct sk_buff *, struct bpf_sock_tuple *, u32, u64, u64);

typedef u64 (*btf_bpf_sk_lookup_udp)(struct sk_buff *, struct bpf_sock_tuple *, u32, u64, u64);

typedef u64 (*btf_bpf_sk_redirect_hash)(struct sk_buff *, struct bpf_map *, void *, u64);

typedef u64 (*btf_bpf_sk_redirect_map)(struct sk_buff *, struct bpf_map *, u32, u64);

typedef u64 (*btf_bpf_sk_release)(struct sock *);

typedef u64 (*btf_bpf_sk_setsockopt)(struct sock *, int, int, char *, int);

typedef u64 (*btf_bpf_sk_storage_delete)(struct bpf_map *, struct sock *);

typedef u64 (*btf_bpf_sk_storage_delete_tracing)(struct bpf_map *, struct sock *);

typedef u64 (*btf_bpf_sk_storage_get)(struct bpf_map *, struct sock *, void *, u64, gfp_t);

typedef u64 (*btf_bpf_sk_storage_get_tracing)(struct bpf_map *, struct sock *, void *, u64, gfp_t);

typedef u64 (*btf_bpf_skb_adjust_room)(struct sk_buff *, s32, u32, u64);

typedef u64 (*btf_bpf_skb_ancestor_cgroup_id)(const struct sk_buff *, int);

typedef u64 (*btf_bpf_skb_cgroup_classid)(const struct sk_buff *);

typedef u64 (*btf_bpf_skb_cgroup_id)(const struct sk_buff *);

typedef u64 (*btf_bpf_skb_change_head)(struct sk_buff *, u32, u64);

typedef u64 (*btf_bpf_skb_change_proto)(struct sk_buff *, __be16, u64);

typedef u64 (*btf_bpf_skb_change_tail)(struct sk_buff *, u32, u64);

typedef u64 (*btf_bpf_skb_change_type)(struct sk_buff *, u32);

typedef u64 (*btf_bpf_skb_check_mtu)(struct sk_buff *, u32, u32 *, s32, u64);

typedef u64 (*btf_bpf_skb_ecn_set_ce)(struct sk_buff *);

typedef u64 (*btf_bpf_skb_event_output)(struct sk_buff *, struct bpf_map *, u64, void *, u64);

typedef u64 (*btf_bpf_skb_fib_lookup)(struct sk_buff *, struct bpf_fib_lookup *, int, u32);

typedef u64 (*btf_bpf_skb_get_nlattr)(struct sk_buff *, u32, u32);

typedef u64 (*btf_bpf_skb_get_nlattr_nest)(struct sk_buff *, u32, u32);

typedef u64 (*btf_bpf_skb_get_pay_offset)(struct sk_buff *);

typedef u64 (*btf_bpf_skb_get_tunnel_key)(struct sk_buff *, struct bpf_tunnel_key *, u32, u64);

typedef u64 (*btf_bpf_skb_get_tunnel_opt)(struct sk_buff *, u8 *, u32);

typedef u64 (*btf_bpf_skb_get_xfrm_state)(struct sk_buff *, u32, struct bpf_xfrm_state *, u32, u64);

typedef u64 (*btf_bpf_skb_load_bytes)(const struct sk_buff *, u32, void *, u32);

typedef u64 (*btf_bpf_skb_load_bytes_relative)(const struct sk_buff *, u32, void *, u32, u32);

typedef u64 (*btf_bpf_skb_load_helper_16)(const struct sk_buff *, const void *, int, int);

typedef u64 (*btf_bpf_skb_load_helper_16_no_cache)(const struct sk_buff *, int);

typedef u64 (*btf_bpf_skb_load_helper_32)(const struct sk_buff *, const void *, int, int);

typedef u64 (*btf_bpf_skb_load_helper_32_no_cache)(const struct sk_buff *, int);

typedef u64 (*btf_bpf_skb_load_helper_8)(const struct sk_buff *, const void *, int, int);

typedef u64 (*btf_bpf_skb_load_helper_8_no_cache)(const struct sk_buff *, int);

typedef u64 (*btf_bpf_skb_pull_data)(struct sk_buff *, u32);

typedef u64 (*btf_bpf_skb_set_tstamp)(struct sk_buff *, u64, u32);

typedef u64 (*btf_bpf_skb_set_tunnel_key)(struct sk_buff *, const struct bpf_tunnel_key *, u32, u64);

typedef u64 (*btf_bpf_skb_set_tunnel_opt)(struct sk_buff *, const u8 *, u32);

typedef u64 (*btf_bpf_skb_store_bytes)(struct sk_buff *, u32, const void *, u32, u64);

typedef u64 (*btf_bpf_skb_under_cgroup)(struct sk_buff *, struct bpf_map *, u32);

typedef u64 (*btf_bpf_skb_vlan_pop)(struct sk_buff *);

typedef u64 (*btf_bpf_skb_vlan_push)(struct sk_buff *, __be16, u16);

typedef u64 (*btf_bpf_skc_lookup_tcp)(struct sk_buff *, struct bpf_sock_tuple *, u32, u64, u64);

typedef u64 (*btf_bpf_skc_to_mptcp_sock)(struct sock *);

typedef u64 (*btf_bpf_skc_to_tcp6_sock)(struct sock *);

typedef u64 (*btf_bpf_skc_to_tcp_request_sock)(struct sock *);

typedef u64 (*btf_bpf_skc_to_tcp_sock)(struct sock *);

typedef u64 (*btf_bpf_skc_to_tcp_timewait_sock)(struct sock *);

typedef u64 (*btf_bpf_skc_to_udp6_sock)(struct sock *);

typedef u64 (*btf_bpf_skc_to_unix_sock)(struct sock *);

typedef u64 (*btf_bpf_snprintf)(char *, u32, char *, const void *, u32);

typedef u64 (*btf_bpf_snprintf_btf)(char *, u32, struct btf_ptr *, u32, u64);

typedef u64 (*btf_bpf_sock_addr_getsockopt)(struct bpf_sock_addr_kern *, int, int, char *, int);

typedef u64 (*btf_bpf_sock_addr_setsockopt)(struct bpf_sock_addr_kern *, int, int, char *, int);

typedef u64 (*btf_bpf_sock_addr_sk_lookup_tcp)(struct bpf_sock_addr_kern *, struct bpf_sock_tuple *, u32, u64, u64);

typedef u64 (*btf_bpf_sock_addr_sk_lookup_udp)(struct bpf_sock_addr_kern *, struct bpf_sock_tuple *, u32, u64, u64);

typedef u64 (*btf_bpf_sock_addr_skc_lookup_tcp)(struct bpf_sock_addr_kern *, struct bpf_sock_tuple *, u32, u64, u64);

typedef u64 (*btf_bpf_sock_from_file)(struct file *);

typedef u64 (*btf_bpf_sock_hash_update)(struct bpf_sock_ops_kern *, struct bpf_map *, void *, u64);

typedef u64 (*btf_bpf_sock_map_update)(struct bpf_sock_ops_kern *, struct bpf_map *, void *, u64);

typedef u64 (*btf_bpf_sock_ops_cb_flags_set)(struct bpf_sock_ops_kern *, int);

typedef u64 (*btf_bpf_sock_ops_getsockopt)(struct bpf_sock_ops_kern *, int, int, char *, int);

typedef u64 (*btf_bpf_sock_ops_load_hdr_opt)(struct bpf_sock_ops_kern *, void *, u32, u64);

typedef u64 (*btf_bpf_sock_ops_reserve_hdr_opt)(struct bpf_sock_ops_kern *, u32, u64);

typedef u64 (*btf_bpf_sock_ops_setsockopt)(struct bpf_sock_ops_kern *, int, int, char *, int);

typedef u64 (*btf_bpf_sock_ops_store_hdr_opt)(struct bpf_sock_ops_kern *, const void *, u32, u64);

typedef u64 (*btf_bpf_spin_lock)(struct bpf_spin_lock *);

typedef u64 (*btf_bpf_spin_unlock)(struct bpf_spin_lock *);

typedef u64 (*btf_bpf_strncmp)(const char *, u32, const char *);

typedef u64 (*btf_bpf_strtol)(const char *, size_t, u64, s64 *);

typedef u64 (*btf_bpf_strtoul)(const char *, size_t, u64, u64 *);

typedef u64 (*btf_bpf_sys_bpf)(int, union bpf_attr *, u32);

typedef u64 (*btf_bpf_sys_close)(u32);

typedef u64 (*btf_bpf_task_pt_regs)(struct task_struct *);

typedef u64 (*btf_bpf_task_storage_delete)(struct bpf_map *, struct task_struct *);

typedef u64 (*btf_bpf_task_storage_delete_recur)(struct bpf_map *, struct task_struct *);

typedef u64 (*btf_bpf_task_storage_get)(struct bpf_map *, struct task_struct *, void *, u64, gfp_t);

typedef u64 (*btf_bpf_task_storage_get_recur)(struct bpf_map *, struct task_struct *, void *, u64, gfp_t);

typedef u64 (*btf_bpf_tc_sk_lookup_tcp)(struct sk_buff *, struct bpf_sock_tuple *, u32, u64, u64);

typedef u64 (*btf_bpf_tc_sk_lookup_udp)(struct sk_buff *, struct bpf_sock_tuple *, u32, u64, u64);

typedef u64 (*btf_bpf_tc_skc_lookup_tcp)(struct sk_buff *, struct bpf_sock_tuple *, u32, u64, u64);

typedef u64 (*btf_bpf_tcp_check_syncookie)(struct sock *, void *, u32, struct tcphdr *, u32);

typedef u64 (*btf_bpf_tcp_gen_syncookie)(struct sock *, void *, u32, struct tcphdr *, u32);

typedef u64 (*btf_bpf_tcp_raw_check_syncookie_ipv4)(struct iphdr *, struct tcphdr *);

typedef u64 (*btf_bpf_tcp_raw_check_syncookie_ipv6)(struct ipv6hdr *, struct tcphdr *);

typedef u64 (*btf_bpf_tcp_raw_gen_syncookie_ipv4)(struct iphdr *, struct tcphdr *, u32);

typedef u64 (*btf_bpf_tcp_raw_gen_syncookie_ipv6)(struct ipv6hdr *, struct tcphdr *, u32);

typedef u64 (*btf_bpf_tcp_sock)(struct sock *);

typedef u64 (*btf_bpf_this_cpu_ptr)(const void *);

typedef u64 (*btf_bpf_timer_cancel)(struct bpf_async_kern *);

typedef u64 (*btf_bpf_timer_init)(struct bpf_async_kern *, struct bpf_map *, u64);

typedef u64 (*btf_bpf_timer_set_callback)(struct bpf_async_kern *, void *, struct bpf_prog_aux *);

typedef u64 (*btf_bpf_timer_start)(struct bpf_async_kern *, u64, u64);

typedef u64 (*btf_bpf_trace_printk)(char *, u32, u64, u64, u64);

typedef u64 (*btf_bpf_trace_vprintk)(char *, u32, const void *, u32);

typedef u64 (*btf_bpf_unlocked_sk_getsockopt)(struct sock *, int, int, char *, int);

typedef u64 (*btf_bpf_unlocked_sk_setsockopt)(struct sock *, int, int, char *, int);

typedef u64 (*btf_bpf_user_ringbuf_drain)(struct bpf_map *, void *, void *, u64);

typedef u64 (*btf_bpf_user_rnd_u32)(void);

typedef u64 (*btf_bpf_xdp_adjust_head)(struct xdp_buff *, int);

typedef u64 (*btf_bpf_xdp_adjust_meta)(struct xdp_buff *, int);

typedef u64 (*btf_bpf_xdp_adjust_tail)(struct xdp_buff *, int);

typedef u64 (*btf_bpf_xdp_check_mtu)(struct xdp_buff *, u32, u32 *, s32, u64);

typedef u64 (*btf_bpf_xdp_event_output)(struct xdp_buff *, struct bpf_map *, u64, void *, u64);

typedef u64 (*btf_bpf_xdp_fib_lookup)(struct xdp_buff *, struct bpf_fib_lookup *, int, u32);

typedef u64 (*btf_bpf_xdp_get_buff_len)(struct xdp_buff *);

typedef u64 (*btf_bpf_xdp_load_bytes)(struct xdp_buff *, u32, void *, u32);

typedef u64 (*btf_bpf_xdp_redirect)(u32, u64);

typedef u64 (*btf_bpf_xdp_redirect_map)(struct bpf_map *, u64, u64);

typedef u64 (*btf_bpf_xdp_sk_lookup_tcp)(struct xdp_buff *, struct bpf_sock_tuple *, u32, u32, u64);

typedef u64 (*btf_bpf_xdp_sk_lookup_udp)(struct xdp_buff *, struct bpf_sock_tuple *, u32, u32, u64);

typedef u64 (*btf_bpf_xdp_skc_lookup_tcp)(struct xdp_buff *, struct bpf_sock_tuple *, u32, u32, u64);

typedef u64 (*btf_bpf_xdp_store_bytes)(struct xdp_buff *, u32, void *, u32);

typedef u64 (*btf_get_func_arg)(void *, u32, u64 *);

typedef u64 (*btf_get_func_arg_cnt)(void *);

typedef u64 (*btf_get_func_ret)(void *, u64 *);

typedef u64 (*btf_sk_reuseport_load_bytes)(const struct sk_reuseport_kern *, u32, void *, u32);

typedef u64 (*btf_sk_reuseport_load_bytes_relative)(const struct sk_reuseport_kern *, u32, void *, u32, u32);

typedef u64 (*btf_sk_select_reuseport)(struct sk_reuseport_kern *, struct bpf_map *, void *, u32);

typedef u64 (*btf_sk_skb_adjust_room)(struct sk_buff *, s32, u32, u64);

typedef u64 (*btf_sk_skb_change_head)(struct sk_buff *, u32, u64);

typedef u64 (*btf_sk_skb_change_tail)(struct sk_buff *, u32, u64);

typedef u64 (*btf_sk_skb_pull_data)(struct sk_buff *, u32);

typedef void (*btf_trace_9p_client_req)(void *, struct p9_client *, int8_t, int);

typedef void (*btf_trace_9p_client_res)(void *, struct p9_client *, int8_t, int, int);

typedef void (*btf_trace_9p_fid_ref)(void *, struct p9_fid *, __u8);

typedef void (*btf_trace_9p_protocol_dump)(void *, struct p9_client *, struct p9_fcall *);

typedef void (*btf_trace_add_device_to_group)(void *, int, struct device *);

typedef void (*btf_trace_alarmtimer_cancel)(void *, struct alarm *, ktime_t);

typedef void (*btf_trace_alarmtimer_fired)(void *, struct alarm *, ktime_t);

typedef void (*btf_trace_alarmtimer_start)(void *, struct alarm *, ktime_t);

typedef void (*btf_trace_alarmtimer_suspend)(void *, ktime_t, int);

typedef void (*btf_trace_alloc_vmap_area)(void *, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, int);

typedef void (*btf_trace_amd_pstate_epp_perf)(void *, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, bool);

typedef void (*btf_trace_amd_pstate_perf)(void *, long unsigned int, long unsigned int, long unsigned int, u64, u64, u64, u64, unsigned int, bool);

typedef void (*btf_trace_api_beacon_loss)(void *, struct ieee80211_sub_if_data *);

typedef void (*btf_trace_api_chswitch_done)(void *, struct ieee80211_sub_if_data *, bool, unsigned int);

typedef void (*btf_trace_api_connection_loss)(void *, struct ieee80211_sub_if_data *);

typedef void (*btf_trace_api_cqm_beacon_loss_notify)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *);

typedef void (*btf_trace_api_cqm_rssi_notify)(void *, struct ieee80211_sub_if_data *, enum nl80211_cqm_rssi_threshold_event, s32);

typedef void (*btf_trace_api_disconnect)(void *, struct ieee80211_sub_if_data *, bool);

typedef void (*btf_trace_api_enable_rssi_reports)(void *, struct ieee80211_sub_if_data *, int, int);

typedef void (*btf_trace_api_eosp)(void *, struct ieee80211_local *, struct ieee80211_sta *);

typedef void (*btf_trace_api_finalize_rx_omi_bw)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct link_sta_info *);

typedef void (*btf_trace_api_gtk_rekey_notify)(void *, struct ieee80211_sub_if_data *, const u8 *, const u8 *);

typedef void (*btf_trace_api_prepare_rx_omi_bw)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct link_sta_info *, enum ieee80211_sta_rx_bandwidth);

typedef void (*btf_trace_api_radar_detected)(void *, struct ieee80211_local *);

typedef void (*btf_trace_api_ready_on_channel)(void *, struct ieee80211_local *);

typedef void (*btf_trace_api_remain_on_channel_expired)(void *, struct ieee80211_local *);

typedef void (*btf_trace_api_request_smps)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct ieee80211_link_data *, enum ieee80211_smps_mode);

typedef void (*btf_trace_api_restart_hw)(void *, struct ieee80211_local *);

typedef void (*btf_trace_api_return_bool)(void *, struct ieee80211_local *, bool);

typedef void (*btf_trace_api_return_void)(void *, struct ieee80211_local *);

typedef void (*btf_trace_api_scan_completed)(void *, struct ieee80211_local *, bool);

typedef void (*btf_trace_api_sched_scan_results)(void *, struct ieee80211_local *);

typedef void (*btf_trace_api_sched_scan_stopped)(void *, struct ieee80211_local *);

typedef void (*btf_trace_api_send_eosp_nullfunc)(void *, struct ieee80211_local *, struct ieee80211_sta *, u8);

typedef void (*btf_trace_api_sta_block_awake)(void *, struct ieee80211_local *, struct ieee80211_sta *, bool);

typedef void (*btf_trace_api_sta_set_buffered)(void *, struct ieee80211_local *, struct ieee80211_sta *, u8, bool);

typedef void (*btf_trace_api_start_tx_ba_cb)(void *, struct ieee80211_sub_if_data *, const u8 *, u16);

typedef void (*btf_trace_api_start_tx_ba_session)(void *, struct ieee80211_sta *, u16);

typedef void (*btf_trace_api_stop_tx_ba_cb)(void *, struct ieee80211_sub_if_data *, const u8 *, u16);

typedef void (*btf_trace_api_stop_tx_ba_session)(void *, struct ieee80211_sta *, u16);

typedef void (*btf_trace_ata_bmdma_setup)(void *, struct ata_port *, const struct ata_taskfile *, unsigned int);

typedef void (*btf_trace_ata_bmdma_start)(void *, struct ata_port *, const struct ata_taskfile *, unsigned int);

typedef void (*btf_trace_ata_bmdma_status)(void *, struct ata_port *, unsigned int);

typedef void (*btf_trace_ata_bmdma_stop)(void *, struct ata_port *, const struct ata_taskfile *, unsigned int);

typedef void (*btf_trace_ata_eh_about_to_do)(void *, struct ata_link *, unsigned int, unsigned int);

typedef void (*btf_trace_ata_eh_done)(void *, struct ata_link *, unsigned int, unsigned int);

typedef void (*btf_trace_ata_eh_link_autopsy)(void *, struct ata_device *, unsigned int, unsigned int);

typedef void (*btf_trace_ata_eh_link_autopsy_qc)(void *, struct ata_queued_cmd *);

typedef void (*btf_trace_ata_exec_command)(void *, struct ata_port *, const struct ata_taskfile *, unsigned int);

typedef void (*btf_trace_ata_link_hardreset_begin)(void *, struct ata_link *, unsigned int *, long unsigned int);

typedef void (*btf_trace_ata_link_hardreset_end)(void *, struct ata_link *, unsigned int *, int);

typedef void (*btf_trace_ata_link_postreset)(void *, struct ata_link *, unsigned int *, int);

typedef void (*btf_trace_ata_link_softreset_begin)(void *, struct ata_link *, unsigned int *, long unsigned int);

typedef void (*btf_trace_ata_link_softreset_end)(void *, struct ata_link *, unsigned int *, int);

typedef void (*btf_trace_ata_port_freeze)(void *, struct ata_port *);

typedef void (*btf_trace_ata_port_thaw)(void *, struct ata_port *);

typedef void (*btf_trace_ata_qc_complete_done)(void *, struct ata_queued_cmd *);

typedef void (*btf_trace_ata_qc_complete_failed)(void *, struct ata_queued_cmd *);

typedef void (*btf_trace_ata_qc_complete_internal)(void *, struct ata_queued_cmd *);

typedef void (*btf_trace_ata_qc_issue)(void *, struct ata_queued_cmd *);

typedef void (*btf_trace_ata_qc_prep)(void *, struct ata_queued_cmd *);

typedef void (*btf_trace_ata_sff_flush_pio_task)(void *, struct ata_port *);

typedef void (*btf_trace_ata_sff_hsm_command_complete)(void *, struct ata_queued_cmd *, unsigned char);

typedef void (*btf_trace_ata_sff_hsm_state)(void *, struct ata_queued_cmd *, unsigned char);

typedef void (*btf_trace_ata_sff_pio_transfer_data)(void *, struct ata_queued_cmd *, unsigned int, unsigned int);

typedef void (*btf_trace_ata_sff_port_intr)(void *, struct ata_queued_cmd *, unsigned char);

typedef void (*btf_trace_ata_slave_hardreset_begin)(void *, struct ata_link *, unsigned int *, long unsigned int);

typedef void (*btf_trace_ata_slave_hardreset_end)(void *, struct ata_link *, unsigned int *, int);

typedef void (*btf_trace_ata_slave_postreset)(void *, struct ata_link *, unsigned int *, int);

typedef void (*btf_trace_ata_std_sched_eh)(void *, struct ata_port *);

typedef void (*btf_trace_ata_tf_load)(void *, struct ata_port *, const struct ata_taskfile *);

typedef void (*btf_trace_atapi_pio_transfer_data)(void *, struct ata_queued_cmd *, unsigned int, unsigned int);

typedef void (*btf_trace_atapi_send_cdb)(void *, struct ata_queued_cmd *, unsigned int, unsigned int);

typedef void (*btf_trace_attach_device_to_domain)(void *, struct device *);

typedef void (*btf_trace_azx_get_position)(void *, struct azx *, struct azx_dev *, unsigned int, unsigned int);

typedef void (*btf_trace_azx_pcm_close)(void *, struct azx *, struct azx_dev *);

typedef void (*btf_trace_azx_pcm_hw_params)(void *, struct azx *, struct azx_dev *);

typedef void (*btf_trace_azx_pcm_open)(void *, struct azx *, struct azx_dev *);

typedef void (*btf_trace_azx_pcm_prepare)(void *, struct azx *, struct azx_dev *);

typedef void (*btf_trace_azx_pcm_trigger)(void *, struct azx *, struct azx_dev *, int);

typedef void (*btf_trace_azx_resume)(void *, struct azx *);

typedef void (*btf_trace_azx_runtime_resume)(void *, struct azx *);

typedef void (*btf_trace_azx_runtime_suspend)(void *, struct azx *);

typedef void (*btf_trace_azx_suspend)(void *, struct azx *);

typedef void (*btf_trace_balance_dirty_pages)(void *, struct bdi_writeback *, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long int, long unsigned int);

typedef void (*btf_trace_bdi_dirty_ratelimit)(void *, struct bdi_writeback *, long unsigned int, long unsigned int);

typedef void (*btf_trace_block_bio_backmerge)(void *, struct bio *);

typedef void (*btf_trace_block_bio_bounce)(void *, struct bio *);

typedef void (*btf_trace_block_bio_complete)(void *, struct request_queue *, struct bio *);

typedef void (*btf_trace_block_bio_frontmerge)(void *, struct bio *);

typedef void (*btf_trace_block_bio_queue)(void *, struct bio *);

typedef void (*btf_trace_block_bio_remap)(void *, struct bio *, dev_t, sector_t);

typedef void (*btf_trace_block_dirty_buffer)(void *, struct buffer_head *);

typedef void (*btf_trace_block_getrq)(void *, struct bio *);

typedef void (*btf_trace_block_io_done)(void *, struct request *);

typedef void (*btf_trace_block_io_start)(void *, struct request *);

typedef void (*btf_trace_block_plug)(void *, struct request_queue *);

typedef void (*btf_trace_block_rq_complete)(void *, struct request *, blk_status_t, unsigned int);

typedef void (*btf_trace_block_rq_error)(void *, struct request *, blk_status_t, unsigned int);

typedef void (*btf_trace_block_rq_insert)(void *, struct request *);

typedef void (*btf_trace_block_rq_issue)(void *, struct request *);

typedef void (*btf_trace_block_rq_merge)(void *, struct request *);

typedef void (*btf_trace_block_rq_remap)(void *, struct request *, dev_t, sector_t);

typedef void (*btf_trace_block_rq_requeue)(void *, struct request *);

typedef void (*btf_trace_block_split)(void *, struct bio *, unsigned int);

typedef void (*btf_trace_block_touch_buffer)(void *, struct buffer_head *);

typedef void (*btf_trace_block_unplug)(void *, struct request_queue *, unsigned int, bool);

typedef void (*btf_trace_bpf_test_finish)(void *, int *);

typedef void (*btf_trace_bpf_trace_printk)(void *, const char *);

typedef void (*btf_trace_bpf_trigger_tp)(void *, int);

typedef void (*btf_trace_bpf_xdp_link_attach_failed)(void *, const char *);

typedef void (*btf_trace_break_lease_block)(void *, struct inode *, struct file_lease *);

typedef void (*btf_trace_break_lease_noblock)(void *, struct inode *, struct file_lease *);

typedef void (*btf_trace_break_lease_unblock)(void *, struct inode *, struct file_lease *);

typedef void (*btf_trace_cache_entry_expired)(void *, const struct cache_detail *, const struct cache_head *);

typedef void (*btf_trace_cache_entry_make_negative)(void *, const struct cache_detail *, const struct cache_head *);

typedef void (*btf_trace_cache_entry_no_listener)(void *, const struct cache_detail *, const struct cache_head *);

typedef void (*btf_trace_cache_entry_upcall)(void *, const struct cache_detail *, const struct cache_head *);

typedef void (*btf_trace_cache_entry_update)(void *, const struct cache_detail *, const struct cache_head *);

typedef void (*btf_trace_cache_tag_assign)(void *, struct cache_tag *);

typedef void (*btf_trace_cache_tag_flush_all)(void *, struct cache_tag *);

typedef void (*btf_trace_cache_tag_flush_range)(void *, struct cache_tag *, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int);

typedef void (*btf_trace_cache_tag_flush_range_np)(void *, struct cache_tag *, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int);

typedef void (*btf_trace_cache_tag_unassign)(void *, struct cache_tag *);

typedef void (*btf_trace_call_function_entry)(void *, int);

typedef void (*btf_trace_call_function_exit)(void *, int);

typedef void (*btf_trace_call_function_single_entry)(void *, int);

typedef void (*btf_trace_call_function_single_exit)(void *, int);

typedef void (*btf_trace_cap_capable)(void *, const struct cred *, struct user_namespace *, const struct user_namespace *, int, int);

typedef void (*btf_trace_cdev_update)(void *, struct thermal_cooling_device *, long unsigned int);

typedef void (*btf_trace_cfg80211_assoc_comeback)(void *, struct wireless_dev *, const u8 *, u32);

typedef void (*btf_trace_cfg80211_bss_color_notify)(void *, struct net_device *, enum nl80211_commands, u8, u64);

typedef void (*btf_trace_cfg80211_cac_event)(void *, struct net_device *, enum nl80211_radar_event, unsigned int);

typedef void (*btf_trace_cfg80211_ch_switch_notify)(void *, struct net_device *, struct cfg80211_chan_def *, unsigned int);

typedef void (*btf_trace_cfg80211_ch_switch_started_notify)(void *, struct net_device *, struct cfg80211_chan_def *, unsigned int);

typedef void (*btf_trace_cfg80211_chandef_dfs_required)(void *, struct wiphy *, struct cfg80211_chan_def *);

typedef void (*btf_trace_cfg80211_control_port_tx_status)(void *, struct wireless_dev *, u64, bool);

typedef void (*btf_trace_cfg80211_cqm_pktloss_notify)(void *, struct net_device *, const u8 *, u32);

typedef void (*btf_trace_cfg80211_cqm_rssi_notify)(void *, struct net_device *, enum nl80211_cqm_rssi_threshold_event, s32);

typedef void (*btf_trace_cfg80211_del_sta)(void *, struct net_device *, const u8 *);

typedef void (*btf_trace_cfg80211_epcs_changed)(void *, struct wireless_dev *, bool);

typedef void (*btf_trace_cfg80211_ft_event)(void *, struct wiphy *, struct net_device *, struct cfg80211_ft_event_params *);

typedef void (*btf_trace_cfg80211_get_bss)(void *, struct wiphy *, struct ieee80211_channel *, const u8 *, const u8 *, size_t, enum ieee80211_bss_type, enum ieee80211_privacy);

typedef void (*btf_trace_cfg80211_gtk_rekey_notify)(void *, struct net_device *, const u8 *);

typedef void (*btf_trace_cfg80211_ibss_joined)(void *, struct net_device *, const u8 *, struct ieee80211_channel *);

typedef void (*btf_trace_cfg80211_inform_bss_frame)(void *, struct wiphy *, struct cfg80211_inform_bss *, struct ieee80211_mgmt *, size_t);

typedef void (*btf_trace_cfg80211_links_removed)(void *, struct net_device *, u16);

typedef void (*btf_trace_cfg80211_mgmt_tx_status)(void *, struct wireless_dev *, u64, bool);

typedef void (*btf_trace_cfg80211_michael_mic_failure)(void *, struct net_device *, const u8 *, enum nl80211_key_type, int, const u8 *);

typedef void (*btf_trace_cfg80211_mlo_reconf_add_done)(void *, struct net_device *, u16, const u8 *, size_t);

typedef void (*btf_trace_cfg80211_new_sta)(void *, struct net_device *, const u8 *, struct station_info *);

typedef void (*btf_trace_cfg80211_notify_new_peer_candidate)(void *, struct net_device *, const u8 *);

typedef void (*btf_trace_cfg80211_pmksa_candidate_notify)(void *, struct net_device *, int, const u8 *, bool);

typedef void (*btf_trace_cfg80211_pmsr_complete)(void *, struct wiphy *, struct wireless_dev *, u64);

typedef void (*btf_trace_cfg80211_pmsr_report)(void *, struct wiphy *, struct wireless_dev *, u64, const u8 *);

typedef void (*btf_trace_cfg80211_probe_status)(void *, struct net_device *, const u8 *, u64, bool);

typedef void (*btf_trace_cfg80211_radar_event)(void *, struct wiphy *, struct cfg80211_chan_def *, bool);

typedef void (*btf_trace_cfg80211_ready_on_channel)(void *, struct wireless_dev *, u64, struct ieee80211_channel *, unsigned int);

typedef void (*btf_trace_cfg80211_ready_on_channel_expired)(void *, struct wireless_dev *, u64, struct ieee80211_channel *);

typedef void (*btf_trace_cfg80211_reg_can_beacon)(void *, struct wiphy *, struct cfg80211_chan_def *, enum nl80211_iftype, u32, u32);

typedef void (*btf_trace_cfg80211_report_obss_beacon)(void *, struct wiphy *, const u8 *, size_t, int, int);

typedef void (*btf_trace_cfg80211_report_wowlan_wakeup)(void *, struct wiphy *, struct wireless_dev *, struct cfg80211_wowlan_wakeup *);

typedef void (*btf_trace_cfg80211_return_bool)(void *, bool);

typedef void (*btf_trace_cfg80211_return_bss)(void *, struct cfg80211_bss *);

typedef void (*btf_trace_cfg80211_return_u32)(void *, u32);

typedef void (*btf_trace_cfg80211_return_uint)(void *, unsigned int);

typedef void (*btf_trace_cfg80211_rx_control_port)(void *, struct net_device *, struct sk_buff *, bool, int);

typedef void (*btf_trace_cfg80211_rx_mgmt)(void *, struct wireless_dev *, struct cfg80211_rx_info *);

typedef void (*btf_trace_cfg80211_rx_mlme_mgmt)(void *, struct net_device *, const u8 *, int);

typedef void (*btf_trace_cfg80211_rx_spurious_frame)(void *, struct net_device *, const u8 *);

typedef void (*btf_trace_cfg80211_rx_unexpected_4addr_frame)(void *, struct net_device *, const u8 *);

typedef void (*btf_trace_cfg80211_rx_unprot_mlme_mgmt)(void *, struct net_device *, const u8 *, int);

typedef void (*btf_trace_cfg80211_scan_done)(void *, struct cfg80211_scan_request *, struct cfg80211_scan_info *);

typedef void (*btf_trace_cfg80211_sched_scan_results)(void *, struct wiphy *, u64);

typedef void (*btf_trace_cfg80211_sched_scan_stopped)(void *, struct wiphy *, u64);

typedef void (*btf_trace_cfg80211_send_assoc_failure)(void *, struct net_device *, struct cfg80211_assoc_failure *);

typedef void (*btf_trace_cfg80211_send_auth_timeout)(void *, struct net_device *, const u8 *);

typedef void (*btf_trace_cfg80211_send_rx_assoc)(void *, struct net_device *, const struct cfg80211_rx_assoc_resp_data *);

typedef void (*btf_trace_cfg80211_send_rx_auth)(void *, struct net_device *);

typedef void (*btf_trace_cfg80211_stop_iface)(void *, struct wiphy *, struct wireless_dev *);

typedef void (*btf_trace_cfg80211_tdls_oper_request)(void *, struct wiphy *, struct net_device *, const u8 *, enum nl80211_tdls_operation, u16);

typedef void (*btf_trace_cfg80211_tx_mgmt_expired)(void *, struct wireless_dev *, u64, struct ieee80211_channel *);

typedef void (*btf_trace_cfg80211_tx_mlme_mgmt)(void *, struct net_device *, const u8 *, int, bool);

typedef void (*btf_trace_cfg80211_update_owe_info_event)(void *, struct wiphy *, struct net_device *, struct cfg80211_update_owe_info *);

typedef void (*btf_trace_cgroup_attach_task)(void *, struct cgroup *, const char *, struct task_struct *, bool);

typedef void (*btf_trace_cgroup_destroy_root)(void *, struct cgroup_root *);

typedef void (*btf_trace_cgroup_freeze)(void *, struct cgroup *, const char *);

typedef void (*btf_trace_cgroup_mkdir)(void *, struct cgroup *, const char *);

typedef void (*btf_trace_cgroup_notify_frozen)(void *, struct cgroup *, const char *, int);

typedef void (*btf_trace_cgroup_notify_populated)(void *, struct cgroup *, const char *, int);

typedef void (*btf_trace_cgroup_release)(void *, struct cgroup *, const char *);

typedef void (*btf_trace_cgroup_remount)(void *, struct cgroup_root *);

typedef void (*btf_trace_cgroup_rename)(void *, struct cgroup *, const char *);

typedef void (*btf_trace_cgroup_rmdir)(void *, struct cgroup *, const char *);

typedef void (*btf_trace_cgroup_rstat_cpu_lock_contended)(void *, struct cgroup *, int, bool);

typedef void (*btf_trace_cgroup_rstat_cpu_lock_contended_fastpath)(void *, struct cgroup *, int, bool);

typedef void (*btf_trace_cgroup_rstat_cpu_locked)(void *, struct cgroup *, int, bool);

typedef void (*btf_trace_cgroup_rstat_cpu_locked_fastpath)(void *, struct cgroup *, int, bool);

typedef void (*btf_trace_cgroup_rstat_cpu_unlock)(void *, struct cgroup *, int, bool);

typedef void (*btf_trace_cgroup_rstat_cpu_unlock_fastpath)(void *, struct cgroup *, int, bool);

typedef void (*btf_trace_cgroup_rstat_lock_contended)(void *, struct cgroup *, int, bool);

typedef void (*btf_trace_cgroup_rstat_locked)(void *, struct cgroup *, int, bool);

typedef void (*btf_trace_cgroup_rstat_unlock)(void *, struct cgroup *, int, bool);

typedef void (*btf_trace_cgroup_setup_root)(void *, struct cgroup_root *);

typedef void (*btf_trace_cgroup_transfer_tasks)(void *, struct cgroup *, const char *, struct task_struct *, bool);

typedef void (*btf_trace_cgroup_unfreeze)(void *, struct cgroup *, const char *);

typedef void (*btf_trace_clock_disable)(void *, const char *, unsigned int, unsigned int);

typedef void (*btf_trace_clock_enable)(void *, const char *, unsigned int, unsigned int);

typedef void (*btf_trace_clock_set_rate)(void *, const char *, unsigned int, unsigned int);

typedef void (*btf_trace_compact_retry)(void *, int, enum compact_priority, enum compact_result, int, int, bool);

typedef void (*btf_trace_console)(void *, const char *, size_t);

typedef void (*btf_trace_consume_skb)(void *, struct sk_buff *, void *);

typedef void (*btf_trace_contention_begin)(void *, void *, unsigned int);

typedef void (*btf_trace_contention_end)(void *, void *, int);

typedef void (*btf_trace_cpu_frequency)(void *, unsigned int, unsigned int);

typedef void (*btf_trace_cpu_frequency_limits)(void *, struct cpufreq_policy *);

typedef void (*btf_trace_cpu_idle)(void *, unsigned int, unsigned int);

typedef void (*btf_trace_cpu_idle_miss)(void *, unsigned int, unsigned int, bool);

typedef void (*btf_trace_cpuhp_enter)(void *, unsigned int, int, int, int (*)(unsigned int));

typedef void (*btf_trace_cpuhp_exit)(void *, unsigned int, int, int, int);

typedef void (*btf_trace_cpuhp_multi_enter)(void *, unsigned int, int, int, int (*)(unsigned int, struct hlist_node *), struct hlist_node *);

typedef void (*btf_trace_csd_function_entry)(void *, smp_call_func_t, call_single_data_t *);

typedef void (*btf_trace_csd_function_exit)(void *, smp_call_func_t, call_single_data_t *);

typedef void (*btf_trace_csd_queue_cpu)(void *, const unsigned int, long unsigned int, smp_call_func_t, call_single_data_t *);

typedef void (*btf_trace_ctime_ns_xchg)(void *, struct inode *, u32, u32, u32);

typedef void (*btf_trace_ctime_xchg_skip)(void *, struct inode *, struct timespec64 *);

typedef void (*btf_trace_deferred_error_apic_entry)(void *, int);

typedef void (*btf_trace_deferred_error_apic_exit)(void *, int);

typedef void (*btf_trace_dev_pm_qos_add_request)(void *, const char *, enum dev_pm_qos_req_type, s32);

typedef void (*btf_trace_dev_pm_qos_remove_request)(void *, const char *, enum dev_pm_qos_req_type, s32);

typedef void (*btf_trace_dev_pm_qos_update_request)(void *, const char *, enum dev_pm_qos_req_type, s32);

typedef void (*btf_trace_device_pm_callback_end)(void *, struct device *, int);

typedef void (*btf_trace_device_pm_callback_start)(void *, struct device *, const char *, int);

typedef void (*btf_trace_devres_log)(void *, struct device *, const char *, void *, const char *, size_t);

typedef void (*btf_trace_dma_alloc)(void *, struct device *, void *, dma_addr_t, size_t, enum dma_data_direction, gfp_t, long unsigned int);

typedef void (*btf_trace_dma_alloc_pages)(void *, struct device *, void *, dma_addr_t, size_t, enum dma_data_direction, gfp_t, long unsigned int);

typedef void (*btf_trace_dma_alloc_sgt)(void *, struct device *, struct sg_table *, size_t, enum dma_data_direction, gfp_t, long unsigned int);

typedef void (*btf_trace_dma_alloc_sgt_err)(void *, struct device *, void *, dma_addr_t, size_t, enum dma_data_direction, gfp_t, long unsigned int);

typedef void (*btf_trace_dma_fence_destroy)(void *, struct dma_fence *);

typedef void (*btf_trace_dma_fence_emit)(void *, struct dma_fence *);

typedef void (*btf_trace_dma_fence_enable_signal)(void *, struct dma_fence *);

typedef void (*btf_trace_dma_fence_init)(void *, struct dma_fence *);

typedef void (*btf_trace_dma_fence_signaled)(void *, struct dma_fence *);

typedef void (*btf_trace_dma_fence_wait_end)(void *, struct dma_fence *);

typedef void (*btf_trace_dma_fence_wait_start)(void *, struct dma_fence *);

typedef void (*btf_trace_dma_free)(void *, struct device *, void *, dma_addr_t, size_t, enum dma_data_direction, long unsigned int);

typedef void (*btf_trace_dma_free_pages)(void *, struct device *, void *, dma_addr_t, size_t, enum dma_data_direction, long unsigned int);

typedef void (*btf_trace_dma_free_sgt)(void *, struct device *, struct sg_table *, size_t, enum dma_data_direction);

typedef void (*btf_trace_dma_map_page)(void *, struct device *, phys_addr_t, dma_addr_t, size_t, enum dma_data_direction, long unsigned int);

typedef void (*btf_trace_dma_map_resource)(void *, struct device *, phys_addr_t, dma_addr_t, size_t, enum dma_data_direction, long unsigned int);

typedef void (*btf_trace_dma_map_sg)(void *, struct device *, struct scatterlist *, int, int, enum dma_data_direction, long unsigned int);

typedef void (*btf_trace_dma_map_sg_err)(void *, struct device *, struct scatterlist *, int, int, enum dma_data_direction, long unsigned int);

typedef void (*btf_trace_dma_sync_sg_for_cpu)(void *, struct device *, struct scatterlist *, int, enum dma_data_direction);

typedef void (*btf_trace_dma_sync_sg_for_device)(void *, struct device *, struct scatterlist *, int, enum dma_data_direction);

typedef void (*btf_trace_dma_sync_single_for_cpu)(void *, struct device *, dma_addr_t, size_t, enum dma_data_direction);

typedef void (*btf_trace_dma_sync_single_for_device)(void *, struct device *, dma_addr_t, size_t, enum dma_data_direction);

typedef void (*btf_trace_dma_unmap_page)(void *, struct device *, dma_addr_t, size_t, enum dma_data_direction, long unsigned int);

typedef void (*btf_trace_dma_unmap_resource)(void *, struct device *, dma_addr_t, size_t, enum dma_data_direction, long unsigned int);

typedef void (*btf_trace_dma_unmap_sg)(void *, struct device *, struct scatterlist *, int, enum dma_data_direction, long unsigned int);

typedef void (*btf_trace_dql_stall_detected)(void *, short unsigned int, unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int *);

typedef void (*btf_trace_drm_vblank_event)(void *, int, unsigned int, ktime_t, bool);

typedef void (*btf_trace_drm_vblank_event_delivered)(void *, struct drm_file *, int, unsigned int);

typedef void (*btf_trace_drm_vblank_event_queued)(void *, struct drm_file *, int, unsigned int);

typedef void (*btf_trace_drv_abort_channel_switch)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *);

typedef void (*btf_trace_drv_abort_pmsr)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *);

typedef void (*btf_trace_drv_add_chanctx)(void *, struct ieee80211_local *, struct ieee80211_chanctx *);

typedef void (*btf_trace_drv_add_interface)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *);

typedef void (*btf_trace_drv_add_nan_func)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, const struct cfg80211_nan_func *);

typedef void (*btf_trace_drv_add_twt_setup)(void *, struct ieee80211_local *, struct ieee80211_sta *, struct ieee80211_twt_setup *, struct ieee80211_twt_params *);

typedef void (*btf_trace_drv_allow_buffered_frames)(void *, struct ieee80211_local *, struct ieee80211_sta *, u16, int, enum ieee80211_frame_release_type, bool);

typedef void (*btf_trace_drv_ampdu_action)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct ieee80211_ampdu_params *);

typedef void (*btf_trace_drv_assign_vif_chanctx)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct ieee80211_bss_conf *, struct ieee80211_chanctx *);

typedef void (*btf_trace_drv_can_activate_links)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, u16);

typedef void (*btf_trace_drv_can_neg_ttlm)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct ieee80211_neg_ttlm *);

typedef void (*btf_trace_drv_cancel_hw_scan)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *);

typedef void (*btf_trace_drv_cancel_remain_on_channel)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *);

typedef void (*btf_trace_drv_change_chanctx)(void *, struct ieee80211_local *, struct ieee80211_chanctx *, u32);

typedef void (*btf_trace_drv_change_interface)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, enum nl80211_iftype, bool);

typedef void (*btf_trace_drv_change_sta_links)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct ieee80211_sta *, u16, u16);

typedef void (*btf_trace_drv_change_vif_links)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, u16, u16);

typedef void (*btf_trace_drv_channel_switch)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct ieee80211_channel_switch *);

typedef void (*btf_trace_drv_channel_switch_beacon)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct cfg80211_chan_def *);

typedef void (*btf_trace_drv_channel_switch_rx_beacon)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct ieee80211_channel_switch *);

typedef void (*btf_trace_drv_conf_tx)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, unsigned int, u16, const struct ieee80211_tx_queue_params *);

typedef void (*btf_trace_drv_config)(void *, struct ieee80211_local *, u32);

typedef void (*btf_trace_drv_config_iface_filter)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, unsigned int, unsigned int);

typedef void (*btf_trace_drv_configure_filter)(void *, struct ieee80211_local *, unsigned int, unsigned int *, u64);

typedef void (*btf_trace_drv_del_nan_func)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, u8);

typedef void (*btf_trace_drv_event_callback)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, const struct ieee80211_event *);

typedef void (*btf_trace_drv_flush)(void *, struct ieee80211_local *, u32, bool);

typedef void (*btf_trace_drv_flush_sta)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct ieee80211_sta *);

typedef void (*btf_trace_drv_get_antenna)(void *, struct ieee80211_local *, u32, u32, int);

typedef void (*btf_trace_drv_get_et_sset_count)(void *, struct ieee80211_local *, u32);

typedef void (*btf_trace_drv_get_et_stats)(void *, struct ieee80211_local *);

typedef void (*btf_trace_drv_get_et_strings)(void *, struct ieee80211_local *, u32);

typedef void (*btf_trace_drv_get_expected_throughput)(void *, struct ieee80211_sta *);

typedef void (*btf_trace_drv_get_ftm_responder_stats)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct cfg80211_ftm_responder_stats *);

typedef void (*btf_trace_drv_get_key_seq)(void *, struct ieee80211_local *, struct ieee80211_key_conf *);

typedef void (*btf_trace_drv_get_ringparam)(void *, struct ieee80211_local *, u32 *, u32 *, u32 *, u32 *);

typedef void (*btf_trace_drv_get_stats)(void *, struct ieee80211_local *, struct ieee80211_low_level_stats *, int);

typedef void (*btf_trace_drv_get_survey)(void *, struct ieee80211_local *, int, struct survey_info *);

typedef void (*btf_trace_drv_get_tsf)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *);

typedef void (*btf_trace_drv_get_txpower)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, unsigned int, int, int);

typedef void (*btf_trace_drv_hw_scan)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *);

typedef void (*btf_trace_drv_ipv6_addr_change)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *);

typedef void (*btf_trace_drv_join_ibss)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct ieee80211_bss_conf *);

typedef void (*btf_trace_drv_leave_ibss)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *);

typedef void (*btf_trace_drv_link_info_changed)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct ieee80211_bss_conf *, u64);

typedef void (*btf_trace_drv_link_sta_rc_update)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct ieee80211_link_sta *, u32);

typedef void (*btf_trace_drv_mgd_complete_tx)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, u16, u16, bool);

typedef void (*btf_trace_drv_mgd_prepare_tx)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, u16, u16, bool);

typedef void (*btf_trace_drv_mgd_protect_tdls_discover)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *);

typedef void (*btf_trace_drv_nan_change_conf)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct cfg80211_nan_conf *, u32);

typedef void (*btf_trace_drv_neg_ttlm_res)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, enum ieee80211_neg_ttlm_res, struct ieee80211_neg_ttlm *);

typedef void (*btf_trace_drv_net_fill_forward_path)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct ieee80211_sta *);

typedef void (*btf_trace_drv_net_setup_tc)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, u8);

typedef void (*btf_trace_drv_offchannel_tx_cancel_wait)(void *, struct ieee80211_local *);

typedef void (*btf_trace_drv_offset_tsf)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, s64);

typedef void (*btf_trace_drv_post_channel_switch)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *);

typedef void (*btf_trace_drv_pre_channel_switch)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct ieee80211_channel_switch *);

typedef void (*btf_trace_drv_prep_add_interface)(void *, struct ieee80211_local *, enum nl80211_iftype);

typedef void (*btf_trace_drv_prepare_multicast)(void *, struct ieee80211_local *, int);

typedef void (*btf_trace_drv_reconfig_complete)(void *, struct ieee80211_local *, enum ieee80211_reconfig_type);

typedef void (*btf_trace_drv_release_buffered_frames)(void *, struct ieee80211_local *, struct ieee80211_sta *, u16, int, enum ieee80211_frame_release_type, bool);

typedef void (*btf_trace_drv_remain_on_channel)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct ieee80211_channel *, unsigned int, enum ieee80211_roc_type);

typedef void (*btf_trace_drv_remove_chanctx)(void *, struct ieee80211_local *, struct ieee80211_chanctx *);

typedef void (*btf_trace_drv_remove_interface)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *);

typedef void (*btf_trace_drv_reset_tsf)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *);

typedef void (*btf_trace_drv_resume)(void *, struct ieee80211_local *);

typedef void (*btf_trace_drv_return_bool)(void *, struct ieee80211_local *, bool);

typedef void (*btf_trace_drv_return_int)(void *, struct ieee80211_local *, int);

typedef void (*btf_trace_drv_return_u32)(void *, struct ieee80211_local *, u32);

typedef void (*btf_trace_drv_return_u64)(void *, struct ieee80211_local *, u64);

typedef void (*btf_trace_drv_return_void)(void *, struct ieee80211_local *);

typedef void (*btf_trace_drv_sched_scan_start)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *);

typedef void (*btf_trace_drv_sched_scan_stop)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *);

typedef void (*btf_trace_drv_set_antenna)(void *, struct ieee80211_local *, u32, u32, int);

typedef void (*btf_trace_drv_set_bitrate_mask)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, const struct cfg80211_bitrate_mask *);

typedef void (*btf_trace_drv_set_coverage_class)(void *, struct ieee80211_local *, s16);

typedef void (*btf_trace_drv_set_default_unicast_key)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, int);

typedef void (*btf_trace_drv_set_frag_threshold)(void *, struct ieee80211_local *, u32);

typedef void (*btf_trace_drv_set_key)(void *, struct ieee80211_local *, enum set_key_cmd, struct ieee80211_sub_if_data *, struct ieee80211_sta *, struct ieee80211_key_conf *);

typedef void (*btf_trace_drv_set_rekey_data)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct cfg80211_gtk_rekey_data *);

typedef void (*btf_trace_drv_set_ringparam)(void *, struct ieee80211_local *, u32, u32);

typedef void (*btf_trace_drv_set_rts_threshold)(void *, struct ieee80211_local *, u32);

typedef void (*btf_trace_drv_set_tim)(void *, struct ieee80211_local *, struct ieee80211_sta *, bool);

typedef void (*btf_trace_drv_set_tsf)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, u64);

typedef void (*btf_trace_drv_set_wakeup)(void *, struct ieee80211_local *, bool);

typedef void (*btf_trace_drv_sta_add)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct ieee80211_sta *);

typedef void (*btf_trace_drv_sta_notify)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, enum sta_notify_cmd, struct ieee80211_sta *);

typedef void (*btf_trace_drv_sta_pre_rcu_remove)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct ieee80211_sta *);

typedef void (*btf_trace_drv_sta_rate_tbl_update)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct ieee80211_sta *);

typedef void (*btf_trace_drv_sta_remove)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct ieee80211_sta *);

typedef void (*btf_trace_drv_sta_set_4addr)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct ieee80211_sta *, bool);

typedef void (*btf_trace_drv_sta_set_decap_offload)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct ieee80211_sta *, bool);

typedef void (*btf_trace_drv_sta_set_txpwr)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct ieee80211_sta *);

typedef void (*btf_trace_drv_sta_state)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct ieee80211_sta *, enum ieee80211_sta_state, enum ieee80211_sta_state);

typedef void (*btf_trace_drv_sta_statistics)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct ieee80211_sta *);

typedef void (*btf_trace_drv_start)(void *, struct ieee80211_local *);

typedef void (*btf_trace_drv_start_ap)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct ieee80211_bss_conf *);

typedef void (*btf_trace_drv_start_nan)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct cfg80211_nan_conf *);

typedef void (*btf_trace_drv_start_pmsr)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *);

typedef void (*btf_trace_drv_stop)(void *, struct ieee80211_local *, bool);

typedef void (*btf_trace_drv_stop_ap)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct ieee80211_bss_conf *);

typedef void (*btf_trace_drv_stop_nan)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *);

typedef void (*btf_trace_drv_suspend)(void *, struct ieee80211_local *);

typedef void (*btf_trace_drv_sw_scan_complete)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *);

typedef void (*btf_trace_drv_sw_scan_start)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, const u8 *);

typedef void (*btf_trace_drv_switch_vif_chanctx)(void *, struct ieee80211_local *, struct ieee80211_vif_chanctx_switch *, int, enum ieee80211_chanctx_switch_mode);

typedef void (*btf_trace_drv_sync_rx_queues)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct ieee80211_sta *);

typedef void (*btf_trace_drv_tdls_cancel_channel_switch)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct ieee80211_sta *);

typedef void (*btf_trace_drv_tdls_channel_switch)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct ieee80211_sta *, u8, struct cfg80211_chan_def *);

typedef void (*btf_trace_drv_tdls_recv_channel_switch)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct ieee80211_tdls_ch_sw_params *);

typedef void (*btf_trace_drv_twt_teardown_request)(void *, struct ieee80211_local *, struct ieee80211_sta *, u8);

typedef void (*btf_trace_drv_tx_frames_pending)(void *, struct ieee80211_local *);

typedef void (*btf_trace_drv_tx_last_beacon)(void *, struct ieee80211_local *);

typedef void (*btf_trace_drv_unassign_vif_chanctx)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct ieee80211_bss_conf *, struct ieee80211_chanctx *);

typedef void (*btf_trace_drv_update_tkip_key)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct ieee80211_key_conf *, struct ieee80211_sta *, u32);

typedef void (*btf_trace_drv_update_vif_offload)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *);

typedef void (*btf_trace_drv_vif_cfg_changed)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, u64);

typedef void (*btf_trace_drv_wake_tx_queue)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct txq_info *);

typedef void (*btf_trace_e1000e_trace_mac_register)(void *, uint32_t);

typedef void (*btf_trace_emulate_vsyscall)(void *, int);

typedef void (*btf_trace_error_apic_entry)(void *, int);

typedef void (*btf_trace_error_apic_exit)(void *, int);

typedef void (*btf_trace_error_report_end)(void *, enum error_detector, long unsigned int);

typedef void (*btf_trace_exit_mmap)(void *, struct mm_struct *);

typedef void (*btf_trace_ext4_alloc_da_blocks)(void *, struct inode *);

typedef void (*btf_trace_ext4_allocate_blocks)(void *, struct ext4_allocation_request *, long long unsigned int);

typedef void (*btf_trace_ext4_allocate_inode)(void *, struct inode *, struct inode *, int);

typedef void (*btf_trace_ext4_begin_ordered_truncate)(void *, struct inode *, loff_t);

typedef void (*btf_trace_ext4_collapse_range)(void *, struct inode *, loff_t, loff_t);

typedef void (*btf_trace_ext4_da_release_space)(void *, struct inode *, int);

typedef void (*btf_trace_ext4_da_reserve_space)(void *, struct inode *, int);

typedef void (*btf_trace_ext4_da_update_reserve_space)(void *, struct inode *, int, int);

typedef void (*btf_trace_ext4_da_write_begin)(void *, struct inode *, loff_t, unsigned int);

typedef void (*btf_trace_ext4_da_write_end)(void *, struct inode *, loff_t, unsigned int, unsigned int);

typedef void (*btf_trace_ext4_da_write_pages)(void *, struct inode *, long unsigned int, struct writeback_control *);

typedef void (*btf_trace_ext4_da_write_pages_extent)(void *, struct inode *, struct ext4_map_blocks *);

typedef void (*btf_trace_ext4_discard_blocks)(void *, struct super_block *, long long unsigned int, long long unsigned int);

typedef void (*btf_trace_ext4_discard_preallocations)(void *, struct inode *, unsigned int);

typedef void (*btf_trace_ext4_drop_inode)(void *, struct inode *, int);

typedef void (*btf_trace_ext4_error)(void *, struct super_block *, const char *, unsigned int);

typedef void (*btf_trace_ext4_es_cache_extent)(void *, struct inode *, struct extent_status *);

typedef void (*btf_trace_ext4_es_find_extent_range_enter)(void *, struct inode *, ext4_lblk_t);

typedef void (*btf_trace_ext4_es_find_extent_range_exit)(void *, struct inode *, struct extent_status *);

typedef void (*btf_trace_ext4_es_insert_delayed_extent)(void *, struct inode *, struct extent_status *, bool, bool);

typedef void (*btf_trace_ext4_es_insert_extent)(void *, struct inode *, struct extent_status *);

typedef void (*btf_trace_ext4_es_lookup_extent_enter)(void *, struct inode *, ext4_lblk_t);

typedef void (*btf_trace_ext4_es_lookup_extent_exit)(void *, struct inode *, struct extent_status *, int);

typedef void (*btf_trace_ext4_es_remove_extent)(void *, struct inode *, ext4_lblk_t, ext4_lblk_t);

typedef void (*btf_trace_ext4_es_shrink)(void *, struct super_block *, int, u64, int, int);

typedef void (*btf_trace_ext4_es_shrink_count)(void *, struct super_block *, int, int);

typedef void (*btf_trace_ext4_es_shrink_scan_enter)(void *, struct super_block *, int, int);

typedef void (*btf_trace_ext4_es_shrink_scan_exit)(void *, struct super_block *, int, int);

typedef void (*btf_trace_ext4_evict_inode)(void *, struct inode *);

typedef void (*btf_trace_ext4_ext_convert_to_initialized_enter)(void *, struct inode *, struct ext4_map_blocks *, struct ext4_extent *);

typedef void (*btf_trace_ext4_ext_convert_to_initialized_fastpath)(void *, struct inode *, struct ext4_map_blocks *, struct ext4_extent *, struct ext4_extent *);

typedef void (*btf_trace_ext4_ext_handle_unwritten_extents)(void *, struct inode *, struct ext4_map_blocks *, int, unsigned int, ext4_fsblk_t);

typedef void (*btf_trace_ext4_ext_load_extent)(void *, struct inode *, ext4_lblk_t, ext4_fsblk_t);

typedef void (*btf_trace_ext4_ext_map_blocks_enter)(void *, struct inode *, ext4_lblk_t, unsigned int, unsigned int);

typedef void (*btf_trace_ext4_ext_map_blocks_exit)(void *, struct inode *, unsigned int, struct ext4_map_blocks *, int);

typedef void (*btf_trace_ext4_ext_remove_space)(void *, struct inode *, ext4_lblk_t, ext4_lblk_t, int);

typedef void (*btf_trace_ext4_ext_remove_space_done)(void *, struct inode *, ext4_lblk_t, ext4_lblk_t, int, struct partial_cluster *, __le16);

typedef void (*btf_trace_ext4_ext_rm_idx)(void *, struct inode *, ext4_fsblk_t);

typedef void (*btf_trace_ext4_ext_rm_leaf)(void *, struct inode *, ext4_lblk_t, struct ext4_extent *, struct partial_cluster *);

typedef void (*btf_trace_ext4_ext_show_extent)(void *, struct inode *, ext4_lblk_t, ext4_fsblk_t, short unsigned int);

typedef void (*btf_trace_ext4_fallocate_enter)(void *, struct inode *, loff_t, loff_t, int);

typedef void (*btf_trace_ext4_fallocate_exit)(void *, struct inode *, loff_t, unsigned int, int);

typedef void (*btf_trace_ext4_fc_cleanup)(void *, journal_t *, int, tid_t);

typedef void (*btf_trace_ext4_fc_commit_start)(void *, struct super_block *, tid_t);

typedef void (*btf_trace_ext4_fc_commit_stop)(void *, struct super_block *, int, int, tid_t);

typedef void (*btf_trace_ext4_fc_replay)(void *, struct super_block *, int, int, int, int);

typedef void (*btf_trace_ext4_fc_replay_scan)(void *, struct super_block *, int, int);

typedef void (*btf_trace_ext4_fc_stats)(void *, struct super_block *);

typedef void (*btf_trace_ext4_fc_track_create)(void *, handle_t *, struct inode *, struct dentry *, int);

typedef void (*btf_trace_ext4_fc_track_inode)(void *, handle_t *, struct inode *, int);

typedef void (*btf_trace_ext4_fc_track_link)(void *, handle_t *, struct inode *, struct dentry *, int);

typedef void (*btf_trace_ext4_fc_track_range)(void *, handle_t *, struct inode *, long int, long int, int);

typedef void (*btf_trace_ext4_fc_track_unlink)(void *, handle_t *, struct inode *, struct dentry *, int);

typedef void (*btf_trace_ext4_forget)(void *, struct inode *, int, __u64);

typedef void (*btf_trace_ext4_free_blocks)(void *, struct inode *, __u64, long unsigned int, int);

typedef void (*btf_trace_ext4_free_inode)(void *, struct inode *);

typedef void (*btf_trace_ext4_fsmap_high_key)(void *, struct super_block *, u32, u32, u64, u64, u64);

typedef void (*btf_trace_ext4_fsmap_low_key)(void *, struct super_block *, u32, u32, u64, u64, u64);

typedef void (*btf_trace_ext4_fsmap_mapping)(void *, struct super_block *, u32, u32, u64, u64, u64);

typedef void (*btf_trace_ext4_get_implied_cluster_alloc_exit)(void *, struct super_block *, struct ext4_map_blocks *, int);

typedef void (*btf_trace_ext4_getfsmap_high_key)(void *, struct super_block *, struct ext4_fsmap *);

typedef void (*btf_trace_ext4_getfsmap_low_key)(void *, struct super_block *, struct ext4_fsmap *);

typedef void (*btf_trace_ext4_getfsmap_mapping)(void *, struct super_block *, struct ext4_fsmap *);

typedef void (*btf_trace_ext4_ind_map_blocks_enter)(void *, struct inode *, ext4_lblk_t, unsigned int, unsigned int);

typedef void (*btf_trace_ext4_ind_map_blocks_exit)(void *, struct inode *, unsigned int, struct ext4_map_blocks *, int);

typedef void (*btf_trace_ext4_insert_range)(void *, struct inode *, loff_t, loff_t);

typedef void (*btf_trace_ext4_invalidate_folio)(void *, struct folio *, size_t, size_t);

typedef void (*btf_trace_ext4_journal_start_inode)(void *, struct inode *, int, int, int, int, long unsigned int);

typedef void (*btf_trace_ext4_journal_start_reserved)(void *, struct super_block *, int, long unsigned int);

typedef void (*btf_trace_ext4_journal_start_sb)(void *, struct super_block *, int, int, int, int, long unsigned int);

typedef void (*btf_trace_ext4_journalled_invalidate_folio)(void *, struct folio *, size_t, size_t);

typedef void (*btf_trace_ext4_journalled_write_end)(void *, struct inode *, loff_t, unsigned int, unsigned int);

typedef void (*btf_trace_ext4_lazy_itable_init)(void *, struct super_block *, ext4_group_t);

typedef void (*btf_trace_ext4_load_inode)(void *, struct super_block *, long unsigned int);

typedef void (*btf_trace_ext4_load_inode_bitmap)(void *, struct super_block *, long unsigned int);

typedef void (*btf_trace_ext4_mark_inode_dirty)(void *, struct inode *, long unsigned int);

typedef void (*btf_trace_ext4_mb_bitmap_load)(void *, struct super_block *, long unsigned int);

typedef void (*btf_trace_ext4_mb_buddy_bitmap_load)(void *, struct super_block *, long unsigned int);

typedef void (*btf_trace_ext4_mb_discard_preallocations)(void *, struct super_block *, int);

typedef void (*btf_trace_ext4_mb_new_group_pa)(void *, struct ext4_allocation_context *, struct ext4_prealloc_space *);

typedef void (*btf_trace_ext4_mb_new_inode_pa)(void *, struct ext4_allocation_context *, struct ext4_prealloc_space *);

typedef void (*btf_trace_ext4_mb_release_group_pa)(void *, struct super_block *, struct ext4_prealloc_space *);

typedef void (*btf_trace_ext4_mb_release_inode_pa)(void *, struct ext4_prealloc_space *, long long unsigned int, unsigned int);

typedef void (*btf_trace_ext4_mballoc_alloc)(void *, struct ext4_allocation_context *);

typedef void (*btf_trace_ext4_mballoc_discard)(void *, struct super_block *, struct inode *, ext4_group_t, ext4_grpblk_t, ext4_grpblk_t);

typedef void (*btf_trace_ext4_mballoc_free)(void *, struct super_block *, struct inode *, ext4_group_t, ext4_grpblk_t, ext4_grpblk_t);

typedef void (*btf_trace_ext4_mballoc_prealloc)(void *, struct ext4_allocation_context *);

typedef void (*btf_trace_ext4_nfs_commit_metadata)(void *, struct inode *);

typedef void (*btf_trace_ext4_other_inode_update_time)(void *, struct inode *, ino_t);

typedef void (*btf_trace_ext4_prefetch_bitmaps)(void *, struct super_block *, ext4_group_t, ext4_group_t, unsigned int);

typedef void (*btf_trace_ext4_punch_hole)(void *, struct inode *, loff_t, loff_t, int);

typedef void (*btf_trace_ext4_read_block_bitmap_load)(void *, struct super_block *, long unsigned int, bool);

typedef void (*btf_trace_ext4_read_folio)(void *, struct inode *, struct folio *);

typedef void (*btf_trace_ext4_release_folio)(void *, struct inode *, struct folio *);

typedef void (*btf_trace_ext4_remove_blocks)(void *, struct inode *, struct ext4_extent *, ext4_lblk_t, ext4_fsblk_t, struct partial_cluster *);

typedef void (*btf_trace_ext4_request_blocks)(void *, struct ext4_allocation_request *);

typedef void (*btf_trace_ext4_request_inode)(void *, struct inode *, int);

typedef void (*btf_trace_ext4_shutdown)(void *, struct super_block *, long unsigned int);

typedef void (*btf_trace_ext4_sync_file_enter)(void *, struct file *, int);

typedef void (*btf_trace_ext4_sync_file_exit)(void *, struct inode *, int);

typedef void (*btf_trace_ext4_sync_fs)(void *, struct super_block *, int);

typedef void (*btf_trace_ext4_trim_all_free)(void *, struct super_block *, ext4_group_t, ext4_grpblk_t, ext4_grpblk_t);

typedef void (*btf_trace_ext4_trim_extent)(void *, struct super_block *, ext4_group_t, ext4_grpblk_t, ext4_grpblk_t);

typedef void (*btf_trace_ext4_truncate_enter)(void *, struct inode *);

typedef void (*btf_trace_ext4_truncate_exit)(void *, struct inode *);

typedef void (*btf_trace_ext4_unlink_enter)(void *, struct inode *, struct dentry *);

typedef void (*btf_trace_ext4_unlink_exit)(void *, struct dentry *, int);

typedef void (*btf_trace_ext4_update_sb)(void *, struct super_block *, ext4_fsblk_t, unsigned int);

typedef void (*btf_trace_ext4_write_begin)(void *, struct inode *, loff_t, unsigned int);

typedef void (*btf_trace_ext4_write_end)(void *, struct inode *, loff_t, unsigned int, unsigned int);

typedef void (*btf_trace_ext4_writepages)(void *, struct inode *, struct writeback_control *);

typedef void (*btf_trace_ext4_writepages_result)(void *, struct inode *, struct writeback_control *, int, int);

typedef void (*btf_trace_ext4_zero_range)(void *, struct inode *, loff_t, loff_t, int);

typedef void (*btf_trace_fcntl_setlk)(void *, struct inode *, struct file_lock *, int);

typedef void (*btf_trace_fib6_table_lookup)(void *, const struct net *, const struct fib6_result *, struct fib6_table *, const struct flowi6 *);

typedef void (*btf_trace_fib_table_lookup)(void *, u32, const struct flowi4 *, const struct fib_nh_common *, int);

typedef void (*btf_trace_file_check_and_advance_wb_err)(void *, struct file *, errseq_t);

typedef void (*btf_trace_filemap_set_wb_err)(void *, struct address_space *, errseq_t);

typedef void (*btf_trace_fill_mg_cmtime)(void *, struct inode *, struct timespec64 *, struct timespec64 *);

typedef void (*btf_trace_finish_task_reaping)(void *, int);

typedef void (*btf_trace_flock_lock_inode)(void *, struct inode *, struct file_lock *, int);

typedef void (*btf_trace_folio_wait_writeback)(void *, struct folio *, struct address_space *);

typedef void (*btf_trace_free_vmap_area_noflush)(void *, long unsigned int, long unsigned int, long unsigned int);

typedef void (*btf_trace_g4x_wm)(void *, struct intel_crtc *, const struct g4x_wm_values *);

typedef void (*btf_trace_generic_add_lease)(void *, struct inode *, struct file_lease *);

typedef void (*btf_trace_generic_delete_lease)(void *, struct inode *, struct file_lease *);

typedef void (*btf_trace_global_dirty_state)(void *, long unsigned int, long unsigned int);

typedef void (*btf_trace_guest_halt_poll_ns)(void *, bool, unsigned int, unsigned int);

typedef void (*btf_trace_handshake_cancel)(void *, const struct net *, const struct handshake_req *, const struct sock *);

typedef void (*btf_trace_handshake_cancel_busy)(void *, const struct net *, const struct handshake_req *, const struct sock *);

typedef void (*btf_trace_handshake_cancel_none)(void *, const struct net *, const struct handshake_req *, const struct sock *);

typedef void (*btf_trace_handshake_cmd_accept)(void *, const struct net *, const struct handshake_req *, const struct sock *, int);

typedef void (*btf_trace_handshake_cmd_accept_err)(void *, const struct net *, const struct handshake_req *, const struct sock *, int);

typedef void (*btf_trace_handshake_cmd_done)(void *, const struct net *, const struct handshake_req *, const struct sock *, int);

typedef void (*btf_trace_handshake_cmd_done_err)(void *, const struct net *, const struct handshake_req *, const struct sock *, int);

typedef void (*btf_trace_handshake_complete)(void *, const struct net *, const struct handshake_req *, const struct sock *, int);

typedef void (*btf_trace_handshake_destruct)(void *, const struct net *, const struct handshake_req *, const struct sock *);

typedef void (*btf_trace_handshake_notify_err)(void *, const struct net *, const struct handshake_req *, const struct sock *, int);

typedef void (*btf_trace_handshake_submit)(void *, const struct net *, const struct handshake_req *, const struct sock *);

typedef void (*btf_trace_handshake_submit_err)(void *, const struct net *, const struct handshake_req *, const struct sock *, int);

typedef void (*btf_trace_hda_get_response)(void *, struct hdac_bus *, unsigned int, unsigned int);

typedef void (*btf_trace_hda_send_cmd)(void *, struct hdac_bus *, unsigned int);

typedef void (*btf_trace_hda_unsol_event)(void *, struct hdac_bus *, u32, u32);

typedef void (*btf_trace_hrtimer_cancel)(void *, struct hrtimer *);

typedef void (*btf_trace_hrtimer_expire_entry)(void *, struct hrtimer *, ktime_t *);

typedef void (*btf_trace_hrtimer_expire_exit)(void *, struct hrtimer *);

typedef void (*btf_trace_hrtimer_init)(void *, struct hrtimer *, clockid_t, enum hrtimer_mode);

typedef void (*btf_trace_hrtimer_start)(void *, struct hrtimer *, enum hrtimer_mode);

typedef void (*btf_trace_hugetlbfs_alloc_inode)(void *, struct inode *, struct inode *, int);

typedef void (*btf_trace_hugetlbfs_evict_inode)(void *, struct inode *);

typedef void (*btf_trace_hugetlbfs_fallocate)(void *, struct inode *, int, loff_t, loff_t, int);

typedef void (*btf_trace_hugetlbfs_free_inode)(void *, struct inode *);

typedef void (*btf_trace_hugetlbfs_setattr)(void *, struct inode *, struct dentry *, struct iattr *);

typedef void (*btf_trace_hwmon_attr_show)(void *, int, const char *, long int);

typedef void (*btf_trace_hwmon_attr_show_string)(void *, int, const char *, const char *);

typedef void (*btf_trace_hwmon_attr_store)(void *, int, const char *, long int);

typedef void (*btf_trace_i2c_read)(void *, const struct i2c_adapter *, const struct i2c_msg *, int);

typedef void (*btf_trace_i2c_reply)(void *, const struct i2c_adapter *, const struct i2c_msg *, int);

typedef void (*btf_trace_i2c_result)(void *, const struct i2c_adapter *, int, int);

typedef void (*btf_trace_i2c_write)(void *, const struct i2c_adapter *, const struct i2c_msg *, int);

typedef void (*btf_trace_i915_context_create)(void *, struct i915_gem_context *);

typedef void (*btf_trace_i915_context_free)(void *, struct i915_gem_context *);

typedef void (*btf_trace_i915_gem_evict)(void *, struct i915_address_space *, u64, u64, unsigned int);

typedef void (*btf_trace_i915_gem_evict_node)(void *, struct i915_address_space *, struct drm_mm_node *, unsigned int);

typedef void (*btf_trace_i915_gem_evict_vm)(void *, struct i915_address_space *);

typedef void (*btf_trace_i915_gem_object_clflush)(void *, struct drm_i915_gem_object *);

typedef void (*btf_trace_i915_gem_object_create)(void *, struct drm_i915_gem_object *);

typedef void (*btf_trace_i915_gem_object_destroy)(void *, struct drm_i915_gem_object *);

typedef void (*btf_trace_i915_gem_object_fault)(void *, struct drm_i915_gem_object *, u64, bool, bool);

typedef void (*btf_trace_i915_gem_object_pread)(void *, struct drm_i915_gem_object *, u64, u64);

typedef void (*btf_trace_i915_gem_object_pwrite)(void *, struct drm_i915_gem_object *, u64, u64);

typedef void (*btf_trace_i915_gem_shrink)(void *, struct drm_i915_private *, long unsigned int, unsigned int);

typedef void (*btf_trace_i915_ppgtt_create)(void *, struct i915_address_space *);

typedef void (*btf_trace_i915_ppgtt_release)(void *, struct i915_address_space *);

typedef void (*btf_trace_i915_reg_rw)(void *, bool, i915_reg_t, u64, int, bool);

typedef void (*btf_trace_i915_request_add)(void *, struct i915_request *);

typedef void (*btf_trace_i915_request_queue)(void *, struct i915_request *, u32);

typedef void (*btf_trace_i915_request_retire)(void *, struct i915_request *);

typedef void (*btf_trace_i915_request_wait_begin)(void *, struct i915_request *, unsigned int);

typedef void (*btf_trace_i915_request_wait_end)(void *, struct i915_request *);

typedef void (*btf_trace_i915_vma_bind)(void *, struct i915_vma *, unsigned int);

typedef void (*btf_trace_i915_vma_unbind)(void *, struct i915_vma *);

typedef void (*btf_trace_icmp_send)(void *, const struct sk_buff *, int, int);

typedef void (*btf_trace_inet_sk_error_report)(void *, const struct sock *);

typedef void (*btf_trace_inet_sock_set_state)(void *, const struct sock *, const int, const int);

typedef void (*btf_trace_initcall_finish)(void *, initcall_t, int);

typedef void (*btf_trace_initcall_level)(void *, const char *);

typedef void (*btf_trace_initcall_start)(void *, initcall_t);

typedef void (*btf_trace_inode_set_ctime_to_ts)(void *, struct inode *, struct timespec64 *);

typedef void (*btf_trace_intel_cpu_fifo_underrun)(void *, struct intel_display *, enum pipe);

typedef void (*btf_trace_intel_crtc_flip_done)(void *, struct intel_crtc *);

typedef void (*btf_trace_intel_crtc_vblank_work_end)(void *, struct intel_crtc *);

typedef void (*btf_trace_intel_crtc_vblank_work_start)(void *, struct intel_crtc *);

typedef void (*btf_trace_intel_fbc_activate)(void *, struct intel_plane *);

typedef void (*btf_trace_intel_fbc_deactivate)(void *, struct intel_plane *);

typedef void (*btf_trace_intel_fbc_nuke)(void *, struct intel_plane *);

typedef void (*btf_trace_intel_frontbuffer_flush)(void *, struct intel_display *, unsigned int, unsigned int);

typedef void (*btf_trace_intel_frontbuffer_invalidate)(void *, struct intel_display *, unsigned int, unsigned int);

typedef void (*btf_trace_intel_memory_cxsr)(void *, struct intel_display *, bool, bool);

typedef void (*btf_trace_intel_pch_fifo_underrun)(void *, struct intel_display *, enum pipe);

typedef void (*btf_trace_intel_pipe_crc)(void *, struct intel_crtc *, const u32 *);

typedef void (*btf_trace_intel_pipe_disable)(void *, struct intel_crtc *);

typedef void (*btf_trace_intel_pipe_enable)(void *, struct intel_crtc *);

typedef void (*btf_trace_intel_pipe_update_end)(void *, struct intel_crtc *, u32, int);

typedef void (*btf_trace_intel_pipe_update_start)(void *, struct intel_crtc *);

typedef void (*btf_trace_intel_pipe_update_vblank_evaded)(void *, struct intel_crtc *);

typedef void (*btf_trace_intel_plane_async_flip)(void *, struct intel_plane *, struct intel_crtc *, bool);

typedef void (*btf_trace_intel_plane_disable_arm)(void *, struct intel_plane *, struct intel_crtc *);

typedef void (*btf_trace_intel_plane_update_arm)(void *, struct intel_plane *, struct intel_crtc *);

typedef void (*btf_trace_intel_plane_update_noarm)(void *, struct intel_plane *, struct intel_crtc *);

typedef void (*btf_trace_io_page_fault)(void *, struct device *, long unsigned int, int);

typedef void (*btf_trace_io_uring_complete)(void *, struct io_ring_ctx *, void *, struct io_uring_cqe *);

typedef void (*btf_trace_io_uring_cqe_overflow)(void *, void *, long long unsigned int, s32, u32, void *);

typedef void (*btf_trace_io_uring_cqring_wait)(void *, void *, int);

typedef void (*btf_trace_io_uring_create)(void *, int, void *, u32, u32, u32);

typedef void (*btf_trace_io_uring_defer)(void *, struct io_kiocb *);

typedef void (*btf_trace_io_uring_fail_link)(void *, struct io_kiocb *, struct io_kiocb *);

typedef void (*btf_trace_io_uring_file_get)(void *, struct io_kiocb *, int);

typedef void (*btf_trace_io_uring_link)(void *, struct io_kiocb *, struct io_kiocb *);

typedef void (*btf_trace_io_uring_local_work_run)(void *, void *, int, unsigned int);

typedef void (*btf_trace_io_uring_poll_arm)(void *, struct io_kiocb *, int, int);

typedef void (*btf_trace_io_uring_queue_async_work)(void *, struct io_kiocb *, int);

typedef void (*btf_trace_io_uring_register)(void *, void *, unsigned int, unsigned int, unsigned int, long int);

typedef void (*btf_trace_io_uring_req_failed)(void *, const struct io_uring_sqe *, struct io_kiocb *, int);

typedef void (*btf_trace_io_uring_short_write)(void *, void *, u64, u64, u64);

typedef void (*btf_trace_io_uring_submit_req)(void *, struct io_kiocb *);

typedef void (*btf_trace_io_uring_task_add)(void *, struct io_kiocb *, int);

typedef void (*btf_trace_io_uring_task_work_run)(void *, void *, unsigned int);

typedef void (*btf_trace_iocost_inuse_adjust)(void *, struct ioc_gq *, const char *, struct ioc_now *, u32, u32, u64, u64);

typedef void (*btf_trace_iocost_inuse_shortage)(void *, struct ioc_gq *, const char *, struct ioc_now *, u32, u32, u64, u64);

typedef void (*btf_trace_iocost_inuse_transfer)(void *, struct ioc_gq *, const char *, struct ioc_now *, u32, u32, u64, u64);

typedef void (*btf_trace_iocost_ioc_vrate_adj)(void *, struct ioc *, u64, u32 *, u32, int, int);

typedef void (*btf_trace_iocost_iocg_activate)(void *, struct ioc_gq *, const char *, struct ioc_now *, u64, u64, u64);

typedef void (*btf_trace_iocost_iocg_forgive_debt)(void *, struct ioc_gq *, const char *, struct ioc_now *, u32, u64, u64, u64, u64);

typedef void (*btf_trace_iocost_iocg_idle)(void *, struct ioc_gq *, const char *, struct ioc_now *, u64, u64, u64);

typedef void (*btf_trace_iomap_dio_complete)(void *, struct kiocb *, int, ssize_t);

typedef void (*btf_trace_iomap_dio_invalidate_fail)(void *, struct inode *, loff_t, u64);

typedef void (*btf_trace_iomap_dio_rw_begin)(void *, struct kiocb *, struct iov_iter *, unsigned int, size_t);

typedef void (*btf_trace_iomap_dio_rw_queued)(void *, struct inode *, loff_t, u64);

typedef void (*btf_trace_iomap_invalidate_folio)(void *, struct inode *, loff_t, u64);

typedef void (*btf_trace_iomap_iter)(void *, struct iomap_iter *, const void *, long unsigned int);

typedef void (*btf_trace_iomap_iter_dstmap)(void *, struct inode *, struct iomap *);

typedef void (*btf_trace_iomap_iter_srcmap)(void *, struct inode *, struct iomap *);

typedef void (*btf_trace_iomap_readahead)(void *, struct inode *, int);

typedef void (*btf_trace_iomap_readpage)(void *, struct inode *, int);

typedef void (*btf_trace_iomap_release_folio)(void *, struct inode *, loff_t, u64);

typedef void (*btf_trace_iomap_writepage)(void *, struct inode *, loff_t, u64);

typedef void (*btf_trace_iomap_writepage_map)(void *, struct inode *, u64, unsigned int, struct iomap *);

typedef void (*btf_trace_ipi_entry)(void *, const char *);

typedef void (*btf_trace_ipi_exit)(void *, const char *);

typedef void (*btf_trace_ipi_raise)(void *, const struct cpumask *, const char *);

typedef void (*btf_trace_ipi_send_cpu)(void *, const unsigned int, long unsigned int, void *);

typedef void (*btf_trace_ipi_send_cpumask)(void *, const struct cpumask *, long unsigned int, void *);

typedef void (*btf_trace_irq_handler_entry)(void *, int, struct irqaction *);

typedef void (*btf_trace_irq_handler_exit)(void *, int, struct irqaction *, int);

typedef void (*btf_trace_irq_matrix_alloc)(void *, int, unsigned int, struct irq_matrix *, struct cpumap *);

typedef void (*btf_trace_irq_matrix_alloc_managed)(void *, int, unsigned int, struct irq_matrix *, struct cpumap *);

typedef void (*btf_trace_irq_matrix_alloc_reserved)(void *, int, unsigned int, struct irq_matrix *, struct cpumap *);

typedef void (*btf_trace_irq_matrix_assign)(void *, int, unsigned int, struct irq_matrix *, struct cpumap *);

typedef void (*btf_trace_irq_matrix_assign_system)(void *, int, struct irq_matrix *);

typedef void (*btf_trace_irq_matrix_free)(void *, int, unsigned int, struct irq_matrix *, struct cpumap *);

typedef void (*btf_trace_irq_matrix_offline)(void *, struct irq_matrix *);

typedef void (*btf_trace_irq_matrix_online)(void *, struct irq_matrix *);

typedef void (*btf_trace_irq_matrix_remove_managed)(void *, int, unsigned int, struct irq_matrix *, struct cpumap *);

typedef void (*btf_trace_irq_matrix_remove_reserved)(void *, struct irq_matrix *);

typedef void (*btf_trace_irq_matrix_reserve)(void *, struct irq_matrix *);

typedef void (*btf_trace_irq_matrix_reserve_managed)(void *, int, unsigned int, struct irq_matrix *, struct cpumap *);

typedef void (*btf_trace_irq_work_entry)(void *, int);

typedef void (*btf_trace_irq_work_exit)(void *, int);

typedef void (*btf_trace_itimer_expire)(void *, int, struct pid *, long long unsigned int);

typedef void (*btf_trace_itimer_state)(void *, int, const struct itimerspec64 * const, long long unsigned int);

typedef void (*btf_trace_jbd2_checkpoint)(void *, journal_t *, int);

typedef void (*btf_trace_jbd2_checkpoint_stats)(void *, dev_t, tid_t, struct transaction_chp_stats_s *);

typedef void (*btf_trace_jbd2_commit_flushing)(void *, journal_t *, transaction_t *);

typedef void (*btf_trace_jbd2_commit_locking)(void *, journal_t *, transaction_t *);

typedef void (*btf_trace_jbd2_commit_logging)(void *, journal_t *, transaction_t *);

typedef void (*btf_trace_jbd2_drop_transaction)(void *, journal_t *, transaction_t *);

typedef void (*btf_trace_jbd2_end_commit)(void *, journal_t *, transaction_t *);

typedef void (*btf_trace_jbd2_handle_extend)(void *, dev_t, tid_t, unsigned int, unsigned int, int, int);

typedef void (*btf_trace_jbd2_handle_restart)(void *, dev_t, tid_t, unsigned int, unsigned int, int);

typedef void (*btf_trace_jbd2_handle_start)(void *, dev_t, tid_t, unsigned int, unsigned int, int);

typedef void (*btf_trace_jbd2_handle_stats)(void *, dev_t, tid_t, unsigned int, unsigned int, int, int, int, int);

typedef void (*btf_trace_jbd2_lock_buffer_stall)(void *, dev_t, long unsigned int);

typedef void (*btf_trace_jbd2_run_stats)(void *, dev_t, tid_t, struct transaction_run_stats_s *);

typedef void (*btf_trace_jbd2_shrink_checkpoint_list)(void *, journal_t *, tid_t, tid_t, tid_t, long unsigned int, tid_t);

typedef void (*btf_trace_jbd2_shrink_count)(void *, journal_t *, long unsigned int, long unsigned int);

typedef void (*btf_trace_jbd2_shrink_scan_enter)(void *, journal_t *, long unsigned int, long unsigned int);

typedef void (*btf_trace_jbd2_shrink_scan_exit)(void *, journal_t *, long unsigned int, long unsigned int, long unsigned int);

typedef void (*btf_trace_jbd2_start_commit)(void *, journal_t *, transaction_t *);

typedef void (*btf_trace_jbd2_submit_inode_data)(void *, struct inode *);

typedef void (*btf_trace_jbd2_update_log_tail)(void *, journal_t *, tid_t, long unsigned int, long unsigned int);

typedef void (*btf_trace_jbd2_write_superblock)(void *, journal_t *, blk_opf_t);

typedef void (*btf_trace_kfree)(void *, long unsigned int, const void *);

typedef void (*btf_trace_kfree_skb)(void *, struct sk_buff *, void *, enum skb_drop_reason, struct sock *);

typedef void (*btf_trace_kmalloc)(void *, long unsigned int, const void *, size_t, size_t, gfp_t, int);

typedef void (*btf_trace_kmem_cache_alloc)(void *, long unsigned int, const void *, struct kmem_cache *, gfp_t, int);

typedef void (*btf_trace_kmem_cache_free)(void *, long unsigned int, const void *, const struct kmem_cache *);

typedef void (*btf_trace_kyber_adjust)(void *, dev_t, const char *, unsigned int);

typedef void (*btf_trace_kyber_latency)(void *, dev_t, const char *, const char *, unsigned int, unsigned int, unsigned int, unsigned int);

typedef void (*btf_trace_kyber_throttled)(void *, dev_t, const char *);

typedef void (*btf_trace_leases_conflict)(void *, bool, struct file_lease *, struct file_lease *);

typedef void (*btf_trace_local_timer_entry)(void *, int);

typedef void (*btf_trace_local_timer_exit)(void *, int);

typedef void (*btf_trace_locks_get_lock_context)(void *, struct inode *, int, struct file_lock_context *);

typedef void (*btf_trace_locks_remove_posix)(void *, struct inode *, struct file_lock *, int);

typedef void (*btf_trace_ma_op)(void *, const char *, struct ma_state *);

typedef void (*btf_trace_ma_read)(void *, const char *, struct ma_state *);

typedef void (*btf_trace_ma_write)(void *, const char *, struct ma_state *, long unsigned int, void *);

typedef void (*btf_trace_map)(void *, long unsigned int, phys_addr_t, size_t);

typedef void (*btf_trace_mark_victim)(void *, struct task_struct *, uid_t);

typedef void (*btf_trace_mce_record)(void *, struct mce_hw_err *);

typedef void (*btf_trace_mdio_access)(void *, struct mii_bus *, char, u8, unsigned int, u16, int);

typedef void (*btf_trace_mei_pci_cfg_read)(void *, const struct device *, const char *, u32, u32);

typedef void (*btf_trace_mei_reg_read)(void *, const struct device *, const char *, u32, u32);

typedef void (*btf_trace_mei_reg_write)(void *, const struct device *, const char *, u32, u32);

typedef void (*btf_trace_mem_connect)(void *, const struct xdp_mem_allocator *, const struct xdp_rxq_info *);

typedef void (*btf_trace_mem_disconnect)(void *, const struct xdp_mem_allocator *);

typedef void (*btf_trace_mem_return_failed)(void *, const struct xdp_mem_info *, const struct page *);

typedef void (*btf_trace_mm_alloc_contig_migrate_range_info)(void *, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, int);

typedef void (*btf_trace_mm_compaction_begin)(void *, struct compact_control *, long unsigned int, long unsigned int, bool);

typedef void (*btf_trace_mm_compaction_defer_compaction)(void *, struct zone *, int);

typedef void (*btf_trace_mm_compaction_defer_reset)(void *, struct zone *, int);

typedef void (*btf_trace_mm_compaction_deferred)(void *, struct zone *, int);

typedef void (*btf_trace_mm_compaction_end)(void *, struct compact_control *, long unsigned int, long unsigned int, bool, int);

typedef void (*btf_trace_mm_compaction_fast_isolate_freepages)(void *, long unsigned int, long unsigned int, long unsigned int, long unsigned int);

typedef void (*btf_trace_mm_compaction_finished)(void *, struct zone *, int, int);

typedef void (*btf_trace_mm_compaction_isolate_freepages)(void *, long unsigned int, long unsigned int, long unsigned int, long unsigned int);

typedef void (*btf_trace_mm_compaction_isolate_migratepages)(void *, long unsigned int, long unsigned int, long unsigned int, long unsigned int);

typedef void (*btf_trace_mm_compaction_kcompactd_sleep)(void *, int);

typedef void (*btf_trace_mm_compaction_kcompactd_wake)(void *, int, int, enum zone_type);

typedef void (*btf_trace_mm_compaction_migratepages)(void *, unsigned int, unsigned int);

typedef void (*btf_trace_mm_compaction_suitable)(void *, struct zone *, int, int);

typedef void (*btf_trace_mm_compaction_try_to_compact_pages)(void *, int, gfp_t, int);

typedef void (*btf_trace_mm_compaction_wakeup_kcompactd)(void *, int, int, enum zone_type);

typedef void (*btf_trace_mm_filemap_add_to_page_cache)(void *, struct folio *);

typedef void (*btf_trace_mm_filemap_delete_from_page_cache)(void *, struct folio *);

typedef void (*btf_trace_mm_filemap_fault)(void *, struct address_space *, long unsigned int);

typedef void (*btf_trace_mm_filemap_get_pages)(void *, struct address_space *, long unsigned int, long unsigned int);

typedef void (*btf_trace_mm_filemap_map_pages)(void *, struct address_space *, long unsigned int, long unsigned int);

typedef void (*btf_trace_mm_lru_activate)(void *, struct folio *);

typedef void (*btf_trace_mm_lru_insertion)(void *, struct folio *);

typedef void (*btf_trace_mm_migrate_pages)(void *, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, enum migrate_mode, int);

typedef void (*btf_trace_mm_migrate_pages_start)(void *, enum migrate_mode, int);

typedef void (*btf_trace_mm_page_alloc)(void *, struct page *, unsigned int, gfp_t, int);

typedef void (*btf_trace_mm_page_alloc_extfrag)(void *, struct page *, int, int, int, int);

typedef void (*btf_trace_mm_page_alloc_zone_locked)(void *, struct page *, unsigned int, int, int);

typedef void (*btf_trace_mm_page_free)(void *, struct page *, unsigned int);

typedef void (*btf_trace_mm_page_free_batched)(void *, struct page *);

typedef void (*btf_trace_mm_page_pcpu_drain)(void *, struct page *, unsigned int, int);

typedef void (*btf_trace_mm_shrink_slab_end)(void *, struct shrinker *, int, int, long int, long int, long int);

typedef void (*btf_trace_mm_shrink_slab_start)(void *, struct shrinker *, struct shrink_control *, long int, long unsigned int, long long unsigned int, long unsigned int, int);

typedef void (*btf_trace_mm_vmscan_direct_reclaim_begin)(void *, int, gfp_t);

typedef void (*btf_trace_mm_vmscan_direct_reclaim_end)(void *, long unsigned int);

typedef void (*btf_trace_mm_vmscan_kswapd_sleep)(void *, int);

typedef void (*btf_trace_mm_vmscan_kswapd_wake)(void *, int, int, int);

typedef void (*btf_trace_mm_vmscan_lru_isolate)(void *, int, int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, int);

typedef void (*btf_trace_mm_vmscan_lru_shrink_active)(void *, int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, int, int);

typedef void (*btf_trace_mm_vmscan_lru_shrink_inactive)(void *, int, long unsigned int, long unsigned int, struct reclaim_stat *, int, int);

typedef void (*btf_trace_mm_vmscan_node_reclaim_begin)(void *, int, int, gfp_t);

typedef void (*btf_trace_mm_vmscan_node_reclaim_end)(void *, long unsigned int);

typedef void (*btf_trace_mm_vmscan_reclaim_pages)(void *, int, long unsigned int, long unsigned int, struct reclaim_stat *);

typedef void (*btf_trace_mm_vmscan_throttled)(void *, int, int, int, int);

typedef void (*btf_trace_mm_vmscan_wakeup_kswapd)(void *, int, int, int, gfp_t);

typedef void (*btf_trace_mm_vmscan_write_folio)(void *, struct folio *);

typedef void (*btf_trace_mmap_lock_acquire_returned)(void *, struct mm_struct *, bool, bool);

typedef void (*btf_trace_mmap_lock_released)(void *, struct mm_struct *, bool);

typedef void (*btf_trace_mmap_lock_start_locking)(void *, struct mm_struct *, bool);

typedef void (*btf_trace_module_free)(void *, struct module *);

typedef void (*btf_trace_module_get)(void *, struct module *, long unsigned int);

typedef void (*btf_trace_module_load)(void *, struct module *);

typedef void (*btf_trace_module_put)(void *, struct module *, long unsigned int);

typedef void (*btf_trace_module_request)(void *, char *, bool, long unsigned int);

typedef void (*btf_trace_napi_gro_frags_entry)(void *, const struct sk_buff *);

typedef void (*btf_trace_napi_gro_frags_exit)(void *, int);

typedef void (*btf_trace_napi_gro_receive_entry)(void *, const struct sk_buff *);

typedef void (*btf_trace_napi_gro_receive_exit)(void *, int);

typedef void (*btf_trace_napi_poll)(void *, struct napi_struct *, int, int);

typedef void (*btf_trace_neigh_cleanup_and_release)(void *, struct neighbour *, int);

typedef void (*btf_trace_neigh_create)(void *, struct neigh_table *, struct net_device *, const void *, const struct neighbour *, bool);

typedef void (*btf_trace_neigh_event_send_dead)(void *, struct neighbour *, int);

typedef void (*btf_trace_neigh_event_send_done)(void *, struct neighbour *, int);

typedef void (*btf_trace_neigh_timer_handler)(void *, struct neighbour *, int);

typedef void (*btf_trace_neigh_update)(void *, struct neighbour *, const u8 *, u8, u32, u32);

typedef void (*btf_trace_neigh_update_done)(void *, struct neighbour *, int);

typedef void (*btf_trace_net_dev_queue)(void *, struct sk_buff *);

typedef void (*btf_trace_net_dev_start_xmit)(void *, const struct sk_buff *, const struct net_device *);

typedef void (*btf_trace_net_dev_xmit)(void *, struct sk_buff *, int, struct net_device *, unsigned int);

typedef void (*btf_trace_net_dev_xmit_timeout)(void *, struct net_device *, int);

typedef void (*btf_trace_netfs_collect)(void *, const struct netfs_io_request *);

typedef void (*btf_trace_netfs_collect_folio)(void *, const struct netfs_io_request *, const struct folio *, long long unsigned int, long long unsigned int);

typedef void (*btf_trace_netfs_collect_gap)(void *, const struct netfs_io_request *, const struct netfs_io_stream *, long long unsigned int, char);

typedef void (*btf_trace_netfs_collect_sreq)(void *, const struct netfs_io_request *, const struct netfs_io_subrequest *);

typedef void (*btf_trace_netfs_collect_state)(void *, const struct netfs_io_request *, long long unsigned int, unsigned int);

typedef void (*btf_trace_netfs_collect_stream)(void *, const struct netfs_io_request *, const struct netfs_io_stream *);

typedef void (*btf_trace_netfs_failure)(void *, struct netfs_io_request *, struct netfs_io_subrequest *, int, enum netfs_failure);

typedef void (*btf_trace_netfs_folio)(void *, struct folio *, enum netfs_folio_trace);

typedef void (*btf_trace_netfs_folioq)(void *, const struct folio_queue *, enum netfs_folioq_trace);

typedef void (*btf_trace_netfs_read)(void *, struct netfs_io_request *, loff_t, size_t, enum netfs_read_trace);

typedef void (*btf_trace_netfs_rreq)(void *, struct netfs_io_request *, enum netfs_rreq_trace);

typedef void (*btf_trace_netfs_rreq_ref)(void *, unsigned int, int, enum netfs_rreq_ref_trace);

typedef void (*btf_trace_netfs_sreq)(void *, struct netfs_io_subrequest *, enum netfs_sreq_trace);

typedef void (*btf_trace_netfs_sreq_ref)(void *, unsigned int, unsigned int, int, enum netfs_sreq_ref_trace);

typedef void (*btf_trace_netfs_write)(void *, const struct netfs_io_request *, enum netfs_write_trace);

typedef void (*btf_trace_netfs_write_iter)(void *, const struct kiocb *, const struct iov_iter *);

typedef void (*btf_trace_netif_receive_skb)(void *, struct sk_buff *);

typedef void (*btf_trace_netif_receive_skb_entry)(void *, const struct sk_buff *);

typedef void (*btf_trace_netif_receive_skb_exit)(void *, int);

typedef void (*btf_trace_netif_receive_skb_list_entry)(void *, const struct sk_buff *);

typedef void (*btf_trace_netif_receive_skb_list_exit)(void *, int);

typedef void (*btf_trace_netif_rx)(void *, struct sk_buff *);

typedef void (*btf_trace_netif_rx_entry)(void *, const struct sk_buff *);

typedef void (*btf_trace_netif_rx_exit)(void *, int);

typedef void (*btf_trace_netlink_extack)(void *, const char *);

typedef void (*btf_trace_nfs4_access)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs4_cached_open)(void *, const struct nfs4_state *);

typedef void (*btf_trace_nfs4_cb_getattr)(void *, const struct nfs_client *, const struct nfs_fh *, const struct inode *, int);

typedef void (*btf_trace_nfs4_cb_layoutrecall_file)(void *, const struct nfs_client *, const struct nfs_fh *, const struct inode *, const nfs4_stateid *, int);

typedef void (*btf_trace_nfs4_cb_recall)(void *, const struct nfs_client *, const struct nfs_fh *, const struct inode *, const nfs4_stateid *, int);

typedef void (*btf_trace_nfs4_close)(void *, const struct nfs4_state *, const struct nfs_closeargs *, const struct nfs_closeres *, int);

typedef void (*btf_trace_nfs4_close_stateid_update_wait)(void *, const struct inode *, const nfs4_stateid *, int);

typedef void (*btf_trace_nfs4_commit)(void *, const struct nfs_commit_data *, int);

typedef void (*btf_trace_nfs4_delegreturn)(void *, const struct inode *, const nfs4_stateid *, int);

typedef void (*btf_trace_nfs4_delegreturn_exit)(void *, const struct nfs4_delegreturnargs *, const struct nfs4_delegreturnres *, int);

typedef void (*btf_trace_nfs4_fsinfo)(void *, const struct nfs_server *, const struct nfs_fh *, const struct nfs_fattr *, int);

typedef void (*btf_trace_nfs4_get_acl)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs4_get_fs_locations)(void *, const struct inode *, const struct qstr *, int);

typedef void (*btf_trace_nfs4_get_lock)(void *, const struct file_lock *, const struct nfs4_state *, int, int);

typedef void (*btf_trace_nfs4_getattr)(void *, const struct nfs_server *, const struct nfs_fh *, const struct nfs_fattr *, int);

typedef void (*btf_trace_nfs4_lookup)(void *, const struct inode *, const struct qstr *, int);

typedef void (*btf_trace_nfs4_lookup_root)(void *, const struct nfs_server *, const struct nfs_fh *, const struct nfs_fattr *, int);

typedef void (*btf_trace_nfs4_lookupp)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs4_map_gid_to_group)(void *, const char *, int, u32, int);

typedef void (*btf_trace_nfs4_map_group_to_gid)(void *, const char *, int, u32, int);

typedef void (*btf_trace_nfs4_map_name_to_uid)(void *, const char *, int, u32, int);

typedef void (*btf_trace_nfs4_map_uid_to_name)(void *, const char *, int, u32, int);

typedef void (*btf_trace_nfs4_mkdir)(void *, const struct inode *, const struct qstr *, int);

typedef void (*btf_trace_nfs4_mknod)(void *, const struct inode *, const struct qstr *, int);

typedef void (*btf_trace_nfs4_open_expired)(void *, const struct nfs_open_context *, int, int);

typedef void (*btf_trace_nfs4_open_file)(void *, const struct nfs_open_context *, int, int);

typedef void (*btf_trace_nfs4_open_reclaim)(void *, const struct nfs_open_context *, int, int);

typedef void (*btf_trace_nfs4_open_stateid_update)(void *, const struct inode *, const nfs4_stateid *, int);

typedef void (*btf_trace_nfs4_open_stateid_update_wait)(void *, const struct inode *, const nfs4_stateid *, int);

typedef void (*btf_trace_nfs4_read)(void *, const struct nfs_pgio_header *, int);

typedef void (*btf_trace_nfs4_readdir)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs4_readlink)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs4_reclaim_delegation)(void *, const struct inode *, fmode_t);

typedef void (*btf_trace_nfs4_remove)(void *, const struct inode *, const struct qstr *, int);

typedef void (*btf_trace_nfs4_rename)(void *, const struct inode *, const struct qstr *, const struct inode *, const struct qstr *, int);

typedef void (*btf_trace_nfs4_renew)(void *, const struct nfs_client *, int);

typedef void (*btf_trace_nfs4_renew_async)(void *, const struct nfs_client *, int);

typedef void (*btf_trace_nfs4_secinfo)(void *, const struct inode *, const struct qstr *, int);

typedef void (*btf_trace_nfs4_set_acl)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs4_set_delegation)(void *, const struct inode *, fmode_t);

typedef void (*btf_trace_nfs4_set_lock)(void *, const struct file_lock *, const struct nfs4_state *, const nfs4_stateid *, int, int);

typedef void (*btf_trace_nfs4_setattr)(void *, const struct inode *, const nfs4_stateid *, int);

typedef void (*btf_trace_nfs4_setclientid)(void *, const struct nfs_client *, int);

typedef void (*btf_trace_nfs4_setclientid_confirm)(void *, const struct nfs_client *, int);

typedef void (*btf_trace_nfs4_setup_sequence)(void *, const struct nfs4_session *, const struct nfs4_sequence_args *);

typedef void (*btf_trace_nfs4_state_lock_reclaim)(void *, const struct nfs4_state *, const struct nfs4_lock_state *);

typedef void (*btf_trace_nfs4_state_mgr)(void *, const struct nfs_client *);

typedef void (*btf_trace_nfs4_state_mgr_failed)(void *, const struct nfs_client *, const char *, int);

typedef void (*btf_trace_nfs4_symlink)(void *, const struct inode *, const struct qstr *, int);

typedef void (*btf_trace_nfs4_unlock)(void *, const struct file_lock *, const struct nfs4_state *, int, int);

typedef void (*btf_trace_nfs4_write)(void *, const struct nfs_pgio_header *, int);

typedef void (*btf_trace_nfs4_xdr_bad_filehandle)(void *, const struct xdr_stream *, u32, u32);

typedef void (*btf_trace_nfs4_xdr_bad_operation)(void *, const struct xdr_stream *, u32, u32);

typedef void (*btf_trace_nfs4_xdr_status)(void *, const struct xdr_stream *, u32, u32);

typedef void (*btf_trace_nfs_access_enter)(void *, const struct inode *);

typedef void (*btf_trace_nfs_access_exit)(void *, const struct inode *, unsigned int, unsigned int, int);

typedef void (*btf_trace_nfs_aop_readahead)(void *, const struct inode *, loff_t, unsigned int);

typedef void (*btf_trace_nfs_aop_readahead_done)(void *, const struct inode *, unsigned int, int);

typedef void (*btf_trace_nfs_aop_readpage)(void *, const struct inode *, loff_t, size_t);

typedef void (*btf_trace_nfs_aop_readpage_done)(void *, const struct inode *, loff_t, size_t, int);

typedef void (*btf_trace_nfs_async_rename_done)(void *, const struct inode *, const struct dentry *, const struct inode *, const struct dentry *, int);

typedef void (*btf_trace_nfs_atomic_open_enter)(void *, const struct inode *, const struct nfs_open_context *, unsigned int);

typedef void (*btf_trace_nfs_atomic_open_exit)(void *, const struct inode *, const struct nfs_open_context *, unsigned int, int);

typedef void (*btf_trace_nfs_cb_badprinc)(void *, __be32, u32);

typedef void (*btf_trace_nfs_cb_no_clp)(void *, __be32, u32);

typedef void (*btf_trace_nfs_commit_done)(void *, const struct rpc_task *, const struct nfs_commit_data *);

typedef void (*btf_trace_nfs_commit_error)(void *, const struct inode *, const struct nfs_page *, int);

typedef void (*btf_trace_nfs_comp_error)(void *, const struct inode *, const struct nfs_page *, int);

typedef void (*btf_trace_nfs_create_enter)(void *, const struct inode *, const struct dentry *, unsigned int);

typedef void (*btf_trace_nfs_create_exit)(void *, const struct inode *, const struct dentry *, unsigned int, int);

typedef void (*btf_trace_nfs_direct_commit_complete)(void *, const struct nfs_direct_req *);

typedef void (*btf_trace_nfs_direct_resched_write)(void *, const struct nfs_direct_req *);

typedef void (*btf_trace_nfs_direct_write_complete)(void *, const struct nfs_direct_req *);

typedef void (*btf_trace_nfs_direct_write_completion)(void *, const struct nfs_direct_req *);

typedef void (*btf_trace_nfs_direct_write_reschedule_io)(void *, const struct nfs_direct_req *);

typedef void (*btf_trace_nfs_direct_write_schedule_iovec)(void *, const struct nfs_direct_req *);

typedef void (*btf_trace_nfs_fh_to_dentry)(void *, const struct super_block *, const struct nfs_fh *, u64, int);

typedef void (*btf_trace_nfs_fsync_enter)(void *, const struct inode *);

typedef void (*btf_trace_nfs_fsync_exit)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs_getattr_enter)(void *, const struct inode *);

typedef void (*btf_trace_nfs_getattr_exit)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs_initiate_commit)(void *, const struct nfs_commit_data *);

typedef void (*btf_trace_nfs_initiate_read)(void *, const struct nfs_pgio_header *);

typedef void (*btf_trace_nfs_initiate_write)(void *, const struct nfs_pgio_header *);

typedef void (*btf_trace_nfs_invalidate_folio)(void *, const struct inode *, loff_t, size_t);

typedef void (*btf_trace_nfs_invalidate_mapping_enter)(void *, const struct inode *);

typedef void (*btf_trace_nfs_invalidate_mapping_exit)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs_launder_folio_done)(void *, const struct inode *, loff_t, size_t, int);

typedef void (*btf_trace_nfs_link_enter)(void *, const struct inode *, const struct inode *, const struct dentry *);

typedef void (*btf_trace_nfs_link_exit)(void *, const struct inode *, const struct inode *, const struct dentry *, int);

typedef void (*btf_trace_nfs_local_open_fh)(void *, const struct nfs_fh *, fmode_t, int);

typedef void (*btf_trace_nfs_lookup_enter)(void *, const struct inode *, const struct dentry *, unsigned int);

typedef void (*btf_trace_nfs_lookup_exit)(void *, const struct inode *, const struct dentry *, unsigned int, int);

typedef void (*btf_trace_nfs_lookup_revalidate_enter)(void *, const struct inode *, const struct dentry *, unsigned int);

typedef void (*btf_trace_nfs_lookup_revalidate_exit)(void *, const struct inode *, const struct dentry *, unsigned int, int);

typedef void (*btf_trace_nfs_mkdir_enter)(void *, const struct inode *, const struct dentry *);

typedef void (*btf_trace_nfs_mkdir_exit)(void *, const struct inode *, const struct dentry *, int);

typedef void (*btf_trace_nfs_mknod_enter)(void *, const struct inode *, const struct dentry *);

typedef void (*btf_trace_nfs_mknod_exit)(void *, const struct inode *, const struct dentry *, int);

typedef void (*btf_trace_nfs_mount_assign)(void *, const char *, const char *);

typedef void (*btf_trace_nfs_mount_option)(void *, const struct fs_parameter *);

typedef void (*btf_trace_nfs_mount_path)(void *, const char *);

typedef void (*btf_trace_nfs_pgio_error)(void *, const struct nfs_pgio_header *, int, loff_t);

typedef void (*btf_trace_nfs_readdir_cache_fill)(void *, const struct file *, const __be32 *, u64, long unsigned int, unsigned int);

typedef void (*btf_trace_nfs_readdir_cache_fill_done)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs_readdir_force_readdirplus)(void *, const struct inode *);

typedef void (*btf_trace_nfs_readdir_invalidate_cache_range)(void *, const struct inode *, loff_t, loff_t);

typedef void (*btf_trace_nfs_readdir_lookup)(void *, const struct inode *, const struct dentry *, unsigned int);

typedef void (*btf_trace_nfs_readdir_lookup_revalidate)(void *, const struct inode *, const struct dentry *, unsigned int, int);

typedef void (*btf_trace_nfs_readdir_lookup_revalidate_failed)(void *, const struct inode *, const struct dentry *, unsigned int);

typedef void (*btf_trace_nfs_readdir_uncached)(void *, const struct file *, const __be32 *, u64, long unsigned int, unsigned int);

typedef void (*btf_trace_nfs_readdir_uncached_done)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs_readpage_done)(void *, const struct rpc_task *, const struct nfs_pgio_header *);

typedef void (*btf_trace_nfs_readpage_short)(void *, const struct rpc_task *, const struct nfs_pgio_header *);

typedef void (*btf_trace_nfs_refresh_inode_enter)(void *, const struct inode *);

typedef void (*btf_trace_nfs_refresh_inode_exit)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs_remove_enter)(void *, const struct inode *, const struct dentry *);

typedef void (*btf_trace_nfs_remove_exit)(void *, const struct inode *, const struct dentry *, int);

typedef void (*btf_trace_nfs_rename_enter)(void *, const struct inode *, const struct dentry *, const struct inode *, const struct dentry *);

typedef void (*btf_trace_nfs_rename_exit)(void *, const struct inode *, const struct dentry *, const struct inode *, const struct dentry *, int);

typedef void (*btf_trace_nfs_revalidate_inode_enter)(void *, const struct inode *);

typedef void (*btf_trace_nfs_revalidate_inode_exit)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs_rmdir_enter)(void *, const struct inode *, const struct dentry *);

typedef void (*btf_trace_nfs_rmdir_exit)(void *, const struct inode *, const struct dentry *, int);

typedef void (*btf_trace_nfs_set_cache_invalid)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs_set_inode_stale)(void *, const struct inode *);

typedef void (*btf_trace_nfs_setattr_enter)(void *, const struct inode *);

typedef void (*btf_trace_nfs_setattr_exit)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs_sillyrename_unlink)(void *, const struct nfs_unlinkdata *, int);

typedef void (*btf_trace_nfs_size_grow)(void *, const struct inode *, loff_t);

typedef void (*btf_trace_nfs_size_truncate)(void *, const struct inode *, loff_t);

typedef void (*btf_trace_nfs_size_update)(void *, const struct inode *, loff_t);

typedef void (*btf_trace_nfs_size_wcc)(void *, const struct inode *, loff_t);

typedef void (*btf_trace_nfs_symlink_enter)(void *, const struct inode *, const struct dentry *);

typedef void (*btf_trace_nfs_symlink_exit)(void *, const struct inode *, const struct dentry *, int);

typedef void (*btf_trace_nfs_unlink_enter)(void *, const struct inode *, const struct dentry *);

typedef void (*btf_trace_nfs_unlink_exit)(void *, const struct inode *, const struct dentry *, int);

typedef void (*btf_trace_nfs_write_error)(void *, const struct inode *, const struct nfs_page *, int);

typedef void (*btf_trace_nfs_writeback_done)(void *, const struct rpc_task *, const struct nfs_pgio_header *);

typedef void (*btf_trace_nfs_writeback_folio)(void *, const struct inode *, loff_t, size_t);

typedef void (*btf_trace_nfs_writeback_folio_done)(void *, const struct inode *, loff_t, size_t, int);

typedef void (*btf_trace_nfs_writeback_inode_enter)(void *, const struct inode *);

typedef void (*btf_trace_nfs_writeback_inode_exit)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs_xdr_bad_filehandle)(void *, const struct xdr_stream *, int);

typedef void (*btf_trace_nfs_xdr_status)(void *, const struct xdr_stream *, int);

typedef void (*btf_trace_nlmclnt_grant)(void *, const struct nlm_lock *, const struct sockaddr *, unsigned int, __be32);

typedef void (*btf_trace_nlmclnt_lock)(void *, const struct nlm_lock *, const struct sockaddr *, unsigned int, __be32);

typedef void (*btf_trace_nlmclnt_test)(void *, const struct nlm_lock *, const struct sockaddr *, unsigned int, __be32);

typedef void (*btf_trace_nlmclnt_unlock)(void *, const struct nlm_lock *, const struct sockaddr *, unsigned int, __be32);

typedef void (*btf_trace_nmi_handler)(void *, void *, s64, int);

typedef void (*btf_trace_notifier_register)(void *, void *);

typedef void (*btf_trace_notifier_run)(void *, void *);

typedef void (*btf_trace_notifier_unregister)(void *, void *);

typedef void (*btf_trace_oom_score_adj_update)(void *, struct task_struct *);

typedef void (*btf_trace_page_fault_kernel)(void *, long unsigned int, struct pt_regs *, long unsigned int);

typedef void (*btf_trace_page_fault_user)(void *, long unsigned int, struct pt_regs *, long unsigned int);

typedef void (*btf_trace_page_pool_release)(void *, const struct page_pool *, s32, u32, u32);

typedef void (*btf_trace_page_pool_state_hold)(void *, const struct page_pool *, netmem_ref, u32);

typedef void (*btf_trace_page_pool_state_release)(void *, const struct page_pool *, netmem_ref, u32);

typedef void (*btf_trace_page_pool_update_nid)(void *, const struct page_pool *, int);

typedef void (*btf_trace_pelt_cfs_tp)(void *, struct cfs_rq *);

typedef void (*btf_trace_pelt_dl_tp)(void *, struct rq *);

typedef void (*btf_trace_pelt_hw_tp)(void *, struct rq *);

typedef void (*btf_trace_pelt_irq_tp)(void *, struct rq *);

typedef void (*btf_trace_pelt_rt_tp)(void *, struct rq *);

typedef void (*btf_trace_pelt_se_tp)(void *, struct sched_entity *);

typedef void (*btf_trace_percpu_alloc_percpu)(void *, long unsigned int, bool, bool, size_t, size_t, void *, int, void *, size_t, gfp_t);

typedef void (*btf_trace_percpu_alloc_percpu_fail)(void *, bool, bool, size_t, size_t);

typedef void (*btf_trace_percpu_create_chunk)(void *, void *);

typedef void (*btf_trace_percpu_destroy_chunk)(void *, void *);

typedef void (*btf_trace_percpu_free_percpu)(void *, void *, int, void *);

typedef void (*btf_trace_pm_qos_add_request)(void *, s32);

typedef void (*btf_trace_pm_qos_remove_request)(void *, s32);

typedef void (*btf_trace_pm_qos_update_flags)(void *, enum pm_qos_req_action, int, int);

typedef void (*btf_trace_pm_qos_update_request)(void *, s32);

typedef void (*btf_trace_pm_qos_update_target)(void *, enum pm_qos_req_action, int, int);

typedef void (*btf_trace_pmap_register)(void *, u32, u32, int, short unsigned int);

typedef void (*btf_trace_posix_lock_inode)(void *, struct inode *, struct file_lock *, int);

typedef void (*btf_trace_power_domain_target)(void *, const char *, unsigned int, unsigned int);

typedef void (*btf_trace_powernv_throttle)(void *, int, const char *, int);

typedef void (*btf_trace_prq_report)(void *, struct intel_iommu *, struct device *, u64, u64, u64, u64, long unsigned int);

typedef void (*btf_trace_pstate_sample)(void *, u32, u32, u32, u32, u64, u64, u64, u32, u32);

typedef void (*btf_trace_purge_vmap_area_lazy)(void *, long unsigned int, long unsigned int, unsigned int);

typedef void (*btf_trace_qdisc_create)(void *, const struct Qdisc_ops *, struct net_device *, u32);

typedef void (*btf_trace_qdisc_dequeue)(void *, struct Qdisc *, const struct netdev_queue *, int, struct sk_buff *);

typedef void (*btf_trace_qdisc_destroy)(void *, struct Qdisc *);

typedef void (*btf_trace_qdisc_enqueue)(void *, struct Qdisc *, const struct netdev_queue *, struct sk_buff *);

typedef void (*btf_trace_qdisc_reset)(void *, struct Qdisc *);

typedef void (*btf_trace_qi_submit)(void *, struct intel_iommu *, u64, u64, u64, u64);

typedef void (*btf_trace_rcu_barrier)(void *, const char *, const char *, int, int, long unsigned int);

typedef void (*btf_trace_rcu_batch_end)(void *, const char *, int, char, char, char, char);

typedef void (*btf_trace_rcu_batch_start)(void *, const char *, long int, long int);

typedef void (*btf_trace_rcu_callback)(void *, const char *, struct callback_head *, long int);

typedef void (*btf_trace_rcu_exp_funnel_lock)(void *, const char *, u8, int, int, const char *);

typedef void (*btf_trace_rcu_exp_grace_period)(void *, const char *, long unsigned int, const char *);

typedef void (*btf_trace_rcu_fqs)(void *, const char *, long unsigned int, int, const char *);

typedef void (*btf_trace_rcu_future_grace_period)(void *, const char *, long unsigned int, long unsigned int, u8, int, int, const char *);

typedef void (*btf_trace_rcu_grace_period)(void *, const char *, long unsigned int, const char *);

typedef void (*btf_trace_rcu_grace_period_init)(void *, const char *, long unsigned int, u8, int, int, long unsigned int);

typedef void (*btf_trace_rcu_invoke_callback)(void *, const char *, struct callback_head *);

typedef void (*btf_trace_rcu_invoke_kfree_bulk_callback)(void *, const char *, long unsigned int, void **);

typedef void (*btf_trace_rcu_invoke_kvfree_callback)(void *, const char *, struct callback_head *, long unsigned int);

typedef void (*btf_trace_rcu_kvfree_callback)(void *, const char *, struct callback_head *, long unsigned int, long int);

typedef void (*btf_trace_rcu_preempt_task)(void *, const char *, int, long unsigned int);

typedef void (*btf_trace_rcu_quiescent_state_report)(void *, const char *, long unsigned int, long unsigned int, long unsigned int, u8, int, int, int);

typedef void (*btf_trace_rcu_segcb_stats)(void *, struct rcu_segcblist *, const char *);

typedef void (*btf_trace_rcu_sr_normal)(void *, const char *, struct callback_head *, const char *);

typedef void (*btf_trace_rcu_stall_warning)(void *, const char *, const char *);

typedef void (*btf_trace_rcu_torture_read)(void *, const char *, struct callback_head *, long unsigned int, long unsigned int, long unsigned int);

typedef void (*btf_trace_rcu_unlock_preempted_task)(void *, const char *, long unsigned int, int);

typedef void (*btf_trace_rcu_utilization)(void *, const char *);

typedef void (*btf_trace_rcu_watching)(void *, const char *, long int, long int, int);

typedef void (*btf_trace_rdev_abort_pmsr)(void *, struct wiphy *, struct wireless_dev *, u64);

typedef void (*btf_trace_rdev_abort_scan)(void *, struct wiphy *, struct wireless_dev *);

typedef void (*btf_trace_rdev_add_intf_link)(void *, struct wiphy *, struct wireless_dev *, unsigned int);

typedef void (*btf_trace_rdev_add_key)(void *, struct wiphy *, struct net_device *, int, u8, bool, const u8 *, u8);

typedef void (*btf_trace_rdev_add_link_station)(void *, struct wiphy *, struct net_device *, struct link_station_parameters *);

typedef void (*btf_trace_rdev_add_mpath)(void *, struct wiphy *, struct net_device *, u8 *, u8 *);

typedef void (*btf_trace_rdev_add_nan_func)(void *, struct wiphy *, struct wireless_dev *, const struct cfg80211_nan_func *);

typedef void (*btf_trace_rdev_add_station)(void *, struct wiphy *, struct net_device *, u8 *, struct station_parameters *);

typedef void (*btf_trace_rdev_add_tx_ts)(void *, struct wiphy *, struct net_device *, u8, const u8 *, u8, u16);

typedef void (*btf_trace_rdev_add_virtual_intf)(void *, struct wiphy *, char *, enum nl80211_iftype);

typedef void (*btf_trace_rdev_assoc)(void *, struct wiphy *, struct net_device *, struct cfg80211_assoc_request *);

typedef void (*btf_trace_rdev_assoc_ml_reconf)(void *, struct wiphy *, struct net_device *, struct cfg80211_assoc_link *, u16);

typedef void (*btf_trace_rdev_auth)(void *, struct wiphy *, struct net_device *, struct cfg80211_auth_request *);

typedef void (*btf_trace_rdev_cancel_remain_on_channel)(void *, struct wiphy *, struct wireless_dev *, u64);

typedef void (*btf_trace_rdev_change_beacon)(void *, struct wiphy *, struct net_device *, struct cfg80211_ap_update *);

typedef void (*btf_trace_rdev_change_bss)(void *, struct wiphy *, struct net_device *, struct bss_parameters *);

typedef void (*btf_trace_rdev_change_mpath)(void *, struct wiphy *, struct net_device *, u8 *, u8 *);

typedef void (*btf_trace_rdev_change_station)(void *, struct wiphy *, struct net_device *, u8 *, struct station_parameters *);

typedef void (*btf_trace_rdev_change_virtual_intf)(void *, struct wiphy *, struct net_device *, enum nl80211_iftype);

typedef void (*btf_trace_rdev_channel_switch)(void *, struct wiphy *, struct net_device *, struct cfg80211_csa_settings *);

typedef void (*btf_trace_rdev_color_change)(void *, struct wiphy *, struct net_device *, struct cfg80211_color_change_settings *);

typedef void (*btf_trace_rdev_connect)(void *, struct wiphy *, struct net_device *, struct cfg80211_connect_params *);

typedef void (*btf_trace_rdev_crit_proto_start)(void *, struct wiphy *, struct wireless_dev *, enum nl80211_crit_proto_id, u16);

typedef void (*btf_trace_rdev_crit_proto_stop)(void *, struct wiphy *, struct wireless_dev *);

typedef void (*btf_trace_rdev_deauth)(void *, struct wiphy *, struct net_device *, struct cfg80211_deauth_request *);

typedef void (*btf_trace_rdev_del_intf_link)(void *, struct wiphy *, struct wireless_dev *, unsigned int);

typedef void (*btf_trace_rdev_del_key)(void *, struct wiphy *, struct net_device *, int, u8, bool, const u8 *);

typedef void (*btf_trace_rdev_del_link_station)(void *, struct wiphy *, struct net_device *, struct link_station_del_parameters *);

typedef void (*btf_trace_rdev_del_mpath)(void *, struct wiphy *, struct net_device *, const u8 *);

typedef void (*btf_trace_rdev_del_nan_func)(void *, struct wiphy *, struct wireless_dev *, u64);

typedef void (*btf_trace_rdev_del_pmk)(void *, struct wiphy *, struct net_device *, const u8 *);

typedef void (*btf_trace_rdev_del_pmksa)(void *, struct wiphy *, struct net_device *, struct cfg80211_pmksa *);

typedef void (*btf_trace_rdev_del_station)(void *, struct wiphy *, struct net_device *, struct station_del_parameters *);

typedef void (*btf_trace_rdev_del_tx_ts)(void *, struct wiphy *, struct net_device *, u8, const u8 *);

typedef void (*btf_trace_rdev_del_virtual_intf)(void *, struct wiphy *, struct wireless_dev *);

typedef void (*btf_trace_rdev_disassoc)(void *, struct wiphy *, struct net_device *, struct cfg80211_disassoc_request *);

typedef void (*btf_trace_rdev_disconnect)(void *, struct wiphy *, struct net_device *, u16);

typedef void (*btf_trace_rdev_dump_mpath)(void *, struct wiphy *, struct net_device *, int, u8 *, u8 *);

typedef void (*btf_trace_rdev_dump_mpp)(void *, struct wiphy *, struct net_device *, int, u8 *, u8 *);

typedef void (*btf_trace_rdev_dump_station)(void *, struct wiphy *, struct net_device *, int, u8 *);

typedef void (*btf_trace_rdev_dump_survey)(void *, struct wiphy *, struct net_device *, int);

typedef void (*btf_trace_rdev_end_cac)(void *, struct wiphy *, struct net_device *, unsigned int);

typedef void (*btf_trace_rdev_external_auth)(void *, struct wiphy *, struct net_device *, struct cfg80211_external_auth_params *);

typedef void (*btf_trace_rdev_flush_pmksa)(void *, struct wiphy *, struct net_device *);

typedef void (*btf_trace_rdev_get_antenna)(void *, struct wiphy *);

typedef void (*btf_trace_rdev_get_channel)(void *, struct wiphy *, struct wireless_dev *, unsigned int);

typedef void (*btf_trace_rdev_get_ftm_responder_stats)(void *, struct wiphy *, struct net_device *, struct cfg80211_ftm_responder_stats *);

typedef void (*btf_trace_rdev_get_key)(void *, struct wiphy *, struct net_device *, int, u8, bool, const u8 *);

typedef void (*btf_trace_rdev_get_mesh_config)(void *, struct wiphy *, struct net_device *);

typedef void (*btf_trace_rdev_get_mpath)(void *, struct wiphy *, struct net_device *, u8 *, u8 *);

typedef void (*btf_trace_rdev_get_mpp)(void *, struct wiphy *, struct net_device *, u8 *, u8 *);

typedef void (*btf_trace_rdev_get_station)(void *, struct wiphy *, struct net_device *, const u8 *);

typedef void (*btf_trace_rdev_get_tx_power)(void *, struct wiphy *, struct wireless_dev *, unsigned int);

typedef void (*btf_trace_rdev_get_txq_stats)(void *, struct wiphy *, struct wireless_dev *);

typedef void (*btf_trace_rdev_inform_bss)(void *, struct wiphy *, struct cfg80211_bss *);

typedef void (*btf_trace_rdev_join_ibss)(void *, struct wiphy *, struct net_device *, struct cfg80211_ibss_params *);

typedef void (*btf_trace_rdev_join_mesh)(void *, struct wiphy *, struct net_device *, const struct mesh_config *, const struct mesh_setup *);

typedef void (*btf_trace_rdev_join_ocb)(void *, struct wiphy *, struct net_device *, const struct ocb_setup *);

typedef void (*btf_trace_rdev_leave_ibss)(void *, struct wiphy *, struct net_device *);

typedef void (*btf_trace_rdev_leave_mesh)(void *, struct wiphy *, struct net_device *);

typedef void (*btf_trace_rdev_leave_ocb)(void *, struct wiphy *, struct net_device *);

typedef void (*btf_trace_rdev_libertas_set_mesh_channel)(void *, struct wiphy *, struct net_device *, struct ieee80211_channel *);

typedef void (*btf_trace_rdev_mgmt_tx)(void *, struct wiphy *, struct wireless_dev *, struct cfg80211_mgmt_tx_params *);

typedef void (*btf_trace_rdev_mgmt_tx_cancel_wait)(void *, struct wiphy *, struct wireless_dev *, u64);

typedef void (*btf_trace_rdev_mod_link_station)(void *, struct wiphy *, struct net_device *, struct link_station_parameters *);

typedef void (*btf_trace_rdev_nan_change_conf)(void *, struct wiphy *, struct wireless_dev *, struct cfg80211_nan_conf *, u32);

typedef void (*btf_trace_rdev_probe_client)(void *, struct wiphy *, struct net_device *, const u8 *);

typedef void (*btf_trace_rdev_probe_mesh_link)(void *, struct wiphy *, struct net_device *, const u8 *, const u8 *, size_t);

typedef void (*btf_trace_rdev_remain_on_channel)(void *, struct wiphy *, struct wireless_dev *, struct ieee80211_channel *, unsigned int);

typedef void (*btf_trace_rdev_reset_tid_config)(void *, struct wiphy *, struct net_device *, const u8 *, u8);

typedef void (*btf_trace_rdev_resume)(void *, struct wiphy *);

typedef void (*btf_trace_rdev_return_chandef)(void *, struct wiphy *, int, struct cfg80211_chan_def *);

typedef void (*btf_trace_rdev_return_int)(void *, struct wiphy *, int);

typedef void (*btf_trace_rdev_return_int_cookie)(void *, struct wiphy *, int, u64);

typedef void (*btf_trace_rdev_return_int_int)(void *, struct wiphy *, int, int);

typedef void (*btf_trace_rdev_return_int_mesh_config)(void *, struct wiphy *, int, struct mesh_config *);

typedef void (*btf_trace_rdev_return_int_mpath_info)(void *, struct wiphy *, int, struct mpath_info *);

typedef void (*btf_trace_rdev_return_int_station_info)(void *, struct wiphy *, int, struct station_info *);

typedef void (*btf_trace_rdev_return_int_survey_info)(void *, struct wiphy *, int, struct survey_info *);

typedef void (*btf_trace_rdev_return_int_tx_rx)(void *, struct wiphy *, int, u32, u32);

typedef void (*btf_trace_rdev_return_void)(void *, struct wiphy *);

typedef void (*btf_trace_rdev_return_void_tx_rx)(void *, struct wiphy *, u32, u32, u32, u32);

typedef void (*btf_trace_rdev_return_wdev)(void *, struct wiphy *, struct wireless_dev *);

typedef void (*btf_trace_rdev_rfkill_poll)(void *, struct wiphy *);

typedef void (*btf_trace_rdev_scan)(void *, struct wiphy *, struct cfg80211_scan_request *);

typedef void (*btf_trace_rdev_sched_scan_start)(void *, struct wiphy *, struct net_device *, u64);

typedef void (*btf_trace_rdev_sched_scan_stop)(void *, struct wiphy *, struct net_device *, u64);

typedef void (*btf_trace_rdev_set_antenna)(void *, struct wiphy *, u32, u32);

typedef void (*btf_trace_rdev_set_ap_chanwidth)(void *, struct wiphy *, struct net_device *, unsigned int, struct cfg80211_chan_def *);

typedef void (*btf_trace_rdev_set_bitrate_mask)(void *, struct wiphy *, struct net_device *, unsigned int, const u8 *, const struct cfg80211_bitrate_mask *);

typedef void (*btf_trace_rdev_set_coalesce)(void *, struct wiphy *, struct cfg80211_coalesce *);

typedef void (*btf_trace_rdev_set_cqm_rssi_config)(void *, struct wiphy *, struct net_device *, s32, u32);

typedef void (*btf_trace_rdev_set_cqm_rssi_range_config)(void *, struct wiphy *, struct net_device *, s32, s32);

typedef void (*btf_trace_rdev_set_cqm_txe_config)(void *, struct wiphy *, struct net_device *, u32, u32, u32);

typedef void (*btf_trace_rdev_set_default_beacon_key)(void *, struct wiphy *, struct net_device *, int, u8);

typedef void (*btf_trace_rdev_set_default_key)(void *, struct wiphy *, struct net_device *, int, u8, bool, bool);

typedef void (*btf_trace_rdev_set_default_mgmt_key)(void *, struct wiphy *, struct net_device *, int, u8);

typedef void (*btf_trace_rdev_set_epcs)(void *, struct wiphy *, struct net_device *, bool);

typedef void (*btf_trace_rdev_set_fils_aad)(void *, struct wiphy *, struct net_device *, struct cfg80211_fils_aad *);

typedef void (*btf_trace_rdev_set_hw_timestamp)(void *, struct wiphy *, struct net_device *, struct cfg80211_set_hw_timestamp *);

typedef void (*btf_trace_rdev_set_mac_acl)(void *, struct wiphy *, struct net_device *, struct cfg80211_acl_data *);

typedef void (*btf_trace_rdev_set_mcast_rate)(void *, struct wiphy *, struct net_device *, int *);

typedef void (*btf_trace_rdev_set_monitor_channel)(void *, struct wiphy *, struct net_device *, struct cfg80211_chan_def *);

typedef void (*btf_trace_rdev_set_multicast_to_unicast)(void *, struct wiphy *, struct net_device *, const bool);

typedef void (*btf_trace_rdev_set_noack_map)(void *, struct wiphy *, struct net_device *, u16);

typedef void (*btf_trace_rdev_set_pmk)(void *, struct wiphy *, struct net_device *, struct cfg80211_pmk_conf *);

typedef void (*btf_trace_rdev_set_pmksa)(void *, struct wiphy *, struct net_device *, struct cfg80211_pmksa *);

typedef void (*btf_trace_rdev_set_power_mgmt)(void *, struct wiphy *, struct net_device *, bool, int);

typedef void (*btf_trace_rdev_set_qos_map)(void *, struct wiphy *, struct net_device *, struct cfg80211_qos_map *);

typedef void (*btf_trace_rdev_set_radar_background)(void *, struct wiphy *, struct cfg80211_chan_def *);

typedef void (*btf_trace_rdev_set_rekey_data)(void *, struct wiphy *, struct net_device *);

typedef void (*btf_trace_rdev_set_sar_specs)(void *, struct wiphy *, struct cfg80211_sar_specs *);

typedef void (*btf_trace_rdev_set_tid_config)(void *, struct wiphy *, struct net_device *, struct cfg80211_tid_config *);

typedef void (*btf_trace_rdev_set_ttlm)(void *, struct wiphy *, struct net_device *, struct cfg80211_ttlm_params *);

typedef void (*btf_trace_rdev_set_tx_power)(void *, struct wiphy *, struct wireless_dev *, enum nl80211_tx_power_setting, int);

typedef void (*btf_trace_rdev_set_txq_params)(void *, struct wiphy *, struct net_device *, struct ieee80211_txq_params *);

typedef void (*btf_trace_rdev_set_wakeup)(void *, struct wiphy *, bool);

typedef void (*btf_trace_rdev_set_wiphy_params)(void *, struct wiphy *, u32);

typedef void (*btf_trace_rdev_start_ap)(void *, struct wiphy *, struct net_device *, struct cfg80211_ap_settings *);

typedef void (*btf_trace_rdev_start_nan)(void *, struct wiphy *, struct wireless_dev *, struct cfg80211_nan_conf *);

typedef void (*btf_trace_rdev_start_p2p_device)(void *, struct wiphy *, struct wireless_dev *);

typedef void (*btf_trace_rdev_start_pmsr)(void *, struct wiphy *, struct wireless_dev *, u64);

typedef void (*btf_trace_rdev_start_radar_detection)(void *, struct wiphy *, struct net_device *, struct cfg80211_chan_def *, u32, int);

typedef void (*btf_trace_rdev_stop_ap)(void *, struct wiphy *, struct net_device *, unsigned int);

typedef void (*btf_trace_rdev_stop_nan)(void *, struct wiphy *, struct wireless_dev *);

typedef void (*btf_trace_rdev_stop_p2p_device)(void *, struct wiphy *, struct wireless_dev *);

typedef void (*btf_trace_rdev_suspend)(void *, struct wiphy *, struct cfg80211_wowlan *);

typedef void (*btf_trace_rdev_tdls_cancel_channel_switch)(void *, struct wiphy *, struct net_device *, const u8 *);

typedef void (*btf_trace_rdev_tdls_channel_switch)(void *, struct wiphy *, struct net_device *, const u8 *, u8, struct cfg80211_chan_def *);

typedef void (*btf_trace_rdev_tdls_mgmt)(void *, struct wiphy *, struct net_device *, u8 *, int, u8, u8, u16, u32, bool, const u8 *, size_t);

typedef void (*btf_trace_rdev_tdls_oper)(void *, struct wiphy *, struct net_device *, u8 *, enum nl80211_tdls_operation);

typedef void (*btf_trace_rdev_tx_control_port)(void *, struct wiphy *, struct net_device *, const u8 *, size_t, const u8 *, __be16, bool, int);

typedef void (*btf_trace_rdev_update_connect_params)(void *, struct wiphy *, struct net_device *, struct cfg80211_connect_params *, u32);

typedef void (*btf_trace_rdev_update_ft_ies)(void *, struct wiphy *, struct net_device *, struct cfg80211_update_ft_ies_params *);

typedef void (*btf_trace_rdev_update_mesh_config)(void *, struct wiphy *, struct net_device *, u32, const struct mesh_config *);

typedef void (*btf_trace_rdev_update_mgmt_frame_registrations)(void *, struct wiphy *, struct wireless_dev *, struct mgmt_frame_regs *);

typedef void (*btf_trace_rdev_update_owe_info)(void *, struct wiphy *, struct net_device *, struct cfg80211_update_owe_info *);

typedef void (*btf_trace_rdpmc)(void *, unsigned int, u64, int);

typedef void (*btf_trace_read_msr)(void *, unsigned int, u64, int);

typedef void (*btf_trace_reclaim_retry_zone)(void *, struct zoneref *, int, long unsigned int, long unsigned int, long unsigned int, int, bool);

typedef void (*btf_trace_regcache_drop_region)(void *, struct regmap *, unsigned int, unsigned int);

typedef void (*btf_trace_regcache_sync)(void *, struct regmap *, const char *, const char *);

typedef void (*btf_trace_regmap_async_complete_done)(void *, struct regmap *);

typedef void (*btf_trace_regmap_async_complete_start)(void *, struct regmap *);

typedef void (*btf_trace_regmap_async_io_complete)(void *, struct regmap *);

typedef void (*btf_trace_regmap_async_write_start)(void *, struct regmap *, unsigned int, int);

typedef void (*btf_trace_regmap_bulk_read)(void *, struct regmap *, unsigned int, const void *, int);

typedef void (*btf_trace_regmap_bulk_write)(void *, struct regmap *, unsigned int, const void *, int);

typedef void (*btf_trace_regmap_cache_bypass)(void *, struct regmap *, bool);

typedef void (*btf_trace_regmap_cache_only)(void *, struct regmap *, bool);

typedef void (*btf_trace_regmap_hw_read_done)(void *, struct regmap *, unsigned int, int);

typedef void (*btf_trace_regmap_hw_read_start)(void *, struct regmap *, unsigned int, int);

typedef void (*btf_trace_regmap_hw_write_done)(void *, struct regmap *, unsigned int, int);

typedef void (*btf_trace_regmap_hw_write_start)(void *, struct regmap *, unsigned int, int);

typedef void (*btf_trace_regmap_reg_read)(void *, struct regmap *, unsigned int, unsigned int);

typedef void (*btf_trace_regmap_reg_read_cache)(void *, struct regmap *, unsigned int, unsigned int);

typedef void (*btf_trace_regmap_reg_write)(void *, struct regmap *, unsigned int, unsigned int);

typedef void (*btf_trace_remove_device_from_group)(void *, int, struct device *);

typedef void (*btf_trace_remove_migration_pte)(void *, long unsigned int, long unsigned int, int);

typedef void (*btf_trace_reschedule_entry)(void *, int);

typedef void (*btf_trace_reschedule_exit)(void *, int);

typedef void (*btf_trace_rpc__auth_tooweak)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc__bad_creds)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc__garbage_args)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc__mismatch)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc__proc_unavail)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc__prog_mismatch)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc__prog_unavail)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc__stale_creds)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc__unparsable)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc_bad_callhdr)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc_bad_verifier)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc_buf_alloc)(void *, const struct rpc_task *, int);

typedef void (*btf_trace_rpc_call_rpcerror)(void *, const struct rpc_task *, int, int);

typedef void (*btf_trace_rpc_call_status)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc_clnt_clone_err)(void *, const struct rpc_clnt *, int);

typedef void (*btf_trace_rpc_clnt_free)(void *, const struct rpc_clnt *);

typedef void (*btf_trace_rpc_clnt_killall)(void *, const struct rpc_clnt *);

typedef void (*btf_trace_rpc_clnt_new)(void *, const struct rpc_clnt *, const struct rpc_xprt *, const struct rpc_create_args *);

typedef void (*btf_trace_rpc_clnt_new_err)(void *, const char *, const char *, int);

typedef void (*btf_trace_rpc_clnt_release)(void *, const struct rpc_clnt *);

typedef void (*btf_trace_rpc_clnt_replace_xprt)(void *, const struct rpc_clnt *);

typedef void (*btf_trace_rpc_clnt_replace_xprt_err)(void *, const struct rpc_clnt *);

typedef void (*btf_trace_rpc_clnt_shutdown)(void *, const struct rpc_clnt *);

typedef void (*btf_trace_rpc_connect_status)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc_refresh_status)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc_request)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc_retry_refresh_status)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc_socket_close)(void *, struct rpc_xprt *, struct socket *);

typedef void (*btf_trace_rpc_socket_connect)(void *, struct rpc_xprt *, struct socket *, int);

typedef void (*btf_trace_rpc_socket_error)(void *, struct rpc_xprt *, struct socket *, int);

typedef void (*btf_trace_rpc_socket_nospace)(void *, const struct rpc_rqst *, const struct sock_xprt *);

typedef void (*btf_trace_rpc_socket_reset_connection)(void *, struct rpc_xprt *, struct socket *, int);

typedef void (*btf_trace_rpc_socket_shutdown)(void *, struct rpc_xprt *, struct socket *);

typedef void (*btf_trace_rpc_socket_state_change)(void *, struct rpc_xprt *, struct socket *);

typedef void (*btf_trace_rpc_stats_latency)(void *, const struct rpc_task *, ktime_t, ktime_t, ktime_t);

typedef void (*btf_trace_rpc_task_begin)(void *, const struct rpc_task *, const void *);

typedef void (*btf_trace_rpc_task_call_done)(void *, const struct rpc_task *, const void *);

typedef void (*btf_trace_rpc_task_complete)(void *, const struct rpc_task *, const void *);

typedef void (*btf_trace_rpc_task_end)(void *, const struct rpc_task *, const void *);

typedef void (*btf_trace_rpc_task_run_action)(void *, const struct rpc_task *, const void *);

typedef void (*btf_trace_rpc_task_signalled)(void *, const struct rpc_task *, const void *);

typedef void (*btf_trace_rpc_task_sleep)(void *, const struct rpc_task *, const struct rpc_wait_queue *);

typedef void (*btf_trace_rpc_task_sync_sleep)(void *, const struct rpc_task *, const void *);

typedef void (*btf_trace_rpc_task_sync_wake)(void *, const struct rpc_task *, const void *);

typedef void (*btf_trace_rpc_task_timeout)(void *, const struct rpc_task *, const void *);

typedef void (*btf_trace_rpc_task_wakeup)(void *, const struct rpc_task *, const struct rpc_wait_queue *);

typedef void (*btf_trace_rpc_timeout_status)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc_tls_not_started)(void *, const struct rpc_clnt *, const struct rpc_xprt *);

typedef void (*btf_trace_rpc_tls_unavailable)(void *, const struct rpc_clnt *, const struct rpc_xprt *);

typedef void (*btf_trace_rpc_xdr_alignment)(void *, const struct xdr_stream *, size_t, unsigned int);

typedef void (*btf_trace_rpc_xdr_overflow)(void *, const struct xdr_stream *, size_t);

typedef void (*btf_trace_rpc_xdr_recvfrom)(void *, const struct rpc_task *, const struct xdr_buf *);

typedef void (*btf_trace_rpc_xdr_reply_pages)(void *, const struct rpc_task *, const struct xdr_buf *);

typedef void (*btf_trace_rpc_xdr_sendto)(void *, const struct rpc_task *, const struct xdr_buf *);

typedef void (*btf_trace_rpcb_bind_version_err)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpcb_getport)(void *, const struct rpc_clnt *, const struct rpc_task *, unsigned int);

typedef void (*btf_trace_rpcb_prog_unavail_err)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpcb_register)(void *, u32, u32, const char *, const char *);

typedef void (*btf_trace_rpcb_setport)(void *, const struct rpc_task *, int, short unsigned int);

typedef void (*btf_trace_rpcb_timeout_err)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpcb_unreachable_err)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpcb_unrecognized_err)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpcb_unregister)(void *, u32, u32, const char *);

typedef void (*btf_trace_rpcgss_bad_seqno)(void *, const struct rpc_task *, u32, u32);

typedef void (*btf_trace_rpcgss_context)(void *, u32, long unsigned int, long unsigned int, unsigned int, unsigned int, const u8 *);

typedef void (*btf_trace_rpcgss_createauth)(void *, unsigned int, int);

typedef void (*btf_trace_rpcgss_ctx_destroy)(void *, const struct gss_cred *);

typedef void (*btf_trace_rpcgss_ctx_init)(void *, const struct gss_cred *);

typedef void (*btf_trace_rpcgss_get_mic)(void *, const struct rpc_task *, u32);

typedef void (*btf_trace_rpcgss_import_ctx)(void *, int);

typedef void (*btf_trace_rpcgss_need_reencode)(void *, const struct rpc_task *, u32, bool);

typedef void (*btf_trace_rpcgss_oid_to_mech)(void *, const char *);

typedef void (*btf_trace_rpcgss_seqno)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpcgss_svc_accept_upcall)(void *, const struct svc_rqst *, u32, u32);

typedef void (*btf_trace_rpcgss_svc_authenticate)(void *, const struct svc_rqst *, const struct rpc_gss_wire_cred *);

typedef void (*btf_trace_rpcgss_svc_get_mic)(void *, const struct svc_rqst *, u32);

typedef void (*btf_trace_rpcgss_svc_mic)(void *, const struct svc_rqst *, u32);

typedef void (*btf_trace_rpcgss_svc_seqno_bad)(void *, const struct svc_rqst *, u32, u32);

typedef void (*btf_trace_rpcgss_svc_seqno_large)(void *, const struct svc_rqst *, u32);

typedef void (*btf_trace_rpcgss_svc_seqno_low)(void *, const struct svc_rqst *, u32, u32, u32);

typedef void (*btf_trace_rpcgss_svc_seqno_seen)(void *, const struct svc_rqst *, u32);

typedef void (*btf_trace_rpcgss_svc_unwrap)(void *, const struct svc_rqst *, u32);

typedef void (*btf_trace_rpcgss_svc_unwrap_failed)(void *, const struct svc_rqst *);

typedef void (*btf_trace_rpcgss_svc_wrap)(void *, const struct svc_rqst *, u32);

typedef void (*btf_trace_rpcgss_svc_wrap_failed)(void *, const struct svc_rqst *);

typedef void (*btf_trace_rpcgss_unwrap)(void *, const struct rpc_task *, u32);

typedef void (*btf_trace_rpcgss_unwrap_failed)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpcgss_upcall_msg)(void *, const char *);

typedef void (*btf_trace_rpcgss_upcall_result)(void *, u32, int);

typedef void (*btf_trace_rpcgss_update_slack)(void *, const struct rpc_task *, const struct rpc_auth *);

typedef void (*btf_trace_rpcgss_verify_mic)(void *, const struct rpc_task *, u32);

typedef void (*btf_trace_rpcgss_wrap)(void *, const struct rpc_task *, u32);

typedef void (*btf_trace_rpm_idle)(void *, struct device *, int);

typedef void (*btf_trace_rpm_resume)(void *, struct device *, int);

typedef void (*btf_trace_rpm_return_int)(void *, struct device *, long unsigned int, int);

typedef void (*btf_trace_rpm_status)(void *, struct device *, enum rpm_status);

typedef void (*btf_trace_rpm_suspend)(void *, struct device *, int);

typedef void (*btf_trace_rpm_usage)(void *, struct device *, int);

typedef void (*btf_trace_rseq_ip_fixup)(void *, long unsigned int, long unsigned int, long unsigned int, long unsigned int);

typedef void (*btf_trace_rseq_update)(void *, struct task_struct *);

typedef void (*btf_trace_rss_stat)(void *, struct mm_struct *, int);

typedef void (*btf_trace_rtc_alarm_irq_enable)(void *, unsigned int, int);

typedef void (*btf_trace_rtc_irq_set_freq)(void *, int, int);

typedef void (*btf_trace_rtc_irq_set_state)(void *, int, int);

typedef void (*btf_trace_rtc_read_alarm)(void *, time64_t, int);

typedef void (*btf_trace_rtc_read_offset)(void *, long int, int);

typedef void (*btf_trace_rtc_read_time)(void *, time64_t, int);

typedef void (*btf_trace_rtc_set_alarm)(void *, time64_t, int);

typedef void (*btf_trace_rtc_set_offset)(void *, long int, int);

typedef void (*btf_trace_rtc_set_time)(void *, time64_t, int);

typedef void (*btf_trace_rtc_timer_dequeue)(void *, struct rtc_timer *);

typedef void (*btf_trace_rtc_timer_enqueue)(void *, struct rtc_timer *);

typedef void (*btf_trace_rtc_timer_fired)(void *, struct rtc_timer *);

typedef void (*btf_trace_sb_clear_inode_writeback)(void *, struct inode *);

typedef void (*btf_trace_sb_mark_inode_writeback)(void *, struct inode *);

typedef void (*btf_trace_sched_compute_energy_tp)(void *, struct task_struct *, int, long unsigned int, long unsigned int, long unsigned int);

typedef void (*btf_trace_sched_cpu_capacity_tp)(void *, struct rq *);

typedef void (*btf_trace_sched_kthread_stop)(void *, struct task_struct *);

typedef void (*btf_trace_sched_kthread_stop_ret)(void *, int);

typedef void (*btf_trace_sched_kthread_work_execute_end)(void *, struct kthread_work *, kthread_work_func_t);

typedef void (*btf_trace_sched_kthread_work_execute_start)(void *, struct kthread_work *);

typedef void (*btf_trace_sched_kthread_work_queue_work)(void *, struct kthread_worker *, struct kthread_work *);

typedef void (*btf_trace_sched_migrate_task)(void *, struct task_struct *, int);

typedef void (*btf_trace_sched_move_numa)(void *, struct task_struct *, int, int);

typedef void (*btf_trace_sched_overutilized_tp)(void *, struct root_domain *, bool);

typedef void (*btf_trace_sched_pi_setprio)(void *, struct task_struct *, struct task_struct *);

typedef void (*btf_trace_sched_prepare_exec)(void *, struct task_struct *, struct linux_binprm *);

typedef void (*btf_trace_sched_process_exec)(void *, struct task_struct *, pid_t, struct linux_binprm *);

typedef void (*btf_trace_sched_process_exit)(void *, struct task_struct *);

typedef void (*btf_trace_sched_process_fork)(void *, struct task_struct *, struct task_struct *);

typedef void (*btf_trace_sched_process_free)(void *, struct task_struct *);

typedef void (*btf_trace_sched_process_wait)(void *, struct pid *);

typedef void (*btf_trace_sched_stat_blocked)(void *, struct task_struct *, u64);

typedef void (*btf_trace_sched_stat_iowait)(void *, struct task_struct *, u64);

typedef void (*btf_trace_sched_stat_runtime)(void *, struct task_struct *, u64);

typedef void (*btf_trace_sched_stat_sleep)(void *, struct task_struct *, u64);

typedef void (*btf_trace_sched_stat_wait)(void *, struct task_struct *, u64);

typedef void (*btf_trace_sched_stick_numa)(void *, struct task_struct *, int, struct task_struct *, int);

typedef void (*btf_trace_sched_swap_numa)(void *, struct task_struct *, int, struct task_struct *, int);

typedef void (*btf_trace_sched_switch)(void *, bool, struct task_struct *, struct task_struct *, unsigned int);

typedef void (*btf_trace_sched_update_nr_running_tp)(void *, struct rq *, int);

typedef void (*btf_trace_sched_util_est_cfs_tp)(void *, struct cfs_rq *);

typedef void (*btf_trace_sched_util_est_se_tp)(void *, struct sched_entity *);

typedef void (*btf_trace_sched_wait_task)(void *, struct task_struct *);

typedef void (*btf_trace_sched_wake_idle_without_ipi)(void *, int);

typedef void (*btf_trace_sched_wakeup)(void *, struct task_struct *);

typedef void (*btf_trace_sched_wakeup_new)(void *, struct task_struct *);

typedef void (*btf_trace_sched_waking)(void *, struct task_struct *);

typedef void (*btf_trace_scsi_dispatch_cmd_done)(void *, struct scsi_cmnd *);

typedef void (*btf_trace_scsi_dispatch_cmd_error)(void *, struct scsi_cmnd *, int);

typedef void (*btf_trace_scsi_dispatch_cmd_start)(void *, struct scsi_cmnd *);

typedef void (*btf_trace_scsi_dispatch_cmd_timeout)(void *, struct scsi_cmnd *);

typedef void (*btf_trace_scsi_eh_wakeup)(void *, struct Scsi_Host *);

typedef void (*btf_trace_selinux_audited)(void *, struct selinux_audit_data *, char *, char *, const char *);

typedef void (*btf_trace_set_migration_pte)(void *, long unsigned int, long unsigned int, int);

typedef void (*btf_trace_signal_deliver)(void *, int, struct kernel_siginfo *, struct k_sigaction *);

typedef void (*btf_trace_signal_generate)(void *, int, struct kernel_siginfo *, struct task_struct *, int, int);

typedef void (*btf_trace_sk_data_ready)(void *, const struct sock *);

typedef void (*btf_trace_skb_copy_datagram_iovec)(void *, const struct sk_buff *, int);

typedef void (*btf_trace_skip_task_reaping)(void *, int);

typedef void (*btf_trace_smbus_read)(void *, const struct i2c_adapter *, u16, short unsigned int, char, u8, int);

typedef void (*btf_trace_smbus_reply)(void *, const struct i2c_adapter *, u16, short unsigned int, char, u8, int, const union i2c_smbus_data *, int);

typedef void (*btf_trace_smbus_result)(void *, const struct i2c_adapter *, u16, short unsigned int, char, u8, int, int);

typedef void (*btf_trace_smbus_write)(void *, const struct i2c_adapter *, u16, short unsigned int, char, u8, int, const union i2c_smbus_data *);

typedef void (*btf_trace_snd_hdac_stream_start)(void *, struct hdac_bus *, struct hdac_stream *);

typedef void (*btf_trace_snd_hdac_stream_stop)(void *, struct hdac_bus *, struct hdac_stream *);

typedef void (*btf_trace_sock_exceed_buf_limit)(void *, struct sock *, struct proto *, long int, int);

typedef void (*btf_trace_sock_rcvqueue_full)(void *, struct sock *, struct sk_buff *);

typedef void (*btf_trace_sock_recv_length)(void *, struct sock *, int, int);

typedef void (*btf_trace_sock_send_length)(void *, struct sock *, int, int);

typedef void (*btf_trace_softirq_entry)(void *, unsigned int);

typedef void (*btf_trace_softirq_exit)(void *, unsigned int);

typedef void (*btf_trace_softirq_raise)(void *, unsigned int);

typedef void (*btf_trace_spurious_apic_entry)(void *, int);

typedef void (*btf_trace_spurious_apic_exit)(void *, int);

typedef void (*btf_trace_start_task_reaping)(void *, int);

typedef void (*btf_trace_stop_queue)(void *, struct ieee80211_local *, u16, enum queue_stop_reason, int);

typedef void (*btf_trace_suspend_resume)(void *, const char *, int, bool);

typedef void (*btf_trace_svc_alloc_arg_err)(void *, unsigned int, unsigned int);

typedef void (*btf_trace_svc_authenticate)(void *, const struct svc_rqst *, enum svc_auth_status);

typedef void (*btf_trace_svc_defer)(void *, const struct svc_rqst *);

typedef void (*btf_trace_svc_defer_drop)(void *, const struct svc_deferred_req *);

typedef void (*btf_trace_svc_defer_queue)(void *, const struct svc_deferred_req *);

typedef void (*btf_trace_svc_defer_recv)(void *, const struct svc_deferred_req *);

typedef void (*btf_trace_svc_drop)(void *, const struct svc_rqst *);

typedef void (*btf_trace_svc_noregister)(void *, const char *, const u32, const int, const short unsigned int, const short unsigned int, int);

typedef void (*btf_trace_svc_process)(void *, const struct svc_rqst *, const char *);

typedef void (*btf_trace_svc_register)(void *, const char *, const u32, const int, const short unsigned int, const short unsigned int, int);

typedef void (*btf_trace_svc_replace_page_err)(void *, const struct svc_rqst *);

typedef void (*btf_trace_svc_send)(void *, const struct svc_rqst *, int);

typedef void (*btf_trace_svc_stats_latency)(void *, const struct svc_rqst *);

typedef void (*btf_trace_svc_tls_not_started)(void *, const struct svc_xprt *);

typedef void (*btf_trace_svc_tls_start)(void *, const struct svc_xprt *);

typedef void (*btf_trace_svc_tls_timed_out)(void *, const struct svc_xprt *);

typedef void (*btf_trace_svc_tls_unavailable)(void *, const struct svc_xprt *);

typedef void (*btf_trace_svc_tls_upcall)(void *, const struct svc_xprt *);

typedef void (*btf_trace_svc_unregister)(void *, const char *, const u32, int);

typedef void (*btf_trace_svc_wake_up)(void *, int);

typedef void (*btf_trace_svc_xdr_recvfrom)(void *, const struct xdr_buf *);

typedef void (*btf_trace_svc_xdr_sendto)(void *, __be32, const struct xdr_buf *);

typedef void (*btf_trace_svc_xprt_accept)(void *, const struct svc_xprt *, const char *);

typedef void (*btf_trace_svc_xprt_close)(void *, const struct svc_xprt *);

typedef void (*btf_trace_svc_xprt_create_err)(void *, const char *, const char *, struct sockaddr *, size_t, const struct svc_xprt *);

typedef void (*btf_trace_svc_xprt_dequeue)(void *, const struct svc_rqst *);

typedef void (*btf_trace_svc_xprt_detach)(void *, const struct svc_xprt *);

typedef void (*btf_trace_svc_xprt_enqueue)(void *, const struct svc_xprt *, long unsigned int);

typedef void (*btf_trace_svc_xprt_free)(void *, const struct svc_xprt *);

typedef void (*btf_trace_svc_xprt_no_write_space)(void *, const struct svc_xprt *);

typedef void (*btf_trace_svcsock_accept_err)(void *, const struct svc_xprt *, const char *, long int);

typedef void (*btf_trace_svcsock_data_ready)(void *, const struct svc_xprt *, ssize_t);

typedef void (*btf_trace_svcsock_free)(void *, const void *, const struct socket *);

typedef void (*btf_trace_svcsock_getpeername_err)(void *, const struct svc_xprt *, const char *, long int);

typedef void (*btf_trace_svcsock_marker)(void *, const struct svc_xprt *, __be32);

typedef void (*btf_trace_svcsock_new)(void *, const void *, const struct socket *);

typedef void (*btf_trace_svcsock_tcp_recv)(void *, const struct svc_xprt *, ssize_t);

typedef void (*btf_trace_svcsock_tcp_recv_eagain)(void *, const struct svc_xprt *, ssize_t);

typedef void (*btf_trace_svcsock_tcp_recv_err)(void *, const struct svc_xprt *, ssize_t);

typedef void (*btf_trace_svcsock_tcp_recv_short)(void *, const struct svc_xprt *, u32, u32);

typedef void (*btf_trace_svcsock_tcp_send)(void *, const struct svc_xprt *, ssize_t);

typedef void (*btf_trace_svcsock_tcp_state)(void *, const struct svc_xprt *, const struct socket *);

typedef void (*btf_trace_svcsock_udp_recv)(void *, const struct svc_xprt *, ssize_t);

typedef void (*btf_trace_svcsock_udp_recv_err)(void *, const struct svc_xprt *, ssize_t);

typedef void (*btf_trace_svcsock_udp_send)(void *, const struct svc_xprt *, ssize_t);

typedef void (*btf_trace_svcsock_write_space)(void *, const struct svc_xprt *, ssize_t);

typedef void (*btf_trace_swiotlb_bounced)(void *, struct device *, dma_addr_t, size_t);

typedef void (*btf_trace_sys_enter)(void *, struct pt_regs *, long int);

typedef void (*btf_trace_sys_exit)(void *, struct pt_regs *, long int);

typedef void (*btf_trace_task_newtask)(void *, struct task_struct *, long unsigned int);

typedef void (*btf_trace_task_prctl_unknown)(void *, int, long unsigned int, long unsigned int, long unsigned int, long unsigned int);

typedef void (*btf_trace_task_rename)(void *, struct task_struct *, const char *);

typedef void (*btf_trace_tasklet_entry)(void *, struct tasklet_struct *, void *);

typedef void (*btf_trace_tasklet_exit)(void *, struct tasklet_struct *, void *);

typedef void (*btf_trace_tcp_ao_handshake_failure)(void *, const struct sock *, const struct sk_buff *, const __u8, const __u8, const __u8);

typedef void (*btf_trace_tcp_ao_key_not_found)(void *, const struct sock *, const struct sk_buff *, const __u8, const __u8, const __u8);

typedef void (*btf_trace_tcp_ao_mismatch)(void *, const struct sock *, const struct sk_buff *, const __u8, const __u8, const __u8);

typedef void (*btf_trace_tcp_ao_rcv_sne_update)(void *, const struct sock *, __u32);

typedef void (*btf_trace_tcp_ao_rnext_request)(void *, const struct sock *, const struct sk_buff *, const __u8, const __u8, const __u8);

typedef void (*btf_trace_tcp_ao_snd_sne_update)(void *, const struct sock *, __u32);

typedef void (*btf_trace_tcp_ao_synack_no_key)(void *, const struct sock *, const __u8, const __u8);

typedef void (*btf_trace_tcp_ao_wrong_maclen)(void *, const struct sock *, const struct sk_buff *, const __u8, const __u8, const __u8);

typedef void (*btf_trace_tcp_bad_csum)(void *, const struct sk_buff *);

typedef void (*btf_trace_tcp_cong_state_set)(void *, struct sock *, const u8);

typedef void (*btf_trace_tcp_destroy_sock)(void *, struct sock *);

typedef void (*btf_trace_tcp_hash_ao_required)(void *, const struct sock *, const struct sk_buff *);

typedef void (*btf_trace_tcp_hash_bad_header)(void *, const struct sock *, const struct sk_buff *);

typedef void (*btf_trace_tcp_hash_md5_mismatch)(void *, const struct sock *, const struct sk_buff *);

typedef void (*btf_trace_tcp_hash_md5_required)(void *, const struct sock *, const struct sk_buff *);

typedef void (*btf_trace_tcp_hash_md5_unexpected)(void *, const struct sock *, const struct sk_buff *);

typedef void (*btf_trace_tcp_probe)(void *, struct sock *, struct sk_buff *);

typedef void (*btf_trace_tcp_rcv_space_adjust)(void *, struct sock *);

typedef void (*btf_trace_tcp_receive_reset)(void *, struct sock *);

typedef void (*btf_trace_tcp_retransmit_skb)(void *, const struct sock *, const struct sk_buff *);

typedef void (*btf_trace_tcp_retransmit_synack)(void *, const struct sock *, const struct request_sock *);

typedef void (*btf_trace_tcp_send_reset)(void *, const struct sock *, const struct sk_buff *, const enum sk_rst_reason);

typedef void (*btf_trace_thermal_apic_entry)(void *, int);

typedef void (*btf_trace_thermal_apic_exit)(void *, int);

typedef void (*btf_trace_thermal_temperature)(void *, struct thermal_zone_device *);

typedef void (*btf_trace_thermal_zone_trip)(void *, struct thermal_zone_device *, int, enum thermal_trip_type);

typedef void (*btf_trace_threshold_apic_entry)(void *, int);

typedef void (*btf_trace_threshold_apic_exit)(void *, int);

typedef void (*btf_trace_tick_stop)(void *, int, int);

typedef void (*btf_trace_time_out_leases)(void *, struct inode *, struct file_lease *);

typedef void (*btf_trace_timer_base_idle)(void *, bool, unsigned int);

typedef void (*btf_trace_timer_cancel)(void *, struct timer_list *);

typedef void (*btf_trace_timer_expire_entry)(void *, struct timer_list *, long unsigned int);

typedef void (*btf_trace_timer_expire_exit)(void *, struct timer_list *);

typedef void (*btf_trace_timer_init)(void *, struct timer_list *);

typedef void (*btf_trace_timer_start)(void *, struct timer_list *, long unsigned int);

typedef void (*btf_trace_tlb_flush)(void *, int, long unsigned int);

typedef void (*btf_trace_tls_alert_recv)(void *, const struct sock *, unsigned char, unsigned char);

typedef void (*btf_trace_tls_alert_send)(void *, const struct sock *, unsigned char, unsigned char);

typedef void (*btf_trace_tls_contenttype)(void *, const struct sock *, unsigned char);

typedef void (*btf_trace_tmigr_connect_child_parent)(void *, struct tmigr_group *);

typedef void (*btf_trace_tmigr_connect_cpu_parent)(void *, struct tmigr_cpu *);

typedef void (*btf_trace_tmigr_cpu_active)(void *, struct tmigr_cpu *);

typedef void (*btf_trace_tmigr_cpu_idle)(void *, struct tmigr_cpu *, u64);

typedef void (*btf_trace_tmigr_cpu_new_timer)(void *, struct tmigr_cpu *);

typedef void (*btf_trace_tmigr_cpu_new_timer_idle)(void *, struct tmigr_cpu *, u64);

typedef void (*btf_trace_tmigr_cpu_offline)(void *, struct tmigr_cpu *);

typedef void (*btf_trace_tmigr_cpu_online)(void *, struct tmigr_cpu *);

typedef void (*btf_trace_tmigr_group_set)(void *, struct tmigr_group *);

typedef void (*btf_trace_tmigr_group_set_cpu_active)(void *, struct tmigr_group *, union tmigr_state, u32);

typedef void (*btf_trace_tmigr_group_set_cpu_inactive)(void *, struct tmigr_group *, union tmigr_state, u32);

typedef void (*btf_trace_tmigr_handle_remote)(void *, struct tmigr_group *);

typedef void (*btf_trace_tmigr_handle_remote_cpu)(void *, struct tmigr_cpu *);

typedef void (*btf_trace_tmigr_update_events)(void *, struct tmigr_group *, struct tmigr_group *, union tmigr_state, union tmigr_state, u64);

typedef void (*btf_trace_udp_fail_queue_rcv_skb)(void *, int, struct sock *, struct sk_buff *);

typedef void (*btf_trace_unmap)(void *, long unsigned int, size_t, size_t);

typedef void (*btf_trace_vector_activate)(void *, unsigned int, bool, bool, bool);

typedef void (*btf_trace_vector_alloc)(void *, unsigned int, unsigned int, bool, int);

typedef void (*btf_trace_vector_alloc_managed)(void *, unsigned int, unsigned int, int);

typedef void (*btf_trace_vector_clear)(void *, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int);

typedef void (*btf_trace_vector_config)(void *, unsigned int, unsigned int, unsigned int, unsigned int);

typedef void (*btf_trace_vector_deactivate)(void *, unsigned int, bool, bool, bool);

typedef void (*btf_trace_vector_free_moved)(void *, unsigned int, unsigned int, unsigned int, bool);

typedef void (*btf_trace_vector_reserve)(void *, unsigned int, int);

typedef void (*btf_trace_vector_reserve_managed)(void *, unsigned int, int);

typedef void (*btf_trace_vector_setup)(void *, unsigned int, bool, int);

typedef void (*btf_trace_vector_teardown)(void *, unsigned int, bool, bool);

typedef void (*btf_trace_vector_update)(void *, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int);

typedef void (*btf_trace_virtio_gpu_cmd_queue)(void *, struct virtqueue *, struct virtio_gpu_ctrl_hdr *, u32);

typedef void (*btf_trace_virtio_gpu_cmd_response)(void *, struct virtqueue *, struct virtio_gpu_ctrl_hdr *, u32);

typedef void (*btf_trace_vlv_fifo_size)(void *, struct intel_crtc *, u32, u32, u32);

typedef void (*btf_trace_vlv_wm)(void *, struct intel_crtc *, const struct vlv_wm_values *);

typedef void (*btf_trace_vm_unmapped_area)(void *, long unsigned int, struct vm_unmapped_area_info *);

typedef void (*btf_trace_vma_mas_szero)(void *, struct maple_tree *, long unsigned int, long unsigned int);

typedef void (*btf_trace_vma_store)(void *, struct maple_tree *, struct vm_area_struct *);

typedef void (*btf_trace_wake_queue)(void *, struct ieee80211_local *, u16, enum queue_stop_reason, int);

typedef void (*btf_trace_wake_reaper)(void *, int);

typedef void (*btf_trace_wakeup_source_activate)(void *, const char *, unsigned int);

typedef void (*btf_trace_wakeup_source_deactivate)(void *, const char *, unsigned int);

typedef void (*btf_trace_wbc_writepage)(void *, struct writeback_control *, struct backing_dev_info *);

typedef void (*btf_trace_wiphy_delayed_work_queue)(void *, struct wiphy *, struct wiphy_work *, long unsigned int);

typedef void (*btf_trace_wiphy_work_cancel)(void *, struct wiphy *, struct wiphy_work *);

typedef void (*btf_trace_wiphy_work_flush)(void *, struct wiphy *, struct wiphy_work *);

typedef void (*btf_trace_wiphy_work_queue)(void *, struct wiphy *, struct wiphy_work *);

typedef void (*btf_trace_wiphy_work_run)(void *, struct wiphy *, struct wiphy_work *);

typedef void (*btf_trace_wiphy_work_worker_start)(void *, struct wiphy *);

typedef void (*btf_trace_workqueue_activate_work)(void *, struct work_struct *);

typedef void (*btf_trace_workqueue_execute_end)(void *, struct work_struct *, work_func_t);

typedef void (*btf_trace_workqueue_execute_start)(void *, struct work_struct *);

typedef void (*btf_trace_workqueue_queue_work)(void *, int, struct pool_workqueue *, struct work_struct *);

typedef void (*btf_trace_write_msr)(void *, unsigned int, u64, int);

typedef void (*btf_trace_writeback_bdi_register)(void *, struct backing_dev_info *);

typedef void (*btf_trace_writeback_dirty_folio)(void *, struct folio *, struct address_space *);

typedef void (*btf_trace_writeback_dirty_inode)(void *, struct inode *, int);

typedef void (*btf_trace_writeback_dirty_inode_enqueue)(void *, struct inode *);

typedef void (*btf_trace_writeback_dirty_inode_start)(void *, struct inode *, int);

typedef void (*btf_trace_writeback_exec)(void *, struct bdi_writeback *, struct wb_writeback_work *);

typedef void (*btf_trace_writeback_lazytime)(void *, struct inode *);

typedef void (*btf_trace_writeback_lazytime_iput)(void *, struct inode *);

typedef void (*btf_trace_writeback_mark_inode_dirty)(void *, struct inode *, int);

typedef void (*btf_trace_writeback_pages_written)(void *, long int);

typedef void (*btf_trace_writeback_queue)(void *, struct bdi_writeback *, struct wb_writeback_work *);

typedef void (*btf_trace_writeback_queue_io)(void *, struct bdi_writeback *, struct wb_writeback_work *, long unsigned int, int);

typedef void (*btf_trace_writeback_sb_inodes_requeue)(void *, struct inode *);

typedef void (*btf_trace_writeback_single_inode)(void *, struct inode *, struct writeback_control *, long unsigned int);

typedef void (*btf_trace_writeback_single_inode_start)(void *, struct inode *, struct writeback_control *, long unsigned int);

typedef void (*btf_trace_writeback_start)(void *, struct bdi_writeback *, struct wb_writeback_work *);

typedef void (*btf_trace_writeback_wait)(void *, struct bdi_writeback *, struct wb_writeback_work *);

typedef void (*btf_trace_writeback_wake_background)(void *, struct bdi_writeback *);

typedef void (*btf_trace_writeback_write_inode)(void *, struct inode *, struct writeback_control *);

typedef void (*btf_trace_writeback_write_inode_start)(void *, struct inode *, struct writeback_control *);

typedef void (*btf_trace_writeback_written)(void *, struct bdi_writeback *, struct wb_writeback_work *);

typedef void (*btf_trace_x86_fpu_after_restore)(void *, struct fpu *);

typedef void (*btf_trace_x86_fpu_after_save)(void *, struct fpu *);

typedef void (*btf_trace_x86_fpu_before_restore)(void *, struct fpu *);

typedef void (*btf_trace_x86_fpu_before_save)(void *, struct fpu *);

typedef void (*btf_trace_x86_fpu_copy_dst)(void *, struct fpu *);

typedef void (*btf_trace_x86_fpu_copy_src)(void *, struct fpu *);

typedef void (*btf_trace_x86_fpu_dropped)(void *, struct fpu *);

typedef void (*btf_trace_x86_fpu_init_state)(void *, struct fpu *);

typedef void (*btf_trace_x86_fpu_regs_activated)(void *, struct fpu *);

typedef void (*btf_trace_x86_fpu_regs_deactivated)(void *, struct fpu *);

typedef void (*btf_trace_x86_fpu_xstate_check_failed)(void *, struct fpu *);

typedef void (*btf_trace_x86_platform_ipi_entry)(void *, int);

typedef void (*btf_trace_x86_platform_ipi_exit)(void *, int);

typedef void (*btf_trace_xdp_bulk_tx)(void *, const struct net_device *, int, int, int);

typedef void (*btf_trace_xdp_cpumap_enqueue)(void *, int, unsigned int, unsigned int, int);

typedef void (*btf_trace_xdp_cpumap_kthread)(void *, int, unsigned int, unsigned int, int, struct xdp_cpumap_stats *);

typedef void (*btf_trace_xdp_devmap_xmit)(void *, const struct net_device *, const struct net_device *, int, int, int);

typedef void (*btf_trace_xdp_exception)(void *, const struct net_device *, const struct bpf_prog *, u32);

typedef void (*btf_trace_xdp_redirect)(void *, const struct net_device *, const struct bpf_prog *, const void *, int, enum bpf_map_type, u32, u32);

typedef void (*btf_trace_xdp_redirect_err)(void *, const struct net_device *, const struct bpf_prog *, const void *, int, enum bpf_map_type, u32, u32);

typedef void (*btf_trace_xdp_redirect_map)(void *, const struct net_device *, const struct bpf_prog *, const void *, int, enum bpf_map_type, u32, u32);

typedef void (*btf_trace_xdp_redirect_map_err)(void *, const struct net_device *, const struct bpf_prog *, const void *, int, enum bpf_map_type, u32, u32);

typedef void (*btf_trace_xhci_add_endpoint)(void *, struct xhci_ep_ctx *);

typedef void (*btf_trace_xhci_address_ctrl_ctx)(void *, struct xhci_input_control_ctx *);

typedef void (*btf_trace_xhci_address_ctx)(void *, struct xhci_hcd *, struct xhci_container_ctx *, unsigned int);

typedef void (*btf_trace_xhci_alloc_dev)(void *, struct xhci_slot_ctx *);

typedef void (*btf_trace_xhci_alloc_stream_info_ctx)(void *, struct xhci_stream_info *, unsigned int);

typedef void (*btf_trace_xhci_alloc_virt_device)(void *, struct xhci_virt_device *);

typedef void (*btf_trace_xhci_configure_endpoint)(void *, struct xhci_slot_ctx *);

typedef void (*btf_trace_xhci_configure_endpoint_ctrl_ctx)(void *, struct xhci_input_control_ctx *);

typedef void (*btf_trace_xhci_dbc_alloc_request)(void *, struct dbc_request *);

typedef void (*btf_trace_xhci_dbc_free_request)(void *, struct dbc_request *);

typedef void (*btf_trace_xhci_dbc_gadget_ep_queue)(void *, struct xhci_ring *, struct xhci_generic_trb *, dma_addr_t);

typedef void (*btf_trace_xhci_dbc_giveback_request)(void *, struct dbc_request *);

typedef void (*btf_trace_xhci_dbc_handle_event)(void *, struct xhci_ring *, struct xhci_generic_trb *, dma_addr_t);

typedef void (*btf_trace_xhci_dbc_handle_transfer)(void *, struct xhci_ring *, struct xhci_generic_trb *, dma_addr_t);

typedef void (*btf_trace_xhci_dbc_queue_request)(void *, struct dbc_request *);

typedef void (*btf_trace_xhci_dbg_address)(void *, struct va_format *);

typedef void (*btf_trace_xhci_dbg_cancel_urb)(void *, struct va_format *);

typedef void (*btf_trace_xhci_dbg_context_change)(void *, struct va_format *);

typedef void (*btf_trace_xhci_dbg_init)(void *, struct va_format *);

typedef void (*btf_trace_xhci_dbg_quirks)(void *, struct va_format *);

typedef void (*btf_trace_xhci_dbg_reset_ep)(void *, struct va_format *);

typedef void (*btf_trace_xhci_dbg_ring_expansion)(void *, struct va_format *);

typedef void (*btf_trace_xhci_discover_or_reset_device)(void *, struct xhci_slot_ctx *);

typedef void (*btf_trace_xhci_free_dev)(void *, struct xhci_slot_ctx *);

typedef void (*btf_trace_xhci_free_virt_device)(void *, struct xhci_virt_device *);

typedef void (*btf_trace_xhci_get_port_status)(void *, struct xhci_port *, u32);

typedef void (*btf_trace_xhci_handle_cmd_addr_dev)(void *, struct xhci_slot_ctx *);

typedef void (*btf_trace_xhci_handle_cmd_config_ep)(void *, struct xhci_ep_ctx *);

typedef void (*btf_trace_xhci_handle_cmd_disable_slot)(void *, struct xhci_slot_ctx *);

typedef void (*btf_trace_xhci_handle_cmd_reset_dev)(void *, struct xhci_slot_ctx *);

typedef void (*btf_trace_xhci_handle_cmd_reset_ep)(void *, struct xhci_ep_ctx *);

typedef void (*btf_trace_xhci_handle_cmd_set_deq)(void *, struct xhci_slot_ctx *);

typedef void (*btf_trace_xhci_handle_cmd_set_deq_ep)(void *, struct xhci_ep_ctx *);

typedef void (*btf_trace_xhci_handle_cmd_set_deq_stream)(void *, struct xhci_stream_info *, unsigned int);

typedef void (*btf_trace_xhci_handle_cmd_stop_ep)(void *, struct xhci_ep_ctx *);

typedef void (*btf_trace_xhci_handle_command)(void *, struct xhci_ring *, struct xhci_generic_trb *, dma_addr_t);

typedef void (*btf_trace_xhci_handle_event)(void *, struct xhci_ring *, struct xhci_generic_trb *, dma_addr_t);

typedef void (*btf_trace_xhci_handle_port_status)(void *, struct xhci_port *, u32);

typedef void (*btf_trace_xhci_handle_transfer)(void *, struct xhci_ring *, struct xhci_generic_trb *, dma_addr_t);

typedef void (*btf_trace_xhci_hub_status_data)(void *, struct xhci_port *, u32);

typedef void (*btf_trace_xhci_inc_deq)(void *, struct xhci_ring *);

typedef void (*btf_trace_xhci_inc_enq)(void *, struct xhci_ring *);

typedef void (*btf_trace_xhci_queue_trb)(void *, struct xhci_ring *, struct xhci_generic_trb *, dma_addr_t);

typedef void (*btf_trace_xhci_ring_alloc)(void *, struct xhci_ring *);

typedef void (*btf_trace_xhci_ring_ep_doorbell)(void *, u32, u32);

typedef void (*btf_trace_xhci_ring_expansion)(void *, struct xhci_ring *);

typedef void (*btf_trace_xhci_ring_free)(void *, struct xhci_ring *);

typedef void (*btf_trace_xhci_ring_host_doorbell)(void *, u32, u32);

typedef void (*btf_trace_xhci_setup_addressable_virt_device)(void *, struct xhci_virt_device *);

typedef void (*btf_trace_xhci_setup_device)(void *, struct xhci_virt_device *);

typedef void (*btf_trace_xhci_setup_device_slot)(void *, struct xhci_slot_ctx *);

typedef void (*btf_trace_xhci_stop_device)(void *, struct xhci_virt_device *);

typedef void (*btf_trace_xhci_urb_dequeue)(void *, struct urb *);

typedef void (*btf_trace_xhci_urb_enqueue)(void *, struct urb *);

typedef void (*btf_trace_xhci_urb_giveback)(void *, struct urb *);

typedef void (*btf_trace_xprt_connect)(void *, const struct rpc_xprt *);

typedef void (*btf_trace_xprt_create)(void *, const struct rpc_xprt *);

typedef void (*btf_trace_xprt_destroy)(void *, const struct rpc_xprt *);

typedef void (*btf_trace_xprt_disconnect_auto)(void *, const struct rpc_xprt *);

typedef void (*btf_trace_xprt_disconnect_done)(void *, const struct rpc_xprt *);

typedef void (*btf_trace_xprt_disconnect_force)(void *, const struct rpc_xprt *);

typedef void (*btf_trace_xprt_get_cong)(void *, const struct rpc_xprt *, const struct rpc_task *);

typedef void (*btf_trace_xprt_lookup_rqst)(void *, const struct rpc_xprt *, __be32, int);

typedef void (*btf_trace_xprt_ping)(void *, const struct rpc_xprt *, int);

typedef void (*btf_trace_xprt_put_cong)(void *, const struct rpc_xprt *, const struct rpc_task *);

typedef void (*btf_trace_xprt_release_cong)(void *, const struct rpc_xprt *, const struct rpc_task *);

typedef void (*btf_trace_xprt_release_xprt)(void *, const struct rpc_xprt *, const struct rpc_task *);

typedef void (*btf_trace_xprt_reserve)(void *, const struct rpc_rqst *);

typedef void (*btf_trace_xprt_reserve_cong)(void *, const struct rpc_xprt *, const struct rpc_task *);

typedef void (*btf_trace_xprt_reserve_xprt)(void *, const struct rpc_xprt *, const struct rpc_task *);

typedef void (*btf_trace_xprt_retransmit)(void *, const struct rpc_rqst *);

typedef void (*btf_trace_xprt_timer)(void *, const struct rpc_xprt *, __be32, int);

typedef void (*btf_trace_xprt_transmit)(void *, const struct rpc_rqst *, int);

typedef void (*btf_trace_xs_data_ready)(void *, const struct rpc_xprt *);

typedef void (*btf_trace_xs_stream_read_data)(void *, struct rpc_xprt *, ssize_t, size_t);

typedef void (*btf_trace_xs_stream_read_request)(void *, struct sock_xprt *);

typedef int (*cb_t)(struct param *);

typedef bool (*check_reserved_t)(u64, u64, enum e820_type);

typedef void cleanup_cb_t(struct rq_wait *, void *);

typedef int (*cmp_r_func_t)(const void *, const void *, const void *);

typedef struct sk_buff * (*codel_skb_dequeue_t)(struct codel_vars *, void *);

typedef void (*codel_skb_drop_t)(struct sk_buff *, void *);

typedef u32 (*codel_skb_len_t)(const struct sk_buff *);

typedef codel_time_t (*codel_skb_time_t)(const struct sk_buff *);

typedef void (*companion_fn)(struct pci_dev *, struct usb_hcd *, struct pci_dev *, struct usb_hcd *);

typedef bool (*cond_update_fn_t)(struct trace_array *, void *);

typedef int (*cppc_mode_transition_fn)(int);

typedef void detailed_cb(const struct detailed_timing *, void *);

typedef void * (*devcon_match_fn_t)(const struct fwnode_handle *, const char *, void *);

typedef int (*device_iter_t)(struct device *, void *);

typedef int (*device_match_t)(struct device *, const void *);

typedef int (*dr_match_t)(struct device *, void *, void *);

typedef int drm_ioctl_compat_t(struct file *, unsigned int, long unsigned int);

typedef bool (*drm_vblank_get_scanout_position_func)(struct drm_crtc *, bool, int *, int *, ktime_t *, ktime_t *, const struct drm_display_mode *);

typedef int (*dynevent_check_arg_fn_t)(void *);

typedef int (*efi_memattr_perm_setter)(struct mm_struct *, efi_memory_desc_t *, bool);

typedef void (*ethnl_notify_handler_t)(struct net_device *, unsigned int, const void *);

typedef void (*exitcall_t)(void);

typedef int (*ext4_mballoc_query_range_fn)(struct super_block *, ext4_group_t, ext4_grpblk_t, ext4_grpblk_t, void *);

typedef void ext4_update_sb_callback(struct ext4_super_block *, const void *);

typedef int filler_t(struct file *, struct folio *);

typedef bool (*filter_func_t)(struct uprobe_consumer *, struct mm_struct *);

typedef void fn_handler_fn(struct vc_data *);

typedef const u8 * (*fn_mipi_elem_exec)(struct intel_dsi *, const u8 *);

typedef bool fq_skb_filter_t(struct fq *, struct fq_tin *, struct fq_flow *, struct sk_buff *, void *);

typedef void fq_skb_free_t(struct fq *, struct fq_tin *, struct fq_flow *, struct sk_buff *);

typedef struct sk_buff *fq_tin_dequeue_t(struct fq *, struct fq_tin *, struct fq_flow *);

typedef void free_folio_t(struct folio *, long unsigned int);

typedef struct sk_buff * (*gro_receive_sk_t)(struct sock *, struct list_head *, struct sk_buff *);

typedef struct sk_buff * (*gro_receive_t)(struct list_head *, struct sk_buff *);

typedef int (*hda_codec_patch_t)(struct hda_codec *);

typedef bool (*hid_usage_cmp_t)(struct hid_usage *, unsigned int, unsigned int);

typedef u32 (*hotplug_enables_func)(struct intel_encoder *);

typedef u32 (*hotplug_mask_func)(enum hpd_pin);

typedef bool (*i8042_filter_t)(unsigned char, unsigned char, struct serio *, void *);

typedef int (*i915_user_extension_fn)(struct i915_user_extension *, void *);

typedef u32 inet6_ehashfn_t(const struct net *, const struct in6_addr *, const u16, const struct in6_addr *, const __be16);

typedef u32 inet_ehashfn_t(const struct net *, const __be32, const __u16, const __be32, const __be16);

typedef int (*initxattrs)(struct inode *, const struct xattr *, void *);

typedef struct dentry *instantiate_t(struct dentry *, struct task_struct *, const void *);

typedef int (*ioctl_fn)(struct file *, struct autofs_sb_info *, struct autofs_dev_ioctl *);

typedef int (*ioctl_fn___2)(struct file *, struct dm_ioctl *, size_t);

typedef void (*iomap_punch_t)(struct inode *, loff_t, loff_t, struct iomap *);

typedef size_t (*iov_step_f)(void *, size_t, size_t, void *, void *);

typedef size_t (*iov_ustep_f)(void *, size_t, size_t, void *, void *);

typedef void ip6_icmp_send_t(struct sk_buff *, u8, u8, __u32, const struct in6_addr *, const struct inet6_skb_parm *);

typedef void (*irq_write_msi_msg_t)(struct msi_desc *, struct msi_msg *);

typedef void k_handler_fn(struct vc_data *, unsigned char, char);

typedef int (*list_cmp_func_t)(void *, const struct list_head *, const struct list_head *);

typedef enum lru_status (*list_lru_walk_cb)(struct list_head *, struct list_lru_one *, void *);

typedef int (*map_follower_func_t)(struct hda_codec *, void *, struct snd_kcontrol *);

typedef void (*move_fn_t)(struct lruvec *, struct folio *);

typedef int (*netlink_filter_fn)(struct sock *, struct sk_buff *, void *);

typedef struct folio *new_folio_t(struct folio *, long unsigned int);

typedef int (*nlm_host_match_fn_t)(void *, struct nlm_host *);

typedef void (*nmi_shootdown_cb)(int, struct pt_regs *);

typedef struct ns_common *ns_get_path_helper_t(void *);

typedef int (*objpool_init_obj_cb)(void *, void *);

typedef int (*parse_pred_fn)(const char *, void *, int, struct filter_parse_error *, struct filter_pred **);

typedef int (*parse_unknown_fn)(char *, char *, const char *, void *);

typedef int (*pcie_callback_t)(struct pcie_device *);

typedef int (*pcm_transfer_f)(struct snd_pcm_substream *, int, long unsigned int, struct iov_iter *, long unsigned int);

typedef int (*pcm_copy_f)(struct snd_pcm_substream *, snd_pcm_uframes_t, void *, snd_pcm_uframes_t, snd_pcm_uframes_t, pcm_transfer_f, bool);

typedef int pcpu_fc_cpu_distance_fn_t(unsigned int, unsigned int);

typedef int pcpu_fc_cpu_to_node_fn_t(int);

typedef void perf_iterate_f(struct perf_event *, void *);

typedef int perf_snapshot_branch_stack_t(struct perf_branch_entry *, unsigned int);

typedef int (*pm_callback_t)(struct device *);

typedef int (*pm_cpu_match_t)(const struct x86_cpu_id *);

typedef struct rt6_info * (*pol_lookup_t)(struct net *, struct fib6_table *, struct flowi6 *, const struct sk_buff *, int);

typedef int (*pp_nl_fill_cb)(struct sk_buff *, const struct page_pool *, const struct genl_info *);

typedef bool (*pps_check)(struct intel_display *, int);

typedef int (*proc_visitor)(struct task_struct *, void *);

typedef int (*pte_fn_t)(pte_t *, long unsigned int, void *);

typedef int read_block_fn(void *, u8 *, unsigned int, size_t);

typedef long unsigned int relocate_kernel_fn(long unsigned int, long unsigned int, long unsigned int, unsigned int, unsigned int);

typedef int (*reset_func)(struct intel_gt *, intel_engine_mask_t, unsigned int);

typedef void (*rethook_handler_t)(struct rethook_node *, void *, long unsigned int, struct pt_regs *);

typedef bool (*ring_buffer_cond_fn)(void *);

typedef void (*rpc_action)(struct rpc_task *);

typedef irqreturn_t (*rtc_irq_handler)(int, void *);

typedef void (*rtl_generic_fct)(struct rtl8169_private *);

typedef void (*rtl_phy_cfg_fct)(struct rtl8169_private *, struct phy_device *);

typedef bool (*sb_for_each_fn)(struct sbitmap *, unsigned int, void *);

typedef int (*sendmsg_func)(struct sock *, struct msghdr *);

typedef void (*serial8250_isa_config_fn)(int, struct uart_port *, u32 *);

typedef int (*set_callee_state_fn)(struct bpf_verifier_env *, struct bpf_func_state *, struct bpf_func_state *, int);

typedef void (*set_debug_port_t)(int);

typedef void (*setup_fn)(struct perf_event *, struct pt_regs *, void *, struct perf_sample_data *, struct pt_regs *);

typedef struct scatterlist *sg_alloc_fn(unsigned int, gfp_t);

typedef void sg_free_fn(struct scatterlist *, unsigned int);

typedef void sha256_block_fn(struct sha256_state *, const u8 *, int);

typedef void sha512_block_fn(struct sha512_state *, const u8 *, int);

typedef bool (*smp_cond_func_t)(int, void *);

typedef int (*snd_seq_dump_func_t)(void *, void *, int);

typedef int splice_actor(struct pipe_inode_info *, struct pipe_buffer *, struct splice_desc *);

typedef int splice_direct_actor(struct pipe_inode_info *, struct splice_desc *);

typedef bool (*stack_trace_consume_fn)(void *, long unsigned int);

typedef void (*swap_r_func_t)(void *, void *, int, const void *);

typedef long int (*sys_call_ptr_t)(const struct pt_regs *);

typedef int (*task_call_f)(struct task_struct *, void *);

typedef void (*task_work_func_t)(struct callback_head *);

typedef void text_poke_f(void *, const void *, size_t);

typedef int (*tg_visitor)(struct task_group *, void *);

typedef struct sock * (*udp_lookup_t)(const struct sk_buff *, __be16, __be16);

typedef bool (*up_f)(struct tmigr_group *, struct tmigr_group *, struct tmigr_walk *);

typedef void (*vlv_dsi_dmi_quirk_func)(struct intel_dsi *);

typedef u32 * (*wa_bb_func_t)(struct intel_engine_cs *, u32 *);

typedef int wait_bit_action_f(struct wait_bit_key *, int);

typedef int (*writepage_t)(struct folio *, struct writeback_control *, void *);

typedef size_t (*xdr_skb_read_actor)(struct xdr_skb_reader *, void *, size_t);

typedef void (*xhci_get_quirks_t)(struct device *, struct xhci_hcd *);

typedef struct rpc_xprt * (*xprt_switch_find_xprt_t)(struct rpc_xprt_switch *, const struct rpc_xprt *);

struct net_bridge;

struct nf_bridge_frag_data;

struct bpf_iter;

struct creds;

struct fscrypt_inode_info;

struct fsverity_info;

struct virtio_gpu_command;


/* BPF kfuncs */
#ifndef BPF_NO_KFUNC_PROTOTYPES
extern void *bpf_arena_alloc_pages(void *p__map, void *addr__ign, u32 page_cnt, int node_id, u64 flags) __weak __ksym;
extern void bpf_arena_free_pages(void *p__map, void *ptr__ign, u32 page_cnt) __weak __ksym;
extern __bpf_fastcall void *bpf_cast_to_kern_ctx(void *obj) __weak __ksym;
extern struct cgroup *bpf_cgroup_acquire(struct cgroup *cgrp) __weak __ksym;
extern struct cgroup *bpf_cgroup_ancestor(struct cgroup *cgrp, int level) __weak __ksym;
extern struct cgroup *bpf_cgroup_from_id(u64 cgid) __weak __ksym;
extern void bpf_cgroup_release(struct cgroup *cgrp) __weak __ksym;
extern int bpf_copy_from_user_str(void *dst, u32 dst__sz, const void *unsafe_ptr__ign, u64 flags) __weak __ksym;
extern struct bpf_crypto_ctx *bpf_crypto_ctx_acquire(struct bpf_crypto_ctx *ctx) __weak __ksym;
extern struct bpf_crypto_ctx *bpf_crypto_ctx_create(const struct bpf_crypto_params *params, u32 params__sz, int *err) __weak __ksym;
extern void bpf_crypto_ctx_release(struct bpf_crypto_ctx *ctx) __weak __ksym;
extern int bpf_crypto_decrypt(struct bpf_crypto_ctx *ctx, const struct bpf_dynptr *src, const struct bpf_dynptr *dst, const struct bpf_dynptr *siv__nullable) __weak __ksym;
extern int bpf_crypto_encrypt(struct bpf_crypto_ctx *ctx, const struct bpf_dynptr *src, const struct bpf_dynptr *dst, const struct bpf_dynptr *siv__nullable) __weak __ksym;
extern int bpf_ct_change_status(struct nf_conn *nfct, u32 status) __weak __ksym;
extern int bpf_ct_change_timeout(struct nf_conn *nfct, u32 timeout) __weak __ksym;
extern struct nf_conn *bpf_ct_insert_entry(struct nf_conn___init *nfct_i) __weak __ksym;
extern void bpf_ct_release(struct nf_conn *nfct) __weak __ksym;
extern int bpf_ct_set_nat_info(struct nf_conn___init *nfct, union nf_inet_addr *addr, int port, enum nf_nat_manip_type manip) __weak __ksym;
extern int bpf_ct_set_status(const struct nf_conn___init *nfct, u32 status) __weak __ksym;
extern void bpf_ct_set_timeout(struct nf_conn___init *nfct, u32 timeout) __weak __ksym;
extern int bpf_dynptr_adjust(const struct bpf_dynptr *p, u32 start, u32 end) __weak __ksym;
extern int bpf_dynptr_clone(const struct bpf_dynptr *p, struct bpf_dynptr *clone__uninit) __weak __ksym;
extern int bpf_dynptr_from_skb(struct __sk_buff *s, u64 flags, struct bpf_dynptr *ptr__uninit) __weak __ksym;
extern int bpf_dynptr_from_xdp(struct xdp_md *x, u64 flags, struct bpf_dynptr *ptr__uninit) __weak __ksym;
extern bool bpf_dynptr_is_null(const struct bpf_dynptr *p) __weak __ksym;
extern bool bpf_dynptr_is_rdonly(const struct bpf_dynptr *p) __weak __ksym;
extern __u32 bpf_dynptr_size(const struct bpf_dynptr *p) __weak __ksym;
extern void *bpf_dynptr_slice(const struct bpf_dynptr *p, u32 offset, void *buffer__opt, u32 buffer__szk) __weak __ksym;
extern void *bpf_dynptr_slice_rdwr(const struct bpf_dynptr *p, u32 offset, void *buffer__opt, u32 buffer__szk) __weak __ksym;
extern int bpf_fentry_test1(int a) __weak __ksym;
extern struct kmem_cache *bpf_get_kmem_cache(u64 addr) __weak __ksym;
extern void bpf_iter_bits_destroy(struct bpf_iter_bits *it) __weak __ksym;
extern int bpf_iter_bits_new(struct bpf_iter_bits *it, const u64 *unsafe_ptr__ign, u32 nr_words) __weak __ksym;
extern int *bpf_iter_bits_next(struct bpf_iter_bits *it) __weak __ksym;
extern void bpf_iter_css_destroy(struct bpf_iter_css *it) __weak __ksym;
extern int bpf_iter_css_new(struct bpf_iter_css *it, struct cgroup_subsys_state *start, unsigned int flags) __weak __ksym;
extern struct cgroup_subsys_state *bpf_iter_css_next(struct bpf_iter_css *it) __weak __ksym;
extern void bpf_iter_css_task_destroy(struct bpf_iter_css_task *it) __weak __ksym;
extern int bpf_iter_css_task_new(struct bpf_iter_css_task *it, struct cgroup_subsys_state *css, unsigned int flags) __weak __ksym;
extern struct task_struct *bpf_iter_css_task_next(struct bpf_iter_css_task *it) __weak __ksym;
extern void bpf_iter_kmem_cache_destroy(struct bpf_iter_kmem_cache *it) __weak __ksym;
extern int bpf_iter_kmem_cache_new(struct bpf_iter_kmem_cache *it) __weak __ksym;
extern struct kmem_cache *bpf_iter_kmem_cache_next(struct bpf_iter_kmem_cache *it) __weak __ksym;
extern void bpf_iter_num_destroy(struct bpf_iter_num *it) __weak __ksym;
extern int bpf_iter_num_new(struct bpf_iter_num *it, int start, int end) __weak __ksym;
extern int *bpf_iter_num_next(struct bpf_iter_num *it) __weak __ksym;
extern void bpf_iter_task_destroy(struct bpf_iter_task *it) __weak __ksym;
extern int bpf_iter_task_new(struct bpf_iter_task *it, struct task_struct *task__nullable, unsigned int flags) __weak __ksym;
extern struct task_struct *bpf_iter_task_next(struct bpf_iter_task *it) __weak __ksym;
extern void bpf_iter_task_vma_destroy(struct bpf_iter_task_vma *it) __weak __ksym;
extern int bpf_iter_task_vma_new(struct bpf_iter_task_vma *it, struct task_struct *task, u64 addr) __weak __ksym;
extern struct vm_area_struct *bpf_iter_task_vma_next(struct bpf_iter_task_vma *it) __weak __ksym;
extern void bpf_key_put(struct bpf_key *bkey) __weak __ksym;
extern void bpf_kfunc_call_memb_release(struct prog_test_member *p) __weak __ksym;
extern void bpf_kfunc_call_test_release(struct prog_test_ref_kfunc *p) __weak __ksym;
extern struct bpf_list_node *bpf_list_pop_back(struct bpf_list_head *head) __weak __ksym;
extern struct bpf_list_node *bpf_list_pop_front(struct bpf_list_head *head) __weak __ksym;
extern int bpf_list_push_back_impl(struct bpf_list_head *head, struct bpf_list_node *node, void *meta__ign, u64 off) __weak __ksym;
extern int bpf_list_push_front_impl(struct bpf_list_head *head, struct bpf_list_node *node, void *meta__ign, u64 off) __weak __ksym;
extern void bpf_local_irq_restore(long unsigned int *flags__irq_flag) __weak __ksym;
extern void bpf_local_irq_save(long unsigned int *flags__irq_flag) __weak __ksym;
extern struct bpf_key *bpf_lookup_system_key(u64 id) __weak __ksym;
extern struct bpf_key *bpf_lookup_user_key(u32 serial, u64 flags) __weak __ksym;
extern s64 bpf_map_sum_elem_count(const struct bpf_map *map) __weak __ksym;
extern int bpf_modify_return_test(int a, int *b) __weak __ksym;
extern int bpf_modify_return_test2(int a, int *b, short int c, int d, void *e, char f, int g) __weak __ksym;
extern int bpf_modify_return_test_tp(int nonce) __weak __ksym;
extern void bpf_obj_drop_impl(void *p__alloc, void *meta__ign) __weak __ksym;
extern void *bpf_obj_new_impl(u64 local_type_id__k, void *meta__ign) __weak __ksym;
extern void bpf_percpu_obj_drop_impl(void *p__alloc, void *meta__ign) __weak __ksym;
extern void *bpf_percpu_obj_new_impl(u64 local_type_id__k, void *meta__ign) __weak __ksym;
extern void bpf_preempt_disable(void) __weak __ksym;
extern void bpf_preempt_enable(void) __weak __ksym;
extern int bpf_rbtree_add_impl(struct bpf_rb_root *root, struct bpf_rb_node *node, bool (*less)(struct bpf_rb_node *, const struct bpf_rb_node *), void *meta__ign, u64 off) __weak __ksym;
extern struct bpf_rb_node *bpf_rbtree_first(struct bpf_rb_root *root) __weak __ksym;
extern struct bpf_rb_node *bpf_rbtree_remove(struct bpf_rb_root *root, struct bpf_rb_node *node) __weak __ksym;
extern void bpf_rcu_read_lock(void) __weak __ksym;
extern void bpf_rcu_read_unlock(void) __weak __ksym;
extern __bpf_fastcall void *bpf_rdonly_cast(const void *obj__ign, u32 btf_id__k) __weak __ksym;
extern void *bpf_refcount_acquire_impl(void *p__refcounted_kptr, void *meta__ign) __weak __ksym;
extern int bpf_send_signal_task(struct task_struct *task, int sig, enum pid_type type, u64 value) __weak __ksym;
extern __u64 *bpf_session_cookie(void) __weak __ksym;
extern bool bpf_session_is_return(void) __weak __ksym;
extern int bpf_sk_assign_tcp_reqsk(struct __sk_buff *s, struct sock *sk, struct bpf_tcp_req_attrs *attrs, int attrs__sz) __weak __ksym;
extern struct nf_conn___init *bpf_skb_ct_alloc(struct __sk_buff *skb_ctx, struct bpf_sock_tuple *bpf_tuple, u32 tuple__sz, struct bpf_ct_opts *opts, u32 opts__sz) __weak __ksym;
extern struct nf_conn *bpf_skb_ct_lookup(struct __sk_buff *skb_ctx, struct bpf_sock_tuple *bpf_tuple, u32 tuple__sz, struct bpf_ct_opts *opts, u32 opts__sz) __weak __ksym;
extern int bpf_sock_addr_set_sun_path(struct bpf_sock_addr_kern *sa_kern, const u8 *sun_path, u32 sun_path__sz) __weak __ksym;
extern int bpf_sock_destroy(struct sock_common *sock) __weak __ksym;
extern struct task_struct *bpf_task_acquire(struct task_struct *p) __weak __ksym;
extern struct task_struct *bpf_task_from_pid(s32 pid) __weak __ksym;
extern struct task_struct *bpf_task_from_vpid(s32 vpid) __weak __ksym;
extern struct cgroup *bpf_task_get_cgroup1(struct task_struct *task, int hierarchy_id) __weak __ksym;
extern void bpf_task_release(struct task_struct *p) __weak __ksym;
extern long int bpf_task_under_cgroup(struct task_struct *task, struct cgroup *ancestor) __weak __ksym;
extern void bpf_throw(u64 cookie) __weak __ksym;
extern int bpf_verify_pkcs7_signature(struct bpf_dynptr *data_p, struct bpf_dynptr *sig_p, struct bpf_key *trusted_keyring) __weak __ksym;
extern int bpf_wq_init(struct bpf_wq *wq, void *p__map, unsigned int flags) __weak __ksym;
extern int bpf_wq_set_callback_impl(struct bpf_wq *wq, int (*callback_fn)(void *, int *, void *), unsigned int flags, void *aux__ign) __weak __ksym;
extern int bpf_wq_start(struct bpf_wq *wq, unsigned int flags) __weak __ksym;
extern struct nf_conn___init *bpf_xdp_ct_alloc(struct xdp_md *xdp_ctx, struct bpf_sock_tuple *bpf_tuple, u32 tuple__sz, struct bpf_ct_opts *opts, u32 opts__sz) __weak __ksym;
extern struct nf_conn *bpf_xdp_ct_lookup(struct xdp_md *xdp_ctx, struct bpf_sock_tuple *bpf_tuple, u32 tuple__sz, struct bpf_ct_opts *opts, u32 opts__sz) __weak __ksym;
extern struct xfrm_state *bpf_xdp_get_xfrm_state(struct xdp_md *ctx, struct bpf_xfrm_state_opts *opts, u32 opts__sz) __weak __ksym;
extern int bpf_xdp_metadata_rx_hash(const struct xdp_md *ctx, u32 *hash, enum xdp_rss_hash_type *rss_type) __weak __ksym;
extern int bpf_xdp_metadata_rx_timestamp(const struct xdp_md *ctx, u64 *timestamp) __weak __ksym;
extern int bpf_xdp_metadata_rx_vlan_tag(const struct xdp_md *ctx, __be16 *vlan_proto, u16 *vlan_tci) __weak __ksym;
extern void bpf_xdp_xfrm_state_release(struct xfrm_state *x) __weak __ksym;
extern void cgroup_rstat_flush(struct cgroup *cgrp) __weak __ksym;
extern void cgroup_rstat_updated(struct cgroup *cgrp, int cpu) __weak __ksym;
extern void crash_kexec(struct pt_regs *regs) __weak __ksym;
extern void cubictcp_acked(struct sock *sk, const struct ack_sample *sample) __weak __ksym;
extern void cubictcp_cong_avoid(struct sock *sk, u32 ack, u32 acked) __weak __ksym;
extern void cubictcp_cwnd_event(struct sock *sk, enum tcp_ca_event event) __weak __ksym;
extern void cubictcp_init(struct sock *sk) __weak __ksym;
extern u32 cubictcp_recalc_ssthresh(struct sock *sk) __weak __ksym;
extern void cubictcp_state(struct sock *sk, u8 new_state) __weak __ksym;
#endif

#ifndef BPF_NO_PRESERVE_ACCESS_INDEX
#pragma clang attribute pop
#endif

#endif /* __VMLINUX_H__ */
